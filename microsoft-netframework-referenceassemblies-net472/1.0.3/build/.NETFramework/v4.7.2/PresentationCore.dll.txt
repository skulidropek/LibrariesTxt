[NativeCppClassAttribute]
internal class __type_info_node : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class _BY_HANDLE_FILE_INFORMATION : ValueType {
}
[NativeCppClassAttribute]
internal class _EXCEPTION_POINTERS : ValueType {
}
[NativeCppClassAttribute]
internal class _FILETIME : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class _GUID : ValueType {
}
[NativeCppClassAttribute]
internal class _SECURITY_ATTRIBUTES : ValueType {
}
internal class $VCls$0000000080 : ValueType {
}
[NativeCppClassAttribute]
internal class CModuleInitialize : ValueType {
}
[NativeCppClassAttribute]
internal class gcroot<System::String ^> : ValueType {
}
[NativeCppClassAttribute]
internal class HINSTANCE__ : ValueType {
}
[NativeCppClassAttribute]
internal class HKEY__ : ValueType {
}
internal class MS.Internal.AbbreviatedGeometryParser : object {
    internal void ParseToGeometryContext(StreamGeometryContext context, string pathString, int startIndex);
}
internal static class MS.Internal.AppDomainShutdownMonitor : object {
    private static AppDomainShutdownMonitor();
    public static void Add(WeakReference listener);
    public static void Remove(WeakReference listener);
}
internal static class MS.Internal.AppModel.CookieHandler : object {
    internal static void HandleWebRequest(WebRequest request);
    [SecurityCriticalAttribute]
internal static void HandleWebResponse(WebResponse response);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static string GetCookie(Uri uri, bool throwIfNoCookie);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static bool SetCookie(Uri uri, string cookieData);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.AppModel.CustomCredentialPolicy : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static CustomCredentialPolicy();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void EnsureCustomCredentialPolicy();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static SecurityZone MapUrlToZone(Uri uri);
}
internal class MS.Internal.AppModel.SiteOfOriginContainer : Package {
    internal static BooleanSwitch _traceSwitch;
    internal static Uri SiteOfOrigin { get; }
    internal static Uri SiteOfOriginForClickOnceApp { get; }
    internal static Uri BrowserSource { get; internal set; }
    internal static bool TraceSwitchEnabled { get; internal set; }
    private static SiteOfOriginContainer();
    [FriendAccessAllowedAttribute]
internal static Uri get_SiteOfOrigin();
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Uri get_SiteOfOriginForClickOnceApp();
    internal static Uri get_BrowserSource();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static void set_BrowserSource(Uri value);
    public virtual bool PartExists(Uri uri);
    internal static bool get_TraceSwitchEnabled();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void set_TraceSwitchEnabled(bool value);
    protected virtual PackagePart GetPartCore(Uri uri);
    protected virtual PackagePart CreatePartCore(Uri uri, string contentType, CompressionOption compressionOption);
    protected virtual void DeletePartCore(Uri uri);
    protected virtual PackagePart[] GetPartsCore();
    protected virtual void FlushCore();
}
internal class MS.Internal.AppModel.SiteOfOriginPart : PackagePart {
    internal SiteOfOriginPart(Package container, Uri uri);
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
}
internal class MS.Internal.Automation.AutomationPatternInfo : object {
    internal AutomationPattern ID { get; }
    internal WrapObject WcpWrapper { get; }
    internal AutomationPatternInfo(AutomationPattern id, WrapObject wcpWrapper);
    internal AutomationPattern get_ID();
    internal WrapObject get_WcpWrapper();
}
internal class MS.Internal.Automation.AutomationPropertyInfo : object {
    internal AutomationProperty ID { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal DependencyProperty OverrideDP { get; }
    internal AutomationPropertyInfo(AutomationProperty id, DependencyProperty dependencyProperty, DependencyProperty overrideDP);
    internal AutomationProperty get_ID();
    internal DependencyProperty get_DependencyProperty();
    internal DependencyProperty get_OverrideDP();
}
internal class MS.Internal.Automation.DockProviderWrapper : MarshalByRefObject {
    public DockPosition DockPosition { get; }
    public sealed virtual void SetDockPosition(DockPosition dockPosition);
    public sealed virtual DockPosition get_DockPosition();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.ElementProxy : object {
    public ProviderOptions ProviderOptions { get; }
    public IRawElementProviderSimple HostRawElementProvider { get; }
    public Rect BoundingRectangle { get; }
    public IRawElementProviderFragmentRoot FragmentRoot { get; }
    internal AutomationPeer Peer { get; }
    internal static ReferenceType AutomationInteropReferenceType { get; }
    private static ElementProxy();
    public sealed virtual object GetPatternProvider(int pattern);
    public sealed virtual object GetPropertyValue(int property);
    public sealed virtual ProviderOptions get_ProviderOptions();
    public sealed virtual IRawElementProviderSimple get_HostRawElementProvider();
    public sealed virtual IRawElementProviderFragment Navigate(NavigateDirection direction);
    public sealed virtual Int32[] GetRuntimeId();
    public sealed virtual Rect get_BoundingRectangle();
    public sealed virtual IRawElementProviderSimple[] GetEmbeddedFragmentRoots();
    public sealed virtual void SetFocus();
    public sealed virtual IRawElementProviderFragmentRoot get_FragmentRoot();
    public sealed virtual IRawElementProviderFragment ElementProviderFromPoint(double x, double y);
    public sealed virtual IRawElementProviderFragment GetFocus();
    public sealed virtual void AdviseEventAdded(int eventID, Int32[] properties);
    public sealed virtual void AdviseEventRemoved(int eventID, Int32[] properties);
    internal static ElementProxy StaticWrap(AutomationPeer peer, AutomationPeer referencePeer);
    internal AutomationPeer get_Peer();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static ReferenceType get_AutomationInteropReferenceType();
}
internal class MS.Internal.Automation.ElementUtil : object {
    internal static Visual GetParent(Visual el);
    internal static Visual GetFirstChild(Visual el);
    internal static Visual GetLastChild(Visual el);
    internal static Visual GetNextSibling(Visual el);
    internal static Visual GetPreviousSibling(Visual el);
    internal static Visual GetRoot(Visual el);
    internal static Rect GetLocalRect(UIElement element);
    internal static Rect GetScreenRect(IntPtr hwnd, UIElement el);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Visual GetElementFromPoint(IntPtr hwnd, Visual root, Point pointScreen);
    internal static void CheckEnabled(Visual visual);
    internal static object Invoke(AutomationPeer peer, DispatcherOperationCallback work, object arg);
}
internal static class MS.Internal.Automation.EventMap : object {
    private static EventMap();
    internal static void AddEvent(int idEvent);
    internal static void RemoveEvent(int idEvent);
    internal static bool HasRegisteredEvent(AutomationEvents eventId);
    internal static AutomationEvent GetRegisteredEvent(AutomationEvents eventId);
}
internal class MS.Internal.Automation.EventPropertyMap : object {
    private static EventPropertyMap();
    internal static bool IsInterestingDP(DependencyProperty dp);
    internal static bool AddPropertyNotify(DependencyProperty[] properties);
    internal static bool RemovePropertyNotify(DependencyProperty[] properties);
}
internal class MS.Internal.Automation.ExpandCollapseProviderWrapper : MarshalByRefObject {
    public ExpandCollapseState ExpandCollapseState { get; }
    public sealed virtual void Expand();
    public sealed virtual void Collapse();
    public sealed virtual ExpandCollapseState get_ExpandCollapseState();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.GridItemProviderWrapper : MarshalByRefObject {
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public IRawElementProviderSimple ContainingGrid { get; }
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
    public sealed virtual IRawElementProviderSimple get_ContainingGrid();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.GridProviderWrapper : MarshalByRefObject {
    public int RowCount { get; }
    public int ColumnCount { get; }
    public sealed virtual IRawElementProviderSimple GetItem(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
    internal static object Wrap(AutomationPeer peer, object iface);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Automation.InteropAutomationProvider : object {
    private ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.ProviderOptions { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.HostRawElementProvider { get; }
    private Rect System.Windows.Automation.Provider.IRawElementProviderFragment.BoundingRectangle { get; }
    private IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.FragmentRoot { get; }
    internal InteropAutomationProvider(HostedWindowWrapper wrapper, AutomationPeer parent);
    private sealed virtual override ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.get_ProviderOptions();
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPatternProvider(int patternId);
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPropertyValue(int propertyId);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.get_HostRawElementProvider();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragment.Navigate(NavigateDirection direction);
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetRuntimeId();
    private sealed virtual override Rect System.Windows.Automation.Provider.IRawElementProviderFragment.get_BoundingRectangle();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetEmbeddedFragmentRoots();
    private sealed virtual override void System.Windows.Automation.Provider.IRawElementProviderFragment.SetFocus();
    private sealed virtual override IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.get_FragmentRoot();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.ElementProviderFromPoint(double x, double y);
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.GetFocus();
}
internal class MS.Internal.Automation.InvokeProviderWrapper : MarshalByRefObject {
    public sealed virtual void Invoke();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.ItemContainerProviderWrapper : MarshalByRefObject {
    public sealed virtual IRawElementProviderSimple FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.MultipleViewProviderWrapper : MarshalByRefObject {
    public int CurrentView { get; }
    public sealed virtual string GetViewName(int viewID);
    public sealed virtual void SetCurrentView(int viewID);
    public sealed virtual int get_CurrentView();
    public sealed virtual Int32[] GetSupportedViews();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.RangeValueProviderWrapper : MarshalByRefObject {
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Maximum { get; }
    public double Minimum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public sealed virtual void SetValue(double val);
    public sealed virtual double get_Value();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_LargeChange();
    public sealed virtual double get_SmallChange();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.ScrollItemProviderWrapper : MarshalByRefObject {
    public sealed virtual void ScrollIntoView();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.ScrollProviderWrapper : MarshalByRefObject {
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    public sealed virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public sealed virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public sealed virtual double get_HorizontalScrollPercent();
    public sealed virtual double get_VerticalScrollPercent();
    public sealed virtual double get_HorizontalViewSize();
    public sealed virtual double get_VerticalViewSize();
    public sealed virtual bool get_HorizontallyScrollable();
    public sealed virtual bool get_VerticallyScrollable();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.SelectionItemProviderWrapper : MarshalByRefObject {
    public bool IsSelected { get; }
    public IRawElementProviderSimple SelectionContainer { get; }
    public sealed virtual void Select();
    public sealed virtual void AddToSelection();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual bool get_IsSelected();
    public sealed virtual IRawElementProviderSimple get_SelectionContainer();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.SelectionProviderWrapper : MarshalByRefObject {
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public sealed virtual IRawElementProviderSimple[] GetSelection();
    public sealed virtual bool get_CanSelectMultiple();
    public sealed virtual bool get_IsSelectionRequired();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.SynchronizedInputAdaptor : object {
    internal SynchronizedInputAdaptor(DependencyObject owner);
    private sealed virtual override void System.Windows.Automation.Provider.ISynchronizedInputProvider.StartListening(SynchronizedInputType inputType);
    private sealed virtual override void System.Windows.Automation.Provider.ISynchronizedInputProvider.Cancel();
}
internal class MS.Internal.Automation.SynchronizedInputProviderWrapper : MarshalByRefObject {
    public sealed virtual void StartListening(SynchronizedInputType inputType);
    public sealed virtual void Cancel();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.TableItemProviderWrapper : MarshalByRefObject {
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public IRawElementProviderSimple ContainingGrid { get; }
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
    public sealed virtual IRawElementProviderSimple get_ContainingGrid();
    public sealed virtual IRawElementProviderSimple[] GetRowHeaderItems();
    public sealed virtual IRawElementProviderSimple[] GetColumnHeaderItems();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.TableProviderWrapper : MarshalByRefObject {
    public int RowCount { get; }
    public int ColumnCount { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    public sealed virtual IRawElementProviderSimple GetItem(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
    public sealed virtual IRawElementProviderSimple[] GetRowHeaders();
    public sealed virtual IRawElementProviderSimple[] GetColumnHeaders();
    public sealed virtual RowOrColumnMajor get_RowOrColumnMajor();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.TextProviderWrapper : MarshalByRefObject {
    public ITextRangeProvider DocumentRange { get; }
    public SupportedTextSelection SupportedTextSelection { get; }
    public sealed virtual ITextRangeProvider[] GetSelection();
    public sealed virtual ITextRangeProvider[] GetVisibleRanges();
    public sealed virtual ITextRangeProvider RangeFromChild(IRawElementProviderSimple childElement);
    public sealed virtual ITextRangeProvider RangeFromPoint(Point screenLocation);
    public sealed virtual ITextRangeProvider get_DocumentRange();
    public sealed virtual SupportedTextSelection get_SupportedTextSelection();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.TextRangeProviderWrapper : MarshalByRefObject {
    internal TextRangeProviderWrapper(AutomationPeer peer, ITextRangeProvider iface);
    public sealed virtual ITextRangeProvider Clone();
    public sealed virtual bool Compare(ITextRangeProvider range);
    public sealed virtual int CompareEndpoints(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    public sealed virtual void ExpandToEnclosingUnit(TextUnit unit);
    public sealed virtual ITextRangeProvider FindAttribute(int attribute, object val, bool backward);
    public sealed virtual ITextRangeProvider FindText(string text, bool backward, bool ignoreCase);
    public sealed virtual object GetAttributeValue(int attribute);
    public sealed virtual Double[] GetBoundingRectangles();
    public sealed virtual IRawElementProviderSimple GetEnclosingElement();
    public sealed virtual string GetText(int maxLength);
    public sealed virtual int Move(TextUnit unit, int count);
    public sealed virtual int MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    public sealed virtual void MoveEndpointByRange(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    public sealed virtual void Select();
    public sealed virtual void AddToSelection();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual void ScrollIntoView(bool alignToTop);
    public sealed virtual IRawElementProviderSimple[] GetChildren();
    internal static ITextRangeProvider WrapArgument(ITextRangeProvider argument, AutomationPeer peer);
    internal static ITextRangeProvider[] WrapArgument(ITextRangeProvider[] argument, AutomationPeer peer);
    internal static ITextRangeProvider UnwrapArgument(ITextRangeProvider argument);
}
internal class MS.Internal.Automation.ToggleProviderWrapper : MarshalByRefObject {
    public ToggleState ToggleState { get; }
    public sealed virtual void Toggle();
    public sealed virtual ToggleState get_ToggleState();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.TransformProviderWrapper : MarshalByRefObject {
    public bool CanMove { get; }
    public bool CanResize { get; }
    public bool CanRotate { get; }
    public sealed virtual void Move(double x, double y);
    public sealed virtual void Resize(double width, double height);
    public sealed virtual void Rotate(double degrees);
    public sealed virtual bool get_CanMove();
    public sealed virtual bool get_CanResize();
    public sealed virtual bool get_CanRotate();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.ValueProviderWrapper : MarshalByRefObject {
    public string Value { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void SetValue(string val);
    public sealed virtual string get_Value();
    public sealed virtual bool get_IsReadOnly();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.VirtualizedItemProviderWrapper : MarshalByRefObject {
    public sealed virtual void Realize();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.WindowProviderWrapper : MarshalByRefObject {
    public bool Maximizable { get; }
    public bool Minimizable { get; }
    public bool IsModal { get; }
    public WindowVisualState VisualState { get; }
    public WindowInteractionState InteractionState { get; }
    public bool IsTopmost { get; }
    public sealed virtual void SetVisualState(WindowVisualState state);
    public sealed virtual void Close();
    public sealed virtual bool WaitForInputIdle(int milliseconds);
    public sealed virtual bool get_Maximizable();
    public sealed virtual bool get_Minimizable();
    public sealed virtual bool get_IsModal();
    public sealed virtual WindowVisualState get_VisualState();
    public sealed virtual WindowInteractionState get_InteractionState();
    public sealed virtual bool get_IsTopmost();
    internal static object Wrap(AutomationPeer peer, object iface);
}
internal class MS.Internal.Automation.WrapObject : MulticastDelegate {
    public WrapObject(object object, IntPtr method);
    public virtual object Invoke(AutomationPeer peer, object iface, IntPtr hwnd);
    public virtual IAsyncResult BeginInvoke(AutomationPeer peer, object iface, IntPtr hwnd, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class MS.Internal.CharacterAttribute : ValueType {
    internal byte Script;
    internal byte ItemClass;
    internal ushort Flags;
    internal byte BreakType;
    internal DirectionClass BiDi;
    internal short LineBreak;
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.CharacterBuffer : object {
    public char Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [SecurityCriticalAttribute]
public abstract virtual Char* GetCharacterPointer();
    public abstract virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    public abstract virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public abstract virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int length);
    public sealed virtual int IndexOf(char item);
    public sealed virtual void Insert(int index, char item);
    public abstract virtual char get_Item(int index);
    public abstract virtual void set_Item(int index, char value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(char item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(char item);
    public sealed virtual void CopyTo(Char[] array, int arrayIndex);
    public abstract virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(char item);
    [IteratorStateMachineAttribute("MS.Internal.CharacterBuffer/<System-Collections-Generic-IEnumerable<System-Char>-GetEnumerator>d__19")]
private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.CharArrayCharacterBuffer : CharacterBuffer {
    public char Item { get; public set; }
    public int Count { get; }
    public CharArrayCharacterBuffer(Char[] characterArray);
    public virtual char get_Item(int characterOffset);
    public virtual void set_Item(int characterOffset, char value);
    public virtual int get_Count();
    [SecurityCriticalAttribute]
public virtual Char* GetCharacterPointer();
    [SecurityCriticalAttribute]
public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal class MS.Internal.CheckedCharPointer : ValueType {
    private CheckedPointer _checkedPointer;
    [SecurityCriticalAttribute]
internal CheckedCharPointer(Char* pointer, int length);
    [SecurityCriticalAttribute]
internal Char* Probe(int offset, int length);
}
internal class MS.Internal.CheckedIntPointer : ValueType {
    private CheckedPointer _checkedPointer;
    [SecurityCriticalAttribute]
internal CheckedIntPointer(Int32* pointer, int length);
    [SecurityCriticalAttribute]
internal Int32* Probe(int offset, int length);
}
internal class MS.Internal.CheckedUShortPointer : ValueType {
    private CheckedPointer _checkedPointer;
    [SecurityCriticalAttribute]
internal CheckedUShortPointer(UInt16* pointer, int length);
    [SecurityCriticalAttribute]
internal UInt16* Probe(int offset, int length);
}
internal static class MS.Internal.Classification : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Classification();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void MILGetClassificationTables(RawClassificationTables& ct);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static short GetUnicodeClassUTF16(char codepoint);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static short GetUnicodeClass(int unicodeScalar);
    internal static int UnicodeScalar(CharacterBufferRange unicodeString, Int32& sizeofChar);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool IsCombining(int unicodeScalar);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static bool IsJoiner(int unicodeScalar);
    public static bool IsIVS(int unicodeScalar);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static int AdvanceUntilUTF16(CharacterBuffer charBuffer, int offsetToFirstChar, int stringLength, ushort mask, UInt16& charFlags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int AdvanceWhile(CharacterBufferRange unicodeString, ItemClass itemClass);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static CharacterAttribute CharAttributeOf(int charClass);
}
internal class MS.Internal.ClassificationUtility : object {
    internal static Boolean[] ScriptCaretInfo;
    internal static ClassificationUtility Instance { get; }
    private static ClassificationUtility();
    internal static ClassificationUtility get_Instance();
    public sealed virtual void GetCharAttribute(int unicodeScalar, Boolean& isCombining, Boolean& needsCaretInfo, Boolean& isIndic, Boolean& isDigit, Boolean& isLatin, Boolean& isStrong);
}
internal class MS.Internal.Collections.ItemInsertedHandler : MulticastDelegate {
    public ItemInsertedHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, object item);
    public virtual IAsyncResult BeginInvoke(object sender, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Collections.ItemRemovedHandler : MulticastDelegate {
    public ItemRemovedHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, object item);
    public virtual IAsyncResult BeginInvoke(object sender, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.CommandLibraryHelper : object {
    internal static RoutedUICommand CreateUICommand(string name, Type ownerType, byte commandId, PermissionSet ps);
}
internal static class MS.Internal.Composition.Version : object {
    internal static UInt32 MilSdkVersion { get; }
    internal static UInt32 DwmSdkVersion { get; }
    internal static UInt32 get_MilSdkVersion();
    internal static UInt32 get_DwmSdkVersion();
}
internal class MS.Internal.ConstrainedDataObject : object {
    [SecurityCriticalAttribute]
internal ConstrainedDataObject(IDataObject data);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual object GetData(string format, bool autoConvert);
    public sealed virtual object GetData(string format);
    public sealed virtual object GetData(Type format);
    public sealed virtual bool GetDataPresent(Type format);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual bool GetDataPresent(string format, bool autoConvert);
    public sealed virtual bool GetDataPresent(string format);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual String[] GetFormats(bool autoConvert);
    public sealed virtual String[] GetFormats();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void SetData(object data);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual void SetData(string format, object data);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void SetData(Type format, object data);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void SetData(string format, object data, bool autoConvert);
}
internal static class MS.Internal.CoreAppContextSwitches : object {
    internal static string DoNotScaleForDpiChangesSwitchName;
    internal static string DisableStylusAndTouchSupportSwitchName;
    internal static string EnablePointerSupportSwitchName;
    internal static string OverrideExceptionWithNullReferenceExceptionName;
    internal static string DisableDiagnosticsSwitchName;
    internal static string AllowChangesDuringVisualTreeChangedSwitchName;
    internal static string DisableImplicitTouchKeyboardInvocationSwitchName;
    internal static string ShouldRenderEvenWhenNoDisplayDevicesAreAvailableSwitchName;
    internal static string ShouldNotRenderInNonInteractiveWindowStationSwitchName;
    public static bool DoNotScaleForDpiChanges { get; }
    public static bool DisableStylusAndTouchSupport { get; }
    public static bool EnablePointerSupport { get; }
    public static bool OverrideExceptionWithNullReferenceException { get; }
    public static bool DisableDiagnostics { get; }
    public static bool AllowChangesDuringVisualTreeChanged { get; }
    public static bool DisableImplicitTouchKeyboardInvocation { get; }
    public static bool UseLegacyAccessibilityFeatures { get; }
    public static bool UseLegacyAccessibilityFeatures2 { get; }
    public static bool ShouldRenderEvenWhenNoDisplayDevicesAreAvailable { get; }
    public static bool ShouldNotRenderInNonInteractiveWindowStation { get; }
    public static bool get_DoNotScaleForDpiChanges();
    public static bool get_DisableStylusAndTouchSupport();
    public static bool get_EnablePointerSupport();
    public static bool get_OverrideExceptionWithNullReferenceException();
    public static bool get_DisableDiagnostics();
    public static bool get_AllowChangesDuringVisualTreeChanged();
    public static bool get_DisableImplicitTouchKeyboardInvocation();
    public static bool get_UseLegacyAccessibilityFeatures();
    public static bool get_UseLegacyAccessibilityFeatures2();
    public static bool get_ShouldRenderEvenWhenNoDisplayDevicesAreAvailable();
    public static bool get_ShouldNotRenderInNonInteractiveWindowStation();
}
internal class MS.Internal.CustomCategoryAttribute : CategoryAttribute {
    internal CustomCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
internal class MS.Internal.DecoderFallbackWithFailureFlag : DecoderFallback {
    public int MaxCharCount { get; }
    public bool HasFailed { get; public set; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public bool get_HasFailed();
    public void set_HasFailed(bool value);
}
internal class MS.Internal.DeferredElementTreeState : object {
    public bool IsEmpty { get; }
    public void SetCoreParent(DependencyObject element, DependencyObject parent);
    public static DependencyObject GetCoreParent(DependencyObject element, DeferredElementTreeState treeState);
    public static DependencyObject GetInputElementParent(DependencyObject element, DeferredElementTreeState treeState);
    public void SetLogicalParent(DependencyObject element, DependencyObject parent);
    public static DependencyObject GetLogicalParent(DependencyObject element, DeferredElementTreeState treeState);
    public void Clear();
    public bool get_IsEmpty();
}
internal enum MS.Internal.DirectionClass : Enum {
    public byte value__;
    public static DirectionClass Left;
    public static DirectionClass Right;
    public static DirectionClass ArabicNumber;
    public static DirectionClass EuropeanNumber;
    public static DirectionClass ArabicLetter;
    public static DirectionClass EuropeanSeparator;
    public static DirectionClass CommonSeparator;
    public static DirectionClass EuropeanTerminator;
    public static DirectionClass NonSpacingMark;
    public static DirectionClass BoundaryNeutral;
    public static DirectionClass GenericNeutral;
    public static DirectionClass ParagraphSeparator;
    public static DirectionClass LeftToRightEmbedding;
    public static DirectionClass LeftToRightOverride;
    public static DirectionClass RightToLeftEmbedding;
    public static DirectionClass RightToLeftOverride;
    public static DirectionClass PopDirectionalFormat;
    public static DirectionClass SegmentSeparator;
    public static DirectionClass WhiteSpace;
    public static DirectionClass OtherNeutral;
    public static DirectionClass ClassInvalid;
    public static DirectionClass ClassMax;
}
internal enum MS.Internal.DitherType : Enum {
    public int value__;
    public static DitherType DitherTypeNone;
    public static DitherType DitherTypeSolid;
    public static DitherType DitherTypeOrdered4x4;
    public static DitherType DitherTypeOrdered8x8;
    public static DitherType DitherTypeOrdered16x16;
    public static DitherType DitherTypeSpiral4x4;
    public static DitherType DitherTypeSpiral8x8;
    public static DitherType DitherTypeDualSpiral4x4;
    public static DitherType DitherTypeDualSpiral8x8;
    public static DitherType DitherTypeErrorDiffusion;
}
internal class MS.Internal.Equals : MulticastDelegate {
    public Equals(object object, IntPtr method);
    public virtual bool Invoke(object first, object second);
    public virtual IAsyncResult BeginInvoke(object first, object second, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class MS.Internal.FloatUtil : object {
    internal static float FLT_EPSILON;
    internal static float FLT_MAX_PRECISION;
    internal static float INVERSE_FLT_MAX_PRECISION;
    private static FloatUtil();
    public static bool AreClose(float a, float b);
    public static bool IsOne(float a);
    public static bool IsZero(float a);
    public static bool IsCloseToDivideByZero(float numerator, float denominator);
}
internal static class MS.Internal.FontCache.BufferCache : object {
    internal static void Reset();
    internal static GlyphMetrics[] GetGlyphMetrics(int length);
    internal static void ReleaseGlyphMetrics(GlyphMetrics[] glyphMetrics);
    internal static UInt16[] GetUShorts(int length);
    internal static void ReleaseUShorts(UInt16[] ushorts);
    internal static UInt32[] GetUInts(int length);
    internal static void ReleaseUInts(UInt32[] uints);
}
internal class MS.Internal.FontCache.CachedTypeface : object {
    internal FontStyle CanonicalStyle { get; }
    internal FontWeight CanonicalWeight { get; }
    internal FontStretch CanonicalStretch { get; }
    internal IFontFamily FirstFontFamily { get; }
    internal ITypefaceMetrics TypefaceMetrics { get; }
    internal bool NullFont { get; }
    internal CachedTypeface(FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, IFontFamily firstFontFamily, ITypefaceMetrics typefaceMetrics, bool nullFont);
    internal FontStyle get_CanonicalStyle();
    internal FontWeight get_CanonicalWeight();
    internal FontStretch get_CanonicalStretch();
    internal IFontFamily get_FirstFontFamily();
    internal ITypefaceMetrics get_TypefaceMetrics();
    internal bool get_NullFont();
}
internal class MS.Internal.FontCache.CanonicalFontFamilyReference : object {
    public static CanonicalFontFamilyReference Unresolved { get; }
    public string FamilyName { get; }
    public string EscapedFileName { get; private set; }
    public Uri LocationUri { get; }
    private static CanonicalFontFamilyReference();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static CanonicalFontFamilyReference Create(Uri baseUri, string normalizedString);
    public static CanonicalFontFamilyReference get_Unresolved();
    public string get_FamilyName();
    [CompilerGeneratedAttribute]
public string get_EscapedFileName();
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
private void set_EscapedFileName(string value);
    public Uri get_LocationUri();
    public bool Equals(CanonicalFontFamilyReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.CheckedPointer : ValueType {
    [SecurityCriticalAttribute]
private Void* _pointer;
    [SecurityCriticalAttribute]
private int _size;
    internal bool IsNull { get; }
    internal int Size { get; }
    [SecurityCriticalAttribute]
internal CheckedPointer(Void* pointer, int size);
    [SecurityCriticalAttribute]
internal CheckedPointer(UnmanagedMemoryStream stream);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsNull();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int get_Size();
    [SecurityCriticalAttribute]
internal Byte[] ToArray();
    [SecurityCriticalAttribute]
internal void CopyTo(CheckedPointer dest);
    [SecurityCriticalAttribute]
internal int OffsetOf(Void* pointer);
    [SecurityCriticalAttribute]
internal int OffsetOf(CheckedPointer pointer);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static CheckedPointer op_Addition(CheckedPointer rhs, int offset);
    [SecurityCriticalAttribute]
internal Void* Probe(int offset, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CheckedPointer CheckedProbe(int offset, int length);
    [SecurityCriticalAttribute]
internal void SetSize(int newSize);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool PointerEquals(CheckedPointer pointer);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void WriteBool(bool value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool ReadBool();
}
internal static class MS.Internal.FontCache.DWriteFactory : object {
    internal static Factory Instance { get; }
    internal static FontCollection SystemFontCollection { get; }
    [SecuritySafeCriticalAttribute]
private static DWriteFactory();
    [SecurityCriticalAttribute]
internal static Factory get_Instance();
    [SecurityCriticalAttribute]
internal static FontCollection get_SystemFontCollection();
    [SecurityCriticalAttribute]
internal static FontCollection GetFontCollectionFromFolder(Uri fontCollectionUri);
    [SecurityCriticalAttribute]
internal static FontCollection GetFontCollectionFromFile(Uri fontCollectionUri);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FamilyCollection : object {
    internal static string SxSFontsLocation { get; }
    internal UInt32 FamilyCount { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static FamilyCollection();
    [SecurityCriticalAttribute]
internal static string get_SxSFontsLocation();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static FamilyCollection FromUri(Uri folderUri);
    [SecurityCriticalAttribute]
internal static FamilyCollection FromWindowsFonts(Uri folderUri);
    [SecurityCriticalAttribute]
internal IFontFamily LookupFamily(string familyName, FontStyle& fontStyle, FontWeight& fontWeight, FontStretch& fontStretch);
    internal FontFamily[] GetFontFamilies(Uri fontFamilyBaseUri, string fontFamilyLocationReference);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal UInt32 get_FamilyCount();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FileMapping : UnmanagedMemoryStream {
    protected virtual override void Finalize();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
internal void OpenFile(string fileName);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FontFaceLayoutInfo : object {
    internal IntMap CharacterMap { get; }
    internal ushort BlankGlyph { get; }
    internal ushort DesignEmHeight { get; }
    internal FontEmbeddingRight EmbeddingRights { get; }
    internal FontTechnology FontTechnology { get; }
    internal TypographyAvailabilities TypographyAvailabilities { get; }
    internal ushort GlyphCount { get; }
    [SecurityCriticalAttribute]
internal FontFaceLayoutInfo(Font font);
    private static FontFaceLayoutInfo();
    internal IntMap get_CharacterMap();
    internal ushort get_BlankGlyph();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ushort get_DesignEmHeight();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal FontEmbeddingRight get_EmbeddingRights();
    internal FontTechnology get_FontTechnology();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal TypographyAvailabilities get_TypographyAvailabilities();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ushort get_GlyphCount();
    [SecurityCriticalAttribute]
internal Byte[] Gsub();
    [SecurityCriticalAttribute]
internal Byte[] Gpos();
    [SecurityCriticalAttribute]
internal Byte[] Gdef();
    [SecurityCriticalAttribute]
internal Byte[] GetTableCache(OpenTypeTags tableTag);
    internal Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
}
internal static class MS.Internal.FontCache.FontResourceCache : object {
    private static FontResourceCache();
    internal static List`1<string> LookupFolder(Uri uri);
}
internal class MS.Internal.FontCache.FontSource : object {
    public bool IsComposite { get; }
    public Uri Uri { get; }
    public bool IsAppSpecific { get; }
    [SecurityCriticalAttribute]
public FontSource(Uri fontUri, bool skipDemand);
    [SecurityCriticalAttribute]
public FontSource(Uri fontUri, bool skipDemand, bool isComposite);
    private static FontSource();
    public sealed virtual bool get_IsComposite();
    [SecurityCriticalAttribute]
public string GetUriString();
    [SecurityCriticalAttribute]
public string ToStringUpperInvariant();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public sealed virtual Uri get_Uri();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public bool get_IsAppSpecific();
    internal long SkipLastWriteTime();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual DateTime GetLastWriteTimeUtc();
    [SecurityCriticalAttribute]
public sealed virtual UnmanagedMemoryStream GetUnmanagedStream();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual void TestFileOpenable();
    [SecurityCriticalAttribute]
public Stream GetStream();
}
internal class MS.Internal.FontCache.FontSourceCollection : object {
    [SecurityCriticalAttribute]
public FontSourceCollection(Uri folderUri, bool isWindowsFonts);
    [SecurityCriticalAttribute]
public FontSourceCollection(Uri folderUri, bool isWindowsFonts, bool tryGetCompositeFontsOnly);
    private sealed virtual override IEnumerator`1<IFontSource> System.Collections.Generic.IEnumerable<MS.Internal.Text.TextInterface.IFontSource>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.FontCache.FontSourceCollectionFactory : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual IFontSourceCollection Create(string uriString);
}
internal class MS.Internal.FontCache.FontSourceFactory : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual IFontSource Create(string uriString);
}
internal class MS.Internal.FontCache.GsubGposTables : object {
    [SecurityCriticalAttribute]
internal GsubGposTables(FontFaceLayoutInfo layout);
    public sealed virtual FontTable GetFontTable(OpenTypeTags TableTag);
    public sealed virtual LayoutOffset GetGlyphPointCoord(ushort Glyph, ushort PointIndex);
    [SecurityCriticalAttribute]
public sealed virtual Byte[] GetTableCache(OpenTypeTags tableTag);
    [SecurityCriticalAttribute]
public sealed virtual Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FontCache.HashFn : object {
    internal static int HashMultiply(int hash);
    internal static int HashScramble(int hash);
    [SecurityCriticalAttribute]
internal static int HashMemory(Void* pv, int numBytes, int hash);
    internal static int HashString(string s, int hash);
}
internal class MS.Internal.FontCache.LocalizedName : object {
    internal XmlLanguage Language { get; }
    internal string Name { get; }
    internal int OriginalLCID { get; }
    internal static IComparer`1<LocalizedName> NameComparer { get; }
    internal static IComparer`1<LocalizedName> LanguageComparer { get; }
    internal LocalizedName(XmlLanguage language, string name);
    internal LocalizedName(XmlLanguage language, string name, int originalLCID);
    private static LocalizedName();
    internal XmlLanguage get_Language();
    internal string get_Name();
    internal int get_OriginalLCID();
    internal static IComparer`1<LocalizedName> get_NameComparer();
    internal static IComparer`1<LocalizedName> get_LanguageComparer();
}
internal static class MS.Internal.FontCache.MajorLanguages : object {
    private static MajorLanguages();
    internal static bool Contains(ScriptTags script, LanguageTags langSys);
    internal static bool Contains(CultureInfo culture);
}
internal static class MS.Internal.FontCache.TypefaceMetricsCache : object {
    private static TypefaceMetricsCache();
    internal static object ReadonlyLookup(object key);
    internal static void Add(object key, object value);
}
[FlagsAttribute]
internal enum MS.Internal.FontCache.TypographyAvailabilities : Enum {
    public int value__;
    public static TypographyAvailabilities None;
    public static TypographyAvailabilities Available;
    public static TypographyAvailabilities IdeoTypographyAvailable;
    public static TypographyAvailabilities FastTextTypographyAvailable;
    public static TypographyAvailabilities FastTextMajorLanguageLocalizedFormAvailable;
    public static TypographyAvailabilities FastTextExtraLanguageLocalizedFormAvailable;
}
internal class MS.Internal.FontCache.UnicodeRange : ValueType {
    internal int firstChar;
    internal int lastChar;
    internal UnicodeRange(int first, int last);
    internal UInt32[] GetFullRange();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FontCache.Util : object {
    internal static int nullOffset;
    internal static UriComponents UriWithoutFragment;
    internal static string CompositeFontExtension { get; }
    internal static string WindowsFontsLocalPath { get; }
    internal static float PixelsPerDip { get; }
    internal static int Dpi { get; }
    internal static Uri WindowsFontsUriObject { get; }
    internal static string WindowsFontsUriString { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Util();
    internal static string get_CompositeFontExtension();
    [SecurityCriticalAttribute]
internal static string get_WindowsFontsLocalPath();
    internal static float get_PixelsPerDip();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int get_Dpi();
    [SecurityCriticalAttribute]
internal static Uri get_WindowsFontsUriObject();
    [SecurityCriticalAttribute]
internal static string get_WindowsFontsUriString();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static bool IsReferenceToWindowsFonts(string s);
    internal static bool IsSupportedSchemeForAbsoluteFontFamilyUri(Uri absoluteUri);
    internal static void SplitFontFaceIndex(Uri fontUri, Uri& fontSourceUri, Int32& faceIndex);
    internal static Uri CombineUriWithFaceIndex(string fontUri, int faceIndex);
    internal static bool IsSupportedFontExtension(string extension, Boolean& isComposite);
    internal static bool IsCompositeFont(string extension);
    internal static bool IsEnumerableFontUriScheme(Uri fontLocation);
    internal static bool IsAppSpecificUri(Uri fontLocation);
    internal static string GetUriExtension(Uri uri);
    internal static string GetNormalizedFontFamilyReference(string friendlyName, int startIndex, int length);
    internal static string ConvertFamilyNameAndLocationToFontFamilyReference(string familyName, string location);
    internal static string ConvertFontFamilyReferenceToFriendlyName(string fontFamilyReference);
    internal static int CompareOrdinalIgnoreCase(string a, string b);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ThrowWin32Exception(int errorCode, string fileName);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Exception ConvertInPageException(FontSource fontSource, SEHException e);
}
internal class MS.Internal.FontFace.CompositeFontInfo : object {
    internal static int FirstFamilyMapRange;
    internal FamilyTypefaceCollection FamilyTypefaces { get; }
    internal double Baseline { get; internal set; }
    internal double LineSpacing { get; internal set; }
    internal LanguageSpecificStringDictionary FamilyNames { get; }
    internal FontFamilyMapCollection FamilyMaps { get; }
    internal ICollection`1<XmlLanguage> FamilyMapLanguages { get; }
    private static CompositeFontInfo();
    internal void PrepareToAddFamilyMap(FontFamilyMap familyMap);
    internal void InvalidateFamilyMapRanges();
    internal UInt16[] GetFamilyMapsOfLanguage(XmlLanguage language);
    internal FontFamilyMap GetFamilyMapOfChar(UInt16[] familyMapRanges, int ch);
    internal FamilyTypefaceCollection get_FamilyTypefaces();
    internal FamilyTypefaceCollection GetFamilyTypefaceList();
    internal double get_Baseline();
    internal void set_Baseline(double value);
    internal double get_LineSpacing();
    internal void set_LineSpacing(double value);
    internal LanguageSpecificStringDictionary get_FamilyNames();
    internal FontFamilyMapCollection get_FamilyMaps();
    internal ICollection`1<XmlLanguage> get_FamilyMapLanguages();
}
internal class MS.Internal.FontFace.CompositeFontParser : object {
    internal static void VerifyMultiplierOfEm(string propertyName, Double& value);
    internal static void VerifyPositiveMultiplierOfEm(string propertyName, Double& value);
    internal static void VerifyNonNegativeMultiplierOfEm(string propertyName, Double& value);
    internal static CompositeFontInfo LoadXml(Stream fileStream);
}
internal static class MS.Internal.FontFace.FontDifferentiator : object {
    internal static IDictionary`2<XmlLanguage, string> ConstructFaceNamesByStyleWeightStretch(FontStyle style, FontWeight weight, FontStretch stretch);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.FontFace.FontFamilyIdentifier : ValueType {
    private string _friendlyName;
    private Uri _baseUri;
    private int _tokenCount;
    private CanonicalFontFamilyReference[] _canonicalReferences;
    internal static char FamilyNameDelimiter;
    internal static int MaxFamilyNamePerFamilyMapTarget;
    internal string Source { get; }
    internal Uri BaseUri { get; }
    internal int Count { get; }
    internal CanonicalFontFamilyReference Item { get; }
    internal FontFamilyIdentifier(string friendlyName, Uri baseUri);
    internal FontFamilyIdentifier(FontFamilyIdentifier first, FontFamilyIdentifier second);
    internal string get_Source();
    internal Uri get_BaseUri();
    public bool Equals(FontFamilyIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Count();
    internal CanonicalFontFamilyReference get_Item(int tokenIndex);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Canonicalize();
}
internal enum MS.Internal.FontFace.FontTechnology : Enum {
    public int value__;
    public static FontTechnology PostscriptOpenType;
    public static FontTechnology TrueType;
    public static FontTechnology TrueTypeCollection;
}
internal interface MS.Internal.FontFace.IDeviceFont {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool ContainsCharacter(int unicodeScalar);
    [SecurityCriticalAttribute]
public abstract virtual void GetAdvanceWidths(Char* characterString, int characterLength, double emSize, Int32* pAdvances);
}
internal interface MS.Internal.FontFace.IFontFamily {
    public IDictionary`2<XmlLanguage, string> Names { get; }
    public double BaselineDesign { get; }
    public double LineSpacingDesign { get; }
    public abstract virtual IDictionary`2<XmlLanguage, string> get_Names();
    public abstract virtual double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public abstract virtual double get_BaselineDesign();
    public abstract virtual double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public abstract virtual double get_LineSpacingDesign();
    public abstract virtual ITypefaceMetrics GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    public abstract virtual IDeviceFont GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    public abstract virtual bool GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
    public abstract virtual ICollection`1<Typeface> GetTypefaces(FontFamilyIdentifier familyIdentifier);
}
internal interface MS.Internal.FontFace.ITypefaceMetrics {
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public bool Symbol { get; }
    public StyleSimulations StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public abstract virtual double get_XHeight();
    public abstract virtual double get_CapsHeight();
    public abstract virtual double get_UnderlinePosition();
    public abstract virtual double get_UnderlineThickness();
    public abstract virtual double get_StrikethroughPosition();
    public abstract virtual double get_StrikethroughThickness();
    public abstract virtual bool get_Symbol();
    public abstract virtual StyleSimulations get_StyleSimulations();
    public abstract virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
}
internal class MS.Internal.FontFace.MatchingStyle : ValueType {
    private Vector _vector;
    private static double FontWeightScale;
    private static double FontStyleScale;
    private static double FontStretchScale;
    internal MatchingStyle(FontStyle style, FontWeight weight, FontStretch stretch);
    public static bool op_Equality(MatchingStyle l, MatchingStyle r);
    public static bool op_Inequality(MatchingStyle l, MatchingStyle r);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal static bool IsBetterMatch(MatchingStyle target, MatchingStyle best, MatchingStyle& matching);
    internal bool IsBetterMatch(MatchingStyle target, MatchingStyle best);
}
internal class MS.Internal.FontFace.PhysicalFontFamily : object {
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.Names { get; }
    private double MS.Internal.FontFace.IFontFamily.BaselineDesign { get; }
    private double MS.Internal.FontFace.IFontFamily.LineSpacingDesign { get; }
    internal PhysicalFontFamily(FontFamily family);
    private sealed virtual override ITypefaceMetrics MS.Internal.FontFace.IFontFamily.GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override IDeviceFont MS.Internal.FontFace.IFontFamily.GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.get_Names();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal GlyphTypeface GetGlyphTypeface(FontStyle style, FontWeight weight, FontStretch stretch);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal GlyphTypeface MapGlyphTypeface(FontStyle style, FontWeight weight, FontStretch stretch, CharacterBufferRange charString, CultureInfo digitCulture, Int32& advance, Int32& nextValid);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override double MS.Internal.FontFace.IFontFamily.Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_BaselineDesign();
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_LineSpacingDesign();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override double MS.Internal.FontFace.IFontFamily.LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override ICollection`1<Typeface> MS.Internal.FontFace.IFontFamily.GetTypefaces(FontFamilyIdentifier familyIdentifier);
    private sealed virtual override bool MS.Internal.FontFace.IFontFamily.GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
}
internal class MS.Internal.FontFace.TrueTypeFontDriver : object {
    internal int NumFaces { get; }
    [SecurityCriticalAttribute]
internal TrueTypeFontDriver(UnmanagedMemoryStream unmanagedMemoryStream, Uri sourceUri);
    internal void SetFace(int faceIndex);
    internal int get_NumFaces();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal Byte[] ComputeFontSubset(ICollection`1<ushort> glyphs);
}
internal class MS.Internal.FontFace.TypefaceCollection : ValueType {
    private FontFamily _fontFamily;
    private FontFamily _family;
    private FamilyTypefaceCollection _familyTypefaceCollection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TypefaceCollection(FontFamily fontFamily, FontFamily family);
    public TypefaceCollection(FontFamily fontFamily, FamilyTypefaceCollection familyTypefaceCollection);
    public sealed virtual void Add(Typeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Typeface item);
    public sealed virtual void CopyTo(Typeface[] array, int arrayIndex);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Typeface item);
    public sealed virtual IEnumerator`1<Typeface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FreezableOperations : object {
    internal static Freezable Clone(Freezable freezable);
    public static Freezable GetAsFrozen(Freezable freezable);
    internal static Freezable GetAsFrozenIfPossible(Freezable freezable);
    internal static void PropagateChangedHandlers(Freezable oldValue, Freezable newValue, EventHandler changedHandler);
}
internal class MS.Internal.Generic.Span`1 : ValueType {
    internal T Value;
    internal int Length;
    internal Span`1(T value, int length);
}
internal class MS.Internal.Generic.SpanRider`1 : ValueType {
    private static int MaxCch;
    private SpanVector`1<T> _vector;
    private Span`1<T> _defaultSpan;
    private int _current;
    private int _cp;
    private int _dcp;
    private int _cch;
    internal int CurrentSpanStart { get; }
    internal int Length { get; }
    internal int CurrentPosition { get; }
    internal T CurrentValue { get; }
    internal SpanRider`1(SpanVector`1<T> vector);
    internal bool At(int cp);
    internal int get_CurrentSpanStart();
    internal int get_Length();
    internal int get_CurrentPosition();
    internal T get_CurrentValue();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Generic.SpanVector`1 : ValueType {
    private FrugalStructList`1<Span`1<T>> _spanList;
    private T _defaultValue;
    internal int Count { get; }
    internal T DefaultValue { get; }
    internal Span`1<T> Item { get; }
    internal SpanVector`1(T defaultValue);
    public sealed virtual IEnumerator`1<Span`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Delete(int index, int count);
    internal void Set(int first, int length, T value);
    internal int get_Count();
    internal T get_DefaultValue();
    internal Span`1<T> get_Item(int index);
}
internal class MS.Internal.GenericEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    internal GenericEnumerator(IList array, GetGenerationIDDelegate getGenerationID);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class MS.Internal.Hashing.PresentationCore.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
internal class MS.Internal.HRESULT : ValueType {
    internal static int FACILITY_NT_BIT;
    internal static int FACILITY_MASK;
    internal static int FACILITY_WINCODEC_ERROR;
    internal static int COMPONENT_MASK;
    internal static int COMPONENT_WINCODEC_ERROR;
    internal static int S_OK;
    internal static int E_FAIL;
    internal static int E_OUTOFMEMORY;
    internal static int D3DERR_OUTOFVIDEOMEMORY;
    internal static bool IsWindowsCodecError(int hr);
    [SecuritySafeCriticalAttribute]
internal static Exception ConvertHRToException(int hr);
    public static void Check(int hr);
    public static bool Succeeded(int hr);
    public static bool Failed(int hr);
}
internal interface MS.Internal.IAppDomainShutdownListener {
    public abstract virtual void NotifyShutdown();
}
internal class MS.Internal.Ink.Bezier : object {
    internal bool ConstructBezierState(StylusPointCollection stylusPoints, double fitError);
    internal List`1<Point> Flatten(double tolerance);
}
internal class MS.Internal.Ink.BitStreamReader : object {
    internal bool EndOfStream { get; }
    internal int CurrentIndex { get; }
    internal BitStreamReader(Byte[] buffer);
    internal BitStreamReader(Byte[] buffer, int startIndex);
    internal BitStreamReader(Byte[] buffer, UInt32 bufferLengthInBits);
    internal long ReadUInt64(int countOfBits);
    internal ushort ReadUInt16(int countOfBits);
    internal UInt32 ReadUInt16Reverse(int countOfBits);
    internal UInt32 ReadUInt32(int countOfBits);
    internal UInt32 ReadUInt32Reverse(int countOfBits);
    internal bool ReadBit();
    internal byte ReadByte(int countOfBits);
    internal bool get_EndOfStream();
    internal int get_CurrentIndex();
}
internal class MS.Internal.Ink.BitStreamWriter : object {
    internal BitStreamWriter(List`1<byte> bufferToWriteTo);
    internal void Write(UInt32 bits, int countOfBits);
    internal void WriteReverse(UInt32 bits, int countOfBits);
    internal void Write(byte bits, int countOfBits);
}
internal class MS.Internal.Ink.ContourSegment : ValueType {
    private Point _begin;
    private Vector _vector;
    private Vector _radius;
    internal bool IsArc { get; }
    internal Point Begin { get; }
    internal Point End { get; }
    internal Vector Vector { get; }
    internal Vector Radius { get; }
    internal ContourSegment(Point begin, Point end);
    internal ContourSegment(Point begin, Point end, Point center);
    internal bool get_IsArc();
    internal Point get_Begin();
    internal Point get_End();
    internal Vector get_Vector();
    internal Vector get_Radius();
}
internal class MS.Internal.Ink.CuspData : object {
    internal int Count { get; }
    internal void Analyze(StylusPointCollection stylusPoints, double rSpan);
    internal void SetTanLinks(double rError);
    internal int GetNextCusp(int iCurrent);
    internal Vector XY(int i);
    internal int get_Count();
    internal double Node(int i);
    internal int GetPointIndex(int nodeIndex);
    internal double Distance();
    internal bool Tangent(Vector& ptT, int nAt, int nPrevCusp, int nNextCusp, bool bReverse, bool bIsCusp);
}
internal class MS.Internal.Ink.EllipticalNodeOperations : StrokeNodeOperations {
    internal bool IsNodeShapeEllipse { get; }
    internal EllipticalNodeOperations(StylusShape nodeShape);
    internal virtual bool get_IsNodeShapeEllipse();
    internal virtual Quad GetConnectingQuad(StrokeNodeData beginNode, StrokeNodeData endNode);
    [IteratorStateMachineAttribute("MS.Internal.Ink.EllipticalNodeOperations/<GetContourSegments>d__4")]
internal virtual IEnumerable`1<ContourSegment> GetContourSegments(StrokeNodeData node, Quad quad);
    internal virtual IEnumerable`1<ContourSegment> GetNonBezierContourSegments(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
}
internal class MS.Internal.Ink.ErasingStroke : object {
    internal Rect Bounds { get; }
    internal ErasingStroke(StylusShape erasingShape);
    internal ErasingStroke(StylusShape erasingShape, IEnumerable`1<Point> path);
    private static ErasingStroke();
    internal void MoveTo(IEnumerable`1<Point> path);
    internal Rect get_Bounds();
    internal bool HitTest(StrokeNodeIterator iterator);
    internal bool EraseTest(StrokeNodeIterator iterator, List`1<StrokeIntersection> intersections);
}
internal class MS.Internal.Ink.GestureRecognition.NativeRecognizer : object {
    [SecurityCriticalAttribute]
private static NativeRecognizer();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static NativeRecognizer CreateInstance();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ApplicationGesture[] SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    [SecurityCriticalAttribute]
internal GestureRecognitionResult[] Recognize(StrokeCollection strokes);
    internal static ApplicationGesture[] GetApplicationGestureArrayAndVerify(IEnumerable`1<ApplicationGesture> applicationGestures);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
}
internal class MS.Internal.Ink.InkSerializedFormat.AlgoModule : object {
    internal static byte NoCompression;
    internal static byte DefaultCompression;
    internal static byte IndexedHuffman;
    internal static byte LempelZiv;
    internal static byte DefaultBAACount;
    internal static byte MaxBAACount;
    private static AlgoModule();
    internal byte GetBestDefHuff(Int32[] input);
    internal Byte[] CompressPacketData(Int32[] input, byte compression);
    internal UInt32 DecompressPacketData(Byte[] input, Int32[] outputBuffer);
    internal Byte[] CompressPropertyData(Byte[] input, byte compression);
    internal Byte[] DecompressPropertyData(Byte[] input);
}
internal class MS.Internal.Ink.InkSerializedFormat.Compressor : object {
    internal static void DecompressPacketData(Byte[] compressedInput, UInt32& size, Int32[] decompressedPackets);
    internal static Byte[] DecompressPropertyData(Byte[] input);
    internal static Byte[] CompressPropertyData(Byte[] data, byte algorithm);
    internal static Byte[] CompressPacketData(Int32[] input, Byte& algorithm);
}
internal abstract class MS.Internal.Ink.InkSerializedFormat.DataXform : object {
    internal abstract virtual void Transform(int data, Int32& xfData, Int32& extra);
    internal abstract virtual void ResetState();
    internal abstract virtual int InverseTransform(int xfData, int extra);
}
internal class MS.Internal.Ink.InkSerializedFormat.DeltaDelta : DataXform {
    internal virtual void Transform(int data, Int32& xfData, Int32& extra);
    internal virtual void ResetState();
    internal virtual int InverseTransform(int xfData, int extra);
}
internal static class MS.Internal.Ink.InkSerializedFormat.DrawingAttributeSerializer : object {
    internal static UInt32 RasterOperationMaskPen;
    internal static UInt32 RasterOperationDefaultV1;
    private static DrawingAttributeSerializer();
    internal static UInt32 DecodeAsISF(Stream stream, GuidList guidList, UInt32 maximumStreamSize, DrawingAttributes da);
    internal static double GetCappedHeightOrWidth(double heightOrWidth);
    internal static UInt32 EncodeAsISF(DrawingAttributes da, Stream stream, GuidList guidList, byte compressionAlgorithm, bool fTag);
}
internal static class MS.Internal.Ink.InkSerializedFormat.ExtendedPropertySerializer : object {
    internal static void EncodeToStream(ExtendedProperty attribute, Stream stream);
    internal static void EncodeAttribute(Guid guid, object value, VarEnum type, Stream stream);
    internal static UInt32 EncodeAsISF(Guid id, Byte[] data, Stream strm, GuidList guidList, byte compressionAlgorithm, bool fTag);
    internal static UInt32 DecodeAsISF(Stream stream, UInt32 cbSize, GuidList guidList, KnownTagIndex tag, Guid& guid, Object& data);
    internal static object DecodeAttribute(Guid guid, Stream stream);
    internal static object DecodeAttribute(Guid guid, Stream memStream, VarEnum& type);
    internal static UInt32 EncodeAsISF(ExtendedPropertyCollection attributes, Stream stream, GuidList guidList, byte compressionAlgorithm, bool fTag);
    internal static Guid[] GetUnknownGuids(ExtendedPropertyCollection attributes, Int32& count);
    internal static void Validate(Guid id, object value);
}
internal class MS.Internal.Ink.InkSerializedFormat.GorillaAlgoByte : ValueType {
    public UInt32 BitCount;
    public UInt32 PadCount;
    public GorillaAlgoByte(UInt32 bitCount, UInt32 padCount);
}
internal class MS.Internal.Ink.InkSerializedFormat.GorillaCodec : object {
    private static GorillaCodec();
    internal byte FindPacketAlgoByte(Int32[] input, bool testDelDel);
    internal byte FindPropAlgoByte(Byte[] input);
    internal void GetPropertyBitCount(byte algorithmByte, Int32& countPerItem, Int32& bitCount, Int32& padCount);
    internal void Compress(int bitCount, Int32[] input, int startInputIndex, DeltaDelta dtxf, List`1<byte> compressedData);
    internal void Compress(int bitCount, BitStreamReader reader, GorillaEncodingType encodingType, int unitsToEncode, List`1<byte> compressedData);
    internal UInt32 Uncompress(int bitCount, Byte[] input, int inputIndex, DeltaDelta dtxf, Int32[] outputBuffer, int outputBufferIndex);
    internal Byte[] Uncompress(int bitCount, BitStreamReader reader, GorillaEncodingType encodingType, int unitsToDecode);
}
internal enum MS.Internal.Ink.InkSerializedFormat.GorillaEncodingType : Enum {
    public int value__;
    public static GorillaEncodingType Byte;
    public static GorillaEncodingType Short;
    public static GorillaEncodingType Int;
}
internal class MS.Internal.Ink.InkSerializedFormat.GuidList : object {
    public bool Add(Guid guid);
    public static KnownTagIndex FindKnownTag(Guid guid);
    public KnownTagIndex FindTag(Guid guid, bool bFindInKnownListFirst);
    public Guid FindGuid(KnownTagIndex tag);
    public static UInt32 GetDataSizeIfKnownGuid(Guid guid);
    public UInt32 Save(Stream stream);
    public UInt32 Load(Stream strm, UInt32 size);
}
internal class MS.Internal.Ink.InkSerializedFormat.HuffCodec : object {
    internal HuffCodec(UInt32 defaultIndex);
    private static HuffCodec();
    internal void Compress(DataXform dataXf, Int32[] input, List`1<byte> compressedData);
    internal UInt32 Uncompress(DataXform dtxf, Byte[] input, int startIndex, Int32[] outputBuffer);
    internal byte Encode(int data, int extra, BitStreamWriter writer);
    internal void Decode(Int32& data, Int32& extra, BitStreamReader reader);
}
internal class MS.Internal.Ink.InkSerializedFormat.HuffModule : object {
    internal HuffCodec GetDefCodec(UInt32 index);
    internal HuffCodec FindCodec(byte algoData);
    internal DataXform FindDtXf(byte algoData);
}
internal static class MS.Internal.Ink.InkSerializedFormat.KnownIdCache : object {
    public static Guid[] OriginalISFIdTable;
    public static UInt32[] OriginalISFIdPersistenceSize;
    public static Guid[] TabletInternalIdTable;
    internal static KnownTagIndex KnownGuidBaseIndex;
    internal static UInt32 MaximumPossibleKnownGuidIndex;
    internal static UInt32 CustomGuidBaseIndex;
    public static Guid[] ExtendedISFIdTable;
    private static KnownIdCache();
}
internal static class MS.Internal.Ink.InkSerializedFormat.KnownTagCache : object {
    internal static UInt32 MaximumPossibleKnownTags;
    internal static UInt32 KnownTagCount;
    private static KnownTagCache();
}
internal class MS.Internal.Ink.InkSerializedFormat.LZCodec : object {
    private static LZCodec();
    internal Byte[] Uncompress(Byte[] input, int inputIndex);
}
internal static class MS.Internal.Ink.InkSerializedFormat.MathHelper : object {
    internal static int AbsNoThrow(int data);
    internal static long AbsNoThrow(long data);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricBlock : object {
    public UInt32 MetricEntryCount { get; }
    public UInt32 Size { get; }
    public MetricEntry GetMetricEntryList();
    public UInt32 get_MetricEntryCount();
    public UInt32 get_Size();
    public void AddMetricEntry(MetricEntry newEntry);
    public MetricEntryType AddMetricEntry(StylusPointPropertyInfo property, KnownTagIndex tag);
    public UInt32 Pack(Stream strm);
    public bool CompareMetricBlock(MetricBlock metricColl, SetType& setType);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricEntry : object {
    public static StylusPointPropertyInfo DefaultXMetric;
    public static StylusPointPropertyInfo DefaultYMetric;
    public static MetricEntryList[] MetricEntry_Optional { get; }
    public KnownTagIndex Tag { get; public set; }
    public UInt32 Size { get; }
    public Byte[] Data { get; public set; }
    public MetricEntry Next { get; public set; }
    private static MetricEntry();
    public static MetricEntryList[] get_MetricEntry_Optional();
    public KnownTagIndex get_Tag();
    public void set_Tag(KnownTagIndex value);
    public UInt32 get_Size();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public bool Compare(MetricEntry metricEntry);
    public MetricEntry get_Next();
    public void set_Next(MetricEntry value);
    public void Add(MetricEntry next);
    public void Initialize(StylusPointPropertyInfo originalInfo, StylusPointPropertyInfo defaultInfo);
    public MetricEntryType CreateMetricEntry(StylusPointPropertyInfo propertyInfo, KnownTagIndex tag);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricEntryList : ValueType {
    public KnownTagIndex Tag;
    public StylusPointPropertyInfo PropertyMetrics;
    public MetricEntryList(KnownTagIndex tag, StylusPointPropertyInfo prop);
}
internal enum MS.Internal.Ink.InkSerializedFormat.MetricEntryType : Enum {
    public int value__;
    public static MetricEntryType Optional;
    public static MetricEntryType Must;
    public static MetricEntryType Never;
    public static MetricEntryType Custom;
}
internal class MS.Internal.Ink.InkSerializedFormat.MultiByteCodec : object {
    internal void Encode(UInt32 data, List`1<byte> output);
    internal void SignEncode(int data, List`1<byte> output);
    internal UInt32 Decode(Byte[] input, int inputIndex, UInt32& data);
    internal UInt32 SignDecode(Byte[] input, int inputIndex, Int32& data);
}
internal static class MS.Internal.Ink.InkSerializedFormat.SerializationHelper : object {
    public static UInt32 VarSize(UInt32 Value);
    public static UInt32 Encode(Stream strm, UInt32 Value);
    public static UInt32 EncodeLarge(Stream strm, ulong ulValue);
    public static UInt32 SignEncode(Stream strm, int Value);
    public static UInt32 Decode(Stream strm, UInt32& dw);
    public static UInt32 DecodeLarge(Stream strm, UInt64& ull);
    public static UInt32 SignDecode(Stream strm, Int32& i);
    public static VarEnum ConvertToVarEnum(Type type, bool throwOnError);
}
internal enum MS.Internal.Ink.InkSerializedFormat.SetType : Enum {
    public int value__;
    public static SetType SubSet;
    public static SetType SuperSet;
}
internal class MS.Internal.Ink.InkSerializedFormat.StrokeCollectionSerializer : object {
    internal static double AvalonToHimetricMultiplier;
    internal static double HimetricToAvalonMultiplier;
    internal static TransformDescriptor IdentityTransformDescriptor;
    internal PersistenceFormat CurrentPersistenceFormat;
    internal CompressionMode CurrentCompressionMode;
    internal List`1<int> StrokeIds;
    private static StrokeCollectionSerializer();
    internal StrokeCollectionSerializer(StrokeCollection coreStrokes);
    internal void DecodeISF(Stream inkData);
    internal UInt32 LoadStrokeIds(Stream isfStream, UInt32 cbSize);
    internal static UInt32 ReliableRead(Stream stream, Byte[] buffer, UInt32 requestedCount);
    internal void EncodeISF(Stream outputStream);
    internal static UInt32 SaveStrokeIds(StrokeCollection strokes, Stream strm, bool forceSave);
    internal static string ISFDebugMessage(string debugMessage);
}
internal class MS.Internal.Ink.InkSerializedFormat.StrokeDescriptor : object {
    public UInt32 Size { get; public set; }
    public List`1<KnownTagIndex> Template { get; }
    public UInt32 get_Size();
    public void set_Size(UInt32 value);
    public List`1<KnownTagIndex> get_Template();
    public bool IsEqual(StrokeDescriptor strd);
}
internal static class MS.Internal.Ink.InkSerializedFormat.StrokeIdGenerator : object {
    internal static Int32[] GetStrokeIds(StrokeCollection strokes);
}
internal static class MS.Internal.Ink.InkSerializedFormat.StrokeSerializer : object {
    internal static UInt32 DecodeStroke(Stream stream, UInt32 size, GuidList guidList, StrokeDescriptor strokeDescriptor, StylusPointDescription stylusPointDescription, DrawingAttributes drawingAttributes, Matrix transform, Stroke& stroke);
    internal static UInt32 EncodeStroke(Stroke stroke, Stream stream, byte compressionAlgorithm, GuidList guidList, StrokeLookupEntry strokeLookupEntry);
    internal static void BuildStrokeDescriptor(Stroke stroke, GuidList guidList, StrokeLookupEntry strokeLookupEntry, StrokeDescriptor& strokeDescriptor, MetricBlock& metricBlock);
}
internal class MS.Internal.Ink.InkSerializedFormat.TransformDescriptor : object {
    public KnownTagIndex Tag { get; public set; }
    public UInt32 Size { get; public set; }
    public Double[] Transform { get; }
    public KnownTagIndex get_Tag();
    public void set_Tag(KnownTagIndex value);
    public UInt32 get_Size();
    public void set_Size(UInt32 value);
    public Double[] get_Transform();
    public bool Compare(TransformDescriptor that);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.Lasso : object {
    internal Rect Bounds { get; internal set; }
    internal bool IsEmpty { get; }
    internal int PointCount { get; }
    internal Point Item { get; }
    internal bool IsIncrementalLassoDirty { get; internal set; }
    protected List`1<Point> PointsList { get; }
    private static Lasso();
    internal Rect get_Bounds();
    internal void set_Bounds(Rect value);
    internal bool get_IsEmpty();
    internal int get_PointCount();
    internal Point get_Item(int index);
    internal void AddPoints(IEnumerable`1<Point> points);
    internal void AddPoint(Point point);
    internal bool Contains(Point point);
    internal StrokeIntersection[] HitTest(StrokeNodeIterator iterator);
    internal bool get_IsIncrementalLassoDirty();
    internal void set_IsIncrementalLassoDirty(bool value);
    protected List`1<Point> get_PointsList();
    protected virtual bool Filter(Point point);
    protected virtual void AddPointImpl(Point point);
}
internal static class MS.Internal.Ink.Native : object {
    internal static UInt32 SizeOfInt;
    internal static UInt32 SizeOfUInt;
    internal static UInt32 SizeOfUShort;
    internal static UInt32 SizeOfByte;
    internal static UInt32 SizeOfFloat;
    internal static UInt32 SizeOfDouble;
    internal static UInt32 SizeOfGuid;
    internal static UInt32 SizeOfDecimal;
    internal static int BitsPerByte;
    internal static int BitsPerShort;
    internal static int BitsPerInt;
    internal static int BitsPerLong;
    internal static int MaxFloatToIntValue;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Native();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.Quad : ValueType {
    private Point _A;
    private Point _B;
    private Point _C;
    private Point _D;
    internal static Quad Empty { get; }
    internal Point A { get; internal set; }
    internal Point B { get; internal set; }
    internal Point C { get; internal set; }
    internal Point D { get; internal set; }
    internal Point Item { get; }
    internal bool IsEmpty { get; }
    internal Rect Bounds { get; }
    internal Quad(Point a, Point b, Point c, Point d);
    private static Quad();
    internal static Quad get_Empty();
    internal Point get_A();
    internal void set_A(Point value);
    internal Point get_B();
    internal void set_B(Point value);
    internal Point get_C();
    internal void set_C(Point value);
    internal Point get_D();
    internal void set_D(Point value);
    internal Point get_Item(int index);
    internal bool get_IsEmpty();
    internal void GetPoints(List`1<Point> pointBuffer);
    internal Rect get_Bounds();
}
internal class MS.Internal.Ink.SingleLoopLasso : Lasso {
    private static SingleLoopLasso();
    protected virtual bool Filter(Point point);
    protected virtual void AddPointImpl(Point point);
    internal static double AdjustFIndex(double findex);
}
internal class MS.Internal.Ink.StrokeFIndices : ValueType {
    private double _beginFIndex;
    private double _endFIndex;
    internal static double BeforeFirst { get; }
    internal static double AfterLast { get; }
    internal double BeginFIndex { get; internal set; }
    internal double EndFIndex { get; internal set; }
    internal static StrokeFIndices Empty { get; }
    internal static StrokeFIndices Full { get; }
    internal bool IsEmpty { get; }
    internal bool IsFull { get; }
    internal StrokeFIndices(double beginFIndex, double endFIndex);
    private static StrokeFIndices();
    internal static double get_BeforeFirst();
    internal static double get_AfterLast();
    internal double get_BeginFIndex();
    internal void set_BeginFIndex(double value);
    internal double get_EndFIndex();
    internal void set_EndFIndex(double value);
    public virtual string ToString();
    public sealed virtual bool Equals(StrokeFIndices strokeFIndices);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StrokeFIndices sfiLeft, StrokeFIndices sfiRight);
    public static bool op_Inequality(StrokeFIndices sfiLeft, StrokeFIndices sfiRight);
    internal static string GetStringRepresentation(double fIndex);
    internal static StrokeFIndices get_Empty();
    internal static StrokeFIndices get_Full();
    internal bool get_IsEmpty();
    internal bool get_IsFull();
    internal int CompareTo(StrokeFIndices fIndices);
}
internal class MS.Internal.Ink.StrokeInfo : object {
    internal Stroke Stroke { get; }
    internal Rect StrokeBounds { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsHit { get; internal set; }
    internal StylusPointCollection StylusPoints { get; }
    internal double HitWeight { get; internal set; }
    internal double TotalWeight { get; }
    internal StrokeInfo(Stroke stroke);
    internal Stroke get_Stroke();
    internal Rect get_StrokeBounds();
    internal bool get_IsDirty();
    internal void set_IsDirty(bool value);
    internal bool get_IsHit();
    internal void set_IsHit(bool value);
    internal StylusPointCollection get_StylusPoints();
    internal double get_HitWeight();
    internal void set_HitWeight(double value);
    internal double get_TotalWeight();
    internal double GetPointWeight(int index);
    internal void Detach();
}
internal class MS.Internal.Ink.StrokeNode : ValueType {
    private StrokeNodeOperations _operations;
    private int _index;
    private StrokeNodeData _thisNode;
    private StrokeNodeData _lastNode;
    private bool _isQuadCached;
    private Quad _connectingQuad;
    private bool _isLastNode;
    internal Point Position { get; }
    internal Point PreviousPosition { get; }
    internal float PressureFactor { get; }
    internal float PreviousPressureFactor { get; }
    internal bool IsEllipse { get; }
    internal bool IsLastNode { get; }
    internal int Index { get; }
    internal bool IsValid { get; }
    internal StrokeNode(StrokeNodeOperations operations, int index, StrokeNodeData nodeData, StrokeNodeData lastNodeData, bool isLastNode);
    internal Point get_Position();
    internal Point get_PreviousPosition();
    internal float get_PressureFactor();
    internal float get_PreviousPressureFactor();
    internal bool get_IsEllipse();
    internal bool get_IsLastNode();
    internal Rect GetBounds();
    internal Rect GetBoundsConnected();
    internal void GetContourPoints(List`1<Point> pointBuffer);
    internal void GetPreviousContourPoints(List`1<Point> pointBuffer);
    internal Quad GetConnectingQuad();
    internal void GetPointsAtStartOfSegment(List`1<Point> abPoints, List`1<Point> dcPoints);
    internal void GetPointsAtEndOfSegment(List`1<Point> abPoints, List`1<Point> dcPoints);
    internal void GetPointsAtMiddleSegment(StrokeNode previous, double angleBetweenNodes, List`1<Point> abPoints, List`1<Point> dcPoints, Boolean& missingIntersection);
    internal static Point GetIntersection(Point line1Start, Point line1End, Point line2Start, Point line2End);
    internal bool HitTest(StrokeNode hitNode);
    internal StrokeFIndices CutTest(StrokeNode hitNode);
    internal StrokeFIndices CutTest(Point begin, Point end);
    internal int get_Index();
    internal bool get_IsValid();
    internal Point GetPointAt(double findex);
}
internal class MS.Internal.Ink.StrokeNodeData : ValueType {
    private Point _position;
    private float _pressure;
    internal static StrokeNodeData Empty { get; }
    internal bool IsEmpty { get; }
    internal Point Position { get; }
    internal float PressureFactor { get; }
    internal StrokeNodeData(Point position);
    internal StrokeNodeData(Point position, float pressure);
    private static StrokeNodeData();
    internal static StrokeNodeData get_Empty();
    internal bool get_IsEmpty();
    internal Point get_Position();
    internal float get_PressureFactor();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.StrokeNodeIterator : object {
    internal int Count { get; }
    internal StrokeNode Item { get; }
    internal StrokeNode Item { get; }
    internal StrokeNodeIterator(StylusShape nodeShape);
    internal StrokeNodeIterator(DrawingAttributes drawingAttributes);
    internal StrokeNodeIterator(StylusPointCollection stylusPoints, StrokeNodeOperations operations, bool usePressure);
    internal static StrokeNodeIterator GetIterator(Stroke stroke, DrawingAttributes drawingAttributes);
    internal static StrokeNodeIterator GetIterator(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    internal StrokeNodeIterator GetIteratorForNextSegment(StylusPointCollection stylusPoints);
    internal StrokeNodeIterator GetIteratorForNextSegment(Point[] points);
    internal int get_Count();
    internal StrokeNode get_Item(int index);
    internal StrokeNode get_Item(int index, int previousIndex);
}
internal class MS.Internal.Ink.StrokeNodeOperations : object {
    protected Vector[] _vertices;
    internal bool IsNodeShapeEllipse { get; }
    internal StrokeNodeOperations(StylusShape nodeShape);
    internal static StrokeNodeOperations CreateInstance(StylusShape nodeShape);
    internal virtual bool get_IsNodeShapeEllipse();
    internal Rect GetNodeBounds(StrokeNodeData node);
    internal void GetNodeContourPoints(StrokeNodeData node, List`1<Point> pointBuffer);
    [IteratorStateMachineAttribute("MS.Internal.Ink.StrokeNodeOperations/<GetContourSegments>d__6")]
internal virtual IEnumerable`1<ContourSegment> GetContourSegments(StrokeNodeData node, Quad quad);
    internal virtual IEnumerable`1<ContourSegment> GetNonBezierContourSegments(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual Quad GetConnectingQuad(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    internal Vector[] GetVertices();
    protected bool IsInvalidCutTestResult(StrokeFIndices result);
    internal static bool HitTestPolygonSegment(Vector[] vertices, Vector hitBegin, Vector hitEnd);
    internal static bool HitTestQuadSegment(Quad quad, Point hitBegin, Point hitEnd);
    internal static bool HitTestPolygonCircle(Vector[] vertices, Vector center, Vector radius);
    internal static bool HitTestQuadCircle(Quad quad, Point center, Vector radius);
    internal static HitResult WhereIsSegmentAboutSegment(Vector hitBegin, Vector hitEnd, Vector orgBegin, Vector orgEnd);
    internal static HitResult WhereIsCircleAboutSegment(Vector center, Vector radius, Vector segBegin, Vector segEnd);
    internal static HitResult WhereIsVectorAboutVector(Vector vector1, Vector vector2);
    internal static HitResult WhereIsVectorAboutArc(Vector hitVector, Vector arcBegin, Vector arcEnd);
    internal static Vector TurnLeft(Vector vector);
    internal static Vector TurnRight(Vector vector);
    internal static bool IsOutside(HitResult hitResult, HitResult prevHitResult);
    internal static double GetPositionBetweenLines(Vector linesVector, Vector nextLine, Vector hitPoint);
    internal static double GetProjectionFIndex(Vector begin, Vector end);
    internal static Vector GetProjection(Vector begin, Vector end);
    internal static Vector GetNearest(Vector begin, Vector end);
    internal static double AdjustFIndex(double findex);
}
internal static class MS.Internal.Ink.StrokeRenderer : object {
    internal static double HighlighterOpacity;
    internal static byte SolidStrokeAlpha;
    internal static Point ArcToMarker;
    private static StrokeRenderer();
    internal static void CalcGeometryAndBoundsWithTransform(StrokeNodeIterator iterator, DrawingAttributes drawingAttributes, MatrixTypes stylusTipMatrixType, bool calculateBounds, Geometry& geometry, Rect& bounds);
    [FriendAccessAllowedAttribute]
internal static void CalcGeometryAndBounds(StrokeNodeIterator iterator, DrawingAttributes drawingAttributes, bool calculateBounds, Geometry& geometry, Rect& bounds);
    internal static DrawingAttributes GetHighlighterAttributes(Stroke stroke, DrawingAttributes da);
    internal static Color GetHighlighterColor(Color color);
}
internal static class MS.Internal.Interop.TipTsfHelper : object {
    private static TipTsfHelper();
    [SecuritySafeCriticalAttribute]
internal static void Show(DependencyObject focusedObject);
    [SecuritySafeCriticalAttribute]
internal static void Hide(DependencyObject focusedObject);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.ByteRangeDownloader : object {
    unknown IWebProxy Proxy {internal set; }
    unknown ICredentials Credentials {internal set; }
    unknown RequestCachePolicy CachePolicy {internal set; }
    internal Mutex FileMutex { get; }
    internal bool ErroredOut { get; }
    [SecurityCriticalAttribute]
internal ByteRangeDownloader(Uri requestedUri, string tempFileName, SafeWaitHandle eventHandle);
    [SecurityCriticalAttribute]
internal ByteRangeDownloader(Uri requestedUri, Stream tempStream, SafeWaitHandle eventHandle, Mutex fileMutex);
    public sealed virtual void Dispose();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    internal Int32[0...,0...] GetDownloadedByteRanges();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void RequestByteRanges(Int32[0...,0...] byteRanges);
    internal static Int32[0...,0...] ConvertByteRanges(Int32[] inByteRanges);
    internal static Int32[] ConvertByteRanges(Int32[0...,0...] inByteRanges);
    [SecurityCriticalAttribute]
internal void set_Proxy(IWebProxy value);
    internal void set_Credentials(ICredentials value);
    internal void set_CachePolicy(RequestCachePolicy value);
    internal Mutex get_FileMutex();
    internal bool get_ErroredOut();
}
internal class MS.Internal.IO.Packaging.DeobfuscatingStream : Stream {
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal DeobfuscatingStream(Stream obfuscatedStream, Uri streamUri, bool leaveOpen);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.NetStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    [SecurityCriticalAttribute]
internal NetStream(Stream responseStream, long fullStreamLength, Uri uri, WebRequest originalRequest, WebResponse originalResponse);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual long get_Length();
    public virtual void Flush();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void Dispose(bool disposing);
}
[FriendAccessAllowedAttribute]
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.IO.Packaging.PreloadedPackages : object {
    private static PreloadedPackages();
    internal static Package GetPackage(Uri uri);
    internal static Package GetPackage(Uri uri, Boolean& threadSafe);
    internal static void AddPackage(Uri uri, Package package);
    internal static void AddPackage(Uri uri, Package package, bool threadSafe);
    internal static void RemovePackage(Uri uri);
    internal static void Clear();
}
internal class MS.Internal.IO.Packaging.PseudoWebRequest : WebRequest {
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    internal PseudoWebRequest(Uri uri, Uri packageUri, Uri partUri, Package cacheEntry);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
}
internal class MS.Internal.IO.Packaging.ResponseStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal ResponseStream(Stream s, PackWebResponse response, Stream owningStream, Package container);
    internal ResponseStream(Stream s, PackWebResponse response);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.SynchronizingStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal SynchronizingStream(Stream stream, object syncRoot);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
}
internal enum MS.Internal.ItemClass : Enum {
    public byte value__;
    public static ItemClass DigitClass;
    public static ItemClass ANClass;
    public static ItemClass CSClass;
    public static ItemClass ESClass;
    public static ItemClass ETClass;
    public static ItemClass StrongClass;
    public static ItemClass WeakClass;
    public static ItemClass SimpleMarkClass;
    public static ItemClass ComplexMarkClass;
    public static ItemClass ControlClass;
    public static ItemClass JoinerClass;
    public static ItemClass NumberSignClass;
    public static ItemClass MaxClass;
}
internal interface MS.Internal.IVisual3DContainer {
    public abstract virtual void AddChild(Visual3D child);
    public abstract virtual void RemoveChild(Visual3D child);
    public abstract virtual int GetChildrenCount();
    public abstract virtual Visual3D GetChild(int index);
    public abstract virtual void VerifyAPIReadOnly();
    public abstract virtual void VerifyAPIReadOnly(DependencyObject other);
    public abstract virtual void VerifyAPIReadWrite();
    public abstract virtual void VerifyAPIReadWrite(DependencyObject other);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.FillRuleBoxes : object {
    internal static object EvenOddBox;
    internal static object NonzeroBox;
    private static FillRuleBoxes();
    internal static object Box(FillRule value);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.VisibilityBoxes : object {
    internal static object VisibleBox;
    internal static object HiddenBox;
    internal static object CollapsedBox;
    private static VisibilityBoxes();
    internal static object Box(Visibility value);
}
internal enum MS.Internal.LanguageTags : Enum {
    public int value__;
    public static LanguageTags Abaza;
    public static LanguageTags Abkhazian;
    public static LanguageTags Adyghe;
    public static LanguageTags Afrikaans;
    public static LanguageTags Afar;
    public static LanguageTags Agaw;
    public static LanguageTags Altai;
    public static LanguageTags Amharic;
    public static LanguageTags Arabic;
    public static LanguageTags Aari;
    public static LanguageTags Arakanese;
    public static LanguageTags Assamese;
    public static LanguageTags Athapaskan;
    public static LanguageTags Avar;
    public static LanguageTags Awadhi;
    public static LanguageTags Aymara;
    public static LanguageTags Azeri;
    public static LanguageTags Badaga;
    public static LanguageTags Baghelkhandi;
    public static LanguageTags Balkar;
    public static LanguageTags Baule;
    public static LanguageTags Berber;
    public static LanguageTags Bench;
    public static LanguageTags BibleCree;
    public static LanguageTags Belarussian;
    public static LanguageTags Bemba;
    public static LanguageTags Bengali;
    public static LanguageTags Bulgarian;
    public static LanguageTags Bhili;
    public static LanguageTags Bhojpuri;
    public static LanguageTags Bikol;
    public static LanguageTags Bilen;
    public static LanguageTags Blackfoot;
    public static LanguageTags Balochi;
    public static LanguageTags Balante;
    public static LanguageTags Balti;
    public static LanguageTags Bambara;
    public static LanguageTags Bamileke;
    public static LanguageTags Breton;
    public static LanguageTags Brahui;
    public static LanguageTags BrajBhasha;
    public static LanguageTags Burmese;
    public static LanguageTags Bashkir;
    public static LanguageTags Beti;
    public static LanguageTags Catalan;
    public static LanguageTags Cebuano;
    public static LanguageTags Chechen;
    public static LanguageTags ChahaGurage;
    public static LanguageTags Chattisgarhi;
    public static LanguageTags Chichewa;
    public static LanguageTags Chukchi;
    public static LanguageTags Chipewyan;
    public static LanguageTags Cherokee;
    public static LanguageTags Chuvash;
    public static LanguageTags Comorian;
    public static LanguageTags Coptic;
    public static LanguageTags Cree;
    public static LanguageTags Carrier;
    public static LanguageTags CrimeanTatar;
    public static LanguageTags ChurchSlavonic;
    public static LanguageTags Czech;
    public static LanguageTags Danish;
    public static LanguageTags Dargwa;
    public static LanguageTags WoodsCree;
    public static LanguageTags German;
    public static LanguageTags Default;
    public static LanguageTags Dogri;
    public static LanguageTags Divehi;
    public static LanguageTags Djerma;
    public static LanguageTags Dangme;
    public static LanguageTags Dinka;
    public static LanguageTags Dungan;
    public static LanguageTags Dzongkha;
    public static LanguageTags Ebira;
    public static LanguageTags EasternCree;
    public static LanguageTags Edo;
    public static LanguageTags Efik;
    public static LanguageTags Greek;
    public static LanguageTags English;
    public static LanguageTags Erzya;
    public static LanguageTags Spanish;
    public static LanguageTags Estonian;
    public static LanguageTags Basque;
    public static LanguageTags Evenki;
    public static LanguageTags Even;
    public static LanguageTags Ewe;
    public static LanguageTags FrenchAntillean;
    public static LanguageTags Farsi;
    public static LanguageTags Finnish;
    public static LanguageTags Fijian;
    public static LanguageTags Flemish;
    public static LanguageTags ForestNenets;
    public static LanguageTags Fon;
    public static LanguageTags Faroese;
    public static LanguageTags French;
    public static LanguageTags Frisian;
    public static LanguageTags Friulian;
    public static LanguageTags Futa;
    public static LanguageTags Fulani;
    public static LanguageTags Ga;
    public static LanguageTags Gaelic;
    public static LanguageTags Gagauz;
    public static LanguageTags Galician;
    public static LanguageTags Garshuni;
    public static LanguageTags Garhwali;
    public static LanguageTags Geez;
    public static LanguageTags Gilyak;
    public static LanguageTags Gumuz;
    public static LanguageTags Gondi;
    public static LanguageTags Greenlandic;
    public static LanguageTags Garo;
    public static LanguageTags Guarani;
    public static LanguageTags Gujarati;
    public static LanguageTags Haitian;
    public static LanguageTags Halam;
    public static LanguageTags Harauti;
    public static LanguageTags Hausa;
    public static LanguageTags Hawaiin;
    public static LanguageTags HammerBanna;
    public static LanguageTags Hiligaynon;
    public static LanguageTags Hindi;
    public static LanguageTags HighMari;
    public static LanguageTags Hindko;
    public static LanguageTags Ho;
    public static LanguageTags Harari;
    public static LanguageTags Croatian;
    public static LanguageTags Hungarian;
    public static LanguageTags Armenian;
    public static LanguageTags Igbo;
    public static LanguageTags Ijo;
    public static LanguageTags Ilokano;
    public static LanguageTags Indonesian;
    public static LanguageTags Ingush;
    public static LanguageTags Inuktitut;
    public static LanguageTags Irish;
    public static LanguageTags IrishTraditional;
    public static LanguageTags Icelandic;
    public static LanguageTags InariSami;
    public static LanguageTags Italian;
    public static LanguageTags Hebrew;
    public static LanguageTags Javanese;
    public static LanguageTags Yiddish;
    public static LanguageTags Japanese;
    public static LanguageTags Judezmo;
    public static LanguageTags Jula;
    public static LanguageTags Kabardian;
    public static LanguageTags Kachchi;
    public static LanguageTags Kalenjin;
    public static LanguageTags Kannada;
    public static LanguageTags Karachay;
    public static LanguageTags Georgian;
    public static LanguageTags Kazakh;
    public static LanguageTags Kebena;
    public static LanguageTags KhutsuriGeorgian;
    public static LanguageTags Khakass;
    public static LanguageTags KhantyKazim;
    public static LanguageTags Khmer;
    public static LanguageTags KhantyShurishkar;
    public static LanguageTags KhantyVakhi;
    public static LanguageTags Khowar;
    public static LanguageTags Kikuyu;
    public static LanguageTags Kirghiz;
    public static LanguageTags Kisii;
    public static LanguageTags Kokni;
    public static LanguageTags Kalmyk;
    public static LanguageTags Kamba;
    public static LanguageTags Kumaoni;
    public static LanguageTags Komo;
    public static LanguageTags Komso;
    public static LanguageTags Kanuri;
    public static LanguageTags Kodagu;
    public static LanguageTags KoreanOldHangul;
    public static LanguageTags Konkani;
    public static LanguageTags Kikongo;
    public static LanguageTags KomiPermyak;
    public static LanguageTags Korean;
    public static LanguageTags KomiZyrian;
    public static LanguageTags Kpelle;
    public static LanguageTags Krio;
    public static LanguageTags Karakalpak;
    public static LanguageTags Karelian;
    public static LanguageTags Karaim;
    public static LanguageTags Karen;
    public static LanguageTags Koorete;
    public static LanguageTags Kashmiri;
    public static LanguageTags Khasi;
    public static LanguageTags KildinSami;
    public static LanguageTags Kui;
    public static LanguageTags Kulvi;
    public static LanguageTags Kumyk;
    public static LanguageTags Kurdish;
    public static LanguageTags Kurukh;
    public static LanguageTags Kuy;
    public static LanguageTags Koryak;
    public static LanguageTags Ladin;
    public static LanguageTags Lahuli;
    public static LanguageTags Lak;
    public static LanguageTags Lambani;
    public static LanguageTags Lao;
    public static LanguageTags Latin;
    public static LanguageTags Laz;
    public static LanguageTags LCree;
    public static LanguageTags Ladakhi;
    public static LanguageTags Lezgi;
    public static LanguageTags Lingala;
    public static LanguageTags LowMari;
    public static LanguageTags Limbu;
    public static LanguageTags Lomwe;
    public static LanguageTags LowerSorbian;
    public static LanguageTags LuleSami;
    public static LanguageTags Lithuanian;
    public static LanguageTags Luba;
    public static LanguageTags Luganda;
    public static LanguageTags Luhya;
    public static LanguageTags Luo;
    public static LanguageTags Latvian;
    public static LanguageTags Majang;
    public static LanguageTags Makua;
    public static LanguageTags MalayalamTraditional;
    public static LanguageTags Mansi;
    public static LanguageTags Marathi;
    public static LanguageTags Marwari;
    public static LanguageTags Mbundu;
    public static LanguageTags Manchu;
    public static LanguageTags MooseCree;
    public static LanguageTags Mende;
    public static LanguageTags Meen;
    public static LanguageTags Mizo;
    public static LanguageTags Macedonian;
    public static LanguageTags Male;
    public static LanguageTags Malagasy;
    public static LanguageTags Malinke;
    public static LanguageTags MalayalamReformed;
    public static LanguageTags Malay;
    public static LanguageTags Mandinka;
    public static LanguageTags Mongolian;
    public static LanguageTags Manipuri;
    public static LanguageTags Maninka;
    public static LanguageTags ManxGaelic;
    public static LanguageTags Moksha;
    public static LanguageTags Moldavian;
    public static LanguageTags Mon;
    public static LanguageTags Moroccan;
    public static LanguageTags Maori;
    public static LanguageTags Maithili;
    public static LanguageTags Maltese;
    public static LanguageTags Mundari;
    public static LanguageTags NagaAssamese;
    public static LanguageTags Nanai;
    public static LanguageTags Naskapi;
    public static LanguageTags NCree;
    public static LanguageTags Ndebele;
    public static LanguageTags Ndonga;
    public static LanguageTags Nepali;
    public static LanguageTags Newari;
    public static LanguageTags NorwayHouseCree;
    public static LanguageTags Nisi;
    public static LanguageTags Niuean;
    public static LanguageTags Nkole;
    public static LanguageTags Nko;
    public static LanguageTags Dutch;
    public static LanguageTags Nogai;
    public static LanguageTags Norwegian;
    public static LanguageTags NorthernSami;
    public static LanguageTags NorthernTai;
    public static LanguageTags Esperanto;
    public static LanguageTags Nynorsk;
    public static LanguageTags OjiCree;
    public static LanguageTags Ojibway;
    public static LanguageTags Oriya;
    public static LanguageTags Oromo;
    public static LanguageTags Ossetian;
    public static LanguageTags PalestinianAramaic;
    public static LanguageTags Pali;
    public static LanguageTags Punjabi;
    public static LanguageTags Palpa;
    public static LanguageTags Pashto;
    public static LanguageTags PolytonicGreek;
    public static LanguageTags Pilipino;
    public static LanguageTags Palaung;
    public static LanguageTags Polish;
    public static LanguageTags Provencal;
    public static LanguageTags Portuguese;
    public static LanguageTags Chin;
    public static LanguageTags Rajasthani;
    public static LanguageTags RCree;
    public static LanguageTags RussianBuriat;
    public static LanguageTags Riang;
    public static LanguageTags RhaetoRomanic;
    public static LanguageTags Romanian;
    public static LanguageTags Romany;
    public static LanguageTags Rusyn;
    public static LanguageTags Ruanda;
    public static LanguageTags Russian;
    public static LanguageTags Sadri;
    public static LanguageTags Sanskrit;
    public static LanguageTags Santali;
    public static LanguageTags Sayisi;
    public static LanguageTags Sekota;
    public static LanguageTags Selkup;
    public static LanguageTags Sango;
    public static LanguageTags Shan;
    public static LanguageTags Sibe;
    public static LanguageTags Sidamo;
    public static LanguageTags SilteGurage;
    public static LanguageTags SkoltSami;
    public static LanguageTags Slovak;
    public static LanguageTags Slavey;
    public static LanguageTags Slovenian;
    public static LanguageTags Somali;
    public static LanguageTags Samoan;
    public static LanguageTags Sena;
    public static LanguageTags Sindhi;
    public static LanguageTags Sinhalese;
    public static LanguageTags Soninke;
    public static LanguageTags SodoGurage;
    public static LanguageTags Sotho;
    public static LanguageTags Albanian;
    public static LanguageTags Serbian;
    public static LanguageTags Saraiki;
    public static LanguageTags Serer;
    public static LanguageTags SouthSlavey;
    public static LanguageTags SouthernSami;
    public static LanguageTags Suri;
    public static LanguageTags Svan;
    public static LanguageTags Swedish;
    public static LanguageTags SwadayaAramaic;
    public static LanguageTags Swahili;
    public static LanguageTags Swazi;
    public static LanguageTags Sutu;
    public static LanguageTags Syriac;
    public static LanguageTags Tabasaran;
    public static LanguageTags Tajiki;
    public static LanguageTags Tamil;
    public static LanguageTags Tatar;
    public static LanguageTags THCree;
    public static LanguageTags Telugu;
    public static LanguageTags Tongan;
    public static LanguageTags Tigre;
    public static LanguageTags Tigrinya;
    public static LanguageTags Thai;
    public static LanguageTags Tahitian;
    public static LanguageTags Tibetan;
    public static LanguageTags Turkmen;
    public static LanguageTags Temne;
    public static LanguageTags Tswana;
    public static LanguageTags TundraNenets;
    public static LanguageTags Tonga;
    public static LanguageTags Todo;
    public static LanguageTags Turkish;
    public static LanguageTags Tsonga;
    public static LanguageTags TuroyoAramaic;
    public static LanguageTags Tulu;
    public static LanguageTags Tuvin;
    public static LanguageTags Twi;
    public static LanguageTags Udmurt;
    public static LanguageTags Ukrainian;
    public static LanguageTags Urdu;
    public static LanguageTags UpperSorbian;
    public static LanguageTags Uyghur;
    public static LanguageTags Uzbek;
    public static LanguageTags Venda;
    public static LanguageTags Vietnamese;
    public static LanguageTags Wa;
    public static LanguageTags Wagdi;
    public static LanguageTags WestCree;
    public static LanguageTags Welsh;
    public static LanguageTags Wolof;
    public static LanguageTags TaiLue;
    public static LanguageTags Xhosa;
    public static LanguageTags Yakut;
    public static LanguageTags Yoruba;
    public static LanguageTags YCree;
    public static LanguageTags YiClassic;
    public static LanguageTags YiModern;
    public static LanguageTags ChineseHongKong;
    public static LanguageTags ChinesePhonetic;
    public static LanguageTags ChineseSimplified;
    public static LanguageTags ChineseTraditional;
    public static LanguageTags Zande;
    public static LanguageTags Zulu;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.LoadedOrUnloadedOperation : object {
    internal LoadedOrUnloadedOperation(DispatcherOperationCallback callback, DependencyObject target);
    internal void DoWork();
    internal void Cancel();
}
internal enum MS.Internal.LockFlags : Enum {
    public int value__;
    public static LockFlags MIL_LOCK_READ;
    public static LockFlags MIL_LOCK_WRITE;
}
internal class MS.Internal.Media.ParserStreamGeometryContext : StreamGeometryContext {
    internal bool FigurePending { get; }
    internal int CurrentStreamPosition { get; }
    internal ParserStreamGeometryContext(BinaryWriter bw);
    internal void SetFillRule(FillRule fillRule);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal bool get_FigurePending();
    internal int get_CurrentStreamPosition();
    internal void FinishFigure();
    internal virtual void DisposeCore();
    internal virtual void SetClosedState(bool closed);
    internal void MarkEOF();
    internal static void Deserialize(BinaryReader br, StreamGeometryContext sc, StreamGeometry geometry);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.Media.TextOptionsInternal : object {
    [FriendAccessAllowedAttribute]
internal static DependencyProperty TextHintingModeProperty;
    private static TextOptionsInternal();
    [FriendAccessAllowedAttribute]
public static void SetTextHintingMode(DependencyObject element, TextHintingMode value);
    [FriendAccessAllowedAttribute]
public static TextHintingMode GetTextHintingMode(DependencyObject element);
}
internal static class MS.Internal.Media.VisualTreeUtils : object {
    public static string BitmapEffectObsoleteMessage;
    internal static void PropagateFlags(DependencyObject element, VisualFlags flags, VisualProxyFlags proxyFlags);
    internal static void SetFlagsToRoot(DependencyObject element, bool value, VisualFlags flags);
    internal static DependencyObject FindFirstAncestorWithFlagsAnd(DependencyObject element, VisualFlags flags);
    internal static PointHitTestResult AsNearestPointHitTestResult(HitTestResult result);
    internal static void EnsureNonNullVisual(DependencyObject element);
    internal static void EnsureVisual(DependencyObject element);
    internal static void AsNonNullVisual(DependencyObject element, Visual& visual, Visual3D& visual3D);
    internal static void AsVisual(DependencyObject element, Visual& visual, Visual3D& visual3D);
    internal static bool AsVisualInternal(DependencyObject element, Visual& visual, Visual3D& visual3D);
}
internal static class MS.Internal.Media.XamlSerializationHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool SerializePoint3D(BinaryWriter writer, string stringValues);
    [FriendAccessAllowedAttribute]
internal static bool SerializeVector3D(BinaryWriter writer, string stringValues);
    [FriendAccessAllowedAttribute]
internal static bool SerializePoint(BinaryWriter writer, string stringValue);
    internal static void WriteDouble(BinaryWriter writer, double value);
    internal static double ReadDouble(BinaryReader reader);
    internal static double ReadScaledInteger(BinaryReader reader);
    internal static bool CanConvertToInteger(double doubleValue, Int32& intValue);
}
[FlagsAttribute]
internal enum MS.Internal.Media3D.FaceType : Enum {
    public int value__;
    public static FaceType None;
    public static FaceType Front;
    public static FaceType Back;
}
internal class MS.Internal.Media3D.GeneralTransform2DTo3DTo2D : GeneralTransform {
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    internal bool IsInverse { get; internal set; }
    internal GeneralTransform2DTo3DTo2D(Viewport2DVisual3D visual3D, Visual fromVisual);
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    internal bool get_IsInverse();
    internal void set_IsInverse(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
internal class MS.Internal.Media3D.GeneralTransform3DTo2DTo3D : GeneralTransform3D {
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    internal GeneralTransform3DTo2DTo3D(GeneralTransform3DTo2D transform3DTo2D, GeneralTransform2DTo3D transform2DTo3D);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public virtual Rect3D TransformBounds(Rect3D rect);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
internal class MS.Internal.Media3D.HitTestEdge : object {
    internal Point3D _p1;
    internal Point3D _p2;
    internal Point _uv1;
    internal Point _uv2;
    internal Point _p1Transformed;
    internal Point _p2Transformed;
    public HitTestEdge(Point3D p1, Point3D p2, Point uv1, Point uv2);
    public void Project(GeneralTransform3DTo2D objectToViewportTransform);
}
internal static class MS.Internal.Media3D.LineUtil : object {
    private static LineUtil();
    public static void Transform(Matrix3D modelMatrix, Point3D& origin, Vector3D& direction, Boolean& isRay);
    internal static bool ComputeLineTriangleIntersection(FaceType type, Point3D& origin, Vector3D& direction, Point3D& v0, Point3D& v1, Point3D& v2, Point& hitCoord, Double& dist);
    internal static bool ComputeLineBoxIntersection(Point3D& origin, Vector3D& direction, Rect3D& box, bool isRay);
}
internal static class MS.Internal.Media3D.M3DUtil : object {
    internal static Point3D Interpolate(Point3D& v0, Point3D& v1, Point3D& v2, Point& barycentric);
    internal static Rect3D ComputeAxisAlignedBoundingBox(Point3DCollection positions);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBox(Rect3D& originalBox, Transform3D transform);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBox(Rect3D& originalBox, Matrix3D& matrix);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBoxAffine(Rect3D& originalBox, Matrix3D& matrix);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBoxNonAffine(Rect3D& originalBox, Matrix3D& matrix);
    internal static double GetAspectRatio(Size viewSize);
    internal static Point GetNormalizedPoint(Point point, Size size);
    internal static double RadiansToDegrees(double radians);
    internal static double DegreesToRadians(double degrees);
    internal static Matrix3D GetWorldToViewportTransform3D(Camera camera, Rect viewport);
    internal static Matrix3D GetHomogeneousToViewportTransform3D(Rect viewport);
    internal static Matrix GetHomogeneousToViewportTransform(Rect viewport);
    internal static Matrix3D GetWorldTransformationMatrix(Visual3D visual);
    internal static Matrix3D GetWorldTransformationMatrix(Visual3D visual3DStart, Viewport3DVisual& viewport);
    internal static bool TryTransformToViewport3DVisual(Visual3D visual3D, Viewport3DVisual& viewport, Matrix3D& matrix);
    internal static bool IsPointInTriangle(Point p, Point[] triUVVertices, Point3D[] tri3DVertices, Point3D& inters3DPoint);
}
internal static class MS.Internal.MILGuidData : object {
    [SecurityCriticalAttribute]
internal static Guid IID_IMILRenderTargetBitmap;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICPalette;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapSource;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICFormatConverter;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapScaler;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapClipper;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapFlipRotator;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmap;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapEncoder;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapFrameEncode;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapDecoder;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICBitmapFrameDecode;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICMetadataQueryReader;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICMetadataQueryWriter;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICMetadataReader;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICMetadataWriter;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICPixelFormatInfo;
    [SecurityCriticalAttribute]
internal static Guid IID_IWICImagingFactory;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICBmpDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICPngDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICIcoDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICJpegDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICGifDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICTiffDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICWmpDecoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICBmpEncoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICPngEncoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICJpegEncoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICGifEncoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICTiffEncoder;
    [SecurityCriticalAttribute]
internal static Guid CLSID_WICWmpEncoder;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatBmp;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatIco;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatGif;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatJpeg;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatPng;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatTiff;
    [SecurityCriticalAttribute]
internal static Guid GUID_ContainerFormatWmp;
    [SecurityCriticalAttribute]
internal static Byte[] GUID_VendorMicrosoft;
    [SecurityCriticalAttribute]
private static MILGuidData();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Internal.MILMedia : object {
    internal static int Open(SafeMediaHandle THIS_PTR, string src);
    internal static int Stop(SafeMediaHandle THIS_PTR);
    internal static int Close(SafeMediaHandle THIS_PTR);
    internal static int GetPosition(SafeMediaHandle THIS_PTR, Int64& pllTime);
    internal static int SetPosition(SafeMediaHandle THIS_PTR, long llTime);
    internal static int SetVolume(SafeMediaHandle THIS_PTR, double dblVolume);
    internal static int SetBalance(SafeMediaHandle THIS_PTR, double dblBalance);
    internal static int SetIsScrubbingEnabled(SafeMediaHandle THIS_PTR, bool isScrubbingEnabled);
    internal static int IsBuffering(SafeMediaHandle THIS_PTR, Boolean& pIsBuffering);
    internal static int CanPause(SafeMediaHandle THIS_PTR, Boolean& pCanPause);
    internal static int GetDownloadProgress(SafeMediaHandle THIS_PTR, Double& pProgress);
    internal static int GetBufferingProgress(SafeMediaHandle THIS_PTR, Double& pProgress);
    internal static int SetRate(SafeMediaHandle THIS_PTR, double dblRate);
    internal static int HasVideo(SafeMediaHandle THIS_PTR, Boolean& pfHasVideo);
    internal static int HasAudio(SafeMediaHandle THIS_PTR, Boolean& pfHasAudio);
    internal static int GetNaturalHeight(SafeMediaHandle THIS_PTR, UInt32& puiHeight);
    internal static int GetNaturalWidth(SafeMediaHandle THIS_PTR, UInt32& puiWidth);
    internal static int GetMediaLength(SafeMediaHandle THIS_PTR, Int64& pllLength);
    internal static int NeedUIFrameUpdate(SafeMediaHandle THIS_PTR);
    internal static int Shutdown(IntPtr THIS_PTR);
    internal static int ProcessExitHandler(SafeMediaHandle THIS_PTR);
}
internal static class MS.Internal.MILRenderTargetBitmap : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int GetBitmap(SafeMILHandle THIS_PTR, BitmapSourceSafeMILHandle& ppIBitmap);
    internal static int Clear(SafeMILHandle THIS_PTR);
}
internal static class MS.Internal.MILSwDoubleBufferedBitmap : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int Create(UInt32 width, UInt32 height, double dpiX, double dpiY, Guid& pixelFormatGuid, SafeMILHandle pPalette, SafeMILHandle& ppSwDoubleBufferedBitmap);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void GetBackBuffer(SafeMILHandle THIS_PTR, BitmapSourceSafeMILHandle& pBackBuffer, UInt32& pBackBufferSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void AddDirtyRect(SafeMILHandle THIS_PTR, Int32Rect& dirtyRect);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int ProtectBackBuffer(SafeMILHandle THIS_PTR);
}
internal static class MS.Internal.MILUpdateSystemParametersInfo : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int Update();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.MimeTypeMapper : object {
    internal static ContentType OctetMime;
    internal static ContentType TextPlainMime;
    internal static string XamlExtension;
    internal static string BamlExtension;
    internal static string XbapExtension;
    internal static string JpgExtension;
    internal static ContentType XamlMime;
    internal static ContentType BamlMime;
    internal static ContentType JpgMime;
    internal static ContentType IconMime;
    internal static ContentType FixedDocumentSequenceMime;
    internal static ContentType FixedDocumentMime;
    internal static ContentType FixedPageMime;
    internal static ContentType ResourceDictionaryMime;
    internal static ContentType HtmlMime;
    internal static ContentType HtmMime;
    internal static ContentType XbapMime;
    private static MimeTypeMapper();
    internal static ContentType GetMimeTypeFromUri(Uri uriSource);
    internal static string GetFileExtension(Uri uri);
    internal static bool IsHTMLMime(ContentType contentType);
}
internal class MS.Internal.NativeWPFDLLLoader : object {
    private static NativeWPFDLLLoader();
    [SecuritySafeCriticalAttribute]
public static void LoadCommonDLLsAndDwrite();
    [SecuritySafeCriticalAttribute]
public static void UnloadCommonDLLs();
    [SecuritySafeCriticalAttribute]
public static void UnloadDWrite();
    [SecuritySafeCriticalAttribute]
public static void LoadPresentationNative();
    [SecurityCriticalAttribute]
public static Void* GetDWriteCreateFactoryFunctionPointer();
    [SecurityCriticalAttribute]
public static void ClearDWriteCreateFactoryFunctionPointer();
}
internal class MS.Internal.Pair : object {
    public object First { get; }
    public object Second { get; }
    public Pair(object first, object second);
    public object get_First();
    public object get_Second();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
internal static class MS.Internal.Parsers : object {
    internal static string s_ContextColor;
    internal static string s_ContextColorNoSpace;
    internal static Color ParseColor(string color, IFormatProvider formatProvider);
    internal static Color ParseColor(string color, IFormatProvider formatProvider, ITypeDescriptorContext context);
    internal static Brush ParseBrush(string brush, IFormatProvider formatProvider, ITypeDescriptorContext context);
    internal static Transform ParseTransform(string transformString, IFormatProvider formatProvider);
    internal static PathFigureCollection ParsePathFigureCollection(string pathString, IFormatProvider formatProvider);
    internal static object DeserializeStreamGeometry(BinaryReader reader);
    internal static void PathMinilanguageToBinary(BinaryWriter bw, string stringValue);
    internal static Geometry ParseGeometry(string pathString, IFormatProvider formatProvider);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PartialArray`1 : ValueType {
    private T[] _array;
    private int _initialIndex;
    private int _count;
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public PartialArray`1(T[] array, int initialIndex, int count);
    public PartialArray`1(T[] array);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T item);
    public bool get_IsFixedSize();
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual void Add(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.PartialArray`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__22")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PartialList`1 : object {
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public PartialList`1(IList`1<T> list);
    public PartialList`1(IList`1<T> list, int initialIndex, int count);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.PartialList`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__20")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum MS.Internal.PixelFormatEnum : Enum {
    public int value__;
    public static PixelFormatEnum Default;
    public static PixelFormatEnum Extended;
    public static PixelFormatEnum Indexed1;
    public static PixelFormatEnum Indexed2;
    public static PixelFormatEnum Indexed4;
    public static PixelFormatEnum Indexed8;
    public static PixelFormatEnum BlackWhite;
    public static PixelFormatEnum Gray2;
    public static PixelFormatEnum Gray4;
    public static PixelFormatEnum Gray8;
    public static PixelFormatEnum Bgr555;
    public static PixelFormatEnum Bgr565;
    public static PixelFormatEnum Gray16;
    public static PixelFormatEnum Bgr24;
    public static PixelFormatEnum Rgb24;
    public static PixelFormatEnum Bgr32;
    public static PixelFormatEnum Bgra32;
    public static PixelFormatEnum Pbgra32;
    public static PixelFormatEnum Gray32Float;
    public static PixelFormatEnum Bgr101010;
    public static PixelFormatEnum Rgb48;
    public static PixelFormatEnum Rgba64;
    public static PixelFormatEnum Prgba64;
    public static PixelFormatEnum Rgba128Float;
    public static PixelFormatEnum Prgba128Float;
    public static PixelFormatEnum Rgb128Float;
    public static PixelFormatEnum Cmyk32;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.PointUtil : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static Point ClientToRoot(Point point, PresentationSource presentationSource);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static Point TryClientToRoot(Point point, PresentationSource presentationSource, bool throwOnError, Boolean& success);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static Point RootToClient(Point point, PresentationSource presentationSource);
    public static Point ApplyVisualTransform(Point point, Visual v, bool inverse);
    public static Point TryApplyVisualTransform(Point point, Visual v, bool inverse, bool throwOnError, Boolean& success);
    internal static Matrix GetVisualTransform(Visual v);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static Point ClientToScreen(Point pointClient, PresentationSource presentationSource);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Point ScreenToClient(Point pointScreen, PresentationSource presentationSource);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Rect ElementToRoot(Rect rectElement, Visual element, PresentationSource presentationSource);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Rect RootToClient(Rect rectRoot, PresentationSource presentationSource);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Rect ClientToScreen(Rect rectClient, HwndSource hwndSource);
    internal static POINT AdjustForRightToLeft(POINT pt, HandleRef handleRef);
    internal static RECT AdjustForRightToLeft(RECT rc, HandleRef handleRef);
    internal static POINT FromPoint(Point point);
    internal static Point ToPoint(POINT pt);
    internal static RECT FromRect(Rect rect);
    internal static Rect ToRect(RECT rc);
}
internal static class MS.Internal.PresentationCore.AnimatedTypeHelpers : object {
    internal static byte InterpolateByte(byte from, byte to, double progress);
    internal static Color InterpolateColor(Color from, Color to, double progress);
    internal static decimal InterpolateDecimal(decimal from, decimal to, double progress);
    internal static double InterpolateDouble(double from, double to, double progress);
    internal static short InterpolateInt16(short from, short to, double progress);
    internal static int InterpolateInt32(int from, int to, double progress);
    internal static long InterpolateInt64(long from, long to, double progress);
    internal static Point InterpolatePoint(Point from, Point to, double progress);
    internal static Point3D InterpolatePoint3D(Point3D from, Point3D to, double progress);
    internal static Quaternion InterpolateQuaternion(Quaternion from, Quaternion to, double progress, bool useShortestPath);
    internal static Rect InterpolateRect(Rect from, Rect to, double progress);
    internal static Rotation3D InterpolateRotation3D(Rotation3D from, Rotation3D to, double progress);
    internal static float InterpolateSingle(float from, float to, double progress);
    internal static Size InterpolateSize(Size from, Size to, double progress);
    internal static Vector InterpolateVector(Vector from, Vector to, double progress);
    internal static Vector3D InterpolateVector3D(Vector3D from, Vector3D to, double progress);
    internal static byte AddByte(byte value1, byte value2);
    internal static Color AddColor(Color value1, Color value2);
    internal static decimal AddDecimal(decimal value1, decimal value2);
    internal static double AddDouble(double value1, double value2);
    internal static short AddInt16(short value1, short value2);
    internal static int AddInt32(int value1, int value2);
    internal static long AddInt64(long value1, long value2);
    internal static Point AddPoint(Point value1, Point value2);
    internal static Point3D AddPoint3D(Point3D value1, Point3D value2);
    internal static Quaternion AddQuaternion(Quaternion value1, Quaternion value2);
    internal static float AddSingle(float value1, float value2);
    internal static Size AddSize(Size value1, Size value2);
    internal static Vector AddVector(Vector value1, Vector value2);
    internal static Vector3D AddVector3D(Vector3D value1, Vector3D value2);
    internal static Rect AddRect(Rect value1, Rect value2);
    internal static Rotation3D AddRotation3D(Rotation3D value1, Rotation3D value2);
    internal static byte SubtractByte(byte value1, byte value2);
    internal static Color SubtractColor(Color value1, Color value2);
    internal static decimal SubtractDecimal(decimal value1, decimal value2);
    internal static double SubtractDouble(double value1, double value2);
    internal static short SubtractInt16(short value1, short value2);
    internal static int SubtractInt32(int value1, int value2);
    internal static long SubtractInt64(long value1, long value2);
    internal static Point SubtractPoint(Point value1, Point value2);
    internal static Point3D SubtractPoint3D(Point3D value1, Point3D value2);
    internal static Quaternion SubtractQuaternion(Quaternion value1, Quaternion value2);
    internal static float SubtractSingle(float value1, float value2);
    internal static Size SubtractSize(Size value1, Size value2);
    internal static Vector SubtractVector(Vector value1, Vector value2);
    internal static Vector3D SubtractVector3D(Vector3D value1, Vector3D value2);
    internal static Rect SubtractRect(Rect value1, Rect value2);
    internal static Rotation3D SubtractRotation3D(Rotation3D value1, Rotation3D value2);
    internal static double GetSegmentLengthBoolean(bool from, bool to);
    internal static double GetSegmentLengthByte(byte from, byte to);
    internal static double GetSegmentLengthChar(char from, char to);
    internal static double GetSegmentLengthColor(Color from, Color to);
    internal static double GetSegmentLengthDecimal(decimal from, decimal to);
    internal static double GetSegmentLengthDouble(double from, double to);
    internal static double GetSegmentLengthInt16(short from, short to);
    internal static double GetSegmentLengthInt32(int from, int to);
    internal static double GetSegmentLengthInt64(long from, long to);
    internal static double GetSegmentLengthMatrix(Matrix from, Matrix to);
    internal static double GetSegmentLengthObject(object from, object to);
    internal static double GetSegmentLengthPoint(Point from, Point to);
    internal static double GetSegmentLengthPoint3D(Point3D from, Point3D to);
    internal static double GetSegmentLengthQuaternion(Quaternion from, Quaternion to);
    internal static double GetSegmentLengthRect(Rect from, Rect to);
    internal static double GetSegmentLengthRotation3D(Rotation3D from, Rotation3D to);
    internal static double GetSegmentLengthSingle(float from, float to);
    internal static double GetSegmentLengthSize(Size from, Size to);
    internal static double GetSegmentLengthString(string from, string to);
    internal static double GetSegmentLengthVector(Vector from, Vector to);
    internal static double GetSegmentLengthVector3D(Vector3D from, Vector3D to);
    internal static byte ScaleByte(byte value, double factor);
    internal static Color ScaleColor(Color value, double factor);
    internal static decimal ScaleDecimal(decimal value, double factor);
    internal static double ScaleDouble(double value, double factor);
    internal static short ScaleInt16(short value, double factor);
    internal static int ScaleInt32(int value, double factor);
    internal static long ScaleInt64(long value, double factor);
    internal static Point ScalePoint(Point value, double factor);
    internal static Point3D ScalePoint3D(Point3D value, double factor);
    internal static Quaternion ScaleQuaternion(Quaternion value, double factor);
    internal static Rect ScaleRect(Rect value, double factor);
    internal static Rotation3D ScaleRotation3D(Rotation3D value, double factor);
    internal static float ScaleSingle(float value, double factor);
    internal static Size ScaleSize(Size value, double factor);
    internal static Vector ScaleVector(Vector value, double factor);
    internal static Vector3D ScaleVector3D(Vector3D value, double factor);
    internal static bool IsValidAnimationValueBoolean(bool value);
    internal static bool IsValidAnimationValueByte(byte value);
    internal static bool IsValidAnimationValueChar(char value);
    internal static bool IsValidAnimationValueColor(Color value);
    internal static bool IsValidAnimationValueDecimal(decimal value);
    internal static bool IsValidAnimationValueDouble(double value);
    internal static bool IsValidAnimationValueInt16(short value);
    internal static bool IsValidAnimationValueInt32(int value);
    internal static bool IsValidAnimationValueInt64(long value);
    internal static bool IsValidAnimationValueMatrix(Matrix value);
    internal static bool IsValidAnimationValuePoint(Point value);
    internal static bool IsValidAnimationValuePoint3D(Point3D value);
    internal static bool IsValidAnimationValueQuaternion(Quaternion value);
    internal static bool IsValidAnimationValueRect(Rect value);
    internal static bool IsValidAnimationValueRotation3D(Rotation3D value);
    internal static bool IsValidAnimationValueSingle(float value);
    internal static bool IsValidAnimationValueSize(Size value);
    internal static bool IsValidAnimationValueString(string value);
    internal static bool IsValidAnimationValueVector(Vector value);
    internal static bool IsValidAnimationValueVector3D(Vector3D value);
    internal static byte GetZeroValueByte(byte baseValue);
    internal static Color GetZeroValueColor(Color baseValue);
    internal static decimal GetZeroValueDecimal(decimal baseValue);
    internal static double GetZeroValueDouble(double baseValue);
    internal static short GetZeroValueInt16(short baseValue);
    internal static int GetZeroValueInt32(int baseValue);
    internal static long GetZeroValueInt64(long baseValue);
    internal static Point GetZeroValuePoint(Point baseValue);
    internal static Point3D GetZeroValuePoint3D(Point3D baseValue);
    internal static Quaternion GetZeroValueQuaternion(Quaternion baseValue);
    internal static float GetZeroValueSingle(float baseValue);
    internal static Size GetZeroValueSize(Size baseValue);
    internal static Vector GetZeroValueVector(Vector baseValue);
    internal static Vector3D GetZeroValueVector3D(Vector3D baseValue);
    internal static Rect GetZeroValueRect(Rect baseValue);
    internal static Rotation3D GetZeroValueRotation3D(Rotation3D baseValue);
}
internal static class MS.Internal.PresentationCore.BindUriHelper : object {
    public static int MAX_URL_LENGTH;
    internal static Uri BaseUri { get; internal set; }
    internal static string UriToString(Uri uri);
    internal static Uri get_BaseUri();
    [SecurityCriticalAttribute]
internal static void set_BaseUri(Uri value);
    internal static bool DoSchemeAndHostMatch(Uri first, Uri second);
    internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    internal static string GetReferer(Uri destinationUri);
}
[ConditionalAttribute("COMMONDPS")]
internal class MS.Internal.PresentationCore.CommonDependencyPropertyAttribute : Attribute {
}
internal static class MS.Internal.PresentationCore.DpiUtil : object {
    internal static double DefaultPixelsPerInch;
    internal static DpiFlags UpdateDpiScalesAndGetIndex(double pixelsPerInchX, double pixelsPerInchY);
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.PresentationCore.FriendAccessAllowedAttribute : Attribute {
}
internal class MS.Internal.PresentationCore.GCNotificationToken : object {
    protected virtual override void Finalize();
    internal static void RegisterCallback(WaitCallback callback, object state);
}
[SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.PresentationCore.PresentationNativeLoader : object {
    internal static void EnsureLoaded();
}
internal static class MS.Internal.PresentationCore.SafeSecurityHelper : object {
    internal static string IMAGE;
    private static SafeSecurityHelper();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void TransformLocalRectToScreen(HandleRef hwnd, RECT& rcWindowCoords);
    internal static string GetAssemblyPartialName(Assembly assembly);
    internal static Assembly GetLoadedAssembly(AssemblyName assemblyName);
    internal static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static bool IsFeatureDisabled(KeyToRead key);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static CultureInfo GetCultureInfoByIetfLanguageTag(string languageTag);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsConnectedToPresentationSource(Visual visual);
}
internal static class MS.Internal.PresentationCore.SR : object {
    internal static ResourceManager ResourceManager { get; }
    private static SR();
    internal static string Get(string id);
    internal static string Get(string id, Object[] args);
    internal static ResourceManager get_ResourceManager();
}
internal class MS.Internal.PresentationCore.WeakRefKey : WeakReference {
    public WeakRefKey(object target);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
[ExtensionAttribute]
internal static class MS.Internal.PresentationCore.WindowsRuntime.ReflectionHelper : object {
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName);
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName, TArg arg);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetField(object obj, string fieldName);
    [ExtensionAttribute]
public static object ReflectionNew(Type type);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static object ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static TResult ReflectionStaticGetProperty(Type type, string propertyName);
}
internal class MS.Internal.PriorityQueue`1 : object {
    internal int Count { get; }
    internal T Top { get; }
    internal PriorityQueue`1(int capacity, IComparer`1<T> comparer);
    internal int get_Count();
    internal T get_Top();
    internal void Push(T value);
    internal void Pop();
}
internal static class MS.Internal.Resources.ContentFileHelper : object {
    internal static bool IsContentFile(string partName);
    internal static Dictionary`2<string, string> GetContentFiles(Assembly asm);
}
internal class MS.Internal.Resources.ResourceManagerWrapper : object {
    internal Assembly Assembly { get; internal set; }
    internal IList ResourceList { get; }
    internal ResourceManagerWrapper(Assembly assembly);
    internal Stream GetStream(string name);
    internal Assembly get_Assembly();
    internal void set_Assembly(Assembly value);
    internal IList get_ResourceList();
}
internal enum MS.Internal.ScriptID : Enum {
    public byte value__;
    public static ScriptID Default;
    public static ScriptID Arabic;
    public static ScriptID Armenian;
    public static ScriptID Bengali;
    public static ScriptID Bopomofo;
    public static ScriptID Braille;
    public static ScriptID Buginese;
    public static ScriptID Buhid;
    public static ScriptID CanadianSyllabics;
    public static ScriptID Cherokee;
    public static ScriptID CJKIdeographic;
    public static ScriptID Coptic;
    public static ScriptID CypriotSyllabary;
    public static ScriptID Cyrillic;
    public static ScriptID Deseret;
    public static ScriptID Devanagari;
    public static ScriptID Ethiopic;
    public static ScriptID Georgian;
    public static ScriptID Glagolitic;
    public static ScriptID Gothic;
    public static ScriptID Greek;
    public static ScriptID Gujarati;
    public static ScriptID Gurmukhi;
    public static ScriptID Hangul;
    public static ScriptID Hanunoo;
    public static ScriptID Hebrew;
    public static ScriptID Kannada;
    public static ScriptID Kana;
    public static ScriptID Kharoshthi;
    public static ScriptID Khmer;
    public static ScriptID Lao;
    public static ScriptID Latin;
    public static ScriptID Limbu;
    public static ScriptID LinearB;
    public static ScriptID Malayalam;
    public static ScriptID MathematicalAlphanumericSymbols;
    public static ScriptID Mongolian;
    public static ScriptID MusicalSymbols;
    public static ScriptID Myanmar;
    public static ScriptID NewTaiLue;
    public static ScriptID Ogham;
    public static ScriptID OldItalic;
    public static ScriptID OldPersianCuneiform;
    public static ScriptID Oriya;
    public static ScriptID Osmanya;
    public static ScriptID Runic;
    public static ScriptID Shavian;
    public static ScriptID Sinhala;
    public static ScriptID SylotiNagri;
    public static ScriptID Syriac;
    public static ScriptID Tagalog;
    public static ScriptID Tagbanwa;
    public static ScriptID TaiLe;
    public static ScriptID Tamil;
    public static ScriptID Telugu;
    public static ScriptID Thaana;
    public static ScriptID Thai;
    public static ScriptID Tibetan;
    public static ScriptID Tifinagh;
    public static ScriptID UgariticCuneiform;
    public static ScriptID Yi;
    public static ScriptID Digit;
    public static ScriptID Control;
    public static ScriptID Mirror;
    public static ScriptID Max;
}
internal enum MS.Internal.ScriptTags : Enum {
    public int value__;
    public static ScriptTags Arabic;
    public static ScriptTags Armenian;
    public static ScriptTags Balinese;
    public static ScriptTags Bengali;
    public static ScriptTags Bengali_v2;
    public static ScriptTags Bopomofo;
    public static ScriptTags Braille;
    public static ScriptTags Buginese;
    public static ScriptTags Buhid;
    public static ScriptTags ByzantineMusic;
    public static ScriptTags CanadianSyllabics;
    public static ScriptTags Cherokee;
    public static ScriptTags CJKIdeographic;
    public static ScriptTags Coptic;
    public static ScriptTags CypriotSyllabary;
    public static ScriptTags Cyrillic;
    public static ScriptTags Default;
    public static ScriptTags Deseret;
    public static ScriptTags Devanagari;
    public static ScriptTags Devanagari_v2;
    public static ScriptTags Ethiopic;
    public static ScriptTags Georgian;
    public static ScriptTags Glagolitic;
    public static ScriptTags Gothic;
    public static ScriptTags Greek;
    public static ScriptTags Gujarati;
    public static ScriptTags Gujarati_v2;
    public static ScriptTags Gurmukhi;
    public static ScriptTags Gurmukhi_v2;
    public static ScriptTags HangulJamo;
    public static ScriptTags Hangul;
    public static ScriptTags Hanunoo;
    public static ScriptTags Hebrew;
    public static ScriptTags Hiragana;
    public static ScriptTags Javanese;
    public static ScriptTags Kannada;
    public static ScriptTags Kannada_v2;
    public static ScriptTags Katakana;
    public static ScriptTags Kharosthi;
    public static ScriptTags Khmer;
    public static ScriptTags Lao;
    public static ScriptTags Latin;
    public static ScriptTags Limbu;
    public static ScriptTags LinearB;
    public static ScriptTags Malayalam;
    public static ScriptTags Malayalam_v2;
    public static ScriptTags MathematicalAlphanumericSymbols;
    public static ScriptTags Mongolian;
    public static ScriptTags MusicalSymbols;
    public static ScriptTags Myanmar;
    public static ScriptTags Nko;
    public static ScriptTags Ogham;
    public static ScriptTags OldItalic;
    public static ScriptTags OldPersianCuneiform;
    public static ScriptTags Oriya;
    public static ScriptTags Oriya_v2;
    public static ScriptTags Osmanya;
    public static ScriptTags Phagspa;
    public static ScriptTags Phoenician;
    public static ScriptTags Runic;
    public static ScriptTags Shavian;
    public static ScriptTags Sinhala;
    public static ScriptTags SumeroAkkadianCuneiform;
    public static ScriptTags SylotiNagri;
    public static ScriptTags Syriac;
    public static ScriptTags Tagalog;
    public static ScriptTags Tagbanwa;
    public static ScriptTags TaiLe;
    public static ScriptTags NewTaiLue;
    public static ScriptTags Tamil;
    public static ScriptTags Tamil_v2;
    public static ScriptTags Telugu;
    public static ScriptTags Telugu_v2;
    public static ScriptTags Thaana;
    public static ScriptTags Thai;
    public static ScriptTags Tibetan;
    public static ScriptTags Tifinagh;
    public static ScriptTags UgariticCuneiform;
    public static ScriptTags Yi;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataForMultipleGetAndSet`1 : object {
    internal T Value { get; internal set; }
    [SecurityCriticalAttribute]
internal SecurityCriticalDataForMultipleGetAndSet`1(T value);
    [SecurityCriticalAttribute]
internal T get_Value();
    [SecurityCriticalAttribute]
internal void set_Value(T value);
}
internal static class MS.Internal.SecurityHelper : object {
    internal static PermissionSet EnvelopePermissionSet { get; }
    internal static bool AppDomainGrantedUnrestrictedUIPermission { get; }
    private static SecurityHelper();
    [SecuritySafeCriticalAttribute]
internal static bool CheckUnmanagedCodePermission();
    [SecurityCriticalAttribute]
internal static void DemandUnmanagedCode();
    [SecurityCriticalAttribute]
internal static CodeAccessPermission CreateUserInitiatedRoutedEventPermission();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasUserInitiatedRoutedEventPermission();
    [SecuritySafeCriticalAttribute]
internal static bool IsFullTrustCaller();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasPermissionWithAppDomainOptimization(IPermission[] permissionsToCheck);
    [SecuritySafeCriticalAttribute]
internal static bool AppDomainHasPermission(IPermission permissionToCheck);
    [SecurityCriticalAttribute]
internal static Uri GetBaseDirectory(AppDomain domain);
    internal static Uri ExtractUriForClickOnceDeployedApp();
    [SecurityCriticalAttribute]
internal static void BlockCrossDomainForHttpsApps(Uri uri);
    [SecurityCriticalAttribute]
internal static void EnforceUncContentAccessRules(Uri contentUri);
    [SecurityCriticalAttribute]
internal static int MapUrlToZoneWrapper(Uri uri);
    [SecurityCriticalAttribute]
internal static void DemandFilePathDiscoveryWriteRead();
    [SecurityCriticalAttribute]
internal static PermissionSet ExtractAppDomainPermissionSetMinusSiteOfOrigin();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasSerializationPermission();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasAllClipboardPermission();
    [SecurityCriticalAttribute]
internal static void DemandAllClipboardPermission();
    [SecurityCriticalAttribute]
internal static void DemandPathDiscovery(string path);
    [SecuritySafeCriticalAttribute]
internal static bool CheckEnvironmentPermission();
    [SecurityCriticalAttribute]
internal static void DemandEnvironmentPermission();
    [SecurityCriticalAttribute]
internal static void DemandUriDiscoveryPermission(Uri uri);
    [SecurityCriticalAttribute]
internal static CodeAccessPermission CreateUriDiscoveryPermission(Uri uri);
    [SecurityCriticalAttribute]
internal static CodeAccessPermission CreateUriReadPermission(Uri uri);
    [SecurityCriticalAttribute]
internal static void DemandUriReadPermission(Uri uri);
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasPathDiscoveryPermission(string path);
    [SecurityCriticalAttribute]
internal static PermissionSet get_EnvelopePermissionSet();
    [SecuritySafeCriticalAttribute]
internal static Exception GetExceptionForHR(int hr);
    [SecuritySafeCriticalAttribute]
internal static void ThrowExceptionForHR(int hr);
    [SecuritySafeCriticalAttribute]
internal static int GetHRForException(Exception exception);
    [SecurityCriticalAttribute]
internal static void DemandRegistryPermission();
    [SecurityCriticalAttribute]
internal static void DemandUIWindowPermission();
    [SecurityCriticalAttribute]
internal static void DemandInfrastructurePermission();
    [SecurityCriticalAttribute]
internal static void DemandMediaPermission(MediaPermissionAudio audioPermissionToDemand, MediaPermissionVideo videoPermissionToDemand, MediaPermissionImage imagePermissionToDemand);
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasMediaPermission(MediaPermissionAudio audioPermissionToDemand, MediaPermissionVideo videoPermissionToDemand, MediaPermissionImage imagePermissionToDemand);
    [SecurityCriticalAttribute]
internal static void DemandUnrestrictedUIPermission();
    [SecurityCriticalAttribute]
internal static bool get_AppDomainGrantedUnrestrictedUIPermission();
    [SecurityCriticalAttribute]
internal static void DemandFileIOReadPermission(string fileName);
    [SecurityCriticalAttribute]
internal static void DemandMediaAccessPermission(string uri);
    [SecurityCriticalAttribute]
internal static CodeAccessPermission CreateMediaAccessPermission(string uri);
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasWebPermission(Uri uri);
    [SecurityCriticalAttribute]
internal static void DemandWebPermission(Uri uri);
    [SecurityCriticalAttribute]
internal static void DemandPlugInSerializerPermissions();
    internal static bool AreStringTypesEqual(string m1, string m2);
}
internal class MS.Internal.SequentialUshortCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SequentialUshortCollection(ushort count);
    public sealed virtual void Add(ushort item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ushort item);
    public sealed virtual void CopyTo(UInt16[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(ushort item);
    [IteratorStateMachineAttribute("MS.Internal.SequentialUshortCollection/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<ushort> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.AlternateSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetAlternateSetCount;
    private static int offsetAlternateSets;
    private static int sizeAlternateSetOffset;
    private static ushort InvalidAlternateGlyph;
    private int offset;
    public AlternateSubstitutionSubtable(int Offset);
    public ushort Format(FontTable Table);
    public bool Apply(FontTable Table, GlyphInfoList GlyphInfo, UInt32 FeatureParam, int FirstGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.AnchorTable : ValueType {
    private static int offsetFormat;
    private static int offsetXCoordinate;
    private static int offsetYCoordinate;
    private static int offsetFormat2AnchorPoint;
    private static int offsetFormat3XDeviceTable;
    private static int offsetFormat3YDeviceTable;
    private int offset;
    private ushort format;
    public AnchorTable(FontTable Table, int Offset);
    public bool NeedContourPoint(FontTable Table);
    public ushort ContourPointIndex(FontTable Table);
    public LayoutOffset AnchorCoordinates(FontTable Table, LayoutMetrics Metrics, LayoutOffset ContourPoint);
    public bool IsNull();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ChainingSubtable : ValueType {
    private static int offsetFormat;
    private int offset;
    public ChainingSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ClassChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBacktrackClassDef;
    private static int offsetInputClassDef;
    private static int offsetLookaheadClassDef;
    private static int offsetSubClassSetCount;
    private static int offsetSubClassSetArray;
    private static int sizeClassSetOffset;
    private int offset;
    public ClassChainingSubtable(int Offset);
    public ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ClassContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetClassDef;
    private static int offsetSubClassSetCount;
    private static int offsetSubClassSetArray;
    private static int sizeClassSetOffset;
    private int offset;
    public ClassContextSubtable(int Offset);
    public ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ClassDefTable : ValueType {
    private static int offsetFormat;
    private static int offsetFormat1StartGlyph;
    private static int offsetFormat1GlyphCount;
    private static int offsetFormat1ClassValueArray;
    private static int sizeFormat1ClassValue;
    private static int offsetFormat2RangeCount;
    private static int offsetFormat2RangeRecordArray;
    private static int sizeFormat2RangeRecord;
    private static int offsetFormat2RangeRecordStart;
    private static int offsetFormat2RangeRecordEnd;
    private static int offsetFormat2RangeRecordClass;
    private int offset;
    public static ClassDefTable InvalidClassDef { get; }
    public bool IsInvalid { get; }
    public ClassDefTable(int Offset);
    public ushort GetClass(FontTable Table, ushort glyph);
    public static ClassDefTable get_InvalidClassDef();
    public bool get_IsInvalid();
}
internal class MS.Internal.Shaping.CompositeFontFamily : object {
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.Names { get; }
    private double MS.Internal.FontFace.IFontFamily.BaselineDesign { get; }
    private double MS.Internal.FontFace.IFontFamily.LineSpacingDesign { get; }
    internal LanguageSpecificStringDictionary FamilyNames { get; }
    internal FamilyTypefaceCollection FamilyTypefaces { get; }
    internal FontFamilyMapCollection FamilyMaps { get; }
    internal CompositeFontFamily(CompositeFontInfo fontInfo);
    internal CompositeFontFamily(string friendlyName);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CompositeFontFamily(string friendlyName, IFontFamily firstFontFamily);
    private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.get_Names();
    public sealed virtual double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public void SetBaseline(double value);
    public sealed virtual double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_BaselineDesign();
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_LineSpacingDesign();
    public void SetLineSpacing(double value);
    private sealed virtual override ITypefaceMetrics MS.Internal.FontFace.IFontFamily.GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override IDeviceFont MS.Internal.FontFace.IFontFamily.GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override bool MS.Internal.FontFace.IFontFamily.GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
    private sealed virtual override ICollection`1<Typeface> MS.Internal.FontFace.IFontFamily.GetTypefaces(FontFamilyIdentifier familyIdentifier);
    internal LanguageSpecificStringDictionary get_FamilyNames();
    internal FamilyTypefaceCollection get_FamilyTypefaces();
    internal FontFamilyMapCollection get_FamilyMaps();
}
internal class MS.Internal.Shaping.CompositeTypefaceMetrics : object {
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public bool Symbol { get; }
    public StyleSimulations StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    internal CompositeTypefaceMetrics(double underlinePosition, double underlineThickness, double strikethroughPosition, double strikethroughThickness, double capsHeight, double xHeight, FontStyle style, FontWeight weight, FontStretch stretch);
    public sealed virtual double get_XHeight();
    public sealed virtual double get_CapsHeight();
    public sealed virtual double get_UnderlinePosition();
    public sealed virtual double get_UnderlineThickness();
    public sealed virtual double get_StrikethroughPosition();
    public sealed virtual double get_StrikethroughThickness();
    public sealed virtual bool get_Symbol();
    public sealed virtual StyleSimulations get_StyleSimulations();
    public sealed virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ContextSubtable : ValueType {
    private static int offsetFormat;
    private int offset;
    public ContextSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ContextualLookupRecords : ValueType {
    private static int offsetSequenceIndex;
    private static int offsetLookupIndex;
    private static int sizeLookupRecord;
    private static int MaximumContextualLookupNestingLevel;
    private int offset;
    private ushort recordCount;
    public ContextualLookupRecords(int Offset, ushort RecordCount);
    public void ApplyContextualLookups(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& nextGlyph);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.CoverageChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetBacktrackGlyphCount;
    private static int offsetBacktrackCoverageArray;
    private static int sizeGlyphCount;
    private static int sizeCoverageOffset;
    private int offset;
    private int offsetInputGlyphCount;
    private int offsetLookaheadGlyphCount;
    public CoverageChainingSubtable(FontTable Table, int Offset);
    public ushort Format(FontTable Table);
    public ushort BacktrackGlyphCount(FontTable Table);
    public CoverageTable BacktrackCoverage(FontTable Table, ushort Index);
    public ushort InputGlyphCount(FontTable Table);
    public CoverageTable InputCoverage(FontTable Table, ushort Index);
    public ushort LookaheadGlyphCount(FontTable Table);
    public CoverageTable LookaheadCoverage(FontTable Table, ushort Index);
    public ContextualLookupRecords ContextualLookups(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.CoverageContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetGlyphCount;
    private static int offsetSubstCount;
    private static int offsetInputCoverage;
    private static int sizeOffset;
    private int offset;
    public CoverageContextSubtable(int Offset);
    public ContextualLookupRecords ContextualLookups(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.CoverageTable : ValueType {
    private static int offsetFormat;
    private static int offsetFormat1GlyphCount;
    private static int offsetFormat1GlyphArray;
    private static int sizeFormat1GlyphId;
    private static int offsetFormat2RangeCount;
    private static int offsetFormat2RangeRecordArray;
    private static int sizeFormat2RangeRecord;
    private static int offsetFormat2RangeRecordStart;
    private static int offsetFormat2RangeRecordEnd;
    private static int offsetFormat2RangeRecordStartIndex;
    private int offset;
    public static CoverageTable InvalidCoverage { get; }
    public bool IsInvalid { get; }
    public CoverageTable(int Offset);
    public ushort Format(FontTable Table);
    public ushort Format1GlyphCount(FontTable Table);
    public ushort Format1Glyph(FontTable Table, ushort Index);
    public ushort Format2RangeCount(FontTable Table);
    public ushort Format2RangeStartGlyph(FontTable Table, ushort Index);
    public ushort Format2RangeEndGlyph(FontTable Table, ushort Index);
    public ushort Format2RangeStartCoverageIndex(FontTable Table, ushort Index);
    public int GetGlyphIndex(FontTable Table, ushort glyph);
    public bool IsAnyGlyphCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public static CoverageTable get_InvalidCoverage();
    public bool get_IsInvalid();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.CursivePositioningSubtable : ValueType {
    private static ushort offsetFormat;
    private static ushort offsetCoverage;
    private static ushort offsetEntryExitCount;
    private static ushort offsetEntryExitArray;
    private static ushort sizeEntryExitRecord;
    private static ushort offsetEntryAnchor;
    private static ushort offsetExitAnchor;
    private int offset;
    public CursivePositioningSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.DeviceTable : ValueType {
    private static int offsetStartSize;
    private static int offsetEndSize;
    private static int offsetDeltaFormat;
    private static int offsetDeltaValueArray;
    private static int sizeDeltaValue;
    private int offset;
    public DeviceTable(int Offset);
    public int Value(FontTable Table, ushort PixelsPerEm);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ExtensionLookupTable : ValueType {
    private static int offsetFormat;
    private static int offsetLookupType;
    private static int offsetExtensionOffset;
    private int offset;
    public ExtensionLookupTable(int Offset);
    internal ushort LookupType(FontTable Table);
    internal int LookupSubtableOffset(FontTable Table);
}
internal class MS.Internal.Shaping.Feature : object {
    public UInt32 Tag { get; public set; }
    public UInt32 Parameter { get; public set; }
    public ushort StartIndex { get; public set; }
    public ushort Length { get; public set; }
    public Feature(ushort startIndex, ushort length, UInt32 tag, UInt32 parameter);
    public UInt32 get_Tag();
    public void set_Tag(UInt32 value);
    public UInt32 get_Parameter();
    public void set_Parameter(UInt32 value);
    public ushort get_StartIndex();
    public void set_StartIndex(ushort value);
    public ushort get_Length();
    public void set_Length(ushort value);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.FeatureList : ValueType {
    private static int offsetFeatureCount;
    private static int offsetFeatureRecordArray;
    private static int sizeFeatureRecord;
    private static int offsetFeatureRecordTag;
    private static int offsetFeatureRecordOffset;
    private int offset;
    public FeatureList(int Offset);
    public ushort FeatureCount(FontTable Table);
    public UInt32 FeatureTag(FontTable Table, ushort Index);
    public FeatureTable FeatureTable(FontTable Table, ushort Index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.FeatureTable : ValueType {
    private static int offsetLookupCount;
    private static int offsetLookupIndexArray;
    private static int sizeLookupIndex;
    private int offset;
    public bool IsNull { get; }
    public FeatureTable(int Offset);
    public ushort LookupCount(FontTable Table);
    public ushort LookupIndex(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal class MS.Internal.Shaping.FontTable : object {
    public static int InvalidOffset;
    public static int NullOffset;
    public bool IsPresent { get; }
    [SecurityCriticalAttribute]
public FontTable(Byte[] data);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public bool get_IsPresent();
    [SecurityCriticalAttribute]
public ushort GetUShort(int offset);
    [SecurityCriticalAttribute]
public short GetShort(int offset);
    [SecurityCriticalAttribute]
public UInt32 GetUInt(int offset);
    [SecurityCriticalAttribute]
public ushort GetOffset(int offset);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.GDEFHeader : ValueType {
    private static int offsetGlyphClassDef;
    private static int offsetGlyphAttachList;
    private static int offsetLigaCaretList;
    private static int offsetMarkAttachClassDef;
    private int offset;
    public GDEFHeader(int Offset);
    public ClassDefTable GetGlyphClassDef(FontTable Table);
    public ClassDefTable GetMarkAttachClassDef(FontTable Table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.GlyphChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSubRuleSetCount;
    private static int offsetSubRuleSetArray;
    private static int sizeRuleSetOffset;
    private int offset;
    public GlyphChainingSubtable(int Offset);
    public ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.GlyphContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSubRuleSetCount;
    private static int offsetSubRuleSetArray;
    private static int sizeRuleSetOffset;
    private int offset;
    public GlyphContextSubtable(int Offset);
    public ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[FlagsAttribute]
internal enum MS.Internal.Shaping.GlyphFlags : Enum {
    public ushort value__;
    public static GlyphFlags Unassigned;
    public static GlyphFlags Base;
    public static GlyphFlags Ligature;
    public static GlyphFlags Mark;
    public static GlyphFlags Component;
    public static GlyphFlags Unresolved;
    public static GlyphFlags GlyphTypeMask;
    public static GlyphFlags Substituted;
    public static GlyphFlags Positioned;
    public static GlyphFlags NotChanged;
    public static GlyphFlags CursiveConnected;
    public static GlyphFlags ClusterStart;
    public static GlyphFlags Diacritic;
    public static GlyphFlags ZeroWidth;
    public static GlyphFlags Missing;
    public static GlyphFlags InvalidBase;
}
internal class MS.Internal.Shaping.GlyphInfoList : object {
    public int Length { get; }
    internal int Offset { get; }
    public UshortList Glyphs { get; }
    public UshortList GlyphFlags { get; }
    public UshortList FirstChars { get; }
    public UshortList LigatureCounts { get; }
    internal GlyphInfoList(int capacity, int leap, bool justify);
    public int get_Length();
    internal int get_Offset();
    [ConditionalAttribute("DEBUG")]
internal void ValidateLength(int cch);
    public void SetRange(int index, int length);
    [SecurityCriticalAttribute]
public void SetLength(int length);
    public void Insert(int index, int Count);
    public void Remove(int index, int Count);
    public UshortList get_Glyphs();
    public UshortList get_GlyphFlags();
    public UshortList get_FirstChars();
    public UshortList get_LigatureCounts();
}
internal class MS.Internal.Shaping.GlyphingCache : object {
    internal GlyphingCache(int capacity);
    internal void GetShapeableText(Typeface typeface, CharacterBufferReference characterBufferReference, int stringLength, TextRunProperties textRunProperties, CultureInfo digitCulture, bool isRightToLeftParagraph, IList`1<TextShapeableSymbols> shapeableList, IShapeableTextCollector collector, TextFormattingMode textFormattingMode);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.GPOSHeader : ValueType {
    private static int offsetScriptList;
    private static int offsetFeatureList;
    private static int offsetLookupList;
    private int offset;
    public GPOSHeader(int Offset);
    public ScriptList GetScriptList(FontTable Table);
    public FeatureList GetFeatureList(FontTable Table);
    public LookupList GetLookupList(FontTable Table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.GSUBHeader : ValueType {
    private static int offsetScriptList;
    private static int offsetFeatureList;
    private static int offsetLookupList;
    private int offset;
    public GSUBHeader(int Offset);
    public ScriptList GetScriptList(FontTable Table);
    public FeatureList GetFeatureList(FontTable Table);
    public LookupList GetLookupList(FontTable Table);
}
internal interface MS.Internal.Shaping.IOpenTypeFont {
    [SecurityCriticalAttribute]
public abstract virtual FontTable GetFontTable(OpenTypeTags TableTag);
    public abstract virtual LayoutOffset GetGlyphPointCoord(ushort Glyph, ushort PointIndex);
    public abstract virtual Byte[] GetTableCache(OpenTypeTags tableTag);
    public abstract virtual Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.LangSysTable : ValueType {
    private static int offsetRequiredFeature;
    private static int offsetFeatureCount;
    private static int offsetFeatureIndexArray;
    private static int sizeFeatureIndex;
    private int offset;
    public bool IsNull { get; }
    public LangSysTable(int Offset);
    public FeatureTable FindFeature(FontTable Table, FeatureList Features, UInt32 FeatureTag);
    public FeatureTable RequiredFeature(FontTable Table, FeatureList Features);
    public ushort FeatureCount(FontTable Table);
    public ushort GetFeatureIndex(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal static class MS.Internal.Shaping.LayoutEngine : object {
    public static ushort LookupFlagRightToLeft;
    public static ushort LookupFlagIgnoreBases;
    public static ushort LookupFlagIgnoreLigatures;
    public static ushort LookupFlagIgnoreMarks;
    public static ushort LookupFlagMarkAttachmentTypeMask;
    public static ushort LookupFlagFindBase;
    public static int LookForward;
    public static int LookBackward;
    [SecurityCriticalAttribute]
public static void ApplyFeatures(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, LangSysTable LangSys, FeatureList Features, LookupList Lookups, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets);
    [SecurityCriticalAttribute]
internal static bool ApplyLookup(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, LookupTable Lookup, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    [SecurityCriticalAttribute]
internal static int GetNextGlyphInLookup(IOpenTypeFont Font, GlyphInfoList GlyphInfo, int FirstGlyph, ushort LookupFlags, int Direction);
    [SecurityCriticalAttribute]
internal static void GetComplexLanguageList(OpenTypeTags tableTag, FontTable table, UInt32[] featureTagsList, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId, WritingSystem[]& complexLanguages, Int32& complexLanguageCount);
}
internal class MS.Internal.Shaping.LayoutMetrics : ValueType {
    public TextFlowDirection Direction;
    public ushort DesignEmHeight;
    public ushort PixelsEmWidth;
    public ushort PixelsEmHeight;
    public LayoutMetrics(TextFlowDirection Direction, ushort DesignEmHeight, ushort PixelsEmWidth, ushort PixelsEmHeight);
}
internal class MS.Internal.Shaping.LayoutOffset : ValueType {
    public int dx;
    public int dy;
    public LayoutOffset(int dx, int dy);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.LigatureAttachTable : ValueType {
    private static int offsetAnchorArray;
    private static int sizeAnchorOffset;
    private int offset;
    private int classCount;
    public LigatureAttachTable(int Offset, ushort ClassCount);
    public AnchorTable LigatureAnchor(FontTable Table, ushort Component, ushort MarkClass);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.LigatureSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetLigatureSetCount;
    private static int offsetLigatureSetArray;
    private static int sizeLigatureSet;
    private int offset;
    public LigatureSubstitutionSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.LookupList : ValueType {
    private static int offsetLookupCount;
    private static int LookupOffsetArray;
    private static int sizeLookupOffset;
    private int offset;
    public LookupList(int Offset);
    public ushort LookupCount(FontTable Table);
    public LookupTable Lookup(FontTable Table, ushort Index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.LookupTable : ValueType {
    private static int offsetLookupType;
    private static int offsetLookupFlags;
    private static int offsetSubtableCount;
    private static int offsetSubtableArray;
    private static int sizeSubtableOffset;
    private int offset;
    private ushort lookupType;
    private ushort lookupFlags;
    private ushort subtableCount;
    public LookupTable(FontTable table, int Offset);
    public ushort LookupType();
    public ushort LookupFlags();
    public ushort SubTableCount();
    public int SubtableOffset(FontTable Table, ushort Index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MarkArray : ValueType {
    private static int offsetClassArray;
    private static int sizeClassRecord;
    private static int offsetClassRecordClass;
    private static int offsetClassRecordAnchor;
    private int offset;
    public MarkArray(int Offset);
    public ushort Class(FontTable Table, ushort Index);
    public AnchorTable MarkAnchor(FontTable Table, ushort Index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MarkToBasePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBaseCoverage;
    private static int offsetClassCount;
    private static int offsetMarkArray;
    private static int offsetBaseArray;
    private int offset;
    public MarkToBasePositioningSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MarkToLigaturePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetMarkCoverage;
    private static int offsetLigatureCoverage;
    private static int offsetClassCount;
    private static int offsetMarkArray;
    private static int offsetLigatureArray;
    private static int offsetLigatureAttachArray;
    private static int sizeOffset;
    private int offset;
    public MarkToLigaturePositioningSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, int CharCount, UshortList Charmap, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MarkToMarkPositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetMark2Coverage;
    private static int offsetClassCount;
    private static int offsetMark1Array;
    private static int offsetMark2Array;
    private int offset;
    public MarkToMarkPositioningSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MultipleSubstitutionSequenceTable : ValueType {
    private static int offsetGlyphCount;
    private static int offsetGlyphArray;
    private static int sizeGlyphId;
    private int offset;
    public MultipleSubstitutionSequenceTable(int Offset);
    public ushort GlyphCount(FontTable Table);
    public ushort Glyph(FontTable Table, ushort index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.MultipleSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSequenceCount;
    private static int offsetSequenceArray;
    private static int sizeSequenceOffset;
    private int offset;
    public MultipleSubstitutionSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal static class MS.Internal.Shaping.OpenTypeLayout : object {
    [SecurityCriticalAttribute]
internal static TagInfoFlags FindScript(IOpenTypeFont Font, UInt32 ScriptTag);
    [SecurityCriticalAttribute]
internal static TagInfoFlags FindLangSys(IOpenTypeFont Font, UInt32 ScriptTag, UInt32 LangSysTag);
    [SecurityCriticalAttribute]
internal static OpenTypeLayoutResult SubstituteGlyphs(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, UInt32 ScriptTag, UInt32 LangSysTag, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList Glyphs);
    [SecurityCriticalAttribute]
internal static OpenTypeLayoutResult PositionGlyphs(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, UInt32 ScriptTag, UInt32 LangSysTag, LayoutMetrics Metrics, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList Glyphs, Int32* Advances, LayoutOffset* Offsets);
    [SecurityCriticalAttribute]
internal static OpenTypeLayoutResult CreateLayoutCache(IOpenTypeFont font, int maxCacheSize);
    [SecurityCriticalAttribute]
internal static OpenTypeLayoutResult GetComplexLanguageList(IOpenTypeFont Font, UInt32[] featureList, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId, WritingSystem[]& complexLanguages);
}
internal static class MS.Internal.Shaping.OpenTypeLayoutCache : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static void InitCache(IOpenTypeFont font, OpenTypeTags tableTag, GlyphInfoList glyphInfo, OpenTypeLayoutWorkspace workspace);
    [SecurityCriticalAttribute]
public static void OnGlyphsChanged(OpenTypeLayoutWorkspace workspace, GlyphInfoList glyphInfo, int oldLength, int firstGlyphChanged, int afterLastGlyphChanged);
    [SecurityCriticalAttribute]
public static void FindNextLookup(OpenTypeLayoutWorkspace workspace, GlyphInfoList glyphInfo, ushort firstLookupIndex, UInt16& lookupIndex, Int32& firstGlyph);
    [SecurityCriticalAttribute]
public static bool FindNextGlyphInLookup(OpenTypeLayoutWorkspace workspace, ushort lookupIndex, bool isLookupReversal, Int32& firstGlyph, Int32& afterLastGlyph);
    [SecurityCriticalAttribute]
internal static void CreateCache(IOpenTypeFont font, int maxCacheSize);
}
internal enum MS.Internal.Shaping.OpenTypeLayoutResult : Enum {
    public int value__;
    public static OpenTypeLayoutResult Success;
    public static OpenTypeLayoutResult InvalidParameter;
    public static OpenTypeLayoutResult TableNotFound;
    public static OpenTypeLayoutResult ScriptNotFound;
    public static OpenTypeLayoutResult LangSysNotFound;
    public static OpenTypeLayoutResult BadFontTable;
    public static OpenTypeLayoutResult UnderConstruction;
}
internal class MS.Internal.Shaping.OpenTypeLayoutWorkspace : object {
    public UInt16[] CachePointers { get; }
    public Byte[] TableCacheData { get; public set; }
    internal OpenTypeLayoutResult Init(IOpenTypeFont font, OpenTypeTags tableTag, UInt32 scriptTag, UInt32 langSysTag);
    public void InitLookupUsageFlags(int lookupCount, int featureCount);
    public bool IsAggregatedFlagSet(int lookupIndex);
    public bool IsFeatureFlagSet(int lookupIndex, int featureIndex);
    public bool IsRequiredFeatureFlagSet(int lookupIndex);
    public void SetFeatureFlag(int lookupIndex, int featureIndex);
    public void SetRequiredFeatureFlag(int lookupIndex);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public void AllocateCachePointers(int glyphRunLength);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public void UpdateCachePointers(int oldLength, int newLength, int firstGlyphChanged, int afterLastGlyphChanged);
    [SecurityCriticalAttribute]
public UInt16[] get_CachePointers();
    [SecurityCriticalAttribute]
public Byte[] get_TableCacheData();
    [SecurityCriticalAttribute]
public void set_TableCacheData(Byte[] value);
}
internal enum MS.Internal.Shaping.OpenTypeTags : Enum {
    public UInt32 value__;
    public static OpenTypeTags Null;
    public static OpenTypeTags GSUB;
    public static OpenTypeTags GPOS;
    public static OpenTypeTags GDEF;
    public static OpenTypeTags BASE;
    public static OpenTypeTags name;
    public static OpenTypeTags post;
    public static OpenTypeTags dflt;
    public static OpenTypeTags head;
    public static OpenTypeTags locl;
    public static OpenTypeTags ccmp;
    public static OpenTypeTags rlig;
    public static OpenTypeTags liga;
    public static OpenTypeTags clig;
    public static OpenTypeTags pwid;
    public static OpenTypeTags init;
    public static OpenTypeTags medi;
    public static OpenTypeTags fina;
    public static OpenTypeTags isol;
    public static OpenTypeTags calt;
    public static OpenTypeTags nukt;
    public static OpenTypeTags akhn;
    public static OpenTypeTags rphf;
    public static OpenTypeTags blwf;
    public static OpenTypeTags half;
    public static OpenTypeTags vatu;
    public static OpenTypeTags pres;
    public static OpenTypeTags abvs;
    public static OpenTypeTags blws;
    public static OpenTypeTags psts;
    public static OpenTypeTags haln;
    public static OpenTypeTags kern;
    public static OpenTypeTags mark;
    public static OpenTypeTags mkmk;
    public static OpenTypeTags curs;
    public static OpenTypeTags abvm;
    public static OpenTypeTags blwm;
    public static OpenTypeTags dist;
    public static OpenTypeTags latn;
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.PairPositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetValueFormat1;
    private static int offsetValueFormat2;
    private static int offsetFormat1PairSetCount;
    private static int offsetFormat1PairSetArray;
    private static int sizeFormat1PairSetOffset;
    private static int offsetFormat2ClassDef1;
    private static int offsetFormat2ClassDef2;
    private static int offsetFormat2Class1Count;
    private static int offsetFormat2Class2Count;
    private static int offsetFormat2ValueRecordArray;
    private int offset;
    public PairPositioningSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.Shaping.Positioning : object {
    public static int DesignToPixels(ushort DesignUnitsPerEm, ushort PixelsPerEm, int Value);
    public static void AlignAnchors(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int StaticGlyph, int MobileGlyph, AnchorTable StaticAnchor, AnchorTable MobileAnchor, bool UseAdvances);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ReverseChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBacktrackGlyphCount;
    private static int sizeCount;
    private static int sizeOffset;
    private static int sizeGlyphId;
    private int offset;
    public ReverseChainingSubtable(int Offset);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ScaledShapeTypeface : object {
    internal ShapeTypeface ShapeTypeface { get; }
    internal double ScaleInEm { get; }
    internal bool NullShape { get; }
    internal ScaledShapeTypeface(GlyphTypeface glyphTypeface, IDeviceFont deviceFont, double scaleInEm, bool nullShape);
    internal ShapeTypeface get_ShapeTypeface();
    internal double get_ScaleInEm();
    internal bool get_NullShape();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ScriptList : ValueType {
    private static int offsetScriptCount;
    private static int offsetScriptRecordArray;
    private static int sizeScriptRecord;
    private static int offsetScriptRecordTag;
    private static int offsetScriptRecordOffset;
    private int offset;
    public ScriptList(int Offset);
    public ScriptTable FindScript(FontTable Table, UInt32 Tag);
    public ushort GetScriptCount(FontTable Table);
    public UInt32 GetScriptTag(FontTable Table, ushort Index);
    public ScriptTable GetScriptTable(FontTable Table, ushort Index);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ScriptTable : ValueType {
    private static int offsetDefaultLangSys;
    private static int offsetLangSysCount;
    private static int offsetLangSysRecordArray;
    private static int sizeLangSysRecord;
    private static int offsetLangSysRecordTag;
    private static int offsetLangSysRecordOffset;
    private int offset;
    public bool IsNull { get; }
    public ScriptTable(int Offset);
    public LangSysTable FindLangSys(FontTable Table, UInt32 Tag);
    public bool IsDefaultLangSysExists(FontTable Table);
    public LangSysTable GetDefaultLangSysTable(FontTable Table);
    public ushort GetLangSysCount(FontTable Table);
    public UInt32 GetLangSysTag(FontTable Table, ushort Index);
    public LangSysTable GetLangSysTable(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal class MS.Internal.Shaping.ShaperBuffers : object {
    public UshortList CharMap { get; }
    public GlyphInfoList GlyphInfoList { get; public set; }
    public OpenTypeLayoutWorkspace LayoutWorkspace { get; }
    public ShaperFeaturesList TextFeatures { get; }
    public ShaperBuffers(ushort charCount, ushort glyphCount);
    protected virtual override void Finalize();
    public UshortList get_CharMap();
    public GlyphInfoList get_GlyphInfoList();
    public void set_GlyphInfoList(GlyphInfoList value);
    public bool Initialize(ushort charCount, ushort glyphCount);
    public bool InitializeFeatureList(ushort size, ushort keep);
    public OpenTypeLayoutWorkspace get_LayoutWorkspace();
    public ShaperFeaturesList get_TextFeatures();
}
internal class MS.Internal.Shaping.ShaperFeaturesList : object {
    public int FeaturesCount { get; }
    public Feature[] Features { get; }
    public int NextIx { get; }
    public UInt32 CurrentTag { get; }
    public int Length { get; }
    public int get_FeaturesCount();
    public Feature[] get_Features();
    public int get_NextIx();
    public UInt32 get_CurrentTag();
    public int get_Length();
    public void SetFeatureParameter(ushort featureIx, UInt32 paramValue);
    internal bool Initialize(ushort newSize);
    internal bool Resize(ushort newSize, ushort keepCount);
    internal void AddFeature(Feature feature);
    internal void AddFeature(ushort startIndex, ushort length, UInt32 featureTag, UInt32 parameter);
    internal void AddFeature(ushort charIx, UInt32 featureTag);
    internal void UpdatePreviousShapedChar(UInt32 featureTag);
}
internal class MS.Internal.Shaping.ShapeTypeface : object {
    internal IDeviceFont DeviceFont { get; }
    internal GlyphTypeface GlyphTypeface { get; }
    internal ShapeTypeface(GlyphTypeface glyphTypeface, IDeviceFont deviceFont);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal IDeviceFont get_DeviceFont();
    internal GlyphTypeface get_GlyphTypeface();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.SinglePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetValueFormat;
    private static int offsetFormat1Value;
    private static int offsetFormat2ValueCount;
    private static int offsetFormat2ValueArray;
    private int offset;
    public SinglePositioningSubtable(int Offset);
    public bool Apply(FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.SingleSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetFormat1DeltaGlyphId;
    private static int offsetFormat2GlyphCount;
    private static int offsetFormat2SubstitutehArray;
    private static int sizeFormat2SubstituteSize;
    private int offset;
    public SingleSubstitutionSubtable(int Offset);
    public bool Apply(FontTable Table, GlyphInfoList GlyphInfo, int FirstGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[FlagsAttribute]
internal enum MS.Internal.Shaping.TagInfoFlags : Enum {
    public UInt32 value__;
    public static TagInfoFlags Substitution;
    public static TagInfoFlags Positioning;
    public static TagInfoFlags Both;
    public static TagInfoFlags None;
}
internal enum MS.Internal.Shaping.TextFlowDirection : Enum {
    public ushort value__;
    public static TextFlowDirection LTR;
    public static TextFlowDirection RTL;
    public static TextFlowDirection TTB;
    public static TextFlowDirection BTT;
}
internal class MS.Internal.Shaping.TypefaceMap : object {
    internal TypefaceMap(FontFamily fontFamily, FontFamily fallbackFontFamily, FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, bool nullFont);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void GetShapeableText(CharacterBufferReference characterBufferReference, int stringLength, TextRunProperties textRunProperties, CultureInfo digitCulture, bool isRightToLeftParagraph, IList`1<TextShapeableSymbols> shapeableList, IShapeableTextCollector collector, TextFormattingMode textFormattingMode);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UnsafeUshortArray : UshortBuffer {
    public ushort Item { get; public set; }
    public int Length { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal UnsafeUshortArray(CheckedUShortPointer array, int arrayLength);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual ushort get_Item(int index);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void set_Item(int index, ushort value);
    public virtual int get_Length();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UshortArray : UshortBuffer {
    public ushort Item { get; public set; }
    public int Length { get; }
    internal UshortArray(UInt16[] array);
    internal UshortArray(int capacity, int leap);
    public virtual ushort get_Item(int index);
    public virtual void set_Item(int index, ushort value);
    public virtual int get_Length();
    public virtual UInt16[] ToArray();
    public virtual UInt16[] GetSubsetCopy(int index, int count);
    public virtual void Insert(int index, int count, int length);
    public virtual void Remove(int index, int count, int length);
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.Shaping.UshortBuffer : object {
    protected int _leap;
    public ushort Item { get; public set; }
    public int Length { get; }
    public abstract virtual ushort get_Item(int index);
    public abstract virtual void set_Item(int index, ushort value);
    public abstract virtual int get_Length();
    public virtual UInt16[] ToArray();
    public virtual UInt16[] GetSubsetCopy(int index, int count);
    public virtual void Insert(int index, int count, int length);
    public virtual void Remove(int index, int count, int length);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UshortList : object {
    public ushort Item { get; public set; }
    public int Length { get; public set; }
    public int Offset { get; }
    internal UshortList(int capacity, int leap);
    internal UshortList(UInt16[] array);
    internal UshortList(CheckedUShortPointer unsafeArray, int arrayLength);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public ushort get_Item(int index);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public void set_Item(int index, ushort value);
    public int get_Length();
    [SecurityCriticalAttribute]
public void set_Length(int value);
    public int get_Offset();
    public void SetRange(int index, int length);
    public void Insert(int index, int count);
    public void Remove(int index, int count);
    public UInt16[] ToArray();
    public UInt16[] GetCopy();
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Shaping.ValueRecordTable : ValueType {
    private static ushort XPlacmentFlag;
    private static ushort YPlacmentFlag;
    private static ushort XAdvanceFlag;
    private static ushort YAdvanceFlag;
    private static ushort XPlacementDeviceFlag;
    private static ushort YPlacementDeviceFlag;
    private static ushort XAdvanceDeviceFlag;
    private static ushort YAdvanceDeviceFlag;
    private ushort format;
    private int baseTableOffset;
    private int offset;
    public ValueRecordTable(int Offset, int BaseTableOffset, ushort Format);
    private static ValueRecordTable();
    public static ushort Size(ushort Format);
    public void AdjustPos(FontTable Table, LayoutMetrics Metrics, LayoutOffset& GlyphOffset, Int32& GlyphAdvance);
}
internal class MS.Internal.Shaping.WritingSystem : ValueType {
    internal UInt32 scriptTag;
    internal UInt32 langSysTag;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SizeLimitedCache`2 : object {
    public int MaximumItems { get; }
    public SizeLimitedCache`2(int maximumItems);
    public int get_MaximumItems();
    public void Add(K key, V resource, bool isPermanent);
    public void Remove(K key);
    public V Get(K key);
}
internal class MS.Internal.Span : object {
    public object element;
    public int length;
    public Span(object element, int length);
}
internal class MS.Internal.SpanEnumerator : object {
    public object Current { get; }
    internal SpanEnumerator(SpanVector spans);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class MS.Internal.SpanPosition : ValueType {
    private int _spanIndex;
    private int _spanCP;
    internal int Index { get; }
    internal int CP { get; }
    internal SpanPosition(int spanIndex, int spanCP);
    internal int get_Index();
    internal int get_CP();
}
internal class MS.Internal.SpanRider : ValueType {
    private SpanVector _spans;
    private SpanPosition _spanPosition;
    private int _cp;
    private int _cch;
    public int CurrentSpanStart { get; }
    public int Length { get; }
    public int CurrentPosition { get; }
    public object CurrentElement { get; }
    public int CurrentSpanIndex { get; }
    public SpanPosition SpanPosition { get; }
    public SpanRider(SpanVector spans);
    public SpanRider(SpanVector spans, SpanPosition latestPosition);
    public SpanRider(SpanVector spans, SpanPosition latestPosition, int cp);
    public bool At(int cp);
    public bool At(SpanPosition latestPosition, int cp);
    public int get_CurrentSpanStart();
    public int get_Length();
    public int get_CurrentPosition();
    public object get_CurrentElement();
    public int get_CurrentSpanIndex();
    public SpanPosition get_SpanPosition();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.SpanVector : object {
    public int Count { get; }
    public object Default { get; }
    public Span Item { get; }
    public SpanVector(object defaultObject);
    internal SpanVector(object defaultObject, FrugalStructList`1<Span> spans);
    private static SpanVector();
    public sealed virtual IEnumerator GetEnumerator();
    internal virtual void Delete(int index, int count, SpanPosition& latestPosition);
    internal bool FindSpan(int cp, SpanPosition latestPosition, SpanPosition& spanPosition);
    public void SetValue(int first, int length, object element);
    public SpanPosition SetValue(int first, int length, object element, SpanPosition spanPosition);
    public void SetReference(int first, int length, object element);
    public SpanPosition SetReference(int first, int length, object element, SpanPosition spanPosition);
    public int get_Count();
    public object get_Default();
    public Span get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.StringCharacterBuffer : CharacterBuffer {
    public char Item { get; public set; }
    public int Count { get; }
    public StringCharacterBuffer(string characterString);
    public virtual char get_Item(int characterOffset);
    public virtual void set_Item(int characterOffset, char value);
    public virtual int get_Count();
    [SecurityCriticalAttribute]
public virtual Char* GetCharacterPointer();
    [SecurityCriticalAttribute]
public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal static class MS.Internal.SynchronizedInputHelper : object {
    internal static DependencyObject GetUIParentCore(DependencyObject o);
    internal static bool IsMappedEvent(RoutedEventArgs args);
    internal static SynchronizedInputType GetPairedInputType(SynchronizedInputType inputType);
    internal static bool IsListening(RoutedEventArgs args);
    internal static bool IsListening(DependencyObject o, RoutedEventArgs args);
    internal static bool ShouldContinueListening(RoutedEventArgs args);
    internal static void AddParentPreOpportunityHandler(DependencyObject o, EventRoute route, RoutedEventArgs args);
    internal static void AddHandlerToRoute(DependencyObject o, EventRoute route, RoutedEventHandler eventHandler, bool handledToo);
    internal static void PreOpportunityHandler(object sender, RoutedEventArgs args);
    internal static void PostOpportunityHandler(object sender, RoutedEventArgs args);
    internal static RoutedEvent[] MapInputTypeToRoutedEvents(SynchronizedInputType inputType);
    internal static void RaiseAutomationEvents();
    internal static void RaiseAutomationEvent(AutomationPeer peer);
}
internal enum MS.Internal.SynchronizedInputStates : Enum {
    public int value__;
    public static SynchronizedInputStates NoOpportunity;
    public static SynchronizedInputStates HadOpportunity;
    public static SynchronizedInputStates Handled;
    public static SynchronizedInputStates Discarded;
}
internal static class MS.Internal.SystemDrawingHelper : object {
    internal static bool IsBitmap(object data);
    internal static bool IsImage(object data);
    internal static bool IsMetafile(object data);
    [SecurityCriticalAttribute]
internal static IntPtr GetHandleFromMetafile(object data);
    internal static object GetMetafileFromHemf(IntPtr hMetafile);
    internal static object GetBitmap(object data);
    [SecurityCriticalAttribute]
internal static IntPtr GetHBitmap(object data, Int32& width, Int32& height);
    [SecurityCriticalAttribute]
internal static IntPtr GetHBitmapFromBitmap(object data);
    [SecurityCriticalAttribute]
internal static IntPtr ConvertMetafileToHBitmap(IntPtr handle);
    internal static Stream GetCommentFromGifStream(Stream stream);
    internal static CodeAccessPermission NewSafePrintingPermission();
    internal static CodeAccessPermission NewDefaultPrintingPermission();
    internal static void SaveMetafileToImageStream(MemoryStream metafileStream, Stream imageStream);
    [SecurityCriticalAttribute]
internal static object GetBitmapFromBitmapSource(object source);
}
internal class MS.Internal.Telemetry.PresentationCore.EventSourceActivity : object {
    private Guid _id;
    internal EventSource EventSource { get; }
    internal Guid Id { get; }
    internal EventSourceActivity(EventSource eventSource);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions, Guid parentActivityId);
    internal EventSourceActivity(EventSourceActivity parentActivity);
    internal EventSourceActivity(EventSourceActivity parentActivity, EventSourceOptions startStopOptions);
    internal EventSource get_EventSource();
    internal Guid get_Id();
    internal void Start(string eventName);
    internal void Start(string eventName, T data);
    internal void Stop(string eventName);
    internal void Stop(string eventName, T data);
    internal void Write(string eventName);
    internal void Write(string eventName, EventSourceOptions options);
    internal void Write(string eventName, T data);
    internal void Write(string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
}
internal class MS.Internal.Telemetry.PresentationCore.TelemetryEventSource : EventSource {
    internal static EventKeywords Reserved44Keyword;
    internal static EventKeywords TelemetryKeyword;
    internal static EventKeywords MeasuresKeyword;
    internal static EventKeywords CriticalDataKeyword;
    internal static EventTags CoreData;
    internal static EventTags InjectXToken;
    internal static EventTags RealtimeLatency;
    internal static EventTags NormalLatency;
    internal static EventTags CriticalPersistence;
    internal static EventTags NormalPersistence;
    internal static EventTags DropPii;
    internal static EventTags HashPii;
    internal static EventTags MarkPii;
    internal static EventFieldTags DropPiiField;
    internal static EventFieldTags HashPiiField;
    internal TelemetryEventSource(string eventSourceName);
    private static TelemetryEventSource();
    internal static EventSourceOptions TelemetryOptions();
    internal static EventSourceOptions MeasuresOptions();
    internal static EventSourceOptions CriticalDataOptions();
}
internal static class MS.Internal.Telemetry.PresentationCore.TraceLoggingProvider : object {
    private static TraceLoggingProvider();
    internal static EventSource GetProvider();
}
internal static class MS.Internal.Telemetry.PresentationCore.XpsOMPrintingTraceLogger : object {
    private static XpsOMPrintingTraceLogger();
    internal static void LogXpsOMStatus(bool enabled);
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.CharAttribute : ValueType {
}
[SecurityCriticalAttribute]
internal class MS.Internal.Text.TextInterface.CreateTextAnalysisSink : MulticastDelegate {
    public CreateTextAnalysisSink(object A_0, IntPtr A_1);
    public sealed virtual Void* Invoke();
    public sealed virtual IAsyncResult BeginInvoke(AsyncCallback callback, object obj);
    public sealed virtual Void* EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.Text.TextInterface.CreateTextAnalysisSource : MulticastDelegate {
    public CreateTextAnalysisSource(object A_0, IntPtr A_1);
    public sealed virtual int Invoke(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* text, UInt32 length, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* culture, Void* factory, bool isRightToLeft, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* numberCulture, bool ignoreUserOverride, UInt32 numberSubstitutionMethod, Void** ppTextAnalysisSource);
    public sealed virtual IAsyncResult BeginInvoke(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* text, UInt32 length, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* culture, Void* factory, bool isRightToLeft, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* numberCulture, bool ignoreUserOverride, UInt32 numberSubstitutionMethod, Void** ppTextAnalysisSource, AsyncCallback callback, object obj);
    public sealed virtual int EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Text.TextInterface.DWriteFontFeature : ValueType {
    public DWriteFontFeatureTag nameTag;
    public UInt32 parameter;
    public DWriteFontFeature(DWriteFontFeatureTag dwriteNameTag, UInt32 dwriteParameter);
}
internal enum MS.Internal.Text.TextInterface.DWriteFontFeatureTag : Enum {
    public int value__;
    public static DWriteFontFeatureTag AlternativeFractions;
    public static DWriteFontFeatureTag PetiteCapitalsFromCapitals;
    public static DWriteFontFeatureTag SmallCapitalsFromCapitals;
    public static DWriteFontFeatureTag ContextualAlternates;
    public static DWriteFontFeatureTag CaseSensitiveForms;
    public static DWriteFontFeatureTag GlyphCompositionDecomposition;
    public static DWriteFontFeatureTag ContextualLigatures;
    public static DWriteFontFeatureTag CapitalSpacing;
    public static DWriteFontFeatureTag ContextualSwash;
    public static DWriteFontFeatureTag CursivePositioning;
    public static DWriteFontFeatureTag Default;
    public static DWriteFontFeatureTag DiscretionaryLigatures;
    public static DWriteFontFeatureTag ExpertForms;
    public static DWriteFontFeatureTag Fractions;
    public static DWriteFontFeatureTag FullWidth;
    public static DWriteFontFeatureTag HalfForms;
    public static DWriteFontFeatureTag HalantForms;
    public static DWriteFontFeatureTag AlternateHalfWidth;
    public static DWriteFontFeatureTag HistoricalForms;
    public static DWriteFontFeatureTag HorizontalKanaAlternates;
    public static DWriteFontFeatureTag HistoricalLigatures;
    public static DWriteFontFeatureTag HalfWidth;
    public static DWriteFontFeatureTag HojoKanjiForms;
    public static DWriteFontFeatureTag JIS04Forms;
    public static DWriteFontFeatureTag JIS78Forms;
    public static DWriteFontFeatureTag JIS83Forms;
    public static DWriteFontFeatureTag JIS90Forms;
    public static DWriteFontFeatureTag Kerning;
    public static DWriteFontFeatureTag StandardLigatures;
    public static DWriteFontFeatureTag LiningFigures;
    public static DWriteFontFeatureTag LocalizedForms;
    public static DWriteFontFeatureTag MarkPositioning;
    public static DWriteFontFeatureTag MathematicalGreek;
    public static DWriteFontFeatureTag MarkToMarkPositioning;
    public static DWriteFontFeatureTag AlternateAnnotationForms;
    public static DWriteFontFeatureTag NLCKanjiForms;
    public static DWriteFontFeatureTag OldStyleFigures;
    public static DWriteFontFeatureTag Ordinals;
    public static DWriteFontFeatureTag ProportionalAlternateWidth;
    public static DWriteFontFeatureTag PetiteCapitals;
    public static DWriteFontFeatureTag ProportionalFigures;
    public static DWriteFontFeatureTag ProportionalWidths;
    public static DWriteFontFeatureTag QuarterWidths;
    public static DWriteFontFeatureTag RequiredLigatures;
    public static DWriteFontFeatureTag RubyNotationForms;
    public static DWriteFontFeatureTag StylisticAlternates;
    public static DWriteFontFeatureTag ScientificInferiors;
    public static DWriteFontFeatureTag SmallCapitals;
    public static DWriteFontFeatureTag SimplifiedForms;
    public static DWriteFontFeatureTag StylisticSet1;
    public static DWriteFontFeatureTag StylisticSet2;
    public static DWriteFontFeatureTag StylisticSet3;
    public static DWriteFontFeatureTag StylisticSet4;
    public static DWriteFontFeatureTag StylisticSet5;
    public static DWriteFontFeatureTag StylisticSet6;
    public static DWriteFontFeatureTag StylisticSet7;
    public static DWriteFontFeatureTag StylisticSet8;
    public static DWriteFontFeatureTag StylisticSet9;
    public static DWriteFontFeatureTag StylisticSet10;
    public static DWriteFontFeatureTag StylisticSet11;
    public static DWriteFontFeatureTag StylisticSet12;
    public static DWriteFontFeatureTag StylisticSet13;
    public static DWriteFontFeatureTag StylisticSet14;
    public static DWriteFontFeatureTag StylisticSet15;
    public static DWriteFontFeatureTag StylisticSet16;
    public static DWriteFontFeatureTag StylisticSet17;
    public static DWriteFontFeatureTag StylisticSet18;
    public static DWriteFontFeatureTag StylisticSet19;
    public static DWriteFontFeatureTag StylisticSet20;
    public static DWriteFontFeatureTag Subscript;
    public static DWriteFontFeatureTag Superscript;
    public static DWriteFontFeatureTag Swash;
    public static DWriteFontFeatureTag Titling;
    public static DWriteFontFeatureTag TraditionalNameForms;
    public static DWriteFontFeatureTag TabularFigures;
    public static DWriteFontFeatureTag TraditionalForms;
    public static DWriteFontFeatureTag ThirdWidths;
    public static DWriteFontFeatureTag Unicase;
    public static DWriteFontFeatureTag SlashedZero;
}
internal class MS.Internal.Text.TextInterface.DWriteMatrix : ValueType {
    public float M11;
    public float M12;
    public float M21;
    public float M22;
    public float Dx;
    public float Dy;
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.DWriteTextAnalysisNode<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS> : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.DWriteTextAnalysisNode<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution *> : ValueType {
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Text.TextInterface.DWriteTypeConverter : object {
    internal static TextFormattingMode Convert(DWRITE_MEASURING_MODE dwriteMeasuringMode);
    internal static DWRITE_MEASURING_MODE Convert(TextFormattingMode measuringMode);
    internal static InformationalStringID Convert(DWRITE_INFORMATIONAL_STRING_ID dwriteInformationStringID);
    internal static DWRITE_INFORMATIONAL_STRING_ID Convert(InformationalStringID informationStringID);
    internal static Point Convert(DWRITE_GLYPH_OFFSET dwriteGlyphOffset);
    internal static ValueType modopt(MS.Internal.Text.TextInterface.DWriteMatrix) modopt(System.Runtime.CompilerServices.IsBoxed) Convert(DWRITE_MATRIX dwriteMatrix);
    internal static DWRITE_MATRIX Convert(ValueType modopt(MS.Internal.Text.TextInterface.DWriteMatrix) modopt(System.Runtime.CompilerServices.IsBoxed) matrix);
    internal static FontMetrics Convert(DWRITE_FONT_METRICS dwriteFontMetrics);
    internal static DWRITE_FONT_METRICS Convert(FontMetrics fontMetrics);
    internal static DWRITE_FONT_STYLE Convert(FontStyle fontStyle);
    internal static FontStyle Convert(DWRITE_FONT_STYLE fontStyle);
    internal static DWRITE_FONT_STRETCH Convert(FontStretch fontStrech);
    internal static FontStretch Convert(DWRITE_FONT_STRETCH fontStrech);
    internal static FontFaceType Convert(DWRITE_FONT_FACE_TYPE fontFaceType);
    internal static DWRITE_FONT_FACE_TYPE Convert(FontFaceType fontFaceType);
    internal static byte Convert(FontSimulations fontSimulations);
    internal static FontSimulations Convert(DWRITE_FONT_SIMULATIONS fontSimulations);
    internal static FontFileType Convert(DWRITE_FONT_FILE_TYPE dwriteFontFileType);
    internal static DWRITE_FONT_WEIGHT Convert(FontWeight fontWeight);
    internal static FontWeight Convert(DWRITE_FONT_WEIGHT fontWeight);
    internal static DWRITE_FACTORY_TYPE Convert(FactoryType factoryType);
}
internal class MS.Internal.Text.TextInterface.Factory : CriticalHandle {
    public bool IsInvalid { get; }
    internal IDWriteFactory* DWriteFactoryAddRef { get; }
    [SecuritySafeCriticalAttribute]
private static Factory();
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected sealed virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
internal IDWriteFactory* get_DWriteFactoryAddRef();
    [SecurityCriticalAttribute]
internal static Factory Create(FactoryType factoryType, IFontSourceCollectionFactory fontSourceCollectionFactory, IFontSourceFactory fontSourceFactory);
    [SecurityCriticalAttribute]
internal static Int32 modopt(System.Runtime.CompilerServices.IsLong) CreateFontFile(IDWriteFactory* factory, FontFileLoader fontFileLoader, Uri filePathUri, IDWriteFontFile** dwriteFontFile);
    [SecurityCriticalAttribute]
internal FontFile CreateFontFile(Uri filePathUri);
    [SecurityCriticalAttribute]
internal FontFace CreateFontFace(Uri filePathUri, UInt32 faceIndex);
    [SecurityCriticalAttribute]
internal FontFace CreateFontFace(Uri filePathUri, UInt32 faceIndex, FontSimulations fontSimulationFlags);
    [SecuritySafeCriticalAttribute]
internal FontCollection GetSystemFontCollection(bool checkForUpdates);
    internal FontCollection GetSystemFontCollection();
    [SecurityCriticalAttribute]
internal FontCollection GetFontCollection(Uri uri);
    internal static bool IsLocalUri(Uri uri);
    [SecuritySafeCriticalAttribute]
internal static DWRITE_MATRIX GetIdentityTransform();
    [SecuritySafeCriticalAttribute]
internal TextAnalyzer CreateTextAnalyzer();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
}
internal enum MS.Internal.Text.TextInterface.FactoryType : Enum {
    public int value__;
    public static FactoryType Shared;
    public static FactoryType Isolated;
}
internal class MS.Internal.Text.TextInterface.Font : object {
    internal double Version { get; }
    internal FontMetrics Metrics { get; }
    internal FontSimulations SimulationFlags { get; }
    internal LocalizedStrings FaceNames { get; }
    internal bool IsSymbolFont { get; }
    internal FontStyle Style { get; }
    internal FontStretch Stretch { get; }
    internal FontWeight Weight { get; }
    internal FontFamily Family { get; }
    internal IntPtr DWriteFontAddRef { get; }
    [SecurityCriticalAttribute]
internal Font(IDWriteFont* font);
    private static Font();
    [SecurityCriticalAttribute]
internal IntPtr get_DWriteFontAddRef();
    [SecuritySafeCriticalAttribute]
internal FontFamily get_Family();
    [SecuritySafeCriticalAttribute]
internal FontWeight get_Weight();
    [SecuritySafeCriticalAttribute]
internal FontStretch get_Stretch();
    [SecuritySafeCriticalAttribute]
internal FontStyle get_Style();
    [SecuritySafeCriticalAttribute]
internal bool get_IsSymbolFont();
    [SecuritySafeCriticalAttribute]
internal LocalizedStrings get_FaceNames();
    [SecuritySafeCriticalAttribute]
internal FontSimulations get_SimulationFlags();
    [SecuritySafeCriticalAttribute]
internal FontMetrics get_Metrics();
    internal double get_Version();
    [SecuritySafeCriticalAttribute]
internal FontMetrics DisplayMetrics(float emSize, float pixelsPerDip);
    internal static void ResetFontFaceCache();
    internal FontFace GetFontFace();
    [SecuritySafeCriticalAttribute]
internal bool GetInformationalStrings(InformationalStringID informationalStringID, LocalizedStrings& informationalStrings);
    [SecuritySafeCriticalAttribute]
internal bool HasCharacter(UInt32 unicodeValue);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Text.TextInterface.FontCollection : object {
    internal FontFamily Item { get; }
    internal FontFamily Item { get; }
    internal UInt32 FamilyCount { get; }
    [SecurityCriticalAttribute]
internal FontCollection(IDWriteFontCollection* fontCollection);
    [SecuritySafeCriticalAttribute]
internal UInt32 get_FamilyCount();
    internal FontFamily get_Item(string familyName);
    [SecuritySafeCriticalAttribute]
internal FontFamily get_Item(UInt32 familyIndex);
    [SecuritySafeCriticalAttribute]
internal bool FindFamilyName(string familyName, UInt32& index);
    [SecuritySafeCriticalAttribute]
internal Font GetFontFromFontFace(FontFace fontFace);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Text.TextInterface.FontCollectionLoader : object {
    public FontCollectionLoader(IFontSourceCollectionFactory fontSourceCollectionFactory, FontFileLoader fontFileLoader);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) CreateEnumeratorFromKey(IntPtr factory, Void modopt(System.Runtime.CompilerServices.IsConst)* collectionKey, UInt32 collectionKeySize, IntPtr* fontFileEnumerator);
}
internal class MS.Internal.Text.TextInterface.FontFace : object {
    internal ushort GlyphCount { get; }
    internal FontMetrics Metrics { get; }
    internal bool IsSymbolFont { get; }
    internal FontSimulations SimulationFlags { get; }
    internal UInt32 Index { get; }
    internal FontFaceType Type { get; }
    internal IntPtr DWriteFontFaceAddRef { get; }
    internal IDWriteFontFace* DWriteFontFaceNoAddRef { get; }
    [SecurityCriticalAttribute]
internal FontFace(IDWriteFontFace* fontFace);
    [SecurityCriticalAttribute]
internal IDWriteFontFace* get_DWriteFontFaceNoAddRef();
    [SecurityCriticalAttribute]
internal IntPtr get_DWriteFontFaceAddRef();
    [SecuritySafeCriticalAttribute]
internal FontFaceType get_Type();
    [SecuritySafeCriticalAttribute]
internal UInt32 get_Index();
    [SecuritySafeCriticalAttribute]
internal FontSimulations get_SimulationFlags();
    [SecuritySafeCriticalAttribute]
internal bool get_IsSymbolFont();
    [SecuritySafeCriticalAttribute]
internal FontMetrics get_Metrics();
    [SecuritySafeCriticalAttribute]
internal ushort get_GlyphCount();
    [SecuritySafeCriticalAttribute]
internal FontFile GetFileZero();
    internal void AddRef();
    internal void Release();
    [SecurityCriticalAttribute]
internal void GetDesignGlyphMetrics(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* pGlyphIndices, UInt32 glyphCount, GlyphMetrics* pGlyphMetrics);
    [SecurityCriticalAttribute]
internal void GetDisplayGlyphMetrics(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* pGlyphIndices, UInt32 glyphCount, GlyphMetrics* pGlyphMetrics, float emSize, bool useDisplayNatural, bool isSideways, float pixelsPerDip);
    [SecurityCriticalAttribute]
internal void GetArrayOfGlyphIndices(UInt32 modopt(System.Runtime.CompilerServices.IsConst)* pCodePoints, UInt32 glyphCount, UInt16* pGlyphIndices);
    [SecurityCriticalAttribute]
internal bool TryGetFontTable(OpenTypeTableTag openTypeTableTag, Byte[]& tableData);
    [SecuritySafeCriticalAttribute]
internal bool ReadFontEmbeddingRights(UInt16& fsType);
    protected sealed virtual void Dispose(bool A_0);
    public sealed virtual void Dispose();
}
internal enum MS.Internal.Text.TextInterface.FontFaceType : Enum {
    public int value__;
    public static FontFaceType CFF;
    public static FontFaceType TrueType;
    public static FontFaceType TrueTypeCollection;
    public static FontFaceType Type1;
    public static FontFaceType Vector;
    public static FontFaceType Bitmap;
    public static FontFaceType Unknown;
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Text.TextInterface.FontFamily : FontList {
    internal FontMetrics Metrics { get; }
    internal string OrdinalName { get; }
    internal bool IsComposite { get; }
    internal bool IsPhysical { get; }
    internal LocalizedStrings FamilyNames { get; }
    [SecurityCriticalAttribute]
internal FontFamily(IDWriteFontFamily* fontFamily);
    [SecuritySafeCriticalAttribute]
internal LocalizedStrings get_FamilyNames();
    internal bool get_IsPhysical();
    internal bool get_IsComposite();
    internal string get_OrdinalName();
    internal FontMetrics get_Metrics();
    internal FontMetrics DisplayMetrics(float emSize, float pixelsPerDip);
    [SecuritySafeCriticalAttribute]
internal Font GetFirstMatchingFont(FontWeight weight, FontStretch stretch, FontStyle style);
    [SecuritySafeCriticalAttribute]
internal FontList GetMatchingFonts(FontWeight weight, FontStretch stretch, FontStyle style);
}
internal class MS.Internal.Text.TextInterface.FontFile : object {
    internal IDWriteFontFile* DWriteFontFileNoAddRef { get; }
    [SecuritySafeCriticalAttribute]
private static FontFile();
    [SecurityCriticalAttribute]
internal FontFile(IDWriteFontFile* fontFile);
    [SecurityCriticalAttribute]
internal IDWriteFontFile* get_DWriteFontFileNoAddRef();
    [SecuritySafeCriticalAttribute]
internal bool Analyze(DWRITE_FONT_FILE_TYPE& dwriteFontFileType, DWRITE_FONT_FACE_TYPE& dwriteFontFaceType, UInt32& numberOfFaces, Int32 modopt(System.Runtime.CompilerServices.IsLong)* modopt(System.Runtime.CompilerServices.IsImplicitlyDereferenced) hr);
    [SecurityCriticalAttribute]
internal string GetUriPath();
    protected sealed virtual void Dispose(bool A_0);
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Text.TextInterface.FontFileEnumerator : object {
    public FontFileEnumerator(IEnumerable`1<IFontSource> fontSourceCollection, FontFileLoader fontFileLoader, IDWriteFactory* factory);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) MoveNext(Boolean& hasCurrentFile);
    [ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetCurrentFontFile(IDWriteFontFile** fontFile);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute("1")]
[ClassInterfaceAttribute("0")]
internal class MS.Internal.Text.TextInterface.FontFileLoader : object {
    public FontFileLoader(IFontSourceFactory fontSourceFactory);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) CreateStreamFromKey(Void modopt(System.Runtime.CompilerServices.IsConst)* fontFileReferenceKey, UInt32 fontFileReferenceKeySize, IntPtr* fontFileStream);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Text.TextInterface.FontFileStream : object {
    public FontFileStream(IFontSource fontSource);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) ReadFileFragment(Void modopt(System.Runtime.CompilerServices.IsConst)** fragmentStart, ulong fileOffset, ulong fragmentSize, Void** fragmentContext);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void ReleaseFileFragment(Void* fragmentContext);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetFileSize(UInt64* fileSize);
    [ComVisibleAttribute("True")]
public virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetLastWriteTime(UInt64* lastWriteTime);
    protected virtual void Dispose(bool A_0);
    public sealed virtual void Dispose();
}
internal enum MS.Internal.Text.TextInterface.FontFileType : Enum {
    public int value__;
    public static FontFileType Unknown;
    public static FontFileType CFF;
    public static FontFileType TrueType;
    public static FontFileType TrueTypeCollection;
    public static FontFileType Type1PFM;
    public static FontFileType Type1PFB;
    public static FontFileType Vector;
    public static FontFileType Bitmap;
}
[DefaultMemberAttribute("Item")]
[SecurityCriticalAttribute("1")]
internal class MS.Internal.Text.TextInterface.FontList : object {
    internal FontCollection FontsCollection { get; }
    internal UInt32 Count { get; }
    internal Font Item { get; }
    protected NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontList> FontListObject { get; }
    internal FontList(IDWriteFontList* fontList);
    protected NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontList> get_FontListObject();
    internal Font get_Item(UInt32 A_0);
    internal UInt32 get_Count();
    internal FontCollection get_FontsCollection();
    public virtual IEnumerator`1<Font> GetEnumerator();
    public sealed virtual override IEnumerator GetEnumerator2();
}
internal class MS.Internal.Text.TextInterface.FontMetrics : object {
    public ushort DesignUnitsPerEm;
    public ushort Ascent;
    public ushort Descent;
    public short LineGap;
    public ushort CapHeight;
    public ushort XHeight;
    public short UnderlinePosition;
    public ushort UnderlineThickness;
    public short StrikethroughPosition;
    public ushort StrikethroughThickness;
    public double LineSpacing { get; }
    public double Baseline { get; }
    public double get_Baseline();
    public double get_LineSpacing();
}
[FlagsAttribute]
internal enum MS.Internal.Text.TextInterface.FontSimulations : Enum {
    public int value__;
    public static FontSimulations None;
    public static FontSimulations Bold;
    public static FontSimulations Oblique;
}
internal enum MS.Internal.Text.TextInterface.FontStretch : Enum {
    public int value__;
    public static FontStretch Undefined;
    public static FontStretch UltraCondensed;
    public static FontStretch ExtraCondensed;
    public static FontStretch Condensed;
    public static FontStretch SemiCondensed;
    public static FontStretch Normal;
    public static FontStretch Medium;
    public static FontStretch SemiExpanded;
    public static FontStretch Expanded;
    public static FontStretch ExtraExpanded;
    public static FontStretch UltraExpanded;
}
internal enum MS.Internal.Text.TextInterface.FontStyle : Enum {
    public int value__;
    public static FontStyle Normal;
    public static FontStyle Oblique;
    public static FontStyle Italic;
}
internal enum MS.Internal.Text.TextInterface.FontWeight : Enum {
    public int value__;
    public static FontWeight Thin;
    public static FontWeight ExtraLight;
    public static FontWeight UltraLight;
    public static FontWeight Light;
    public static FontWeight Normal;
    public static FontWeight Regular;
    public static FontWeight Medium;
    public static FontWeight DemiBold;
    public static FontWeight SemiBOLD;
    public static FontWeight Bold;
    public static FontWeight ExtraBold;
    public static FontWeight UltraBold;
    public static FontWeight Black;
    public static FontWeight Heavy;
    public static FontWeight ExtraBlack;
    public static FontWeight UltraBlack;
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFont> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFont> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFont>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontCollection> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontCollection> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontCollection>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontFace> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFace> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontFace>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontFile> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFile> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontFile>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontList> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontList> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteFontList>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteLocalizedStrings> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteLocalizedStrings> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteLocalizedStrings>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution>(IUnknown* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteTextAnalyzer> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteTextAnalyzer> {
    [SecurityCriticalAttribute]
public NativeIUnknownWrapper<MS::Internal::Text::TextInterface::Native::IDWriteTextAnalyzer>(IUnknown* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<_GUID> : CriticalHandle {
    public _GUID* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<_GUID>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public _GUID* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS> : CriticalHandle {
    public DWRITE_SCRIPT_ANALYSIS* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public DWRITE_SCRIPT_ANALYSIS* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFont> : CriticalHandle {
    public IDWriteFont* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFont>(Void* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteFont* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontCollection> : CriticalHandle {
    public IDWriteFontCollection* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontCollection>(Void* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteFontCollection* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFace> : CriticalHandle {
    public IDWriteFontFace* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFace>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteFontFace* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFile> : CriticalHandle {
    public IDWriteFontFile* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontFile>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteFontFile* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontList> : CriticalHandle {
    public IDWriteFontList* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteFontList>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteFontList* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteLocalizedStrings> : CriticalHandle {
    public IDWriteLocalizedStrings* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteLocalizedStrings>(Void* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteLocalizedStrings* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution> : CriticalHandle {
    public IDWriteNumberSubstitution* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution>(Void* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteNumberSubstitution* get_Value();
}
internal abstract class MS.Internal.Text.TextInterface.Generics.NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteTextAnalyzer> : CriticalHandle {
    public IDWriteTextAnalyzer* Value { get; }
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::IDWriteTextAnalyzer>(Void* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public IDWriteTextAnalyzer* get_Value();
}
internal class MS.Internal.Text.TextInterface.Generics.NativePointerWrapper<_GUID> : NativePointerCriticalHandle<_GUID> {
    [SecurityCriticalAttribute]
public NativePointerWrapper<_GUID>(_GUID* pNativePointer);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Text.TextInterface.Generics.NativePointerWrapper<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS> : NativePointerCriticalHandle<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS> {
    [SecurityCriticalAttribute]
public NativePointerWrapper<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS>(DWRITE_SCRIPT_ANALYSIS* pNativePointer);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class MS.Internal.Text.TextInterface.GetNumberSubstitutionList : MulticastDelegate {
    public GetNumberSubstitutionList(object A_0, IntPtr A_1);
    public sealed virtual Void* Invoke(Void* A_0);
    public sealed virtual IAsyncResult BeginInvoke(Void* __unnamed000, AsyncCallback callback, object obj);
    public sealed virtual Void* EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.Text.TextInterface.GetScriptAnalysisList : MulticastDelegate {
    public GetScriptAnalysisList(object A_0, IntPtr A_1);
    public sealed virtual Void* Invoke(Void* A_0);
    public sealed virtual IAsyncResult BeginInvoke(Void* __unnamed000, AsyncCallback callback, object obj);
    public sealed virtual Void* EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Text.TextInterface.GlyphMetrics : ValueType {
    public int LeftSideBearing;
    public UInt32 AdvanceWidth;
    public int RightSideBearing;
    public int TopSideBearing;
    public UInt32 AdvanceHeight;
    public int BottomSideBearing;
    public int VerticalOriginY;
}
internal class MS.Internal.Text.TextInterface.GlyphOffset : ValueType {
    public int du;
    public int dv;
}
internal interface MS.Internal.Text.TextInterface.IClassification {
    public abstract virtual void GetCharAttribute(int unicodeScalar, Boolean& isCombining, Boolean& needsCaretInfo, Boolean& isIndic, Boolean& isDigit, Boolean& isLatin, Boolean& isStrong);
}
internal interface MS.Internal.Text.TextInterface.IFontSource {
    public bool IsComposite { get; }
    public Uri Uri { get; }
    public abstract virtual void TestFileOpenable();
    public abstract virtual UnmanagedMemoryStream GetUnmanagedStream();
    public abstract virtual DateTime GetLastWriteTimeUtc();
    public abstract virtual Uri get_Uri();
    public abstract virtual bool get_IsComposite();
}
internal interface MS.Internal.Text.TextInterface.IFontSourceCollection {
}
internal interface MS.Internal.Text.TextInterface.IFontSourceCollectionFactory {
    public abstract virtual IFontSourceCollection Create(string A_0);
}
internal interface MS.Internal.Text.TextInterface.IFontSourceFactory {
    public abstract virtual IFontSource Create(string A_0);
}
internal enum MS.Internal.Text.TextInterface.InformationalStringID : Enum {
    public int value__;
    public static InformationalStringID None;
    public static InformationalStringID CopyrightNotice;
    public static InformationalStringID VersionStrings;
    public static InformationalStringID Trademark;
    public static InformationalStringID Manufacturer;
    public static InformationalStringID Designer;
    public static InformationalStringID DesignerURL;
    public static InformationalStringID Description;
    public static InformationalStringID FontVendorURL;
    public static InformationalStringID LicenseDescription;
    public static InformationalStringID LicenseInfoURL;
    public static InformationalStringID WIN32FamilyNames;
    public static InformationalStringID Win32SubFamilyNames;
    public static InformationalStringID PreferredFamilyNames;
    public static InformationalStringID PreferredSubFamilyNames;
    public static InformationalStringID SampleText;
}
[GuidAttribute("cca920e4-52f0-492b-bfa8-29c72ee0a468")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Text.TextInterface.Interfaces.IDWriteFontCollectionLoaderMirror {
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) CreateEnumeratorFromKey(IntPtr factory, Void modopt(System.Runtime.CompilerServices.IsConst)* collectionKey, UInt32 collectionKeySize, IntPtr* fontFileEnumerator);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("72755049-5ff7-435d-8348-4be97cfa6c7c")]
internal interface MS.Internal.Text.TextInterface.Interfaces.IDWriteFontFileEnumeratorMirror {
    public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) MoveNext(Boolean& hasCurrentFile);
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetCurrentFontFile(IDWriteFontFile** fontFile);
}
[GuidAttribute("727cad4e-d6af-4c9e-8a08-d695b11caa49")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Text.TextInterface.Interfaces.IDWriteFontFileLoaderMirror {
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) CreateStreamFromKey(Void modopt(System.Runtime.CompilerServices.IsConst)* fontFileReferenceKey, UInt32 fontFileReferenceKeySize, IntPtr* fontFileStream);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0")]
internal interface MS.Internal.Text.TextInterface.Interfaces.IDWriteFontFileStreamMirror {
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) ReadFileFragment(Void modopt(System.Runtime.CompilerServices.IsConst)** fragmentStart, ulong fileOffset, ulong fragmentSize, Void** fragmentContext);
    [SecurityCriticalAttribute]
public abstract virtual void ReleaseFileFragment(Void* fragmentContext);
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetFileSize(UInt64* fileSize);
    [SecurityCriticalAttribute]
public abstract virtual Int32 modopt(System.Runtime.CompilerServices.IsLong) GetLastWriteTime(UInt64* lastWriteTime);
}
internal class MS.Internal.Text.TextInterface.ItemizerHelper : object {
    internal static bool IsExtendedCharacter(ushort ch);
}
internal class MS.Internal.Text.TextInterface.ItemProps : object {
    public bool HasCombiningMark { get; }
    public bool IsLatin { get; }
    public bool IsIndic { get; }
    public bool NeedsCaretInfo { get; }
    public bool HasExtendedCharacter { get; }
    public CultureInfo DigitCulture { get; }
    public Void* ScriptAnalysis { get; }
    public Void* NumberSubstitutionNoAddRef { get; }
    [SecurityCriticalAttribute]
public Void* get_NumberSubstitutionNoAddRef();
    [SecurityCriticalAttribute]
public Void* get_ScriptAnalysis();
    public CultureInfo get_DigitCulture();
    public bool get_HasExtendedCharacter();
    public bool get_NeedsCaretInfo();
    public bool get_IsIndic();
    public bool get_IsLatin();
    public bool get_HasCombiningMark();
    [SecuritySafeCriticalAttribute]
public bool CanShapeTogether(ItemProps other);
    [SecurityCriticalAttribute]
public static ItemProps Create(Void* scriptAnalysis, Void* numberSubstitution, CultureInfo digitCulture, bool hasCombiningMark, bool needsCaretInfo, bool hasExtendedCharacter, bool isIndic, bool isLatin);
}
internal class MS.Internal.Text.TextInterface.LocalizedErrorMsgs : object {
    internal static string EnumeratorReachedEnd { get; internal set; }
    internal static string EnumeratorNotStarted { get; internal set; }
    private static LocalizedErrorMsgs();
    internal static string get_EnumeratorNotStarted();
    internal static void set_EnumeratorNotStarted(string msg);
    internal static string get_EnumeratorReachedEnd();
    internal static void set_EnumeratorReachedEnd(string msg);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Text.TextInterface.LocalizedStrings : object {
    public bool IsReadOnly { get; }
    public int Count { get; }
    public string Item { get; public set; }
    public ICollection`1<string> Values { get; }
    public ICollection`1<CultureInfo> Keys { get; }
    internal UInt32 StringsCount { get; }
    [SecurityCriticalAttribute]
internal LocalizedStrings(IDWriteLocalizedStrings* localizedStrings);
    [SecuritySafeCriticalAttribute]
internal UInt32 get_StringsCount();
    [SecuritySafeCriticalAttribute]
internal bool FindLocaleName(string localeName, UInt32& index);
    [SecuritySafeCriticalAttribute]
internal string GetLocaleName(UInt32 index);
    [SecuritySafeCriticalAttribute]
internal string GetString(UInt32 index);
    public sealed virtual void Add(KeyValuePair`2<CultureInfo, string> item);
    public sealed virtual void Add(CultureInfo key, string value);
    public sealed virtual bool ContainsKey(CultureInfo key);
    public virtual ICollection`1<CultureInfo> get_Keys();
    public sealed virtual bool Remove(KeyValuePair`2<CultureInfo, string> item);
    public sealed virtual bool Remove(CultureInfo key);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool TryGetValue(CultureInfo key, String& value);
    public virtual ICollection`1<string> get_Values();
    public virtual string get_Item(CultureInfo key);
    public virtual void set_Item(CultureInfo key, string value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<CultureInfo, string> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] arrayObj, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<CultureInfo, string>> GetEnumerator();
    public sealed virtual override IEnumerator GetEnumerator2();
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FACTORY_TYPE : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_FACE_TYPE : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_FILE_TYPE : Enum {
    public int value__;
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_FONT_METRICS : ValueType {
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_SIMULATIONS : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_STRETCH : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_STYLE : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_FONT_WEIGHT : Enum {
    public int value__;
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_GLYPH_METRICS : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_GLYPH_OFFSET : ValueType {
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_INFORMATIONAL_STRING_ID : Enum {
    public int value__;
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_MATRIX : ValueType {
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_MEASURING_MODE : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_SCRIPT_ANALYSIS : ValueType {
}
[NativeCppClassAttribute]
internal enum MS.Internal.Text.TextInterface.Native.DWRITE_SCRIPT_SHAPES : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_SHAPING_GLYPH_PROPERTIES : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_SHAPING_TEXT_PROPERTIES : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.Text.TextInterface.Native.DWRITE_TYPOGRAPHIC_FEATURES : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFactory : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFont : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontCollection : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontCollectionLoader : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontFace : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontFamily : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontFile : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontFileLoader : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteFontList : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteLocalFontFileLoader : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteLocalizedStrings : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteNumberSubstitution : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteTextAnalysisSink : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteTextAnalysisSource : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IDWriteTextAnalyzer : ValueType {
}
[NativeCppClassAttribute]
internal static class MS.Internal.Text.TextInterface.Native.IUnknown : ValueType {
}
internal class MS.Internal.Text.TextInterface.Native.Util : object {
    private static Util();
    [SecuritySafeCriticalAttribute]
public static void ConvertHresultToException(Int32 modopt(System.Runtime.CompilerServices.IsLong) hr);
    [SecurityCriticalAttribute]
public static Char modopt(System.Runtime.CompilerServices.IsConst)& modopt(System.Runtime.CompilerServices.IsExplicitlyDereferenced) modopt(System.Runtime.CompilerServices.IsConst) GetPtrToStringChars(string s);
    [SecuritySafeCriticalAttribute]
public static _GUID ToGUID(Guid* modopt(System.Runtime.CompilerServices.IsImplicitlyDereferenced) guid);
}
internal enum MS.Internal.Text.TextInterface.OpenTypeTableTag : Enum {
    public int value__;
    public static OpenTypeTableTag CharToIndexMap;
    public static OpenTypeTableTag ControlValue;
    public static OpenTypeTableTag BitmapData;
    public static OpenTypeTableTag BitmapLocation;
    public static OpenTypeTableTag BitmapScale;
    public static OpenTypeTableTag Editor0;
    public static OpenTypeTableTag Editor1;
    public static OpenTypeTableTag Encryption;
    public static OpenTypeTableTag FontHeader;
    public static OpenTypeTableTag FontProgram;
    public static OpenTypeTableTag GridfitAndScanProc;
    public static OpenTypeTableTag GlyphDirectory;
    public static OpenTypeTableTag GlyphData;
    public static OpenTypeTableTag HoriDeviceMetrics;
    public static OpenTypeTableTag HoriHeader;
    public static OpenTypeTableTag HorizontalMetrics;
    public static OpenTypeTableTag IndexToLoc;
    public static OpenTypeTableTag Kerning;
    public static OpenTypeTableTag LinearThreshold;
    public static OpenTypeTableTag MaxProfile;
    public static OpenTypeTableTag NamingTable;
    public static OpenTypeTableTag OS_2;
    public static OpenTypeTableTag Postscript;
    public static OpenTypeTableTag PreProgram;
    public static OpenTypeTableTag VertDeviceMetrics;
    public static OpenTypeTableTag VertHeader;
    public static OpenTypeTableTag VerticalMetrics;
    public static OpenTypeTableTag PCLT;
    public static OpenTypeTableTag TTO_GSUB;
    public static OpenTypeTableTag TTO_GPOS;
    public static OpenTypeTableTag TTO_GDEF;
    public static OpenTypeTableTag TTO_BASE;
    public static OpenTypeTableTag TTO_JSTF;
}
internal class MS.Internal.Text.TextInterface.TextAnalyzer : object {
    internal static Char modopt(System.Runtime.CompilerServices.IsConst) CharHyphen;
    [SecurityCriticalAttribute]
internal TextAnalyzer(IDWriteTextAnalyzer* textAnalyzer);
    private static TextAnalyzer();
    [SecurityCriticalAttribute]
internal static IList`1<Span> Itemize(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* text, UInt32 length, CultureInfo culture, Factory factory, bool isRightToLeftParagraph, CultureInfo numberCulture, bool ignoreUserOverride, UInt32 numberSubstitutionMethod, IClassification classificationUtility, CreateTextAnalysisSink pfnCreateTextAnalysisSink, GetScriptAnalysisList pfnGetScriptAnalysisList, GetNumberSubstitutionList pfnGetNumberSubstitutionList, CreateTextAnalysisSource pfnCreateTextAnalysisSource);
    [SecurityCriticalAttribute]
internal static void AnalyzeExtendedCharactersAndDigits(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* text, UInt32 length, TextItemizer textItemizer, Byte* pCharAttribute, CultureInfo numberCulture, IClassification classificationUtility);
    [SecurityCriticalAttribute]
internal void GetGlyphsAndTheirPlacements(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* textString, UInt32 textLength, Font font, ushort blankGlyphIndex, bool isSideways, bool isRightToLeft, CultureInfo cultureInfo, DWriteFontFeature[][] features, UInt32[] featureRangeLengths, double fontEmSize, double scalingFactor, float pixelsPerDip, TextFormattingMode textFormattingMode, ItemProps itemProps, UInt16[]& clusterMap, UInt16[]& glyphIndices, Int32[]& glyphAdvances, GlyphOffset[]& glyphOffsets);
    [SecurityCriticalAttribute]
internal void GetGlyphs(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* textString, UInt32 textLength, Font font, ushort blankGlyphIndex, bool isSideways, bool isRightToLeft, CultureInfo cultureInfo, DWriteFontFeature[][] features, UInt32[] featureRangeLengths, UInt32 maxGlyphCount, TextFormattingMode textFormattingMode, ItemProps itemProps, UInt16* clusterMap, UInt16* textProps, UInt16* glyphIndices, UInt32* glyphProps, Int32* pfCanGlyphAlone, UInt32& actualGlyphCount);
    [SecurityCriticalAttribute]
internal void GetGlyphPlacements(UInt16 modopt(System.Runtime.CompilerServices.IsConst)* textString, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* clusterMap, UInt16* textProps, UInt32 textLength, UInt16 modopt(System.Runtime.CompilerServices.IsConst)* glyphIndices, UInt32* glyphProps, UInt32 glyphCount, Font font, double fontEmSize, double scalingFactor, bool isSideways, bool isRightToLeft, CultureInfo cultureInfo, DWriteFontFeature[][] features, UInt32[] featureRangeLengths, TextFormattingMode textFormattingMode, ItemProps itemProps, float pixelsPerDip, Int32* glyphAdvances, GlyphOffset[]& glyphOffsets);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute("1")]
[ClassInterfaceAttribute("0")]
internal class MS.Internal.Text.TextInterface.TextItemizer : object {
    public TextItemizer(DWriteTextAnalysisNode<MS::Internal::Text::TextInterface::Native::DWRITE_SCRIPT_ANALYSIS>* pScriptAnalysisListHead, DWriteTextAnalysisNode<MS::Internal::Text::TextInterface::Native::IDWriteNumberSubstitution *>* pNumberSubstitutionListHead);
    [SecurityCriticalAttribute]
public IList`1<Span> Itemize(CultureInfo numberCulture, Byte* pCharAttribute, UInt32 textLength);
    public void SetIsDigit(UInt32 textPosition, UInt32 textLength, bool isDigit);
}
internal static class MS.Internal.TextFormatting.Bidi : object {
    private static Bidi();
    internal static bool GetLastStongAndNumberClass(CharacterBufferRange charString, DirectionClass& strongClass, DirectionClass& numberClass);
    public static bool Analyze(Char[] chars, int cchText, int cchTextMaxHint, Flags flags, State state, Byte[]& levels, Int32& cchResolved);
    internal static bool BidiAnalyzeInternal(CharacterBuffer charBuffer, int ichText, int cchText, int cchTextMaxHint, Flags flags, State state, IList`1<byte> levels, IList`1<DirectionClass> characterClass, Int32& cchResolved);
}
internal class MS.Internal.TextFormatting.BidiState : State {
    internal byte CurrentLevel { get; }
    public DirectionClass LastNumberClass { get; public set; }
    public DirectionClass LastStrongClass { get; public set; }
    public BidiState(FormatSettings settings, int cpFirst);
    public BidiState(FormatSettings settings, int cpFirst, TextModifierScope modifierScope);
    internal void SetLastDirectionClassesAtLevelChange();
    internal byte get_CurrentLevel();
    public virtual DirectionClass get_LastNumberClass();
    public virtual void set_LastNumberClass(DirectionClass value);
    public virtual DirectionClass get_LastStrongClass();
    public virtual void set_LastStrongClass(DirectionClass value);
    internal DirectionClass GetEuropeanNumberClassOverride(CultureInfo cultureInfo);
}
internal class MS.Internal.TextFormatting.Convert : object {
    public static FlowDirection LsTFlowToFlowDirection(LsTFlow lstflow);
    public static LsKTab LsKTabFromTabAlignment(TextTabAlignment tabAlignment);
}
internal static class MS.Internal.TextFormatting.CultureMapper : object {
    private static CultureMapper();
    public static CultureInfo GetSpecificCulture(CultureInfo runCulture);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.DigitMap : ValueType {
    private NumberFormatInfo _format;
    private String[] _digits;
    internal int Item { get; }
    internal DigitMap(CultureInfo digitCulture);
    internal int get_Item(int ch);
    internal static int GetFallbackCharacter(int ch);
    internal static bool IsHighSurrogate(int ch);
    internal static bool IsLowSurrogate(int ch);
    internal static bool IsSurrogate(int ch);
    internal static int MakeUnicodeScalar(int hi, int lo);
}
internal class MS.Internal.TextFormatting.DigitState : object {
    internal CultureInfo DigitCulture { get; }
    internal bool RequiresNumberSubstitution { get; }
    internal bool Contextual { get; }
    internal CultureInfo get_DigitCulture();
    internal bool get_RequiresNumberSubstitution();
    internal bool get_Contextual();
    internal static NumberSubstitutionMethod GetResolvedSubstitutionMethod(TextRunProperties properties, CultureInfo digitCulture, Boolean& ignoreUserOverride);
    internal void SetTextRunProperties(TextRunProperties properties);
}
internal static class MS.Internal.TextFormatting.DoubleWideChar : object {
    internal static int GetChar(CharacterBuffer charBuffer, int ichText, int cchText, int charNumber, Int32& wordCount);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.DrawGlyphs : MulticastDelegate {
    public DrawGlyphs(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* puGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& origin, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* puGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& origin, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& origin, LsHeights& lsHeights, LSRECT& clippingRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.DrawingState : object {
    internal DrawingContext DrawingContext { get; }
    internal MatrixTransform AntiInversion { get; }
    internal Point LineOrigin { get; }
    internal Point VectorToLineOrigin { get; }
    internal FullTextLine CurrentLine { get; }
    internal DrawingState(DrawingContext drawingContext, Point lineOrigin, MatrixTransform antiInversion, FullTextLine currentLine);
    internal void SetGuidelineY(double runGuidelineY);
    internal void UnsetGuidelineY();
    public sealed virtual void Dispose();
    internal DrawingContext get_DrawingContext();
    internal MatrixTransform get_AntiInversion();
    internal Point get_LineOrigin();
    internal Point get_VectorToLineOrigin();
    internal FullTextLine get_CurrentLine();
}
internal class MS.Internal.TextFormatting.DrawStrikethrough : MulticastDelegate {
    public DrawStrikethrough(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptOrigin, LSRECT& clipRect, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.DrawTextRun : MulticastDelegate {
    public DrawTextRun(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* runText, Int32* charWidths, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* runText, Int32* charWidths, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptText, LSPOINT& ptRun, LsHeights& lsHeights, LSRECT& clipRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.DrawUnderline : MulticastDelegate {
    public DrawUnderline(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptOrigin, LSRECT& clipRect, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.EnumTab : MulticastDelegate {
    public EnumTab(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& pptStart, LsHeights& heights, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.EnumText : MulticastDelegate {
    public EnumText(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* charWidths, UInt16* pClusterMap, UInt16* characterProperties, UInt16* puglyphs, Int32* pGlyphAdvances, GlyphOffset* pGlyphOffsets, UInt32* pGlyphProperties, int glyphCount);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* charWidths, UInt16* pClusterMap, UInt16* characterProperties, UInt16* puglyphs, Int32* pGlyphAdvances, GlyphOffset* pGlyphOffsets, UInt32* pGlyphProperties, int glyphCount, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& pptStart, LsHeights& pheights, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.EscStringInfo : ValueType {
    public IntPtr szParaSeparator;
    public IntPtr szLineSeparator;
    public IntPtr szHidden;
    public IntPtr szNbsp;
    public IntPtr szObjectTerminator;
    public IntPtr szObjectReplacement;
}
internal class MS.Internal.TextFormatting.FetchLineProps : MulticastDelegate {
    public FetchLineProps(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsLineProps& lsLineProps, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FetchPap : MulticastDelegate {
    public FetchPap(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, LsPap& lspap);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, LsPap& lspap, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsPap& lspap, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.FetchRunRedefined : MulticastDelegate {
    public FetchRunRedefined(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FInterruptShaping : MulticastDelegate {
    public FInterruptShaping(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsTFlow textFlow, Plsrun firstPlsrun, Plsrun secondPlsrun, Int32& fIsInterruptOk);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsTFlow textFlow, Plsrun firstPlsrun, Plsrun secondPlsrun, Int32& fIsInterruptOk, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsInterruptOk, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FormatSettings : object {
    internal TextFormattingMode TextFormattingMode { get; }
    internal bool IsSideways { get; }
    internal TextFormatterImp Formatter { get; }
    internal TextSource TextSource { get; }
    internal TextLineBreak PreviousLineBreak { get; }
    internal ParaProp Pap { get; }
    internal int MaxLineWidth { get; }
    internal DigitState DigitState { get; }
    internal int TextIndent { get; }
    internal FormatSettings(TextFormatterImp formatter, TextSource textSource, TextRunCacheImp runCache, ParaProp pap, TextLineBreak previousLineBreak, bool isSingleLineFormatting, TextFormattingMode textFormattingMode, bool isSideways);
    internal TextFormattingMode get_TextFormattingMode();
    internal bool get_IsSideways();
    internal TextFormatterImp get_Formatter();
    internal TextSource get_TextSource();
    internal TextLineBreak get_PreviousLineBreak();
    internal ParaProp get_Pap();
    internal int get_MaxLineWidth();
    internal void UpdateSettingsForCurrentLine(int maxLineWidth, TextLineBreak previousLineBreak, bool isFirstLineInPara);
    internal int GetFormatWidth(int finiteFormatWidth);
    internal int GetFiniteFormatWidth(int paragraphWidth);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal CharacterBufferRange FetchTextRun(int cpFetch, int cpFirst, TextRun& textRun, Int32& runLength);
    internal TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int cpLimit);
    internal DigitState get_DigitState();
    internal int get_TextIndent();
}
internal class MS.Internal.TextFormatting.FormattedTextSymbols : object {
    public double Width { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public FormattedTextSymbols(GlyphingCache glyphingCache, TextRun textSymbols, bool rightToLeft, double scalingFactor, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    public double get_Width();
    public Rect Draw(DrawingContext drawingContext, Point currentOrigin);
}
internal class MS.Internal.TextFormatting.FullTextBreakpoint : TextBreakpoint {
    public bool IsTruncated { get; }
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static IList`1<TextBreakpoint> CreateMultiple(TextParagraphCache paragraphCache, int firstCharIndex, int maxLineWidth, TextLineBreak previousLineBreak, IntPtr penaltyRestriction, Int32& bestFitIndex);
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual TextLineBreak GetTextLineBreak();
    [SecurityCriticalAttribute]
internal virtual SecurityCriticalDataForSet`1<IntPtr> GetTextPenaltyResource();
    public virtual bool get_IsTruncated();
    public virtual int get_Length();
    public virtual int get_DependentLength();
    public virtual int get_NewlineLength();
    public virtual double get_Start();
    public virtual double get_Width();
    public virtual double get_WidthIncludingTrailingWhitespace();
    public virtual double get_Height();
    public virtual double get_TextHeight();
    public virtual double get_Baseline();
    public virtual double get_TextBaseline();
    public virtual double get_MarkerBaseline();
    public virtual double get_MarkerHeight();
}
internal class MS.Internal.TextFormatting.FullTextState : object {
    internal int CpMeasured { get; internal set; }
    internal int LscpHyphenationLookAhead { get; }
    internal TextFormattingMode TextFormattingMode { get; }
    internal bool IsSideways { get; }
    internal bool VerticalAdjust { get; internal set; }
    internal bool ForceWrap { get; internal set; }
    internal bool KeepState { get; }
    internal TextStore TextStore { get; }
    internal TextStore TextMarkerStore { get; }
    internal TextFormatterImp Formatter { get; }
    internal int FormatWidth { get; }
    internal static FullTextState Create(FormatSettings settings, int cpFirst, int finiteFormatWidth);
    internal int get_CpMeasured();
    internal void set_CpMeasured(int value);
    internal int get_LscpHyphenationLookAhead();
    internal TextFormattingMode get_TextFormattingMode();
    internal bool get_IsSideways();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void SetTabs(TextFormatterContext context);
    internal int GetMainTextToMarkerIdealDistance();
    internal LSRun CountText(int lscpLim, int cpFirst, Int32& count);
    internal int GetBreakpointInternalCp(int cp);
    internal bool FindNextHyphenBreak(int lscpCurrent, int lscchLim, bool isCurrentAtWordStart, Int32& lscpHyphen, LsHyph& lshyph);
    internal TextStore StoreFrom(Plsrun plsrun);
    internal TextStore StoreFrom(int lscp);
    internal bool get_VerticalAdjust();
    internal void set_VerticalAdjust(bool value);
    internal bool get_ForceWrap();
    internal void set_ForceWrap(bool value);
    internal bool get_KeepState();
    internal TextStore get_TextStore();
    internal TextStore get_TextMarkerStore();
    internal TextFormatterImp get_Formatter();
    internal int get_FormatWidth();
}
internal class MS.Internal.TextFormatting.GenericTextParagraphProperties : TextParagraphProperties {
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public GenericTextParagraphProperties(FlowDirection flowDirection, TextAlignment textAlignment, bool firstLineInParagraph, bool alwaysCollapsible, TextRunProperties defaultTextRunProperties, TextWrapping textWrap, double lineHeight, double indent);
    public GenericTextParagraphProperties(TextParagraphProperties textParagraphProperties);
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    public virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextWrapping get_TextWrapping();
    public virtual TextMarkerProperties get_TextMarkerProperties();
    public virtual double get_Indent();
    internal void SetFlowDirection(FlowDirection flowDirection);
    internal void SetTextAlignment(TextAlignment textAlignment);
    internal void SetLineHeight(double lineHeight);
    internal void SetTextWrapping(TextWrapping textWrap);
}
internal class MS.Internal.TextFormatting.GenericTextRunProperties : TextRunProperties {
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public TextEffectCollection TextEffects { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public GenericTextRunProperties(Typeface typeface, double size, double hintingSize, double pixelsPerDip, TextDecorationCollection textDecorations, Brush foregroundBrush, Brush backgroundBrush, BaselineAlignment baselineAlignment, CultureInfo culture, NumberSubstitution substitution);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Typeface get_Typeface();
    public virtual double get_FontRenderingEmSize();
    public virtual double get_FontHintingEmSize();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual Brush get_ForegroundBrush();
    public virtual Brush get_BackgroundBrush();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual CultureInfo get_CultureInfo();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual TextEffectCollection get_TextEffects();
    public virtual NumberSubstitution get_NumberSubstitution();
}
internal class MS.Internal.TextFormatting.GetAutoNumberInfo : MulticastDelegate {
    public GetAutoNumberInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetCharCompressionInfoFullMixed : MulticastDelegate {
    public GetCharCompressionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetCharExpansionInfoFullMixed : MulticastDelegate {
    public GetCharExpansionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetDurMaxExpandRagged : MulticastDelegate {
    public GetDurMaxExpandRagged(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& maxExpandRagged, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetGlyphCompressionInfoFullMixed : MulticastDelegate {
    public GetGlyphCompressionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetGlyphExpansionInfoFullMixed : MulticastDelegate {
    public GetGlyphExpansionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetGlyphPositions : MulticastDelegate {
    public GetGlyphPositions(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetGlyphsRedefined : MulticastDelegate {
    public GetGlyphsRedefined(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsGlyphBuffersUsed, Int32& glyphCount, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetNextHyphenOpp : MulticastDelegate {
    public GetNextHyphenOpp(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetObjectHandlerInfo : MulticastDelegate {
    public GetObjectHandlerInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, UInt32 objectId, Void* objectInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, UInt32 objectId, Void* objectInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetPrevHyphenOpp : MulticastDelegate {
    public GetPrevHyphenOpp(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class MS.Internal.TextFormatting.GetRunCharWidths : MulticastDelegate {
    public GetRunCharWidths(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsDevice device, Char* runText, int cchRun, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& cchProcessed);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsDevice device, Char* runText, int cchRun, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& cchProcessed, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& totalWidth, Int32& cchProcessed, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunStrikethroughInfo : MulticastDelegate {
    public GetRunStrikethroughInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHeights& lsHeights, LsStInfo& stInfo, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunTextMetrics : MulticastDelegate {
    public GetRunTextMetrics(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsTxM& lstTextMetrics, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunUnderlineInfo : MulticastDelegate {
    public GetRunUnderlineInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHeights& lsHeights, LsULInfo& ulInfo, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.Hyphenate : MulticastDelegate {
    public Hyphenate(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int fLastHyphenationFound, int lscpLastHyphenation, LsHyph& lastHyphenation, int lscpBeginWord, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int fLastHyphenationFound, int lscpLastHyphenation, LsHyph& lastHyphenation, int lscpBeginWord, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHyph& lastHyphenation, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineDraw : MulticastDelegate {
    public InlineDraw(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LSPOINT& runOrigin, LsTFlow textFlow, int runWidth);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LSPOINT& runOrigin, LsTFlow textFlow, int runWidth, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& runOrigin, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineFormat : MulticastDelegate {
    public InlineFormat(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineInit : ValueType {
    public UInt32 dwVersion;
    [SecurityCriticalAttribute]
public InlineFormat pfnFormat;
    [SecurityCriticalAttribute]
public InlineDraw pfnDraw;
}
internal interface MS.Internal.TextFormatting.IShapeableTextCollector {
    public abstract virtual void Add(IList`1<TextShapeableSymbols> shapeableList, CharacterBufferRange characterBufferRange, TextRunProperties textRunProperties, ItemProps textItem, ShapeTypeface shapeTypeface, double emScale, bool nullShape, TextFormattingMode textFormattingMode);
}
internal interface MS.Internal.TextFormatting.ITextMetrics {
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double MarkerHeight { get; }
    public double Baseline { get; }
    public double MarkerBaseline { get; }
    public abstract virtual int get_Length();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_MarkerBaseline();
}
internal interface MS.Internal.TextFormatting.ITextSymbols {
    public abstract virtual IList`1<TextShapeableSymbols> GetTextShapeableSymbols(GlyphingCache glyphingCache, CharacterBufferReference characterBufferReference, int characterLength, bool rightToLeft, bool isRightToLeftParagraph, CultureInfo digitCulture, TextModifierScope textModifierScope, TextFormattingMode textFormattingMode, bool isSideways);
}
internal class MS.Internal.TextFormatting.LexicalChunk : ValueType {
    private TextLexicalBreaks _breaks;
    private SpanVector`1<int> _ichVector;
    internal TextLexicalBreaks Breaks { get; }
    internal bool IsNoBreak { get; }
    internal LexicalChunk(TextLexicalBreaks breaks, SpanVector`1<int> ichVector);
    internal TextLexicalBreaks get_Breaks();
    internal bool get_IsNoBreak();
    internal int LSCPToCharacterIndex(int lsdcp);
    internal int CharacterIndexToLSCP(int ich);
}
[FlagsAttribute]
internal enum MS.Internal.TextFormatting.LineFlags : Enum {
    public int value__;
    public static LineFlags None;
    public static LineFlags BreakClassWide;
    public static LineFlags BreakClassStrict;
    public static LineFlags BreakAlways;
    public static LineFlags MinMax;
    public static LineFlags KeepState;
}
internal class MS.Internal.TextFormatting.LineServicesCallbacks : object {
    internal InlineFormat InlineFormatDelegate { get; }
    internal InlineDraw InlineDrawDelegate { get; }
    internal Exception Exception { get; internal set; }
    internal object Owner { get; internal set; }
    internal Rect BoundingBox { get; }
    internal ICollection`1<IndexedGlyphRun> IndexedGlyphRuns { get; }
    [SecurityCriticalAttribute]
internal LsErr FetchRunRedefined(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun);
    [SecurityCriticalAttribute]
internal LsErr FetchPap(IntPtr pols, int lscpFetch, LsPap& lspap);
    [SecurityCriticalAttribute]
internal LsErr FetchLineProps(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps);
    [SecurityCriticalAttribute]
internal LsErr GetRunTextMetrics(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics);
    [SecurityCriticalAttribute]
internal LsErr GetRunCharWidths(IntPtr pols, Plsrun plsrun, LsDevice device, Char* charString, int stringLength, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& stringLengthFitted);
    [SecurityCriticalAttribute]
internal LsErr GetDurMaxExpandRagged(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged);
    [SecurityCriticalAttribute]
internal LsErr GetAutoNumberInfo(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width);
    [SecurityCriticalAttribute]
internal LsErr GetRunUnderlineInfo(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo);
    [SecurityCriticalAttribute]
internal LsErr GetRunStrikethroughInfo(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo);
    [SecurityCriticalAttribute]
internal LsErr Hyphenate(IntPtr pols, int fLastHyphenFound, int lscpLastHyphen, LsHyph& lastHyph, int lscpWordStart, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    [SecurityCriticalAttribute]
internal LsErr GetNextHyphenOpp(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    [SecurityCriticalAttribute]
internal LsErr GetPrevHyphenOpp(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    [SecurityCriticalAttribute]
internal LsErr DrawStrikethrough(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    [SecurityCriticalAttribute]
internal LsErr DrawUnderline(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    [SecurityCriticalAttribute]
internal LsErr DrawTextRun(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* pwchText, Int32* piCharAdvances, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect);
    [SecurityCriticalAttribute]
internal LsErr FInterruptShaping(IntPtr pols, LsTFlow textFlow, Plsrun plsrunFirst, Plsrun plsrunSecond, Int32& fIsInterruptOk);
    internal static CultureInfo GetNumberCulture(TextRunProperties properties, NumberSubstitutionMethod& method);
    [SecurityCriticalAttribute]
internal LsErr GetGlyphsRedefined(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount);
    [SecurityCriticalAttribute]
internal LsErr GetGlyphPositions(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets);
    [SecurityCriticalAttribute]
internal LsErr DrawGlyphs(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int charCount, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect);
    [SecurityCriticalAttribute]
internal LsErr GetCharCompressionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    [SecurityCriticalAttribute]
internal LsErr GetCharExpansionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight);
    [SecurityCriticalAttribute]
internal LsErr GetGlyphCompressionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    [SecurityCriticalAttribute]
internal LsErr GetGlyphExpansionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk);
    [SecurityCriticalAttribute]
internal LsErr GetObjectHandlerInfo(IntPtr pols, UInt32 objectId, Void* objectInfo);
    [SecurityCriticalAttribute]
internal LsErr InlineFormat(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter);
    [SecurityCriticalAttribute]
internal LsErr InlineDraw(IntPtr pols, Plsrun plsrun, LSPOINT& ptRun, LsTFlow textFlow, int runWidth);
    [SecurityCriticalAttribute]
internal LsErr EnumText(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* piCharAdvances, UInt16* puClusterMap, UInt16* characterProperties, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, int glyphCount);
    [SecurityCriticalAttribute]
internal LsErr EnumTab(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun);
    [SecurityCriticalAttribute]
internal void PopulateContextInfo(LsContextInfo& contextInfo, LscbkRedefined& lscbkRedef);
    [SecurityCriticalAttribute]
internal InlineFormat get_InlineFormatDelegate();
    [SecurityCriticalAttribute]
internal InlineDraw get_InlineDrawDelegate();
    [SecurityCriticalAttribute]
internal Exception get_Exception();
    [SecurityCriticalAttribute]
internal void set_Exception(Exception value);
    [SecurityCriticalAttribute]
internal object get_Owner();
    [SecurityCriticalAttribute]
internal void set_Owner(object value);
    internal void EmptyBoundingBox();
    internal Rect get_BoundingBox();
    internal void ClearIndexedGlyphRuns();
    internal ICollection`1<IndexedGlyphRun> get_IndexedGlyphRuns();
}
internal enum MS.Internal.TextFormatting.LsBreakJust : Enum {
    public int value__;
    public static LsBreakJust lsbrjBreakJustify;
    public static LsBreakJust lsbrjBreakWithCompJustify;
    public static LsBreakJust lsbrjBreakThenExpand;
    public static LsBreakJust lsbrjBreakOptimal;
    public static LsBreakJust lsbrjBreakThenSqueeze;
}
internal class MS.Internal.TextFormatting.LsBreaks : ValueType {
    public int cBreaks;
    [SecurityCriticalAttribute]
public LsLInfo* plslinfoArray;
    [SecurityCriticalAttribute]
public IntPtr* plinepenaltyArray;
    [SecurityCriticalAttribute]
public IntPtr* pplolineArray;
}
internal enum MS.Internal.TextFormatting.LsBrkCond : Enum {
    public int value__;
    public static LsBrkCond Never;
    public static LsBrkCond Can;
    public static LsBrkCond Please;
    public static LsBrkCond Must;
}
internal class MS.Internal.TextFormatting.LscbkRedefined : ValueType {
    [SecurityCriticalAttribute]
public FetchRunRedefined pfnFetchRunRedefined;
    [SecurityCriticalAttribute]
public GetGlyphsRedefined pfnGetGlyphsRedefined;
    [SecurityCriticalAttribute]
public FetchLineProps pfnFetchLineProps;
}
internal class MS.Internal.TextFormatting.LsCharRunInfo : ValueType {
    public Plsrun plsrun;
    [SecurityCriticalAttribute]
public Char* pwch;
    [SecurityCriticalAttribute]
public Int32* rgduNominalWidth;
    [SecurityCriticalAttribute]
public Int32* rgduChangeLeft;
    [SecurityCriticalAttribute]
public Int32* rgduChangeRight;
    public int cwch;
}
internal class MS.Internal.TextFormatting.LsChp : ValueType {
    public ushort idObj;
    public ushort dcpMaxContent;
    public UInt32 effectsFlags;
    public Flags flags;
    public int dvpPos;
}
internal class MS.Internal.TextFormatting.LsContextInfo : ValueType {
    public UInt32 version;
    public int cInstalledHandlers;
    public IntPtr plsimethods;
    public int cEstimatedCharsPerLine;
    public int cJustPriorityLim;
    public char wchUndef;
    public char wchNull;
    public char wchSpace;
    public char wchHyphen;
    public char wchTab;
    public char wchPosTab;
    public char wchEndPara1;
    public char wchEndPara2;
    public char wchAltEndPara;
    public char wchEndLineInPara;
    public char wchColumnBreak;
    public char wchSectionBreak;
    public char wchPageBreak;
    public char wchNonBreakSpace;
    public char wchNonBreakHyphen;
    public char wchNonReqHyphen;
    public char wchEmDash;
    public char wchEnDash;
    public char wchEmSpace;
    public char wchEnSpace;
    public char wchNarrowSpace;
    public char wchOptBreak;
    public char wchNoBreak;
    public char wchFESpace;
    public char wchJoiner;
    public char wchNonJoiner;
    public char wchToReplace;
    public char wchReplace;
    public char wchVisiNull;
    public char wchVisiAltEndPara;
    public char wchVisiEndLineInPara;
    public char wchVisiEndPara;
    public char wchVisiSpace;
    public char wchVisiNonBreakSpace;
    public char wchVisiNonBreakHyphen;
    public char wchVisiNonReqHyphen;
    public char wchVisiTab;
    public char wchVisiPosTab;
    public char wchVisiEmSpace;
    public char wchVisiEnSpace;
    public char wchVisiNarrowSpace;
    public char wchVisiOptBreak;
    public char wchVisiNoBreak;
    public char wchVisiFESpace;
    public char wchEscAnmRun;
    public char wchPad;
    public IntPtr pols;
    [SecurityCriticalAttribute]
public IntPtr pfnNewPtr;
    [SecurityCriticalAttribute]
public IntPtr pfnDisposePtr;
    [SecurityCriticalAttribute]
public IntPtr pfnReallocPtr;
    [SecurityCriticalAttribute]
public IntPtr pfnFetchRun;
    [SecurityCriticalAttribute]
public GetAutoNumberInfo pfnGetAutoNumberInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnGetNumericSeparators;
    [SecurityCriticalAttribute]
public IntPtr pfnCheckForDigit;
    [SecurityCriticalAttribute]
public FetchPap pfnFetchPap;
    [SecurityCriticalAttribute]
public FetchLineProps pfnFetchLineProps;
    [SecurityCriticalAttribute]
public IntPtr pfnFetchTabs;
    [SecurityCriticalAttribute]
public IntPtr pfnReleaseTabsBuffer;
    [SecurityCriticalAttribute]
public IntPtr pfnGetBreakThroughTab;
    [SecurityCriticalAttribute]
public IntPtr pfnGetPosTabProps;
    [SecurityCriticalAttribute]
public IntPtr pfnFGetLastLineJustification;
    [SecurityCriticalAttribute]
public IntPtr pfnCheckParaBoundaries;
    [SecurityCriticalAttribute]
public GetRunCharWidths pfnGetRunCharWidths;
    [SecurityCriticalAttribute]
public IntPtr pfnCheckRunKernability;
    [SecurityCriticalAttribute]
public IntPtr pfnGetRunCharKerning;
    [SecurityCriticalAttribute]
public GetRunTextMetrics pfnGetRunTextMetrics;
    [SecurityCriticalAttribute]
public GetRunUnderlineInfo pfnGetRunUnderlineInfo;
    [SecurityCriticalAttribute]
public GetRunStrikethroughInfo pfnGetRunStrikethroughInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnGetBorderInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnReleaseRun;
    [SecurityCriticalAttribute]
public IntPtr pfnReleaseRunBuffer;
    [SecurityCriticalAttribute]
public Hyphenate pfnHyphenate;
    [SecurityCriticalAttribute]
public GetPrevHyphenOpp pfnGetPrevHyphenOpp;
    [SecurityCriticalAttribute]
public GetNextHyphenOpp pfnGetNextHyphenOpp;
    [SecurityCriticalAttribute]
public IntPtr pfnGetHyphenInfo;
    [SecurityCriticalAttribute]
public DrawUnderline pfnDrawUnderline;
    [SecurityCriticalAttribute]
public DrawStrikethrough pfnDrawStrikethrough;
    [SecurityCriticalAttribute]
public IntPtr pfnDrawBorder;
    [SecurityCriticalAttribute]
public IntPtr pfnFInterruptUnderline;
    [SecurityCriticalAttribute]
public IntPtr pfnFInterruptShade;
    [SecurityCriticalAttribute]
public IntPtr pfnFInterruptBorder;
    [SecurityCriticalAttribute]
public IntPtr pfnShadeRectangle;
    [SecurityCriticalAttribute]
public DrawTextRun pfnDrawTextRun;
    [SecurityCriticalAttribute]
public IntPtr pfnDrawSplatLine;
    [SecurityCriticalAttribute]
public FInterruptShaping pfnFInterruptShaping;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphs;
    [SecurityCriticalAttribute]
public GetGlyphPositions pfnGetGlyphPositions;
    [SecurityCriticalAttribute]
public DrawGlyphs pfnDrawGlyphs;
    [SecurityCriticalAttribute]
public IntPtr pfnReleaseGlyphBuffers;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphExpansionInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphExpansionInkInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphRunInk;
    [SecurityCriticalAttribute]
public IntPtr pfnGetEms;
    [SecurityCriticalAttribute]
public IntPtr pfnPunctStartLine;
    [SecurityCriticalAttribute]
public IntPtr pfnModWidthOnRun;
    [SecurityCriticalAttribute]
public IntPtr pfnModWidthSpace;
    [SecurityCriticalAttribute]
public IntPtr pfnCompOnRun;
    [SecurityCriticalAttribute]
public IntPtr pfnCompWidthSpace;
    [SecurityCriticalAttribute]
public IntPtr pfnExpOnRun;
    [SecurityCriticalAttribute]
public IntPtr pfnExpWidthSpace;
    [SecurityCriticalAttribute]
public IntPtr pfnGetModWidthClasses;
    [SecurityCriticalAttribute]
public IntPtr pfnGetBreakingClasses;
    [SecurityCriticalAttribute]
public IntPtr pfnFTruncateBefore;
    [SecurityCriticalAttribute]
public IntPtr pfnCanBreakBeforeChar;
    [SecurityCriticalAttribute]
public IntPtr pfnCanBreakAfterChar;
    [SecurityCriticalAttribute]
public IntPtr pfnFHangingPunct;
    [SecurityCriticalAttribute]
public IntPtr pfnGetSnapGrid;
    [SecurityCriticalAttribute]
public IntPtr pfnDrawEffects;
    [SecurityCriticalAttribute]
public IntPtr pfnFCancelHangingPunct;
    [SecurityCriticalAttribute]
public IntPtr pfnModifyCompAtLastChar;
    [SecurityCriticalAttribute]
public GetDurMaxExpandRagged pfnGetDurMaxExpandRagged;
    [SecurityCriticalAttribute]
public GetCharExpansionInfoFullMixed pfnGetCharExpansionInfoFullMixed;
    [SecurityCriticalAttribute]
public GetGlyphExpansionInfoFullMixed pfnGetGlyphExpansionInfoFullMixed;
    [SecurityCriticalAttribute]
public GetCharCompressionInfoFullMixed pfnGetCharCompressionInfoFullMixed;
    [SecurityCriticalAttribute]
public GetGlyphCompressionInfoFullMixed pfnGetGlyphCompressionInfoFullMixed;
    [SecurityCriticalAttribute]
public IntPtr pfnGetCharAlignmentStartLine;
    [SecurityCriticalAttribute]
public IntPtr pfnGetCharAlignmentEndLine;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphAlignmentStartLine;
    [SecurityCriticalAttribute]
public IntPtr pfnGetGlyphAlignmentEndLine;
    [SecurityCriticalAttribute]
public IntPtr pfnGetPriorityForGoodTypography;
    [SecurityCriticalAttribute]
public EnumText pfnEnumText;
    [SecurityCriticalAttribute]
public EnumTab pfnEnumTab;
    [SecurityCriticalAttribute]
public IntPtr pfnEnumPen;
    [SecurityCriticalAttribute]
public GetObjectHandlerInfo pfnGetObjectHandlerInfo;
    [SecurityCriticalAttribute]
public IntPtr pfnAssertFailedPtr;
    public int fDontReleaseRuns;
}
internal enum MS.Internal.TextFormatting.LsDevice : Enum {
    public int value__;
    public static LsDevice Presentation;
    public static LsDevice Reference;
}
internal class MS.Internal.TextFormatting.LsDevRes : ValueType {
    public UInt32 dxpInch;
    public UInt32 dypInch;
    public UInt32 dxrInch;
    public UInt32 dyrInch;
}
internal enum MS.Internal.TextFormatting.LsEndRes : Enum {
    public int value__;
    public static LsEndRes endrNormal;
    public static LsEndRes endrHyphenated;
    public static LsEndRes endrEndPara;
    public static LsEndRes endrAltPara;
    public static LsEndRes endrSoftCR;
    public static LsEndRes endrEndColumn;
    public static LsEndRes endrEndSection;
    public static LsEndRes endrEndPage;
    public static LsEndRes endrEndParaSection;
    public static LsEndRes endrStopped;
    public static LsEndRes endrBeforeFillLineObject;
    public static LsEndRes endrAfterFillLineObject;
    public static LsEndRes endrMathUserRequiredBreak;
}
internal enum MS.Internal.TextFormatting.LsErr : Enum {
    public int value__;
    public static LsErr None;
    public static LsErr InvalidParameter;
    public static LsErr OutOfMemory;
    public static LsErr NullOutputParameter;
    public static LsErr InvalidContext;
    public static LsErr InvalidLine;
    public static LsErr InvalidDnode;
    public static LsErr InvalidDeviceResolution;
    public static LsErr InvalidRun;
    public static LsErr MismatchLineContext;
    public static LsErr ContextInUse;
    public static LsErr DuplicateSpecialCharacter;
    public static LsErr InvalidAutonumRun;
    public static LsErr FormattingFunctionDisabled;
    public static LsErr UnfinishedDnode;
    public static LsErr InvalidDnodeType;
    public static LsErr InvalidPenDnode;
    public static LsErr InvalidNonPenDnode;
    public static LsErr InvalidBaselinePenDnode;
    public static LsErr InvalidFormatterResult;
    public static LsErr InvalidObjectIdFetched;
    public static LsErr InvalidDcpFetched;
    public static LsErr InvalidCpContentFetched;
    public static LsErr InvalidBookmarkType;
    public static LsErr SetDocDisabled;
    public static LsErr FiniFunctionDisabled;
    public static LsErr CurrentDnodeIsNotTab;
    public static LsErr PendingTabIsNotResolved;
    public static LsErr WrongFiniFunction;
    public static LsErr InvalidBreakingClass;
    public static LsErr BreakingTableNotSet;
    public static LsErr InvalidModWidthClass;
    public static LsErr ModWidthPairsNotSet;
    public static LsErr WrongTruncationPoint;
    public static LsErr WrongBreak;
    public static LsErr DupInvalid;
    public static LsErr RubyInvalidVersion;
    public static LsErr TatenakayokoInvalidVersion;
    public static LsErr WarichuInvalidVersion;
    public static LsErr WarichuInvalidData;
    public static LsErr CreateSublineDisabled;
    public static LsErr CurrentSublineDoesNotExist;
    public static LsErr CpOutsideSubline;
    public static LsErr HihInvalidVersion;
    public static LsErr InsufficientQueryDepth;
    public static LsErr InvalidBreakRecord;
    public static LsErr InvalidPap;
    public static LsErr ContradictoryQueryInput;
    public static LsErr LineIsNotActive;
    public static LsErr TooLongParagraph;
    public static LsErr TooManyCharsToGlyph;
    public static LsErr WrongHyphenationPosition;
    public static LsErr TooManyPriorities;
    public static LsErr WrongGivenCp;
    public static LsErr WrongCpFirstForGetBreaks;
    public static LsErr WrongJustTypeForGetBreaks;
    public static LsErr WrongJustTypeForCreateLineGivenCp;
    public static LsErr TooLongGlyphContext;
    public static LsErr InvalidCharToGlyphMapping;
    public static LsErr InvalidMathUsage;
    public static LsErr InconsistentChp;
    public static LsErr StoppedInSubline;
    public static LsErr PenPositionCouldNotBeUsed;
    public static LsErr DebugFlagsInShip;
    public static LsErr InvalidOrderTabs;
    public static LsErr OutputArrayTooSmall;
    public static LsErr SystemRestrictionsExceeded;
    public static LsErr LsInternalError;
    public static LsErr NotImplemented;
    public static LsErr ClientAbort;
}
internal enum MS.Internal.TextFormatting.LsExpType : Enum {
    public byte value__;
    public static LsExpType None;
    public static LsExpType AddWhiteSpace;
    public static LsExpType AddInkContinuous;
    public static LsExpType AddInkDiscrete;
}
internal class MS.Internal.TextFormatting.LsGlyphRunInfo : ValueType {
    public Plsrun plsrun;
    [SecurityCriticalAttribute]
public Char* pwch;
    [SecurityCriticalAttribute]
public UInt16* rggmap;
    [SecurityCriticalAttribute]
public UInt16* rgchprop;
    public int cwch;
    public int duChangeRight;
    [SecurityCriticalAttribute]
public UInt16* rggindex;
    [SecurityCriticalAttribute]
public UInt32* rggprop;
    [SecurityCriticalAttribute]
public Int32* rgduWidth;
    [SecurityCriticalAttribute]
public GlyphOffset* rggoffset;
    public int cgindex;
}
internal class MS.Internal.TextFormatting.LsHeights : ValueType {
    public int dvAscent;
    public int dvDescent;
    public int dvMultiLineHeight;
}
internal class MS.Internal.TextFormatting.LsHyph : ValueType {
    public LsKysr kysr;
    public char wchYsr;
    public char wchYsr2;
    public LsHyphenQuality lshq;
}
internal enum MS.Internal.TextFormatting.LsHyphenQuality : Enum {
    public int value__;
    public static LsHyphenQuality lshqExcellent;
    public static LsHyphenQuality lshqGood;
    public static LsHyphenQuality lshqFair;
    public static LsHyphenQuality lshqPoor;
    public static LsHyphenQuality lshqBad;
}
internal enum MS.Internal.TextFormatting.LsKAlign : Enum {
    public int value__;
    public static LsKAlign lskalLeft;
    public static LsKAlign lskalCentered;
    public static LsKAlign lskalRight;
}
internal enum MS.Internal.TextFormatting.LsKEOP : Enum {
    public int value__;
    public static LsKEOP lskeopEndPara1;
    public static LsKEOP lskeopEndPara2;
    public static LsKEOP lskeopEndPara12;
    public static LsKEOP lskeopEndParaAlt;
}
internal enum MS.Internal.TextFormatting.LsKJust : Enum {
    public int value__;
    public static LsKJust lskjFullInterWord;
    public static LsKJust lskjFullInterLetterAligned;
    public static LsKJust lskjFullScaled;
    public static LsKJust lskjFullGlyphs;
    public static LsKJust lskjFullMixed;
    public static LsKJust lskjSnapGrid;
}
internal enum MS.Internal.TextFormatting.LsKTab : Enum {
    public int value__;
    public static LsKTab lsktLeft;
    public static LsKTab lsktCenter;
    public static LsKTab lsktRight;
    public static LsKTab lsktDecimal;
    public static LsKTab lsktChar;
}
internal enum MS.Internal.TextFormatting.LsKysr : Enum {
    public int value__;
    public static LsKysr kysrNormal;
    public static LsKysr kysrAddBefore;
    public static LsKysr kysrChangeBefore;
    public static LsKysr kysrDeleteBefore;
    public static LsKysr kysrChangeAfter;
    public static LsKysr kysrDelAndChange;
    public static LsKysr kysrAddBeforeChangeAfter;
}
internal class MS.Internal.TextFormatting.LsLineProps : ValueType {
    public LsKAlign lskal;
    public int durLeft;
    public int durRightBreak;
    public int durRightJustify;
    public int fProhibitHyphenation;
    public int durHyphenationZone;
}
internal class MS.Internal.TextFormatting.LsLineWidths : ValueType {
    public int upStartMarker;
    public int upLimMarker;
    public int upStartMainText;
    public int upStartTrailing;
    public int upLimLine;
    public int upMinStartTrailing;
    public int upMinLimLine;
}
internal class MS.Internal.TextFormatting.LsLInfo : ValueType {
    public int dvpAscent;
    public int dvrAscent;
    public int dvpDescent;
    public int dvrDescent;
    public int dvpMultiLineHeight;
    public int dvrMultiLineHeight;
    public int dvpAscentAutoNumber;
    public int dvrAscentAutoNumber;
    public int dvpDescentAutoNumber;
    public int dvrDescentAutoNumber;
    public int cpLimToContinue;
    public int cpLimToStay;
    public int dcpDepend;
    public int cpFirstVis;
    public LsEndRes endr;
    public int fAdvanced;
    public int vaAdvance;
    public int fFirstLineInPara;
    public int fTabInMarginExLine;
    public int fForcedBreak;
    public UInt32 EffectsFlags;
}
internal class MS.Internal.TextFormatting.LsNeighborInfo : ValueType {
    public UInt32 fNeighborIsPresent;
    public UInt32 fNeighborIsText;
    public Plsrun plsrun;
    public char wch;
    public UInt32 fGlyphBased;
    public ushort chprop;
    public ushort gindex;
    public UInt32 gprop;
}
internal class MS.Internal.TextFormatting.LsPap : ValueType {
    public int cpFirst;
    public int cpFirstContent;
    public Flags grpf;
    public LsBreakJust lsbrj;
    public LsKJust lskj;
    public int fJustify;
    public int durAutoDecimalTab;
    public LsKEOP lskeop;
    public LsTFlow lstflow;
}
internal class MS.Internal.TextFormatting.LSPOINT : ValueType {
    public int x;
    public int y;
    public LSPOINT(int horizontalPosition, int verticalPosition);
}
internal class MS.Internal.TextFormatting.LsQSubInfo : ValueType {
    public LsTFlow lstflowSubLine;
    public int lscpFirstSubLine;
    public int lsdcpSubLine;
    public LSPOINT pointUvStartSubLine;
    public LsHeights lsHeightsPresSubLine;
    public int dupSubLine;
    public UInt32 idobj;
    public IntPtr plsrun;
    public int lscpFirstRun;
    public int lsdcpRun;
    public LSPOINT pointUvStartRun;
    public LsHeights lsHeightsPresRun;
    public int dupRun;
    public int dvpPosRun;
    public int dupBorderBefore;
    public int dupBorderAfter;
    public LSPOINT pointUvStartObj;
    public LsHeights lsHeightsPresObj;
    public int dupObj;
}
internal class MS.Internal.TextFormatting.LSRECT : ValueType {
    public int left;
    public int top;
    public int right;
    public int bottom;
    internal LSRECT(int x1, int y1, int x2, int y2);
}
internal class MS.Internal.TextFormatting.LSRun : object {
    internal bool IsHitTestable { get; }
    internal bool IsVisible { get; }
    internal bool IsNewline { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal byte BidiLevel { get; }
    internal bool IsSymbol { get; }
    internal int OffsetToFirstCp { get; }
    internal int Length { get; }
    internal TextModifierScope TextModifierScope { get; }
    internal Plsrun Type { get; }
    internal ushort CharacterAttributeFlags { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int StringLength { get; }
    internal int OffsetToFirstChar { get; }
    internal TextRun TextRun { get; }
    internal TextShapeableSymbols Shapeable { get; }
    internal int BaselineOffset { get; internal set; }
    internal int Height { get; internal set; }
    internal int Descent { get; }
    internal TextRunProperties RunProp { get; }
    internal CultureInfo TextCulture { get; }
    internal int EmSize { get; }
    internal int BaselineMoveOffset { get; }
    internal LSRun(TextRunInfo runInfo, IList`1<TextEffect> textEffects, Plsrun type, int offsetToFirstCp, int textRunLength, int emSize, ushort charFlags, CharacterBufferRange charBufferRange, TextShapeableSymbols shapeable, double realToIdeal, byte bidiLevel);
    internal LSRun(Plsrun type, IntPtr controlChar);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal LSRun(TextRunInfo runInfo, Plsrun type, IntPtr controlChar, int textRunLength, int offsetToFirstCp, byte bidiLevel);
    internal void Truncate(int newLength);
    internal bool get_IsHitTestable();
    internal bool get_IsVisible();
    internal bool get_IsNewline();
    internal bool get_NeedsCaretInfo();
    internal bool get_HasExtendedCharacter();
    internal Rect DrawGlyphRun(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal static Point UVToXY(Point origin, Point vectorToOrigin, double u, double v, FullTextLine line);
    internal static Point UVToXY(Point origin, Point vectorToOrigin, int u, int v, FullTextLine line);
    internal static void UVToNominalXY(Point origin, Point vectorToOrigin, int u, int v, FullTextLine line, Int32& nominalX, Int32& nominalY);
    internal static Rect RectUV(Point origin, LSPOINT topLeft, LSPOINT bottomRight, FullTextLine line);
    internal void Move(int baselineMoveOffset);
    internal byte get_BidiLevel();
    internal bool get_IsSymbol();
    internal int get_OffsetToFirstCp();
    internal int get_Length();
    internal TextModifierScope get_TextModifierScope();
    internal Plsrun get_Type();
    internal ushort get_CharacterAttributeFlags();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_StringLength();
    internal int get_OffsetToFirstChar();
    internal TextRun get_TextRun();
    internal TextShapeableSymbols get_Shapeable();
    internal int get_BaselineOffset();
    internal void set_BaselineOffset(int value);
    internal int get_Height();
    internal void set_Height(int value);
    internal int get_Descent();
    internal TextRunProperties get_RunProp();
    internal CultureInfo get_TextCulture();
    internal int get_EmSize();
    internal int get_BaselineMoveOffset();
    [SecurityCriticalAttribute]
internal static void CompileFeatureSet(LSRun[] lsruns, Int32* pcchRuns, UInt32 totalLength, DWriteFontFeature[][]& fontFeatures, UInt32[]& fontFeatureRanges);
    internal static void CompileFeatureSet(TextRunTypographyProperties textRunTypographyProperties, UInt32 totalLength, DWriteFontFeature[][]& fontFeatures, UInt32[]& fontFeatureRanges);
}
internal class MS.Internal.TextFormatting.LsStInfo : ValueType {
    public UInt32 kstBase;
    public int cNumberOfLines;
    public int dvpLowerStrikethroughOffset;
    public int dvpLowerStrikethroughSize;
    public int dvpUpperStrikethroughOffset;
    public int dvpUpperStrikethroughSize;
}
internal class MS.Internal.TextFormatting.LsTbd : ValueType {
    public LsKTab lskt;
    public int ur;
    public char wchTabLeader;
    public char wchCharTab;
}
internal class MS.Internal.TextFormatting.LsTextCell : ValueType {
    public int lscpStartCell;
    public int lscpEndCell;
    public LSPOINT pointUvStartCell;
    public int dupCell;
    public int cCharsInCell;
    public int cGlyphsInCell;
    public IntPtr plsCellDetails;
}
internal enum MS.Internal.TextFormatting.LsTFlow : Enum {
    public int value__;
    public static LsTFlow lstflowDefault;
    public static LsTFlow lstflowES;
    public static LsTFlow lstflowEN;
    public static LsTFlow lstflowSE;
    public static LsTFlow lstflowSW;
    public static LsTFlow lstflowWS;
    public static LsTFlow lstflowWN;
    public static LsTFlow lstflowNE;
    public static LsTFlow lstflowNW;
}
internal class MS.Internal.TextFormatting.LsTxM : ValueType {
    public int dvAscent;
    public int dvDescent;
    public int dvMultiLineHeight;
    public int fMonospaced;
}
internal class MS.Internal.TextFormatting.LsULInfo : ValueType {
    public UInt32 kulBase;
    public int cNumberOfLines;
    public int dvpUnderlineOriginOffset;
    public int dvpFirstUnderlineOffset;
    public int dvpFirstUnderlineSize;
    public int dvpGapBetweenLines;
    public int dvpSecondUnderlineSize;
}
internal class MS.Internal.TextFormatting.ObjDim : ValueType {
    public LsHeights heightsRef;
    public LsHeights heightsPres;
    public int dur;
}
internal class MS.Internal.TextFormatting.ParaProp : object {
    internal bool RightToLeft { get; }
    internal bool OptimalBreak { get; }
    internal bool FirstLineInParagraph { get; }
    internal bool AlwaysCollapsible { get; }
    internal int Indent { get; }
    internal int ParagraphIndent { get; }
    internal double DefaultIncrementalTab { get; }
    internal IList`1<TextTabProperties> Tabs { get; }
    internal TextAlignment Align { get; }
    internal bool Justify { get; }
    internal bool EmergencyWrap { get; }
    internal bool Wrap { get; }
    internal Typeface DefaultTypeface { get; }
    internal int EmSize { get; }
    internal int LineHeight { get; }
    internal TextMarkerProperties TextMarkerProperties { get; }
    internal TextLexicalService Hyphenator { get; }
    internal TextDecorationCollection TextDecorations { get; }
    internal Brush DefaultTextDecorationsBrush { get; }
    internal ParaProp(TextFormatterImp formatter, TextParagraphProperties paragraphProperties, bool optimalBreak);
    internal bool get_RightToLeft();
    internal bool get_OptimalBreak();
    internal bool get_FirstLineInParagraph();
    internal bool get_AlwaysCollapsible();
    internal int get_Indent();
    internal int get_ParagraphIndent();
    internal double get_DefaultIncrementalTab();
    internal IList`1<TextTabProperties> get_Tabs();
    internal TextAlignment get_Align();
    internal bool get_Justify();
    internal bool get_EmergencyWrap();
    internal bool get_Wrap();
    internal Typeface get_DefaultTypeface();
    internal int get_EmSize();
    internal int get_LineHeight();
    internal TextMarkerProperties get_TextMarkerProperties();
    internal TextLexicalService get_Hyphenator();
    internal TextDecorationCollection get_TextDecorations();
    internal Brush get_DefaultTextDecorationsBrush();
}
internal enum MS.Internal.TextFormatting.Plsrun : Enum {
    public UInt32 value__;
    public static Plsrun CloseAnchor;
    public static Plsrun Reverse;
    public static Plsrun FakeLineBreak;
    public static Plsrun FormatAnchor;
    public static Plsrun Hidden;
    public static Plsrun Text;
    public static Plsrun InlineObject;
    public static Plsrun LineBreak;
    public static Plsrun ParaBreak;
    public static Plsrun Undefined;
    public static Plsrun IsMarker;
    public static Plsrun UseNewCharacterBuffer;
    public static Plsrun IsSymbol;
    public static Plsrun UnmaskAll;
}
internal class MS.Internal.TextFormatting.SimpleRun : object {
    public CharacterBufferReference CharBufferReference;
    public int Length;
    public Int32[] NominalAdvances;
    public int IdealWidth;
    public TextRun TextRun;
    public TextDecoration Underline;
    public Flags RunFlags;
    internal bool EOT { get; }
    internal bool Ghost { get; }
    internal bool Tab { get; }
    internal bool TrimTrailingUnderline { get; internal set; }
    internal double Baseline { get; }
    internal double Height { get; }
    internal Typeface Typeface { get; }
    internal double EmSize { get; }
    internal bool IsVisible { get; }
    internal SimpleRun(TextFormatterImp textFormatterImp, double pixelsPerDip);
    internal bool get_EOT();
    internal bool get_Ghost();
    internal bool get_Tab();
    internal bool get_TrimTrailingUnderline();
    internal void set_TrimTrailingUnderline(bool value);
    internal double get_Baseline();
    internal double get_Height();
    internal Typeface get_Typeface();
    internal double get_EmSize();
    internal bool get_IsVisible();
    public static SimpleRun Create(FormatSettings settings, int cp, int cpFirst, int widthLeft, int widthMax, int idealRunOffsetUnRounded, double pixelsPerDip);
    public static SimpleRun Create(FormatSettings settings, CharacterBufferRange charString, TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip);
    internal static SimpleRun CreateSimpleTextRun(CharacterBufferRange charBufferRange, TextRun textRun, TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Rect Draw(DrawingContext drawingContext, double x, double y, bool visiCodePath);
    internal bool CollectTrailingSpaces(TextFormatterImp formatter, Int32& trailing, Int32& trailingSpaceWidth);
    internal bool IsUnderlineCompatible(SimpleRun nextRun);
    internal int DistanceFromDcp(int dcp);
    internal CharacterHit DcpFromDistance(int idealDistance);
}
internal class MS.Internal.TextFormatting.SimpleTextLine : TextLine {
    public int Length { get; }
    public int TrailingWhitespaceLength { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double OverhangAfter { get; }
    public bool HasOverflowed { get; }
    public bool HasCollapsed { get; }
    public SimpleTextLine(FormatSettings settings, int cpFirst, int paragraphWidth, ArrayList runs, Int32& trailing, Int32& trailingSpaceWidth, double pixelsPerDip);
    public static TextLine Create(FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip);
    public virtual void Dispose();
    public virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    [SecurityCriticalAttribute]
public virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public virtual TextLineBreak GetTextLineBreak();
    public virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public virtual int get_Length();
    public virtual int get_TrailingWhitespaceLength();
    public virtual int get_DependentLength();
    public virtual int get_NewlineLength();
    public virtual double get_Start();
    public virtual double get_Width();
    public virtual double get_WidthIncludingTrailingWhitespace();
    public virtual double get_Height();
    public virtual double get_TextHeight();
    public virtual double get_Extent();
    public virtual double get_Baseline();
    public virtual double get_TextBaseline();
    public virtual double get_MarkerBaseline();
    public virtual double get_MarkerHeight();
    public virtual double get_OverhangLeading();
    public virtual double get_OverhangTrailing();
    public virtual double get_OverhangAfter();
    public virtual bool get_HasOverflowed();
    public virtual bool get_HasCollapsed();
}
internal class MS.Internal.TextFormatting.TextFormatterImp : TextFormatter {
    internal TextFormattingMode TextFormattingMode { get; }
    internal static double ToIdeal { get; }
    internal GlyphingCache GlyphingCache { get; }
    internal TextAnalyzer TextAnalyzer { get; }
    internal TextFormatterImp(TextFormattingMode textFormattingMode);
    internal TextFormatterImp(TextFormatterContext soleContext, TextFormattingMode textFormattingMode);
    protected virtual override void Finalize();
    public virtual void Dispose();
    public virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    internal virtual TextLine RecreateLine(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
    internal TextFormattingMode get_TextFormattingMode();
    internal virtual TextParagraphCache CreateParagraphCache(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    internal static void VerifyCaretCharacterHit(CharacterHit characterHit, int cpFirst, int cchLength);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextFormatterContext AcquireContext(object owner, IntPtr ploc);
    internal static MatrixTransform CreateAntiInversionTransform(InvertAxes inversion, double paragraphWidth, double lineHeight);
    internal static int CompareReal(double x, double y, double pixelsPerDip, TextFormattingMode mode);
    internal static double RoundDip(double value, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal static double RoundDipForDisplayMode(double value, double pixelsPerDip);
    internal static double RoundDipForDisplayModeJustifiedText(double value, double pixelsPerDip);
    internal static double IdealToRealWithNoRounding(double i);
    internal double IdealToReal(double i, double pixelsPerDip);
    internal static int RealToIdeal(double i);
    internal static int RealToIdealFloor(double i);
    internal static double get_ToIdeal();
    internal GlyphingCache get_GlyphingCache();
    [SecuritySafeCriticalAttribute]
internal TextAnalyzer get_TextAnalyzer();
}
internal class MS.Internal.TextFormatting.TextMarkerSource : TextSource {
    internal TextMarkerSource(TextParagraphProperties textParagraphProperties, TextMarkerStyle markerStyle, int autoNumberingIndex);
    private static TextMarkerSource();
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    internal static bool IsKnownSymbolMarkerStyle(TextMarkerStyle markerStyle);
    internal static bool IsKnownIndexMarkerStyle(TextMarkerStyle markerStyle);
}
internal class MS.Internal.TextFormatting.TextMetrics : ValueType {
    private TextFormatterImp _formatter;
    private int _lscpLim;
    private int _cchLength;
    private int _cchDepend;
    private int _cchNewline;
    private int _height;
    private int _textHeight;
    private int _baselineOffset;
    private int _textAscent;
    private int _textStart;
    private int _textWidth;
    private int _textWidthAtTrailing;
    private int _paragraphToText;
    private LSRun _lastRun;
    private double _pixelsPerDip;
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    [SecurityCriticalAttribute]
internal void Compute(FullTextState fullText, int firstCharIndex, int paragraphWidth, FormattedTextSymbols collapsingSymbol, LsLineWidths& lineWidths, LsLInfo* plsLineInfo);
    [SecurityCriticalAttribute]
internal TextLineBreak GetTextLineBreak(IntPtr ploline);
    public sealed virtual int get_Length();
    public sealed virtual int get_DependentLength();
    public sealed virtual int get_NewlineLength();
    public sealed virtual double get_Start();
    public sealed virtual double get_Width();
    public sealed virtual double get_WidthIncludingTrailingWhitespace();
    public sealed virtual double get_Height();
    public double get_TextHeight();
    public sealed virtual double get_Baseline();
    public double get_TextBaseline();
    public sealed virtual double get_MarkerBaseline();
    public sealed virtual double get_MarkerHeight();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TextFormatting.TextPenaltyModule : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal TextPenaltyModule(SecurityCriticalDataForSet`1<IntPtr> ploc);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
internal IntPtr DangerousGetHandle();
}
internal class MS.Internal.TextFormatting.TextRunCacheImp : object {
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    internal TextRun FetchTextRun(FormatSettings settings, int cpFetch, int cpFirst, Int32& offsetToFirstCp, Int32& runLength);
    internal TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(TextSource textSource, int cpLimit);
    internal IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
}
internal class MS.Internal.TextFormatting.TextRunInfo : object {
    internal TextRun TextRun { get; }
    internal TextRunProperties Properties { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    internal int OffsetToFirstCp { get; }
    internal int StringLength { get; internal set; }
    internal int Length { get; internal set; }
    internal ushort CharacterAttributeFlags { get; internal set; }
    internal CultureInfo DigitCulture { get; }
    internal bool ContextualSubstitution { get; }
    internal bool IsSymbol { get; }
    internal Plsrun Plsrun { get; }
    internal bool IsEndOfLine { get; }
    internal TextModifierScope TextModifierScope { get; }
    internal TextRunInfo(CharacterBufferRange charBufferRange, int textRunLength, int offsetToFirstCp, TextRun textRun, Plsrun lsRunType, ushort charFlags, CultureInfo digitCulture, bool contextualSubstitution, bool symbolTypeface, TextModifierScope modifierScope);
    internal TextRun get_TextRun();
    internal TextRunProperties get_Properties();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
    internal int get_OffsetToFirstCp();
    internal int get_StringLength();
    internal void set_StringLength(int value);
    internal int get_Length();
    internal void set_Length(int value);
    internal ushort get_CharacterAttributeFlags();
    internal void set_CharacterAttributeFlags(ushort value);
    internal CultureInfo get_DigitCulture();
    internal bool get_ContextualSubstitution();
    internal bool get_IsSymbol();
    internal Plsrun get_Plsrun();
    internal bool get_IsEndOfLine();
    internal TextModifierScope get_TextModifierScope();
    internal int GetRoughWidth(double realToIdeal);
    internal static Plsrun GetRunType(TextRun textRun);
}
internal abstract class MS.Internal.TextFormatting.TextShapeableSymbols : TextRun {
    internal bool IsShapingRequired { get; }
    internal bool NeedsMaxClusterSize { get; }
    internal ushort MaxClusterSize { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal GlyphTypeface GlyphTypeFace { get; }
    internal double EmSize { get; }
    internal ItemProps ItemProps { get; }
    internal double Height { get; }
    internal double Baseline { get; }
    internal double UnderlinePosition { get; }
    internal double UnderlineThickness { get; }
    internal double StrikethroughPosition { get; }
    internal double StrikethroughThickness { get; }
    internal abstract virtual GlyphRun ComputeShapedGlyphRun(Point origin, Char[] characterString, UInt16[] clusterMap, UInt16[] glyphIndices, IList`1<double> glyphAdvances, IList`1<Point> glyphOffsets, bool rightToLeft, bool sideways);
    internal abstract virtual bool CanShapeTogether(TextShapeableSymbols shapeable);
    internal abstract virtual bool get_IsShapingRequired();
    internal abstract virtual bool get_NeedsMaxClusterSize();
    internal abstract virtual ushort get_MaxClusterSize();
    internal abstract virtual bool get_NeedsCaretInfo();
    internal abstract virtual bool get_HasExtendedCharacter();
    internal abstract virtual GlyphTypeface get_GlyphTypeFace();
    internal abstract virtual double get_EmSize();
    internal abstract virtual ItemProps get_ItemProps();
    [SecurityCriticalAttribute]
internal abstract virtual void GetAdvanceWidthsUnshaped(Char* characterString, int characterLength, double scalingFactor, Int32* advanceWidthsUnshaped);
    internal abstract virtual GlyphRun ComputeUnshapedGlyphRun(Point origin, Char[] characterString, IList`1<double> characterAdvances);
    internal abstract virtual void Draw(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal abstract virtual double get_Height();
    internal abstract virtual double get_Baseline();
    internal abstract virtual double get_UnderlinePosition();
    internal abstract virtual double get_UnderlineThickness();
    internal abstract virtual double get_StrikethroughPosition();
    internal abstract virtual double get_StrikethroughThickness();
}
internal class MS.Internal.TextFormatting.TextStore : object {
    internal static LSRun[] ControlRuns;
    internal static int LscpFirstMarker;
    internal static int TypicalCharactersPerLine;
    internal static char CharLineSeparator;
    internal static char CharParaSeparator;
    internal static char CharLineFeed;
    internal static char CharCarriageReturn;
    internal static char CharTab;
    internal static IntPtr PwchParaSeparator;
    internal static IntPtr PwchLineSeparator;
    internal static IntPtr PwchNbsp;
    internal static IntPtr PwchHidden;
    internal static IntPtr PwchObjectTerminator;
    internal static IntPtr PwchObjectReplacement;
    internal static int MaxCharactersPerLine;
    internal FormatSettings Settings { get; }
    internal ParaProp Pap { get; }
    internal int CpFirst { get; }
    internal SpanVector PlsrunVector { get; }
    internal ArrayList LsrunList { get; }
    internal int FormatWidth { get; }
    internal int CchEol { get; internal set; }
    private static TextStore();
    public TextStore(FormatSettings settings, int cpFirst, int lscpFirstValue, int formatWidth);
    internal LSRun FetchLSRun(int lscpFetch, TextFormattingMode textFormattingMode, bool isSideways, Plsrun& plsrun, Int32& lsrunOffset, Int32& lsrunLength);
    internal TextRunInfo FetchTextRun(int cpFetch);
    internal bool InsertFakeLineBreak(int cpLimit);
    internal int GetExternalCp(int lscp);
    internal LSRun GetRun(Plsrun plsrun);
    internal static bool IsMarker(Plsrun plsrun);
    internal static Plsrun MakePlsrunMarker(Plsrun plsrun);
    internal static Plsrun MakePlsrunSymbol(Plsrun plsrun);
    internal static Plsrun ToIndex(Plsrun plsrun);
    internal static bool IsContent(Plsrun plsrun);
    internal static bool IsSpace(char ch);
    internal static bool IsStrong(char ch);
    internal static bool IsNewline(Plsrun plsrun);
    internal static bool IsNewline(ushort flags);
    internal void AdjustRunsVerticalOffset(int dcpLimit, int height, int baselineOffset, Int32& cellHeight, Int32& cellAscent);
    internal Char[] CollectRawWord(int lscpCurrent, bool isCurrentAtWordStart, bool isSideways, Int32& lscpChunk, Int32& lscchChunk, CultureInfo& textCulture, Int32& cchWordMax, SpanVector`1& textVector);
    internal TextEmbeddedObjectMetrics FormatTextObject(TextEmbeddedObject textObject, int cpFirst, int currentPosition, int rightMargin);
    internal FormatSettings get_Settings();
    internal ParaProp get_Pap();
    internal int get_CpFirst();
    internal SpanVector get_PlsrunVector();
    internal ArrayList get_LsrunList();
    internal int get_FormatWidth();
    internal int get_CchEol();
    internal void set_CchEol(int value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.ThousandthOfEmRealDoubles : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public double Item { get; public set; }
    internal ThousandthOfEmRealDoubles(double emSize, int capacity);
    internal ThousandthOfEmRealDoubles(double emSize, IList`1<double> realValues);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    public sealed virtual int IndexOf(double item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(double item);
    public sealed virtual void CopyTo(Double[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.TextFormatting.ThousandthOfEmRealDoubles/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<double> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(double value);
    public sealed virtual void Insert(int index, double item);
    public sealed virtual bool Remove(double item);
    public sealed virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.ThousandthOfEmRealPoints : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Point Item { get; public set; }
    internal ThousandthOfEmRealPoints(double emSize, int capacity);
    internal ThousandthOfEmRealPoints(double emSize, IList`1<Point> pointValues);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    public sealed virtual int IndexOf(Point item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point item);
    public sealed virtual void CopyTo(Point[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.TextFormatting.ThousandthOfEmRealPoints/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<Point> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(Point value);
    public sealed virtual void Insert(int index, Point item);
    public sealed virtual bool Remove(Point item);
    public sealed virtual void RemoveAt(int index);
}
internal static class MS.Internal.TextFormatting.UnsafeNativeMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoCreateContext(LsContextInfo& contextInfo, LscbkRedefined& lscbkRedef, IntPtr& ploc);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoDestroyContext(IntPtr ploc);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoCreateLine(IntPtr ploc, int cp, int ccpLim, int durColumn, UInt32 dwLineFlags, IntPtr pInputBreakRec, LsLInfo& plslinfo, IntPtr& pploline, Int32& maxDepth, LsLineWidths& lineWidths);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoDisposeLine(IntPtr ploline, bool finalizing);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoAcquireBreakRecord(IntPtr ploline, IntPtr& pbreakrec);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoDisposeBreakRecord(IntPtr pBreakRec, bool finalizing);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoCloneBreakRecord(IntPtr pBreakRec, IntPtr& pBreakRecClone);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoRelievePenaltyResource(IntPtr ploline);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoSetBreaking(IntPtr ploc, int strategy);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoSetDoc(IntPtr ploc, int isDisplay, int isReferencePresentationEqual, LsDevRes& deviceInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoSetTabs(IntPtr ploc, int durIncrementalTab, int tabCount, LsTbd* pTabs);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoDisplayLine(IntPtr ploline, LSPOINT& pt, UInt32 displayMode, LSRECT& clipRect);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoEnumLine(IntPtr ploline, bool reverseOder, bool fGeometryneeded, LSPOINT& pt);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoQueryLineCpPpoint(IntPtr ploline, int lscpQuery, int depthQueryMax, IntPtr pSubLineInfo, Int32& actualDepthQuery, LsTextCell& lsTextCell);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoQueryLinePointPcp(IntPtr ploline, LSPOINT& ptQuery, int depthQueryMax, IntPtr pSubLineInfo, Int32& actualDepthQuery, LsTextCell& lsTextCell);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoCreateBreaks(IntPtr ploc, int cpFirst, IntPtr previousBreakRecord, IntPtr ploparabreak, IntPtr ptslinevariantRestriction, LsBreaks& lsbreaks, Int32& bestFitIndex);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoCreateParaBreakingSession(IntPtr ploc, int cpParagraphFirst, int maxWidth, IntPtr previousParaBreakRecord, IntPtr& pploparabreak, Boolean& fParagraphJustified);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoDisposeParaBreakingSession(IntPtr ploparabreak, bool finalizing);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LocbkGetObjectHandlerInfo(IntPtr ploc, UInt32 objectId, Void* objectInfo);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void LoGetEscString(EscStringInfo& escStringInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoAcquirePenaltyModule(IntPtr ploc, IntPtr& penaltyModuleHandle);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static LsErr LoDisposePenaltyModule(IntPtr penaltyModuleHandle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static LsErr LoGetPenaltyModuleInternalHandle(IntPtr penaltyModuleHandle, IntPtr& penaltyModuleInternalHandle);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static Void* CreateTextAnalysisSink();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static Void* GetScriptAnalysisList(Void* textAnalysisSink);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static Void* GetNumberSubstitutionList(Void* textAnalysisSink);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CreateTextAnalysisSource(UInt16* text, UInt32 length, UInt16* culture, Void* factory, bool isRightToLeft, UInt16* numberCulture, bool ignoreUserOverride, UInt32 numberSubstitutionMethod, Void** ppTextAnalysisSource);
}
internal static class MS.Internal.TimeEnumHelper : object {
    internal static bool IsValidFillBehavior(FillBehavior value);
    internal static bool IsValidSlipBehavior(SlipBehavior value);
    internal static bool IsValidTimeSeekOrigin(TimeSeekOrigin value);
    internal static bool IsValidPathAnimationSource(PathAnimationSource value);
}
internal static class MS.Internal.TraceAnimation : object {
    public static AvTraceDetails StoryboardBegin { get; }
    public static AvTraceDetails StoryboardPause { get; }
    public static AvTraceDetails StoryboardRemove { get; }
    public static AvTraceDetails StoryboardResume { get; }
    public static AvTraceDetails StoryboardStop { get; }
    public static AvTraceDetails StoryboardNotApplied { get; }
    public static AvTraceDetails AnimateStorageValidationFailed { get; }
    public static AvTraceDetails AnimateStorageValidationNoLongerFailing { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceAnimation();
    public static AvTraceDetails get_StoryboardBegin();
    public static AvTraceDetails get_StoryboardPause();
    public static AvTraceDetails get_StoryboardRemove();
    public static AvTraceDetails get_StoryboardResume();
    public static AvTraceDetails get_StoryboardStop();
    public static AvTraceDetails get_StoryboardNotApplied();
    public static AvTraceDetails get_AnimateStorageValidationFailed();
    public static AvTraceDetails get_AnimateStorageValidationNoLongerFailing();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceRoutedEvent : object {
    public static AvTraceDetails RaiseEvent { get; }
    public static AvTraceDetails ReRaiseEventAs { get; }
    public static AvTraceDetails HandleEvent { get; }
    public static AvTraceDetails InvokeHandlers { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceRoutedEvent();
    public static AvTraceDetails get_RaiseEvent();
    public static AvTraceDetails get_ReRaiseEventAs();
    public static AvTraceDetails get_HandleEvent();
    public static AvTraceDetails get_InvokeHandlers();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TrueTypeSubsetter : object {
    [SecurityCriticalAttribute]
public static Byte[] ComputeSubset(Void* fontData, int fileSize, Uri sourceUri, int directoryOffset, UInt16[] glyphArray);
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASEAXIS : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASECOORDFORMAT2 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASEFEATMINMAXRECORD : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASEHEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASELANGSYSRECORD : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASEMINMAX : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.BASESCRIPT : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASESCRIPTLIST : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.BASESCRIPTRECORD : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.BASEVALUES : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.Char_Glyph_Map_List : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.Char_Glyph_Map_List_Ex : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.CMAP_FORMAT0 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CMAP_FORMAT12 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.CMAP_FORMAT4 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CMAP_FORMAT6 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CMAP_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CMAP_SUBHEADER_GEN : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CMAP_TABLELOC : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.cmapoffsetrecordkeeper : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CODEOFFSETPAIR : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.CONST_TTFACC_FILEBUFFERINFO : ValueType {
}
internal class MS.Internal.TtfDelta.ControlTableInit : object {
    private static ControlTableInit();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public static void Init();
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.DIRECTORY : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.DTTF_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.EBLCHEADER : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.FORMAT12_GROUPS : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.FORMAT4_SEGMENTS : ValueType {
}
internal class MS.Internal.TtfDelta.GlobalInit : object {
    private static GlobalInit();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void Init();
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GLYF_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.glyphoffsetrecordkeeper : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.groupoffsetrecordkeeper : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.GSUBALTERNATESUBSTFORMAT1 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.GSUBCOVERAGEFORMAT1 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBCOVERAGEFORMAT2 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBHEADER : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBLIGATURE : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBLIGATURESUBSTFORMAT1 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBLOOKUP : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.GSUBLOOKUPLIST : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.GSUBMULTIPLESUBSTFORMAT1 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBRANGERECORD : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.GSUBSINGLESUBSTFORMAT1 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.GSUBSINGLESUBSTFORMAT2 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.HDMX : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.HDMX_DEVICE_REC : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.HEAD : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.HHEA : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.ImageDataBlock : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.IndexOffset : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBHEADER : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLE1 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLE2 : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLE3 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLE4 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLE5 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.INDEXSUBTABLEARRAY : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.JSTFEXTENDERGLYPH : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.JSTFHEADER : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.JSTFSCRIPT : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.JSTFSCRIPTRECORD : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.KERN_FORMAT_0 : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.KERN_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.KERN_PAIR : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.KERN_SUB_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.LONGXMETRIC : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.LTSH : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.MAXP : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.MORTBINSRCHHEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.MORTLOOKUPSINGLE : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.NAME_HEADER : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.namerecord : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.namerecordstrings : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.NEWOS2 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.OFFSET_TABLE : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.OS2 : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.POST : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.SubTablePointers : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.TTFACC_FILEBUFFERINFO : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.VDMX : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.VDMXGroup : ValueType {
}
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.VDMXRatio : ValueType {
}
[NativeCppClassAttribute]
[UnsafeValueTypeAttribute]
internal class MS.Internal.TtfDelta.VHEA : ValueType {
}
[UnsafeValueTypeAttribute]
[NativeCppClassAttribute]
internal class MS.Internal.TtfDelta.XHEA : ValueType {
}
internal static class MS.Internal.UIElementHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool IsHitTestVisible(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static bool IsVisible(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static DependencyObject PredictFocus(DependencyObject o, FocusNavigationDirection direction);
    [FriendAccessAllowedAttribute]
internal static UIElement GetContainingUIElement2D(DependencyObject reference);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetUIParent(DependencyObject child);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetUIParent(DependencyObject child, bool continuePastVisualTree);
    [FriendAccessAllowedAttribute]
internal static bool IsUIElementOrUIElement3D(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static void InvalidateAutomationAncestors(DependencyObject o);
    internal static bool InvalidateAutomationPeer(DependencyObject o, UIElement& e, ContentElement& ce, UIElement3D& e3d);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.UnsafeStringCharacterBuffer : CharacterBuffer {
    public char Item { get; public set; }
    public int Count { get; }
    [SecurityCriticalAttribute]
public UnsafeStringCharacterBuffer(Char* characterString, int length);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual char get_Item(int characterOffset);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void set_Item(int characterOffset, char value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual int get_Count();
    [SecurityCriticalAttribute]
public virtual Char* GetCharacterPointer();
    [SecurityCriticalAttribute]
public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal enum MS.Internal.WICBitmapAlphaChannelOption : Enum {
    public int value__;
    public static WICBitmapAlphaChannelOption WICBitmapUseAlpha;
    public static WICBitmapAlphaChannelOption WICBitmapUsePremultipliedAlpha;
    public static WICBitmapAlphaChannelOption WICBitmapIgnoreAlpha;
}
internal enum MS.Internal.WICBitmapCreateCacheOptions : Enum {
    public int value__;
    public static WICBitmapCreateCacheOptions WICBitmapNoCache;
    public static WICBitmapCreateCacheOptions WICBitmapCacheOnDemand;
    public static WICBitmapCreateCacheOptions WICBitmapCacheOnLoad;
}
internal enum MS.Internal.WICBitmapEncodeCacheOption : Enum {
    public int value__;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeCacheInMemory;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeCacheTempFile;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeNoCache;
}
internal enum MS.Internal.WICBitmapTransformOptions : Enum {
    public int value__;
    public static WICBitmapTransformOptions WICBitmapTransformRotate0;
    public static WICBitmapTransformOptions WICBitmapTransformRotate90;
    public static WICBitmapTransformOptions WICBitmapTransformRotate180;
    public static WICBitmapTransformOptions WICBitmapTransformRotate270;
    public static WICBitmapTransformOptions WICBitmapTransformFlipHorizontal;
    public static WICBitmapTransformOptions WICBitmapTransformFlipVertical;
}
internal enum MS.Internal.WICInterpolationMode : Enum {
    public int value__;
    public static WICInterpolationMode NearestNeighbor;
    public static WICInterpolationMode Linear;
    public static WICInterpolationMode Cubic;
    public static WICInterpolationMode Fant;
}
internal enum MS.Internal.WICPaletteType : Enum {
    public int value__;
    public static WICPaletteType WICPaletteTypeCustom;
    public static WICPaletteType WICPaletteTypeOptimal;
    public static WICPaletteType WICPaletteTypeFixedBW;
    public static WICPaletteType WICPaletteTypeFixedHalftone8;
    public static WICPaletteType WICPaletteTypeFixedHalftone27;
    public static WICPaletteType WICPaletteTypeFixedHalftone64;
    public static WICPaletteType WICPaletteTypeFixedHalftone125;
    public static WICPaletteType WICPaletteTypeFixedHalftone216;
    public static WICPaletteType WICPaletteTypeFixedWebPalette;
    public static WICPaletteType WICPaletteTypeFixedHalftone252;
    public static WICPaletteType WICPaletteTypeFixedHalftone256;
    public static WICPaletteType WICPaletteTypeFixedGray4;
    public static WICPaletteType WICPaletteTypeFixedGray16;
    public static WICPaletteType WICPaletteTypeFixedGray256;
}
internal static class MS.Internal.WICPixelFormatGUIDs : object {
    internal static Guid WICPixelFormatDontCare;
    internal static Guid WICPixelFormat1bppIndexed;
    internal static Guid WICPixelFormat2bppIndexed;
    internal static Guid WICPixelFormat4bppIndexed;
    internal static Guid WICPixelFormat8bppIndexed;
    internal static Guid WICPixelFormatBlackWhite;
    internal static Guid WICPixelFormat2bppGray;
    internal static Guid WICPixelFormat4bppGray;
    internal static Guid WICPixelFormat8bppGray;
    internal static Guid WICPixelFormat16bppBGR555;
    internal static Guid WICPixelFormat16bppBGR565;
    internal static Guid WICPixelFormat16bppGray;
    internal static Guid WICPixelFormat24bppBGR;
    internal static Guid WICPixelFormat24bppRGB;
    internal static Guid WICPixelFormat32bppBGR;
    internal static Guid WICPixelFormat32bppBGRA;
    internal static Guid WICPixelFormat32bppPBGRA;
    internal static Guid WICPixelFormat32bppGrayFloat;
    internal static Guid WICPixelFormat32bppBGR101010;
    internal static Guid WICPixelFormat48bppRGB;
    internal static Guid WICPixelFormat64bppRGBA;
    internal static Guid WICPixelFormat64bppPRGBA;
    internal static Guid WICPixelFormat128bppRGBAFloat;
    internal static Guid WICPixelFormat128bppPRGBAFloat;
    internal static Guid WICPixelFormat128bppRGBFloat;
    internal static Guid WICPixelFormat32bppCMYK;
    private static WICPixelFormatGUIDs();
}
internal class MS.Internal.WindowsRuntime.Windows.UI.ViewManagement.InputPane : object {
    [SecuritySafeCriticalAttribute]
private static InputPane();
    [SecurityCriticalAttribute]
internal static InputPane GetForWindow(HwndSource source);
    [SecurityCriticalAttribute]
internal bool TryShow();
    [SecurityCriticalAttribute]
internal bool TryHide();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal static class MS.Internal.WindowsRuntime.Windows.UI.ViewManagement.InputPaneRcw : object {
}
internal static class MS.Internal.WpfWebRequestHelper : object {
    internal static string DefaultUserAgent { get; internal set; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static WebRequest CreateRequest(Uri uri);
    [FriendAccessAllowedAttribute]
internal static void ConfigCachePolicy(WebRequest request, bool isRefresh);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static string get_DefaultUserAgent();
    internal static void set_DefaultUserAgent(string value);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static void HandleWebResponse(WebResponse response);
    [FriendAccessAllowedAttribute]
internal static Stream CreateRequestAndGetResponseStream(Uri uri);
    [FriendAccessAllowedAttribute]
internal static Stream CreateRequestAndGetResponseStream(Uri uri, ContentType& contentType);
    [FriendAccessAllowedAttribute]
internal static WebResponse CreateRequestAndGetResponse(Uri uri);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static WebResponse GetResponse(WebRequest request);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static WebResponse EndGetResponse(WebRequest request, IAsyncResult ar);
    [FriendAccessAllowedAttribute]
internal static Stream GetResponseStream(WebRequest request);
    [FriendAccessAllowedAttribute]
internal static Stream GetResponseStream(WebRequest request, ContentType& contentType);
    [FriendAccessAllowedAttribute]
internal static ContentType GetContentType(WebResponse response);
}
[FriendAccessAllowedAttribute]
[DefaultMemberAttribute("Item")]
internal class MS.Utility.DTypeMap : object {
    public object Item { get; public set; }
    public ItemStructList`1<DependencyObjectType> ActiveDTypes { get; }
    public DTypeMap(int entryCount);
    public object get_Item(DependencyObjectType dType);
    public void set_Item(DependencyObjectType dType, object value);
    public ItemStructList`1<DependencyObjectType> get_ActiveDTypes();
    public void Clear();
}
[FriendAccessAllowedAttribute]
internal static class MS.Utility.PerfService : object {
    private static PerfService();
    internal static long GetPerfElementID2(object element, string extraData);
    internal static long GetPerfElementID(object element);
}
[FriendAccessAllowedAttribute]
internal static class MS.Win32.Compile.UnsafeNativeMethods : object {
    public static int SHGetFolderPath(IntPtr hwndOwner, int nFolder, IntPtr hToken, int dwFlags, StringBuilder lpszPath);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int FindMimeFromData(IBindCtx pBC, string wszUrl, IntPtr Buffer, int cbSize, string wzMimeProposed, int dwMimeFlags, String& wzMimeOut, int dwReserved);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("1868091E-AB5A-415F-A02F-5C4DD0CF901D")]
[InterfaceTypeAttribute("1")]
internal interface MS.Win32.Penimc.IPimcContext2 {
    public abstract virtual void ShutdownComm();
    public abstract virtual void GetPacketDescriptionInfo(Int32& cProps, Int32& cButtons);
    public abstract virtual void GetPacketPropertyInfo(int iProp, Guid& guid, Int32& iMin, Int32& iMax, Int32& iUnits, Single& flResolution);
    public abstract virtual void GetPacketButtonInfo(int iButton, Guid& guid);
    public abstract virtual void GetLastSystemEventData(Int32& evt, Int32& modifier, Int32& character, Int32& x, Int32& y, Int32& stylusMode, Int32& buttonState);
}
[SecurityCriticalAttribute("1")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("215B68E5-0E78-4505-BE40-962EE3A0C379")]
internal interface MS.Win32.Penimc.IPimcManager2 {
    public abstract virtual void GetTabletCount(UInt32& count);
    public abstract virtual void GetTablet(UInt32 tablet, IPimcTablet2& IPimcTablet);
}
[GuidAttribute("0EF507FF-0B48-40AD-84DB-E4C7AB81B74A")]
[InterfaceTypeAttribute("1")]
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface MS.Win32.Penimc.IPimcTablet2 {
    public abstract virtual void GetKey(Int32& key);
    public abstract virtual void GetName(String& name);
    public abstract virtual void GetPlugAndPlayId(String& plugAndPlayId);
    public abstract virtual void GetTabletAndDisplaySize(Int32& tabletWidth, Int32& tabletHeight, Int32& displayWidth, Int32& displayHeight);
    public abstract virtual void GetHardwareCaps(Int32& caps);
    public abstract virtual void GetDeviceType(Int32& devType);
    public abstract virtual void RefreshCursorInfo();
    public abstract virtual void GetCursorCount(Int32& cCursors);
    public abstract virtual void GetCursorInfo(int iCursor, String& sName, Int32& id, Boolean& fInverted);
    public abstract virtual void GetCursorButtonCount(int iCursor, Int32& cButtons);
    public abstract virtual void GetCursorButtonInfo(int iCursor, int iButton, String& sName, Guid& guid);
    public abstract virtual void IsPropertySupported(Guid guid, Boolean& fSupported);
    public abstract virtual void GetPropertyInfo(Guid guid, Int32& min, Int32& max, Int32& units, Single& resolution);
    public abstract virtual void CreateContext(IntPtr handle, bool fEnable, UInt32 timeout, IPimcContext2& IPimcContext, Int32& key, Int64& commHandle);
    public abstract virtual void GetPacketDescriptionInfo(Int32& cProps, Int32& cButtons);
    public abstract virtual void GetPacketPropertyInfo(int iProp, Guid& guid, Int32& iMin, Int32& iMax, Int32& iUnits, Single& flResolution);
    public abstract virtual void GetPacketButtonInfo(int iButton, Guid& guid);
}
internal static class MS.Win32.Penimc.UnsafeNativeMethods : object {
    internal static IPimcManager2 PimcManager { get; }
    [SecurityCriticalAttribute]
private static UnsafeNativeMethods();
    [SecurityCriticalAttribute]
internal static IPimcManager2 get_PimcManager();
    [SecurityCriticalAttribute]
internal static void CheckedLockWispObjectFromGit(UInt32 gitKey);
    [SecurityCriticalAttribute]
internal static void CheckedUnlockWispObjectFromGit(UInt32 gitKey);
    [SecurityCriticalAttribute]
internal static void ReleaseManagerExternalLock();
    [SecurityCriticalAttribute]
internal static void SetWispManagerKey(IPimcTablet2 tablet);
    [SecurityCriticalAttribute]
internal static void LockWispManager();
    [SecurityCriticalAttribute]
internal static void UnlockWispManager();
    [SecurityCriticalAttribute]
internal static void AcquireTabletExternalLock(IPimcTablet2 tablet);
    [SecurityCriticalAttribute]
internal static void ReleaseTabletExternalLock(IPimcTablet2 tablet);
    [SecurityCriticalAttribute]
internal static UInt32 QueryWispTabletKey(IPimcTablet2 tablet);
    [SecurityCriticalAttribute]
internal static UInt32 QueryWispContextKey(IPimcContext2 context);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetPenEvent(IntPtr commHandle, IntPtr handleReset, Int32& evt, Int32& stylusPointerId, Int32& cPackets, Int32& cbPacket, IntPtr& pPackets);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetPenEventMultiple(int cCommHandles, IntPtr[] commHandles, IntPtr handleReset, Int32& iHandle, Int32& evt, Int32& stylusPointerId, Int32& cPackets, Int32& cbPacket, IntPtr& pPackets);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetLastSystemEventData(IntPtr commHandle, Int32& evt, Int32& modifier, Int32& key, Int32& x, Int32& y, Int32& cursorMode, Int32& buttonState);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool CreateResetEvent(IntPtr& handle);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool DestroyResetEvent(IntPtr handle);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool RaiseResetEvent(IntPtr handle);
}
internal class MS.Win32.Pointer.UnsafeNativeMethods : object {
    internal static int POINTER_DEVICE_PRODUCT_STRING_MAX;
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerDevices(UInt32& deviceCount, POINTER_DEVICE_INFO[] devices);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerDeviceCursors(IntPtr device, UInt32& cursorCount, POINTER_DEVICE_CURSOR_INFO[] cursors);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetPointerInfo(UInt32 pointerId, POINTER_INFO& pointerInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerInfoHistory(UInt32 pointerId, UInt32& entriesCount, POINTER_INFO[] pointerInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerDeviceProperties(IntPtr device, UInt32& propertyCount, POINTER_DEVICE_PROPERTY[] pointerProperties);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetPointerDeviceRects(IntPtr device, RECT& pointerDeviceRect, RECT& displayRect);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerCursorId(UInt32 pointerId, UInt32& cursorId);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetPointerPenInfo(UInt32 pointerId, POINTER_PEN_INFO& penInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetPointerTouchInfo(UInt32 pointerId, POINTER_TOUCH_INFO& touchInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool GetRawPointerDeviceData(UInt32 pointerId, UInt32 historyCount, UInt32 propertiesCount, POINTER_DEVICE_PROPERTY[] pProperties, Int32[] pValues);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void CreateInteractionContext(IntPtr& interactionContext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void DestroyInteractionContext(IntPtr interactionContext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void SetInteractionConfigurationInteractionContext(IntPtr interactionContext, UInt32 configurationCount, INTERACTION_CONTEXT_CONFIGURATION[] configuration);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void RegisterOutputCallbackInteractionContext(IntPtr interactionContext, INTERACTION_CONTEXT_OUTPUT_CALLBACK outputCallback, IntPtr clientData);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void SetPropertyInteractionContext(IntPtr interactionContext, INTERACTION_CONTEXT_PROPERTY contextProperty, UInt32 value);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void BufferPointerPacketsInteractionContext(IntPtr interactionContext, UInt32 entriesCount, POINTER_INFO[] pointerInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void ProcessBufferedPacketsInteractionContext(IntPtr interactionContext);
}
internal static class MS.Win32.PresentationCore.SafeNativeMethods : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static int MilCompositionEngine_InitializePartitionManager(int nPriority);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int MilCompositionEngine_DeinitializePartitionManager();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static long GetNextPerfElementId();
}
internal static class MS.Win32.PresentationCore.UnsafeNativeMethods : object {
}
internal enum MS.Win32.Recognizer.ALT_BREAKS : Enum {
    public int value__;
    public static ALT_BREAKS ALT_BREAKS_SAME;
    public static ALT_BREAKS ALT_BREAKS_UNIQUE;
    public static ALT_BREAKS ALT_BREAKS_FULL;
}
internal class MS.Win32.Recognizer.CHARACTER_RANGE : ValueType {
    public ushort wcLow;
    public ushort cChars;
}
[SecurityCriticalAttribute]
internal class MS.Win32.Recognizer.ContextSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
internal void AddReferenceOnRecognizer(RecognizerSafeHandle handle);
}
internal class MS.Win32.Recognizer.PACKET_DESCRIPTION : ValueType {
    public UInt32 cbPacketSize;
    public UInt32 cPacketProperties;
    public IntPtr pPacketProperties;
    public UInt32 cButtons;
    public IntPtr pguidButtons;
}
internal class MS.Win32.Recognizer.PACKET_PROPERTY : ValueType {
    public Guid guid;
    public PROPERTY_METRICS PropertyMetrics;
}
internal class MS.Win32.Recognizer.PROPERTY_METRICS : ValueType {
    public int nLogicalMin;
    public int nLogicalMax;
    public int Units;
    public float fResolution;
}
internal class MS.Win32.Recognizer.RECO_LATTICE : ValueType {
    public UInt32 ulColumnCount;
    public IntPtr pLatticeColumns;
    public UInt32 ulPropertyCount;
    public IntPtr pGuidProperties;
    public UInt32 ulBestResultColumnCount;
    public IntPtr pulBestResultColumns;
    public IntPtr pulBestResultIndexes;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_COLUMN : ValueType {
    public UInt32 key;
    public RECO_LATTICE_PROPERTIES cpProp;
    public UInt32 cStrokes;
    public IntPtr pStrokes;
    public UInt32 cLatticeElements;
    public IntPtr pLatticeElements;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_ELEMENT : ValueType {
    public int score;
    public ushort type;
    public IntPtr pData;
    public UInt32 ulNextColumn;
    public UInt32 ulStrokeNumber;
    public RECO_LATTICE_PROPERTIES epProp;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_PROPERTIES : ValueType {
    public UInt32 cProperties;
    public IntPtr apProps;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_PROPERTY : ValueType {
    public Guid guidProperty;
    public ushort cbPropertyValue;
    public IntPtr pPropertyValue;
}
internal class MS.Win32.Recognizer.RECO_RANGE : ValueType {
    public UInt32 iwcBegin;
    public UInt32 cCount;
}
[SecurityCriticalAttribute]
internal class MS.Win32.Recognizer.RecognizerSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
internal static class MS.Win32.Recognizer.UnsafeNativeMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int CreateRecognizer(Guid& clsid, RecognizerSafeHandle& hRec);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DestroyRecognizer(IntPtr hRec);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int CreateContext(RecognizerSafeHandle hRec, ContextSafeHandle& hRecContext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DestroyContext(IntPtr hRecContext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int AddStroke(ContextSafeHandle hRecContext, PACKET_DESCRIPTION& packetDesc, UInt32 cbPackets, IntPtr pByte, XFORM xForm);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int SetEnabledUnicodeRanges(ContextSafeHandle hRecContext, UInt32 cRangs, CHARACTER_RANGE[] charRanges);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int EndInkInput(ContextSafeHandle hRecContext);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int Process(ContextSafeHandle hRecContext, Boolean& partialProcessing);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int GetAlternateList(ContextSafeHandle hRecContext, RECO_RANGE& recoRange, UInt32& cAlts, IntPtr[] recAtls, ALT_BREAKS breaks);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int DestroyAlternate(IntPtr hRecAtls);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetString(IntPtr hRecAtls, RECO_RANGE& recoRange, UInt32& size, StringBuilder recoString);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetConfidenceLevel(IntPtr hRecAtls, RECO_RANGE& recoRange, RecognitionConfidence& confidenceLevel);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int ResetContext(ContextSafeHandle hRecContext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetLatticePtr(ContextSafeHandle hRecContext, IntPtr& pRecoLattice);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.SafeSystemMetrics : object {
    internal static int DoubleClickDeltaX { get; }
    internal static int DoubleClickDeltaY { get; }
    internal static int DragDeltaX { get; }
    internal static int DragDeltaY { get; }
    internal static bool IsImmEnabled { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int get_DoubleClickDeltaX();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static int get_DoubleClickDeltaY();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int get_DragDeltaX();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static int get_DragDeltaY();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool get_IsImmEnabled();
}
internal static class MS.Win32.WinInet : object {
    internal static Uri InternetCacheFolder { get; }
    [SecurityCriticalAttribute]
internal static Uri get_InternetCacheFolder();
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
}
[SecurityCriticalAttribute("1")]
public static class System.IO.Packaging.PackageStore : object {
    private static PackageStore();
    public static Package GetPackage(Uri uri);
    public static void AddPackage(Uri uri, Package package);
    public static void RemovePackage(Uri uri);
}
public class System.IO.Packaging.PackWebRequest : WebRequest {
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    internal PackWebRequest(Uri uri, Uri packageUri, Uri partUri);
    internal PackWebRequest(Uri uri, Uri packageUri, Uri partUri, Package cacheEntry, bool respectCachePolicy, bool cachedPackageIsThreadSafe);
    private static PackWebRequest();
    public virtual Stream GetRequestStream();
    [SecurityCriticalAttribute]
public virtual WebResponse GetResponse();
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    [SecurityCriticalAttribute]
public virtual IWebProxy get_Proxy();
    [SecurityCriticalAttribute]
public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public WebRequest GetInnerRequest();
}
public class System.IO.Packaging.PackWebRequestFactory : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static PackWebRequestFactory();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override WebRequest System.Net.IWebRequestCreate.Create(Uri uri);
    [FriendAccessAllowedAttribute]
internal static WebRequest CreateWebRequest(Uri uri);
}
public class System.IO.Packaging.PackWebResponse : WebResponse {
    public WebResponse InnerResponse { get; }
    public WebHeaderCollection Headers { get; }
    public Uri ResponseUri { get; }
    public bool IsFromCache { get; }
    public string ContentType { get; }
    public long ContentLength { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static PackWebResponse();
    [SecurityCriticalAttribute]
internal PackWebResponse(Uri uri, Uri innerUri, Uri partName, WebRequest innerRequest);
    internal PackWebResponse(Uri uri, Uri innerUri, Uri partName, Package cacheEntry, bool cachedPackageIsThreadSafe);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual Stream GetResponseStream();
    public virtual void Close();
    public WebResponse get_InnerResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual Uri get_ResponseUri();
    public virtual bool get_IsFromCache();
    public virtual string get_ContentType();
    public virtual long get_ContentLength();
    protected virtual void Dispose(bool disposing);
}
internal static class System.LocalAppContext : object {
    private static LocalAppContext();
    public static bool IsSwitchEnabled(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
public enum System.Windows.Automation.AutomationLiveSetting : Enum {
    public int value__;
    public static AutomationLiveSetting Off;
    public static AutomationLiveSetting Polite;
    public static AutomationLiveSetting Assertive;
}
public static class System.Windows.Automation.AutomationProperties : object {
    public static DependencyProperty AutomationIdProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty HelpTextProperty;
    public static DependencyProperty AcceleratorKeyProperty;
    public static DependencyProperty AccessKeyProperty;
    public static DependencyProperty ItemStatusProperty;
    public static DependencyProperty ItemTypeProperty;
    public static DependencyProperty IsColumnHeaderProperty;
    public static DependencyProperty IsRowHeaderProperty;
    public static DependencyProperty IsRequiredForFormProperty;
    public static DependencyProperty LabeledByProperty;
    public static DependencyProperty IsOffscreenBehaviorProperty;
    public static DependencyProperty LiveSettingProperty;
    private static AutomationProperties();
    public static void SetAutomationId(DependencyObject element, string value);
    public static string GetAutomationId(DependencyObject element);
    public static void SetName(DependencyObject element, string value);
    public static string GetName(DependencyObject element);
    public static void SetHelpText(DependencyObject element, string value);
    public static string GetHelpText(DependencyObject element);
    public static void SetAcceleratorKey(DependencyObject element, string value);
    public static string GetAcceleratorKey(DependencyObject element);
    public static void SetAccessKey(DependencyObject element, string value);
    public static string GetAccessKey(DependencyObject element);
    public static void SetItemStatus(DependencyObject element, string value);
    public static string GetItemStatus(DependencyObject element);
    public static void SetItemType(DependencyObject element, string value);
    public static string GetItemType(DependencyObject element);
    public static void SetIsColumnHeader(DependencyObject element, bool value);
    public static bool GetIsColumnHeader(DependencyObject element);
    public static void SetIsRowHeader(DependencyObject element, bool value);
    public static bool GetIsRowHeader(DependencyObject element);
    public static void SetIsRequiredForForm(DependencyObject element, bool value);
    public static bool GetIsRequiredForForm(DependencyObject element);
    public static void SetLabeledBy(DependencyObject element, UIElement value);
    public static UIElement GetLabeledBy(DependencyObject element);
    public static void SetIsOffscreenBehavior(DependencyObject element, IsOffscreenBehavior value);
    public static IsOffscreenBehavior GetIsOffscreenBehavior(DependencyObject element);
    public static void SetLiveSetting(DependencyObject element, AutomationLiveSetting value);
    public static AutomationLiveSetting GetLiveSetting(DependencyObject element);
}
public enum System.Windows.Automation.IsOffscreenBehavior : Enum {
    public int value__;
    public static IsOffscreenBehavior Default;
    public static IsOffscreenBehavior Onscreen;
    public static IsOffscreenBehavior Offscreen;
    public static IsOffscreenBehavior FromClip;
}
public enum System.Windows.Automation.Peers.AutomationControlType : Enum {
    public int value__;
    public static AutomationControlType Button;
    public static AutomationControlType Calendar;
    public static AutomationControlType CheckBox;
    public static AutomationControlType ComboBox;
    public static AutomationControlType Edit;
    public static AutomationControlType Hyperlink;
    public static AutomationControlType Image;
    public static AutomationControlType ListItem;
    public static AutomationControlType List;
    public static AutomationControlType Menu;
    public static AutomationControlType MenuBar;
    public static AutomationControlType MenuItem;
    public static AutomationControlType ProgressBar;
    public static AutomationControlType RadioButton;
    public static AutomationControlType ScrollBar;
    public static AutomationControlType Slider;
    public static AutomationControlType Spinner;
    public static AutomationControlType StatusBar;
    public static AutomationControlType Tab;
    public static AutomationControlType TabItem;
    public static AutomationControlType Text;
    public static AutomationControlType ToolBar;
    public static AutomationControlType ToolTip;
    public static AutomationControlType Tree;
    public static AutomationControlType TreeItem;
    public static AutomationControlType Custom;
    public static AutomationControlType Group;
    public static AutomationControlType Thumb;
    public static AutomationControlType DataGrid;
    public static AutomationControlType DataItem;
    public static AutomationControlType Document;
    public static AutomationControlType SplitButton;
    public static AutomationControlType Window;
    public static AutomationControlType Pane;
    public static AutomationControlType Header;
    public static AutomationControlType HeaderItem;
    public static AutomationControlType Table;
    public static AutomationControlType TitleBar;
    public static AutomationControlType Separator;
}
public enum System.Windows.Automation.Peers.AutomationEvents : Enum {
    public int value__;
    public static AutomationEvents ToolTipOpened;
    public static AutomationEvents ToolTipClosed;
    public static AutomationEvents MenuOpened;
    public static AutomationEvents MenuClosed;
    public static AutomationEvents AutomationFocusChanged;
    public static AutomationEvents InvokePatternOnInvoked;
    public static AutomationEvents SelectionItemPatternOnElementAddedToSelection;
    public static AutomationEvents SelectionItemPatternOnElementRemovedFromSelection;
    public static AutomationEvents SelectionItemPatternOnElementSelected;
    public static AutomationEvents SelectionPatternOnInvalidated;
    public static AutomationEvents TextPatternOnTextSelectionChanged;
    public static AutomationEvents TextPatternOnTextChanged;
    public static AutomationEvents AsyncContentLoaded;
    public static AutomationEvents PropertyChanged;
    public static AutomationEvents StructureChanged;
    public static AutomationEvents InputReachedTarget;
    public static AutomationEvents InputReachedOtherElement;
    public static AutomationEvents InputDiscarded;
    public static AutomationEvents LiveRegionChanged;
}
public enum System.Windows.Automation.Peers.AutomationOrientation : Enum {
    public int value__;
    public static AutomationOrientation None;
    public static AutomationOrientation Horizontal;
    public static AutomationOrientation Vertical;
}
public abstract class System.Windows.Automation.Peers.AutomationPeer : DispatcherObject {
    protected internal bool IsHwndHost { get; }
    public AutomationPeer EventsSource { get; public set; }
    internal IntPtr Hwnd { get; internal set; }
    internal bool AncestorsInvalid { get; internal set; }
    internal bool ChildrenValid { get; internal set; }
    internal bool IsInteropPeer { get; internal set; }
    internal int Index { get; }
    internal List`1<AutomationPeer> Children { get; }
    internal WeakReference ElementProxyWeakReference { get; internal set; }
    private static AutomationPeer();
    protected abstract virtual List`1<AutomationPeer> GetChildrenCore();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public void InvalidatePeer();
    public static bool ListenerExists(AutomationEvents eventId);
    public void RaiseAutomationEvent(AutomationEvents eventId);
    public void RaisePropertyChangedEvent(AutomationProperty property, object oldValue, object newValue);
    public void RaiseAsyncContentLoadedEvent(AsyncContentLoadedEventArgs args);
    internal static void RaiseFocusChangedEventHelper(IInputElement newFocus);
    internal static AutomationPeer AutomationPeerFromInputElement(IInputElement focusedElement);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal AutomationPeer ValidateConnected(AutomationPeer connectedPeer);
    [SecurityCriticalAttribute]
internal bool TrySetParentInfo(AutomationPeer peer);
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual bool IgnoreUpdatePeer();
    internal virtual void AddToParentProxyWeakRefCache();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual HostedWindowWrapper GetHostRawElementProviderCore();
    internal HostedWindowWrapper GetHostRawElementProvider();
    protected internal virtual bool get_IsHwndHost();
    protected abstract virtual Rect GetBoundingRectangleCore();
    protected abstract virtual bool IsOffscreenCore();
    protected abstract virtual AutomationOrientation GetOrientationCore();
    protected abstract virtual string GetItemTypeCore();
    protected abstract virtual string GetClassNameCore();
    protected abstract virtual string GetItemStatusCore();
    protected abstract virtual bool IsRequiredForFormCore();
    protected abstract virtual bool IsKeyboardFocusableCore();
    protected abstract virtual bool HasKeyboardFocusCore();
    protected abstract virtual bool IsEnabledCore();
    protected abstract virtual bool IsPasswordCore();
    protected abstract virtual string GetAutomationIdCore();
    protected abstract virtual string GetNameCore();
    protected abstract virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected abstract virtual bool IsContentElementCore();
    protected abstract virtual bool IsControlElementCore();
    protected abstract virtual AutomationPeer GetLabeledByCore();
    protected abstract virtual string GetHelpTextCore();
    protected abstract virtual string GetAcceleratorKeyCore();
    protected abstract virtual string GetAccessKeyCore();
    protected abstract virtual Point GetClickablePointCore();
    protected abstract virtual void SetFocusCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    internal virtual Rect GetVisibleBoundingRectCore();
    public Rect GetBoundingRectangle();
    public bool IsOffscreen();
    public AutomationOrientation GetOrientation();
    public string GetItemType();
    public string GetClassName();
    public string GetItemStatus();
    public bool IsRequiredForForm();
    public bool IsKeyboardFocusable();
    public bool HasKeyboardFocus();
    public bool IsEnabled();
    public bool IsPassword();
    public string GetAutomationId();
    public string GetName();
    public AutomationControlType GetAutomationControlType();
    public string GetLocalizedControlType();
    public bool IsContentElement();
    public bool IsControlElement();
    public AutomationPeer GetLabeledBy();
    public string GetHelpText();
    public string GetAcceleratorKey();
    public string GetAccessKey();
    public Point GetClickablePoint();
    public void SetFocus();
    public AutomationLiveSetting GetLiveSetting();
    public AutomationPeer GetParent();
    public List`1<AutomationPeer> GetChildren();
    public void ResetChildrenCache();
    internal Int32[] GetRuntimeId();
    internal string GetFrameworkId();
    internal AutomationPeer GetFirstChild();
    internal void ForceEnsureChildren();
    internal AutomationPeer GetLastChild();
    [FriendAccessAllowedAttribute]
internal virtual InteropAutomationProvider GetInteropChild();
    internal AutomationPeer GetNextSibling();
    internal AutomationPeer GetPreviousSibling();
    internal ControlType GetControlType();
    public AutomationPeer GetPeerFromPoint(Point point);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    internal Rect GetVisibleBoundingRect();
    protected internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    public AutomationPeer get_EventsSource();
    public void set_EventsSource(AutomationPeer value);
    protected AutomationPeer PeerFromProvider(IRawElementProviderSimple provider);
    internal void FireAutomationEvents();
    internal void UpdateChildrenInternal(int invalidateLimit);
    internal virtual void UpdateChildren();
    [FriendAccessAllowedAttribute]
internal void UpdateSubtree();
    internal void InvalidateAncestorsRecursive();
    internal void AddToAutomationEventList();
    [SecurityCriticalAttribute]
internal IntPtr get_Hwnd();
    [SecurityCriticalAttribute]
internal void set_Hwnd(IntPtr value);
    internal object GetWrappedPattern(int patternId);
    internal object GetPropertyValue(int propertyId);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    internal bool get_ChildrenValid();
    internal void set_ChildrenValid(bool value);
    internal bool get_IsInteropPeer();
    internal void set_IsInteropPeer(bool value);
    internal int get_Index();
    internal List`1<AutomationPeer> get_Children();
    internal WeakReference get_ElementProxyWeakReference();
    internal void set_ElementProxyWeakReference(WeakReference value);
}
public class System.Windows.Automation.Peers.ContentElementAutomationPeer : AutomationPeer {
    public ContentElement Owner { get; }
    public ContentElementAutomationPeer(ContentElement owner);
    public ContentElement get_Owner();
    public static AutomationPeer CreatePeerForElement(ContentElement element);
    public static AutomationPeer FromElement(ContentElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual Rect GetVisibleBoundingRectCore();
}
public class System.Windows.Automation.Peers.GenericRootAutomationPeer : UIElementAutomationPeer {
    public GenericRootAutomationPeer(UIElement owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual string GetNameCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
}
public class System.Windows.Automation.Peers.HostedWindowWrapper : object {
    internal IntPtr Handle { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public HostedWindowWrapper(IntPtr hwnd);
    [SecurityCriticalAttribute]
internal static HostedWindowWrapper CreateInternal(IntPtr hwnd);
    [SecurityCriticalAttribute]
internal IntPtr get_Handle();
}
public enum System.Windows.Automation.Peers.PatternInterface : Enum {
    public int value__;
    public static PatternInterface Invoke;
    public static PatternInterface Selection;
    public static PatternInterface Value;
    public static PatternInterface RangeValue;
    public static PatternInterface Scroll;
    public static PatternInterface ScrollItem;
    public static PatternInterface ExpandCollapse;
    public static PatternInterface Grid;
    public static PatternInterface GridItem;
    public static PatternInterface MultipleView;
    public static PatternInterface Window;
    public static PatternInterface SelectionItem;
    public static PatternInterface Dock;
    public static PatternInterface Table;
    public static PatternInterface TableItem;
    public static PatternInterface Toggle;
    public static PatternInterface Transform;
    public static PatternInterface Text;
    public static PatternInterface ItemContainer;
    public static PatternInterface VirtualizedItem;
    public static PatternInterface SynchronizedInput;
}
public class System.Windows.Automation.Peers.UIElement3DAutomationPeer : AutomationPeer {
    public UIElement3D Owner { get; }
    public UIElement3DAutomationPeer(UIElement3D owner);
    public UIElement3D get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement3D element);
    public static AutomationPeer FromElement(UIElement3D element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual Rect GetVisibleBoundingRectCore();
}
public class System.Windows.Automation.Peers.UIElementAutomationPeer : AutomationPeer {
    public UIElement Owner { get; }
    public UIElementAutomationPeer(UIElement owner);
    public UIElement get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement element);
    public static AutomationPeer FromElement(UIElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    [SecurityCriticalAttribute]
internal static AutomationPeer GetRootAutomationPeer(Visual rootVisual, IntPtr hwnd);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool IsOffscreenCore();
    internal static Rect CalculateVisibleBoundingRect(UIElement owner);
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.AutoResizedEventArgs : EventArgs {
    public Size Size { get; }
    public AutoResizedEventArgs(Size size);
    public Size get_Size();
}
public class System.Windows.AutoResizedEventHandler : MulticastDelegate {
    public AutoResizedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AutoResizedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AutoResizedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.BaselineAlignment : Enum {
    public int value__;
    public static BaselineAlignment Top;
    public static BaselineAlignment Center;
    public static BaselineAlignment Bottom;
    public static BaselineAlignment Baseline;
    public static BaselineAlignment TextTop;
    public static BaselineAlignment TextBottom;
    public static BaselineAlignment Subscript;
    public static BaselineAlignment Superscript;
}
internal class System.Windows.ClassHandlers : ValueType {
    internal RoutedEvent RoutedEvent;
    internal RoutedEventHandlerInfoList Handlers;
    internal bool HasSelfHandlers;
    public virtual bool Equals(object o);
    public bool Equals(ClassHandlers classHandlers);
    public virtual int GetHashCode();
    public static bool op_Equality(ClassHandlers classHandlers1, ClassHandlers classHandlers2);
    public static bool op_Inequality(ClassHandlers classHandlers1, ClassHandlers classHandlers2);
}
internal class System.Windows.ClassHandlersStore : object {
    internal ClassHandlersStore(int size);
    internal RoutedEventHandlerInfoList AddToExistingHandlers(int index, Delegate handler, bool handledEventsToo);
    internal RoutedEventHandlerInfoList GetExistingHandlers(int index);
    internal int CreateHandlersLink(RoutedEvent routedEvent, RoutedEventHandlerInfoList handlers);
    internal void UpdateSubClassHandlers(RoutedEvent routedEvent, RoutedEventHandlerInfoList baseClassListeners);
    internal int GetHandlersIndex(RoutedEvent routedEvent);
}
public static class System.Windows.Clipboard : object {
    [SecurityCriticalAttribute]
public static void Clear();
    public static bool ContainsAudio();
    public static bool ContainsData(string format);
    public static bool ContainsFileDropList();
    public static bool ContainsImage();
    public static bool ContainsText();
    public static bool ContainsText(TextDataFormat format);
    public static void Flush();
    public static Stream GetAudioStream();
    public static object GetData(string format);
    public static StringCollection GetFileDropList();
    public static BitmapSource GetImage();
    public static string GetText();
    public static string GetText(TextDataFormat format);
    public static void SetAudio(Byte[] audioBytes);
    public static void SetAudio(Stream audioStream);
    public static void SetData(string format, object data);
    public static void SetFileDropList(StringCollection fileDropList);
    public static void SetImage(BitmapSource image);
    public static void SetText(string text);
    public static void SetText(string text, TextDataFormat format);
    [SecurityCriticalAttribute]
public static IDataObject GetDataObject();
    public static bool IsCurrent(IDataObject data);
    [SecurityCriticalAttribute]
public static void SetDataObject(object data);
    [SecurityCriticalAttribute]
public static void SetDataObject(object data, bool copy);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static void CriticalSetDataObject(object data, bool copy);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsClipboardPopulated();
}
public class System.Windows.ContentElement : DependencyObject {
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsEnabledProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    public static DependencyProperty AllowDropProperty;
    internal DependencyObject _parent;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    internal DependencyObject Parent { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool Focusable { get; public set; }
    public bool IsInputMethodEnabled { get; }
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal bool HasAutomationPeer { get; internal set; }
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static ContentElement();
    internal DependencyObject GetUIParent();
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    protected internal virtual DependencyObject GetUIParentCore();
    internal DependencyObject get_Parent();
    [FriendAccessAllowedAttribute]
internal virtual void OnContentParentChanged(DependencyObject oldParent);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    public sealed virtual bool get_IsMouseDirectlyOver();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public bool get_IsInputMethodEnabled();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    [SecurityCriticalAttribute]
internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    [SecurityCriticalAttribute]
internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected internal virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected internal virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
}
public static class System.Windows.ContentOperations : object {
    public static DependencyObject GetParent(ContentElement reference);
    public static void SetParent(ContentElement reference, DependencyObject parent);
}
internal class System.Windows.ContextLayoutManager : DispatcherObject {
    internal static int s_LayoutRecursionLimit;
    internal LayoutQueue MeasureQueue { get; }
    internal LayoutQueue ArrangeQueue { get; }
    internal LayoutEventList LayoutEvents { get; }
    internal LayoutEventList AutomationEvents { get; }
    internal int AutomationSyncUpdateCounter { get; internal set; }
    private static ContextLayoutManager();
    internal static ContextLayoutManager From(Dispatcher dispatcher);
    internal void EnterMeasure();
    internal void ExitMeasure();
    internal void EnterArrange();
    internal void ExitArrange();
    internal void UpdateLayout();
    internal LayoutQueue get_MeasureQueue();
    internal LayoutQueue get_ArrangeQueue();
    internal LayoutEventList get_LayoutEvents();
    internal void AddToSizeChangedChain(SizeChangedInfo info);
    internal LayoutEventList get_AutomationEvents();
    internal AutomationPeer[] GetAutomationRoots();
    internal int get_AutomationSyncUpdateCounter();
    internal void set_AutomationSyncUpdateCounter(int value);
    internal UIElement GetLastExceptionElement();
    internal void SetLastExceptionElement(UIElement e);
}
public static class System.Windows.CoreCompatibilityPreferences : object {
    internal static bool TargetsAtLeast_Desktop_V4_5 { get; }
    public static bool IsAltKeyRequiredInAccessKeyDefaultScope { get; public set; }
    internal static bool IncludeAllInkInBoundingBox { get; internal set; }
    public static Nullable`1<bool> EnableMultiMonitorDisplayClipping { get; public set; }
    private static CoreCompatibilityPreferences();
    internal static bool get_TargetsAtLeast_Desktop_V4_5();
    public static bool get_IsAltKeyRequiredInAccessKeyDefaultScope();
    public static void set_IsAltKeyRequiredInAccessKeyDefaultScope(bool value);
    internal static bool GetIsAltKeyRequiredInAccessKeyDefaultScope();
    internal static bool get_IncludeAllInkInBoundingBox();
    internal static void set_IncludeAllInkInBoundingBox(bool value);
    internal static bool GetIncludeAllInkInBoundingBox();
    public static Nullable`1<bool> get_EnableMultiMonitorDisplayClipping();
    public static void set_EnableMultiMonitorDisplayClipping(Nullable`1<bool> value);
    internal static Nullable`1<bool> GetEnableMultiMonitorDisplayClipping();
}
[FlagsAttribute]
internal enum System.Windows.CoreFlags : Enum {
    public UInt32 value__;
    public static CoreFlags None;
    public static CoreFlags SnapsToDevicePixelsCache;
    public static CoreFlags ClipToBoundsCache;
    public static CoreFlags MeasureDirty;
    public static CoreFlags ArrangeDirty;
    public static CoreFlags MeasureInProgress;
    public static CoreFlags ArrangeInProgress;
    public static CoreFlags NeverMeasured;
    public static CoreFlags NeverArranged;
    public static CoreFlags MeasureDuringArrange;
    public static CoreFlags IsCollapsed;
    public static CoreFlags IsKeyboardFocusWithinCache;
    public static CoreFlags IsKeyboardFocusWithinChanged;
    public static CoreFlags IsMouseOverCache;
    public static CoreFlags IsMouseOverChanged;
    public static CoreFlags IsMouseCaptureWithinCache;
    public static CoreFlags IsMouseCaptureWithinChanged;
    public static CoreFlags IsStylusOverCache;
    public static CoreFlags IsStylusOverChanged;
    public static CoreFlags IsStylusCaptureWithinCache;
    public static CoreFlags IsStylusCaptureWithinChanged;
    public static CoreFlags HasAutomationPeer;
    public static CoreFlags RenderingInvalidated;
    public static CoreFlags IsVisibleCache;
    public static CoreFlags AreTransformsClean;
    public static CoreFlags IsOpacitySuppressed;
    public static CoreFlags ExistsEventHandlersStore;
    public static CoreFlags TouchesOverCache;
    public static CoreFlags TouchesOverChanged;
    public static CoreFlags TouchesCapturedWithinCache;
    public static CoreFlags TouchesCapturedWithinChanged;
    public static CoreFlags TouchLeaveCache;
    public static CoreFlags TouchEnterCache;
}
public class System.Windows.CultureInfoIetfLanguageTagConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.DataFormat : object {
    public string Name { get; }
    public int Id { get; }
    public DataFormat(string name, int id);
    public string get_Name();
    public int get_Id();
}
public static class System.Windows.DataFormats : object {
    public static string Text;
    public static string UnicodeText;
    public static string Dib;
    public static string Bitmap;
    public static string EnhancedMetafile;
    public static string MetafilePicture;
    public static string SymbolicLink;
    public static string Dif;
    public static string Tiff;
    public static string OemText;
    public static string Palette;
    public static string PenData;
    public static string Riff;
    public static string WaveAudio;
    public static string FileDrop;
    public static string Locale;
    public static string Html;
    public static string Rtf;
    public static string CommaSeparatedValue;
    public static string StringFormat;
    public static string Serializable;
    public static string Xaml;
    public static string XamlPackage;
    internal static string ApplicationTrust;
    internal static string FileName;
    internal static string FileNameW;
    private static DataFormats();
    public static DataFormat GetDataFormat(int id);
    [SecurityCriticalAttribute]
public static DataFormat GetDataFormat(string format);
    internal static string ConvertToDataFormats(TextDataFormat textDataformat);
    internal static bool IsValidTextDataFormat(TextDataFormat textDataFormat);
}
public class System.Windows.DataObject : object {
    public static RoutedEvent CopyingEvent;
    public static RoutedEvent PastingEvent;
    public static RoutedEvent SettingDataEvent;
    [SecurityCriticalAttribute]
public DataObject(object data);
    [SecurityCriticalAttribute]
public DataObject(string format, object data);
    [SecurityCriticalAttribute]
public DataObject(Type format, object data);
    [SecurityCriticalAttribute]
public DataObject(string format, object data, bool autoConvert);
    internal DataObject(IDataObject data);
    internal DataObject(IDataObject data);
    private static DataObject();
    public sealed virtual object GetData(string format, bool autoConvert);
    public sealed virtual object GetData(string format);
    public sealed virtual object GetData(Type format);
    public sealed virtual bool GetDataPresent(Type format);
    public sealed virtual bool GetDataPresent(string format, bool autoConvert);
    public sealed virtual bool GetDataPresent(string format);
    public sealed virtual String[] GetFormats(bool autoConvert);
    public sealed virtual String[] GetFormats();
    [SecurityCriticalAttribute]
public sealed virtual void SetData(object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string format, object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(Type format, object data);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string format, object data, bool autoConvert);
    public bool ContainsAudio();
    public bool ContainsFileDropList();
    public bool ContainsImage();
    public bool ContainsText();
    public bool ContainsText(TextDataFormat format);
    public Stream GetAudioStream();
    public StringCollection GetFileDropList();
    public BitmapSource GetImage();
    public string GetText();
    public string GetText(TextDataFormat format);
    public void SetAudio(Byte[] audioBytes);
    public void SetAudio(Stream audioStream);
    public void SetFileDropList(StringCollection fileDropList);
    public void SetImage(BitmapSource image);
    public void SetText(string textData);
    public void SetText(string textData, TextDataFormat format);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink pAdvSink, Int32& pdwConnection);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.DUnadvise(int dwConnection);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.EnumDAdvise(IEnumSTATDATA& enumAdvise);
    [SecurityCriticalAttribute]
private sealed virtual override IEnumFORMATETC System.Runtime.InteropServices.ComTypes.IDataObject.EnumFormatEtc(DATADIR dwDirection);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.GetCanonicalFormatEtc(FORMATETC& pformatetcIn, FORMATETC& pformatetcOut);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetData(FORMATETC& formatetc, STGMEDIUM& medium);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetDataHere(FORMATETC& formatetc, STGMEDIUM& medium);
    [SecurityCriticalAttribute]
private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.QueryGetData(FORMATETC& formatetc);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.SetData(FORMATETC& pFormatetcIn, STGMEDIUM& pmedium, bool fRelease);
    public static void AddCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void RemoveCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void AddPastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void RemovePastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void AddSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    public static void RemoveSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    [SecurityCriticalAttribute]
internal static IntPtr Win32GlobalAlloc(int flags, IntPtr bytes);
    [SecurityCriticalAttribute]
internal static void Win32GlobalFree(HandleRef handle);
    [SecurityCriticalAttribute]
internal static IntPtr Win32GlobalReAlloc(HandleRef handle, IntPtr bytes, int flags);
    [SecurityCriticalAttribute]
internal static IntPtr Win32GlobalLock(HandleRef handle);
    [SecurityCriticalAttribute]
internal static void Win32GlobalUnlock(HandleRef handle);
    [SecurityCriticalAttribute]
internal static IntPtr Win32GlobalSize(HandleRef handle);
    [SecurityCriticalAttribute]
internal static IntPtr Win32SelectObject(HandleRef handleDC, IntPtr handleObject);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void Win32DeleteObject(HandleRef handleDC);
    [SecurityCriticalAttribute]
internal static IntPtr Win32GetDC(HandleRef handleDC);
    internal static IntPtr Win32CreateCompatibleDC(HandleRef handleDC);
    [SecurityCriticalAttribute]
internal static IntPtr Win32CreateCompatibleBitmap(HandleRef handleDC, int width, int height);
    internal static void Win32DeleteDC(HandleRef handleDC);
    [SecurityCriticalAttribute]
internal static void Win32BitBlt(HandleRef handledestination, int width, int height, HandleRef handleSource, int operationCode);
    [SecurityCriticalAttribute]
internal static int Win32WideCharToMultiByte(string wideString, int wideChars, Byte[] bytes, int byteCount);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static String[] GetMappedFormats(string format);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal void CriticalSetData(string format, object data, bool autoConvert);
}
public class System.Windows.DataObjectCopyingEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public DataObjectCopyingEventArgs(IDataObject dataObject, bool isDragDrop);
    public IDataObject get_DataObject();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectCopyingEventHandler : MulticastDelegate {
    public DataObjectCopyingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectCopyingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectCopyingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.DataObjectEventArgs : RoutedEventArgs {
    public bool IsDragDrop { get; }
    public bool CommandCancelled { get; }
    internal DataObjectEventArgs(RoutedEvent routedEvent, bool isDragDrop);
    public bool get_IsDragDrop();
    public bool get_CommandCancelled();
    public void CancelCommand();
}
public class System.Windows.DataObjectPastingEventArgs : DataObjectEventArgs {
    public IDataObject SourceDataObject { get; }
    public IDataObject DataObject { get; public set; }
    public string FormatToApply { get; public set; }
    public DataObjectPastingEventArgs(IDataObject dataObject, bool isDragDrop, string formatToApply);
    public IDataObject get_SourceDataObject();
    public IDataObject get_DataObject();
    public void set_DataObject(IDataObject value);
    public string get_FormatToApply();
    public void set_FormatToApply(string value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectPastingEventHandler : MulticastDelegate {
    public DataObjectPastingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectPastingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectPastingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DataObjectSettingDataEventArgs : DataObjectEventArgs {
    public IDataObject DataObject { get; }
    public string Format { get; }
    public DataObjectSettingDataEventArgs(IDataObject dataObject, string format);
    public IDataObject get_DataObject();
    public string get_Format();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectSettingDataEventHandler : MulticastDelegate {
    public DataObjectSettingDataEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectSettingDataEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectSettingDataEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Diagnostics.VisualDiagnostics : object {
    internal static bool IsEnabled { get; }
    private static VisualDiagnostics();
    public static void add_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void remove_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void EnableVisualTreeChanged();
    public static void DisableVisualTreeChanged();
    public static XamlSourceInfo GetXamlSourceInfo(object obj);
    internal static void OnVisualChildChanged(DependencyObject parent, DependencyObject child, bool isAdded);
    internal static bool get_IsEnabled();
    internal static void VerifyVisualTreeChange(DependencyObject d);
    [SecurityCriticalAttribute]
internal static bool IsEnvironmentVariableSet(string value, string environmentVariable);
    internal static bool IsEnvironmentValueSet(string value);
}
public class System.Windows.Diagnostics.VisualTreeChangeEventArgs : EventArgs {
    public DependencyObject Parent { get; private set; }
    public DependencyObject Child { get; private set; }
    public int ChildIndex { get; private set; }
    public VisualTreeChangeType ChangeType { get; private set; }
    public VisualTreeChangeEventArgs(DependencyObject parent, DependencyObject child, int childIndex, VisualTreeChangeType changeType);
    [CompilerGeneratedAttribute]
public DependencyObject get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(DependencyObject value);
    [CompilerGeneratedAttribute]
public DependencyObject get_Child();
    [CompilerGeneratedAttribute]
private void set_Child(DependencyObject value);
    [CompilerGeneratedAttribute]
public int get_ChildIndex();
    [CompilerGeneratedAttribute]
private void set_ChildIndex(int value);
    [CompilerGeneratedAttribute]
public VisualTreeChangeType get_ChangeType();
    [CompilerGeneratedAttribute]
private void set_ChangeType(VisualTreeChangeType value);
}
public enum System.Windows.Diagnostics.VisualTreeChangeType : Enum {
    public int value__;
    public static VisualTreeChangeType Add;
    public static VisualTreeChangeType Remove;
}
[DebuggerDisplayAttribute("{line={LineNumber}, offset={LinePosition}, uri={SourceUri}}")]
public class System.Windows.Diagnostics.XamlSourceInfo : object {
    public Uri SourceUri { get; private set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public XamlSourceInfo(Uri sourceUri, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
}
internal static class System.Windows.Diagnostics.XamlSourceInfoHelper : object {
    internal static bool IsXamlSourceInfoEnabled { get; }
    private static XamlSourceInfoHelper();
    internal static bool get_IsXamlSourceInfoEnabled();
    internal static void SetXamlSourceInfo(object obj, XamlObjectEventArgs args, Uri overrideSourceUri);
    internal static void SetXamlSourceInfo(object obj, Uri sourceUri, int elementLineNumber, int elementLinePosition);
    internal static XamlSourceInfo GetXamlSourceInfo(object obj);
}
public abstract class System.Windows.Documents.ContentPosition : object {
    public static ContentPosition Missing;
    private static ContentPosition();
}
public class System.Windows.Documents.DocumentPage : object {
    public static DocumentPage Missing;
    public Visual Visual { get; }
    public Size Size { get; }
    public Rect BleedBox { get; }
    public Rect ContentBox { get; }
    public DocumentPage(Visual visual);
    public DocumentPage(Visual visual, Size pageSize, Rect bleedBox, Rect contentBox);
    private static DocumentPage();
    public virtual void Dispose();
    public virtual Visual get_Visual();
    public virtual Size get_Size();
    public virtual Rect get_BleedBox();
    public virtual Rect get_ContentBox();
    [CompilerGeneratedAttribute]
public void add_PageDestroyed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageDestroyed(EventHandler value);
    protected void OnPageDestroyed(EventArgs e);
    protected void SetVisual(Visual visual);
    protected void SetSize(Size size);
    protected void SetBleedBox(Rect bleedBox);
    protected void SetContentBox(Rect contentBox);
}
public abstract class System.Windows.Documents.DocumentPaginator : object {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public abstract virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync();
    public virtual void ComputePageCountAsync(object userState);
    public virtual void CancelAsync(object userState);
    public abstract virtual bool get_IsPageCountValid();
    public abstract virtual int get_PageCount();
    public abstract virtual Size get_PageSize();
    public abstract virtual void set_PageSize(Size value);
    public abstract virtual IDocumentPaginatorSource get_Source();
    [CompilerGeneratedAttribute]
public void add_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PagesChanged(PagesChangedEventHandler value);
    protected virtual void OnGetPageCompleted(GetPageCompletedEventArgs e);
    protected virtual void OnComputePageCountCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnPagesChanged(PagesChangedEventArgs e);
}
public abstract class System.Windows.Documents.DynamicDocumentPaginator : DocumentPaginator {
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public abstract virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public abstract virtual ContentPosition GetPagePosition(DocumentPage page);
    public abstract virtual ContentPosition GetObjectPosition(object value);
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    [CompilerGeneratedAttribute]
public void add_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationProgress(PaginationProgressEventHandler value);
    protected virtual void OnGetPageNumberCompleted(GetPageNumberCompletedEventArgs e);
    protected virtual void OnPaginationProgress(PaginationProgressEventArgs e);
    protected virtual void OnPaginationCompleted(EventArgs e);
}
public class System.Windows.Documents.GetPageCompletedEventArgs : AsyncCompletedEventArgs {
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; }
    public GetPageCompletedEventArgs(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageCompletedEventHandler : MulticastDelegate {
    public GetPageCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.GetPageNumberCompletedEventArgs : AsyncCompletedEventArgs {
    public ContentPosition ContentPosition { get; }
    public int PageNumber { get; }
    public GetPageNumberCompletedEventArgs(ContentPosition contentPosition, int pageNumber, Exception error, bool cancelled, object userState);
    public ContentPosition get_ContentPosition();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageNumberCompletedEventHandler : MulticastDelegate {
    public GetPageNumberCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageNumberCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageNumberCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.Documents.IDocumentPaginatorSource {
    public DocumentPaginator DocumentPaginator { get; }
    public abstract virtual DocumentPaginator get_DocumentPaginator();
}
public class System.Windows.Documents.PagesChangedEventArgs : EventArgs {
    public int Start { get; }
    public int Count { get; }
    public PagesChangedEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PagesChangedEventHandler : MulticastDelegate {
    public PagesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PagesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PagesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.PaginationProgressEventArgs : EventArgs {
    public int Start { get; }
    public int Count { get; }
    public PaginationProgressEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PaginationProgressEventHandler : MulticastDelegate {
    public PaginationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PaginationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PaginationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DpiChangedEventArgs : RoutedEventArgs {
    public DpiScale OldDpi { get; private set; }
    public DpiScale NewDpi { get; private set; }
    internal DpiChangedEventArgs(DpiScale oldDpi, DpiScale newDpi, RoutedEvent routedEvent, object source);
    [CompilerGeneratedAttribute]
public DpiScale get_OldDpi();
    [CompilerGeneratedAttribute]
private void set_OldDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public DpiScale get_NewDpi();
    [CompilerGeneratedAttribute]
private void set_NewDpi(DpiScale value);
}
public class System.Windows.DpiChangedEventHandler : MulticastDelegate {
    public DpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.DpiFlags : object {
    internal bool DpiScaleFlag1 { get; internal set; }
    internal bool DpiScaleFlag2 { get; internal set; }
    internal int Index { get; internal set; }
    internal DpiFlags(bool dpiScaleFlag1, bool dpiScaleFlag2, int index);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag1();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag1(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag2();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag2(bool value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
}
internal class System.Windows.DpiRecursiveChangeArgs : object {
    internal bool DpiScaleFlag1 { get; internal set; }
    internal bool DpiScaleFlag2 { get; internal set; }
    internal int Index { get; internal set; }
    internal DpiScale OldDpiScale { get; internal set; }
    internal DpiScale NewDpiScale { get; internal set; }
    internal DpiRecursiveChangeArgs(DpiFlags dpiFlags, DpiScale oldDpiScale, DpiScale newDpiScale);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag1();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag1(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag2();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag2(bool value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal DpiScale get_OldDpiScale();
    [CompilerGeneratedAttribute]
internal void set_OldDpiScale(DpiScale value);
    [CompilerGeneratedAttribute]
internal DpiScale get_NewDpiScale();
    [CompilerGeneratedAttribute]
internal void set_NewDpiScale(DpiScale value);
}
public class System.Windows.DpiScale : ValueType {
    private double _dpiScaleX;
    private double _dpiScaleY;
    public double DpiScaleX { get; }
    public double DpiScaleY { get; }
    public double PixelsPerDip { get; }
    public double PixelsPerInchX { get; }
    public double PixelsPerInchY { get; }
    public DpiScale(double dpiScaleX, double dpiScaleY);
    public double get_DpiScaleX();
    public double get_DpiScaleY();
    public double get_PixelsPerDip();
    public double get_PixelsPerInchX();
    public double get_PixelsPerInchY();
}
public enum System.Windows.DragAction : Enum {
    public int value__;
    public static DragAction Continue;
    public static DragAction Drop;
    public static DragAction Cancel;
}
public static class System.Windows.DragDrop : object {
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    internal static RoutedEvent DragDropStartedEvent;
    internal static RoutedEvent DragDropCompletedEvent;
    private static DragDrop();
    public static void AddPreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemovePreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemoveQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddPreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemovePreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemoveGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddPreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDropHandler(DependencyObject element, DragEventHandler handler);
    [SecurityCriticalAttribute]
public static DragDropEffects DoDragDrop(DependencyObject dragSource, object data, DragDropEffects allowedEffects);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RegisterDropTarget(IntPtr windowHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RevokeDropTarget(IntPtr windowHandle);
    internal static bool IsValidDragDropEffects(DragDropEffects dragDropEffects);
    internal static bool IsValidDragAction(DragAction dragAction);
    internal static bool IsValidDragDropKeyStates(DragDropKeyStates dragDropKeyStates);
}
[FlagsAttribute]
public enum System.Windows.DragDropEffects : Enum {
    public int value__;
    public static DragDropEffects None;
    public static DragDropEffects Copy;
    public static DragDropEffects Move;
    public static DragDropEffects Link;
    public static DragDropEffects Scroll;
    public static DragDropEffects All;
}
[FlagsAttribute]
public enum System.Windows.DragDropKeyStates : Enum {
    public int value__;
    public static DragDropKeyStates None;
    public static DragDropKeyStates LeftMouseButton;
    public static DragDropKeyStates RightMouseButton;
    public static DragDropKeyStates ShiftKey;
    public static DragDropKeyStates ControlKey;
    public static DragDropKeyStates MiddleMouseButton;
    public static DragDropKeyStates AltKey;
}
public class System.Windows.DragEventArgs : RoutedEventArgs {
    public IDataObject Data { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragDropEffects AllowedEffects { get; }
    public DragDropEffects Effects { get; public set; }
    internal DragEventArgs(IDataObject data, DragDropKeyStates dragDropKeyStates, DragDropEffects allowedEffects, DependencyObject target, Point point);
    public Point GetPosition(IInputElement relativeTo);
    public IDataObject get_Data();
    public DragDropKeyStates get_KeyStates();
    public DragDropEffects get_AllowedEffects();
    public DragDropEffects get_Effects();
    public void set_Effects(DragDropEffects value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DragEventHandler : MulticastDelegate {
    public DragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.DurationConverter")]
public class System.Windows.Duration : ValueType {
    private TimeSpan _timeSpan;
    private DurationType _durationType;
    public bool HasTimeSpan { get; }
    public static Duration Automatic { get; }
    public static Duration Forever { get; }
    public TimeSpan TimeSpan { get; }
    public Duration(TimeSpan timeSpan);
    public static Duration op_Implicit(TimeSpan timeSpan);
    public static Duration op_Addition(Duration t1, Duration t2);
    public static Duration op_Subtraction(Duration t1, Duration t2);
    public static bool op_Equality(Duration t1, Duration t2);
    public static bool op_Inequality(Duration t1, Duration t2);
    public static bool op_GreaterThan(Duration t1, Duration t2);
    public static bool op_GreaterThanOrEqual(Duration t1, Duration t2);
    public static bool op_LessThan(Duration t1, Duration t2);
    public static bool op_LessThanOrEqual(Duration t1, Duration t2);
    public static int Compare(Duration t1, Duration t2);
    public static Duration Plus(Duration duration);
    public static Duration op_UnaryPlus(Duration duration);
    public bool get_HasTimeSpan();
    public static Duration get_Automatic();
    public static Duration get_Forever();
    public TimeSpan get_TimeSpan();
    public Duration Add(Duration duration);
    public virtual bool Equals(object value);
    public bool Equals(Duration duration);
    public static bool Equals(Duration t1, Duration t2);
    public virtual int GetHashCode();
    public Duration Subtract(Duration duration);
    public virtual string ToString();
}
public class System.Windows.DurationConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
[FriendAccessAllowedAttribute]
[DefaultMemberAttribute("Item")]
internal class System.Windows.EventHandlersStore : object {
    internal FrugalObjectList`1<RoutedEventHandlerInfo> Item { get; }
    internal Delegate Item { get; }
    internal int Count { get; }
    public EventHandlersStore(EventHandlersStore source);
    private static EventHandlersStore();
    public void Add(EventPrivateKey key, Delegate handler);
    public void Remove(EventPrivateKey key, Delegate handler);
    public Delegate Get(EventPrivateKey key);
    public void AddRoutedEventHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void RemoveRoutedEventHandler(RoutedEvent routedEvent, Delegate handler);
    public bool Contains(RoutedEvent routedEvent);
    public RoutedEventHandlerInfo[] GetRoutedEventHandlers(RoutedEvent routedEvent);
    internal FrugalObjectList`1<RoutedEventHandlerInfo> get_Item(RoutedEvent key);
    internal Delegate get_Item(EventPrivateKey key);
    internal int get_Count();
}
public static class System.Windows.EventManager : object {
    public static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public static RoutedEvent[] GetRoutedEvents();
    public static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
    [FriendAccessAllowedAttribute]
internal static RoutedEvent GetRoutedEventFromName(string name, Type ownerType);
}
public class System.Windows.EventPrivateKey : object {
    internal int GlobalIndex { get; }
    internal int get_GlobalIndex();
}
public class System.Windows.EventRoute : object {
    internal RoutedEvent RoutedEvent { get; internal set; }
    public EventRoute(RoutedEvent routedEvent);
    public void Add(object target, Delegate handler, bool handledEventsToo);
    internal void InvokeHandlers(object source, RoutedEventArgs args);
    internal void ReInvokeHandlers(object source, RoutedEventArgs args);
    [EditorBrowsableAttribute("2")]
public void PushBranchNode(object node, object source);
    [EditorBrowsableAttribute("2")]
public object PopBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchSource();
    internal RoutedEvent get_RoutedEvent();
    internal void set_RoutedEvent(RoutedEvent value);
    internal void AddSource(object source);
    internal void Clear();
}
internal static class System.Windows.EventRouteFactory : object {
    private static EventRouteFactory();
    internal static EventRoute FetchObject(RoutedEvent routedEvent);
    internal static void RecycleObject(EventRoute eventRoute);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.FlowDirection : Enum {
    public int value__;
    public static FlowDirection LeftToRight;
    public static FlowDirection RightToLeft;
}
internal class System.Windows.FocusWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public enum System.Windows.FontCapitals : Enum {
    public int value__;
    public static FontCapitals Normal;
    public static FontCapitals AllSmallCaps;
    public static FontCapitals SmallCaps;
    public static FontCapitals AllPetiteCaps;
    public static FontCapitals PetiteCaps;
    public static FontCapitals Unicase;
    public static FontCapitals Titling;
}
public enum System.Windows.FontEastAsianLanguage : Enum {
    public int value__;
    public static FontEastAsianLanguage Normal;
    public static FontEastAsianLanguage Jis78;
    public static FontEastAsianLanguage Jis83;
    public static FontEastAsianLanguage Jis90;
    public static FontEastAsianLanguage Jis04;
    public static FontEastAsianLanguage HojoKanji;
    public static FontEastAsianLanguage NlcKanji;
    public static FontEastAsianLanguage Simplified;
    public static FontEastAsianLanguage Traditional;
    public static FontEastAsianLanguage TraditionalNames;
}
public enum System.Windows.FontEastAsianWidths : Enum {
    public int value__;
    public static FontEastAsianWidths Normal;
    public static FontEastAsianWidths Proportional;
    public static FontEastAsianWidths Full;
    public static FontEastAsianWidths Half;
    public static FontEastAsianWidths Third;
    public static FontEastAsianWidths Quarter;
}
public enum System.Windows.FontFraction : Enum {
    public int value__;
    public static FontFraction Normal;
    public static FontFraction Slashed;
    public static FontFraction Stacked;
}
public enum System.Windows.FontNumeralAlignment : Enum {
    public int value__;
    public static FontNumeralAlignment Normal;
    public static FontNumeralAlignment Proportional;
    public static FontNumeralAlignment Tabular;
}
public enum System.Windows.FontNumeralStyle : Enum {
    public int value__;
    public static FontNumeralStyle Normal;
    public static FontNumeralStyle Lining;
    public static FontNumeralStyle OldStyle;
}
[TypeConverterAttribute("System.Windows.FontStretchConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontStretch : ValueType {
    private int _stretch;
    internal FontStretch(int stretch);
    public static FontStretch FromOpenTypeStretch(int stretchValue);
    public int ToOpenTypeStretch();
    public static int Compare(FontStretch left, FontStretch right);
    public static bool op_LessThan(FontStretch left, FontStretch right);
    public static bool op_LessThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_GreaterThan(FontStretch left, FontStretch right);
    public static bool op_GreaterThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_Equality(FontStretch left, FontStretch right);
    public static bool op_Inequality(FontStretch left, FontStretch right);
    public bool Equals(FontStretch obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.FontStretchConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStretches : object {
    public static FontStretch UltraCondensed { get; }
    public static FontStretch ExtraCondensed { get; }
    public static FontStretch Condensed { get; }
    public static FontStretch SemiCondensed { get; }
    public static FontStretch Normal { get; }
    public static FontStretch Medium { get; }
    public static FontStretch SemiExpanded { get; }
    public static FontStretch Expanded { get; }
    public static FontStretch ExtraExpanded { get; }
    public static FontStretch UltraExpanded { get; }
    public static FontStretch get_UltraCondensed();
    public static FontStretch get_ExtraCondensed();
    public static FontStretch get_Condensed();
    public static FontStretch get_SemiCondensed();
    public static FontStretch get_Normal();
    public static FontStretch get_Medium();
    public static FontStretch get_SemiExpanded();
    public static FontStretch get_Expanded();
    public static FontStretch get_ExtraExpanded();
    public static FontStretch get_UltraExpanded();
    internal static bool FontStretchStringToKnownStretch(string s, IFormatProvider provider, FontStretch& fontStretch);
    internal static bool FontStretchToString(int stretch, String& convertedValue);
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontStyleConverter")]
public class System.Windows.FontStyle : ValueType {
    private int _style;
    internal FontStyle(int style);
    public static bool op_Equality(FontStyle left, FontStyle right);
    public static bool op_Inequality(FontStyle left, FontStyle right);
    public bool Equals(FontStyle obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal int GetStyleForInternalConstruction();
}
public class System.Windows.FontStyleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStyles : object {
    public static FontStyle Normal { get; }
    public static FontStyle Oblique { get; }
    public static FontStyle Italic { get; }
    public static FontStyle get_Normal();
    public static FontStyle get_Oblique();
    public static FontStyle get_Italic();
    internal static bool FontStyleStringToKnownStyle(string s, IFormatProvider provider, FontStyle& fontStyle);
}
public enum System.Windows.FontVariants : Enum {
    public int value__;
    public static FontVariants Normal;
    public static FontVariants Superscript;
    public static FontVariants Subscript;
    public static FontVariants Ordinal;
    public static FontVariants Inferior;
    public static FontVariants Ruby;
}
[TypeConverterAttribute("System.Windows.FontWeightConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.FontWeight : ValueType {
    private int _weight;
    internal FontWeight(int weight);
    public static FontWeight FromOpenTypeWeight(int weightValue);
    public int ToOpenTypeWeight();
    public static int Compare(FontWeight left, FontWeight right);
    public static bool op_LessThan(FontWeight left, FontWeight right);
    public static bool op_LessThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_GreaterThan(FontWeight left, FontWeight right);
    public static bool op_GreaterThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_Equality(FontWeight left, FontWeight right);
    public static bool op_Inequality(FontWeight left, FontWeight right);
    public bool Equals(FontWeight obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class System.Windows.FontWeightConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontWeights : object {
    public static FontWeight Thin { get; }
    public static FontWeight ExtraLight { get; }
    public static FontWeight UltraLight { get; }
    public static FontWeight Light { get; }
    public static FontWeight Normal { get; }
    public static FontWeight Regular { get; }
    public static FontWeight Medium { get; }
    public static FontWeight DemiBold { get; }
    public static FontWeight SemiBold { get; }
    public static FontWeight Bold { get; }
    public static FontWeight ExtraBold { get; }
    public static FontWeight UltraBold { get; }
    public static FontWeight Black { get; }
    public static FontWeight Heavy { get; }
    public static FontWeight ExtraBlack { get; }
    public static FontWeight UltraBlack { get; }
    public static FontWeight get_Thin();
    public static FontWeight get_ExtraLight();
    public static FontWeight get_UltraLight();
    public static FontWeight get_Light();
    public static FontWeight get_Normal();
    public static FontWeight get_Regular();
    public static FontWeight get_Medium();
    public static FontWeight get_DemiBold();
    public static FontWeight get_SemiBold();
    public static FontWeight get_Bold();
    public static FontWeight get_ExtraBold();
    public static FontWeight get_UltraBold();
    public static FontWeight get_Black();
    public static FontWeight get_Heavy();
    public static FontWeight get_ExtraBlack();
    public static FontWeight get_UltraBlack();
    internal static bool FontWeightStringToKnownWeight(string s, IFormatProvider provider, FontWeight& fontWeight);
    internal static bool FontWeightToString(int weight, String& convertedValue);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.FreezableCollection`1 : Animatable {
    internal List`1<T> _collection;
    internal UInt32 _version;
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public FreezableCollection`1(int capacity);
    public FreezableCollection`1(IEnumerable`1<T> collection);
    public FreezableCollection`1<T> Clone();
    public FreezableCollection`1<T> CloneCurrentValue();
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual int IndexOf(T value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(T value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.GiveFeedbackEventArgs : RoutedEventArgs {
    public DragDropEffects Effects { get; }
    public bool UseDefaultCursors { get; public set; }
    internal GiveFeedbackEventArgs(DragDropEffects effects, bool useDefaultCursors);
    public DragDropEffects get_Effects();
    public bool get_UseDefaultCursors();
    public void set_UseDefaultCursors(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.GiveFeedbackEventHandler : MulticastDelegate {
    public GiveFeedbackEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GiveFeedbackEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GiveFeedbackEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.GlobalEventManager : object {
    internal static object Synchronized;
    private static GlobalEventManager();
    internal static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    internal static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal static RoutedEvent[] GetRoutedEvents();
    internal static void AddOwner(RoutedEvent routedEvent, Type ownerType);
    internal static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
    internal static RoutedEvent GetRoutedEventFromName(string name, Type ownerType, bool includeSupers);
    internal static RoutedEventHandlerInfoList GetDTypedClassListeners(DependencyObjectType dType, RoutedEvent routedEvent);
    internal static RoutedEventHandlerInfoList GetDTypedClassListeners(DependencyObjectType dType, RoutedEvent routedEvent, ClassHandlersStore& classListenersLists, Int32& index);
    internal static int GetNextAvailableGlobalIndex(object value);
    internal static object EventFromGlobalIndex(int globalIndex);
}
public class System.Windows.HwndDpiChangedEventArgs : HandledEventArgs {
    public DpiScale OldDpi { get; private set; }
    public DpiScale NewDpi { get; private set; }
    public Rect SuggestedRect { get; private set; }
    [SecurityCriticalAttribute]
internal HwndDpiChangedEventArgs(double oldDpiX, double oldDpiY, double newDpiX, double newDpiY, IntPtr lParam);
    [CompilerGeneratedAttribute]
public DpiScale get_OldDpi();
    [CompilerGeneratedAttribute]
private void set_OldDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public DpiScale get_NewDpi();
    [CompilerGeneratedAttribute]
private void set_NewDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public Rect get_SuggestedRect();
    [CompilerGeneratedAttribute]
private void set_SuggestedRect(Rect value);
}
public class System.Windows.HwndDpiChangedEventHandler : MulticastDelegate {
    public HwndDpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HwndDpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HwndDpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.IContentHost {
    public IEnumerator`1<IInputElement> HostedElements { get; }
    public abstract virtual IInputElement InputHitTest(Point point);
    public abstract virtual ReadOnlyCollection`1<Rect> GetRectangles(ContentElement child);
    public abstract virtual IEnumerator`1<IInputElement> get_HostedElements();
    public abstract virtual void OnChildDesiredSizeChanged(UIElement child);
}
public interface System.Windows.IDataObject {
    [SecurityCriticalAttribute]
public abstract virtual object GetData(string format);
    [SecurityCriticalAttribute]
public abstract virtual object GetData(Type format);
    [SecurityCriticalAttribute]
public abstract virtual object GetData(string format, bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(string format);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(Type format);
    [SecurityCriticalAttribute]
public abstract virtual bool GetDataPresent(string format, bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual String[] GetFormats();
    [SecurityCriticalAttribute]
public abstract virtual String[] GetFormats(bool autoConvert);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string format, object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(Type format, object data);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string format, object data, bool autoConvert);
}
public interface System.Windows.IInputElement {
    public bool IsMouseOver { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseCaptured { get; }
    public bool IsStylusOver { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsEnabled { get; }
    public bool Focusable { get; public set; }
    public abstract virtual void RaiseEvent(RoutedEventArgs e);
    public abstract virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual bool get_IsMouseOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseWheel(MouseWheelEventHandler value);
    public abstract virtual bool get_IsMouseDirectlyOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostMouseCapture(MouseEventHandler value);
    public abstract virtual bool get_IsMouseCaptured();
    public abstract virtual bool CaptureMouse();
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual bool get_IsStylusOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    public abstract virtual bool get_IsStylusDirectlyOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostStylusCapture(StylusEventHandler value);
    public abstract virtual bool get_IsStylusCaptured();
    public abstract virtual bool CaptureStylus();
    public abstract virtual void ReleaseStylusCapture();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyUp(KeyEventHandler value);
    public abstract virtual bool get_IsKeyboardFocusWithin();
    public abstract virtual bool get_IsKeyboardFocused();
    public abstract virtual bool Focus();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual bool get_Focusable();
    public abstract virtual void set_Focusable(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextInput(TextCompositionEventHandler value);
}
public enum System.Windows.Ink.ApplicationGesture : Enum {
    public int value__;
    public static ApplicationGesture AllGestures;
    public static ApplicationGesture ArrowDown;
    public static ApplicationGesture ArrowLeft;
    public static ApplicationGesture ArrowRight;
    public static ApplicationGesture ArrowUp;
    public static ApplicationGesture Check;
    public static ApplicationGesture ChevronDown;
    public static ApplicationGesture ChevronLeft;
    public static ApplicationGesture ChevronRight;
    public static ApplicationGesture ChevronUp;
    public static ApplicationGesture Circle;
    public static ApplicationGesture Curlicue;
    public static ApplicationGesture DoubleCircle;
    public static ApplicationGesture DoubleCurlicue;
    public static ApplicationGesture DoubleTap;
    public static ApplicationGesture Down;
    public static ApplicationGesture DownLeft;
    public static ApplicationGesture DownLeftLong;
    public static ApplicationGesture DownRight;
    public static ApplicationGesture DownRightLong;
    public static ApplicationGesture DownUp;
    public static ApplicationGesture Exclamation;
    public static ApplicationGesture Left;
    public static ApplicationGesture LeftDown;
    public static ApplicationGesture LeftRight;
    public static ApplicationGesture LeftUp;
    public static ApplicationGesture NoGesture;
    public static ApplicationGesture Right;
    public static ApplicationGesture RightDown;
    public static ApplicationGesture RightLeft;
    public static ApplicationGesture RightUp;
    public static ApplicationGesture ScratchOut;
    public static ApplicationGesture SemicircleLeft;
    public static ApplicationGesture SemicircleRight;
    public static ApplicationGesture Square;
    public static ApplicationGesture Star;
    public static ApplicationGesture Tap;
    public static ApplicationGesture Triangle;
    public static ApplicationGesture Up;
    public static ApplicationGesture UpDown;
    public static ApplicationGesture UpLeft;
    public static ApplicationGesture UpLeftLong;
    public static ApplicationGesture UpRight;
    public static ApplicationGesture UpRightLong;
}
internal static class System.Windows.Ink.ApplicationGestureHelper : object {
    internal static int CountOfValues;
    private static ApplicationGestureHelper();
    internal static bool IsDefined(ApplicationGesture applicationGesture);
}
internal enum System.Windows.Ink.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compressed;
    public static CompressionMode NoCompression;
}
public static class System.Windows.Ink.DrawingAttributeIds : object {
    public static Guid Color;
    public static Guid StylusTip;
    public static Guid StylusTipTransform;
    public static Guid StylusHeight;
    public static Guid StylusWidth;
    public static Guid DrawingFlags;
    public static Guid IsHighlighter;
    private static DrawingAttributeIds();
}
public class System.Windows.Ink.DrawingAttributes : object {
    internal static float StylusPrecision;
    internal static double DefaultWidth;
    internal static double DefaultHeight;
    public static double MinHeight;
    public static double MinWidth;
    public static double MaxHeight;
    public static double MaxWidth;
    public Color Color { get; public set; }
    public StylusTip StylusTip { get; public set; }
    public Matrix StylusTipTransform { get; public set; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public bool FitToCurve { get; public set; }
    public bool IgnorePressure { get; public set; }
    public bool IsHighlighter { get; public set; }
    internal ExtendedPropertyCollection ExtendedProperties { get; }
    internal StylusShape StylusShape { get; }
    internal int FittingError { get; internal set; }
    internal DrawingFlags DrawingFlags { get; internal set; }
    internal UInt32 RasterOperation { get; internal set; }
    internal bool HeightChangedForCompatabity { get; internal set; }
    internal DrawingAttributes(ExtendedPropertyCollection extendedProperties);
    private static DrawingAttributes();
    public Color get_Color();
    public void set_Color(Color value);
    public StylusTip get_StylusTip();
    public void set_StylusTip(StylusTip value);
    public Matrix get_StylusTipTransform();
    public void set_StylusTipTransform(Matrix value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Width();
    public void set_Width(double value);
    public bool get_FitToCurve();
    public void set_FitToCurve(bool value);
    public bool get_IgnorePressure();
    public void set_IgnorePressure(bool value);
    public bool get_IsHighlighter();
    public void set_IsHighlighter(bool value);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    internal ExtendedPropertyCollection CopyPropertyData();
    internal StylusShape get_StylusShape();
    internal int get_FittingError();
    internal void set_FittingError(int value);
    internal DrawingFlags get_DrawingFlags();
    internal void set_DrawingFlags(DrawingFlags value);
    internal UInt32 get_RasterOperation();
    internal void set_RasterOperation(UInt32 value);
    internal bool get_HeightChangedForCompatabity();
    internal void set_HeightChangedForCompatabity(bool value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(DrawingAttributes first, DrawingAttributes second);
    public static bool op_Inequality(DrawingAttributes first, DrawingAttributes second);
    public virtual DrawingAttributes Clone();
    [CompilerGeneratedAttribute]
public void add_AttributeChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AttributeChanged(PropertyDataChangedEventHandler value);
    protected virtual void OnAttributeChanged(PropertyDataChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal static object GetDefaultDrawingAttributeValue(Guid id);
    internal static void ValidateStylusTipTransform(Guid propertyDataId, object propertyData);
    internal static bool RemoveIdFromExtendedProperties(Guid id);
    internal static bool GeometricallyEqual(DrawingAttributes left, DrawingAttributes right);
    internal static bool IsGeometricalDaGuid(Guid guid);
}
public class System.Windows.Ink.DrawingAttributesReplacedEventArgs : EventArgs {
    public DrawingAttributes NewDrawingAttributes { get; }
    public DrawingAttributes PreviousDrawingAttributes { get; }
    public DrawingAttributesReplacedEventArgs(DrawingAttributes newDrawingAttributes, DrawingAttributes previousDrawingAttributes);
    public DrawingAttributes get_NewDrawingAttributes();
    public DrawingAttributes get_PreviousDrawingAttributes();
}
public class System.Windows.Ink.DrawingAttributesReplacedEventHandler : MulticastDelegate {
    public DrawingAttributesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DrawingAttributesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DrawingAttributesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Windows.Ink.DrawingFlags : Enum {
    public int value__;
    public static DrawingFlags Polyline;
    public static DrawingFlags FitToCurve;
    public static DrawingFlags SubtractiveTransparency;
    public static DrawingFlags IgnorePressure;
    public static DrawingFlags AntiAliased;
    public static DrawingFlags IgnoreRotation;
    public static DrawingFlags IgnoreAngle;
}
public class System.Windows.Ink.EllipseStylusShape : StylusShape {
    public EllipseStylusShape(double width, double height);
    public EllipseStylusShape(double width, double height, double rotation);
}
internal class System.Windows.Ink.ExtendedPropertiesChangedEventArgs : EventArgs {
    internal ExtendedProperty OldProperty { get; }
    internal ExtendedProperty NewProperty { get; }
    internal ExtendedPropertiesChangedEventArgs(ExtendedProperty oldProperty, ExtendedProperty newProperty);
    internal ExtendedProperty get_OldProperty();
    internal ExtendedProperty get_NewProperty();
}
internal class System.Windows.Ink.ExtendedPropertiesChangedEventHandler : MulticastDelegate {
    public ExtendedPropertiesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExtendedPropertiesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExtendedPropertiesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Ink.ExtendedProperty : object {
    internal Guid Id { get; }
    internal object Value { get; internal set; }
    internal ExtendedProperty(Guid id, object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ExtendedProperty first, ExtendedProperty second);
    public static bool op_Inequality(ExtendedProperty first, ExtendedProperty second);
    public virtual string ToString();
    internal Guid get_Id();
    internal object get_Value();
    internal void set_Value(object value);
    internal ExtendedProperty Clone();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Ink.ExtendedPropertyCollection : object {
    internal object Item { get; internal set; }
    internal ExtendedProperty Item { get; }
    internal int Count { get; }
    public virtual bool Equals(object o);
    public static bool op_Equality(ExtendedPropertyCollection first, ExtendedPropertyCollection second);
    public static bool op_Inequality(ExtendedPropertyCollection first, ExtendedPropertyCollection second);
    public virtual int GetHashCode();
    internal bool Contains(Guid attributeId);
    internal ExtendedPropertyCollection Clone();
    internal void Add(Guid id, object value);
    internal void Remove(Guid id);
    internal Guid[] GetGuidArray();
    internal object get_Item(Guid attributeId);
    internal void set_Item(Guid attributeId, object value);
    internal ExtendedProperty get_Item(int index);
    internal int get_Count();
    [CompilerGeneratedAttribute]
internal void add_Changed(ExtendedPropertiesChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(ExtendedPropertiesChangedEventHandler value);
}
public class System.Windows.Ink.GestureRecognitionResult : object {
    public RecognitionConfidence RecognitionConfidence { get; }
    public ApplicationGesture ApplicationGesture { get; }
    internal GestureRecognitionResult(RecognitionConfidence confidence, ApplicationGesture gesture);
    public RecognitionConfidence get_RecognitionConfidence();
    public ApplicationGesture get_ApplicationGesture();
}
public class System.Windows.Ink.GestureRecognizer : DependencyObject {
    public bool IsRecognizerAvailable { get; }
    public GestureRecognizer(IEnumerable`1<ApplicationGesture> enabledApplicationGestures);
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    [SecurityCriticalAttribute]
public ReadOnlyCollection`1<GestureRecognitionResult> Recognize(StrokeCollection strokes);
    [SecurityCriticalAttribute]
internal ReadOnlyCollection`1<GestureRecognitionResult> CriticalRecognize(StrokeCollection strokes);
    public bool get_IsRecognizerAvailable();
    public sealed virtual void Dispose();
}
internal static class System.Windows.Ink.IEnumerablePointHelper : object {
    internal static int GetCount(IEnumerable`1<Point> ienum);
    internal static Point[] GetPointArray(IEnumerable`1<Point> ienum);
}
public abstract class System.Windows.Ink.IncrementalHitTester : object {
    public bool IsValid { get; }
    internal List`1<StrokeInfo> StrokeInfos { get; }
    internal IncrementalHitTester(StrokeCollection strokes);
    public void AddPoint(Point point);
    public void AddPoints(IEnumerable`1<Point> points);
    public void AddPoints(StylusPointCollection stylusPoints);
    public void EndHitTesting();
    public bool get_IsValid();
    protected abstract virtual void AddPointsCore(IEnumerable`1<Point> points);
    internal List`1<StrokeInfo> get_StrokeInfos();
}
public class System.Windows.Ink.IncrementalLassoHitTester : IncrementalHitTester {
    internal IncrementalLassoHitTester(StrokeCollection strokes, int percentageWithinLasso);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(LassoSelectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(LassoSelectionChangedEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnSelectionChanged(LassoSelectionChangedEventArgs eventArgs);
}
public class System.Windows.Ink.IncrementalStrokeHitTester : IncrementalHitTester {
    internal IncrementalStrokeHitTester(StrokeCollection strokes, StylusShape eraserShape);
    [CompilerGeneratedAttribute]
public void add_StrokeHit(StrokeHitEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokeHit(StrokeHitEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnStrokeHit(StrokeHitEventArgs eventArgs);
}
internal static class System.Windows.Ink.KnownIds : object {
    internal static Guid X;
    internal static Guid Y;
    internal static Guid Z;
    internal static Guid PacketStatus;
    internal static Guid TimerTick;
    internal static Guid SerialNumber;
    internal static Guid NormalPressure;
    internal static Guid TangentPressure;
    internal static Guid ButtonPressure;
    internal static Guid XTiltOrientation;
    internal static Guid YTiltOrientation;
    internal static Guid AzimuthOrientation;
    internal static Guid AltitudeOrientation;
    internal static Guid TwistOrientation;
    internal static Guid PitchRotation;
    internal static Guid RollRotation;
    internal static Guid YawRotation;
    internal static Guid Color;
    internal static Guid DrawingFlags;
    internal static Guid CursorId;
    internal static Guid WordAlternates;
    internal static Guid CharacterAlternates;
    internal static Guid InkMetrics;
    internal static Guid GuideStructure;
    internal static Guid Timestamp;
    internal static Guid Language;
    internal static Guid Transparency;
    internal static Guid CurveFittingError;
    internal static Guid RecognizedLattice;
    internal static Guid CursorDown;
    internal static Guid SecondaryTipSwitch;
    internal static Guid TabletPick;
    internal static Guid BarrelDown;
    internal static Guid RasterOperation;
    internal static Guid StylusHeight;
    internal static Guid StylusWidth;
    internal static Guid Highlighter;
    internal static Guid InkProperties;
    internal static Guid InkStyleBold;
    internal static Guid InkStyleItalics;
    internal static Guid StrokeTimestamp;
    internal static Guid StrokeTimeId;
    internal static Guid StylusTip;
    internal static Guid StylusTipTransform;
    internal static Guid IsHighlighter;
    internal static Guid PenStyle;
    internal static Guid PenTip;
    internal static Guid InkCustomStrokes;
    internal static Guid InkStrokeLattice;
    private static KnownIds();
    internal static string ConvertToString(Guid id);
}
public class System.Windows.Ink.LassoSelectionChangedEventArgs : EventArgs {
    public StrokeCollection SelectedStrokes { get; }
    public StrokeCollection DeselectedStrokes { get; }
    internal LassoSelectionChangedEventArgs(StrokeCollection selectedStrokes, StrokeCollection deselectedStrokes);
    public StrokeCollection get_SelectedStrokes();
    public StrokeCollection get_DeselectedStrokes();
}
public class System.Windows.Ink.LassoSelectionChangedEventHandler : MulticastDelegate {
    public LassoSelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LassoSelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LassoSelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.Ink.MatrixHelper : object {
    internal static bool ContainsNaN(Matrix matrix);
    internal static bool ContainsInfinity(Matrix matrix);
}
internal enum System.Windows.Ink.PersistenceFormat : Enum {
    public int value__;
    public static PersistenceFormat InkSerializedFormat;
    public static PersistenceFormat Gif;
}
public class System.Windows.Ink.PropertyDataChangedEventArgs : EventArgs {
    public Guid PropertyGuid { get; }
    public object NewValue { get; }
    public object PreviousValue { get; }
    public PropertyDataChangedEventArgs(Guid propertyGuid, object newValue, object previousValue);
    public Guid get_PropertyGuid();
    public object get_NewValue();
    public object get_PreviousValue();
}
public class System.Windows.Ink.PropertyDataChangedEventHandler : MulticastDelegate {
    public PropertyDataChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyDataChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyDataChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Ink.RecognitionConfidence : Enum {
    public int value__;
    public static RecognitionConfidence Strong;
    public static RecognitionConfidence Intermediate;
    public static RecognitionConfidence Poor;
}
public class System.Windows.Ink.RectangleStylusShape : StylusShape {
    public RectangleStylusShape(double width, double height);
    public RectangleStylusShape(double width, double height, double rotation);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Ink.Renderer : object {
    internal Visual RootVisual { get; }
    internal StrokeCollection Strokes { get; internal set; }
    internal Visual get_RootVisual();
    internal StrokeCollection get_Strokes();
    internal void set_Strokes(StrokeCollection value);
    internal void AttachIncrementalRendering(Visual visual, DrawingAttributes drawingAttributes);
    internal void DetachIncrementalRendering(Visual visual);
    internal bool ContainsAttachedIncrementalRenderingVisual(Visual visual);
    internal bool AttachedVisualIsPositionedCorrectly(Visual visual, DrawingAttributes drawingAttributes);
    internal void TurnHighContrastOn(Color strokeColor);
    internal void TurnHighContrastOff();
    internal bool IsHighContrast();
    public Color GetHighContrastColor();
}
public class System.Windows.Ink.Stroke : object {
    internal double TapHitPointSize;
    internal double TapHitRotation;
    internal static double PercentageTolerance;
    public DrawingAttributes DrawingAttributes { get; public set; }
    public StylusPointCollection StylusPoints { get; public set; }
    internal ExtendedPropertyCollection ExtendedProperties { get; }
    [FriendAccessAllowedAttribute]
internal bool IsSelected { get; internal set; }
    public Stroke(StylusPointCollection stylusPoints);
    public Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    internal Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes, ExtendedPropertyCollection extendedProperties);
    private static Stroke();
    public virtual Stroke Clone();
    public virtual void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public StylusPointCollection GetBezierStylusPoints();
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public StylusPointCollection get_StylusPoints();
    public void set_StylusPoints(StylusPointCollection value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Invalidated(EventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnDrawingAttributesChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    protected virtual void OnStylusPointsReplaced(StylusPointsReplacedEventArgs e);
    protected virtual void OnStylusPointsChanged(EventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnInvalidated(EventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    public virtual Rect GetBounds();
    public void Draw(DrawingContext context);
    public void Draw(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public StrokeCollection GetClipResult(Rect bounds);
    public StrokeCollection GetClipResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(Rect bounds);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public bool HitTest(Point point);
    public bool HitTest(Point point, double diameter);
    public bool HitTest(Rect bounds, int percentageWithinBounds);
    public bool HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public bool HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    protected virtual void DrawCore(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public Geometry GetGeometry();
    public Geometry GetGeometry(DrawingAttributes drawingAttributes);
    [FriendAccessAllowedAttribute]
internal void DrawInternal(DrawingContext dc, DrawingAttributes DrawingAttributes, bool drawAsHollow);
    internal bool get_IsSelected();
    internal void set_IsSelected(bool value);
    internal void SetGeometry(Geometry geometry);
    internal void SetBounds(Rect newBounds);
    internal StrokeIntersection[] EraseTest(IEnumerable`1<Point> path, StylusShape shape);
    internal StrokeIntersection[] HitTest(Lasso lasso);
    internal StrokeCollection Erase(StrokeIntersection[] cutAt);
    internal StrokeCollection Clip(StrokeIntersection[] cutAt);
}
[TypeConverterAttribute("System.Windows.StrokeCollectionConverter")]
public class System.Windows.Ink.StrokeCollection : Collection`1<Stroke> {
    public static string InkSerializedFormat;
    internal ExtendedPropertyCollection ExtendedProperties { get; private set; }
    public StrokeCollection(IEnumerable`1<Stroke> strokes);
    public StrokeCollection(Stream stream);
    private static StrokeCollection();
    public virtual void Save(Stream stream, bool compress);
    public void Save(Stream stream);
    internal void SaveIsf(Stream stream, bool compress);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public virtual StrokeCollection Clone();
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, Stroke stroke);
    protected sealed virtual void SetItem(int index, Stroke stroke);
    public int IndexOf(Stroke stroke);
    public void Remove(StrokeCollection strokes);
    public void Add(StrokeCollection strokes);
    public void Replace(Stroke strokeToReplace, StrokeCollection strokesToReplaceWith);
    public void Replace(StrokeCollection strokesToReplace, StrokeCollection strokesToReplaceWith);
    internal void AddWithoutEvent(Stroke stroke);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    private void set_ExtendedProperties(ExtendedPropertyCollection value);
    [CompilerGeneratedAttribute]
public void add_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_StrokesChangedInternal(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_StrokesChangedInternal(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnStrokesChanged(StrokeCollectionChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public Rect GetBounds();
    public StrokeCollection HitTest(Point point);
    public StrokeCollection HitTest(Point point, double diameter);
    public StrokeCollection HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public StrokeCollection HitTest(Rect bounds, int percentageWithinBounds);
    public StrokeCollection HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    public void Clip(IEnumerable`1<Point> lassoPoints);
    public void Clip(Rect bounds);
    public void Erase(IEnumerable`1<Point> lassoPoints);
    public void Erase(Rect bounds);
    public void Erase(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public void Draw(DrawingContext context);
    public IncrementalStrokeHitTester GetIncrementalStrokeHitTester(StylusShape eraserShape);
    public IncrementalLassoHitTester GetIncrementalLassoHitTester(int percentageWithinLasso);
}
public class System.Windows.Ink.StrokeCollectionChangedEventArgs : EventArgs {
    public StrokeCollection Added { get; }
    public StrokeCollection Removed { get; }
    internal int Index { get; }
    internal StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed, int index);
    public StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed);
    public StrokeCollection get_Added();
    public StrokeCollection get_Removed();
    internal int get_Index();
}
public class System.Windows.Ink.StrokeCollectionChangedEventHandler : MulticastDelegate {
    public StrokeCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StrokeHitEventArgs : EventArgs {
    public Stroke HitStroke { get; }
    internal StrokeHitEventArgs(Stroke stroke, StrokeIntersection[] hitFragments);
    public Stroke get_HitStroke();
    public StrokeCollection GetPointEraseResults();
}
public class System.Windows.Ink.StrokeHitEventHandler : MulticastDelegate {
    public StrokeHitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeHitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeHitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Ink.StrokeIntersection : ValueType {
    private StrokeFIndices _hitSegment;
    private StrokeFIndices _inSegment;
    internal static double BeforeFirst { get; }
    internal static double AfterLast { get; }
    unknown double HitBegin {internal set; }
    internal double HitEnd { get; internal set; }
    internal double InBegin { get; internal set; }
    internal double InEnd { get; internal set; }
    internal static StrokeIntersection Full { get; }
    internal bool IsEmpty { get; }
    internal StrokeFIndices HitSegment { get; }
    internal StrokeFIndices InSegment { get; }
    internal StrokeIntersection(double hitBegin, double inBegin, double inEnd, double hitEnd);
    private static StrokeIntersection();
    internal static double get_BeforeFirst();
    internal static double get_AfterLast();
    internal void set_HitBegin(double value);
    internal double get_HitEnd();
    internal void set_HitEnd(double value);
    internal double get_InBegin();
    internal void set_InBegin(double value);
    internal double get_InEnd();
    internal void set_InEnd(double value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StrokeIntersection left, StrokeIntersection right);
    public static bool op_Inequality(StrokeIntersection left, StrokeIntersection right);
    internal static StrokeIntersection get_Full();
    internal bool get_IsEmpty();
    internal StrokeFIndices get_HitSegment();
    internal StrokeFIndices get_InSegment();
    internal static StrokeFIndices[] GetInSegments(StrokeIntersection[] intersections);
    internal static StrokeFIndices[] GetHitSegments(StrokeIntersection[] intersections);
}
public class System.Windows.Ink.StylusPointsReplacedEventArgs : EventArgs {
    public StylusPointCollection NewStylusPoints { get; }
    public StylusPointCollection PreviousStylusPoints { get; }
    public StylusPointsReplacedEventArgs(StylusPointCollection newStylusPoints, StylusPointCollection previousStylusPoints);
    public StylusPointCollection get_NewStylusPoints();
    public StylusPointCollection get_PreviousStylusPoints();
}
public class System.Windows.Ink.StylusPointsReplacedEventHandler : MulticastDelegate {
    public StylusPointsReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusPointsReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusPointsReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Ink.StylusShape : object {
    public double Width { get; }
    public double Height { get; }
    public double Rotation { get; }
    internal Matrix Transform { get; internal set; }
    internal bool IsEllipse { get; }
    internal bool IsPolygon { get; }
    internal Rect BoundingBox { get; }
    internal StylusShape(StylusTip tip, double width, double height, double rotation);
    public double get_Width();
    public double get_Height();
    public double get_Rotation();
    internal Vector[] GetVerticesAsVectors();
    internal Matrix get_Transform();
    internal void set_Transform(Matrix value);
    internal bool get_IsEllipse();
    internal bool get_IsPolygon();
    internal Rect get_BoundingBox();
}
public enum System.Windows.Ink.StylusTip : Enum {
    public int value__;
    public static StylusTip Rectangle;
    public static StylusTip Ellipse;
}
internal static class System.Windows.Ink.StylusTipHelper : object {
    internal static bool IsDefined(StylusTip stylusTip);
}
public class System.Windows.Input.AccessKeyEventArgs : EventArgs {
    public string Key { get; }
    public bool IsMultiple { get; }
    internal bool UserInitiated { get; }
    [SecurityCriticalAttribute]
internal AccessKeyEventArgs(string key, bool isMultiple, bool userInitiated);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ClearUserInitiated();
    public string get_Key();
    public bool get_IsMultiple();
    internal bool get_UserInitiated();
}
public class System.Windows.Input.AccessKeyManager : object {
    public static RoutedEvent AccessKeyPressedEvent;
    private static AccessKeyManager();
    public static void Register(string key, IInputElement element);
    public static void Unregister(string key, IInputElement element);
    public static bool IsKeyRegistered(object scope, string key);
    [SecurityCriticalAttribute]
public static bool ProcessKey(object scope, string key, bool isMultiple);
    public static void AddAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    public static void RemoveAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    internal static string InternalGetAccessKeyCharacter(DependencyObject d);
}
public class System.Windows.Input.AccessKeyPressedEventArgs : RoutedEventArgs {
    public object Scope { get; public set; }
    public UIElement Target { get; public set; }
    public string Key { get; }
    public AccessKeyPressedEventArgs(string key);
    public object get_Scope();
    public void set_Scope(object value);
    public UIElement get_Target();
    public void set_Target(UIElement value);
    public string get_Key();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.AccessKeyPressedEventHandler : MulticastDelegate {
    public AccessKeyPressedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AccessKeyPressedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AccessKeyPressedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum System.Windows.Input.AltNumpadConversionMode : Enum {
    public int value__;
    public static AltNumpadConversionMode DefaultCodePage;
    public static AltNumpadConversionMode OEMCodePage;
    public static AltNumpadConversionMode HexDefaultCodePage;
    public static AltNumpadConversionMode HexUnicode;
}
internal static class System.Windows.Input.AngleUtil : object {
    public static double DegreesToRadians(double degrees);
    public static double RadiansToDegrees(double radians);
}
public static class System.Windows.Input.ApplicationCommands : object {
    public static RoutedUICommand Cut { get; }
    public static RoutedUICommand Copy { get; }
    public static RoutedUICommand Paste { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Undo { get; }
    public static RoutedUICommand Redo { get; }
    public static RoutedUICommand Find { get; }
    public static RoutedUICommand Replace { get; }
    public static RoutedUICommand SelectAll { get; }
    public static RoutedUICommand Help { get; }
    public static RoutedUICommand New { get; }
    public static RoutedUICommand Open { get; }
    public static RoutedUICommand Close { get; }
    public static RoutedUICommand Save { get; }
    public static RoutedUICommand SaveAs { get; }
    public static RoutedUICommand Print { get; }
    public static RoutedUICommand CancelPrint { get; }
    public static RoutedUICommand PrintPreview { get; }
    public static RoutedUICommand Properties { get; }
    public static RoutedUICommand ContextMenu { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand CorrectionList { get; }
    public static RoutedUICommand NotACommand { get; }
    private static ApplicationCommands();
    public static RoutedUICommand get_Cut();
    public static RoutedUICommand get_Copy();
    public static RoutedUICommand get_Paste();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Undo();
    public static RoutedUICommand get_Redo();
    public static RoutedUICommand get_Find();
    public static RoutedUICommand get_Replace();
    public static RoutedUICommand get_SelectAll();
    public static RoutedUICommand get_Help();
    public static RoutedUICommand get_New();
    public static RoutedUICommand get_Open();
    public static RoutedUICommand get_Close();
    public static RoutedUICommand get_Save();
    public static RoutedUICommand get_SaveAs();
    public static RoutedUICommand get_Print();
    public static RoutedUICommand get_CancelPrint();
    public static RoutedUICommand get_PrintPreview();
    public static RoutedUICommand get_Properties();
    public static RoutedUICommand get_ContextMenu();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_CorrectionList();
    public static RoutedUICommand get_NotACommand();
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
}
public class System.Windows.Input.CanExecuteChangedEventManager : WeakEventManager {
    private static CanExecuteChangedEventManager();
    public static void AddHandler(ICommand source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(ICommand source, EventHandler`1<EventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
}
public class System.Windows.Input.CanExecuteRoutedEventArgs : RoutedEventArgs {
    public ICommand Command { get; }
    public object Parameter { get; }
    public bool CanExecute { get; public set; }
    public bool ContinueRouting { get; public set; }
    internal CanExecuteRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    public bool get_CanExecute();
    public void set_CanExecute(bool value);
    public bool get_ContinueRouting();
    public void set_ContinueRouting(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.CanExecuteRoutedEventHandler : MulticastDelegate {
    public CanExecuteRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CanExecuteRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CanExecuteRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.CaptureMode : Enum {
    public int value__;
    public static CaptureMode None;
    public static CaptureMode Element;
    public static CaptureMode SubTree;
}
public class System.Windows.Input.CommandBinding : object {
    [LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public CommandBinding(ICommand command);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed, CanExecuteRoutedEventHandler canExecute);
    public ICommand get_Command();
    public void set_Command(ICommand value);
    [CompilerGeneratedAttribute]
public void add_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CanExecute(CanExecuteRoutedEventHandler value);
    internal void OnCanExecute(object sender, CanExecuteRoutedEventArgs e);
    internal void OnExecuted(object sender, ExecutedRoutedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.CommandBindingCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public CommandBinding Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public CommandBindingCollection(IList commandBindings);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object commandBinding);
    private sealed virtual override void System.Collections.IList.Remove(object commandBinding);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CommandBinding get_Item(int index);
    public void set_Item(int index, CommandBinding value);
    public int Add(CommandBinding commandBinding);
    public void AddRange(ICollection collection);
    public void Insert(int index, CommandBinding commandBinding);
    public void Remove(CommandBinding commandBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public int IndexOf(CommandBinding value);
    public bool Contains(CommandBinding commandBinding);
    public void CopyTo(CommandBinding[] commandBindings, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal ICommand FindMatch(object targetElement, InputEventArgs inputEventArgs);
    internal CommandBinding FindMatch(ICommand command, Int32& index);
}
internal class System.Windows.Input.CommandDevice : InputDevice {
    internal static RoutedEvent CommandDeviceEvent;
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal CommandDevice(InputManager inputManager);
    private static CommandDevice();
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual PresentationSource get_ActiveSource();
}
internal class System.Windows.Input.CommandDeviceEventArgs : InputEventArgs {
    internal ICommand Command { get; }
    internal CommandDeviceEventArgs(CommandDevice commandDevice, int timestamp, ICommand command);
    internal ICommand get_Command();
    protected virtual void InvokeEventHandler(Delegate execHandler, object target);
}
internal class System.Windows.Input.CommandDeviceEventHandler : MulticastDelegate {
    public CommandDeviceEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommandDeviceEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CommandDeviceEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.CommandManager : object {
    public static RoutedEvent PreviewExecutedEvent;
    public static RoutedEvent ExecutedEvent;
    public static RoutedEvent PreviewCanExecuteEvent;
    public static RoutedEvent CanExecuteEvent;
    private static CommandManager();
    public static void add_RequerySuggested(EventHandler value);
    public static void remove_RequerySuggested(EventHandler value);
    public static void AddPreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemovePreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemoveExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddPreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemovePreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void AddCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemoveCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RegisterClassInputBinding(Type type, InputBinding inputBinding);
    public static void RegisterClassCommandBinding(Type type, CommandBinding commandBinding);
    public static void InvalidateRequerySuggested();
    [SecurityCriticalAttribute]
internal static void TranslateInput(IInputElement targetElement, InputEventArgs inputEventArgs);
    internal static void OnCanExecute(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnExecuted(object sender, ExecutedRoutedEventArgs e);
    internal static void OnCommandDevice(object sender, CommandDeviceEventArgs e);
}
internal enum System.Windows.Input.CompartmentScope : Enum {
    public int value__;
    public static CompartmentScope Invalid;
    public static CompartmentScope Thread;
    public static CompartmentScope Global;
}
public static class System.Windows.Input.ComponentCommands : object {
    public static RoutedUICommand ScrollPageUp { get; }
    public static RoutedUICommand ScrollPageDown { get; }
    public static RoutedUICommand ScrollPageLeft { get; }
    public static RoutedUICommand ScrollPageRight { get; }
    public static RoutedUICommand ScrollByLine { get; }
    public static RoutedUICommand MoveLeft { get; }
    public static RoutedUICommand MoveRight { get; }
    public static RoutedUICommand MoveUp { get; }
    public static RoutedUICommand MoveDown { get; }
    public static RoutedUICommand MoveToHome { get; }
    public static RoutedUICommand MoveToEnd { get; }
    public static RoutedUICommand MoveToPageUp { get; }
    public static RoutedUICommand MoveToPageDown { get; }
    public static RoutedUICommand ExtendSelectionUp { get; }
    public static RoutedUICommand ExtendSelectionDown { get; }
    public static RoutedUICommand ExtendSelectionLeft { get; }
    public static RoutedUICommand ExtendSelectionRight { get; }
    public static RoutedUICommand SelectToHome { get; }
    public static RoutedUICommand SelectToEnd { get; }
    public static RoutedUICommand SelectToPageUp { get; }
    public static RoutedUICommand SelectToPageDown { get; }
    public static RoutedUICommand MoveFocusUp { get; }
    public static RoutedUICommand MoveFocusDown { get; }
    public static RoutedUICommand MoveFocusForward { get; }
    public static RoutedUICommand MoveFocusBack { get; }
    public static RoutedUICommand MoveFocusPageUp { get; }
    public static RoutedUICommand MoveFocusPageDown { get; }
    private static ComponentCommands();
    public static RoutedUICommand get_ScrollPageUp();
    public static RoutedUICommand get_ScrollPageDown();
    public static RoutedUICommand get_ScrollPageLeft();
    public static RoutedUICommand get_ScrollPageRight();
    public static RoutedUICommand get_ScrollByLine();
    public static RoutedUICommand get_MoveLeft();
    public static RoutedUICommand get_MoveRight();
    public static RoutedUICommand get_MoveUp();
    public static RoutedUICommand get_MoveDown();
    public static RoutedUICommand get_MoveToHome();
    public static RoutedUICommand get_MoveToEnd();
    public static RoutedUICommand get_MoveToPageUp();
    public static RoutedUICommand get_MoveToPageDown();
    public static RoutedUICommand get_ExtendSelectionUp();
    public static RoutedUICommand get_ExtendSelectionDown();
    public static RoutedUICommand get_ExtendSelectionLeft();
    public static RoutedUICommand get_ExtendSelectionRight();
    public static RoutedUICommand get_SelectToHome();
    public static RoutedUICommand get_SelectToEnd();
    public static RoutedUICommand get_SelectToPageUp();
    public static RoutedUICommand get_SelectToPageDown();
    public static RoutedUICommand get_MoveFocusUp();
    public static RoutedUICommand get_MoveFocusDown();
    public static RoutedUICommand get_MoveFocusForward();
    public static RoutedUICommand get_MoveFocusBack();
    public static RoutedUICommand get_MoveFocusPageUp();
    public static RoutedUICommand get_MoveFocusPageDown();
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
}
[TypeConverterAttribute("System.Windows.Input.CursorConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Input.Cursor : object {
    internal CursorType CursorType { get; }
    internal SafeHandle Handle { get; }
    internal string FileName { get; }
    internal Cursor(CursorType cursorType);
    public Cursor(string cursorFile);
    public Cursor(string cursorFile, bool scaleWithDpi);
    public Cursor(Stream cursorStream);
    public Cursor(Stream cursorStream, bool scaleWithDpi);
    [SecurityTreatAsSafeAttribute]
[FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal Cursor(SafeHandle cursorHandle);
    private static Cursor();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal CursorType get_CursorType();
    [SecurityCriticalAttribute]
internal SafeHandle get_Handle();
    internal string get_FileName();
    public virtual string ToString();
}
public class System.Windows.Input.CursorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.Cursors : object {
    public static Cursor None { get; }
    public static Cursor No { get; }
    public static Cursor Arrow { get; }
    public static Cursor AppStarting { get; }
    public static Cursor Cross { get; }
    public static Cursor Help { get; }
    public static Cursor IBeam { get; }
    public static Cursor SizeAll { get; }
    public static Cursor SizeNESW { get; }
    public static Cursor SizeNS { get; }
    public static Cursor SizeNWSE { get; }
    public static Cursor SizeWE { get; }
    public static Cursor UpArrow { get; }
    public static Cursor Wait { get; }
    public static Cursor Hand { get; }
    public static Cursor Pen { get; }
    public static Cursor ScrollNS { get; }
    public static Cursor ScrollWE { get; }
    public static Cursor ScrollAll { get; }
    public static Cursor ScrollN { get; }
    public static Cursor ScrollS { get; }
    public static Cursor ScrollW { get; }
    public static Cursor ScrollE { get; }
    public static Cursor ScrollNW { get; }
    public static Cursor ScrollNE { get; }
    public static Cursor ScrollSW { get; }
    public static Cursor ScrollSE { get; }
    public static Cursor ArrowCD { get; }
    private static Cursors();
    public static Cursor get_None();
    public static Cursor get_No();
    public static Cursor get_Arrow();
    public static Cursor get_AppStarting();
    public static Cursor get_Cross();
    public static Cursor get_Help();
    public static Cursor get_IBeam();
    public static Cursor get_SizeAll();
    public static Cursor get_SizeNESW();
    public static Cursor get_SizeNS();
    public static Cursor get_SizeNWSE();
    public static Cursor get_SizeWE();
    public static Cursor get_UpArrow();
    public static Cursor get_Wait();
    public static Cursor get_Hand();
    public static Cursor get_Pen();
    public static Cursor get_ScrollNS();
    public static Cursor get_ScrollWE();
    public static Cursor get_ScrollAll();
    public static Cursor get_ScrollN();
    public static Cursor get_ScrollS();
    public static Cursor get_ScrollW();
    public static Cursor get_ScrollE();
    public static Cursor get_ScrollNW();
    public static Cursor get_ScrollNE();
    public static Cursor get_ScrollSW();
    public static Cursor get_ScrollSE();
    public static Cursor get_ArrowCD();
    internal static Cursor EnsureCursor(CursorType cursorType);
}
public enum System.Windows.Input.CursorType : Enum {
    public int value__;
    public static CursorType None;
    public static CursorType No;
    public static CursorType Arrow;
    public static CursorType AppStarting;
    public static CursorType Cross;
    public static CursorType Help;
    public static CursorType IBeam;
    public static CursorType SizeAll;
    public static CursorType SizeNESW;
    public static CursorType SizeNS;
    public static CursorType SizeNWSE;
    public static CursorType SizeWE;
    public static CursorType UpArrow;
    public static CursorType Wait;
    public static CursorType Hand;
    public static CursorType Pen;
    public static CursorType ScrollNS;
    public static CursorType ScrollWE;
    public static CursorType ScrollAll;
    public static CursorType ScrollN;
    public static CursorType ScrollS;
    public static CursorType ScrollW;
    public static CursorType ScrollE;
    public static CursorType ScrollNW;
    public static CursorType ScrollNE;
    public static CursorType ScrollSW;
    public static CursorType ScrollSE;
    public static CursorType ArrowCD;
}
internal class System.Windows.Input.DeadCharTextComposition : TextComposition {
    internal bool Composed { get; internal set; }
    [SecurityCriticalAttribute]
internal DeadCharTextComposition(InputManager inputManager, IInputElement source, string text, TextCompositionAutoComplete autoComplete, InputDevice inputDevice);
    internal bool get_Composed();
    internal void set_Composed(bool value);
}
internal class System.Windows.Input.DefaultTextStore : object {
    internal static DefaultTextStore Current { get; }
    internal ITfDocumentMgr DocumentManager { get; internal set; }
    unknown int EditCookie {internal set; }
    internal int TransitoryExtensionSinkCookie { get; internal set; }
    internal ITfDocumentMgr TransitoryDocumentManager { get; }
    internal DefaultTextStore(Dispatcher dispatcher);
    public sealed virtual void GetACPFromPoint(POINT& point, GetPositionFromPointFlags flags, Int32& position);
    public sealed virtual void GetTextExt(int start, int end, RECT& rect, Boolean& clipped);
    public sealed virtual void GetScreenExt(RECT& rect);
    public sealed virtual void GetStatus(TS_STATUS& status);
    public sealed virtual void GetWnd(IntPtr& hwnd);
    public sealed virtual void GetValue(Guid& guidAttribute, Object& varValue);
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnStartComposition(ITfCompositionView view, Boolean& ok);
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnUpdateComposition(ITfCompositionView view, ITfRange rangeNew);
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnEndComposition(ITfCompositionView view);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void OnTransitoryExtensionUpdated(ITfContext context, int ecReadOnly, ITfRange rangeResult, ITfRange rangeComposition, Boolean& fDeleteResultRange);
    internal static DefaultTextStore get_Current();
    [SecurityCriticalAttribute]
internal ITfDocumentMgr get_DocumentManager();
    [SecurityCriticalAttribute]
internal void set_DocumentManager(ITfDocumentMgr value);
    internal void set_EditCookie(int value);
    internal int get_TransitoryExtensionSinkCookie();
    internal void set_TransitoryExtensionSinkCookie(int value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ITfDocumentMgr get_TransitoryDocumentManager();
}
internal class System.Windows.Input.DefaultTextStoreTextComposition : TextComposition {
    [SecurityCriticalAttribute]
internal DefaultTextStoreTextComposition(InputManager inputManager, IInputElement source, string text, TextCompositionAutoComplete autoComplete);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void Complete();
}
public class System.Windows.Input.ExecutedRoutedEventArgs : RoutedEventArgs {
    public ICommand Command { get; }
    public object Parameter { get; }
    internal ExecutedRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.ExecutedRoutedEventHandler : MulticastDelegate {
    public ExecutedRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExecutedRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExecutedRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.FocusManager : object {
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty FocusedElementProperty;
    public static DependencyProperty IsFocusScopeProperty;
    private static FocusManager();
    public static void AddGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    [DesignerSerializationVisibilityAttribute("0")]
public static IInputElement GetFocusedElement(DependencyObject element);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static IInputElement GetFocusedElement(DependencyObject element, bool validate);
    public static void SetFocusedElement(DependencyObject element, IInputElement value);
    public static void SetIsFocusScope(DependencyObject element, bool value);
    public static bool GetIsFocusScope(DependencyObject element);
    public static DependencyObject GetFocusScope(DependencyObject element);
}
public interface System.Windows.Input.ICommandSource {
    public ICommand Command { get; }
    public object CommandParameter { get; }
    public IInputElement CommandTarget { get; }
    public abstract virtual ICommand get_Command();
    public abstract virtual object get_CommandParameter();
    public abstract virtual IInputElement get_CommandTarget();
}
public interface System.Windows.Input.IInputLanguageSource {
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    public abstract virtual void Initialize();
    public abstract virtual void Uninitialize();
    public abstract virtual CultureInfo get_CurrentInputLanguage();
    public abstract virtual void set_CurrentInputLanguage(CultureInfo value);
    public abstract virtual IEnumerable get_InputLanguageList();
}
internal interface System.Windows.Input.IInputProvider {
    public abstract virtual bool ProvidesInputForRootVisual(Visual v);
    public abstract virtual void NotifyDeactivate();
}
internal interface System.Windows.Input.IKeyboardInputProvider {
    public abstract virtual bool AcquireFocus(bool checkOnly);
}
public interface System.Windows.Input.IManipulator {
    public int Id { get; }
    public abstract virtual int get_Id();
    public abstract virtual Point GetPosition(IInputElement relativeTo);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
    [SecurityCriticalAttribute]
public abstract virtual void ManipulationEnded(bool cancel);
}
[FlagsAttribute]
public enum System.Windows.Input.ImeConversionModeValues : Enum {
    public int value__;
    public static ImeConversionModeValues Native;
    public static ImeConversionModeValues Katakana;
    public static ImeConversionModeValues FullShape;
    public static ImeConversionModeValues Roman;
    public static ImeConversionModeValues CharCode;
    public static ImeConversionModeValues NoConversion;
    public static ImeConversionModeValues Eudc;
    public static ImeConversionModeValues Symbol;
    public static ImeConversionModeValues Fixed;
    public static ImeConversionModeValues Alphanumeric;
    public static ImeConversionModeValues DoNotCare;
}
[FlagsAttribute]
public enum System.Windows.Input.ImeSentenceModeValues : Enum {
    public int value__;
    public static ImeSentenceModeValues None;
    public static ImeSentenceModeValues PluralClause;
    public static ImeSentenceModeValues SingleConversion;
    public static ImeSentenceModeValues Automatic;
    public static ImeSentenceModeValues PhrasePrediction;
    public static ImeSentenceModeValues Conversation;
    public static ImeSentenceModeValues DoNotCare;
}
internal interface System.Windows.Input.IMouseInputProvider {
    public abstract virtual bool SetCursor(Cursor cursor);
    public abstract virtual bool CaptureMouse();
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
}
public class System.Windows.Input.InertiaExpansionBehavior : object {
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public Vector DesiredExpansion { get; public set; }
    public double InitialRadius { get; public set; }
    internal InertiaExpansionBehavior(Vector initialVelocity);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public Vector get_DesiredExpansion();
    public void set_DesiredExpansion(Vector value);
    public double get_InitialRadius();
    public void set_InitialRadius(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaExpansionBehavior behavior, InertiaProcessor2D processor, Vector initialVelocity);
}
public class System.Windows.Input.InertiaRotationBehavior : object {
    public double InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredRotation { get; public set; }
    internal InertiaRotationBehavior(double initialVelocity);
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredRotation();
    public void set_DesiredRotation(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaRotationBehavior behavior, InertiaProcessor2D processor, double initialVelocity);
}
public class System.Windows.Input.InertiaTranslationBehavior : object {
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredDisplacement { get; public set; }
    internal InertiaTranslationBehavior(Vector initialVelocity);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredDisplacement();
    public void set_DesiredDisplacement(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaTranslationBehavior behavior, InertiaProcessor2D processor, Vector initialVelocity);
}
public class System.Windows.Input.InputBinding : Freezable {
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    internal static object _dataLock;
    [TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    public InputGesture Gesture { get; public set; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    [SecurityCriticalAttribute]
public InputBinding(ICommand command, InputGesture gesture);
    private static InputBinding();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public virtual InputGesture get_Gesture();
    [SecurityCriticalAttribute]
public virtual void set_Gesture(InputGesture value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputBindingCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public InputBinding Item { get; public set; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public InputBindingCollection(IList inputBindings);
    internal InputBindingCollection(DependencyObject owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputBinding);
    private sealed virtual override void System.Collections.IList.Remove(object inputBinding);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public InputBinding get_Item(int index);
    public void set_Item(int index, InputBinding value);
    public int Add(InputBinding inputBinding);
    public sealed virtual bool get_IsSynchronized();
    public int IndexOf(InputBinding value);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputBinding inputBinding);
    public void Remove(InputBinding inputBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void Clear();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public bool Contains(InputBinding key);
    public void CopyTo(InputBinding[] inputBindings, int index);
    internal InputBinding FindMatch(object targetElement, InputEventArgs inputEventArgs);
}
public abstract class System.Windows.Input.InputDevice : DispatcherObject {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public abstract virtual IInputElement get_Target();
    public abstract virtual PresentationSource get_ActiveSource();
}
internal static class System.Windows.Input.InputElement : object {
    private static InputElement();
    internal static bool IsValid(IInputElement e);
    internal static bool IsValid(DependencyObject o);
    internal static bool IsUIElement(DependencyObject o);
    internal static bool IsUIElement3D(DependencyObject o);
    internal static bool IsContentElement(DependencyObject o);
    internal static DependencyObject GetContainingUIElement(DependencyObject o, bool onlyTraverse2D);
    internal static DependencyObject GetContainingUIElement(DependencyObject o);
    internal static IInputElement GetContainingInputElement(DependencyObject o, bool onlyTraverse2D);
    internal static IInputElement GetContainingInputElement(DependencyObject o);
    internal static DependencyObject GetContainingVisual(DependencyObject o);
    internal static DependencyObject GetRootVisual(DependencyObject o);
    internal static DependencyObject GetRootVisual(DependencyObject o, bool enable2DTo3DTransition);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Point TranslatePoint(Point pt, DependencyObject from, DependencyObject to);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Point TranslatePoint(Point pt, DependencyObject from, DependencyObject to, Boolean& translated);
}
[FriendAccessAllowedAttribute]
public class System.Windows.Input.InputEventArgs : RoutedEventArgs {
    public InputDevice Device { get; internal set; }
    public int Timestamp { get; }
    public InputEventArgs(InputDevice inputDevice, int timestamp);
    public InputDevice get_Device();
    internal void set_Device(InputDevice value);
    public int get_Timestamp();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.InputEventHandler : MulticastDelegate {
    public InputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Input.InputGesture : object {
    public abstract virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputGestureCollection : object {
    private object System.Collections.IList.Item { get; private set; }
    public InputGesture Item { get; public set; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public InputGestureCollection(IList inputGestures);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputGesture);
    private sealed virtual override void System.Collections.IList.Remove(object inputGesture);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IEnumerator GetEnumerator();
    public InputGesture get_Item(int index);
    public void set_Item(int index, InputGesture value);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int IndexOf(InputGesture value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public int Add(InputGesture inputGesture);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputGesture inputGesture);
    public sealed virtual bool get_IsReadOnly();
    public void Remove(InputGesture inputGesture);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public bool Contains(InputGesture key);
    public void CopyTo(InputGesture[] inputGestures, int index);
    public void Seal();
    internal InputGesture FindMatch(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.InputLanguageChangedEventArgs : InputLanguageEventArgs {
    public InputLanguageChangedEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
}
public class System.Windows.Input.InputLanguageChangingEventArgs : InputLanguageEventArgs {
    public bool Rejected { get; public set; }
    public InputLanguageChangingEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool get_Rejected();
    public void set_Rejected(bool value);
}
public abstract class System.Windows.Input.InputLanguageEventArgs : EventArgs {
    public CultureInfo NewLanguage { get; }
    public CultureInfo PreviousLanguage { get; }
    protected InputLanguageEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public virtual CultureInfo get_NewLanguage();
    public virtual CultureInfo get_PreviousLanguage();
}
public class System.Windows.Input.InputLanguageEventHandler : MulticastDelegate {
    public InputLanguageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputLanguageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputLanguageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.InputLanguageManager : DispatcherObject {
    public static DependencyProperty InputLanguageProperty;
    public static DependencyProperty RestoreInputLanguageProperty;
    public static InputLanguageManager Current { get; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable AvailableInputLanguages { get; }
    internal IInputLanguageSource Source { get; }
    internal static bool IsMultipleKeyboardLayout { get; }
    private static InputLanguageManager();
    public static void SetInputLanguage(DependencyObject target, CultureInfo inputLanguage);
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static CultureInfo GetInputLanguage(DependencyObject target);
    public static void SetRestoreInputLanguage(DependencyObject target, bool restore);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetRestoreInputLanguage(DependencyObject target);
    public void RegisterInputLanguageSource(IInputLanguageSource inputLanguageSource);
    public void ReportInputLanguageChanged(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool ReportInputLanguageChanging(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public static InputLanguageManager get_Current();
    public CultureInfo get_CurrentInputLanguage();
    public void set_CurrentInputLanguage(CultureInfo value);
    public IEnumerable get_AvailableInputLanguages();
    public void add_InputLanguageChanged(InputLanguageEventHandler value);
    public void remove_InputLanguageChanged(InputLanguageEventHandler value);
    public void add_InputLanguageChanging(InputLanguageEventHandler value);
    public void remove_InputLanguageChanging(InputLanguageEventHandler value);
    internal void Focus(DependencyObject focus, DependencyObject focused);
    internal IInputLanguageSource get_Source();
    internal static bool get_IsMultipleKeyboardLayout();
}
internal class System.Windows.Input.InputLanguageProfileNotifySink : object {
    internal InputLanguageProfileNotifySink(InputLanguageSource target);
    public sealed virtual void OnLanguageChange(short langid, Boolean& accept);
    public sealed virtual void OnLanguageChanged();
}
internal class System.Windows.Input.InputLanguageSource : object {
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    internal InputLanguageSource(InputLanguageManager inputlanguagemanager);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize();
    public sealed virtual void Uninitialize();
    public sealed virtual CultureInfo get_CurrentInputLanguage();
    public sealed virtual void set_CurrentInputLanguage(CultureInfo value);
    public sealed virtual IEnumerable get_InputLanguageList();
    internal bool OnLanguageChange(short langid);
    internal void OnLanguageChanged();
}
public class System.Windows.Input.InputManager : DispatcherObject {
    internal static RoutedEvent PreviewInputReportEvent;
    [FriendAccessAllowedAttribute]
internal static RoutedEvent InputReportEvent;
    public static InputManager Current { get; }
    internal static InputManager UnsecureCurrent { get; }
    internal static bool IsSynchronizedInput { get; }
    internal static RoutedEvent[] SynchronizedInputEvents { get; }
    internal static RoutedEvent[] PairedSynchronizedInputEvents { get; }
    internal static SynchronizedInputType SynchronizeInputType { get; }
    internal static DependencyObject ListeningElement { get; }
    internal static SynchronizedInputStates SynchronizedInputState { get; internal set; }
    public ICollection InputProviders { get; }
    internal ICollection UnsecureInputProviders { get; }
    public KeyboardDevice PrimaryKeyboardDevice { get; }
    public MouseDevice PrimaryMouseDevice { get; }
    internal StylusLogic StylusLogic { get; }
    internal CommandDevice PrimaryCommandDevice { get; }
    internal bool InDragDrop { get; internal set; }
    public InputDevice MostRecentInputDevice { get; internal set; }
    public bool IsInMenuMode { get; }
    private static InputManager();
    [SecurityCriticalAttribute]
public static InputManager get_Current();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static InputManager get_UnsecureCurrent();
    internal static bool get_IsSynchronizedInput();
    internal static RoutedEvent[] get_SynchronizedInputEvents();
    internal static RoutedEvent[] get_PairedSynchronizedInputEvents();
    internal static SynchronizedInputType get_SynchronizeInputType();
    internal static DependencyObject get_ListeningElement();
    internal static SynchronizedInputStates get_SynchronizedInputState();
    internal static void set_SynchronizedInputState(SynchronizedInputStates value);
    [SecurityCriticalAttribute]
public void add_PreProcessInput(PreProcessInputEventHandler value);
    [SecurityCriticalAttribute]
public void remove_PreProcessInput(PreProcessInputEventHandler value);
    [SecurityCriticalAttribute]
public void add_PreNotifyInput(NotifyInputEventHandler value);
    [SecurityCriticalAttribute]
public void remove_PreNotifyInput(NotifyInputEventHandler value);
    [SecurityCriticalAttribute]
public void add_PostNotifyInput(NotifyInputEventHandler value);
    [SecurityCriticalAttribute]
public void remove_PostNotifyInput(NotifyInputEventHandler value);
    [SecurityCriticalAttribute]
public void add_PostProcessInput(ProcessInputEventHandler value);
    [SecurityCriticalAttribute]
public void remove_PostProcessInput(ProcessInputEventHandler value);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal void add_TranslateAccelerator(KeyEventHandler value);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal void remove_TranslateAccelerator(KeyEventHandler value);
    [SecurityCriticalAttribute]
internal void RaiseTranslateAccelerator(KeyEventArgs e);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal InputProviderSite RegisterInputProvider(IInputProvider inputProvider);
    [SecurityCriticalAttribute]
internal void UnregisterInputProvider(IInputProvider inputProvider);
    [SecurityCriticalAttribute]
public ICollection get_InputProviders();
    [SecurityCriticalAttribute]
internal ICollection get_UnsecureInputProviders();
    public KeyboardDevice get_PrimaryKeyboardDevice();
    public MouseDevice get_PrimaryMouseDevice();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal StylusLogic get_StylusLogic();
    internal CommandDevice get_PrimaryCommandDevice();
    internal bool get_InDragDrop();
    internal void set_InDragDrop(bool value);
    public InputDevice get_MostRecentInputDevice();
    internal void set_MostRecentInputDevice(InputDevice value);
    public void PushMenuMode(PresentationSource menuSite);
    public void PopMenuMode(PresentationSource menuSite);
    public bool get_IsInMenuMode();
    [CompilerGeneratedAttribute]
public void add_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_HitTestInvalidatedAsync(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_HitTestInvalidatedAsync(EventHandler value);
    internal void NotifyHitTestInvalidated();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void SafeCurrentNotifyHitTestInvalidated();
    internal void InvalidateInputDevices();
    [SecurityCriticalAttribute]
public bool ProcessInput(InputEventArgs input);
    [SecurityCriticalAttribute]
internal StagingAreaInputItem PushInput(StagingAreaInputItem inputItem);
    [SecurityCriticalAttribute]
internal StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    [SecurityCriticalAttribute]
internal StagingAreaInputItem PushMarker();
    [SecurityCriticalAttribute]
internal StagingAreaInputItem PopInput();
    [SecurityCriticalAttribute]
internal StagingAreaInputItem PeekInput();
    [SecurityCriticalAttribute]
internal object ContinueProcessingStagingArea(object unused);
    internal static bool StartListeningSynchronizedInput(DependencyObject d, SynchronizedInputType inputType);
    internal static void CancelSynchronizedInput();
}
public class System.Windows.Input.InputMethod : DispatcherObject {
    public static DependencyProperty IsInputMethodEnabledProperty;
    public static DependencyProperty IsInputMethodSuspendedProperty;
    public static DependencyProperty PreferredImeStateProperty;
    public static DependencyProperty PreferredImeConversionModeProperty;
    public static DependencyProperty PreferredImeSentenceModeProperty;
    public static DependencyProperty InputScopeProperty;
    public static InputMethod Current { get; }
    public InputMethodState ImeState { get; public set; }
    public InputMethodState MicrophoneState { get; public set; }
    public InputMethodState HandwritingState { get; public set; }
    public SpeechMode SpeechMode { get; public set; }
    public ImeConversionModeValues ImeConversionMode { get; public set; }
    public ImeSentenceModeValues ImeSentenceMode { get; public set; }
    public bool CanShowConfigurationUI { get; }
    public bool CanShowRegisterWordUI { get; }
    internal TextServicesContext TextServicesContext { get; internal set; }
    internal TextServicesCompartmentContext TextServicesCompartmentContext { get; internal set; }
    internal InputLanguageManager InputLanguageManager { get; internal set; }
    internal DefaultTextStore DefaultTextStore { get; internal set; }
    private static InputMethod();
    public static void SetIsInputMethodEnabled(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodEnabled(DependencyObject target);
    public static void SetIsInputMethodSuspended(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodSuspended(DependencyObject target);
    public static void SetPreferredImeState(DependencyObject target, InputMethodState value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputMethodState GetPreferredImeState(DependencyObject target);
    public static void SetPreferredImeConversionMode(DependencyObject target, ImeConversionModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeConversionModeValues GetPreferredImeConversionMode(DependencyObject target);
    public static void SetPreferredImeSentenceMode(DependencyObject target, ImeSentenceModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeSentenceModeValues GetPreferredImeSentenceMode(DependencyObject target);
    public static void SetInputScope(DependencyObject target, InputScope value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputScope GetInputScope(DependencyObject target);
    public static InputMethod get_Current();
    public void ShowConfigureUI();
    public void ShowConfigureUI(UIElement element);
    public void ShowRegisterWordUI();
    public void ShowRegisterWordUI(string registeredText);
    public void ShowRegisterWordUI(UIElement element, string registeredText);
    [SecurityCriticalAttribute]
public InputMethodState get_ImeState();
    [SecurityCriticalAttribute]
public void set_ImeState(InputMethodState value);
    [SecurityCriticalAttribute]
public InputMethodState get_MicrophoneState();
    [SecurityCriticalAttribute]
public void set_MicrophoneState(InputMethodState value);
    [SecurityCriticalAttribute]
public InputMethodState get_HandwritingState();
    [SecurityCriticalAttribute]
public void set_HandwritingState(InputMethodState value);
    [SecurityCriticalAttribute]
public SpeechMode get_SpeechMode();
    [SecurityCriticalAttribute]
public void set_SpeechMode(SpeechMode value);
    [SecurityCriticalAttribute]
public ImeConversionModeValues get_ImeConversionMode();
    [SecurityCriticalAttribute]
public void set_ImeConversionMode(ImeConversionModeValues value);
    [SecurityCriticalAttribute]
public ImeSentenceModeValues get_ImeSentenceMode();
    [SecurityCriticalAttribute]
public void set_ImeSentenceMode(ImeSentenceModeValues value);
    public bool get_CanShowConfigurationUI();
    public bool get_CanShowRegisterWordUI();
    public void add_StateChanged(InputMethodStateChangedEventHandler value);
    public void remove_StateChanged(InputMethodStateChangedEventHandler value);
    internal void GotKeyboardFocus(DependencyObject focus);
    internal void OnChange(Guid& rguid);
    internal static bool IsImm32ImeCurrent();
    internal static bool IsImm32Ime(IntPtr hkl);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void EnableOrDisableInputMethod(bool bEnabled);
    internal TextServicesContext get_TextServicesContext();
    internal void set_TextServicesContext(TextServicesContext value);
    internal TextServicesCompartmentContext get_TextServicesCompartmentContext();
    internal void set_TextServicesCompartmentContext(TextServicesCompartmentContext value);
    internal InputLanguageManager get_InputLanguageManager();
    internal void set_InputLanguageManager(InputLanguageManager value);
    internal DefaultTextStore get_DefaultTextStore();
    internal void set_DefaultTextStore(DefaultTextStore value);
}
internal class System.Windows.Input.InputMethodEventTypeInfo : object {
    internal InputMethodStateType Type { get; }
    internal Guid Guid { get; }
    internal CompartmentScope Scope { get; }
    internal static InputMethodEventTypeInfo[] InfoList { get; }
    internal InputMethodEventTypeInfo(InputMethodStateType type, Guid guid, CompartmentScope scope);
    private static InputMethodEventTypeInfo();
    internal static InputMethodStateType ToType(Guid& rguid);
    internal InputMethodStateType get_Type();
    internal Guid get_Guid();
    internal CompartmentScope get_Scope();
    internal static InputMethodEventTypeInfo[] get_InfoList();
}
public enum System.Windows.Input.InputMethodState : Enum {
    public int value__;
    public static InputMethodState Off;
    public static InputMethodState On;
    public static InputMethodState DoNotCare;
}
public class System.Windows.Input.InputMethodStateChangedEventArgs : EventArgs {
    public bool IsImeStateChanged { get; }
    public bool IsMicrophoneStateChanged { get; }
    public bool IsHandwritingStateChanged { get; }
    public bool IsSpeechModeChanged { get; }
    public bool IsImeConversionModeChanged { get; }
    public bool IsImeSentenceModeChanged { get; }
    internal InputMethodStateChangedEventArgs(InputMethodStateType statetype);
    public bool get_IsImeStateChanged();
    public bool get_IsMicrophoneStateChanged();
    public bool get_IsHandwritingStateChanged();
    public bool get_IsSpeechModeChanged();
    public bool get_IsImeConversionModeChanged();
    public bool get_IsImeSentenceModeChanged();
}
public class System.Windows.Input.InputMethodStateChangedEventHandler : MulticastDelegate {
    public InputMethodStateChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputMethodStateChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputMethodStateChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum System.Windows.Input.InputMethodStateType : Enum {
    public int value__;
    public static InputMethodStateType Invalid;
    public static InputMethodStateType ImeState;
    public static InputMethodStateType MicrophoneState;
    public static InputMethodStateType HandwritingState;
    public static InputMethodStateType SpeechMode;
    public static InputMethodStateType ImeConversionModeValues;
    public static InputMethodStateType ImeSentenceModeValues;
}
public enum System.Windows.Input.InputMode : Enum {
    public int value__;
    public static InputMode Foreground;
    public static InputMode Sink;
}
internal class System.Windows.Input.InputProcessorProfiles : object {
    unknown short CurrentInputLanguage {internal set; }
    internal ArrayList InputLanguageList { get; }
    [SecurityCriticalAttribute]
internal bool Initialize(object o);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Uninitialize();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set_CurrentInputLanguage(short value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ArrayList get_InputLanguageList();
}
internal static class System.Windows.Input.InputProcessorProfilesLoader : object {
    [SecurityCriticalAttribute]
internal static ITfInputProcessorProfiles Load();
}
internal class System.Windows.Input.InputProviderSite : object {
    public InputManager InputManager { get; }
    internal InputManager CriticalInputManager { get; }
    public bool IsDisposed { get; }
    [SecurityCriticalAttribute]
internal InputProviderSite(InputManager inputManager, IInputProvider inputProvider);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public InputManager get_InputManager();
    [SecurityCriticalAttribute]
internal InputManager get_CriticalInputManager();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    public bool get_IsDisposed();
    [SecurityCriticalAttribute]
public bool ReportInput(InputReport inputReport);
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Input.InputReport : object {
    public PresentationSource InputSource { get; }
    public InputType Type { get; }
    public InputMode Mode { get; }
    public int Timestamp { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected InputReport(PresentationSource inputSource, InputType type, InputMode mode, int timestamp);
    [SecurityCriticalAttribute]
public PresentationSource get_InputSource();
    public InputType get_Type();
    public InputMode get_Mode();
    public int get_Timestamp();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Input.InputReportEventArgs : InputEventArgs {
    public InputReport Report { get; }
    public InputReportEventArgs(InputDevice inputDevice, InputReport report);
    public InputReport get_Report();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
internal class System.Windows.Input.InputReportEventHandler : MulticastDelegate {
    public InputReportEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputReportEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputReportEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.InputScopeConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScope : object {
    [DesignerSerializationVisibilityAttribute("2")]
public IList Names { get; }
    [DefaultValueAttribute("")]
public string SrgsMarkup { get; public set; }
    [DefaultValueAttribute("")]
public string RegularExpression { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList PhraseList { get; }
    public IList get_Names();
    public string get_SrgsMarkup();
    public void set_SrgsMarkup(string value);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public IList get_PhraseList();
}
public class System.Windows.Input.InputScopeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("NameValue")]
[TypeConverterAttribute("System.Windows.Input.InputScopeNameConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScopeName : object {
    public InputScopeNameValue NameValue { get; public set; }
    public InputScopeName(InputScopeNameValue nameValue);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
    public InputScopeNameValue get_NameValue();
    public void set_NameValue(InputScopeNameValue value);
}
public class System.Windows.Input.InputScopeNameConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Input.InputScopeNameValue : Enum {
    public int value__;
    public static InputScopeNameValue Default;
    public static InputScopeNameValue Url;
    public static InputScopeNameValue FullFilePath;
    public static InputScopeNameValue FileName;
    public static InputScopeNameValue EmailUserName;
    public static InputScopeNameValue EmailSmtpAddress;
    public static InputScopeNameValue LogOnName;
    public static InputScopeNameValue PersonalFullName;
    public static InputScopeNameValue PersonalNamePrefix;
    public static InputScopeNameValue PersonalGivenName;
    public static InputScopeNameValue PersonalMiddleName;
    public static InputScopeNameValue PersonalSurname;
    public static InputScopeNameValue PersonalNameSuffix;
    public static InputScopeNameValue PostalAddress;
    public static InputScopeNameValue PostalCode;
    public static InputScopeNameValue AddressStreet;
    public static InputScopeNameValue AddressStateOrProvince;
    public static InputScopeNameValue AddressCity;
    public static InputScopeNameValue AddressCountryName;
    public static InputScopeNameValue AddressCountryShortName;
    public static InputScopeNameValue CurrencyAmountAndSymbol;
    public static InputScopeNameValue CurrencyAmount;
    public static InputScopeNameValue Date;
    public static InputScopeNameValue DateMonth;
    public static InputScopeNameValue DateDay;
    public static InputScopeNameValue DateYear;
    public static InputScopeNameValue DateMonthName;
    public static InputScopeNameValue DateDayName;
    public static InputScopeNameValue Digits;
    public static InputScopeNameValue Number;
    public static InputScopeNameValue OneChar;
    public static InputScopeNameValue Password;
    public static InputScopeNameValue TelephoneNumber;
    public static InputScopeNameValue TelephoneCountryCode;
    public static InputScopeNameValue TelephoneAreaCode;
    public static InputScopeNameValue TelephoneLocalNumber;
    public static InputScopeNameValue Time;
    public static InputScopeNameValue TimeHour;
    public static InputScopeNameValue TimeMinorSec;
    public static InputScopeNameValue NumberFullWidth;
    public static InputScopeNameValue AlphanumericHalfWidth;
    public static InputScopeNameValue AlphanumericFullWidth;
    public static InputScopeNameValue CurrencyChinese;
    public static InputScopeNameValue Bopomofo;
    public static InputScopeNameValue Hiragana;
    public static InputScopeNameValue KatakanaHalfWidth;
    public static InputScopeNameValue KatakanaFullWidth;
    public static InputScopeNameValue Hanja;
    public static InputScopeNameValue PhraseList;
    public static InputScopeNameValue RegularExpression;
    public static InputScopeNameValue Srgs;
    public static InputScopeNameValue Xml;
}
[ContentPropertyAttribute("Name")]
public class System.Windows.Input.InputScopePhrase : object {
    public string Name { get; public set; }
    public InputScopePhrase(string name);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
    public string get_Name();
    public void set_Name(string value);
}
public enum System.Windows.Input.InputType : Enum {
    public int value__;
    public static InputType Keyboard;
    public static InputType Mouse;
    public static InputType Stylus;
    public static InputType Hid;
    public static InputType Text;
    public static InputType Command;
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[FriendAccessAllowedAttribute]
internal interface System.Windows.Input.ISecureCommand {
    public PermissionSet UserInitiatedPermission { get; }
    public abstract virtual PermissionSet get_UserInitiatedPermission();
}
public class System.Windows.Input.KeyBinding : InputBinding {
    public static DependencyProperty ModifiersProperty;
    public static DependencyProperty KeyProperty;
    [TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
public InputGesture Gesture { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public Key Key { get; public set; }
    public KeyBinding(ICommand command, KeyGesture gesture);
    public KeyBinding(ICommand command, Key key, ModifierKeys modifiers);
    private static KeyBinding();
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public Key get_Key();
    public void set_Key(Key value);
    protected virtual Freezable CreateInstanceCore();
}
public static class System.Windows.Input.Keyboard : object {
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent KeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static IInputElement FocusedElement { get; }
    public static RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public static ModifierKeys Modifiers { get; }
    public static KeyboardDevice PrimaryDevice { get; }
    private static Keyboard();
    public static void AddPreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemovePreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemoveKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static IInputElement get_FocusedElement();
    public static void ClearFocus();
    public static IInputElement Focus(IInputElement element);
    public static RestoreFocusMode get_DefaultRestoreFocusMode();
    public static void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public static ModifierKeys get_Modifiers();
    public static bool IsKeyDown(Key key);
    public static bool IsKeyUp(Key key);
    public static bool IsKeyToggled(Key key);
    public static KeyStates GetKeyStates(Key key);
    [SecurityCriticalAttribute]
public static KeyboardDevice get_PrimaryDevice();
    internal static bool IsValidKey(Key key);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static bool IsFocusable(DependencyObject element);
}
public abstract class System.Windows.Input.KeyboardDevice : InputDevice {
    public IInputElement Target { get; }
    internal IInputElement ForceTarget { get; internal set; }
    public PresentationSource ActiveSource { get; }
    public RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public IInputElement FocusedElement { get; }
    public ModifierKeys Modifiers { get; }
    internal TextServicesManager TextServicesManager { get; }
    internal TextCompositionManager TextCompositionManager { get; }
    internal bool IsActive { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected KeyboardDevice(InputManager inputManager);
    protected abstract virtual KeyStates GetKeyStatesFromSystem(Key key);
    public virtual IInputElement get_Target();
    internal IInputElement get_ForceTarget();
    internal void set_ForceTarget(IInputElement value);
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    [CompilerGeneratedAttribute]
public RestoreFocusMode get_DefaultRestoreFocusMode();
    [CompilerGeneratedAttribute]
public void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public IInputElement get_FocusedElement();
    public void ClearFocus();
    [SecurityCriticalAttribute]
public IInputElement Focus(IInputElement element);
    public ModifierKeys get_Modifiers();
    public bool IsKeyDown(Key key);
    public bool IsKeyUp(Key key);
    public bool IsKeyToggled(Key key);
    public KeyStates GetKeyStates(Key key);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal TextServicesManager get_TextServicesManager();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextCompositionManager get_TextCompositionManager();
    internal void ReevaluateFocusAsync(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsActive();
}
public class System.Windows.Input.KeyboardEventArgs : InputEventArgs {
    public KeyboardDevice KeyboardDevice { get; }
    public KeyboardEventArgs(KeyboardDevice keyboard, int timestamp);
    public KeyboardDevice get_KeyboardDevice();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardEventHandler : MulticastDelegate {
    public KeyboardEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardFocusChangedEventArgs : KeyboardEventArgs {
    public IInputElement OldFocus { get; }
    public IInputElement NewFocus { get; }
    public KeyboardFocusChangedEventArgs(KeyboardDevice keyboard, int timestamp, IInputElement oldFocus, IInputElement newFocus);
    public IInputElement get_OldFocus();
    public IInputElement get_NewFocus();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardFocusChangedEventHandler : MulticastDelegate {
    public KeyboardFocusChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardFocusChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardFocusChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventArgs : KeyboardEventArgs {
    public bool FocusAcquired { get; }
    public KeyboardInputProviderAcquireFocusEventArgs(KeyboardDevice keyboard, int timestamp, bool focusAcquired);
    public bool get_FocusAcquired();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler : MulticastDelegate {
    public KeyboardInputProviderAcquireFocusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyEventArgs : KeyboardEventArgs {
    public PresentationSource InputSource { get; }
    public Key Key { get; }
    internal Key RealKey { get; }
    public Key ImeProcessedKey { get; }
    public Key SystemKey { get; }
    public Key DeadCharProcessedKey { get; }
    public KeyStates KeyStates { get; }
    public bool IsRepeat { get; }
    public bool IsDown { get; }
    public bool IsUp { get; }
    public bool IsToggled { get; }
    internal PresentationSource UnsafeInputSource { get; }
    internal int ScanCode { get; internal set; }
    internal bool IsExtendedKey { get; internal set; }
    [SecurityCriticalAttribute]
public KeyEventArgs(KeyboardDevice keyboard, PresentationSource inputSource, int timestamp, Key key);
    [SecurityCriticalAttribute]
public PresentationSource get_InputSource();
    public Key get_Key();
    internal Key get_RealKey();
    public Key get_ImeProcessedKey();
    public Key get_SystemKey();
    public Key get_DeadCharProcessedKey();
    public KeyStates get_KeyStates();
    public bool get_IsRepeat();
    public bool get_IsDown();
    public bool get_IsUp();
    public bool get_IsToggled();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal void SetRepeat(bool newRepeatState);
    internal void MarkNormal();
    internal void MarkSystem();
    internal void MarkImeProcessed();
    internal void MarkDeadCharProcessed();
    [SecurityCriticalAttribute]
internal PresentationSource get_UnsafeInputSource();
    internal int get_ScanCode();
    internal void set_ScanCode(int value);
    internal bool get_IsExtendedKey();
    internal void set_IsExtendedKey(bool value);
}
public class System.Windows.Input.KeyEventHandler : MulticastDelegate {
    public KeyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
public class System.Windows.Input.KeyGesture : InputGesture {
    public ModifierKeys Modifiers { get; }
    public Key Key { get; }
    public string DisplayString { get; }
    public KeyGesture(Key key);
    public KeyGesture(Key key, ModifierKeys modifiers);
    public KeyGesture(Key key, ModifierKeys modifiers, string displayString);
    internal KeyGesture(Key key, ModifierKeys modifiers, bool validateGesture);
    private static KeyGesture();
    public ModifierKeys get_Modifiers();
    public Key get_Key();
    public string get_DisplayString();
    public string GetDisplayStringForCulture(CultureInfo culture);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
    internal static bool IsDefinedKey(Key key);
    internal static bool IsValid(Key key, ModifierKeys modifiers);
    internal static void AddGesturesFromResourceStrings(string keyGestures, string displayStrings, InputGestureCollection gestures);
    internal static KeyGesture CreateFromResourceStrings(string keyGestureToken, string keyDisplayString);
}
public class System.Windows.Input.KeyGestureConverter : TypeConverter {
    internal static char DISPLAYSTRING_SEPARATOR;
    private static KeyGestureConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsDefinedKey(Key key);
}
public class System.Windows.Input.KeyGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[FlagsAttribute]
public enum System.Windows.Input.KeyStates : Enum {
    public byte value__;
    public static KeyStates None;
    public static KeyStates Down;
    public static KeyStates Toggled;
}
public static class System.Windows.Input.Manipulation : object {
    internal static RoutedEvent ManipulationStartingEvent;
    internal static RoutedEvent ManipulationStartedEvent;
    internal static RoutedEvent ManipulationDeltaEvent;
    internal static RoutedEvent ManipulationInertiaStartingEvent;
    internal static RoutedEvent ManipulationBoundaryFeedbackEvent;
    internal static RoutedEvent ManipulationCompletedEvent;
    private static Manipulation();
    public static bool IsManipulationActive(UIElement element);
    public static void StartInertia(UIElement element);
    public static void CompleteManipulation(UIElement element);
    internal static bool TryCompleteManipulation(UIElement element);
    public static void SetManipulationMode(UIElement element, ManipulationModes mode);
    public static ManipulationModes GetManipulationMode(UIElement element);
    public static void SetManipulationContainer(UIElement element, IInputElement container);
    public static IInputElement GetManipulationContainer(UIElement element);
    public static void SetManipulationPivot(UIElement element, ManipulationPivot pivot);
    public static ManipulationPivot GetManipulationPivot(UIElement element);
    public static void AddManipulator(UIElement element, IManipulator manipulator);
    public static void RemoveManipulator(UIElement element, IManipulator manipulator);
    internal static bool TryRemoveManipulator(UIElement element, IManipulator manipulator);
    [BrowsableAttribute("False")]
public static void SetManipulationParameter(UIElement element, ManipulationParameters2D parameter);
    internal static UIElement FindManipulationParent(Visual visual);
}
public class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public ManipulationDelta BoundaryFeedback { get; private set; }
    internal Func`2<Point, Point> CompensateForBoundaryFeedback { get; internal set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationBoundaryFeedbackEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, ManipulationDelta boundaryFeedback);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_BoundaryFeedback();
    [CompilerGeneratedAttribute]
private void set_BoundaryFeedback(ManipulationDelta value);
    [CompilerGeneratedAttribute]
internal Func`2<Point, Point> get_CompensateForBoundaryFeedback();
    [CompilerGeneratedAttribute]
internal void set_CompensateForBoundaryFeedback(Func`2<Point, Point> value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationCompletedEventArgs : InputEventArgs {
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta TotalManipulation { get; private set; }
    public ManipulationVelocities FinalVelocities { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationCompletedEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationDelta total, ManipulationVelocities velocities, bool isInertial);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public bool get_IsInertial();
    [CompilerGeneratedAttribute]
private void set_IsInertial(bool value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_TotalManipulation();
    [CompilerGeneratedAttribute]
private void set_TotalManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_FinalVelocities();
    [CompilerGeneratedAttribute]
private void set_FinalVelocities(ManipulationVelocities value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationDelta : object {
    public Vector Translation { get; private set; }
    public double Rotation { get; private set; }
    public Vector Scale { get; private set; }
    public Vector Expansion { get; private set; }
    public ManipulationDelta(Vector translation, double rotation, Vector scale, Vector expansion);
    [CompilerGeneratedAttribute]
public Vector get_Translation();
    [CompilerGeneratedAttribute]
private void set_Translation(Vector value);
    [CompilerGeneratedAttribute]
public double get_Rotation();
    [CompilerGeneratedAttribute]
private void set_Rotation(double value);
    [CompilerGeneratedAttribute]
public Vector get_Scale();
    [CompilerGeneratedAttribute]
private void set_Scale(Vector value);
    [CompilerGeneratedAttribute]
public Vector get_Expansion();
    [CompilerGeneratedAttribute]
private void set_Expansion(Vector value);
}
public class System.Windows.Input.ManipulationDeltaEventArgs : InputEventArgs {
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta CumulativeManipulation { get; private set; }
    public ManipulationDelta DeltaManipulation { get; private set; }
    public ManipulationVelocities Velocities { get; private set; }
    internal ManipulationDelta UnusedManipulation { get; private set; }
    internal bool RequestedComplete { get; private set; }
    internal bool RequestedInertia { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationDeltaEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationDelta delta, ManipulationDelta cumulative, ManipulationVelocities velocities, bool isInertial);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public bool get_IsInertial();
    [CompilerGeneratedAttribute]
private void set_IsInertial(bool value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_CumulativeManipulation();
    [CompilerGeneratedAttribute]
private void set_CumulativeManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_DeltaManipulation();
    [CompilerGeneratedAttribute]
private void set_DeltaManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_Velocities();
    [CompilerGeneratedAttribute]
private void set_Velocities(ManipulationVelocities value);
    public void ReportBoundaryFeedback(ManipulationDelta unusedManipulation);
    [CompilerGeneratedAttribute]
internal ManipulationDelta get_UnusedManipulation();
    [CompilerGeneratedAttribute]
private void set_UnusedManipulation(ManipulationDelta value);
    public void Complete();
    public void StartInertia();
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedComplete();
    [CompilerGeneratedAttribute]
private void set_RequestedComplete(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedInertia();
    [CompilerGeneratedAttribute]
private void set_RequestedInertia(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
internal class System.Windows.Input.ManipulationDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    internal ManipulationModes ManipulationMode { get; internal set; }
    internal ManipulationPivot ManipulationPivot { get; internal set; }
    internal IInputElement ManipulationContainer { get; internal set; }
    internal bool IsManipulationActive { get; }
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    internal static ManipulationDevice AddManipulationDevice(UIElement element);
    internal static ManipulationDevice GetManipulationDevice(UIElement element);
    internal void AddManipulator(IManipulator manipulator);
    internal void RemoveManipulator(IManipulator manipulator);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ManipulationModes get_ManipulationMode();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set_ManipulationMode(ManipulationModes value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ManipulationPivot get_ManipulationPivot();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_ManipulationPivot(ManipulationPivot value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal IInputElement get_ManipulationContainer();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_ManipulationContainer(IInputElement value);
    internal IEnumerable`1<IManipulator> GetManipulatorsReadOnly();
    internal void OnManipulatorUpdated(object sender, EventArgs e);
    internal Point GetTransformedManipulatorPosition(Point point);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsManipulationActive();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SetManipulationParameters(ManipulationParameters2D parameter);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void CompleteManipulation(bool withInertia);
    [SecurityCriticalAttribute]
internal void ProcessManipulationInput(InputEventArgs e);
}
public class System.Windows.Input.ManipulationInertiaStartingEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; public set; }
    public ManipulationVelocities InitialVelocities { get; private set; }
    public InertiaTranslationBehavior TranslationBehavior { get; public set; }
    public InertiaRotationBehavior RotationBehavior { get; public set; }
    public InertiaExpansionBehavior ExpansionBehavior { get; public set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationInertiaStartingEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationVelocities initialVelocities, bool isInInertia);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
public void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_InitialVelocities();
    [CompilerGeneratedAttribute]
private void set_InitialVelocities(ManipulationVelocities value);
    public InertiaTranslationBehavior get_TranslationBehavior();
    public void set_TranslationBehavior(InertiaTranslationBehavior value);
    public InertiaRotationBehavior get_RotationBehavior();
    public void set_RotationBehavior(InertiaRotationBehavior value);
    public InertiaExpansionBehavior get_ExpansionBehavior();
    public void set_ExpansionBehavior(InertiaExpansionBehavior value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    [BrowsableAttribute("False")]
public void SetInertiaParameter(InertiaParameters2D parameter);
    internal bool CanBeginInertia();
    internal void ApplyParameters(InertiaProcessor2D processor);
}
internal class System.Windows.Input.ManipulationLogic : object {
    internal IInputElement ManipulationContainer { get; internal set; }
    internal ManipulationModes ManipulationMode { get; internal set; }
    internal ManipulationPivot ManipulationPivot { get; internal set; }
    internal bool IsManipulationActive { get; }
    internal ManipulationLogic(ManipulationDevice manipulationDevice);
    private static ManipulationLogic();
    internal void OnCompleted();
    internal void Complete(bool withInertia);
    internal void BeginInertia(ManipulationInertiaStartingEventArgs e);
    internal static long GetCurrentTimestamp();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void PushEventsToDevice();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void RaiseBoundaryFeedback(ManipulationDelta unusedManipulation, bool requestedComplete);
    internal void ReportFrame(ICollection`1<IManipulator> manipulators);
    internal IInputElement get_ManipulationContainer();
    internal void set_ManipulationContainer(IInputElement value);
    internal ManipulationModes get_ManipulationMode();
    internal void set_ManipulationMode(ManipulationModes value);
    internal ManipulationPivot get_ManipulationPivot();
    internal void set_ManipulationPivot(ManipulationPivot value);
    internal void SetManipulationParameters(ManipulationParameters2D parameter);
    internal void add_ContainerLayoutUpdated(EventHandler`1<EventArgs> value);
    internal void remove_ContainerLayoutUpdated(EventHandler`1<EventArgs> value);
    internal bool get_IsManipulationActive();
}
[FlagsAttribute]
public enum System.Windows.Input.ManipulationModes : Enum {
    public int value__;
    public static ManipulationModes None;
    public static ManipulationModes TranslateX;
    public static ManipulationModes TranslateY;
    public static ManipulationModes Translate;
    public static ManipulationModes Rotate;
    public static ManipulationModes Scale;
    public static ManipulationModes All;
}
public class System.Windows.Input.ManipulationPivot : object {
    public Point Center { get; public set; }
    public double Radius { get; public set; }
    public ManipulationPivot(Point center, double radius);
    [CompilerGeneratedAttribute]
public Point get_Center();
    [CompilerGeneratedAttribute]
public void set_Center(Point value);
    [CompilerGeneratedAttribute]
public double get_Radius();
    [CompilerGeneratedAttribute]
public void set_Radius(double value);
}
public class System.Windows.Input.ManipulationStartedEventArgs : InputEventArgs {
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    internal bool RequestedComplete { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationStartedEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    public void Complete();
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedComplete();
    [CompilerGeneratedAttribute]
private void set_RequestedComplete(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationStartingEventArgs : InputEventArgs {
    public ManipulationModes Mode { get; public set; }
    public IInputElement ManipulationContainer { get; public set; }
    public ManipulationPivot Pivot { get; public set; }
    public bool IsSingleTouchEnabled { get; public set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal IList`1<ManipulationParameters2D> Parameters { get; }
    internal ManipulationStartingEventArgs(ManipulationDevice manipulationDevice, int timestamp);
    public ManipulationModes get_Mode();
    public void set_Mode(ManipulationModes value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
public void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public ManipulationPivot get_Pivot();
    [CompilerGeneratedAttribute]
public void set_Pivot(ManipulationPivot value);
    [CompilerGeneratedAttribute]
public bool get_IsSingleTouchEnabled();
    [CompilerGeneratedAttribute]
public void set_IsSingleTouchEnabled(bool value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [BrowsableAttribute("False")]
public void SetManipulationParameter(ManipulationParameters2D parameter);
    internal IList`1<ManipulationParameters2D> get_Parameters();
}
public class System.Windows.Input.ManipulationVelocities : object {
    public Vector LinearVelocity { get; private set; }
    public double AngularVelocity { get; private set; }
    public Vector ExpansionVelocity { get; private set; }
    public ManipulationVelocities(Vector linearVelocity, double angularVelocity, Vector expansionVelocity);
    [CompilerGeneratedAttribute]
public Vector get_LinearVelocity();
    [CompilerGeneratedAttribute]
private void set_LinearVelocity(Vector value);
    [CompilerGeneratedAttribute]
public double get_AngularVelocity();
    [CompilerGeneratedAttribute]
private void set_AngularVelocity(double value);
    [CompilerGeneratedAttribute]
public Vector get_ExpansionVelocity();
    [CompilerGeneratedAttribute]
private void set_ExpansionVelocity(Vector value);
}
public static class System.Windows.Input.MediaCommands : object {
    public static RoutedUICommand Play { get; }
    public static RoutedUICommand Pause { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand Record { get; }
    public static RoutedUICommand NextTrack { get; }
    public static RoutedUICommand PreviousTrack { get; }
    public static RoutedUICommand FastForward { get; }
    public static RoutedUICommand Rewind { get; }
    public static RoutedUICommand ChannelUp { get; }
    public static RoutedUICommand ChannelDown { get; }
    public static RoutedUICommand TogglePlayPause { get; }
    public static RoutedUICommand Select { get; }
    public static RoutedUICommand IncreaseVolume { get; }
    public static RoutedUICommand DecreaseVolume { get; }
    public static RoutedUICommand MuteVolume { get; }
    public static RoutedUICommand IncreaseTreble { get; }
    public static RoutedUICommand DecreaseTreble { get; }
    public static RoutedUICommand IncreaseBass { get; }
    public static RoutedUICommand DecreaseBass { get; }
    public static RoutedUICommand BoostBass { get; }
    public static RoutedUICommand IncreaseMicrophoneVolume { get; }
    public static RoutedUICommand DecreaseMicrophoneVolume { get; }
    public static RoutedUICommand MuteMicrophoneVolume { get; }
    public static RoutedUICommand ToggleMicrophoneOnOff { get; }
    private static MediaCommands();
    public static RoutedUICommand get_Play();
    public static RoutedUICommand get_Pause();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_Record();
    public static RoutedUICommand get_NextTrack();
    public static RoutedUICommand get_PreviousTrack();
    public static RoutedUICommand get_FastForward();
    public static RoutedUICommand get_Rewind();
    public static RoutedUICommand get_ChannelUp();
    public static RoutedUICommand get_ChannelDown();
    public static RoutedUICommand get_TogglePlayPause();
    public static RoutedUICommand get_Select();
    public static RoutedUICommand get_IncreaseVolume();
    public static RoutedUICommand get_DecreaseVolume();
    public static RoutedUICommand get_MuteVolume();
    public static RoutedUICommand get_IncreaseTreble();
    public static RoutedUICommand get_DecreaseTreble();
    public static RoutedUICommand get_IncreaseBass();
    public static RoutedUICommand get_DecreaseBass();
    public static RoutedUICommand get_BoostBass();
    public static RoutedUICommand get_IncreaseMicrophoneVolume();
    public static RoutedUICommand get_DecreaseMicrophoneVolume();
    public static RoutedUICommand get_MuteMicrophoneVolume();
    public static RoutedUICommand get_ToggleMicrophoneOnOff();
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
}
public static class System.Windows.Input.Mouse : object {
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static int MouseWheelDeltaForOneLine;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    internal static CaptureMode CapturedMode { get; }
    public static Cursor OverrideCursor { get; public set; }
    public static MouseButtonState LeftButton { get; }
    public static MouseButtonState RightButton { get; }
    public static MouseButtonState MiddleButton { get; }
    public static MouseButtonState XButton1 { get; }
    public static MouseButtonState XButton2 { get; }
    public static MouseDevice PrimaryDevice { get; }
    private static Mouse();
    public static void AddPreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemovePreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddPreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemovePreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemoveMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static void RemoveQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    internal static CaptureMode get_CapturedMode();
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    [SecurityCriticalAttribute]
public static int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    public static Cursor get_OverrideCursor();
    public static void set_OverrideCursor(Cursor value);
    public static bool SetCursor(Cursor cursor);
    public static MouseButtonState get_LeftButton();
    public static MouseButtonState get_RightButton();
    public static MouseButtonState get_MiddleButton();
    public static MouseButtonState get_XButton1();
    public static MouseButtonState get_XButton2();
    public static Point GetPosition(IInputElement relativeTo);
    public static void Synchronize();
    public static void UpdateCursor();
    [SecurityCriticalAttribute]
public static MouseDevice get_PrimaryDevice();
}
[TypeConverterAttribute("System.Windows.Input.MouseActionConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseActionValueSerializer")]
public enum System.Windows.Input.MouseAction : Enum {
    public byte value__;
    public static MouseAction None;
    public static MouseAction LeftClick;
    public static MouseAction RightClick;
    public static MouseAction MiddleClick;
    public static MouseAction WheelClick;
    public static MouseAction LeftDoubleClick;
    public static MouseAction RightDoubleClick;
    public static MouseAction MiddleDoubleClick;
}
public class System.Windows.Input.MouseActionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsDefinedMouseAction(MouseAction mouseAction);
}
public class System.Windows.Input.MouseActionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseBinding : InputBinding {
    public static DependencyProperty MouseActionProperty;
    [ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
public InputGesture Gesture { get; public set; }
    public MouseAction MouseAction { get; public set; }
    internal MouseBinding(ICommand command, MouseAction mouseAction);
    public MouseBinding(ICommand command, MouseGesture gesture);
    private static MouseBinding();
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public enum System.Windows.Input.MouseButton : Enum {
    public int value__;
    public static MouseButton Left;
    public static MouseButton Middle;
    public static MouseButton Right;
    public static MouseButton XButton1;
    public static MouseButton XButton2;
}
public class System.Windows.Input.MouseButtonEventArgs : MouseEventArgs {
    public MouseButton ChangedButton { get; }
    public MouseButtonState ButtonState { get; }
    public int ClickCount { get; internal set; }
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button);
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button, StylusDevice stylusDevice);
    public MouseButton get_ChangedButton();
    public MouseButtonState get_ButtonState();
    public int get_ClickCount();
    internal void set_ClickCount(int value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseButtonEventHandler : MulticastDelegate {
    public MouseButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.MouseButtonState : Enum {
    public int value__;
    public static MouseButtonState Released;
    public static MouseButtonState Pressed;
}
internal class System.Windows.Input.MouseButtonUtilities : object {
    [FriendAccessAllowedAttribute]
internal static void Validate(MouseButton button);
}
public abstract class System.Windows.Input.MouseDevice : InputDevice {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    [FriendAccessAllowedAttribute]
internal IInputElement RawDirectlyOver { get; }
    public IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    public Cursor OverrideCursor { get; public set; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    internal Point PositionRelativeToOver { get; }
    internal Point NonRelativePosition { get; }
    internal bool IsActive { get; }
    internal StylusDevice StylusDevice { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal MouseDevice(InputManager inputManager);
    protected MouseButtonState GetButtonState(MouseButton mouseButton);
    protected Point GetScreenPosition();
    internal abstract virtual MouseButtonState GetButtonStateFromSystem(MouseButton mouseButton);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Point GetScreenPositionFromSystem();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected Point GetClientPosition();
    protected Point GetClientPosition(PresentationSource presentationSource);
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    [SecurityCriticalAttribute]
internal PresentationSource get_CriticalActiveSource();
    public IInputElement get_DirectlyOver();
    internal IInputElement get_RawDirectlyOver();
    public IInputElement get_Captured();
    internal CaptureMode get_CapturedMode();
    public bool Capture(IInputElement element);
    [SecurityCriticalAttribute]
public bool Capture(IInputElement element, CaptureMode captureMode);
    public Cursor get_OverrideCursor();
    public void set_OverrideCursor(Cursor value);
    [SecurityCriticalAttribute]
public bool SetCursor(Cursor cursor);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    [SecurityCriticalAttribute]
public Point GetPosition(IInputElement relativeTo);
    internal void ReevaluateMouseOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    [SecurityCriticalAttribute]
public void Synchronize();
    public void UpdateCursor();
    internal static IInputElement GlobalHitTest(bool clientUnits, Point pt, PresentationSource inputSource);
    internal static IInputElement GlobalHitTest(Point ptClient, PresentationSource inputSource);
    internal static IInputElement LocalHitTest(bool clientUnits, Point pt, PresentationSource inputSource);
    internal static IInputElement LocalHitTest(Point ptClient, PresentationSource inputSource);
    internal bool IsSameSpot(Point newPosition, StylusDevice stylusDevice);
    internal int CalculateClickCount(MouseButton button, int timeStamp, StylusDevice stylusDevice, Point downPt);
    internal Point get_PositionRelativeToOver();
    internal Point get_NonRelativePosition();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsActive();
    internal StylusDevice get_StylusDevice();
}
public class System.Windows.Input.MouseEventArgs : InputEventArgs {
    public MouseDevice MouseDevice { get; }
    public StylusDevice StylusDevice { get; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    public MouseEventArgs(MouseDevice mouse, int timestamp);
    public MouseEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public MouseDevice get_MouseDevice();
    public StylusDevice get_StylusDevice();
    public Point GetPosition(IInputElement relativeTo);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseEventHandler : MulticastDelegate {
    public MouseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
public class System.Windows.Input.MouseGesture : InputGesture {
    public MouseAction MouseAction { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public MouseGesture(MouseAction mouseAction);
    public MouseGesture(MouseAction mouseAction, ModifierKeys modifiers);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
    internal static bool IsDefinedMouseAction(MouseAction mouseAction);
    [CompilerGeneratedAttribute]
internal void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal virtual void OnPropertyChanged(string propertyName);
    internal static MouseAction GetMouseAction(InputEventArgs inputArgs);
}
public class System.Windows.Input.MouseGestureConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseWheelEventArgs : MouseEventArgs {
    public int Delta { get; }
    public MouseWheelEventArgs(MouseDevice mouse, int timestamp, int delta);
    public int get_Delta();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseWheelEventHandler : MulticastDelegate {
    public MouseWheelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseWheelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseWheelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.MultiTouchSystemGestureLogic : object {
    internal Nullable`1<SystemGesture> GenerateStaticGesture(RawStylusInputReport stylusInputReport);
}
public static class System.Windows.Input.NavigationCommands : object {
    public static RoutedUICommand BrowseBack { get; }
    public static RoutedUICommand BrowseForward { get; }
    public static RoutedUICommand BrowseHome { get; }
    public static RoutedUICommand BrowseStop { get; }
    public static RoutedUICommand Refresh { get; }
    public static RoutedUICommand Favorites { get; }
    public static RoutedUICommand Search { get; }
    public static RoutedUICommand IncreaseZoom { get; }
    public static RoutedUICommand DecreaseZoom { get; }
    public static RoutedUICommand Zoom { get; }
    public static RoutedUICommand NextPage { get; }
    public static RoutedUICommand PreviousPage { get; }
    public static RoutedUICommand FirstPage { get; }
    public static RoutedUICommand LastPage { get; }
    public static RoutedUICommand GoToPage { get; }
    public static RoutedUICommand NavigateJournal { get; }
    private static NavigationCommands();
    public static RoutedUICommand get_BrowseBack();
    public static RoutedUICommand get_BrowseForward();
    public static RoutedUICommand get_BrowseHome();
    public static RoutedUICommand get_BrowseStop();
    public static RoutedUICommand get_Refresh();
    public static RoutedUICommand get_Favorites();
    public static RoutedUICommand get_Search();
    public static RoutedUICommand get_IncreaseZoom();
    public static RoutedUICommand get_DecreaseZoom();
    public static RoutedUICommand get_Zoom();
    public static RoutedUICommand get_NextPage();
    public static RoutedUICommand get_PreviousPage();
    public static RoutedUICommand get_FirstPage();
    public static RoutedUICommand get_LastPage();
    public static RoutedUICommand get_GoToPage();
    public static RoutedUICommand get_NavigateJournal();
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
}
public class System.Windows.Input.NotifyInputEventArgs : EventArgs {
    public StagingAreaInputItem StagingItem { get; }
    public InputManager InputManager { get; }
    internal InputManager UnsecureInputManager { get; }
    [SecurityCriticalAttribute]
internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    public StagingAreaInputItem get_StagingItem();
    [SecurityCriticalAttribute]
public InputManager get_InputManager();
    [SecurityCriticalAttribute]
internal InputManager get_UnsecureInputManager();
}
public class System.Windows.Input.NotifyInputEventHandler : MulticastDelegate {
    public NotifyInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.PenContext : object {
    [SecurityCriticalAttribute]
internal SecurityCriticalDataClass`1<IPimcContext2> _pimcContext;
    internal PenContexts Contexts { get; }
    internal IntPtr CommHandle { get; }
    internal int Id { get; }
    internal int TabletDeviceId { get; }
    internal StylusPointDescription StylusPointDescription { get; }
    internal bool SupportInRange { get; }
    internal bool UpdateScreenMeasurementsPending { get; internal set; }
    internal int LastInRangeTime { get; }
    internal int QueuedInRangeCount { get; }
    internal UInt32 WispContextKey { get; private set; }
    [SecurityCriticalAttribute]
internal PenContext(IPimcContext2 pimcContext, IntPtr hwnd, PenContexts contexts, bool supportInRange, bool isIntegrated, int id, IntPtr commHandle, int tabletDeviceId, UInt32 wispContextKey);
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
internal PenContexts get_Contexts();
    [SecurityCriticalAttribute]
internal IntPtr get_CommHandle();
    internal int get_Id();
    internal int get_TabletDeviceId();
    internal StylusPointDescription get_StylusPointDescription();
    [SecurityCriticalAttribute]
internal void Enable();
    [SecurityCriticalAttribute]
internal void Disable(bool shutdownWorkerThread);
    internal bool get_SupportInRange();
    internal bool IsInRange(int stylusPointerId);
    [SecurityCriticalAttribute]
internal void FirePenDown(int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void FirePenUp(int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void FirePackets(int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void FirePenInRange(int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void FirePenOutOfRange(int stylusPointerId, int timestamp);
    [SecurityCriticalAttribute]
internal void FireSystemGesture(int stylusPointerId, int timestamp);
    internal void CheckForRectMappingChanged(Int32[] data, int numPackets);
    [CompilerGeneratedAttribute]
internal bool get_UpdateScreenMeasurementsPending();
    [CompilerGeneratedAttribute]
internal void set_UpdateScreenMeasurementsPending(bool value);
    internal int get_LastInRangeTime();
    internal int get_QueuedInRangeCount();
    internal void DecrementQueuedInRangeCount();
    [CompilerGeneratedAttribute]
internal UInt32 get_WispContextKey();
    [CompilerGeneratedAttribute]
private void set_WispContextKey(UInt32 value);
}
internal class System.Windows.Input.PenContextInfo : ValueType {
    [SecurityCriticalAttribute]
public SecurityCriticalDataClass`1<IPimcContext2> PimcContext;
    [SecurityCriticalAttribute]
public SecurityCriticalDataClass`1<IntPtr> CommHandle;
    public int ContextId;
    public UInt32 WispContextKey;
}
internal class System.Windows.Input.PenContexts : object {
    internal SecurityCriticalData`1<HwndSource> _inputSource;
    internal bool IsWindowDisabled { get; internal set; }
    internal Point DestroyedLocation { get; internal set; }
    internal object SyncRoot { get; }
    [SecurityCriticalAttribute]
internal PenContexts(WispLogic stylusLogic, PresentationSource inputSource);
    [SecurityCriticalAttribute]
internal void Enable();
    [SecurityCriticalAttribute]
internal void Disable(bool shutdownWorkerThread);
    internal bool get_IsWindowDisabled();
    internal void set_IsWindowDisabled(bool value);
    internal Point get_DestroyedLocation();
    internal void set_DestroyedLocation(Point value);
    [SecurityCriticalAttribute]
internal void OnPenDown(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void OnPenUp(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void OnPackets(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void OnInAirPackets(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void OnPenInRange(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    [SecurityCriticalAttribute]
internal void OnPenOutOfRange(PenContext penContext, int tabletDeviceId, int stylusPointerId, int timestamp);
    [SecurityCriticalAttribute]
internal void OnSystemEvent(PenContext penContext, int tabletDeviceId, int stylusPointerId, int timestamp, SystemGesture id, int gestureX, int gestureY, int buttonState);
    [SecurityCriticalAttribute]
internal PenContext GetTabletDeviceIDPenContext(int tabletDeviceId);
    [SecurityCriticalAttribute]
internal bool ConsiderInRange(int timestamp);
    [SecurityCriticalAttribute]
internal void AddContext(UInt32 index);
    [SecurityCriticalAttribute]
internal void RemoveContext(UInt32 index);
    internal object get_SyncRoot();
    internal void AddStylusPlugInCollection(StylusPlugInCollection pic);
    internal void RemoveStylusPlugInCollection(StylusPlugInCollection pic);
    internal int FindZOrderIndex(StylusPlugInCollection spicAdding);
    [SecurityCriticalAttribute]
internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusInputReport inputReport, IInputElement directlyOver, StylusPlugInCollection currentPlugInCollection);
    [SecurityCriticalAttribute]
internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    [SecurityCriticalAttribute]
internal StylusPlugInCollection TargetPlugInCollection(RawStylusInputReport inputReport);
    internal StylusPlugInCollection FindPlugInCollection(UIElement element);
}
internal class System.Windows.Input.PenThread : object {
    internal void Dispose();
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
internal bool AddPenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal bool RemovePenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal TabletDeviceInfo[] WorkerGetTabletsInfo();
    [SecurityCriticalAttribute]
internal PenContextInfo WorkerCreateContext(IntPtr hwnd, IPimcTablet2 pimcTablet);
    [SecurityCriticalAttribute]
internal bool WorkerAcquireTabletLocks(IPimcTablet2 tablet, UInt32 wispTabletKey);
    [SecurityCriticalAttribute]
internal bool WorkerReleaseTabletLocks(IPimcTablet2 tablet, UInt32 wispTabletKey);
    [SecurityCriticalAttribute]
internal StylusDeviceInfo[] WorkerRefreshCursorInfo(IPimcTablet2 pimcTablet);
    [SecurityCriticalAttribute]
internal TabletDeviceInfo WorkerGetTabletInfo(UInt32 index);
    [SecurityCriticalAttribute]
internal TabletDeviceSizeInfo WorkerGetUpdatedSizes(IPimcTablet2 pimcTablet);
}
internal class System.Windows.Input.PenThreadPool : object {
    [SecurityCriticalAttribute]
private static PenThreadPool();
    [SecurityCriticalAttribute]
internal static PenThread GetPenThreadForPenContext(PenContext penContext);
}
internal class System.Windows.Input.PenThreadWorker : object {
    [SecurityCriticalAttribute]
internal void Dispose();
    [SecurityCriticalAttribute]
internal bool WorkerAddPenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal bool WorkerRemovePenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal TabletDeviceInfo[] WorkerGetTabletsInfo();
    [SecurityCriticalAttribute]
internal PenContextInfo WorkerCreateContext(IntPtr hwnd, IPimcTablet2 pimcTablet);
    [SecurityCriticalAttribute]
internal bool WorkerAcquireTabletLocks(IPimcTablet2 tablet, UInt32 wispTabletKey);
    [SecurityCriticalAttribute]
internal bool WorkerReleaseTabletLocks(IPimcTablet2 tablet, UInt32 wispTabletKey);
    [SecurityCriticalAttribute]
internal StylusDeviceInfo[] WorkerRefreshCursorInfo(IPimcTablet2 pimcTablet);
    [SecurityCriticalAttribute]
internal TabletDeviceInfo WorkerGetTabletInfo(UInt32 index);
    [SecurityCriticalAttribute]
internal TabletDeviceSizeInfo WorkerGetUpdatedSizes(IPimcTablet2 pimcTablet);
    [SecurityCriticalAttribute]
internal void FireEvent(PenContext penContext, int evt, int stylusPointerId, int cPackets, int cbPacket, IntPtr pPackets);
    [SecurityCriticalAttribute]
internal bool AddPenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal bool RemovePenContext(PenContext penContext);
    [SecurityCriticalAttribute]
internal void ThreadProc();
}
public class System.Windows.Input.PreProcessInputEventArgs : ProcessInputEventArgs {
    public bool Canceled { get; }
    [SecurityCriticalAttribute]
internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    public void Cancel();
    public bool get_Canceled();
}
public class System.Windows.Input.PreProcessInputEventHandler : MulticastDelegate {
    public PreProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PreProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PreProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.ProcessInputEventArgs : NotifyInputEventArgs {
    [SecurityCriticalAttribute]
internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    [SecurityCriticalAttribute]
public StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    [SecurityCriticalAttribute]
public StagingAreaInputItem PushInput(StagingAreaInputItem input);
    [SecurityCriticalAttribute]
public StagingAreaInputItem PopInput();
    [SecurityCriticalAttribute]
public StagingAreaInputItem PeekInput();
}
public class System.Windows.Input.ProcessInputEventHandler : MulticastDelegate {
    public ProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.QueryCursorEventArgs : MouseEventArgs {
    public Cursor Cursor { get; public set; }
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp);
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.QueryCursorEventHandler : MulticastDelegate {
    public QueryCursorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryCursorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryCursorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.RawAppCommandInputReport : InputReport {
    internal int AppCommand { get; }
    internal InputType Device { get; }
    internal RawAppCommandInputReport(PresentationSource inputSource, InputMode mode, int timestamp, int appCommand, InputType device, InputType inputType);
    internal int get_AppCommand();
    internal InputType get_Device();
}
[FlagsAttribute]
internal enum System.Windows.Input.RawKeyboardActions : Enum {
    public int value__;
    public static RawKeyboardActions None;
    public static RawKeyboardActions AttributesChanged;
    public static RawKeyboardActions Activate;
    public static RawKeyboardActions Deactivate;
    public static RawKeyboardActions KeyDown;
    public static RawKeyboardActions KeyUp;
}
internal class System.Windows.Input.RawKeyboardInputReport : InputReport {
    public RawKeyboardActions Actions { get; }
    public int ScanCode { get; }
    public bool IsExtendedKey { get; }
    public bool IsSystemKey { get; }
    public int VirtualKey { get; }
    public IntPtr ExtraInformation { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public RawKeyboardInputReport(PresentationSource inputSource, InputMode mode, int timestamp, RawKeyboardActions actions, int scanCode, bool isExtendedKey, bool isSystemKey, int virtualKey, IntPtr extraInformation);
    public RawKeyboardActions get_Actions();
    public int get_ScanCode();
    public bool get_IsExtendedKey();
    public bool get_IsSystemKey();
    public int get_VirtualKey();
    [SecurityCriticalAttribute]
public IntPtr get_ExtraInformation();
    internal static bool IsValidRawKeyboardActions(RawKeyboardActions actions);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawMouseActions : Enum {
    public int value__;
    public static RawMouseActions None;
    public static RawMouseActions AttributesChanged;
    public static RawMouseActions Activate;
    public static RawMouseActions Deactivate;
    public static RawMouseActions RelativeMove;
    public static RawMouseActions AbsoluteMove;
    public static RawMouseActions VirtualDesktopMove;
    public static RawMouseActions Button1Press;
    public static RawMouseActions Button1Release;
    public static RawMouseActions Button2Press;
    public static RawMouseActions Button2Release;
    public static RawMouseActions Button3Press;
    public static RawMouseActions Button3Release;
    public static RawMouseActions Button4Press;
    public static RawMouseActions Button4Release;
    public static RawMouseActions Button5Press;
    public static RawMouseActions Button5Release;
    public static RawMouseActions VerticalWheelRotate;
    public static RawMouseActions HorizontalWheelRotate;
    public static RawMouseActions QueryCursor;
    public static RawMouseActions CancelCapture;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Input.RawMouseInputReport : InputReport {
    internal bool _isSynchronize;
    public RawMouseActions Actions { get; }
    public int X { get; }
    public int Y { get; }
    public int Wheel { get; }
    public IntPtr ExtraInformation { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public RawMouseInputReport(InputMode mode, int timestamp, PresentationSource inputSource, RawMouseActions actions, int x, int y, int wheel, IntPtr extraInformation);
    public RawMouseActions get_Actions();
    public int get_X();
    public int get_Y();
    public int get_Wheel();
    [SecurityCriticalAttribute]
public IntPtr get_ExtraInformation();
    internal static bool IsValidRawMouseActions(RawMouseActions actions);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawStylusActions : Enum {
    public int value__;
    public static RawStylusActions None;
    public static RawStylusActions Activate;
    public static RawStylusActions Deactivate;
    public static RawStylusActions Down;
    public static RawStylusActions Up;
    public static RawStylusActions Move;
    public static RawStylusActions InAirMove;
    public static RawStylusActions InRange;
    public static RawStylusActions OutOfRange;
    public static RawStylusActions SystemGesture;
}
internal static class System.Windows.Input.RawStylusActionsHelper : object {
    private static RawStylusActionsHelper();
    internal static bool IsValid(RawStylusActions action);
}
internal class System.Windows.Input.RawStylusInputReport : InputReport {
    internal RawStylusInput RawStylusInput { get; internal set; }
    internal bool Synchronized { get; internal set; }
    internal RawStylusActions Actions { get; }
    internal int TabletDeviceId { get; }
    internal PenContext PenContext { get; private set; }
    internal StylusPointDescription StylusPointDescription { get; }
    internal int StylusDeviceId { get; }
    internal StylusDevice StylusDevice { get; internal set; }
    internal bool IsQueued { get; internal set; }
    internal Int32[] Data { get; }
    [SecuritySafeCriticalAttribute]
internal RawStylusInputReport(InputMode mode, int timestamp, PresentationSource inputSource, PenContext penContext, RawStylusActions actions, int tabletDeviceId, int stylusDeviceId, Int32[] data);
    [SecuritySafeCriticalAttribute]
internal RawStylusInputReport(InputMode mode, int timestamp, PresentationSource inputSource, RawStylusActions actions, Func`1<StylusPointDescription> stylusPointDescGenerator, int tabletDeviceId, int stylusDeviceId, Int32[] data);
    internal RawStylusInput get_RawStylusInput();
    [SecurityCriticalAttribute]
internal void set_RawStylusInput(RawStylusInput value);
    internal bool get_Synchronized();
    internal void set_Synchronized(bool value);
    internal RawStylusActions get_Actions();
    internal int get_TabletDeviceId();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal PenContext get_PenContext();
    [CompilerGeneratedAttribute]
private void set_PenContext(PenContext value);
    [SecuritySafeCriticalAttribute]
internal StylusPointDescription get_StylusPointDescription();
    internal int get_StylusDeviceId();
    internal StylusDevice get_StylusDevice();
    internal void set_StylusDevice(StylusDevice value);
    internal bool get_IsQueued();
    internal void set_IsQueued(bool value);
    [SecuritySafeCriticalAttribute]
internal Int32[] GetRawPacketData();
    [SecuritySafeCriticalAttribute]
internal Point GetLastTabletPoint();
    [SecurityCriticalAttribute]
internal Int32[] get_Data();
}
internal class System.Windows.Input.RawStylusSystemGestureInputReport : RawStylusInputReport {
    internal static SystemGesture InternalSystemGestureDoubleTap;
    internal SystemGesture SystemGesture { get; }
    internal int GestureX { get; }
    internal int GestureY { get; }
    internal int ButtonState { get; }
    [SecuritySafeCriticalAttribute]
internal RawStylusSystemGestureInputReport(InputMode mode, int timestamp, PresentationSource inputSource, Func`1<StylusPointDescription> stylusPointDescGenerator, int tabletId, int stylusDeviceId, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    [SecuritySafeCriticalAttribute]
internal RawStylusSystemGestureInputReport(InputMode mode, int timestamp, PresentationSource inputSource, PenContext penContext, int tabletId, int stylusDeviceId, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    internal static bool IsValidSystemGesture(SystemGesture systemGesture, bool allowFlick, bool allowDoubleTap);
    internal SystemGesture get_SystemGesture();
    internal int get_GestureX();
    internal int get_GestureY();
    internal int get_ButtonState();
}
internal class System.Windows.Input.RawTextInputReport : InputReport {
    public bool IsDeadCharacter { get; }
    public bool IsSystemCharacter { get; }
    public bool IsControlCharacter { get; }
    public char CharacterCode { get; }
    public RawTextInputReport(PresentationSource inputSource, InputMode mode, int timestamp, bool isDeadCharacter, bool isSystemCharacter, bool isControlCharacter, char characterCode);
    public bool get_IsDeadCharacter();
    public bool get_IsSystemCharacter();
    public bool get_IsControlCharacter();
    public char get_CharacterCode();
}
internal enum System.Windows.Input.RawUIStateActions : Enum {
    public int value__;
    public static RawUIStateActions Set;
    public static RawUIStateActions Clear;
    public static RawUIStateActions Initialize;
}
internal class System.Windows.Input.RawUIStateInputReport : InputReport {
    public RawUIStateActions Action { get; }
    public RawUIStateTargets Targets { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public RawUIStateInputReport(PresentationSource inputSource, InputMode mode, int timestamp, RawUIStateActions action, RawUIStateTargets targets);
    public RawUIStateActions get_Action();
    public RawUIStateTargets get_Targets();
    internal static bool IsValidRawUIStateAction(RawUIStateActions action);
    internal static bool IsValidRawUIStateTargets(RawUIStateTargets targets);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawUIStateTargets : Enum {
    public int value__;
    public static RawUIStateTargets None;
    public static RawUIStateTargets HideFocus;
    public static RawUIStateTargets HideAccelerators;
    public static RawUIStateTargets Active;
}
public enum System.Windows.Input.RestoreFocusMode : Enum {
    public int value__;
    public static RestoreFocusMode Auto;
    public static RestoreFocusMode None;
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedCommand : object {
    public string Name { get; }
    public Type OwnerType { get; }
    internal byte CommandId { get; }
    public InputGestureCollection InputGestures { get; }
    internal InputGestureCollection InputGesturesInternal { get; }
    internal bool IsBlockedByRM { get; internal set; }
    internal bool AreInputGesturesDelayLoaded { get; internal set; }
    public RoutedCommand(string name, Type ownerType);
    public RoutedCommand(string name, Type ownerType, InputGestureCollection inputGestures);
    internal RoutedCommand(string name, Type ownerType, byte commandId);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    [SecurityCriticalAttribute]
public void Execute(object parameter, IInputElement target);
    [SecurityCriticalAttribute]
public bool CanExecute(object parameter, IInputElement target);
    [SecurityCriticalAttribute]
internal bool CriticalCanExecute(object parameter, IInputElement target, bool trusted, Boolean& continueRouting);
    public string get_Name();
    public Type get_OwnerType();
    internal byte get_CommandId();
    public InputGestureCollection get_InputGestures();
    internal InputGestureCollection get_InputGesturesInternal();
    [SecurityCriticalAttribute]
internal bool get_IsBlockedByRM();
    [SecurityCriticalAttribute]
internal void set_IsBlockedByRM(bool value);
    internal bool get_AreInputGesturesDelayLoaded();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_AreInputGesturesDelayLoaded(bool value);
    [SecurityCriticalAttribute]
internal bool ExecuteCore(object parameter, IInputElement target, bool userInitiated);
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedUICommand : RoutedCommand {
    public string Text { get; public set; }
    public RoutedUICommand(string text, string name, Type ownerType);
    public RoutedUICommand(string text, string name, Type ownerType, InputGestureCollection inputGestures);
    internal RoutedUICommand(string name, Type ownerType, byte commandId);
    public string get_Text();
    public void set_Text(string value);
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
internal class System.Windows.Input.SecureUICommand : RoutedUICommand {
    public PermissionSet UserInitiatedPermission { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal SecureUICommand(PermissionSet userInitiated, string name, Type ownerType, byte commandId);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual PermissionSet get_UserInitiatedPermission();
}
public enum System.Windows.Input.SpeechMode : Enum {
    public int value__;
    public static SpeechMode Dictation;
    public static SpeechMode Command;
    public static SpeechMode Indeterminate;
}
public class System.Windows.Input.StagingAreaInputItem : object {
    public InputEventArgs Input { get; }
    internal bool IsMarker { get; }
    internal StagingAreaInputItem(bool isMarker);
    internal void Reset(InputEventArgs input, StagingAreaInputItem promote);
    [SecurityCriticalAttribute]
public InputEventArgs get_Input();
    public object GetData(object key);
    [SecurityCriticalAttribute]
public void SetData(object key, object value);
    internal bool get_IsMarker();
}
public static class System.Windows.Input.Stylus : object {
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static DependencyProperty IsPressAndHoldEnabledProperty;
    public static DependencyProperty IsFlicksEnabledProperty;
    public static DependencyProperty IsTapFeedbackEnabledProperty;
    public static DependencyProperty IsTouchFeedbackEnabledProperty;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    public static StylusDevice CurrentStylusDevice { get; }
    private static Stylus();
    public static void AddPreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemovePreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemoveStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddPreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemovePreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemoveStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsPressAndHoldEnabled(DependencyObject element);
    public static void SetIsPressAndHoldEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsFlicksEnabled(DependencyObject element);
    public static void SetIsFlicksEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTapFeedbackEnabled(DependencyObject element);
    public static void SetIsTapFeedbackEnabled(DependencyObject element, bool enabled);
    public static bool GetIsTouchFeedbackEnabled(DependencyObject element);
    public static void SetIsTouchFeedbackEnabled(DependencyObject element, bool enabled);
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    public static void Synchronize();
    [SecurityCriticalAttribute]
public static StylusDevice get_CurrentStylusDevice();
}
public class System.Windows.Input.StylusButton : object {
    public Guid Guid { get; }
    public StylusButtonState StylusButtonState { get; }
    internal StylusButtonState CachedButtonState { get; internal set; }
    public string Name { get; }
    public StylusDevice StylusDevice { get; }
    internal StylusButton(string name, Guid id);
    public Guid get_Guid();
    public StylusButtonState get_StylusButtonState();
    internal StylusButtonState get_CachedButtonState();
    internal void set_CachedButtonState(StylusButtonState value);
    public string get_Name();
    public StylusDevice get_StylusDevice();
    internal void SetOwner(StylusDeviceBase stylusDevice);
    public virtual string ToString();
}
public class System.Windows.Input.StylusButtonCollection : ReadOnlyCollection`1<StylusButton> {
    internal StylusButtonCollection(StylusButton[] buttons);
    internal StylusButtonCollection(List`1<StylusButton> buttons);
    public StylusButton GetStylusButtonByGuid(Guid guid);
}
public class System.Windows.Input.StylusButtonEventArgs : StylusEventArgs {
    public StylusButton StylusButton { get; }
    public StylusButtonEventArgs(StylusDevice stylusDevice, int timestamp, StylusButton button);
    public StylusButton get_StylusButton();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusButtonEventHandler : MulticastDelegate {
    public StylusButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.StylusButtonState : Enum {
    public int value__;
    public static StylusButtonState Up;
    public static StylusButtonState Down;
}
public class System.Windows.Input.StylusDevice : InputDevice {
    internal StylusDeviceBase StylusDeviceImpl { get; internal set; }
    public IInputElement Target { get; }
    public bool IsValid { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public TabletDevice TabletDevice { get; }
    public string Name { get; }
    public int Id { get; }
    public StylusButtonCollection StylusButtons { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    public bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal StylusDevice(StylusDeviceBase impl);
    [CompilerGeneratedAttribute]
internal StylusDeviceBase get_StylusDeviceImpl();
    [CompilerGeneratedAttribute]
internal void set_StylusDeviceImpl(StylusDeviceBase value);
    public virtual IInputElement get_Target();
    public bool get_IsValid();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public IInputElement get_DirectlyOver();
    public IInputElement get_Captured();
    public bool Capture(IInputElement element, CaptureMode captureMode);
    public bool Capture(IInputElement element);
    [SecurityCriticalAttribute]
public void Synchronize();
    public TabletDevice get_TabletDevice();
    public string get_Name();
    public virtual string ToString();
    public int get_Id();
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    public StylusButtonCollection get_StylusButtons();
    [SecurityCriticalAttribute]
public Point GetPosition(IInputElement relativeTo);
    public bool get_InAir();
    public bool get_Inverted();
    public bool get_InRange();
    internal int get_DoubleTapDeltaX();
    internal int get_DoubleTapDeltaY();
    [SecuritySafeCriticalAttribute]
internal int get_DoubleTapDeltaTime();
    internal Point GetMouseScreenPosition(MouseDevice mouseDevice);
    [SecuritySafeCriticalAttribute]
internal MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal static IInputElement LocalHitTest(PresentationSource inputSource, Point pt);
    internal static IInputElement GlobalHitTest(PresentationSource inputSource, Point pt);
    internal static GeneralTransform GetElementTransform(IInputElement relativeTo);
    internal T As();
}
internal abstract class System.Windows.Input.StylusDeviceBase : DispatcherObject {
    protected bool _disposed;
    internal StylusDevice StylusDevice { get; private set; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool IsValid { get; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    internal TabletDevice TabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int TapCount { get; internal set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    [CompilerGeneratedAttribute]
internal StylusDevice get_StylusDevice();
    [CompilerGeneratedAttribute]
private void set_StylusDevice(StylusDevice value);
    internal T As();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal abstract virtual IInputElement get_Target();
    internal abstract virtual PresentationSource get_ActiveSource();
    internal abstract virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    internal abstract virtual PresentationSource get_CriticalActiveSource();
    internal abstract virtual StylusPoint get_RawStylusPoint();
    internal abstract virtual bool get_IsValid();
    internal abstract virtual IInputElement get_DirectlyOver();
    internal abstract virtual IInputElement get_Captured();
    internal abstract virtual CaptureMode get_CapturedMode();
    internal abstract virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal abstract virtual bool Capture(IInputElement element);
    internal abstract virtual void Synchronize();
    internal abstract virtual TabletDevice get_TabletDevice();
    internal abstract virtual string get_Name();
    internal abstract virtual int get_Id();
    internal abstract virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal abstract virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    internal abstract virtual StylusButtonCollection get_StylusButtons();
    internal abstract virtual Point GetPosition(IInputElement relativeTo);
    internal abstract virtual bool get_InAir();
    internal abstract virtual bool get_Inverted();
    internal abstract virtual bool get_InRange();
    internal abstract virtual int get_DoubleTapDeltaX();
    internal abstract virtual int get_DoubleTapDeltaY();
    internal abstract virtual int get_DoubleTapDeltaTime();
    internal abstract virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    internal abstract virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal abstract virtual int get_TapCount();
    internal abstract virtual void set_TapCount(int value);
    internal abstract virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    internal abstract virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    internal abstract virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
}
public class System.Windows.Input.StylusDeviceCollection : ReadOnlyCollection`1<StylusDevice> {
    internal StylusDeviceCollection(IEnumerable`1<StylusDeviceBase> styluses);
    [SecurityCriticalAttribute]
internal void Dispose();
    internal void AddStylusDevice(int index, StylusDeviceBase stylusDevice);
}
internal class System.Windows.Input.StylusDeviceInfo : ValueType {
    public string CursorName;
    public int CursorId;
    public bool CursorInverted;
    public StylusButtonCollection ButtonCollection;
}
public class System.Windows.Input.StylusDownEventArgs : StylusEventArgs {
    public int TapCount { get; }
    public StylusDownEventArgs(StylusDevice stylusDevice, int timestamp);
    public int get_TapCount();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusDownEventHandler : MulticastDelegate {
    public StylusDownEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusDownEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusDownEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusEventArgs : InputEventArgs {
    public StylusDevice StylusDevice { get; }
    internal StylusDeviceBase StylusDeviceImpl { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    internal RawStylusInputReport InputReport { get; internal set; }
    public StylusEventArgs(StylusDevice stylus, int timestamp);
    public StylusDevice get_StylusDevice();
    internal StylusDeviceBase get_StylusDeviceImpl();
    public Point GetPosition(IInputElement relativeTo);
    public bool get_InAir();
    public bool get_Inverted();
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal RawStylusInputReport get_InputReport();
    internal void set_InputReport(RawStylusInputReport value);
}
public class System.Windows.Input.StylusEventHandler : MulticastDelegate {
    public StylusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Input.StylusLogic : DispatcherObject {
    protected int _stylusDoubleTapDeltaTime;
    protected int _stylusDoubleTapDelta;
    protected int _cancelDelta;
    protected int _touchDoubleTapDeltaTime;
    protected int _touchDoubleTapDelta;
    protected static double DoubleTapMinFactor;
    protected static double DoubleTapMaxFactor;
    internal static bool IsStylusAndTouchSupportEnabled { get; }
    internal static bool IsPointerStackEnabled { get; }
    internal static StylusLogic CurrentStylusLogic { get; }
    internal int StylusDoubleTapDelta { get; }
    internal int TouchDoubleTapDelta { get; }
    internal int StylusDoubleTapDeltaTime { get; }
    internal int TouchDoubleTapDeltaTime { get; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    protected StylusLogicShutDownListener ShutdownListener { get; protected set; }
    public StylusStatistics Statistics { get; protected set; }
    private static StylusLogic();
    internal static bool get_IsStylusAndTouchSupportEnabled();
    [SecurityCriticalAttribute]
internal static bool get_IsPointerStackEnabled();
    [SecurityCriticalAttribute]
internal static StylusLogic get_CurrentStylusLogic();
    [SecurityCriticalAttribute]
internal static T GetCurrentStylusLogicAs();
    internal int get_StylusDoubleTapDelta();
    internal int get_TouchDoubleTapDelta();
    internal int get_StylusDoubleTapDeltaTime();
    internal int get_TouchDoubleTapDeltaTime();
    [SecurityCriticalAttribute]
protected void ReadSystemConfig();
    internal abstract virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    internal abstract virtual StylusDeviceBase get_CurrentStylusDevice();
    internal abstract virtual TabletDeviceCollection get_TabletDevices();
    internal abstract virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    internal abstract virtual Point MeasureUnitsFromDeviceUnits(Point measurePoint);
    internal abstract virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal abstract virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal abstract virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    protected abstract virtual void OnTabletRemoved(UInt32 wisptisIndex);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal abstract virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    [CompilerGeneratedAttribute]
protected StylusLogicShutDownListener get_ShutdownListener();
    [CompilerGeneratedAttribute]
protected void set_ShutdownListener(StylusLogicShutDownListener value);
    [CompilerGeneratedAttribute]
public StylusStatistics get_Statistics();
    [CompilerGeneratedAttribute]
protected void set_Statistics(StylusStatistics value);
    [SecurityCriticalAttribute]
internal static bool IsPromotedMouseEvent(RawMouseInputReport mouseInputReport);
    [SecurityCriticalAttribute]
internal static UInt32 GetCursorIdFromMouseEvent(RawMouseInputReport mouseInputReport);
    [SecuritySafeCriticalAttribute]
internal static void CurrentStylusLogicReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    [SecuritySafeCriticalAttribute]
internal static void CurrentStylusLogicReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal static RoutedEvent GetMainEventFromPreviewEvent(RoutedEvent routedEvent);
    internal static RoutedEvent GetPreviewEventFromRawStylusActions(RawStylusActions actions);
    protected bool ValidateUIElementForCapture(UIElement element);
    protected bool ValidateContentElementForCapture(ContentElement element);
    protected bool ValidateUIElement3DForCapture(UIElement3D element);
    [SecuritySafeCriticalAttribute]
protected bool ValidateVisualForCapture(DependencyObject visual, StylusDeviceBase currentStylusDevice);
    internal static FlickAction GetFlickAction(int flickData);
    protected static bool GetIsScrollUp(int flickData);
    internal bool HandleFlick(int flickData, IInputElement element);
}
internal class System.Windows.Input.StylusPlugIns.DispatcherShutdownStartedEventManager : WeakEventManager {
    [SecurityCriticalAttribute]
public static void AddListener(Dispatcher source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.Windows.Input.StylusPlugIns.DynamicRenderer : StylusPlugIn {
    public Visual RootVisual { get; }
    public DrawingAttributes DrawingAttributes { get; public set; }
    public virtual void Reset(StylusDevice stylusDevice, StylusPointCollection stylusPoints);
    public Visual get_RootVisual();
    protected virtual void OnAdded();
    protected virtual void OnRemoved();
    protected virtual void OnIsActiveForInputChanged();
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnEnabledChanged();
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    protected virtual void OnDraw(DrawingContext drawingContext, StylusPointCollection stylusPoints, Geometry geometry, Brush fillBrush);
    protected virtual void OnDrawingAttributesReplaced();
    protected Dispatcher GetDispatcher();
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
}
internal class System.Windows.Input.StylusPlugIns.DynamicRendererThreadManager : object {
    internal Dispatcher ThreadDispatcher { get; }
    internal static DynamicRendererThreadManager GetCurrentThreadInstance();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
    internal Dispatcher get_ThreadDispatcher();
}
public class System.Windows.Input.StylusPlugIns.RawStylusInput : object {
    public int StylusDeviceId { get; }
    public int TabletDeviceId { get; }
    public int Timestamp { get; }
    internal bool StylusPointsModified { get; }
    internal StylusPlugInCollection Target { get; }
    internal RawStylusInputReport Report { get; }
    internal GeneralTransform ElementTransform { get; }
    internal RawStylusInputCustomDataList CustomDataList { get; }
    internal StylusPlugIn CurrentNotifyPlugIn { get; internal set; }
    internal RawStylusInput(RawStylusInputReport report, GeneralTransform tabletToElementTransform, StylusPlugInCollection targetPlugInCollection);
    public int get_StylusDeviceId();
    public int get_TabletDeviceId();
    public int get_Timestamp();
    public StylusPointCollection GetStylusPoints();
    [SecuritySafeCriticalAttribute]
internal StylusPointCollection GetStylusPoints(GeneralTransform transform);
    [SecuritySafeCriticalAttribute]
public void SetStylusPoints(StylusPointCollection stylusPoints);
    public void NotifyWhenProcessed(object callbackData);
    internal bool get_StylusPointsModified();
    internal StylusPlugInCollection get_Target();
    internal RawStylusInputReport get_Report();
    internal GeneralTransform get_ElementTransform();
    internal RawStylusInputCustomDataList get_CustomDataList();
    internal StylusPlugIn get_CurrentNotifyPlugIn();
    internal void set_CurrentNotifyPlugIn(StylusPlugIn value);
}
internal class System.Windows.Input.StylusPlugIns.RawStylusInputCustomData : object {
    public object Data { get; }
    public StylusPlugIn Owner { get; }
    public RawStylusInputCustomData(StylusPlugIn owner, object data);
    public object get_Data();
    public StylusPlugIn get_Owner();
}
internal class System.Windows.Input.StylusPlugIns.RawStylusInputCustomDataList : Collection`1<RawStylusInputCustomData> {
}
public abstract class System.Windows.Input.StylusPlugIns.StylusPlugIn : object {
    public UIElement Element { get; }
    public Rect ElementBounds { get; }
    public bool Enabled { get; public set; }
    public bool IsActiveForInput { get; }
    internal void Added(StylusPlugInCollection plugInCollection);
    protected virtual void OnAdded();
    internal void Removed();
    protected virtual void OnRemoved();
    internal void StylusEnterLeave(bool isEnter, RawStylusInput rawStylusInput, bool confirmed);
    internal void RawStylusInput(RawStylusInput rawStylusInput);
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    internal void FireCustomData(object callbackData, RawStylusActions action, bool targetVerified);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusMoveProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    public UIElement get_Element();
    public Rect get_ElementBounds();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual void OnEnabledChanged();
    internal void InvalidateIsActiveForInput();
    public bool get_IsActiveForInput();
    protected virtual void OnIsActiveForInputChanged();
}
public class System.Windows.Input.StylusPlugIns.StylusPlugInCollection : Collection`1<StylusPlugIn> {
    internal UIElement Element { get; }
    internal GeneralTransform ViewToElement { get; }
    internal Rect Rect { get; }
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal StylusPlugInCollection(UIElement element);
    protected virtual void InsertItem(int index, StylusPlugIn plugIn);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, StylusPlugIn plugIn);
    internal UIElement get_Element();
    internal void UpdateRect();
    internal bool IsHit(Point pt);
    internal GeneralTransform get_ViewToElement();
    internal Rect get_Rect();
    internal void FireEnterLeave(bool isEnter, RawStylusInput rawStylusInput, bool confirmed);
    internal void FireRawStylusInput(RawStylusInput args);
    internal bool get_IsActiveForInput();
    internal object get_SyncRoot();
    internal void OnLayoutUpdated(object sender, EventArgs e);
    internal void ExecuteWithPotentialLock(Action action);
    internal void ExecuteWithPotentialDispatcherDisable(Action action);
}
internal abstract class System.Windows.Input.StylusPlugIns.StylusPlugInCollectionBase : object {
    internal StylusPlugInCollection Wrapper { get; private set; }
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    [SecuritySafeCriticalAttribute]
internal static StylusPlugInCollectionBase Create(StylusPlugInCollection wrapper);
    [CompilerGeneratedAttribute]
internal StylusPlugInCollection get_Wrapper();
    [CompilerGeneratedAttribute]
private void set_Wrapper(StylusPlugInCollection value);
    internal abstract virtual bool get_IsActiveForInput();
    internal abstract virtual object get_SyncRoot();
    internal abstract virtual void UpdateState(UIElement element);
    internal abstract virtual void Unhook();
}
public class System.Windows.Input.StylusPoint : ValueType {
    internal static float DefaultPressure;
    private double _x;
    private double _y;
    private float _pressureFactor;
    private Int32[] _additionalValues;
    private StylusPointDescription _stylusPointDescription;
    public static double MaxXY;
    public static double MinXY;
    public double X { get; public set; }
    public double Y { get; public set; }
    public float PressureFactor { get; public set; }
    public StylusPointDescription Description { get; internal set; }
    internal bool HasDefaultPressure { get; }
    public StylusPoint(double x, double y);
    public StylusPoint(double x, double y, float pressureFactor);
    public StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues);
    internal StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues, bool validateAdditionalData, bool validatePressureFactor);
    private static StylusPoint();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public float get_PressureFactor();
    public void set_PressureFactor(float value);
    public StylusPointDescription get_Description();
    internal void set_Description(StylusPointDescription value);
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public int GetPropertyValue(StylusPointProperty stylusPointProperty);
    public void SetPropertyValue(StylusPointProperty stylusPointProperty, int value);
    internal void SetPropertyValue(StylusPointProperty stylusPointProperty, int value, bool copyBeforeWrite);
    public static Point op_Explicit(StylusPoint stylusPoint);
    public Point ToPoint();
    public static bool op_Equality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static bool op_Inequality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static bool Equals(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(StylusPoint value);
    public virtual int GetHashCode();
    internal Int32[] GetAdditionalData();
    internal float GetUntruncatedPressureFactor();
    internal Int32[] GetPacketData();
    internal bool get_HasDefaultPressure();
}
public class System.Windows.Input.StylusPointCollection : Collection`1<StylusPoint> {
    public StylusPointDescription Description { get; }
    public StylusPointCollection(int initialCapacity);
    public StylusPointCollection(StylusPointDescription stylusPointDescription);
    public StylusPointCollection(StylusPointDescription stylusPointDescription, int initialCapacity);
    public StylusPointCollection(IEnumerable`1<StylusPoint> stylusPoints);
    public StylusPointCollection(IEnumerable`1<Point> points);
    internal StylusPointCollection(StylusPointDescription stylusPointDescription, Int32[] rawPacketData, GeneralTransform tabletToView, Matrix tabletToViewMatrix);
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_CountGoingToZero(CancelEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CountGoingToZero(CancelEventHandler value);
    public void Add(StylusPointCollection stylusPoints);
    public StylusPointDescription get_Description();
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, StylusPoint stylusPoint);
    protected sealed virtual void SetItem(int index, StylusPoint stylusPoint);
    public StylusPointCollection Clone();
    public static Point[] op_Explicit(StylusPointCollection stylusPoints);
    internal StylusPointCollection Clone(int count);
    internal StylusPointCollection Clone(GeneralTransform transform, StylusPointDescription descriptionToUse);
    protected virtual void OnChanged(EventArgs e);
    internal void Transform(GeneralTransform transform);
    public StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo);
    internal StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo, GeneralTransform transform);
    public Int32[] ToHiMetricArray();
    internal void ToISFReadyArrays(Int32[][]& output, Boolean& shouldPersistPressure);
}
public class System.Windows.Input.StylusPointDescription : object {
    internal static int RequiredCountOfProperties;
    internal static int RequiredXIndex;
    internal static int RequiredYIndex;
    internal static int RequiredPressureIndex;
    internal static int MaximumButtonCount;
    public int PropertyCount { get; }
    internal int ButtonCount { get; }
    internal bool ContainsTruePressure { get; }
    internal int OriginalPressureIndex { get; }
    public StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos);
    internal StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos, int originalPressureIndex);
    private static StylusPointDescription();
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public int get_PropertyCount();
    public StylusPointPropertyInfo GetPropertyInfo(StylusPointProperty stylusPointProperty);
    internal StylusPointPropertyInfo GetPropertyInfo(Guid guid);
    internal int GetPropertyIndex(Guid guid);
    public ReadOnlyCollection`1<StylusPointPropertyInfo> GetStylusPointProperties();
    internal Guid[] GetStylusPointPropertyIds();
    internal int GetInputArrayLengthPerPoint();
    internal int GetExpectedAdditionalDataCount();
    internal int GetOutputArrayLengthPerPoint();
    internal int get_ButtonCount();
    internal int GetButtonBitPosition(StylusPointProperty buttonProperty);
    internal bool get_ContainsTruePressure();
    internal int get_OriginalPressureIndex();
    public static bool AreCompatible(StylusPointDescription stylusPointDescription1, StylusPointDescription stylusPointDescription2);
    public static StylusPointDescription GetCommonDescription(StylusPointDescription stylusPointDescription, StylusPointDescription stylusPointDescriptionPreserveInfo);
    public bool IsSubsetOf(StylusPointDescription stylusPointDescriptionSuperset);
}
internal class System.Windows.Input.StylusPointer.PointerData : object {
    internal bool IsValid { get; private set; }
    internal POINTER_INFO Info { get; }
    internal POINTER_TOUCH_INFO TouchInfo { get; }
    internal POINTER_PEN_INFO PenInfo { get; }
    internal POINTER_INFO[] History { get; }
    [SecuritySafeCriticalAttribute]
internal PointerData(UInt32 pointerId);
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    internal POINTER_INFO get_Info();
    internal POINTER_TOUCH_INFO get_TouchInfo();
    internal POINTER_PEN_INFO get_PenInfo();
    internal POINTER_INFO[] get_History();
}
internal class System.Windows.Input.StylusPointer.PointerFlickEngine : object {
    internal FlickResult Result { get; private set; }
    internal PointerFlickEngine(PointerStylusDevice stylusDevice);
    [CompilerGeneratedAttribute]
internal FlickResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(FlickResult value);
    internal void Reset();
    internal void ResetResult();
    internal void Update(RawStylusInputReport rsir, bool initial);
}
internal class System.Windows.Input.StylusPointer.PointerInteractionEngine : object {
    [SecurityCriticalAttribute]
internal PointerInteractionEngine(PointerStylusDevice stylusDevice, List`1<INTERACTION_CONTEXT_CONFIGURATION> configuration);
    private static PointerInteractionEngine();
    [CompilerGeneratedAttribute]
internal void add_InteractionDetected(EventHandler`1<RawStylusSystemGestureInputReport> value);
    [CompilerGeneratedAttribute]
internal void remove_InteractionDetected(EventHandler`1<RawStylusSystemGestureInputReport> value);
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
protected virtual override void Finalize();
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
internal void Update(RawStylusInputReport rsir);
}
internal class System.Windows.Input.StylusPointer.PointerLogic : StylusLogic {
    internal Dictionary`2<PresentationSource, PointerStylusPlugInManager> PlugInManagers { get; private set; }
    internal bool InDragDrop { get; }
    internal static bool IsEnabled { get; private set; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    [SecuritySafeCriticalAttribute]
internal PointerLogic(InputManager inputManager);
    private static PointerLogic();
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
internal Dictionary`2<PresentationSource, PointerStylusPlugInManager> get_PlugInManagers();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
private void set_PlugInManagers(Dictionary`2<PresentationSource, PointerStylusPlugInManager> value);
    internal bool get_InDragDrop();
    [CompilerGeneratedAttribute]
internal static bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private static void set_IsEnabled(bool value);
    internal virtual StylusDeviceBase get_CurrentStylusDevice();
    internal virtual TabletDeviceCollection get_TabletDevices();
    [SecuritySafeCriticalAttribute]
internal virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    [SecuritySafeCriticalAttribute]
internal virtual Point MeasureUnitsFromDeviceUnits(Point devicePoint);
    internal virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    internal virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    protected virtual void OnTabletRemoved(UInt32 wisptisIndex);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    internal void SelectStylusDevice(PointerStylusDevice pointerStylusDevice, IInputElement newOver, bool updateOver);
    [SecurityCriticalAttribute]
internal PointerStylusPlugInManager GetManagerForSource(PresentationSource source);
}
internal class System.Windows.Input.StylusPointer.PointerStylusDevice : StylusDeviceBase {
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal POINTER_INFO CurrentPointerInfo { get; }
    internal HwndPointerInputProvider CurrentPointerProvider { get; private set; }
    internal UInt32 CursorId { get; }
    internal bool IsNew { get; }
    internal bool IsInContact { get; }
    internal bool IsPrimary { get; }
    internal bool IsFirstButton { get; }
    internal bool IsSecondButton { get; }
    internal bool IsThirdButton { get; }
    internal bool IsFourthButton { get; }
    internal bool IsFifthButton { get; }
    internal UInt32 TimeStamp { get; }
    internal bool IsDown { get; }
    internal bool IsUpdate { get; }
    internal bool IsUp { get; }
    internal bool HasCaptureChanged { get; }
    internal bool HasTransform { get; }
    internal PointerTouchDevice TouchDevice { get; private set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    internal PresentationSource CriticalActiveSource { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool IsValid { get; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal TabletDevice TabletDevice { get; }
    internal PointerTabletDevice PointerTabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int TapCount { get; internal set; }
    internal CaptureMode CapturedMode { get; }
    [SecurityCriticalAttribute]
internal PointerStylusDevice(PointerTabletDevice tabletDevice, POINTER_DEVICE_CURSOR_INFO cursorInfo);
    protected virtual void Dispose(bool disposing);
    internal virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_ActiveSource();
    internal POINTER_INFO get_CurrentPointerInfo();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal HwndPointerInputProvider get_CurrentPointerProvider();
    [CompilerGeneratedAttribute]
private void set_CurrentPointerProvider(HwndPointerInputProvider value);
    internal UInt32 get_CursorId();
    internal bool get_IsNew();
    internal bool get_IsInContact();
    internal bool get_IsPrimary();
    internal bool get_IsFirstButton();
    internal bool get_IsSecondButton();
    internal bool get_IsThirdButton();
    internal bool get_IsFourthButton();
    internal bool get_IsFifthButton();
    internal UInt32 get_TimeStamp();
    internal bool get_IsDown();
    internal bool get_IsUpdate();
    internal bool get_IsUp();
    internal bool get_HasCaptureChanged();
    internal bool get_HasTransform();
    [CompilerGeneratedAttribute]
internal PointerTouchDevice get_TouchDevice();
    [CompilerGeneratedAttribute]
private void set_TouchDevice(PointerTouchDevice value);
    [CompilerGeneratedAttribute]
internal virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    [CompilerGeneratedAttribute]
internal virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_CriticalActiveSource();
    internal virtual StylusButtonCollection get_StylusButtons();
    internal virtual StylusPoint get_RawStylusPoint();
    internal virtual bool get_IsValid();
    internal virtual IInputElement get_DirectlyOver();
    internal virtual IInputElement get_Captured();
    internal virtual TabletDevice get_TabletDevice();
    internal PointerTabletDevice get_PointerTabletDevice();
    internal virtual string get_Name();
    internal virtual int get_Id();
    internal virtual bool get_InAir();
    internal virtual bool get_Inverted();
    internal virtual bool get_InRange();
    internal virtual int get_DoubleTapDeltaX();
    internal virtual int get_DoubleTapDeltaY();
    [SecurityTreatAsSafeAttribute]
internal virtual int get_DoubleTapDeltaTime();
    internal virtual int get_TapCount();
    internal virtual void set_TapCount(int value);
    internal virtual CaptureMode get_CapturedMode();
    internal virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal virtual bool Capture(IInputElement element);
    [SecurityCriticalAttribute]
internal virtual void Synchronize();
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    [SecuritySafeCriticalAttribute]
internal virtual Point GetPosition(IInputElement relativeTo);
    internal virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    [SecuritySafeCriticalAttribute]
internal virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    [SecurityCriticalAttribute]
internal void Update(HwndPointerInputProvider provider, PresentationSource inputSource, PointerData pointerData, RawStylusInputReport rsir);
    [SecurityCriticalAttribute]
internal void UpdateInteractions(RawStylusInputReport rsir);
    internal virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    [SecurityCriticalAttribute]
internal IInputElement FindTarget(PresentationSource inputSource, Point position);
    [SecuritySafeCriticalAttribute]
internal void ChangeStylusOver(IInputElement stylusOver);
    [SecuritySafeCriticalAttribute]
internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captureMode, int timestamp);
    [SecurityCriticalAttribute]
internal virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    [SecuritySafeCriticalAttribute]
internal GeneralTransform GetTabletToElementTransform(IInputElement relativeTo);
}
internal class System.Windows.Input.StylusPointer.PointerStylusPlugInCollection : StylusPlugInCollectionBase {
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsActiveForInput();
    internal virtual object get_SyncRoot();
    [SecuritySafeCriticalAttribute]
internal virtual void UpdateState(UIElement element);
    [SecuritySafeCriticalAttribute]
internal virtual void Unhook();
}
internal class System.Windows.Input.StylusPointer.PointerStylusPlugInManager : object {
    internal SecurityCriticalData`1<PresentationSource> _inputSource;
    internal PointerStylusPlugInManager(PresentationSource source);
    internal void AddStylusPlugInCollection(StylusPlugInCollection pic);
    internal void RemoveStylusPlugInCollection(StylusPlugInCollection pic);
    internal int FindZOrderIndex(StylusPlugInCollection spicAdding);
    [SecurityCriticalAttribute]
internal StylusPlugInCollection TargetPlugInCollection(RawStylusInputReport inputReport);
    internal StylusPlugInCollection FindPlugInCollection(UIElement element);
    [SecurityCriticalAttribute]
internal void VerifyStylusPlugInCollectionTarget(RawStylusInputReport rawStylusInputReport);
    [SecurityCriticalAttribute]
internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusInputReport inputReport, IInputElement directlyOver, StylusPlugInCollection currentPlugInCollection);
    [SecurityCriticalAttribute]
internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    [SecurityCriticalAttribute]
internal static void InvokePlugInsForMouse(ProcessInputEventArgs e);
}
internal class System.Windows.Input.StylusPointer.PointerStylusPointPropertyInfoHelper : object {
    private static PointerStylusPointPropertyInfoHelper();
    internal static StylusPointPropertyInfo CreatePropertyInfo(POINTER_DEVICE_PROPERTY prop);
}
internal class System.Windows.Input.StylusPointer.PointerTabletDevice : TabletDeviceBase {
    internal PointerTabletDeviceInfo DeviceInfo { get; }
    internal IntPtr Device { get; }
    internal int DoubleTapDelta { get; }
    internal int DoubleTapDeltaTime { get; }
    internal Size DoubleTapSize { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    [SecurityCriticalAttribute]
internal PointerTabletDevice(PointerTabletDeviceInfo deviceInfo);
    internal PointerTabletDeviceInfo get_DeviceInfo();
    internal IntPtr get_Device();
    [SecuritySafeCriticalAttribute]
internal int get_DoubleTapDelta();
    [SecuritySafeCriticalAttribute]
internal int get_DoubleTapDeltaTime();
    [SecuritySafeCriticalAttribute]
internal void UpdateSizeDeltas();
    internal virtual Size get_DoubleTapSize();
    internal virtual StylusDeviceCollection get_StylusDevices();
    internal virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_ActiveSource();
    internal PointerStylusDevice GetStylusByCursorId(UInt32 cursorId);
}
internal class System.Windows.Input.StylusPointer.PointerTabletDeviceCollection : TabletDeviceCollection {
    internal bool IsValid { get; private set; }
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    internal PointerTabletDevice GetByDeviceId(IntPtr deviceId);
    internal PointerStylusDevice GetStylusDeviceByCursorId(UInt32 cursorId);
    [SecuritySafeCriticalAttribute]
internal void Refresh();
}
internal class System.Windows.Input.StylusPointer.PointerTabletDeviceInfo : TabletDeviceInfo {
    internal POINTER_DEVICE_PROPERTY[] SupportedPointerProperties { get; private set; }
    internal int SupportedButtonPropertyIndex { get; private set; }
    internal StylusButtonCollection StylusButtons { get; private set; }
    internal IntPtr Device { get; }
    internal bool UsingFakePressure { get; private set; }
    internal RECT DeviceRect { get; private set; }
    internal RECT DisplayRect { get; private set; }
    internal PointerTabletDeviceInfo(int id, POINTER_DEVICE_INFO deviceInfo);
    [CompilerGeneratedAttribute]
internal POINTER_DEVICE_PROPERTY[] get_SupportedPointerProperties();
    [CompilerGeneratedAttribute]
private void set_SupportedPointerProperties(POINTER_DEVICE_PROPERTY[] value);
    [CompilerGeneratedAttribute]
internal int get_SupportedButtonPropertyIndex();
    [CompilerGeneratedAttribute]
private void set_SupportedButtonPropertyIndex(int value);
    [CompilerGeneratedAttribute]
internal StylusButtonCollection get_StylusButtons();
    [CompilerGeneratedAttribute]
private void set_StylusButtons(StylusButtonCollection value);
    internal IntPtr get_Device();
    [CompilerGeneratedAttribute]
internal bool get_UsingFakePressure();
    [CompilerGeneratedAttribute]
private void set_UsingFakePressure(bool value);
    [CompilerGeneratedAttribute]
internal RECT get_DeviceRect();
    [CompilerGeneratedAttribute]
private void set_DeviceRect(RECT value);
    [CompilerGeneratedAttribute]
internal RECT get_DisplayRect();
    [CompilerGeneratedAttribute]
private void set_DisplayRect(RECT value);
    internal bool TryInitialize();
}
internal class System.Windows.Input.StylusPointer.PointerTouchDevice : StylusTouchDeviceBase {
    internal PointerTouchDevice(PointerStylusDevice stylusDevice);
    [SecurityCriticalAttribute]
protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    [SecuritySafeCriticalAttribute]
protected virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    protected virtual void OnActivateImpl();
    protected virtual void OnDeactivateImpl();
}
public static class System.Windows.Input.StylusPointProperties : object {
    public static StylusPointProperty X;
    public static StylusPointProperty Y;
    public static StylusPointProperty Z;
    public static StylusPointProperty Width;
    public static StylusPointProperty Height;
    public static StylusPointProperty SystemTouch;
    public static StylusPointProperty PacketStatus;
    public static StylusPointProperty SerialNumber;
    public static StylusPointProperty NormalPressure;
    public static StylusPointProperty TangentPressure;
    public static StylusPointProperty ButtonPressure;
    public static StylusPointProperty XTiltOrientation;
    public static StylusPointProperty YTiltOrientation;
    public static StylusPointProperty AzimuthOrientation;
    public static StylusPointProperty AltitudeOrientation;
    public static StylusPointProperty TwistOrientation;
    public static StylusPointProperty PitchRotation;
    public static StylusPointProperty RollRotation;
    public static StylusPointProperty YawRotation;
    public static StylusPointProperty TipButton;
    public static StylusPointProperty BarrelButton;
    public static StylusPointProperty SecondaryTipButton;
    private static StylusPointProperties();
}
public class System.Windows.Input.StylusPointProperty : object {
    public Guid Id { get; }
    public bool IsButton { get; }
    public StylusPointProperty(Guid identifier, bool isButton);
    protected StylusPointProperty(StylusPointProperty stylusPointProperty);
    public Guid get_Id();
    public bool get_IsButton();
    public virtual string ToString();
}
internal static class System.Windows.Input.StylusPointPropertyIds : object {
    public static Guid X;
    public static Guid Y;
    public static Guid Z;
    public static Guid Width;
    public static Guid Height;
    public static Guid SystemTouch;
    public static Guid PacketStatus;
    public static Guid SerialNumber;
    public static Guid NormalPressure;
    public static Guid TangentPressure;
    public static Guid ButtonPressure;
    public static Guid XTiltOrientation;
    public static Guid YTiltOrientation;
    public static Guid AzimuthOrientation;
    public static Guid AltitudeOrientation;
    public static Guid TwistOrientation;
    public static Guid PitchRotation;
    public static Guid RollRotation;
    public static Guid YawRotation;
    public static Guid TipButton;
    public static Guid BarrelButton;
    public static Guid SecondaryTipButton;
    private static StylusPointPropertyIds();
    internal static Guid GetKnownGuid(HidUsagePage page, HidUsage usage);
    internal static bool IsKnownId(Guid guid);
    internal static string GetStringRepresentation(Guid guid);
    internal static bool IsKnownButton(Guid guid);
}
public class System.Windows.Input.StylusPointPropertyInfo : StylusPointProperty {
    public int Minimum { get; }
    public int Maximum { get; }
    public float Resolution { get; internal set; }
    public StylusPointPropertyUnit Unit { get; }
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty);
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty, int minimum, int maximum, StylusPointPropertyUnit unit, float resolution);
    public int get_Minimum();
    public int get_Maximum();
    public float get_Resolution();
    internal void set_Resolution(float value);
    public StylusPointPropertyUnit get_Unit();
    internal static bool AreCompatible(StylusPointPropertyInfo stylusPointPropertyInfo1, StylusPointPropertyInfo stylusPointPropertyInfo2);
}
internal static class System.Windows.Input.StylusPointPropertyInfoDefaults : object {
    internal static StylusPointPropertyInfo X;
    internal static StylusPointPropertyInfo Y;
    internal static StylusPointPropertyInfo Z;
    internal static StylusPointPropertyInfo Width;
    internal static StylusPointPropertyInfo Height;
    internal static StylusPointPropertyInfo SystemTouch;
    internal static StylusPointPropertyInfo PacketStatus;
    internal static StylusPointPropertyInfo SerialNumber;
    internal static StylusPointPropertyInfo NormalPressure;
    internal static StylusPointPropertyInfo TangentPressure;
    internal static StylusPointPropertyInfo ButtonPressure;
    internal static StylusPointPropertyInfo XTiltOrientation;
    internal static StylusPointPropertyInfo YTiltOrientation;
    internal static StylusPointPropertyInfo AzimuthOrientation;
    internal static StylusPointPropertyInfo AltitudeOrientation;
    internal static StylusPointPropertyInfo TwistOrientation;
    internal static StylusPointPropertyInfo PitchRotation;
    internal static StylusPointPropertyInfo RollRotation;
    internal static StylusPointPropertyInfo YawRotation;
    internal static StylusPointPropertyInfo TipButton;
    internal static StylusPointPropertyInfo BarrelButton;
    internal static StylusPointPropertyInfo SecondaryTipButton;
    internal static StylusPointPropertyInfo DefaultValue;
    internal static StylusPointPropertyInfo DefaultButton;
    private static StylusPointPropertyInfoDefaults();
    internal static StylusPointPropertyInfo GetStylusPointPropertyInfoDefault(StylusPointProperty stylusPointProperty);
}
public enum System.Windows.Input.StylusPointPropertyUnit : Enum {
    public int value__;
    public static StylusPointPropertyUnit None;
    public static StylusPointPropertyUnit Inches;
    public static StylusPointPropertyUnit Centimeters;
    public static StylusPointPropertyUnit Degrees;
    public static StylusPointPropertyUnit Radians;
    public static StylusPointPropertyUnit Seconds;
    public static StylusPointPropertyUnit Pounds;
    public static StylusPointPropertyUnit Grams;
}
internal static class System.Windows.Input.StylusPointPropertyUnitHelper : object {
    private static StylusPointPropertyUnitHelper();
    internal static Nullable`1<StylusPointPropertyUnit> FromPointerUnit(UInt32 pointerUnit);
    internal static bool IsDefined(StylusPointPropertyUnit unit);
}
public class System.Windows.Input.StylusSystemGestureEventArgs : StylusEventArgs {
    public SystemGesture SystemGesture { get; }
    internal int ButtonState { get; }
    internal int GestureX { get; }
    internal int GestureY { get; }
    public StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture);
    internal StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    public SystemGesture get_SystemGesture();
    internal int get_ButtonState();
    internal int get_GestureX();
    internal int get_GestureY();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusSystemGestureEventHandler : MulticastDelegate {
    public StylusSystemGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusSystemGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusSystemGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Input.StylusTouchDeviceBase : TouchDevice {
    internal static double CentimetersPerInch;
    public bool PromotingToOther { get; protected set; }
    internal bool DownHandled { get; private set; }
    internal StylusDeviceBase StylusDevice { get; private set; }
    internal bool IsPrimary { get; private set; }
    internal static int ActiveDeviceCount { get; }
    [SecuritySafeCriticalAttribute]
internal StylusTouchDeviceBase(StylusDeviceBase stylusDevice);
    private static StylusTouchDeviceBase();
    public virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    protected abstract virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    public virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    [SecurityCriticalAttribute]
internal void ChangeActiveSource(PresentationSource activeSource);
    [SecurityCriticalAttribute]
internal void OnActivate();
    protected abstract virtual void OnActivateImpl();
    [SecurityCriticalAttribute]
internal void OnDeactivate();
    protected abstract virtual void OnDeactivateImpl();
    internal bool OnDown();
    internal bool OnMove();
    internal bool OnUp();
    [CompilerGeneratedAttribute]
public bool get_PromotingToOther();
    [CompilerGeneratedAttribute]
protected void set_PromotingToOther(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DownHandled();
    [CompilerGeneratedAttribute]
private void set_DownHandled(bool value);
    [CompilerGeneratedAttribute]
internal StylusDeviceBase get_StylusDevice();
    [CompilerGeneratedAttribute]
private void set_StylusDevice(StylusDeviceBase value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void set_IsPrimary(bool value);
    internal static int get_ActiveDeviceCount();
}
internal class System.Windows.Input.StylusWisp.WispLogic : StylusLogic {
    internal object CurrentMousePromotionStylusDevice { get; internal set; }
    internal StylusPointDescription GetMousePointDescription { get; }
    internal int DoubleTapDelta { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int CancelDelta { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    internal WispTabletDeviceCollection WispTabletDevices { get; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal bool Enabled { get; }
    [SecurityCriticalAttribute]
internal WispLogic(InputManager inputManager);
    [SecurityCriticalAttribute]
internal void ProcessSystemEvent(PenContext penContext, int tabletDeviceId, int stylusDeviceId, int timestamp, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState, PresentationSource inputSource);
    [SecurityCriticalAttribute]
internal void ProcessInput(RawStylusActions actions, PenContext penContext, int tabletDeviceId, int stylusDeviceId, Int32[] data, int timestamp, PresentationSource inputSource);
    [SecurityCriticalAttribute]
internal object InputManagerProcessInput(object oInput);
    [SecurityCriticalAttribute]
internal void InputManagerProcessInputEventArgs(InputEventArgs input);
    [SecuritySafeCriticalAttribute]
internal object ProcessDeferredMouseMove(object oInput);
    [SecurityCriticalAttribute]
internal void PromoteStoredItemsToMouse(WispStylusTouchDevice touchDevice);
    [CompilerGeneratedAttribute]
internal object get_CurrentMousePromotionStylusDevice();
    [CompilerGeneratedAttribute]
internal void set_CurrentMousePromotionStylusDevice(object value);
    internal StylusPointDescription get_GetMousePointDescription();
    internal MouseButtonState GetMouseLeftOrRightButtonState(bool leftButton);
    internal bool UpdateMouseButtonState(RawMouseActions actions);
    internal virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    internal virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    internal int get_DoubleTapDelta();
    internal int get_DoubleTapDeltaTime();
    internal int get_CancelDelta();
    [SecurityCriticalAttribute]
internal virtual TabletDeviceCollection get_TabletDevices();
    [SecurityCriticalAttribute]
internal WispTabletDeviceCollection get_WispTabletDevices();
    internal virtual StylusDeviceBase get_CurrentStylusDevice();
    internal void RegisterStylusDeviceCore(StylusDevice stylusDevice);
    internal void UnregisterStylusDeviceCore(StylusDevice stylusDevice);
    internal WispStylusDevice FindStylusDevice(int stylusDeviceId);
    internal WispStylusDevice FindStylusDeviceWithLock(int stylusDeviceId);
    internal void SelectStylusDevice(WispStylusDevice wispStylusDevice, IInputElement newOver, bool updateOver);
    [SecurityCriticalAttribute]
internal void EnableCore();
    internal bool get_Enabled();
    [SecurityCriticalAttribute]
internal void RegisterHwndForInput(InputManager inputManager, PresentationSource inputSource);
    [SecurityCriticalAttribute]
internal void UnRegisterHwndForInput(HwndSource hwndSource);
    [SecurityCriticalAttribute]
internal PenContexts GetPenContextsFromHwnd(PresentationSource presentationSource);
    [SecurityCriticalAttribute]
internal bool ShouldConsiderStylusInRange(RawMouseInputReport mouseInputReport);
    [SecurityCriticalAttribute]
internal PenContext GetStylusPenContextForHwnd(PresentationSource presentationSource, int tabletDeviceId);
    [SecurityCriticalAttribute]
protected virtual void OnTabletRemoved(UInt32 wisptisIndex);
    [SecurityCriticalAttribute]
internal void OnWindowEnableChanged(IntPtr hwnd, bool disabled);
    [SecuritySafeCriticalAttribute]
internal object ProcessDisplayChanged(object oInput);
    internal Matrix GetTabletToViewTransform(TabletDevice tabletDevice);
    internal virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    internal virtual Point MeasureUnitsFromDeviceUnits(Point measurePoint);
}
internal class System.Windows.Input.StylusWisp.WispStylusDevice : StylusDeviceBase {
    internal IInputElement Target { get; }
    internal bool IsValid { get; }
    internal PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    internal PenContext ActivePenContext { get; }
    internal StylusPlugInCollection CurrentNonVerifiedTarget { get; internal set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    internal TabletDevice TabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int TapCount { get; internal set; }
    internal int LastTapTime { get; internal set; }
    internal Point LastTapPoint { get; internal set; }
    internal bool LastTapBarrelDown { get; internal set; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal Point LastMouseScreenPoint { get; internal set; }
    internal bool SeenDoubleTapGesture { get; internal set; }
    internal bool SeenHoldEnterGesture { get; }
    internal bool GestureWasFired { get; }
    internal bool SentMouseDown { get; }
    internal bool DetectedDrag { get; }
    internal bool LeftIsActiveMouseButton { get; }
    internal bool IgnoreStroke { get; internal set; }
    internal WispStylusTouchDevice TouchDevice { get; }
    [SecuritySafeCriticalAttribute]
internal WispStylusDevice(WispTabletDevice tabletDevice, string sName, int id, bool fInverted, StylusButtonCollection stylusButtonCollection);
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    internal virtual IInputElement get_Target();
    internal virtual bool get_IsValid();
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_ActiveSource();
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_CriticalActiveSource();
    [SecurityCriticalAttribute]
internal PenContext get_ActivePenContext();
    internal StylusPlugInCollection get_CurrentNonVerifiedTarget();
    internal void set_CurrentNonVerifiedTarget(StylusPlugInCollection value);
    internal virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    internal virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
    internal virtual IInputElement get_DirectlyOver();
    internal virtual IInputElement get_Captured();
    internal virtual CaptureMode get_CapturedMode();
    internal virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal virtual bool Capture(IInputElement element);
    internal virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    [SecurityCriticalAttribute]
internal virtual void Synchronize();
    [SecuritySafeCriticalAttribute]
internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captureMode, int timestamp);
    [SecuritySafeCriticalAttribute]
internal void ChangeStylusOver(IInputElement stylusOver);
    [SecurityCriticalAttribute]
internal IInputElement FindTarget(PresentationSource inputSource, Point position);
    internal virtual TabletDevice get_TabletDevice();
    internal virtual string get_Name();
    public virtual string ToString();
    internal virtual int get_Id();
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    internal virtual StylusButtonCollection get_StylusButtons();
    [SecuritySafeCriticalAttribute]
internal virtual Point GetPosition(IInputElement relativeTo);
    internal Point GetRawPosition(IInputElement relativeTo);
    internal virtual StylusPoint get_RawStylusPoint();
    [SecuritySafeCriticalAttribute]
internal virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    internal virtual bool get_InAir();
    internal virtual bool get_Inverted();
    internal virtual bool get_InRange();
    [SecurityCriticalAttribute]
internal virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    internal virtual int get_TapCount();
    internal virtual void set_TapCount(int value);
    internal int get_LastTapTime();
    internal void set_LastTapTime(int value);
    internal Point get_LastTapPoint();
    internal void set_LastTapPoint(Point value);
    internal bool get_LastTapBarrelDown();
    internal void set_LastTapBarrelDown(bool value);
    internal virtual int get_DoubleTapDeltaX();
    internal virtual int get_DoubleTapDeltaY();
    [SecuritySafeCriticalAttribute]
internal virtual int get_DoubleTapDeltaTime();
    [SecurityCriticalAttribute]
internal void UpdateState(RawStylusInputReport report);
    [SecurityCriticalAttribute]
internal void UpdateInRange(bool inRange, PenContext penContext);
    [SecurityCriticalAttribute]
internal void UpdateStateForSystemGesture(RawStylusSystemGestureInputReport report);
    [SecurityCriticalAttribute]
internal void PlayBackCachedDownInputReport(int timestamp);
    [SecurityCriticalAttribute]
internal PresentationSource GetMousePresentationSource();
    [SecurityCriticalAttribute]
internal RawMouseActions GetMouseActionsFromStylusEventAndPlaybackCachedDown(RoutedEvent stylusEvent, StylusEventArgs stylusArgs);
    internal void ResetStateForStylusUp();
    internal Point get_LastMouseScreenPoint();
    internal void set_LastMouseScreenPoint(Point value);
    internal bool get_SeenDoubleTapGesture();
    internal void set_SeenDoubleTapGesture(bool value);
    internal bool get_SeenHoldEnterGesture();
    internal bool get_GestureWasFired();
    internal bool get_SentMouseDown();
    internal bool get_DetectedDrag();
    internal bool get_LeftIsActiveMouseButton();
    internal void SetSawMouseButton1Down(bool sawMouseButton1Down);
    internal bool get_IgnoreStroke();
    internal void set_IgnoreStroke(bool value);
    internal WispStylusTouchDevice get_TouchDevice();
    [SecuritySafeCriticalAttribute]
internal void UpdateTouchActiveSource();
}
internal class System.Windows.Input.StylusWisp.WispStylusPlugInCollection : StylusPlugInCollectionBase {
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal PenContexts PenContexts { get; }
    [SecuritySafeCriticalAttribute]
internal virtual bool get_IsActiveForInput();
    [SecuritySafeCriticalAttribute]
internal virtual object get_SyncRoot();
    [SecurityCriticalAttribute]
internal PenContexts get_PenContexts();
    [SecuritySafeCriticalAttribute]
internal virtual void UpdateState(UIElement element);
    [SecuritySafeCriticalAttribute]
internal virtual void Unhook();
}
internal class System.Windows.Input.StylusWisp.WispStylusTouchDevice : StylusTouchDeviceBase {
    internal StagingAreaInputItemList StoredStagingAreaItems { get; }
    [SecuritySafeCriticalAttribute]
internal WispStylusTouchDevice(StylusDeviceBase stylusDevice);
    private static WispStylusTouchDevice();
    protected virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    protected virtual void OnManipulationStarted();
    [SecurityCriticalAttribute]
protected virtual void OnManipulationEnded(bool cancel);
    [SecurityCriticalAttribute]
internal StagingAreaInputItemList get_StoredStagingAreaItems();
    [SecurityCriticalAttribute]
protected virtual void OnActivateImpl();
    [SecurityCriticalAttribute]
protected virtual void OnDeactivateImpl();
}
public class System.Windows.Input.StylusWisp.WispTabletDeviceCollection : TabletDeviceCollection {
    internal List`1<TabletDevice> DeferredTablets { get; }
    [SecurityCriticalAttribute]
internal static bool ShouldEnableTablets();
    [SecurityCriticalAttribute]
internal void UpdateTablets();
    [SecurityCriticalAttribute]
internal bool HandleTabletAdded(UInt32 wisptisIndex, UInt32& tabletIndexChanged);
    [SecurityCriticalAttribute]
internal UInt32 HandleTabletRemoved(UInt32 wisptisIndex);
    [SecurityCriticalAttribute]
internal WispStylusDevice UpdateStylusDevices(int tabletId, int stylusId);
    [SecurityCriticalAttribute]
internal void DisposeTablets();
    [SecurityCriticalAttribute]
internal void DisposeDeferredTablets();
    [SecurityCriticalAttribute]
internal PenContext[] CreateContexts(IntPtr hwnd, PenContexts contexts);
    internal List`1<TabletDevice> get_DeferredTablets();
}
public enum System.Windows.Input.SystemGesture : Enum {
    public int value__;
    public static SystemGesture None;
    public static SystemGesture Tap;
    public static SystemGesture RightTap;
    public static SystemGesture Drag;
    public static SystemGesture RightDrag;
    public static SystemGesture HoldEnter;
    public static SystemGesture HoldLeave;
    public static SystemGesture HoverEnter;
    public static SystemGesture HoverLeave;
    public static SystemGesture Flick;
    public static SystemGesture TwoFingerTap;
}
public static class System.Windows.Input.Tablet : object {
    public static TabletDevice CurrentTabletDevice { get; }
    public static TabletDeviceCollection TabletDevices { get; }
    public static TabletDevice get_CurrentTabletDevice();
    [SecurityCriticalAttribute]
public static TabletDeviceCollection get_TabletDevices();
}
public class System.Windows.Input.TabletDevice : InputDevice {
    internal TabletDeviceBase TabletDeviceImpl { get; internal set; }
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public int Id { get; }
    public string Name { get; }
    public string ProductId { get; }
    public TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    public ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    public TabletDeviceType Type { get; }
    public StylusDeviceCollection StylusDevices { get; }
    internal TabletDevice(TabletDeviceBase impl);
    [CompilerGeneratedAttribute]
internal TabletDeviceBase get_TabletDeviceImpl();
    [CompilerGeneratedAttribute]
internal void set_TabletDeviceImpl(TabletDeviceBase value);
    public virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public virtual PresentationSource get_ActiveSource();
    public int get_Id();
    public string get_Name();
    public string get_ProductId();
    public TabletHardwareCapabilities get_TabletHardwareCapabilities();
    public ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    public TabletDeviceType get_Type();
    public virtual string ToString();
    public StylusDeviceCollection get_StylusDevices();
    internal T As();
}
internal abstract class System.Windows.Input.TabletDeviceBase : DispatcherObject {
    protected bool _disposed;
    protected Size _doubleTapSize;
    protected bool _forceUpdateSizeDeltas;
    protected TabletDeviceInfo _tabletInfo;
    protected StylusPointDescription _stylusPointDescription;
    internal TabletDevice TabletDevice { get; private set; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal int Id { get; }
    internal string Name { get; }
    internal string ProductId { get; }
    internal TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    internal ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    internal TabletDeviceType Type { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal Matrix TabletToScreen { get; }
    internal Size TabletSize { get; }
    internal Size ScreenSize { get; }
    internal Size DoubleTapSize { get; }
    internal StylusPointDescription StylusPointDescription { get; }
    protected TabletDeviceBase(TabletDeviceInfo info);
    [CompilerGeneratedAttribute]
internal TabletDevice get_TabletDevice();
    [CompilerGeneratedAttribute]
private void set_TabletDevice(TabletDevice value);
    internal T As();
    [SecurityCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
protected virtual override void Finalize();
    internal abstract virtual IInputElement get_Target();
    internal abstract virtual PresentationSource get_ActiveSource();
    internal int get_Id();
    internal string get_Name();
    internal string get_ProductId();
    internal TabletHardwareCapabilities get_TabletHardwareCapabilities();
    internal ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    internal TabletDeviceType get_Type();
    public virtual string ToString();
    internal abstract virtual StylusDeviceCollection get_StylusDevices();
    [SecurityCriticalAttribute]
internal Nullable`1<SystemGesture> GenerateStaticGesture(RawStylusInputReport stylusInputReport);
    internal Matrix get_TabletToScreen();
    internal Size get_TabletSize();
    internal Size get_ScreenSize();
    internal abstract virtual Size get_DoubleTapSize();
    internal StylusPointDescription get_StylusPointDescription();
    protected static UInt32 GetPropertyValue(StylusPointPropertyInfo propertyInfo);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.TabletDeviceCollection : object {
    public int Count { get; }
    public TabletDevice Item { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    internal List`1<TabletDevice> TabletDevices { get; internal set; }
    internal static TabletDeviceCollection EmptyTabletDeviceCollection { get; }
    internal T As();
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(TabletDevice[] array, int index);
    public TabletDevice get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal List`1<TabletDevice> get_TabletDevices();
    [CompilerGeneratedAttribute]
internal void set_TabletDevices(List`1<TabletDevice> value);
    internal static TabletDeviceCollection get_EmptyTabletDeviceCollection();
}
internal class System.Windows.Input.TabletDeviceInfo : object {
    [SecurityCriticalAttribute]
public SecurityCriticalDataClass`1<IPimcTablet2> PimcTablet;
    public int Id;
    public string Name;
    public string PlugAndPlayId;
    public TabletDeviceSizeInfo SizeInfo;
    public TabletHardwareCapabilities HardwareCapabilities;
    public TabletDeviceType DeviceType;
    public ReadOnlyCollection`1<StylusPointProperty> StylusPointProperties;
    public int PressureIndex;
    public StylusDeviceInfo[] StylusDevicesInfo;
    public UInt32 WispTabletKey { get; public set; }
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public UInt32 get_WispTabletKey();
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public void set_WispTabletKey(UInt32 value);
}
internal class System.Windows.Input.TabletDeviceSizeInfo : ValueType {
    public Size TabletSize;
    public Size ScreenSize;
    internal TabletDeviceSizeInfo(Size tabletSize, Size screenSize);
}
public enum System.Windows.Input.TabletDeviceType : Enum {
    public int value__;
    public static TabletDeviceType Stylus;
    public static TabletDeviceType Touch;
}
[FlagsAttribute]
public enum System.Windows.Input.TabletHardwareCapabilities : Enum {
    public int value__;
    public static TabletHardwareCapabilities None;
    public static TabletHardwareCapabilities Integrated;
    public static TabletHardwareCapabilities StylusMustTouch;
    public static TabletHardwareCapabilities HardProximity;
    public static TabletHardwareCapabilities StylusHasPhysicalIds;
    public static TabletHardwareCapabilities SupportsPressure;
}
public class System.Windows.Input.TextComposition : DispatcherObject {
    [CLSCompliantAttribute("False")]
public string Text { get; protected set; }
    [CLSCompliantAttribute("False")]
public string CompositionText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string ControlText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemCompositionText { get; protected set; }
    public TextCompositionAutoComplete AutoComplete { get; }
    internal IInputElement Source { get; }
    internal InputDevice _InputDevice { get; }
    internal InputManager _InputManager { get; }
    internal TextCompositionStage Stage { get; internal set; }
    public TextComposition(InputManager inputManager, IInputElement source, string resultText);
    [SecurityCriticalAttribute]
public TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete, InputDevice inputDevice);
    [SecurityCriticalAttribute]
public virtual void Complete();
    public string get_Text();
    protected void set_Text(string value);
    public string get_CompositionText();
    protected void set_CompositionText(string value);
    public string get_SystemText();
    protected void set_SystemText(string value);
    public string get_ControlText();
    protected void set_ControlText(string value);
    public string get_SystemCompositionText();
    protected void set_SystemCompositionText(string value);
    public TextCompositionAutoComplete get_AutoComplete();
    internal void SetText(string resultText);
    internal void SetCompositionText(string compositionText);
    internal void MakeSystem();
    internal void MakeControl();
    internal void ClearTexts();
    internal IInputElement get_Source();
    internal InputDevice get__InputDevice();
    [SecurityCriticalAttribute]
internal InputManager get__InputManager();
    internal TextCompositionStage get_Stage();
    internal void set_Stage(TextCompositionStage value);
}
public enum System.Windows.Input.TextCompositionAutoComplete : Enum {
    public int value__;
    public static TextCompositionAutoComplete Off;
    public static TextCompositionAutoComplete On;
}
public class System.Windows.Input.TextCompositionEventArgs : InputEventArgs {
    public TextComposition TextComposition { get; }
    public string Text { get; }
    public string SystemText { get; }
    public string ControlText { get; }
    public TextCompositionEventArgs(InputDevice inputDevice, TextComposition composition);
    public TextComposition get_TextComposition();
    public string get_Text();
    public string get_SystemText();
    public string get_ControlText();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TextCompositionEventHandler : MulticastDelegate {
    public TextCompositionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextCompositionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextCompositionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TextCompositionManager : DispatcherObject {
    public static RoutedEvent PreviewTextInputStartEvent;
    public static RoutedEvent TextInputStartEvent;
    public static RoutedEvent PreviewTextInputUpdateEvent;
    public static RoutedEvent TextInputUpdateEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal TextCompositionManager(InputManager inputManager);
    private static TextCompositionManager();
    public static void AddPreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    [SecurityCriticalAttribute]
public static bool StartComposition(TextComposition composition);
    [SecurityCriticalAttribute]
public static bool UpdateComposition(TextComposition composition);
    [SecurityCriticalAttribute]
public static bool CompleteComposition(TextComposition composition);
    [SecurityCriticalAttribute]
internal void CompleteDeadCharComposition();
}
internal enum System.Windows.Input.TextCompositionStage : Enum {
    public int value__;
    public static TextCompositionStage None;
    public static TextCompositionStage Started;
    public static TextCompositionStage Done;
}
internal class System.Windows.Input.TextServicesCompartment : object {
    internal bool BooleanValue { get; internal set; }
    internal int IntValue { get; internal set; }
    internal object Value { get; internal set; }
    [SecurityCriticalAttribute]
internal TextServicesCompartment(Guid guid, ITfCompartmentMgr compartmentmgr);
    [SecurityCriticalAttribute]
internal void AdviseNotifySink(ITfCompartmentEventSink sink);
    [SecurityCriticalAttribute]
internal void UnadviseNotifySink();
    [SecurityCriticalAttribute]
internal ITfCompartment GetITfCompartment();
    internal bool get_BooleanValue();
    internal void set_BooleanValue(bool value);
    internal int get_IntValue();
    internal void set_IntValue(int value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal object get_Value();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set_Value(object value);
}
internal class System.Windows.Input.TextServicesCompartmentContext : object {
    internal static TextServicesCompartmentContext Current { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextServicesCompartment GetCompartment(InputMethodStateType statetype);
    [SecurityCriticalAttribute]
internal TextServicesCompartment GetThreadCompartment(Guid guid);
    [SecurityCriticalAttribute]
internal TextServicesCompartment GetGlobalCompartment(Guid guid);
    internal static TextServicesCompartmentContext get_Current();
}
internal class System.Windows.Input.TextServicesCompartmentEventSink : object {
    internal TextServicesCompartmentEventSink(InputMethod inputmethod);
    public sealed virtual void OnChange(Guid& rguid);
}
internal class System.Windows.Input.TextServicesContext : object {
    internal static TextServicesContext DispatcherCurrent { get; }
    internal ITfThreadMgr ThreadManager { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Uninitialize(bool appDomainShutdown);
    [SecurityCriticalAttribute]
internal bool Keystroke(int wParam, int lParam, KeyOp op);
    [SecurityCriticalAttribute]
internal void RegisterTextStore(DefaultTextStore defaultTextStore);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void SetFocusOnDefaultTextStore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SetFocusOnEmptyDim();
    internal static TextServicesContext get_DispatcherCurrent();
    [SecurityCriticalAttribute]
internal ITfThreadMgr get_ThreadManager();
}
internal class System.Windows.Input.TextServicesManager : DispatcherObject {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextServicesManager(InputManager inputManager);
    internal void Focus(DependencyObject focus);
}
public static class System.Windows.Input.Touch : object {
    internal static RoutedEvent PreviewTouchDownEvent;
    internal static RoutedEvent TouchDownEvent;
    internal static RoutedEvent PreviewTouchMoveEvent;
    internal static RoutedEvent TouchMoveEvent;
    internal static RoutedEvent PreviewTouchUpEvent;
    internal static RoutedEvent TouchUpEvent;
    internal static RoutedEvent GotTouchCaptureEvent;
    internal static RoutedEvent LostTouchCaptureEvent;
    internal static RoutedEvent TouchEnterEvent;
    internal static RoutedEvent TouchLeaveEvent;
    private static Touch();
    [CompilerGeneratedAttribute]
public static void add_FrameReported(TouchFrameEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_FrameReported(TouchFrameEventHandler value);
    internal static void ReportFrame();
}
public enum System.Windows.Input.TouchAction : Enum {
    public int value__;
    public static TouchAction Down;
    public static TouchAction Move;
    public static TouchAction Up;
}
public abstract class System.Windows.Input.TouchDevice : InputDevice {
    public int Id { get; }
    public bool IsActive { get; }
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public CaptureMode CaptureMode { get; }
    internal bool PromotingToManipulation { get; private set; }
    private int System.Windows.Input.IManipulator.Id { get; }
    [SecurityCriticalAttribute]
protected TouchDevice(int deviceId);
    public int get_Id();
    [CompilerGeneratedAttribute]
public void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler value);
    public bool get_IsActive();
    public sealed virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
public sealed virtual PresentationSource get_ActiveSource();
    [SecurityCriticalAttribute]
protected void SetActiveSource(PresentationSource activeSource);
    public IInputElement get_DirectlyOver();
    public abstract virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    public abstract virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    public IInputElement get_Captured();
    public CaptureMode get_CaptureMode();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    internal static void ReevaluateCapturedWithin(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    protected virtual void OnCapture(IInputElement element, CaptureMode captureMode);
    protected bool ReportDown();
    protected bool ReportMove();
    protected bool ReportUp();
    protected void Activate();
    protected void Deactivate();
    [SecurityCriticalAttribute]
public void Synchronize();
    [SecurityCriticalAttribute]
protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    internal static void ReevaluateDirectlyOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    [CompilerGeneratedAttribute]
internal bool get_PromotingToManipulation();
    [CompilerGeneratedAttribute]
private void set_PromotingToManipulation(bool value);
    internal static TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    internal static TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    internal static void ReleaseAllCaptures(IInputElement element);
    internal static IEnumerable`1<TouchDevice> GetCapturedTouches(IInputElement element, bool includeWithin);
    internal static IEnumerable`1<TouchDevice> GetTouchesOver(IInputElement element, bool includeWithin);
    private sealed virtual override int System.Windows.Input.IManipulator.get_Id();
    private sealed virtual override Point System.Windows.Input.IManipulator.GetPosition(IInputElement relativeTo);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler value);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Input.IManipulator.ManipulationEnded(bool cancel);
}
internal class System.Windows.Input.TouchesCapturedWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.Input.TouchesOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public class System.Windows.Input.TouchEventArgs : InputEventArgs {
    public TouchDevice TouchDevice { get; }
    public TouchEventArgs(TouchDevice touchDevice, int timestamp);
    public TouchDevice get_TouchDevice();
    public TouchPoint GetTouchPoint(IInputElement relativeTo);
    public TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TouchFrameEventArgs : EventArgs {
    public int Timestamp { get; private set; }
    internal TouchFrameEventArgs(int timestamp);
    [CompilerGeneratedAttribute]
public int get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(int value);
    public TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    public TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    public void SuspendMousePromotionUntilTouchUp();
}
public class System.Windows.Input.TouchFrameEventHandler : MulticastDelegate {
    public TouchFrameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TouchFrameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TouchFrameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TouchPoint : object {
    public TouchDevice TouchDevice { get; private set; }
    public Point Position { get; private set; }
    public Rect Bounds { get; private set; }
    public Size Size { get; }
    public TouchAction Action { get; private set; }
    public TouchPoint(TouchDevice device, Point position, Rect bounds, TouchAction action);
    [CompilerGeneratedAttribute]
public TouchDevice get_TouchDevice();
    [CompilerGeneratedAttribute]
private void set_TouchDevice(TouchDevice value);
    [CompilerGeneratedAttribute]
public Point get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(Point value);
    [CompilerGeneratedAttribute]
public Rect get_Bounds();
    [CompilerGeneratedAttribute]
private void set_Bounds(Rect value);
    public Size get_Size();
    [CompilerGeneratedAttribute]
public TouchAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(TouchAction value);
    private sealed virtual override bool System.IEquatable<System.Windows.Input.TouchPoint>.Equals(TouchPoint other);
}
public class System.Windows.Input.TouchPointCollection : Collection`1<TouchPoint> {
}
internal static class System.Windows.Input.Tracing.StylusTraceLogger : object {
    private static StylusTraceLogger();
    internal static void LogStartup();
    internal static void LogStatistics(StylusStatistics stylusData);
    internal static void LogReentrancyRetryLimitReached();
    internal static void LogError(string error);
    internal static void LogDeviceConnect(StylusDeviceInfo deviceInfo);
    internal static void LogDeviceDisconnect(int deviceId);
    internal static void LogReentrancy(string functionName);
    internal static void LogShutdown();
}
internal class System.Windows.Input.Win32KeyboardDevice : KeyboardDevice {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal Win32KeyboardDevice(InputManager inputManager);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual KeyStates GetKeyStatesFromSystem(Key key);
}
internal class System.Windows.Input.Win32MouseDevice : MouseDevice {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Win32MouseDevice(InputManager inputManager);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual MouseButtonState GetButtonStateFromSystem(MouseButton mouseButton);
}
internal class System.Windows.Input.WispTabletDevice : TabletDeviceBase {
    protected Size _cancelSize;
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal PenThread PenThread { get; }
    internal Size DoubleTapSize { get; }
    internal Size CancelSize { get; }
    internal bool IsDisposalPending { get; }
    internal bool CanDispose { get; }
    internal int QueuedEventCount { get; internal set; }
    internal UInt32 WispTabletKey { get; }
    [SecurityCriticalAttribute]
internal WispTabletDevice(TabletDeviceInfo tabletInfo, PenThread penThread);
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
internal WispStylusDevice UpdateStylusDevices(int stylusId);
    internal virtual IInputElement get_Target();
    [SecurityCriticalAttribute]
internal virtual PresentationSource get_ActiveSource();
    public virtual string ToString();
    internal virtual StylusDeviceCollection get_StylusDevices();
    [SecurityCriticalAttribute]
internal PenContext CreateContext(IntPtr hwnd, PenContexts contexts);
    [SecurityCriticalAttribute]
internal PenThread get_PenThread();
    [SecurityCriticalAttribute]
internal void UpdateScreenMeasurements();
    internal virtual Size get_DoubleTapSize();
    internal Size get_CancelSize();
    internal void InvalidateSizeDeltas();
    internal bool AreSizeDeltasValid();
    [SecurityCriticalAttribute]
internal void UpdateSizeDeltas(StylusPointDescription description, WispLogic stylusLogic);
    [SecurityCriticalAttribute]
internal void DisposeOrDeferDisposal();
    internal bool get_IsDisposalPending();
    internal bool get_CanDispose();
    internal int get_QueuedEventCount();
    internal void set_QueuedEventCount(int value);
    [SecurityCriticalAttribute]
internal UInt32 get_WispTabletKey();
}
public static class System.Windows.Interop.CursorInteropHelper : object {
    [SecurityCriticalAttribute]
public static Cursor Create(SafeHandle cursorHandle);
    [SecurityCriticalAttribute]
internal static Cursor CriticalCreate(SafeHandle cursorHandle);
}
public class System.Windows.Interop.D3DImage : ImageSource {
    public static DependencyProperty IsFrontBufferAvailableProperty;
    internal MultiChannelResource _duceResource;
    public bool IsFrontBufferAvailable { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    private static D3DImage();
    [SecurityCriticalAttribute]
public D3DImage(double dpiX, double dpiY);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer);
    [SecurityCriticalAttribute]
public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    public void Lock();
    public bool TryLock(Duration timeout);
    public void Unlock();
    [SecurityCriticalAttribute]
public void AddDirtyRect(Int32Rect dirtyRect);
    public bool get_IsFrontBufferAvailable();
    public void add_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public int get_PixelWidth();
    public int get_PixelHeight();
    public sealed virtual double get_Width();
    public sealed virtual double get_Height();
    public sealed virtual ImageMetadata get_Metadata();
    public D3DImage Clone();
    public D3DImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected sealed virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected internal virtual BitmapSource CopyBackBuffer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void MS.Internal.IAppDomainShutdownListener.NotifyShutdown();
}
public enum System.Windows.Interop.D3DResourceType : Enum {
    public int value__;
    public static D3DResourceType IDirect3DSurface9;
}
internal class System.Windows.Interop.HwndAppCommandInputProvider : DispatcherObject {
    [SecurityCriticalAttribute]
internal HwndAppCommandInputProvider(HwndSource source);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    [SecurityCriticalAttribute]
internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
internal class System.Windows.Interop.HwndKeyboardInputProvider : DispatcherObject {
    [SecurityCriticalAttribute]
internal HwndKeyboardInputProvider(HwndSource source);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    public void OnRootChanged(Visual oldRoot, Visual newRoot);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Input.IKeyboardInputProvider.AcquireFocus(bool checkOnly);
    [SecurityCriticalAttribute]
internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage message, IntPtr wParam, IntPtr lParam, Boolean& handled);
    [SecurityCriticalAttribute]
internal void ProcessKeyAction(MSG& msg, Boolean& handled);
    [SecurityCriticalAttribute]
internal void ProcessTextInputAction(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal static int GetVirtualKey(IntPtr wParam, IntPtr lParam);
    internal static int GetScanCode(IntPtr wParam, IntPtr lParam);
    internal static bool IsExtendedKey(IntPtr lParam);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[FriendAccessAllowedAttribute]
internal static ModifierKeys GetSystemModifierKeys();
}
internal class System.Windows.Interop.HwndMouseInputProvider : DispatcherObject {
    [SecurityCriticalAttribute]
internal HwndMouseInputProvider(HwndSource source);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override bool System.Windows.Input.IMouseInputProvider.SetCursor(Cursor cursor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override bool System.Windows.Input.IMouseInputProvider.CaptureMouse();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void System.Windows.Input.IMouseInputProvider.ReleaseMouseCapture();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override int System.Windows.Input.IMouseInputProvider.GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    [SecurityCriticalAttribute]
internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
internal class System.Windows.Interop.HwndPanningFeedback : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public HwndPanningFeedback(HwndSource hwndSource);
    [SecurityCriticalAttribute]
public void UpdatePanningFeedback(Vector totalOverpanOffset, bool inInertia);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public void EndPanningFeedback(bool animateBack);
}
internal class System.Windows.Interop.HwndPointerInputProvider : DispatcherObject {
    internal bool IsWindowEnabled { get; private set; }
    [SecurityCriticalAttribute]
internal HwndPointerInputProvider(HwndSource source);
    [CompilerGeneratedAttribute]
internal bool get_IsWindowEnabled();
    [CompilerGeneratedAttribute]
private void set_IsWindowEnabled(bool value);
    [SecurityCriticalAttribute]
protected virtual override void Finalize();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
private sealed virtual override IntPtr System.Windows.Interop.IStylusInputProvider.FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public sealed virtual bool ProvidesInputForRootVisual(Visual v);
    public sealed virtual void NotifyDeactivate();
}
public class System.Windows.Interop.HwndSource : PresentationSource {
    [ThreadStaticAttribute]
internal static bool _eatCharMessages;
    public bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    public IEnumerable`1<IKeyboardInputSink> ChildKeyboardInputSinks { get; }
    public HwndTarget CompositionTarget { get; }
    internal bool IsInExclusiveMenuMode { get; private set; }
    public IntPtr Handle { get; }
    internal IntPtr CriticalHandle { get; }
    internal HwndWrapper HwndWrapper { get; }
    internal bool HasCapture { get; }
    internal bool IsHandleNull { get; }
    public SizeToContent SizeToContent { get; public set; }
    public bool UsesPerPixelOpacity { get; }
    protected IKeyboardInputSite KeyboardInputSiteCore { get; protected set; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    public RestoreFocusMode RestoreFocusMode { get; }
    public static bool DefaultAcquireHwndFocusInMenuMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static HwndSource();
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);
    [SecurityCriticalAttribute]
public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);
    [SecurityCriticalAttribute]
public HwndSource(HwndSourceParameters parameters);
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public void AddHook(HwndSourceHook hook);
    [SecurityCriticalAttribute]
public void RemoveHook(HwndSourceHook hook);
    [SecurityCriticalAttribute]
internal virtual IInputProvider GetInputProvider(Type inputDevice);
    internal void ChangeDpi(HwndDpiChangedEventArgs e);
    [SecurityCriticalAttribute]
protected virtual void OnDpiChanged(HwndDpiChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DpiChanged(HwndDpiChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DpiChanged(HwndDpiChangedEventHandler value);
    public virtual bool get_IsDisposed();
    [SecurityCriticalAttribute]
public virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    [IteratorStateMachineAttribute("System.Windows.Interop.HwndSource/<get_ChildKeyboardInputSinks>d__29")]
public IEnumerable`1<IKeyboardInputSink> get_ChildKeyboardInputSinks();
    [SecurityCriticalAttribute]
public static HwndSource FromHwnd(IntPtr hwnd);
    [SecurityCriticalAttribute]
internal static HwndSource CriticalFromHwnd(IntPtr hwnd);
    [SecurityCriticalAttribute]
public HwndTarget get_CompositionTarget();
    [SecurityCriticalAttribute]
protected virtual CompositionTarget GetCompositionTargetCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void OnEnterMenuMode();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void OnLeaveMenuMode();
    [CompilerGeneratedAttribute]
internal bool get_IsInExclusiveMenuMode();
    [CompilerGeneratedAttribute]
private void set_IsInExclusiveMenuMode(bool value);
    [CompilerGeneratedAttribute]
public void add_AutoResized(AutoResizedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AutoResized(AutoResizedEventHandler value);
    [SecurityCriticalAttribute]
internal void ShowSystemMenu();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal Point TransformToDevice(Point pt);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal Point TransformFromDevice(Point pt);
    [SecurityCriticalAttribute]
public sealed virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal IntPtr get_CriticalHandle();
    [SecurityCriticalAttribute]
internal HwndWrapper get_HwndWrapper();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_HasCapture();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsHandleNull();
    public HandleRef CreateHandleRef();
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    [SecurityCriticalAttribute]
public bool get_UsesPerPixelOpacity();
    [SecurityCriticalAttribute]
protected IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    [SecurityCriticalAttribute]
protected IKeyboardInputSite get_KeyboardInputSiteCore();
    [SecurityCriticalAttribute]
protected void set_KeyboardInputSiteCore(IKeyboardInputSite value);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    [SecurityCriticalAttribute]
protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    protected virtual bool HasFocusWithinCore();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
    public RestoreFocusMode get_RestoreFocusMode();
    public static bool get_DefaultAcquireHwndFocusInMenuMode();
    public static void set_DefaultAcquireHwndFocusInMenuMode(bool value);
    public bool get_AcquireHwndFocusInMenuMode();
    [SecurityCriticalAttribute]
internal void CriticalUnregisterKeyboardInputSink(HwndSourceKeyboardInputSite site);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal bool CriticalTranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    internal static object RestoreCharMessages(object unused);
    internal bool IsRepeatedKeyboardMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
}
public class System.Windows.Interop.HwndSourceHook : MulticastDelegate {
    public HwndSourceHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal class System.Windows.Interop.HwndSourceKeyboardInputSite : object {
    private IKeyboardInputSink System.Windows.Interop.IKeyboardInputSite.Sink { get; }
    [SecurityCriticalAttribute]
public HwndSourceKeyboardInputSite(HwndSource source, IKeyboardInputSink sink);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Interop.IKeyboardInputSite.Unregister();
    [SecurityCriticalAttribute]
internal void CriticalUnregister();
    private sealed virtual override IKeyboardInputSink System.Windows.Interop.IKeyboardInputSite.get_Sink();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSite.OnNoMoreTabStops(TraversalRequest request);
}
public class System.Windows.Interop.HwndSourceParameters : ValueType {
    private int _classStyleBits;
    private int _styleBits;
    private int _extendedStyleBits;
    private int _x;
    private int _y;
    private int _width;
    private int _height;
    private string _name;
    private IntPtr _parent;
    private HwndSourceHook _hwndSourceHook;
    private bool _adjustSizingForNonClientArea;
    private bool _hasAssignedSize;
    private bool _usesPerPixelOpacity;
    private bool _usesPerPixelTransparency;
    private Nullable`1<bool> _treatAsInputRoot;
    private bool _treatAncestorsAsNonClientArea;
    private Nullable`1<RestoreFocusMode> _restoreFocusMode;
    private Nullable`1<bool> _acquireHwndFocusInMenuMode;
    public int WindowClassStyle { get; public set; }
    public int WindowStyle { get; public set; }
    public int ExtendedWindowStyle { get; public set; }
    public int PositionX { get; public set; }
    public int PositionY { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool HasAssignedSize { get; }
    public string WindowName { get; public set; }
    public IntPtr ParentWindow { get; public set; }
    public HwndSourceHook HwndSourceHook { get; public set; }
    public bool AdjustSizingForNonClientArea { get; public set; }
    public bool TreatAncestorsAsNonClientArea { get; public set; }
    public bool UsesPerPixelOpacity { get; public set; }
    public bool UsesPerPixelTransparency { get; public set; }
    public RestoreFocusMode RestoreFocusMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; public set; }
    public bool TreatAsInputRoot { get; public set; }
    internal bool EffectivePerPixelOpacity { get; }
    internal static bool PlatformSupportsTransparentChildWindows { get; }
    public HwndSourceParameters(string name);
    public HwndSourceParameters(string name, int width, int height);
    private static HwndSourceParameters();
    public virtual int GetHashCode();
    public int get_WindowClassStyle();
    public void set_WindowClassStyle(int value);
    public int get_WindowStyle();
    public void set_WindowStyle(int value);
    public int get_ExtendedWindowStyle();
    public void set_ExtendedWindowStyle(int value);
    public void SetPosition(int x, int y);
    public int get_PositionX();
    public void set_PositionX(int value);
    public int get_PositionY();
    public void set_PositionY(int value);
    public void SetSize(int width, int height);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public bool get_HasAssignedSize();
    public string get_WindowName();
    public void set_WindowName(string value);
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public HwndSourceHook get_HwndSourceHook();
    public void set_HwndSourceHook(HwndSourceHook value);
    public bool get_AdjustSizingForNonClientArea();
    public void set_AdjustSizingForNonClientArea(bool value);
    public bool get_TreatAncestorsAsNonClientArea();
    public void set_TreatAncestorsAsNonClientArea(bool value);
    public bool get_UsesPerPixelOpacity();
    public void set_UsesPerPixelOpacity(bool value);
    public bool get_UsesPerPixelTransparency();
    public void set_UsesPerPixelTransparency(bool value);
    public RestoreFocusMode get_RestoreFocusMode();
    public void set_RestoreFocusMode(RestoreFocusMode value);
    public bool get_AcquireHwndFocusInMenuMode();
    public void set_AcquireHwndFocusInMenuMode(bool value);
    public bool get_TreatAsInputRoot();
    public void set_TreatAsInputRoot(bool value);
    internal bool get_EffectivePerPixelOpacity();
    public static bool op_Equality(HwndSourceParameters a, HwndSourceParameters b);
    public static bool op_Inequality(HwndSourceParameters a, HwndSourceParameters b);
    public virtual bool Equals(object obj);
    public bool Equals(HwndSourceParameters obj);
    internal static bool get_PlatformSupportsTransparentChildWindows();
    internal static void SetPlatformSupportsTransparentChildWindowsForTestingOnly(bool value);
}
internal class System.Windows.Interop.HwndStylusInputProvider : DispatcherObject {
    [SecurityCriticalAttribute]
internal HwndStylusInputProvider(HwndSource source);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    [SecurityCriticalAttribute]
private sealed virtual override IntPtr System.Windows.Interop.IStylusInputProvider.FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
public class System.Windows.Interop.HwndTarget : CompositionTarget {
    public RenderMode RenderMode { get; public set; }
    internal static ProcessDpiAwareness ProcessDpiAwareness { get; internal set; }
    unknown Visual RootVisual {public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    public Color BackgroundColor { get; public set; }
    public bool UsesPerPixelOpacity { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static HwndTarget();
    [SecurityCriticalAttribute]
public HwndTarget(IntPtr hwnd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int MilCore_SetDpiAwarenessForDisplayModeText(bool isPerMonitorDpiAware);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int VisualTarget_AttachToHwnd(IntPtr hwnd);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int VisualTarget_DetachFromHwnd(IntPtr hwnd);
    internal void InvalidateRenderMode();
    public RenderMode get_RenderMode();
    [SecurityCriticalAttribute]
public void set_RenderMode(RenderMode value);
    [SecurityCriticalAttribute]
public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    [SecurityCriticalAttribute]
internal IntPtr HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam);
    internal void AdjustForRightToLeft(RECT& rc, HandleRef handleRef);
    [SecurityCriticalAttribute]
internal void OnMonitorDPIChanged(Rect suggestedRect, double newDpiX, double newDpiY);
    [CompilerGeneratedAttribute]
internal static ProcessDpiAwareness get_ProcessDpiAwareness();
    [CompilerGeneratedAttribute]
internal static void set_ProcessDpiAwareness(ProcessDpiAwareness value);
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public bool get_UsesPerPixelOpacity();
    internal void set_UsesPerPixelOpacity(bool value);
}
public static class System.Windows.Interop.Imaging : object {
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    [SecurityCriticalAttribute]
internal static BitmapSource CriticalCreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions, WICBitmapAlphaChannelOption alphaOptions);
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromHIcon(IntPtr icon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    [SecurityCriticalAttribute]
public static BitmapSource CreateBitmapSourceFromMemorySection(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
}
public class System.Windows.Interop.InteropBitmap : BitmapSource {
    [SecurityCriticalAttribute]
internal InteropBitmap(IntPtr hbitmap, IntPtr hpalette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions, WICBitmapAlphaChannelOption alphaOptions);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal InteropBitmap(IntPtr hicon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal InteropBitmap(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
public void Invalidate();
    [SecurityCriticalAttribute]
public void Invalidate(Nullable`1<Int32Rect> dirtyRect);
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
}
internal interface System.Windows.Interop.IStylusInputProvider {
    public abstract virtual IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
public interface System.Windows.Interop.IWin32Window {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
internal enum System.Windows.Interop.OperatingSystemVersion : Enum {
    public int value__;
    public static OperatingSystemVersion WindowsXPSP2;
    public static OperatingSystemVersion WindowsXPSP3;
    public static OperatingSystemVersion WindowsVista;
    public static OperatingSystemVersion WindowsVistaSP1;
    public static OperatingSystemVersion WindowsVistaSP2;
    public static OperatingSystemVersion Windows7;
    public static OperatingSystemVersion Windows7SP1;
    public static OperatingSystemVersion Windows8;
    public static OperatingSystemVersion Windows8Point1;
    public static OperatingSystemVersion Windows10;
    public static OperatingSystemVersion Windows10TH2;
    public static OperatingSystemVersion Windows10RS1;
    public static OperatingSystemVersion Windows10RS2;
    public static OperatingSystemVersion Windows10RS3;
}
internal static class System.Windows.Interop.OperatingSystemVersionCheck : object {
    internal static bool IsVersionOrLater(OperatingSystemVersion version);
}
internal static class System.Windows.Interop.OSVersionHelper : object {
    internal static bool IsOsWindows10RS3OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS2OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS1OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH2OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH1OrGreater { get; internal set; }
    internal static bool IsOsWindows10OrGreater { get; internal set; }
    internal static bool IsOsWindows8Point1OrGreater { get; internal set; }
    internal static bool IsOsWindows8OrGreater { get; internal set; }
    internal static bool IsOsWindows7SP1OrGreater { get; internal set; }
    internal static bool IsOsWindows7OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaOrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP3OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPOrGreater { get; internal set; }
    internal static bool IsOsWindowsServer { get; internal set; }
    [SecurityCriticalAttribute]
private static OSVersionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8Point1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8Point1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7SP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7SP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsServer();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsServer(bool value);
    internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer);
    internal static OperatingSystemVersion GetOsVersion();
}
internal enum System.Windows.Interop.RenderingMode : Enum {
    public int value__;
    public static RenderingMode Default;
    public static RenderingMode Software;
    public static RenderingMode Hardware;
    public static RenderingMode HardwareReference;
    public static RenderingMode DisableMultimonDisplayClipping;
    public static RenderingMode IsDisableMultimonDisplayClippingValid;
}
public enum System.Windows.Interop.RenderMode : Enum {
    public int value__;
    public static RenderMode Default;
    public static RenderMode SoftwareOnly;
}
public class System.Windows.KeySplineConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptor, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.KeyTimeConverter : TypeConverter {
    private static KeyTimeConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.LayoutEventList : object {
    internal int Count { get; }
    internal ListItem Add(object target);
    internal void Remove(ListItem t);
    internal ListItem[] CopyToArray();
    internal int get_Count();
}
public enum System.Windows.LineBreakCondition : Enum {
    public int value__;
    public static LineBreakCondition BreakDesired;
    public static LineBreakCondition BreakPossible;
    public static LineBreakCondition BreakRestrained;
    public static LineBreakCondition BreakAlways;
}
[AttributeUsageAttribute("412")]
public class System.Windows.LocalizabilityAttribute : Attribute {
    public LocalizationCategory Category { get; }
    public Readability Readability { get; public set; }
    public Modifiability Modifiability { get; public set; }
    public LocalizabilityAttribute(LocalizationCategory category);
    public LocalizationCategory get_Category();
    public Readability get_Readability();
    public void set_Readability(Readability value);
    public Modifiability get_Modifiability();
    public void set_Modifiability(Modifiability value);
}
public enum System.Windows.LocalizationCategory : Enum {
    public int value__;
    public static LocalizationCategory None;
    public static LocalizationCategory Text;
    public static LocalizationCategory Title;
    public static LocalizationCategory Label;
    public static LocalizationCategory Button;
    public static LocalizationCategory CheckBox;
    public static LocalizationCategory ComboBox;
    public static LocalizationCategory ListBox;
    public static LocalizationCategory Menu;
    public static LocalizationCategory RadioButton;
    public static LocalizationCategory ToolTip;
    public static LocalizationCategory Hyperlink;
    public static LocalizationCategory TextFlow;
    public static LocalizationCategory XmlData;
    public static LocalizationCategory Font;
    public static LocalizationCategory Inherit;
    public static LocalizationCategory Ignore;
    public static LocalizationCategory NeverLocalize;
}
public interface System.Windows.Markup.IAddChild {
    public abstract virtual void AddChild(object value);
    public abstract virtual void AddText(string text);
}
internal interface System.Windows.Markup.IAddChildInternal {
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
internal interface System.Windows.Markup.IProvidePropertyFallback {
    public abstract virtual bool CanProvidePropertyFallback(string property);
    public abstract virtual object ProvidePropertyFallback(string property, Exception cause);
}
internal static class System.Windows.Markup.XamlCoreSerializerUtil : object {
    private static XamlCoreSerializerUtil();
    internal static void ThrowIfIAddChildInternal(object o);
    internal static void ThrowIfNonWhiteSpaceInAddText(string s);
}
[TypeConverterAttribute("System.Windows.Markup.XmlLanguageConverter")]
public class System.Windows.Markup.XmlLanguage : object {
    public static XmlLanguage Empty { get; }
    public string IetfLanguageTag { get; }
    internal MatchingLanguageCollection MatchingLanguages { get; }
    private static XmlLanguage();
    public static XmlLanguage get_Empty();
    public static XmlLanguage GetLanguage(string ietfLanguageTag);
    public string get_IetfLanguageTag();
    public virtual string ToString();
    public CultureInfo GetEquivalentCulture();
    public CultureInfo GetSpecificCulture();
    [FriendAccessAllowedAttribute]
internal CultureInfo GetCompatibleCulture();
    [FriendAccessAllowedAttribute]
internal bool RangeIncludes(XmlLanguage language);
    internal bool RangeIncludes(CultureInfo culture);
    internal int GetSpecificity();
    internal MatchingLanguageCollection get_MatchingLanguages();
}
public class System.Windows.Markup.XmlLanguageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public enum System.Windows.Media.AlignmentX : Enum {
    public int value__;
    public static AlignmentX Left;
    public static AlignmentX Center;
    public static AlignmentX Right;
}
public enum System.Windows.Media.AlignmentY : Enum {
    public int value__;
    public static AlignmentY Top;
    public static AlignmentY Center;
    public static AlignmentY Bottom;
}
internal class System.Windows.Media.AncestorChangedEventArgs : object {
    public DependencyObject Ancestor { get; }
    public DependencyObject OldParent { get; }
    public AncestorChangedEventArgs(DependencyObject subRoot, DependencyObject oldParent);
    public DependencyObject get_Ancestor();
    public DependencyObject get_OldParent();
}
public abstract class System.Windows.Media.Animation.Animatable : Freezable {
    public bool HasAnimatedProperties { get; }
    private static Animatable();
    public Animatable Clone();
    internal void PropertyChanged(DependencyProperty dp);
    internal virtual void AddRefOnChannelAnimations(Channel channel);
    internal virtual void ReleaseOnChannelAnimations(Channel channel);
    internal static DependencyProperty RegisterProperty(string name, Type propertyType, Type ownerType, object defaultValue, PropertyChangedCallback changed, ValidateValueCallback validate, bool isIndependentlyAnimated, CoerceValueCallback coerced);
    internal void AddRefResource(IResource resource, Channel channel);
    internal void ReleaseResource(IResource resource, Channel channel);
    protected virtual bool FreezeCore(bool isChecking);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    internal ResourceHandle GetAnimationResourceHandle(DependencyProperty dp, Channel channel);
    internal WeakReference GetWeakReference();
    internal bool IsBaseValueDefault(DependencyProperty dp);
    internal void RegisterForAsyncUpdateResource();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal void InternalWritePreamble();
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeStoredWeakReference(DependencyObject target);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
}
public class System.Windows.Media.Animation.AnimationClock : Clock {
    public AnimationTimeline Timeline { get; }
    internal bool NeedsTicksWhenActive { get; }
    protected internal AnimationClock(AnimationTimeline animation);
    public AnimationTimeline get_Timeline();
    public object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue);
    internal virtual bool get_NeedsTicksWhenActive();
}
internal abstract class System.Windows.Media.Animation.AnimationClockResource : object {
    protected AnimationClock _animationClock;
    public AnimationClock AnimationClock { get; }
    protected bool IsResourceInvalid { get; protected set; }
    protected ResourceType ResourceType { get; }
    protected AnimationClockResource(AnimationClock animationClock);
    public AnimationClock get_AnimationClock();
    protected void OnChanged(object sender, EventArgs args);
    internal virtual void PropagateChangedHandlersCore(EventHandler handler, bool adding);
    protected abstract virtual void UpdateResource(ResourceHandle handle, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    protected bool get_IsResourceInvalid();
    protected void set_IsResourceInvalid(bool value);
    protected abstract virtual ResourceType get_ResourceType();
}
public class System.Windows.Media.Animation.AnimationException : SystemException {
    public AnimationClock Clock { get; }
    public DependencyProperty Property { get; }
    public IAnimatable Target { get; }
    internal AnimationException(AnimationClock clock, DependencyProperty property, IAnimatable target, string message, Exception innerException);
    private AnimationException(SerializationInfo info, StreamingContext context);
    public AnimationClock get_Clock();
    public DependencyProperty get_Property();
    public IAnimatable get_Target();
}
internal class System.Windows.Media.Animation.AnimationLayer : object {
    internal AnimationLayer(AnimationStorage ownerStorage);
    internal void ApplyAnimationClocks(IList`1<AnimationClock> newAnimationClocks, HandoffBehavior handoffBehavior, object defaultDestinationValue);
    internal object GetCurrentValue(object defaultDestinationValue);
}
internal class System.Windows.Media.Animation.AnimationStorage : object {
    protected WeakReference _dependencyObject;
    protected DependencyProperty _dependencyProperty;
    protected FrugalObjectList`1<AnimationClock> _animationClocks;
    internal object _baseValue;
    internal bool IsEmpty { get; }
    private static AnimationStorage();
    internal bool get_IsEmpty();
    internal void AttachAnimationClock(AnimationClock animationClock, EventHandler removeRequestedHandler);
    internal void DetachAnimationClock(AnimationClock animationClock, EventHandler removeRequestedHandler);
    internal void Initialize(DependencyObject d, DependencyProperty dp);
    internal void RemoveLayer(AnimationLayer layer);
    internal void WritePostscript();
    internal void EvaluateAnimatedValue(PropertyMetadata metadata, EffectiveValueEntry& entry);
    internal static void ApplyAnimationClock(DependencyObject d, DependencyProperty dp, AnimationClock animationClock, HandoffBehavior handoffBehavior);
    [FriendAccessAllowedAttribute]
internal static void ApplyAnimationClocks(DependencyObject d, DependencyProperty dp, IList`1<AnimationClock> animationClocks, HandoffBehavior handoffBehavior);
    [FriendAccessAllowedAttribute]
internal static void ApplyAnimationClocksToLayer(DependencyObject d, DependencyProperty dp, IList`1<AnimationClock> animationClocks, HandoffBehavior handoffBehavior, long propertyTriggerLayerIndex);
    internal static void BeginAnimation(DependencyObject d, DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    internal static AnimationStorage EnsureStorage(DependencyObject d, DependencyProperty dp);
    internal static object GetCurrentPropertyValue(AnimationStorage storage, DependencyObject d, DependencyProperty dp, PropertyMetadata metadata, object baseValue);
    [FriendAccessAllowedAttribute]
internal static bool IsPropertyAnimatable(DependencyObject d, DependencyProperty dp);
    internal static bool IsAnimationValid(DependencyProperty dp, AnimationTimeline animation);
    [FriendAccessAllowedAttribute]
internal static bool IsAnimationClockValid(DependencyProperty dp, AnimationClock animation);
    internal static FrugalMap GetAnimatedPropertiesMap(DependencyObject d);
    internal static AnimationStorage GetStorage(DependencyObject d, DependencyProperty dp);
}
public abstract class System.Windows.Media.Animation.AnimationTimeline : Timeline {
    public static DependencyProperty IsAdditiveProperty;
    public static DependencyProperty IsCumulativeProperty;
    public Type TargetPropertyType { get; }
    public bool IsDestinationDefault { get; }
    private static AnimationTimeline();
    public AnimationTimeline Clone();
    protected internal virtual Clock AllocateClock();
    public AnimationClock CreateClock();
    public virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public abstract virtual Type get_TargetPropertyType();
    public virtual bool get_IsDestinationDefault();
}
internal enum System.Windows.Media.Animation.AnimationType : Enum {
    public byte value__;
    public static AnimationType Automatic;
    public static AnimationType From;
    public static AnimationType To;
    public static AnimationType By;
    public static AnimationType FromTo;
    public static AnimationType FromBy;
}
public class System.Windows.Media.Animation.BackEase : EasingFunctionBase {
    public static DependencyProperty AmplitudeProperty;
    public double Amplitude { get; public set; }
    private static BackEase();
    public double get_Amplitude();
    public void set_Amplitude(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Animation.BooleanAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public BooleanAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public bool GetCurrentValue(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames : BooleanAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public BooleanKeyFrameCollection KeyFrames { get; public set; }
    public BooleanAnimationUsingKeyFrames Clone();
    public BooleanAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public BooleanKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(BooleanKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.BooleanKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public bool Value { get; public set; }
    protected BooleanKeyFrame(bool value);
    protected BooleanKeyFrame(bool value, KeyTime keyTime);
    private static BooleanKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public bool get_Value();
    public void set_Value(bool value);
    public bool InterpolateValue(bool baseValue, double keyFrameProgress);
    protected abstract virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.BooleanKeyFrameCollection : Freezable {
    public static BooleanKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public BooleanKeyFrame Item { get; public set; }
    public static BooleanKeyFrameCollection get_Empty();
    public BooleanKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(BooleanKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(BooleanKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(BooleanKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(BooleanKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, BooleanKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(BooleanKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public BooleanKeyFrame get_Item(int index);
    public void set_Item(int index, BooleanKeyFrame value);
}
public class System.Windows.Media.Animation.BounceEase : EasingFunctionBase {
    public static DependencyProperty BouncesProperty;
    public static DependencyProperty BouncinessProperty;
    public int Bounces { get; public set; }
    public double Bounciness { get; public set; }
    private static BounceEase();
    public int get_Bounces();
    public void set_Bounces(int value);
    public double get_Bounciness();
    public void set_Bounciness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ByteAnimation : ByteAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<byte> From { get; public set; }
    public Nullable`1<byte> To { get; public set; }
    public Nullable`1<byte> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ByteAnimation();
    public ByteAnimation(byte toValue, Duration duration);
    public ByteAnimation(byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<byte> get_From();
    public void set_From(Nullable`1<byte> value);
    public Nullable`1<byte> get_To();
    public void set_To(Nullable`1<byte> value);
    public Nullable`1<byte> get_By();
    public void set_By(Nullable`1<byte> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ByteAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ByteAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public byte GetCurrentValue(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ByteAnimationUsingKeyFrames : ByteAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ByteKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ByteAnimationUsingKeyFrames Clone();
    public ByteAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ByteKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ByteKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ByteKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public byte Value { get; public set; }
    protected ByteKeyFrame(byte value);
    protected ByteKeyFrame(byte value, KeyTime keyTime);
    private static ByteKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public byte get_Value();
    public void set_Value(byte value);
    public byte InterpolateValue(byte baseValue, double keyFrameProgress);
    protected abstract virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ByteKeyFrameCollection : Freezable {
    public static ByteKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ByteKeyFrame Item { get; public set; }
    public static ByteKeyFrameCollection get_Empty();
    public ByteKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ByteKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ByteKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ByteKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ByteKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ByteKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ByteKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ByteKeyFrame get_Item(int index);
    public void set_Item(int index, ByteKeyFrame value);
}
public abstract class System.Windows.Media.Animation.CharAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public CharAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public char GetCurrentValue(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.CharAnimationUsingKeyFrames : CharAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public CharKeyFrameCollection KeyFrames { get; public set; }
    public CharAnimationUsingKeyFrames Clone();
    public CharAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public CharKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(CharKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.CharKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public char Value { get; public set; }
    protected CharKeyFrame(char value);
    protected CharKeyFrame(char value, KeyTime keyTime);
    private static CharKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public char get_Value();
    public void set_Value(char value);
    public char InterpolateValue(char baseValue, double keyFrameProgress);
    protected abstract virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.CharKeyFrameCollection : Freezable {
    public static CharKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public CharKeyFrame Item { get; public set; }
    public static CharKeyFrameCollection get_Empty();
    public CharKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CharKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(CharKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(CharKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(CharKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, CharKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(CharKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CharKeyFrame get_Item(int index);
    public void set_Item(int index, CharKeyFrame value);
}
public class System.Windows.Media.Animation.CircleEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.Clock : DispatcherObject {
    internal SyncData _syncData;
    internal Nullable`1<TimeSpan> _beginTime;
    internal Nullable`1<TimeSpan> _nextTickNeededTime;
    internal Duration _resolvedDuration;
    internal Duration _currentDuration;
    internal Timeline _timeline;
    internal TimeManager _timeManager;
    internal ClockGroup _parent;
    internal int _childIndex;
    internal int _depth;
    internal bool CanGrow { get; }
    internal bool CanSlip { get; }
    public ClockController Controller { get; }
    public Nullable`1<int> CurrentIteration { get; }
    public Nullable`1<double> CurrentGlobalSpeed { get; }
    public Nullable`1<double> CurrentProgress { get; }
    public ClockState CurrentState { get; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool HasControllableRoot { get; }
    public bool IsPaused { get; }
    public Duration NaturalDuration { get; }
    public Clock Parent { get; }
    public Timeline Timeline { get; }
    protected TimeSpan CurrentGlobalTime { get; }
    internal Duration CurrentDuration { get; }
    internal int Depth { get; }
    internal Duration EndOfActivePeriod { get; }
    internal Clock FirstChild { get; }
    internal ClockState InternalCurrentClockState { get; internal set; }
    internal Nullable`1<double> InternalCurrentGlobalSpeed { get; internal set; }
    internal Nullable`1<int> InternalCurrentIteration { get; internal set; }
    internal Nullable`1<double> InternalCurrentProgress { get; internal set; }
    internal Nullable`1<TimeSpan> InternalNextTickNeededTime { get; internal set; }
    internal ClockGroup InternalParent { get; }
    internal Duration ResolvedDuration { get; }
    internal Clock NextSibling { get; }
    internal WeakReference WeakReference { get; }
    internal Nullable`1<int> DesiredFrameRate { get; }
    internal bool CompletedEventRaised { get; internal set; }
    internal bool CurrentGlobalSpeedInvalidatedEventRaised { get; internal set; }
    internal bool CurrentStateInvalidatedEventRaised { get; internal set; }
    internal bool CurrentTimeInvalidatedEventRaised { get; internal set; }
    internal bool HasResolvedDuration { get; internal set; }
    internal bool IsBackwardsProgressingGlobal { get; internal set; }
    internal bool IsInEventQueue { get; internal set; }
    internal bool IsInteractivelyPaused { get; internal set; }
    internal bool IsInteractivelyStopped { get; internal set; }
    internal bool IsRoot { get; internal set; }
    internal bool IsTimeManager { get; internal set; }
    internal bool NeedsPostfixTraversal { get; internal set; }
    internal bool NeedsTicksWhenActive { get; internal set; }
    internal bool PauseStateChangedDuringTick { get; internal set; }
    internal bool PendingInteractivePause { get; internal set; }
    internal bool PendingInteractiveRemove { get; internal set; }
    internal bool PendingInteractiveResume { get; internal set; }
    internal bool PendingInteractiveStop { get; internal set; }
    internal bool RemoveRequestedEventRaised { get; internal set; }
    internal bool HasDescendantsWithUnresolvedDuration { get; internal set; }
    protected internal Clock(Timeline timeline);
    private static Clock();
    internal bool get_CanGrow();
    internal bool get_CanSlip();
    public ClockController get_Controller();
    public Nullable`1<int> get_CurrentIteration();
    public Nullable`1<double> get_CurrentGlobalSpeed();
    public Nullable`1<double> get_CurrentProgress();
    public ClockState get_CurrentState();
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_HasControllableRoot();
    public bool get_IsPaused();
    public Duration get_NaturalDuration();
    public Clock get_Parent();
    public Timeline get_Timeline();
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    protected virtual void DiscontinuousTimeMovement();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void SpeedChanged();
    protected virtual void Stopped();
    protected TimeSpan get_CurrentGlobalTime();
    internal virtual void AddNullPointToCurrentIntervals();
    internal static Clock AllocateClock(Timeline timeline, bool hasControllableRoot);
    internal virtual void BuildClockSubTreeFromTimeline(Timeline timeline, bool hasControllableRoot);
    internal static Clock BuildClockTreeFromTimeline(Timeline rootTimeline, bool hasControllableRoot);
    internal virtual void ClearCurrentIntervalsToNull();
    internal void ClipNextTickByParent();
    internal virtual void ComputeCurrentIntervals(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal virtual void ComputeCurrentFillInterval(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal void ComputeLocalState();
    internal virtual Duration get_CurrentDuration();
    internal void InternalBegin();
    internal double InternalGetSpeedRatio();
    internal void InternalPause();
    internal void InternalRemove();
    internal void InternalResume();
    internal void InternalSeek(TimeSpan destination);
    internal void InternalSeekAlignedToLastTick(TimeSpan destination);
    internal void InternalSetSpeedRatio(double ratio);
    internal void InternalSkipToFill();
    internal void InternalStop();
    internal void RaiseAccumulatedEvents();
    internal void RaiseCompleted();
    internal void RaiseCurrentGlobalSpeedInvalidated();
    internal void RaiseCurrentStateInvalidated();
    internal void RaiseCurrentTimeInvalidated();
    internal void RaiseRemoveRequested();
    internal void ResetCachedStateToStopped();
    internal virtual void ResetNodesWithSlip();
    internal virtual void UpdateDescendantsWithUnresolvedDuration();
    internal int get_Depth();
    internal Duration get_EndOfActivePeriod();
    internal virtual Clock get_FirstChild();
    internal ClockState get_InternalCurrentClockState();
    internal void set_InternalCurrentClockState(ClockState value);
    internal Nullable`1<double> get_InternalCurrentGlobalSpeed();
    internal void set_InternalCurrentGlobalSpeed(Nullable`1<double> value);
    internal Nullable`1<int> get_InternalCurrentIteration();
    internal void set_InternalCurrentIteration(Nullable`1<int> value);
    internal Nullable`1<double> get_InternalCurrentProgress();
    internal void set_InternalCurrentProgress(Nullable`1<double> value);
    internal Nullable`1<TimeSpan> get_InternalNextTickNeededTime();
    internal void set_InternalNextTickNeededTime(Nullable`1<TimeSpan> value);
    internal ClockGroup get_InternalParent();
    internal Duration get_ResolvedDuration();
    internal Clock get_NextSibling();
    internal WeakReference get_WeakReference();
    internal Nullable`1<int> get_DesiredFrameRate();
    internal bool get_CompletedEventRaised();
    internal void set_CompletedEventRaised(bool value);
    internal bool get_CurrentGlobalSpeedInvalidatedEventRaised();
    internal void set_CurrentGlobalSpeedInvalidatedEventRaised(bool value);
    internal bool get_CurrentStateInvalidatedEventRaised();
    internal void set_CurrentStateInvalidatedEventRaised(bool value);
    internal bool get_CurrentTimeInvalidatedEventRaised();
    internal void set_CurrentTimeInvalidatedEventRaised(bool value);
    internal bool get_HasResolvedDuration();
    internal void set_HasResolvedDuration(bool value);
    internal bool get_IsBackwardsProgressingGlobal();
    internal void set_IsBackwardsProgressingGlobal(bool value);
    internal bool get_IsInEventQueue();
    internal void set_IsInEventQueue(bool value);
    internal bool get_IsInteractivelyPaused();
    internal void set_IsInteractivelyPaused(bool value);
    internal bool get_IsInteractivelyStopped();
    internal void set_IsInteractivelyStopped(bool value);
    internal bool get_IsRoot();
    internal void set_IsRoot(bool value);
    internal bool get_IsTimeManager();
    internal void set_IsTimeManager(bool value);
    internal bool get_NeedsPostfixTraversal();
    internal void set_NeedsPostfixTraversal(bool value);
    internal virtual bool get_NeedsTicksWhenActive();
    internal virtual void set_NeedsTicksWhenActive(bool value);
    internal bool get_PauseStateChangedDuringTick();
    internal void set_PauseStateChangedDuringTick(bool value);
    internal bool get_PendingInteractivePause();
    internal void set_PendingInteractivePause(bool value);
    internal bool get_PendingInteractiveRemove();
    internal void set_PendingInteractiveRemove(bool value);
    internal bool get_PendingInteractiveResume();
    internal void set_PendingInteractiveResume(bool value);
    internal bool get_PendingInteractiveStop();
    internal void set_PendingInteractiveStop(bool value);
    internal bool get_RemoveRequestedEventRaised();
    internal void set_RemoveRequestedEventRaised(bool value);
    internal bool get_HasDescendantsWithUnresolvedDuration();
    internal void set_HasDescendantsWithUnresolvedDuration(bool value);
    internal void ApplyDesiredFrameRateToGlobalTime();
    internal void ApplyDesiredFrameRateToNextTick();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ClockCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Clock Item { get; }
    internal ClockCollection(Clock owner);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void Add(Clock item);
    public sealed virtual bool Remove(Clock item);
    public sealed virtual bool Contains(Clock item);
    public sealed virtual void CopyTo(Clock[] array, int index);
    private sealed virtual override IEnumerator`1<Clock> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Clock>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public static bool Equals(ClockCollection objA, ClockCollection objB);
    public static bool op_Equality(ClockCollection objA, ClockCollection objB);
    public static bool op_Inequality(ClockCollection objA, ClockCollection objB);
    public virtual int GetHashCode();
    public Clock get_Item(int index);
}
public class System.Windows.Media.Animation.ClockController : DispatcherObject {
    public Clock Clock { get; }
    public double SpeedRatio { get; public set; }
    internal ClockController(Clock owner);
    public void Begin();
    public void SkipToFill();
    public void Pause();
    public void Resume();
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void Stop();
    public void Remove();
    public Clock get_Clock();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
}
public class System.Windows.Media.Animation.ClockGroup : Clock {
    public TimelineGroup Timeline { get; }
    public ClockCollection Children { get; }
    internal List`1<Clock> InternalChildren { get; }
    internal List`1<WeakReference> InternalRootChildren { get; }
    internal Clock FirstChild { get; }
    internal Duration CurrentDuration { get; }
    internal bool RootHasChildren { get; }
    internal TimeIntervalCollection CurrentIntervals { get; }
    protected internal ClockGroup(TimelineGroup timelineGroup);
    public TimelineGroup get_Timeline();
    public ClockCollection get_Children();
    internal List`1<Clock> get_InternalChildren();
    internal List`1<WeakReference> get_InternalRootChildren();
    internal virtual void BuildClockSubTreeFromTimeline(Timeline timeline, bool hasControllableRoot);
    internal virtual Clock get_FirstChild();
    internal int GetMaxDesiredFrameRate();
    internal void ComputeTreeState();
    internal void ComputeTreeStateRoot();
    internal virtual Duration get_CurrentDuration();
    internal void MakeRoot(TimeManager timeManager);
    internal virtual void ResetNodesWithSlip();
    internal void RootActivate();
    internal void RootCleanChildren();
    internal bool get_RootHasChildren();
    internal void RootDisable();
    internal virtual void UpdateDescendantsWithUnresolvedDuration();
    internal virtual void ClearCurrentIntervalsToNull();
    internal virtual void AddNullPointToCurrentIntervals();
    internal virtual void ComputeCurrentIntervals(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal virtual void ComputeCurrentFillInterval(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal TimeIntervalCollection get_CurrentIntervals();
}
public enum System.Windows.Media.Animation.ClockState : Enum {
    public int value__;
    public static ClockState Active;
    public static ClockState Filling;
    public static ClockState Stopped;
}
public class System.Windows.Media.Animation.ColorAnimation : ColorAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Color> From { get; public set; }
    public Nullable`1<Color> To { get; public set; }
    public Nullable`1<Color> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ColorAnimation();
    public ColorAnimation(Color toValue, Duration duration);
    public ColorAnimation(Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Color> get_From();
    public void set_From(Nullable`1<Color> value);
    public Nullable`1<Color> get_To();
    public void set_To(Nullable`1<Color> value);
    public Nullable`1<Color> get_By();
    public void set_By(Nullable`1<Color> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ColorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ColorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Color GetCurrentValue(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ColorAnimationUsingKeyFrames : ColorAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ColorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ColorAnimationUsingKeyFrames Clone();
    public ColorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ColorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ColorKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.ColorIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.ColorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Color Value { get; public set; }
    protected ColorKeyFrame(Color value);
    protected ColorKeyFrame(Color value, KeyTime keyTime);
    private static ColorKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Color get_Value();
    public void set_Value(Color value);
    public Color InterpolateValue(Color baseValue, double keyFrameProgress);
    protected abstract virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ColorKeyFrameCollection : Freezable {
    public static ColorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ColorKeyFrame Item { get; public set; }
    public static ColorKeyFrameCollection get_Empty();
    public ColorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ColorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ColorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ColorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ColorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ColorKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ColorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ColorKeyFrame get_Item(int index);
    public void set_Item(int index, ColorKeyFrame value);
}
public class System.Windows.Media.Animation.CubicEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.DecimalAnimation : DecimalAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<decimal> From { get; public set; }
    public Nullable`1<decimal> To { get; public set; }
    public Nullable`1<decimal> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DecimalAnimation();
    public DecimalAnimation(decimal toValue, Duration duration);
    public DecimalAnimation(decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<decimal> get_From();
    public void set_From(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_To();
    public void set_To(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_By();
    public void set_By(Nullable`1<decimal> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.DecimalAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public DecimalAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public decimal GetCurrentValue(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames : DecimalAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DecimalKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DecimalAnimationUsingKeyFrames Clone();
    public DecimalAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DecimalKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DecimalKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.DecimalKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public decimal Value { get; public set; }
    protected DecimalKeyFrame(decimal value);
    protected DecimalKeyFrame(decimal value, KeyTime keyTime);
    private static DecimalKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public decimal InterpolateValue(decimal baseValue, double keyFrameProgress);
    protected abstract virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DecimalKeyFrameCollection : Freezable {
    public static DecimalKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DecimalKeyFrame Item { get; public set; }
    public static DecimalKeyFrameCollection get_Empty();
    public DecimalKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DecimalKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DecimalKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DecimalKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DecimalKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DecimalKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DecimalKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DecimalKeyFrame get_Item(int index);
    public void set_Item(int index, DecimalKeyFrame value);
}
public class System.Windows.Media.Animation.DiscreteBooleanKeyFrame : BooleanKeyFrame {
    public DiscreteBooleanKeyFrame(bool value);
    public DiscreteBooleanKeyFrame(bool value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteByteKeyFrame : ByteKeyFrame {
    public DiscreteByteKeyFrame(byte value);
    public DiscreteByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteCharKeyFrame : CharKeyFrame {
    public DiscreteCharKeyFrame(char value);
    public DiscreteCharKeyFrame(char value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteColorKeyFrame : ColorKeyFrame {
    public DiscreteColorKeyFrame(Color value);
    public DiscreteColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDecimalKeyFrame : DecimalKeyFrame {
    public DiscreteDecimalKeyFrame(decimal value);
    public DiscreteDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDoubleKeyFrame : DoubleKeyFrame {
    public DiscreteDoubleKeyFrame(double value);
    public DiscreteDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt16KeyFrame : Int16KeyFrame {
    public DiscreteInt16KeyFrame(short value);
    public DiscreteInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt32KeyFrame : Int32KeyFrame {
    public DiscreteInt32KeyFrame(int value);
    public DiscreteInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt64KeyFrame : Int64KeyFrame {
    public DiscreteInt64KeyFrame(long value);
    public DiscreteInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteMatrixKeyFrame : MatrixKeyFrame {
    public DiscreteMatrixKeyFrame(Matrix value);
    public DiscreteMatrixKeyFrame(Matrix value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteObjectKeyFrame : ObjectKeyFrame {
    public DiscreteObjectKeyFrame(object value);
    public DiscreteObjectKeyFrame(object value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePoint3DKeyFrame : Point3DKeyFrame {
    public DiscretePoint3DKeyFrame(Point3D value);
    public DiscretePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePointKeyFrame : PointKeyFrame {
    public DiscretePointKeyFrame(Point value);
    public DiscretePointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteQuaternionKeyFrame : QuaternionKeyFrame {
    public DiscreteQuaternionKeyFrame(Quaternion value);
    public DiscreteQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRectKeyFrame : RectKeyFrame {
    public DiscreteRectKeyFrame(Rect value);
    public DiscreteRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRotation3DKeyFrame : Rotation3DKeyFrame {
    public DiscreteRotation3DKeyFrame(Rotation3D value);
    public DiscreteRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSingleKeyFrame : SingleKeyFrame {
    public DiscreteSingleKeyFrame(float value);
    public DiscreteSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSizeKeyFrame : SizeKeyFrame {
    public DiscreteSizeKeyFrame(Size value);
    public DiscreteSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteStringKeyFrame : StringKeyFrame {
    public DiscreteStringKeyFrame(string value);
    public DiscreteStringKeyFrame(string value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVector3DKeyFrame : Vector3DKeyFrame {
    public DiscreteVector3DKeyFrame(Vector3D value);
    public DiscreteVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVectorKeyFrame : VectorKeyFrame {
    public DiscreteVectorKeyFrame(Vector value);
    public DiscreteVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DoubleAnimation : DoubleAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<double> From { get; public set; }
    public Nullable`1<double> To { get; public set; }
    public Nullable`1<double> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DoubleAnimation();
    public DoubleAnimation(double toValue, Duration duration);
    public DoubleAnimation(double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation(double fromValue, double toValue, Duration duration);
    public DoubleAnimation(double fromValue, double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<double> get_From();
    public void set_From(Nullable`1<double> value);
    public Nullable`1<double> get_To();
    public void set_To(Nullable`1<double> value);
    public Nullable`1<double> get_By();
    public void set_By(Nullable`1<double> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.DoubleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public DoubleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public double GetCurrentValue(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.DoubleAnimationClockResource : AnimationClockResource {
    public double BaseValue { get; }
    public double CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public DoubleAnimationClockResource(double baseValue, AnimationClock animationClock);
    public double get_BaseValue();
    public double get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames : DoubleAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DoubleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public DoubleAnimationUsingKeyFrames Clone();
    public DoubleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DoubleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DoubleKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public class System.Windows.Media.Animation.DoubleAnimationUsingPath : DoubleAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public static DependencyProperty SourceProperty;
    public PathGeometry PathGeometry { get; public set; }
    public PathAnimationSource Source { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DoubleAnimationUsingPath();
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PathAnimationSource get_Source();
    public void set_Source(PathAnimationSource value);
    public DoubleAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    internal static double CalculateAngleFromTangentVector(double x, double y);
}
internal class System.Windows.Media.Animation.DoubleIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.DoubleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public double Value { get; public set; }
    protected DoubleKeyFrame(double value);
    protected DoubleKeyFrame(double value, KeyTime keyTime);
    private static DoubleKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public double get_Value();
    public void set_Value(double value);
    public double InterpolateValue(double baseValue, double keyFrameProgress);
    protected abstract virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DoubleKeyFrameCollection : Freezable {
    public static DoubleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DoubleKeyFrame Item { get; public set; }
    public static DoubleKeyFrameCollection get_Empty();
    public DoubleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DoubleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DoubleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DoubleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DoubleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DoubleKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DoubleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DoubleKeyFrame get_Item(int index);
    public void set_Item(int index, DoubleKeyFrame value);
}
public class System.Windows.Media.Animation.EasingByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingByteKeyFrame(byte value);
    public EasingByteKeyFrame(byte value, KeyTime keyTime);
    public EasingByteKeyFrame(byte value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingByteKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingColorKeyFrame(Color value);
    public EasingColorKeyFrame(Color value, KeyTime keyTime);
    public EasingColorKeyFrame(Color value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingColorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDecimalKeyFrame(decimal value);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingDecimalKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDoubleKeyFrame(double value);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingDoubleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public abstract class System.Windows.Media.Animation.EasingFunctionBase : Freezable {
    public static DependencyProperty EasingModeProperty;
    public EasingMode EasingMode { get; public set; }
    private static EasingFunctionBase();
    public EasingMode get_EasingMode();
    public void set_EasingMode(EasingMode value);
    public sealed virtual double Ease(double normalizedTime);
    protected abstract virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.EasingInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt16KeyFrame(short value);
    public EasingInt16KeyFrame(short value, KeyTime keyTime);
    public EasingInt16KeyFrame(short value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt16KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt32KeyFrame(int value);
    public EasingInt32KeyFrame(int value, KeyTime keyTime);
    public EasingInt32KeyFrame(int value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt32KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt64KeyFrame(long value);
    public EasingInt64KeyFrame(long value, KeyTime keyTime);
    public EasingInt64KeyFrame(long value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt64KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public enum System.Windows.Media.Animation.EasingMode : Enum {
    public int value__;
    public static EasingMode EaseIn;
    public static EasingMode EaseOut;
    public static EasingMode EaseInOut;
}
public class System.Windows.Media.Animation.EasingPoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPoint3DKeyFrame(Point3D value);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingPoint3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingPointKeyFrame : PointKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPointKeyFrame(Point value);
    public EasingPointKeyFrame(Point value, KeyTime keyTime);
    public EasingPointKeyFrame(Point value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingPointKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty UseShortestPathProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public bool UseShortestPath { get; public set; }
    public EasingQuaternionKeyFrame(Quaternion value);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingQuaternionKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
}
public class System.Windows.Media.Animation.EasingRectKeyFrame : RectKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRectKeyFrame(Rect value);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingRectKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRotation3DKeyFrame(Rotation3D value);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingRotation3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSingleKeyFrame(float value);
    public EasingSingleKeyFrame(float value, KeyTime keyTime);
    public EasingSingleKeyFrame(float value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingSingleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSizeKeyFrame(Size value);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingSizeKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVector3DKeyFrame(Vector3D value);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingVector3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVectorKeyFrame(Vector value);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingVectorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.ElasticEase : EasingFunctionBase {
    public static DependencyProperty OscillationsProperty;
    public static DependencyProperty SpringinessProperty;
    public int Oscillations { get; public set; }
    public double Springiness { get; public set; }
    private static ElasticEase();
    public int get_Oscillations();
    public void set_Oscillations(int value);
    public double get_Springiness();
    public void set_Springiness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ExponentialEase : EasingFunctionBase {
    public static DependencyProperty ExponentProperty;
    public double Exponent { get; public set; }
    private static ExponentialEase();
    public double get_Exponent();
    public void set_Exponent(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Animation.FillBehavior : Enum {
    public int value__;
    public static FillBehavior HoldEnd;
    public static FillBehavior Stop;
}
public enum System.Windows.Media.Animation.HandoffBehavior : Enum {
    public int value__;
    public static HandoffBehavior SnapshotAndReplace;
    public static HandoffBehavior Compose;
}
internal static class System.Windows.Media.Animation.HandoffBehaviorEnum : object {
    [FriendAccessAllowedAttribute]
internal static bool IsDefined(HandoffBehavior handoffBehavior);
}
public interface System.Windows.Media.Animation.IAnimatable {
    public bool HasAnimatedProperties { get; }
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public abstract virtual bool get_HasAnimatedProperties();
    public abstract virtual object GetAnimationBaseValue(DependencyProperty dp);
}
internal interface System.Windows.Media.Animation.IClock {
    public TimeSpan CurrentTime { get; }
    public abstract virtual TimeSpan get_CurrentTime();
}
public interface System.Windows.Media.Animation.IEasingFunction {
    public abstract virtual double Ease(double normalizedTime);
}
public interface System.Windows.Media.Animation.IKeyFrame {
    public KeyTime KeyTime { get; public set; }
    public object Value { get; public set; }
    public abstract virtual KeyTime get_KeyTime();
    public abstract virtual void set_KeyTime(KeyTime value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public interface System.Windows.Media.Animation.IKeyFrameAnimation {
    public IList KeyFrames { get; public set; }
    public abstract virtual IList get_KeyFrames();
    public abstract virtual void set_KeyFrames(IList value);
}
internal abstract class System.Windows.Media.Animation.IndependentAnimationStorage : AnimationStorage {
    protected ResourcesUpdatedHandler _updateResourceHandler;
    protected MultiChannelResource _duceResource;
    protected ResourceType ResourceType { get; }
    protected abstract virtual void UpdateResourceCore(Channel channel);
    protected abstract virtual ResourceType get_ResourceType();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    internal void InvalidateResource();
    internal static ResourceHandle GetResourceHandle(DependencyObject d, DependencyProperty dp, Channel channel);
}
internal class System.Windows.Media.Animation.IndependentlyAnimatedPropertyMetadata : UIPropertyMetadata {
    internal IndependentlyAnimatedPropertyMetadata(object defaultValue);
    internal IndependentlyAnimatedPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    internal virtual PropertyMetadata CreateInstance();
}
public class System.Windows.Media.Animation.Int16Animation : Int16AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<short> From { get; public set; }
    public Nullable`1<short> To { get; public set; }
    public Nullable`1<short> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int16Animation();
    public Int16Animation(short toValue, Duration duration);
    public Int16Animation(short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation(short fromValue, short toValue, Duration duration);
    public Int16Animation(short fromValue, short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<short> get_From();
    public void set_From(Nullable`1<short> value);
    public Nullable`1<short> get_To();
    public void set_To(Nullable`1<short> value);
    public Nullable`1<short> get_By();
    public void set_By(Nullable`1<short> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int16AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int16AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public short GetCurrentValue(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int16AnimationUsingKeyFrames : Int16AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int16KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int16AnimationUsingKeyFrames Clone();
    public Int16AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int16KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int16KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int16KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public short Value { get; public set; }
    protected Int16KeyFrame(short value);
    protected Int16KeyFrame(short value, KeyTime keyTime);
    private static Int16KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public short get_Value();
    public void set_Value(short value);
    public short InterpolateValue(short baseValue, double keyFrameProgress);
    protected abstract virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int16KeyFrameCollection : Freezable {
    public static Int16KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int16KeyFrame Item { get; public set; }
    public static Int16KeyFrameCollection get_Empty();
    public Int16KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int16KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int16KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int16KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int16KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int16KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int16KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int16KeyFrame get_Item(int index);
    public void set_Item(int index, Int16KeyFrame value);
}
public class System.Windows.Media.Animation.Int32Animation : Int32AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<int> From { get; public set; }
    public Nullable`1<int> To { get; public set; }
    public Nullable`1<int> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int32Animation();
    public Int32Animation(int toValue, Duration duration);
    public Int32Animation(int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation(int fromValue, int toValue, Duration duration);
    public Int32Animation(int fromValue, int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<int> get_From();
    public void set_From(Nullable`1<int> value);
    public Nullable`1<int> get_To();
    public void set_To(Nullable`1<int> value);
    public Nullable`1<int> get_By();
    public void set_By(Nullable`1<int> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int32AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int32AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public int GetCurrentValue(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int32AnimationUsingKeyFrames : Int32AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int32KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int32AnimationUsingKeyFrames Clone();
    public Int32AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int32KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int32KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int32KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public int Value { get; public set; }
    protected Int32KeyFrame(int value);
    protected Int32KeyFrame(int value, KeyTime keyTime);
    private static Int32KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public int get_Value();
    public void set_Value(int value);
    public int InterpolateValue(int baseValue, double keyFrameProgress);
    protected abstract virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int32KeyFrameCollection : Freezable {
    public static Int32KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int32KeyFrame Item { get; public set; }
    public static Int32KeyFrameCollection get_Empty();
    public Int32KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int32KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int32KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int32KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int32KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int32KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int32KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int32KeyFrame get_Item(int index);
    public void set_Item(int index, Int32KeyFrame value);
}
public class System.Windows.Media.Animation.Int64Animation : Int64AnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<long> From { get; public set; }
    public Nullable`1<long> To { get; public set; }
    public Nullable`1<long> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int64Animation();
    public Int64Animation(long toValue, Duration duration);
    public Int64Animation(long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation(long fromValue, long toValue, Duration duration);
    public Int64Animation(long fromValue, long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<long> get_From();
    public void set_From(Nullable`1<long> value);
    public Nullable`1<long> get_To();
    public void set_To(Nullable`1<long> value);
    public Nullable`1<long> get_By();
    public void set_By(Nullable`1<long> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int64AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int64AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public long GetCurrentValue(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int64AnimationUsingKeyFrames : Int64AnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int64KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Int64AnimationUsingKeyFrames Clone();
    public Int64AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int64KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int64KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int64KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public long Value { get; public set; }
    protected Int64KeyFrame(long value);
    protected Int64KeyFrame(long value, KeyTime keyTime);
    private static Int64KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public long get_Value();
    public void set_Value(long value);
    public long InterpolateValue(long baseValue, double keyFrameProgress);
    protected abstract virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int64KeyFrameCollection : Freezable {
    public static Int64KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int64KeyFrame Item { get; public set; }
    public static Int64KeyFrameCollection get_Empty();
    public Int64KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int64KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int64KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int64KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int64KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int64KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int64KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int64KeyFrame get_Item(int index);
    public void set_Item(int index, Int64KeyFrame value);
}
[TypeConverterAttribute("System.Windows.KeySplineConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Animation.KeySpline : Freezable {
    public Point ControlPoint1 { get; public set; }
    public Point ControlPoint2 { get; public set; }
    public KeySpline(double x1, double y1, double x2, double y2);
    public KeySpline(Point controlPoint1, Point controlPoint2);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual void OnChanged();
    public Point get_ControlPoint1();
    public void set_ControlPoint1(Point value);
    public Point get_ControlPoint2();
    public void set_ControlPoint2(Point value);
    public double GetSplineProgress(double linearProgress);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    internal string InternalConvertToString(string format, IFormatProvider formatProvider);
}
[TypeConverterAttribute("System.Windows.KeyTimeConverter")]
public class System.Windows.Media.Animation.KeyTime : ValueType {
    private object _value;
    private KeyTimeType _type;
    public static KeyTime Uniform { get; }
    public static KeyTime Paced { get; }
    public TimeSpan TimeSpan { get; }
    public double Percent { get; }
    public KeyTimeType Type { get; }
    public static KeyTime FromPercent(double percent);
    public static KeyTime FromTimeSpan(TimeSpan timeSpan);
    public static KeyTime get_Uniform();
    public static KeyTime get_Paced();
    public static bool Equals(KeyTime keyTime1, KeyTime keyTime2);
    public static bool op_Equality(KeyTime keyTime1, KeyTime keyTime2);
    public static bool op_Inequality(KeyTime keyTime1, KeyTime keyTime2);
    public sealed virtual bool Equals(KeyTime value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static KeyTime op_Implicit(TimeSpan timeSpan);
    public TimeSpan get_TimeSpan();
    public double get_Percent();
    public KeyTimeType get_Type();
}
public enum System.Windows.Media.Animation.KeyTimeType : Enum {
    public byte value__;
    public static KeyTimeType Uniform;
    public static KeyTimeType Percent;
    public static KeyTimeType TimeSpan;
    public static KeyTimeType Paced;
}
public class System.Windows.Media.Animation.LinearByteKeyFrame : ByteKeyFrame {
    public LinearByteKeyFrame(byte value);
    public LinearByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearColorKeyFrame : ColorKeyFrame {
    public LinearColorKeyFrame(Color value);
    public LinearColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDecimalKeyFrame : DecimalKeyFrame {
    public LinearDecimalKeyFrame(decimal value);
    public LinearDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDoubleKeyFrame : DoubleKeyFrame {
    public LinearDoubleKeyFrame(double value);
    public LinearDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt16KeyFrame : Int16KeyFrame {
    public LinearInt16KeyFrame(short value);
    public LinearInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt32KeyFrame : Int32KeyFrame {
    public LinearInt32KeyFrame(int value);
    public LinearInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt64KeyFrame : Int64KeyFrame {
    public LinearInt64KeyFrame(long value);
    public LinearInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPoint3DKeyFrame : Point3DKeyFrame {
    public LinearPoint3DKeyFrame(Point3D value);
    public LinearPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPointKeyFrame : PointKeyFrame {
    public LinearPointKeyFrame(Point value);
    public LinearPointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public bool UseShortestPath { get; public set; }
    public LinearQuaternionKeyFrame(Quaternion value);
    public LinearQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    private static LinearQuaternionKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
}
public class System.Windows.Media.Animation.LinearRectKeyFrame : RectKeyFrame {
    public LinearRectKeyFrame(Rect value);
    public LinearRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRotation3DKeyFrame : Rotation3DKeyFrame {
    public LinearRotation3DKeyFrame(Rotation3D value);
    public LinearRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSingleKeyFrame : SingleKeyFrame {
    public LinearSingleKeyFrame(float value);
    public LinearSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSizeKeyFrame : SizeKeyFrame {
    public LinearSizeKeyFrame(Size value);
    public LinearSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVector3DKeyFrame : Vector3DKeyFrame {
    public LinearVector3DKeyFrame(Vector3D value);
    public LinearVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVectorKeyFrame : VectorKeyFrame {
    public LinearVectorKeyFrame(Vector value);
    public LinearVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.MatrixAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public MatrixAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Matrix GetCurrentValue(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames : MatrixAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public MatrixKeyFrameCollection KeyFrames { get; public set; }
    public MatrixAnimationUsingKeyFrames Clone();
    public MatrixAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public MatrixKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(MatrixKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public class System.Windows.Media.Animation.MatrixAnimationUsingPath : MatrixAnimationBase {
    public static DependencyProperty DoesRotateWithTangentProperty;
    public static DependencyProperty IsAngleCumulativeProperty;
    public static DependencyProperty IsOffsetCumulativeProperty;
    public static DependencyProperty PathGeometryProperty;
    public bool DoesRotateWithTangent { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsAngleCumulative { get; public set; }
    public bool IsOffsetCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    private static MatrixAnimationUsingPath();
    public MatrixAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    public bool get_DoesRotateWithTangent();
    public void set_DoesRotateWithTangent(bool value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsAngleCumulative();
    public void set_IsAngleCumulative(bool value);
    public bool get_IsOffsetCumulative();
    public void set_IsOffsetCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    protected virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.MatrixIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.MatrixKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Matrix Value { get; public set; }
    protected MatrixKeyFrame(Matrix value);
    protected MatrixKeyFrame(Matrix value, KeyTime keyTime);
    private static MatrixKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Matrix get_Value();
    public void set_Value(Matrix value);
    public Matrix InterpolateValue(Matrix baseValue, double keyFrameProgress);
    protected abstract virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.MatrixKeyFrameCollection : Freezable {
    public static MatrixKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public MatrixKeyFrame Item { get; public set; }
    public static MatrixKeyFrameCollection get_Empty();
    public MatrixKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(MatrixKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(MatrixKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(MatrixKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(MatrixKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, MatrixKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(MatrixKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public MatrixKeyFrame get_Item(int index);
    public void set_Item(int index, MatrixKeyFrame value);
}
public abstract class System.Windows.Media.Animation.ObjectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ObjectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    protected abstract virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames : ObjectAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ObjectKeyFrameCollection KeyFrames { get; public set; }
    public ObjectAnimationUsingKeyFrames Clone();
    public ObjectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ObjectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ObjectKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.ObjectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public object Value { get; public set; }
    protected ObjectKeyFrame(object value);
    protected ObjectKeyFrame(object value, KeyTime keyTime);
    private static ObjectKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public object get_Value();
    public void set_Value(object value);
    public object InterpolateValue(object baseValue, double keyFrameProgress);
    protected abstract virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ObjectKeyFrameCollection : Freezable {
    public static ObjectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ObjectKeyFrame Item { get; public set; }
    public static ObjectKeyFrameCollection get_Empty();
    public ObjectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ObjectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ObjectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ObjectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ObjectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ObjectKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ObjectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ObjectKeyFrame get_Item(int index);
    public void set_Item(int index, ObjectKeyFrame value);
}
public class System.Windows.Media.Animation.ParallelTimeline : TimelineGroup {
    public static DependencyProperty SlipBehaviorProperty;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SlipBehavior SlipBehavior { get; public set; }
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static ParallelTimeline();
    public ParallelTimeline Clone();
    public ParallelTimeline CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public SlipBehavior get_SlipBehavior();
    public void set_SlipBehavior(SlipBehavior value);
    internal static void ParallelTimeline_PropertyChangedFunction(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public enum System.Windows.Media.Animation.PathAnimationSource : Enum {
    public byte value__;
    public static PathAnimationSource X;
    public static PathAnimationSource Y;
    public static PathAnimationSource Angle;
}
public class System.Windows.Media.Animation.Point3DAnimation : Point3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point3D> From { get; public set; }
    public Nullable`1<Point3D> To { get; public set; }
    public Nullable`1<Point3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Point3DAnimation();
    public Point3DAnimation(Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Point3D> get_From();
    public void set_From(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_To();
    public void set_To(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_By();
    public void set_By(Nullable`1<Point3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Point3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Point3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Point3D GetCurrentValue(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames : Point3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Point3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Point3DAnimationUsingKeyFrames Clone();
    public Point3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Point3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Point3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.Point3DIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.Point3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point3D Value { get; public set; }
    protected Point3DKeyFrame(Point3D value);
    protected Point3DKeyFrame(Point3D value, KeyTime keyTime);
    private static Point3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point3D get_Value();
    public void set_Value(Point3D value);
    public Point3D InterpolateValue(Point3D baseValue, double keyFrameProgress);
    protected abstract virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Point3DKeyFrameCollection : Freezable {
    public static Point3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Point3DKeyFrame Item { get; public set; }
    public static Point3DKeyFrameCollection get_Empty();
    public Point3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Point3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Point3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Point3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Point3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Point3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Point3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Point3DKeyFrame get_Item(int index);
    public void set_Item(int index, Point3DKeyFrame value);
}
public class System.Windows.Media.Animation.PointAnimation : PointAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point> From { get; public set; }
    public Nullable`1<Point> To { get; public set; }
    public Nullable`1<Point> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static PointAnimation();
    public PointAnimation(Point toValue, Duration duration);
    public PointAnimation(Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation(Point fromValue, Point toValue, Duration duration);
    public PointAnimation(Point fromValue, Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Point> get_From();
    public void set_From(Nullable`1<Point> value);
    public Nullable`1<Point> get_To();
    public void set_To(Nullable`1<Point> value);
    public Nullable`1<Point> get_By();
    public void set_By(Nullable`1<Point> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.PointAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public PointAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Point GetCurrentValue(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.PointAnimationClockResource : AnimationClockResource {
    public Point BaseValue { get; }
    public Point CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public PointAnimationClockResource(Point baseValue, AnimationClock animationClock);
    public Point get_BaseValue();
    public Point get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.PointAnimationUsingKeyFrames : PointAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public PointKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public PointAnimationUsingKeyFrames Clone();
    public PointAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public PointKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(PointKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public class System.Windows.Media.Animation.PointAnimationUsingPath : PointAnimationBase {
    public static DependencyProperty PathGeometryProperty;
    public PathGeometry PathGeometry { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static PointAnimationUsingPath();
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PointAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.PointIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.PointKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point Value { get; public set; }
    protected PointKeyFrame(Point value);
    protected PointKeyFrame(Point value, KeyTime keyTime);
    private static PointKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point get_Value();
    public void set_Value(Point value);
    public Point InterpolateValue(Point baseValue, double keyFrameProgress);
    protected abstract virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.PointKeyFrameCollection : Freezable {
    public static PointKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PointKeyFrame Item { get; public set; }
    public static PointKeyFrameCollection get_Empty();
    public PointKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(PointKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(PointKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(PointKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(PointKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, PointKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(PointKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public PointKeyFrame get_Item(int index);
    public void set_Item(int index, PointKeyFrame value);
}
internal class System.Windows.Media.Animation.PostfixSubtreeEnumerator : ValueType {
    private Clock _rootClock;
    private Clock _currentClock;
    private SubtreeFlag _flags;
    internal Clock Current { get; }
    internal PostfixSubtreeEnumerator(Clock root, bool processRoot);
    public bool MoveNext();
    internal Clock get_Current();
}
public class System.Windows.Media.Animation.PowerEase : EasingFunctionBase {
    public static DependencyProperty PowerProperty;
    public double Power { get; public set; }
    private static PowerEase();
    public double get_Power();
    public void set_Power(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Animation.PrefixSubtreeEnumerator : ValueType {
    private Clock _rootClock;
    private Clock _currentClock;
    private SubtreeFlag _flags;
    internal Clock Current { get; }
    internal PrefixSubtreeEnumerator(Clock root, bool processRoot);
    internal void SkipSubtree();
    public bool MoveNext();
    public void Reset();
    internal Clock get_Current();
}
public class System.Windows.Media.Animation.QuadraticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuarticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuaternionAnimation : QuaternionAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public static DependencyProperty UseShortestPathProperty;
    public Nullable`1<Quaternion> From { get; public set; }
    public Nullable`1<Quaternion> To { get; public set; }
    public Nullable`1<Quaternion> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public bool UseShortestPath { get; public set; }
    private static QuaternionAnimation();
    public QuaternionAnimation(Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public QuaternionAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Quaternion> get_From();
    public void set_From(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_To();
    public void set_To(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_By();
    public void set_By(Nullable`1<Quaternion> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
}
public abstract class System.Windows.Media.Animation.QuaternionAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public QuaternionAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Quaternion GetCurrentValue(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames : QuaternionAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public QuaternionKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public QuaternionAnimationUsingKeyFrames Clone();
    public QuaternionAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public QuaternionKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(QuaternionKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.QuaternionIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.QuaternionKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Quaternion Value { get; public set; }
    protected QuaternionKeyFrame(Quaternion value);
    protected QuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    private static QuaternionKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Quaternion get_Value();
    public void set_Value(Quaternion value);
    public Quaternion InterpolateValue(Quaternion baseValue, double keyFrameProgress);
    protected abstract virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.QuaternionKeyFrameCollection : Freezable {
    public static QuaternionKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public QuaternionKeyFrame Item { get; public set; }
    public static QuaternionKeyFrameCollection get_Empty();
    public QuaternionKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(QuaternionKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(QuaternionKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(QuaternionKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(QuaternionKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, QuaternionKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(QuaternionKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public QuaternionKeyFrame get_Item(int index);
    public void set_Item(int index, QuaternionKeyFrame value);
}
public class System.Windows.Media.Animation.QuinticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.RectAnimation : RectAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Rect> From { get; public set; }
    public Nullable`1<Rect> To { get; public set; }
    public Nullable`1<Rect> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static RectAnimation();
    public RectAnimation(Rect toValue, Duration duration);
    public RectAnimation(Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Rect> get_From();
    public void set_From(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_To();
    public void set_To(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_By();
    public void set_By(Nullable`1<Rect> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.RectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public RectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Rect GetCurrentValue(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.RectAnimationClockResource : AnimationClockResource {
    public Rect BaseValue { get; }
    public Rect CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public RectAnimationClockResource(Rect baseValue, AnimationClock animationClock);
    public Rect get_BaseValue();
    public Rect get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.RectAnimationUsingKeyFrames : RectAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public RectKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public RectAnimationUsingKeyFrames Clone();
    public RectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public RectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(RectKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.RectIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.RectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rect Value { get; public set; }
    protected RectKeyFrame(Rect value);
    protected RectKeyFrame(Rect value, KeyTime keyTime);
    private static RectKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rect get_Value();
    public void set_Value(Rect value);
    public Rect InterpolateValue(Rect baseValue, double keyFrameProgress);
    protected abstract virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.RectKeyFrameCollection : Freezable {
    public static RectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public RectKeyFrame Item { get; public set; }
    public static RectKeyFrameCollection get_Empty();
    public RectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(RectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(RectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(RectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(RectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, RectKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(RectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public RectKeyFrame get_Item(int index);
    public void set_Item(int index, RectKeyFrame value);
}
[TypeConverterAttribute("System.Windows.Media.Animation.RepeatBehaviorConverter")]
public class System.Windows.Media.Animation.RepeatBehavior : ValueType {
    private double _iterationCount;
    private TimeSpan _repeatDuration;
    private RepeatBehaviorType _type;
    public static RepeatBehavior Forever { get; }
    public bool HasCount { get; }
    public bool HasDuration { get; }
    public double Count { get; }
    public TimeSpan Duration { get; }
    public RepeatBehavior(double count);
    public RepeatBehavior(TimeSpan duration);
    public static RepeatBehavior get_Forever();
    public bool get_HasCount();
    public bool get_HasDuration();
    public double get_Count();
    public TimeSpan get_Duration();
    public virtual bool Equals(object value);
    public bool Equals(RepeatBehavior repeatBehavior);
    public static bool Equals(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    internal string InternalToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public static bool op_Inequality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
}
public class System.Windows.Media.Animation.RepeatBehaviorConverter : TypeConverter {
    private static RepeatBehaviorConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.Media.Animation.ResolvedKeyFrameEntry : ValueType {
    internal int _originalKeyFrameIndex;
    internal TimeSpan _resolvedKeyTime;
    public sealed virtual int CompareTo(object other);
}
public class System.Windows.Media.Animation.Rotation3DAnimation : Rotation3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Rotation3D From { get; public set; }
    public Rotation3D To { get; public set; }
    public Rotation3D By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Rotation3DAnimation();
    public Rotation3DAnimation(Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    public Rotation3D get_From();
    public void set_From(Rotation3D value);
    public Rotation3D get_To();
    public void set_To(Rotation3D value);
    public Rotation3D get_By();
    public void set_By(Rotation3D value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Rotation3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Rotation3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Rotation3D GetCurrentValue(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames : Rotation3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Rotation3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Rotation3DAnimationUsingKeyFrames Clone();
    public Rotation3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Rotation3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Rotation3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Rotation3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rotation3D Value { get; public set; }
    protected Rotation3DKeyFrame(Rotation3D value);
    protected Rotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    private static Rotation3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rotation3D get_Value();
    public void set_Value(Rotation3D value);
    public Rotation3D InterpolateValue(Rotation3D baseValue, double keyFrameProgress);
    protected abstract virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Rotation3DKeyFrameCollection : Freezable {
    public static Rotation3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Rotation3DKeyFrame Item { get; public set; }
    public static Rotation3DKeyFrameCollection get_Empty();
    public Rotation3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Rotation3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Rotation3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Rotation3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Rotation3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Rotation3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Rotation3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Rotation3DKeyFrame get_Item(int index);
    public void set_Item(int index, Rotation3DKeyFrame value);
}
public class System.Windows.Media.Animation.SineEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.SingleAnimation : SingleAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<float> From { get; public set; }
    public Nullable`1<float> To { get; public set; }
    public Nullable`1<float> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static SingleAnimation();
    public SingleAnimation(float toValue, Duration duration);
    public SingleAnimation(float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation(float fromValue, float toValue, Duration duration);
    public SingleAnimation(float fromValue, float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<float> get_From();
    public void set_From(Nullable`1<float> value);
    public Nullable`1<float> get_To();
    public void set_To(Nullable`1<float> value);
    public Nullable`1<float> get_By();
    public void set_By(Nullable`1<float> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.SingleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public SingleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public float GetCurrentValue(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SingleAnimationUsingKeyFrames : SingleAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SingleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SingleAnimationUsingKeyFrames Clone();
    public SingleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SingleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SingleKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.SingleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public float Value { get; public set; }
    protected SingleKeyFrame(float value);
    protected SingleKeyFrame(float value, KeyTime keyTime);
    private static SingleKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public float get_Value();
    public void set_Value(float value);
    public float InterpolateValue(float baseValue, double keyFrameProgress);
    protected abstract virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SingleKeyFrameCollection : Freezable {
    public static SingleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SingleKeyFrame Item { get; public set; }
    public static SingleKeyFrameCollection get_Empty();
    public SingleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SingleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SingleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SingleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SingleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SingleKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SingleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SingleKeyFrame get_Item(int index);
    public void set_Item(int index, SingleKeyFrame value);
}
public class System.Windows.Media.Animation.SizeAnimation : SizeAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Size> From { get; public set; }
    public Nullable`1<Size> To { get; public set; }
    public Nullable`1<Size> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static SizeAnimation();
    public SizeAnimation(Size toValue, Duration duration);
    public SizeAnimation(Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Size> get_From();
    public void set_From(Nullable`1<Size> value);
    public Nullable`1<Size> get_To();
    public void set_To(Nullable`1<Size> value);
    public Nullable`1<Size> get_By();
    public void set_By(Nullable`1<Size> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.SizeAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public SizeAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Size GetCurrentValue(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.SizeAnimationClockResource : AnimationClockResource {
    public Size BaseValue { get; }
    public Size CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public SizeAnimationClockResource(Size baseValue, AnimationClock animationClock);
    public Size get_BaseValue();
    public Size get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SizeAnimationUsingKeyFrames : SizeAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SizeKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public SizeAnimationUsingKeyFrames Clone();
    public SizeAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SizeKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SizeKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.SizeIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.SizeKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Size Value { get; public set; }
    protected SizeKeyFrame(Size value);
    protected SizeKeyFrame(Size value, KeyTime keyTime);
    private static SizeKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Size get_Value();
    public void set_Value(Size value);
    public Size InterpolateValue(Size baseValue, double keyFrameProgress);
    protected abstract virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SizeKeyFrameCollection : Freezable {
    public static SizeKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SizeKeyFrame Item { get; public set; }
    public static SizeKeyFrameCollection get_Empty();
    public SizeKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SizeKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SizeKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SizeKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SizeKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SizeKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SizeKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SizeKeyFrame get_Item(int index);
    public void set_Item(int index, SizeKeyFrame value);
}
public enum System.Windows.Media.Animation.SlipBehavior : Enum {
    public int value__;
    public static SlipBehavior Grow;
    public static SlipBehavior Slip;
}
public class System.Windows.Media.Animation.SplineByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineByteKeyFrame(byte value);
    public SplineByteKeyFrame(byte value, KeyTime keyTime);
    public SplineByteKeyFrame(byte value, KeyTime keyTime, KeySpline keySpline);
    private static SplineByteKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineColorKeyFrame(Color value);
    public SplineColorKeyFrame(Color value, KeyTime keyTime);
    public SplineColorKeyFrame(Color value, KeyTime keyTime, KeySpline keySpline);
    private static SplineColorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDecimalKeyFrame(decimal value);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime, KeySpline keySpline);
    private static SplineDecimalKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDoubleKeyFrame(double value);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime, KeySpline keySpline);
    private static SplineDoubleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt16KeyFrame(short value);
    public SplineInt16KeyFrame(short value, KeyTime keyTime);
    public SplineInt16KeyFrame(short value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt16KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt32KeyFrame(int value);
    public SplineInt32KeyFrame(int value, KeyTime keyTime);
    public SplineInt32KeyFrame(int value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt32KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt64KeyFrame(long value);
    public SplineInt64KeyFrame(long value, KeyTime keyTime);
    public SplineInt64KeyFrame(long value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt64KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplinePoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePoint3DKeyFrame(Point3D value);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplinePoint3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplinePointKeyFrame : PointKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePointKeyFrame(Point value);
    public SplinePointKeyFrame(Point value, KeyTime keyTime);
    public SplinePointKeyFrame(Point value, KeyTime keyTime, KeySpline keySpline);
    private static SplinePointKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public static DependencyProperty UseShortestPathProperty;
    public KeySpline KeySpline { get; public set; }
    public bool UseShortestPath { get; public set; }
    public SplineQuaternionKeyFrame(Quaternion value);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime, KeySpline keySpline);
    private static SplineQuaternionKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
}
public class System.Windows.Media.Animation.SplineRectKeyFrame : RectKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRectKeyFrame(Rect value);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime, KeySpline keySpline);
    private static SplineRectKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRotation3DKeyFrame(Rotation3D value);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplineRotation3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSingleKeyFrame(float value);
    public SplineSingleKeyFrame(float value, KeyTime keyTime);
    public SplineSingleKeyFrame(float value, KeyTime keyTime, KeySpline keySpline);
    private static SplineSingleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSizeKeyFrame(Size value);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime, KeySpline keySpline);
    private static SplineSizeKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVector3DKeyFrame(Vector3D value);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplineVector3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVectorKeyFrame(Vector value);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime, KeySpline keySpline);
    private static SplineVectorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public abstract class System.Windows.Media.Animation.StringAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public StringAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public string GetCurrentValue(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.StringAnimationUsingKeyFrames : StringAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public StringKeyFrameCollection KeyFrames { get; public set; }
    public StringAnimationUsingKeyFrames Clone();
    public StringAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public StringKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(StringKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
}
public abstract class System.Windows.Media.Animation.StringKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public string Value { get; public set; }
    protected StringKeyFrame(string value);
    protected StringKeyFrame(string value, KeyTime keyTime);
    private static StringKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public string get_Value();
    public void set_Value(string value);
    public string InterpolateValue(string baseValue, double keyFrameProgress);
    protected abstract virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.StringKeyFrameCollection : Freezable {
    public static StringKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public StringKeyFrame Item { get; public set; }
    public static StringKeyFrameCollection get_Empty();
    public StringKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(StringKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(StringKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(StringKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(StringKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, StringKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(StringKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public StringKeyFrame get_Item(int index);
    public void set_Item(int index, StringKeyFrame value);
}
[FriendAccessAllowedAttribute]
[FlagsAttribute]
internal enum System.Windows.Media.Animation.SubtreeFlag : Enum {
    public int value__;
    public static SubtreeFlag Reset;
    public static SubtreeFlag ProcessRoot;
    public static SubtreeFlag SkipSubtree;
}
internal class System.Windows.Media.Animation.TimeIntervalCollection : ValueType {
    private TimeSpan[] _nodeTime;
    private Boolean[] _nodeIsPoint;
    private Boolean[] _nodeIsInterval;
    private bool _containsNullPoint;
    private int _count;
    private int _current;
    private bool _invertCollection;
    private static int _minimumCapacity;
    internal bool IsSingleInterval { get; }
    internal TimeSpan FirstNodeTime { get; }
    internal static TimeIntervalCollection Empty { get; }
    internal bool IsEmptyOfRealPoints { get; }
    internal bool IsEmpty { get; }
    internal bool ContainsNullPoint { get; }
    internal void Clear();
    internal bool get_IsSingleInterval();
    internal TimeSpan get_FirstNodeTime();
    internal TimeIntervalCollection SlipBeginningOfConnectedInterval(TimeSpan slipTime);
    internal TimeIntervalCollection SetBeginningOfConnectedInterval(TimeSpan beginTime);
    internal static TimeIntervalCollection CreatePoint(TimeSpan time);
    internal static TimeIntervalCollection CreateClosedOpenInterval(TimeSpan from, TimeSpan to);
    internal static TimeIntervalCollection CreateOpenClosedInterval(TimeSpan from, TimeSpan to);
    internal static TimeIntervalCollection CreateInfiniteClosedInterval(TimeSpan from);
    internal static TimeIntervalCollection get_Empty();
    internal static TimeIntervalCollection CreateNullPoint();
    internal void AddNullPoint();
    internal bool Contains(TimeSpan time);
    internal bool Intersects(TimeSpan from, TimeSpan to);
    internal bool Intersects(TimeIntervalCollection other);
    internal bool IntersectsInverseOf(TimeIntervalCollection other);
    internal bool IntersectsPeriodicCollection(TimeSpan beginTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal bool IntersectsMultiplePeriods(TimeSpan beginTime, Duration period, double appliedSpeedRatio);
    internal void ProjectPostFillZone(TimeIntervalCollection& projection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal void ProjectOntoPeriodicFunction(TimeIntervalCollection& projection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal bool get_IsEmptyOfRealPoints();
    internal bool get_IsEmpty();
    internal bool get_ContainsNullPoint();
}
[LocalizabilityAttribute("0")]
[RuntimeNamePropertyAttribute("Name")]
public abstract class System.Windows.Media.Animation.Timeline : Animatable {
    public static DependencyProperty AccelerationRatioProperty;
    public static DependencyProperty AutoReverseProperty;
    public static DependencyProperty BeginTimeProperty;
    public static DependencyProperty DecelerationRatioProperty;
    public static DependencyProperty DesiredFrameRateProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty FillBehaviorProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty RepeatBehaviorProperty;
    public static DependencyProperty SpeedRatioProperty;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static EventPrivateKey CurrentGlobalSpeedInvalidatedKey;
    internal static EventPrivateKey CurrentStateInvalidatedKey;
    internal static EventPrivateKey CurrentTimeInvalidatedKey;
    internal static EventPrivateKey CompletedKey;
    internal static EventPrivateKey RemoveRequestedKey;
    public double AccelerationRatio { get; public set; }
    [DefaultValueAttribute("False")]
public bool AutoReverse { get; public set; }
    public Nullable`1<TimeSpan> BeginTime { get; public set; }
    public double DecelerationRatio { get; public set; }
    public Duration Duration { get; public set; }
    public FillBehavior FillBehavior { get; public set; }
    [MergablePropertyAttribute("False")]
[DefaultValueAttribute("")]
public string Name { get; public set; }
    public RepeatBehavior RepeatBehavior { get; public set; }
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    internal EventHandlersStore InternalEventHandlersStore { get; }
    protected Timeline(Nullable`1<TimeSpan> beginTime);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static Timeline();
    public Timeline Clone();
    public Timeline CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public double get_AccelerationRatio();
    public void set_AccelerationRatio(double value);
    public bool get_AutoReverse();
    public void set_AutoReverse(bool value);
    public Nullable`1<TimeSpan> get_BeginTime();
    public void set_BeginTime(Nullable`1<TimeSpan> value);
    public double get_DecelerationRatio();
    public void set_DecelerationRatio(double value);
    public static Nullable`1<int> GetDesiredFrameRate(Timeline timeline);
    public static void SetDesiredFrameRate(Timeline timeline, Nullable`1<int> desiredFrameRate);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    public FillBehavior get_FillBehavior();
    public void set_FillBehavior(FillBehavior value);
    public string get_Name();
    public void set_Name(string value);
    public RepeatBehavior get_RepeatBehavior();
    public void set_RepeatBehavior(RepeatBehavior value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    protected internal virtual Clock AllocateClock();
    public Clock CreateClock();
    public Clock CreateClock(bool hasControllableRoot);
    protected internal Duration GetNaturalDuration(Clock clock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    internal EventHandlersStore get_InternalEventHandlersStore();
    internal void InternalOnFreezablePropertyChanged(Timeline originalTimeline, Timeline newTimeline);
    internal bool InternalFreeze(bool isChecking);
    internal void InternalReadPreamble();
    internal void InternalWritePostscript();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.TimelineCollection : Animatable {
    internal FrugalStructList`1<Timeline> _collection;
    internal UInt32 _version;
    public Timeline Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TimelineCollection Empty { get; }
    public TimelineCollection(int capacity);
    public TimelineCollection(IEnumerable`1<Timeline> collection);
    public TimelineCollection Clone();
    public TimelineCollection CloneCurrentValue();
    public sealed virtual void Add(Timeline value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Timeline value);
    public sealed virtual int IndexOf(Timeline value);
    public sealed virtual void Insert(int index, Timeline value);
    public sealed virtual bool Remove(Timeline value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Timeline get_Item(int index);
    public sealed virtual void set_Item(int index, Timeline value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Timeline[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Timeline> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Timeline>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TimelineCollection get_Empty();
    internal Timeline Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Timeline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Media.Animation.TimelineGroup : Timeline {
    public static DependencyProperty ChildrenProperty;
    internal static TimelineCollection s_Children;
    public TimelineCollection Children { get; public set; }
    private static TimelineGroup();
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public TimelineGroup Clone();
    public TimelineGroup CloneCurrentValue();
    public TimelineCollection get_Children();
    public void set_Children(TimelineCollection value);
    protected internal virtual Clock AllocateClock();
    public ClockGroup CreateClock();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.Animation.TimelineTreeEnumerator : ValueType {
    private Timeline _rootTimeline;
    private SubtreeFlag _flags;
    private Stack _indexStack;
    private Stack`1<Timeline> _timelineStack;
    internal Timeline Current { get; }
    internal TimelineTreeEnumerator(Timeline root, bool processRoot);
    internal void SkipSubtree();
    public bool MoveNext();
    internal Timeline get_Current();
}
internal class System.Windows.Media.Animation.TimeManager : DispatcherObject {
    public IClock Clock { get; public set; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool IsDirty { get; }
    internal TimeSpan InternalCurrentGlobalTime { get; }
    internal bool InternalIsStopped { get; }
    internal TimeIntervalCollection InternalCurrentIntervals { get; internal set; }
    internal TimeSpan LastTickDelta { get; }
    internal TimeSpan LastTickTime { get; }
    internal ClockGroup TimeManagerClock { get; }
    internal TimeState State { get; }
    public TimeManager(IClock clock);
    public IClock get_Clock();
    public void set_Clock(IClock value);
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_IsDirty();
    public void Pause();
    public void Restart();
    public void Resume();
    public void Seek(int offset, TimeSeekOrigin origin);
    public void Start();
    public void Stop();
    public void Tick();
    internal int GetMaxDesiredFrameRate();
    internal void AddToEventQueue(Clock sender);
    internal TimeSpan GetCurrentGlobalTime();
    internal void LockTickTime();
    internal void NotifyNewEarliestFutureActivity();
    internal void ScheduleClockCleanup();
    internal void SetDirty();
    internal void UnlockTickTime();
    internal TimeSpan get_InternalCurrentGlobalTime();
    internal bool get_InternalIsStopped();
    internal TimeIntervalCollection get_InternalCurrentIntervals();
    internal void set_InternalCurrentIntervals(TimeIntervalCollection value);
    internal TimeSpan GetNextTickNeeded();
    internal TimeSpan get_LastTickDelta();
    internal TimeSpan get_LastTickTime();
    internal ClockGroup get_TimeManagerClock();
    internal TimeState get_State();
    internal void add_NeedTickSooner(EventHandler value);
    internal void remove_NeedTickSooner(EventHandler value);
}
public enum System.Windows.Media.Animation.TimeSeekOrigin : Enum {
    public int value__;
    public static TimeSeekOrigin BeginTime;
    public static TimeSeekOrigin Duration;
}
internal enum System.Windows.Media.Animation.TimeState : Enum {
    public int value__;
    public static TimeState Stopped;
    public static TimeState Paused;
    public static TimeState Running;
}
public class System.Windows.Media.Animation.Vector3DAnimation : Vector3DAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector3D> From { get; public set; }
    public Nullable`1<Vector3D> To { get; public set; }
    public Nullable`1<Vector3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Vector3DAnimation();
    public Vector3DAnimation(Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Vector3D> get_From();
    public void set_From(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_To();
    public void set_To(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_By();
    public void set_By(Nullable`1<Vector3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Vector3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Vector3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Vector3D GetCurrentValue(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames : Vector3DAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Vector3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public Vector3DAnimationUsingKeyFrames Clone();
    public Vector3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Vector3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Vector3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
internal class System.Windows.Media.Animation.Vector3DIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.Vector3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector3D Value { get; public set; }
    protected Vector3DKeyFrame(Vector3D value);
    protected Vector3DKeyFrame(Vector3D value, KeyTime keyTime);
    private static Vector3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector3D get_Value();
    public void set_Value(Vector3D value);
    public Vector3D InterpolateValue(Vector3D baseValue, double keyFrameProgress);
    protected abstract virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Vector3DKeyFrameCollection : Freezable {
    public static Vector3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Vector3DKeyFrame Item { get; public set; }
    public static Vector3DKeyFrameCollection get_Empty();
    public Vector3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Vector3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Vector3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Vector3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Vector3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Vector3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Vector3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Vector3DKeyFrame get_Item(int index);
    public void set_Item(int index, Vector3DKeyFrame value);
}
public class System.Windows.Media.Animation.VectorAnimation : VectorAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector> From { get; public set; }
    public Nullable`1<Vector> To { get; public set; }
    public Nullable`1<Vector> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static VectorAnimation();
    public VectorAnimation(Vector toValue, Duration duration);
    public VectorAnimation(Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Vector> get_From();
    public void set_From(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_To();
    public void set_To(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_By();
    public void set_By(Nullable`1<Vector> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.VectorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public VectorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Vector GetCurrentValue(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.VectorAnimationUsingKeyFrames : VectorAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public VectorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public VectorAnimationUsingKeyFrames Clone();
    public VectorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public VectorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(VectorKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.VectorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector Value { get; public set; }
    protected VectorKeyFrame(Vector value);
    protected VectorKeyFrame(Vector value, KeyTime keyTime);
    private static VectorKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector get_Value();
    public void set_Value(Vector value);
    public Vector InterpolateValue(Vector baseValue, double keyFrameProgress);
    protected abstract virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.VectorKeyFrameCollection : Freezable {
    public static VectorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public VectorKeyFrame Item { get; public set; }
    public static VectorKeyFrameCollection get_Empty();
    public VectorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(VectorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(VectorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(VectorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(VectorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, VectorKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(VectorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public VectorKeyFrame get_Item(int index);
    public void set_Item(int index, VectorKeyFrame value);
}
internal class System.Windows.Media.Animation.WeakRefEnumerator`1 : ValueType {
    private List`1<WeakReference> _list;
    private T _current;
    private int _readIndex;
    private int _writeIndex;
    internal T Current { get; }
    internal int CurrentIndex { get; }
    internal WeakRefEnumerator`1(List`1<WeakReference> list);
    internal T get_Current();
    internal int get_CurrentIndex();
    internal void Dispose();
    internal bool MoveNext();
}
public class System.Windows.Media.ArcSegment : PathSegment {
    public static DependencyProperty PointProperty;
    public static DependencyProperty SizeProperty;
    public static DependencyProperty RotationAngleProperty;
    public static DependencyProperty IsLargeArcProperty;
    public static DependencyProperty SweepDirectionProperty;
    internal static Point s_Point;
    internal static Size s_Size;
    internal static double c_RotationAngle;
    internal static bool c_IsLargeArc;
    internal static SweepDirection c_SweepDirection;
    internal int EffectiveValuesInitialSize { get; }
    public Point Point { get; public set; }
    public Size Size { get; public set; }
    public double RotationAngle { get; public set; }
    public bool IsLargeArc { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    public ArcSegment(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    private static ArcSegment();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal virtual int get_EffectiveValuesInitialSize();
    public ArcSegment Clone();
    public ArcSegment CloneCurrentValue();
    public Point get_Point();
    public void set_Point(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public bool get_IsLargeArc();
    public void set_IsLargeArc(bool value);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    protected virtual Freezable CreateInstanceCore();
}
internal enum System.Windows.Media.AVEvent : Enum {
    public int value__;
    public static AVEvent AVMediaNone;
    public static AVEvent AVMediaOpened;
    public static AVEvent AVMediaClosed;
    public static AVEvent AVMediaStarted;
    public static AVEvent AVMediaStopped;
    public static AVEvent AVMediaPaused;
    public static AVEvent AVMediaRateChanged;
    public static AVEvent AVMediaEnded;
    public static AVEvent AVMediaFailed;
    public static AVEvent AVMediaBufferingStarted;
    public static AVEvent AVMediaBufferingEnded;
    public static AVEvent AVMediaPrerolled;
    public static AVEvent AVMediaScriptCommand;
    public static AVEvent AVMediaNewFrame;
}
public class System.Windows.Media.BezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public static DependencyProperty Point3Property;
    internal static Point s_Point1;
    internal static Point s_Point2;
    internal static Point s_Point3;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public BezierSegment(Point point1, Point point2, Point point3, bool isStroked);
    internal BezierSegment(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    private static BezierSegment();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public BezierSegment Clone();
    public BezierSegment CloneCurrentValue();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public Point get_Point3();
    public void set_Point3(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.BitmapCache : CacheMode {
    public static DependencyProperty RenderAtScaleProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static DependencyProperty EnableClearTypeProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RenderAtScale;
    internal static bool c_SnapsToDevicePixels;
    internal static bool c_EnableClearType;
    public double RenderAtScale { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    public bool EnableClearType { get; public set; }
    public BitmapCache(double renderAtScale);
    private static BitmapCache();
    public BitmapCache Clone();
    public BitmapCache CloneCurrentValue();
    public double get_RenderAtScale();
    public void set_RenderAtScale(double value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    public bool get_EnableClearType();
    public void set_EnableClearType(bool value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.BitmapCacheBrush : Brush {
    public static DependencyProperty TargetProperty;
    public static DependencyProperty BitmapCacheProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    internal static DependencyProperty InternalTargetProperty;
    internal static DependencyProperty AutoWrapTargetProperty;
    internal MultiChannelResource _duceResource;
    internal static bool c_AutoLayoutContent;
    internal static bool c_AutoWrapTarget;
    public Visual Target { get; public set; }
    public BitmapCache BitmapCache { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    internal Visual InternalTarget { get; internal set; }
    internal bool AutoWrapTarget { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    public BitmapCacheBrush(Visual visual);
    private static BitmapCacheBrush();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.FireOnChanged();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
    internal void AddRefResource(Visual visual, Channel channel);
    internal void ReleaseResource(Visual visual, Channel channel);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal bool Enter();
    internal void Exit();
    public BitmapCacheBrush Clone();
    public BitmapCacheBrush CloneCurrentValue();
    public Visual get_Target();
    public void set_Target(Visual value);
    public BitmapCache get_BitmapCache();
    public void set_BitmapCache(BitmapCache value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    internal Visual get_InternalTarget();
    internal void set_InternalTarget(Visual value);
    internal bool get_AutoWrapTarget();
    internal void set_AutoWrapTarget(bool value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.BitmapScalingMode : Enum {
    public int value__;
    public static BitmapScalingMode Unspecified;
    public static BitmapScalingMode LowQuality;
    public static BitmapScalingMode HighQuality;
    public static BitmapScalingMode Linear;
    public static BitmapScalingMode Fant;
    public static BitmapScalingMode NearestNeighbor;
}
internal class System.Windows.Media.BoundsDrawingContextWalker : DrawingContextWalker {
    public Rect Bounds { get; }
    public Rect get_Bounds();
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer video, Rect rectangle);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    internal void ClearState();
}
[TypeConverterAttribute("System.Windows.Media.BrushConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.BrushValueSerializer")]
public abstract class System.Windows.Media.Brush : Animatable {
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty RelativeTransformProperty;
    internal static double c_Opacity;
    internal static Transform s_Transform;
    internal static Transform s_RelativeTransform;
    public double Opacity { get; public set; }
    public Transform Transform { get; public set; }
    public Transform RelativeTransform { get; public set; }
    private static Brush();
    internal static Brush Parse(string value, ITypeDescriptorContext context);
    internal virtual bool CanSerializeToString();
    public Brush Clone();
    public Brush CloneCurrentValue();
    public double get_Opacity();
    public void set_Opacity(double value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Transform get_RelativeTransform();
    public void set_RelativeTransform(Transform value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.BrushConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Brushes : object {
    public static SolidColorBrush AliceBlue { get; }
    public static SolidColorBrush AntiqueWhite { get; }
    public static SolidColorBrush Aqua { get; }
    public static SolidColorBrush Aquamarine { get; }
    public static SolidColorBrush Azure { get; }
    public static SolidColorBrush Beige { get; }
    public static SolidColorBrush Bisque { get; }
    public static SolidColorBrush Black { get; }
    public static SolidColorBrush BlanchedAlmond { get; }
    public static SolidColorBrush Blue { get; }
    public static SolidColorBrush BlueViolet { get; }
    public static SolidColorBrush Brown { get; }
    public static SolidColorBrush BurlyWood { get; }
    public static SolidColorBrush CadetBlue { get; }
    public static SolidColorBrush Chartreuse { get; }
    public static SolidColorBrush Chocolate { get; }
    public static SolidColorBrush Coral { get; }
    public static SolidColorBrush CornflowerBlue { get; }
    public static SolidColorBrush Cornsilk { get; }
    public static SolidColorBrush Crimson { get; }
    public static SolidColorBrush Cyan { get; }
    public static SolidColorBrush DarkBlue { get; }
    public static SolidColorBrush DarkCyan { get; }
    public static SolidColorBrush DarkGoldenrod { get; }
    public static SolidColorBrush DarkGray { get; }
    public static SolidColorBrush DarkGreen { get; }
    public static SolidColorBrush DarkKhaki { get; }
    public static SolidColorBrush DarkMagenta { get; }
    public static SolidColorBrush DarkOliveGreen { get; }
    public static SolidColorBrush DarkOrange { get; }
    public static SolidColorBrush DarkOrchid { get; }
    public static SolidColorBrush DarkRed { get; }
    public static SolidColorBrush DarkSalmon { get; }
    public static SolidColorBrush DarkSeaGreen { get; }
    public static SolidColorBrush DarkSlateBlue { get; }
    public static SolidColorBrush DarkSlateGray { get; }
    public static SolidColorBrush DarkTurquoise { get; }
    public static SolidColorBrush DarkViolet { get; }
    public static SolidColorBrush DeepPink { get; }
    public static SolidColorBrush DeepSkyBlue { get; }
    public static SolidColorBrush DimGray { get; }
    public static SolidColorBrush DodgerBlue { get; }
    public static SolidColorBrush Firebrick { get; }
    public static SolidColorBrush FloralWhite { get; }
    public static SolidColorBrush ForestGreen { get; }
    public static SolidColorBrush Fuchsia { get; }
    public static SolidColorBrush Gainsboro { get; }
    public static SolidColorBrush GhostWhite { get; }
    public static SolidColorBrush Gold { get; }
    public static SolidColorBrush Goldenrod { get; }
    public static SolidColorBrush Gray { get; }
    public static SolidColorBrush Green { get; }
    public static SolidColorBrush GreenYellow { get; }
    public static SolidColorBrush Honeydew { get; }
    public static SolidColorBrush HotPink { get; }
    public static SolidColorBrush IndianRed { get; }
    public static SolidColorBrush Indigo { get; }
    public static SolidColorBrush Ivory { get; }
    public static SolidColorBrush Khaki { get; }
    public static SolidColorBrush Lavender { get; }
    public static SolidColorBrush LavenderBlush { get; }
    public static SolidColorBrush LawnGreen { get; }
    public static SolidColorBrush LemonChiffon { get; }
    public static SolidColorBrush LightBlue { get; }
    public static SolidColorBrush LightCoral { get; }
    public static SolidColorBrush LightCyan { get; }
    public static SolidColorBrush LightGoldenrodYellow { get; }
    public static SolidColorBrush LightGray { get; }
    public static SolidColorBrush LightGreen { get; }
    public static SolidColorBrush LightPink { get; }
    public static SolidColorBrush LightSalmon { get; }
    public static SolidColorBrush LightSeaGreen { get; }
    public static SolidColorBrush LightSkyBlue { get; }
    public static SolidColorBrush LightSlateGray { get; }
    public static SolidColorBrush LightSteelBlue { get; }
    public static SolidColorBrush LightYellow { get; }
    public static SolidColorBrush Lime { get; }
    public static SolidColorBrush LimeGreen { get; }
    public static SolidColorBrush Linen { get; }
    public static SolidColorBrush Magenta { get; }
    public static SolidColorBrush Maroon { get; }
    public static SolidColorBrush MediumAquamarine { get; }
    public static SolidColorBrush MediumBlue { get; }
    public static SolidColorBrush MediumOrchid { get; }
    public static SolidColorBrush MediumPurple { get; }
    public static SolidColorBrush MediumSeaGreen { get; }
    public static SolidColorBrush MediumSlateBlue { get; }
    public static SolidColorBrush MediumSpringGreen { get; }
    public static SolidColorBrush MediumTurquoise { get; }
    public static SolidColorBrush MediumVioletRed { get; }
    public static SolidColorBrush MidnightBlue { get; }
    public static SolidColorBrush MintCream { get; }
    public static SolidColorBrush MistyRose { get; }
    public static SolidColorBrush Moccasin { get; }
    public static SolidColorBrush NavajoWhite { get; }
    public static SolidColorBrush Navy { get; }
    public static SolidColorBrush OldLace { get; }
    public static SolidColorBrush Olive { get; }
    public static SolidColorBrush OliveDrab { get; }
    public static SolidColorBrush Orange { get; }
    public static SolidColorBrush OrangeRed { get; }
    public static SolidColorBrush Orchid { get; }
    public static SolidColorBrush PaleGoldenrod { get; }
    public static SolidColorBrush PaleGreen { get; }
    public static SolidColorBrush PaleTurquoise { get; }
    public static SolidColorBrush PaleVioletRed { get; }
    public static SolidColorBrush PapayaWhip { get; }
    public static SolidColorBrush PeachPuff { get; }
    public static SolidColorBrush Peru { get; }
    public static SolidColorBrush Pink { get; }
    public static SolidColorBrush Plum { get; }
    public static SolidColorBrush PowderBlue { get; }
    public static SolidColorBrush Purple { get; }
    public static SolidColorBrush Red { get; }
    public static SolidColorBrush RosyBrown { get; }
    public static SolidColorBrush RoyalBlue { get; }
    public static SolidColorBrush SaddleBrown { get; }
    public static SolidColorBrush Salmon { get; }
    public static SolidColorBrush SandyBrown { get; }
    public static SolidColorBrush SeaGreen { get; }
    public static SolidColorBrush SeaShell { get; }
    public static SolidColorBrush Sienna { get; }
    public static SolidColorBrush Silver { get; }
    public static SolidColorBrush SkyBlue { get; }
    public static SolidColorBrush SlateBlue { get; }
    public static SolidColorBrush SlateGray { get; }
    public static SolidColorBrush Snow { get; }
    public static SolidColorBrush SpringGreen { get; }
    public static SolidColorBrush SteelBlue { get; }
    public static SolidColorBrush Tan { get; }
    public static SolidColorBrush Teal { get; }
    public static SolidColorBrush Thistle { get; }
    public static SolidColorBrush Tomato { get; }
    public static SolidColorBrush Transparent { get; }
    public static SolidColorBrush Turquoise { get; }
    public static SolidColorBrush Violet { get; }
    public static SolidColorBrush Wheat { get; }
    public static SolidColorBrush White { get; }
    public static SolidColorBrush WhiteSmoke { get; }
    public static SolidColorBrush Yellow { get; }
    public static SolidColorBrush YellowGreen { get; }
    public static SolidColorBrush get_AliceBlue();
    public static SolidColorBrush get_AntiqueWhite();
    public static SolidColorBrush get_Aqua();
    public static SolidColorBrush get_Aquamarine();
    public static SolidColorBrush get_Azure();
    public static SolidColorBrush get_Beige();
    public static SolidColorBrush get_Bisque();
    public static SolidColorBrush get_Black();
    public static SolidColorBrush get_BlanchedAlmond();
    public static SolidColorBrush get_Blue();
    public static SolidColorBrush get_BlueViolet();
    public static SolidColorBrush get_Brown();
    public static SolidColorBrush get_BurlyWood();
    public static SolidColorBrush get_CadetBlue();
    public static SolidColorBrush get_Chartreuse();
    public static SolidColorBrush get_Chocolate();
    public static SolidColorBrush get_Coral();
    public static SolidColorBrush get_CornflowerBlue();
    public static SolidColorBrush get_Cornsilk();
    public static SolidColorBrush get_Crimson();
    public static SolidColorBrush get_Cyan();
    public static SolidColorBrush get_DarkBlue();
    public static SolidColorBrush get_DarkCyan();
    public static SolidColorBrush get_DarkGoldenrod();
    public static SolidColorBrush get_DarkGray();
    public static SolidColorBrush get_DarkGreen();
    public static SolidColorBrush get_DarkKhaki();
    public static SolidColorBrush get_DarkMagenta();
    public static SolidColorBrush get_DarkOliveGreen();
    public static SolidColorBrush get_DarkOrange();
    public static SolidColorBrush get_DarkOrchid();
    public static SolidColorBrush get_DarkRed();
    public static SolidColorBrush get_DarkSalmon();
    public static SolidColorBrush get_DarkSeaGreen();
    public static SolidColorBrush get_DarkSlateBlue();
    public static SolidColorBrush get_DarkSlateGray();
    public static SolidColorBrush get_DarkTurquoise();
    public static SolidColorBrush get_DarkViolet();
    public static SolidColorBrush get_DeepPink();
    public static SolidColorBrush get_DeepSkyBlue();
    public static SolidColorBrush get_DimGray();
    public static SolidColorBrush get_DodgerBlue();
    public static SolidColorBrush get_Firebrick();
    public static SolidColorBrush get_FloralWhite();
    public static SolidColorBrush get_ForestGreen();
    public static SolidColorBrush get_Fuchsia();
    public static SolidColorBrush get_Gainsboro();
    public static SolidColorBrush get_GhostWhite();
    public static SolidColorBrush get_Gold();
    public static SolidColorBrush get_Goldenrod();
    public static SolidColorBrush get_Gray();
    public static SolidColorBrush get_Green();
    public static SolidColorBrush get_GreenYellow();
    public static SolidColorBrush get_Honeydew();
    public static SolidColorBrush get_HotPink();
    public static SolidColorBrush get_IndianRed();
    public static SolidColorBrush get_Indigo();
    public static SolidColorBrush get_Ivory();
    public static SolidColorBrush get_Khaki();
    public static SolidColorBrush get_Lavender();
    public static SolidColorBrush get_LavenderBlush();
    public static SolidColorBrush get_LawnGreen();
    public static SolidColorBrush get_LemonChiffon();
    public static SolidColorBrush get_LightBlue();
    public static SolidColorBrush get_LightCoral();
    public static SolidColorBrush get_LightCyan();
    public static SolidColorBrush get_LightGoldenrodYellow();
    public static SolidColorBrush get_LightGray();
    public static SolidColorBrush get_LightGreen();
    public static SolidColorBrush get_LightPink();
    public static SolidColorBrush get_LightSalmon();
    public static SolidColorBrush get_LightSeaGreen();
    public static SolidColorBrush get_LightSkyBlue();
    public static SolidColorBrush get_LightSlateGray();
    public static SolidColorBrush get_LightSteelBlue();
    public static SolidColorBrush get_LightYellow();
    public static SolidColorBrush get_Lime();
    public static SolidColorBrush get_LimeGreen();
    public static SolidColorBrush get_Linen();
    public static SolidColorBrush get_Magenta();
    public static SolidColorBrush get_Maroon();
    public static SolidColorBrush get_MediumAquamarine();
    public static SolidColorBrush get_MediumBlue();
    public static SolidColorBrush get_MediumOrchid();
    public static SolidColorBrush get_MediumPurple();
    public static SolidColorBrush get_MediumSeaGreen();
    public static SolidColorBrush get_MediumSlateBlue();
    public static SolidColorBrush get_MediumSpringGreen();
    public static SolidColorBrush get_MediumTurquoise();
    public static SolidColorBrush get_MediumVioletRed();
    public static SolidColorBrush get_MidnightBlue();
    public static SolidColorBrush get_MintCream();
    public static SolidColorBrush get_MistyRose();
    public static SolidColorBrush get_Moccasin();
    public static SolidColorBrush get_NavajoWhite();
    public static SolidColorBrush get_Navy();
    public static SolidColorBrush get_OldLace();
    public static SolidColorBrush get_Olive();
    public static SolidColorBrush get_OliveDrab();
    public static SolidColorBrush get_Orange();
    public static SolidColorBrush get_OrangeRed();
    public static SolidColorBrush get_Orchid();
    public static SolidColorBrush get_PaleGoldenrod();
    public static SolidColorBrush get_PaleGreen();
    public static SolidColorBrush get_PaleTurquoise();
    public static SolidColorBrush get_PaleVioletRed();
    public static SolidColorBrush get_PapayaWhip();
    public static SolidColorBrush get_PeachPuff();
    public static SolidColorBrush get_Peru();
    public static SolidColorBrush get_Pink();
    public static SolidColorBrush get_Plum();
    public static SolidColorBrush get_PowderBlue();
    public static SolidColorBrush get_Purple();
    public static SolidColorBrush get_Red();
    public static SolidColorBrush get_RosyBrown();
    public static SolidColorBrush get_RoyalBlue();
    public static SolidColorBrush get_SaddleBrown();
    public static SolidColorBrush get_Salmon();
    public static SolidColorBrush get_SandyBrown();
    public static SolidColorBrush get_SeaGreen();
    public static SolidColorBrush get_SeaShell();
    public static SolidColorBrush get_Sienna();
    public static SolidColorBrush get_Silver();
    public static SolidColorBrush get_SkyBlue();
    public static SolidColorBrush get_SlateBlue();
    public static SolidColorBrush get_SlateGray();
    public static SolidColorBrush get_Snow();
    public static SolidColorBrush get_SpringGreen();
    public static SolidColorBrush get_SteelBlue();
    public static SolidColorBrush get_Tan();
    public static SolidColorBrush get_Teal();
    public static SolidColorBrush get_Thistle();
    public static SolidColorBrush get_Tomato();
    public static SolidColorBrush get_Transparent();
    public static SolidColorBrush get_Turquoise();
    public static SolidColorBrush get_Violet();
    public static SolidColorBrush get_Wheat();
    public static SolidColorBrush get_White();
    public static SolidColorBrush get_WhiteSmoke();
    public static SolidColorBrush get_Yellow();
    public static SolidColorBrush get_YellowGreen();
}
public enum System.Windows.Media.BrushMappingMode : Enum {
    public int value__;
    public static BrushMappingMode Absolute;
    public static BrushMappingMode RelativeToBoundingBox;
}
internal class System.Windows.Media.ByteStreamGeometryContext : CapacityStreamGeometryContext {
    public virtual void Close();
    [SecurityCriticalAttribute]
public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    [SecuritySafeCriticalAttribute]
public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    [SecuritySafeCriticalAttribute]
public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    [SecuritySafeCriticalAttribute]
public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    [SecurityCriticalAttribute]
public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal Byte[] GetData();
    internal virtual void SetClosedState(bool isClosed);
    protected virtual void CloseCore(Byte[] geometryData);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void DisposeCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ShrinkToFit();
}
[TypeConverterAttribute("System.Windows.Media.CacheModeConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.CacheModeValueSerializer")]
public abstract class System.Windows.Media.CacheMode : Animatable {
    internal static CacheMode Parse(string value);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public CacheMode Clone();
    public CacheMode CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.CacheModeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.CachingHint : Enum {
    public int value__;
    public static CachingHint Unspecified;
    public static CachingHint Cache;
}
internal abstract class System.Windows.Media.CapacityStreamGeometryContext : StreamGeometryContext {
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
}
public class System.Windows.Media.CharacterMetrics : object {
    public string Metrics { get; public set; }
    public double BlackBoxWidth { get; }
    public double BlackBoxHeight { get; }
    public double Baseline { get; }
    public double LeftSideBearing { get; }
    public double RightSideBearing { get; }
    public double TopSideBearing { get; }
    public double BottomSideBearing { get; }
    public CharacterMetrics(string metrics);
    public string get_Metrics();
    public void set_Metrics(string value);
    public double get_BlackBoxWidth();
    public double get_BlackBoxHeight();
    public double get_Baseline();
    public double get_LeftSideBearing();
    public double get_RightSideBearing();
    public double get_TopSideBearing();
    public double get_BottomSideBearing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.CharacterMetricsDictionary : object {
    internal static int LastDeviceFontCharacterCode;
    internal static int PageShift;
    internal static int PageSize;
    internal static int PageMask;
    internal static int PageCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CharacterMetrics Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<int> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<CharacterMetrics> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<int, CharacterMetrics>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(int key, CharacterMetrics& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<int, CharacterMetrics> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<int, CharacterMetrics> item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(int key, CharacterMetrics value);
    public sealed virtual bool ContainsKey(int key);
    public sealed virtual bool Remove(int key);
    public sealed virtual CharacterMetrics get_Item(int key);
    public sealed virtual void set_Item(int key, CharacterMetrics value);
    public sealed virtual ICollection`1<int> get_Keys();
    public sealed virtual ICollection`1<CharacterMetrics> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    internal CharacterMetrics[] GetPage(int i);
    internal CharacterMetrics GetValue(int key);
    internal static int ConvertKey(object key);
}
public enum System.Windows.Media.ClearTypeHint : Enum {
    public int value__;
    public static ClearTypeHint Auto;
    public static ClearTypeHint Enabled;
}
[TypeConverterAttribute("System.Windows.Media.ColorConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Color : ValueType {
    private ColorContext context;
    private MILColorF scRgbColor;
    private MILColor sRgbColor;
    private Single[] nativeColorValue;
    private bool isFromScRgb;
    private static string c_scRgbFormat;
    public ColorContext ColorContext { get; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float ScA { get; public set; }
    public float ScR { get; public set; }
    public float ScG { get; public set; }
    public float ScB { get; public set; }
    public static Color FromAValues(float a, Single[] values, Uri profileUri);
    public static Color FromValues(Single[] values, Uri profileUri);
    internal static Color FromUInt32(UInt32 argb);
    public static Color FromScRgb(float a, float r, float g, float b);
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromRgb(byte r, byte g, byte b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static bool AreClose(Color color1, Color color2);
    public void Clamp();
    public Single[] GetNativeColorValues();
    public static Color op_Addition(Color color1, Color color2);
    public static Color Add(Color color1, Color color2);
    public static Color op_Subtraction(Color color1, Color color2);
    public static Color Subtract(Color color1, Color color2);
    public static Color op_Multiply(Color color, float coefficient);
    public static Color Multiply(Color color, float coefficient);
    public static bool Equals(Color color1, Color color2);
    public sealed virtual bool Equals(Color color);
    public virtual bool Equals(object o);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
    public ColorContext get_ColorContext();
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_ScA();
    public void set_ScA(float value);
    public float get_ScR();
    public void set_ScR(float value);
    public float get_ScG();
    public void set_ScG(float value);
    public float get_ScB();
    public void set_ScB(float value);
}
public class System.Windows.Media.ColorContext : object {
    public Uri ProfileUri { get; }
    internal SafeProfileHandle ProfileHandle { get; }
    internal SafeMILHandle ColorContextHandle { get; }
    internal int NumChannels { get; }
    internal UInt32 ColorType { get; }
    internal StandardColorSpace ColorSpaceFamily { get; }
    internal bool IsValid { get; }
    [SecurityCriticalAttribute]
public ColorContext(Uri profileUri);
    [SecurityCriticalAttribute]
public ColorContext(PixelFormat pixelFormat);
    private static ColorContext();
    [SecurityCriticalAttribute]
public Stream OpenProfileStream();
    [SecurityCriticalAttribute]
public Uri get_ProfileUri();
    [SecurityCriticalAttribute]
internal SafeProfileHandle get_ProfileHandle();
    [SecurityCriticalAttribute]
internal SafeMILHandle get_ColorContextHandle();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal int get_NumChannels();
    internal UInt32 get_ColorType();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal StandardColorSpace get_ColorSpaceFamily();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_IsValid();
    [SecurityCriticalAttribute]
internal static IList`1<ColorContext> GetColorContextsHelper(GetColorContextsDelegate getColorContexts);
    public virtual bool Equals(object obj);
    [SecurityCriticalAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public static bool op_Equality(ColorContext context1, ColorContext context2);
    public static bool op_Inequality(ColorContext context1, ColorContext context2);
}
internal class System.Windows.Media.ColorContextHelper : ValueType {
    [SecurityCriticalAttribute]
private SafeProfileHandle _profileHandle;
    internal bool IsInvalid { get; }
    internal SafeProfileHandle ProfileHandle { get; }
    [SecurityCriticalAttribute]
internal void OpenColorProfile(PROFILE& profile);
    [SecurityCriticalAttribute]
internal bool GetColorProfileHeader(PROFILEHEADER& header);
    [SecurityCriticalAttribute]
internal void GetColorProfileFromHandle(Byte[] buffer, UInt32& bufferSize);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_IsInvalid();
    [SecurityCriticalAttribute]
internal SafeProfileHandle get_ProfileHandle();
}
public class System.Windows.Media.ColorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public static object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.ColorInterpolationMode : Enum {
    public int value__;
    public static ColorInterpolationMode ScRgbLinearInterpolation;
    public static ColorInterpolationMode SRgbLinearInterpolation;
}
public class System.Windows.Media.Colors : object {
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
internal class System.Windows.Media.ColorTransform : object {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ColorTransform(ColorContext srcContext, ColorContext dstContext);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ColorTransform(SafeMILHandle bitmapSource, ColorContext srcContext, ColorContext dstContext, PixelFormat pixelFormat);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Translate(Single[] srcValue, Single[] dstValue);
}
internal class System.Windows.Media.ColorTransformHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal ColorTransformHandle(IntPtr profile);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.ColorTransformHelper : object {
    [SecurityCriticalAttribute]
internal void CreateTransform(SafeProfileHandle sourceProfile, SafeProfileHandle destinationProfile);
    [SecurityCriticalAttribute]
internal void TranslateColors(IntPtr paInputColors, UInt32 numColors, UInt32 inputColorType, IntPtr paOutputColors, UInt32 outputColorType);
}
public class System.Windows.Media.CombinedGeometry : Geometry {
    public static DependencyProperty GeometryCombineModeProperty;
    public static DependencyProperty Geometry1Property;
    public static DependencyProperty Geometry2Property;
    internal MultiChannelResource _duceResource;
    internal static GeometryCombineMode c_GeometryCombineMode;
    internal static Geometry s_Geometry1;
    internal static Geometry s_Geometry2;
    public Rect Bounds { get; }
    public GeometryCombineMode GeometryCombineMode { get; public set; }
    public Geometry Geometry1 { get; public set; }
    public Geometry Geometry2 { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public CombinedGeometry(Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2, Transform transform);
    private static CombinedGeometry();
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual PathGeometry GetAsPathGeometry();
    public virtual bool IsEmpty();
    internal virtual bool IsObviouslyEmpty();
    public virtual bool MayHaveCurves();
    public CombinedGeometry Clone();
    public CombinedGeometry CloneCurrentValue();
    public GeometryCombineMode get_GeometryCombineMode();
    public void set_GeometryCombineMode(GeometryCombineMode value);
    public Geometry get_Geometry1();
    public void set_Geometry1(Geometry value);
    public Geometry get_Geometry2();
    public void set_Geometry2(Geometry value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal enum System.Windows.Media.Composition.ChannelMarshalType : Enum {
    public int value__;
    public static ChannelMarshalType ChannelMarshalTypeInvalid;
    public static ChannelMarshalType ChannelMarshalTypeSameThread;
    public static ChannelMarshalType ChannelMarshalTypeCrossThread;
}
internal class System.Windows.Media.Composition.CompositionEngineLock : ValueType {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static CompositionEngineLock Acquire();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
}
internal static class System.Windows.Media.Composition.CompositionResourceManager : object {
    public static int InvalidResourceHandle;
    internal static MilColorF ColorToMilColorF(Color c);
    internal static D3DMATRIX Matrix3DToD3DMATRIX(Matrix3D m);
    internal static MilPoint3F Point3DToMilPoint3F(Point3D p);
    internal static MilPoint3F Vector3DToMilPoint3F(Vector3D v);
    internal static MilQuaternionF QuaternionToMilQuaternionF(Quaternion q);
    internal static MilMatrix4x4D MatrixToMilMatrix4x4D(Matrix m);
    internal static MilMatrix3x2D TransformToMilMatrix3x2D(Transform t);
    internal static MilMatrix3x2D MatrixToMilMatrix3x2D(Matrix m);
    internal static MilMatrix3x2D MatrixToMilMatrix3x2D(Matrix& m);
    internal static Matrix MilMatrix3x2DToMatrix(MilMatrix3x2D& m);
    internal static UInt32 BooleanToUInt32(bool v);
}
internal class System.Windows.Media.Composition.D3DMATRIX : ValueType {
    internal float _11;
    internal float _12;
    internal float _13;
    internal float _14;
    internal float _21;
    internal float _22;
    internal float _23;
    internal float _24;
    internal float _31;
    internal float _32;
    internal float _33;
    internal float _34;
    internal float _41;
    internal float _42;
    internal float _43;
    internal float _44;
    internal D3DMATRIX(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
}
internal class System.Windows.Media.Composition.DUCE : object {
    internal static UInt32 waitInfinite;
    [SecurityCriticalAttribute]
internal static void CopyBytes(Byte* pbTo, Byte* pbFrom, int cbData);
    [SecuritySafeCriticalAttribute]
internal static void NotifyPolicyChangeForNonInteractiveMode(bool forceRender, Channel channel);
}
internal class System.Windows.Media.Composition.MIL_PATHFIGURE : ValueType {
    internal UInt32 BackSize;
    internal MilPathFigureFlags Flags;
    internal UInt32 Count;
    internal UInt32 Size;
    internal Point StartPoint;
    internal UInt32 OffsetToLastSegment;
    internal UInt32 ForcePacking;
}
internal class System.Windows.Media.Composition.MIL_PATHGEOMETRY : ValueType {
    internal UInt32 Size;
    internal MilPathGeometryFlags Flags;
    internal MilRectD Bounds;
    internal UInt32 FigureCount;
    internal UInt32 ForcePacking;
}
internal enum System.Windows.Media.Composition.MIL_PEN_CAP : Enum {
    public int value__;
    public static MIL_PEN_CAP MilPenCapFlat;
    public static MIL_PEN_CAP MilPenCapSquare;
    public static MIL_PEN_CAP MilPenCapRound;
    public static MIL_PEN_CAP MilPenCapTriangle;
    public static MIL_PEN_CAP MIL_PEN_CAP_FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MIL_PEN_DATA : ValueType {
    internal double Thickness;
    internal double MiterLimit;
    internal double DashOffset;
    internal MIL_PEN_CAP StartLineCap;
    internal MIL_PEN_CAP EndLineCap;
    internal MIL_PEN_CAP DashCap;
    internal MIL_PEN_JOIN LineJoin;
    internal UInt32 DashArraySize;
}
internal enum System.Windows.Media.Composition.MIL_PEN_JOIN : Enum {
    public int value__;
    public static MIL_PEN_JOIN MilPenJoinMiter;
    public static MIL_PEN_JOIN MilPenJoinBevel;
    public static MIL_PEN_JOIN MilPenJoinRound;
    public static MIL_PEN_JOIN MIL_PEN_JOIN_FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MIL_PRESENTATION_RESULTS : Enum {
    public int value__;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_VSYNC;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_NOPRESENT;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_VSYNC_UNSUPPORTED;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_DWM;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_ARC : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 LargeArc;
    internal Point Point;
    internal Size Size;
    internal double XRotation;
    internal UInt32 Sweep;
    internal UInt32 ForcePacking;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_BEZIER : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point1;
    internal Point Point2;
    internal Point Point3;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_LINE : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_POLY : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 Count;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_QUADRATICBEZIER : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point1;
    internal Point Point2;
}
internal enum System.Windows.Media.Composition.MIL_SEGMENT_TYPE : Enum {
    public int value__;
    public static MIL_SEGMENT_TYPE MilSegmentNone;
    public static MIL_SEGMENT_TYPE MilSegmentLine;
    public static MIL_SEGMENT_TYPE MilSegmentBezier;
    public static MIL_SEGMENT_TYPE MilSegmentQuadraticBezier;
    public static MIL_SEGMENT_TYPE MilSegmentArc;
    public static MIL_SEGMENT_TYPE MilSegmentPolyLine;
    public static MIL_SEGMENT_TYPE MilSegmentPolyBezier;
    public static MIL_SEGMENT_TYPE MilSegmentPolyQuadraticBezier;
    public static MIL_SEGMENT_TYPE MIL_SEGMENT_TYPE_FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MILCMD : Enum {
    public int value__;
    public static MILCMD MilCmdInvalid;
    public static MILCMD MilCmdTransportSyncFlush;
    public static MILCMD MilCmdTransportDestroyResourcesOnChannel;
    public static MILCMD MilCmdPartitionRegisterForNotifications;
    public static MILCMD MilCmdChannelRequestTier;
    public static MILCMD MilCmdPartitionSetVBlankSyncMode;
    public static MILCMD MilCmdPartitionNotifyPresent;
    public static MILCMD MilCmdChannelCreateResource;
    public static MILCMD MilCmdChannelDeleteResource;
    public static MILCMD MilCmdChannelDuplicateHandle;
    public static MILCMD MilCmdD3DImage;
    public static MILCMD MilCmdD3DImagePresent;
    public static MILCMD MilCmdBitmapSource;
    public static MILCMD MilCmdBitmapInvalidate;
    public static MILCMD MilCmdDoubleResource;
    public static MILCMD MilCmdColorResource;
    public static MILCMD MilCmdPointResource;
    public static MILCMD MilCmdRectResource;
    public static MILCMD MilCmdSizeResource;
    public static MILCMD MilCmdMatrixResource;
    public static MILCMD MilCmdPoint3DResource;
    public static MILCMD MilCmdVector3DResource;
    public static MILCMD MilCmdQuaternionResource;
    public static MILCMD MilCmdMediaPlayer;
    public static MILCMD MilCmdRenderData;
    public static MILCMD MilCmdEtwEventResource;
    public static MILCMD MilCmdVisualCreate;
    public static MILCMD MilCmdVisualSetOffset;
    public static MILCMD MilCmdVisualSetTransform;
    public static MILCMD MilCmdVisualSetEffect;
    public static MILCMD MilCmdVisualSetCacheMode;
    public static MILCMD MilCmdVisualSetClip;
    public static MILCMD MilCmdVisualSetAlpha;
    public static MILCMD MilCmdVisualSetRenderOptions;
    public static MILCMD MilCmdVisualSetContent;
    public static MILCMD MilCmdVisualSetAlphaMask;
    public static MILCMD MilCmdVisualRemoveAllChildren;
    public static MILCMD MilCmdVisualRemoveChild;
    public static MILCMD MilCmdVisualInsertChildAt;
    public static MILCMD MilCmdVisualSetGuidelineCollection;
    public static MILCMD MilCmdVisualSetScrollableAreaClip;
    public static MILCMD MilCmdViewport3DVisualSetCamera;
    public static MILCMD MilCmdViewport3DVisualSetViewport;
    public static MILCMD MilCmdViewport3DVisualSet3DChild;
    public static MILCMD MilCmdVisual3DSetContent;
    public static MILCMD MilCmdVisual3DSetTransform;
    public static MILCMD MilCmdVisual3DRemoveAllChildren;
    public static MILCMD MilCmdVisual3DRemoveChild;
    public static MILCMD MilCmdVisual3DInsertChildAt;
    public static MILCMD MilCmdHwndTargetCreate;
    public static MILCMD MilCmdHwndTargetSuppressLayered;
    public static MILCMD MilCmdTargetUpdateWindowSettings;
    public static MILCMD MilCmdGenericTargetCreate;
    public static MILCMD MilCmdTargetSetRoot;
    public static MILCMD MilCmdTargetSetClearColor;
    public static MILCMD MilCmdTargetInvalidate;
    public static MILCMD MilCmdTargetSetFlags;
    public static MILCMD MilCmdGlyphRunCreate;
    public static MILCMD MilCmdDoubleBufferedBitmap;
    public static MILCMD MilCmdDoubleBufferedBitmapCopyForward;
    public static MILCMD MilCmdPartitionNotifyPolicyChangeForNonInteractiveMode;
    public static MILCMD MilDrawLine;
    public static MILCMD MilDrawLineAnimate;
    public static MILCMD MilDrawRectangle;
    public static MILCMD MilDrawRectangleAnimate;
    public static MILCMD MilDrawRoundedRectangle;
    public static MILCMD MilDrawRoundedRectangleAnimate;
    public static MILCMD MilDrawEllipse;
    public static MILCMD MilDrawEllipseAnimate;
    public static MILCMD MilDrawGeometry;
    public static MILCMD MilDrawImage;
    public static MILCMD MilDrawImageAnimate;
    public static MILCMD MilDrawGlyphRun;
    public static MILCMD MilDrawDrawing;
    public static MILCMD MilDrawVideo;
    public static MILCMD MilDrawVideoAnimate;
    public static MILCMD MilPushClip;
    public static MILCMD MilPushOpacityMask;
    public static MILCMD MilPushOpacity;
    public static MILCMD MilPushOpacityAnimate;
    public static MILCMD MilPushTransform;
    public static MILCMD MilPushGuidelineSet;
    public static MILCMD MilPushGuidelineY1;
    public static MILCMD MilPushGuidelineY2;
    public static MILCMD MilPushEffect;
    public static MILCMD MilPop;
    public static MILCMD MilCmdAxisAngleRotation3D;
    public static MILCMD MilCmdQuaternionRotation3D;
    public static MILCMD MilCmdPerspectiveCamera;
    public static MILCMD MilCmdOrthographicCamera;
    public static MILCMD MilCmdMatrixCamera;
    public static MILCMD MilCmdModel3DGroup;
    public static MILCMD MilCmdAmbientLight;
    public static MILCMD MilCmdDirectionalLight;
    public static MILCMD MilCmdPointLight;
    public static MILCMD MilCmdSpotLight;
    public static MILCMD MilCmdGeometryModel3D;
    public static MILCMD MilCmdMeshGeometry3D;
    public static MILCMD MilCmdMaterialGroup;
    public static MILCMD MilCmdDiffuseMaterial;
    public static MILCMD MilCmdSpecularMaterial;
    public static MILCMD MilCmdEmissiveMaterial;
    public static MILCMD MilCmdTransform3DGroup;
    public static MILCMD MilCmdTranslateTransform3D;
    public static MILCMD MilCmdScaleTransform3D;
    public static MILCMD MilCmdRotateTransform3D;
    public static MILCMD MilCmdMatrixTransform3D;
    public static MILCMD MilCmdPixelShader;
    public static MILCMD MilCmdImplicitInputBrush;
    public static MILCMD MilCmdBlurEffect;
    public static MILCMD MilCmdDropShadowEffect;
    public static MILCMD MilCmdShaderEffect;
    public static MILCMD MilCmdDrawingImage;
    public static MILCMD MilCmdTransformGroup;
    public static MILCMD MilCmdTranslateTransform;
    public static MILCMD MilCmdScaleTransform;
    public static MILCMD MilCmdSkewTransform;
    public static MILCMD MilCmdRotateTransform;
    public static MILCMD MilCmdMatrixTransform;
    public static MILCMD MilCmdLineGeometry;
    public static MILCMD MilCmdRectangleGeometry;
    public static MILCMD MilCmdEllipseGeometry;
    public static MILCMD MilCmdGeometryGroup;
    public static MILCMD MilCmdCombinedGeometry;
    public static MILCMD MilCmdPathGeometry;
    public static MILCMD MilCmdSolidColorBrush;
    public static MILCMD MilCmdLinearGradientBrush;
    public static MILCMD MilCmdRadialGradientBrush;
    public static MILCMD MilCmdImageBrush;
    public static MILCMD MilCmdDrawingBrush;
    public static MILCMD MilCmdVisualBrush;
    public static MILCMD MilCmdBitmapCacheBrush;
    public static MILCMD MilCmdDashStyle;
    public static MILCMD MilCmdPen;
    public static MILCMD MilCmdGeometryDrawing;
    public static MILCMD MilCmdGlyphRunDrawing;
    public static MILCMD MilCmdImageDrawing;
    public static MILCMD MilCmdVideoDrawing;
    public static MILCMD MilCmdDrawingGroup;
    public static MILCMD MilCmdGuidelineSet;
    public static MILCMD MilCmdBitmapCache;
}
internal class System.Windows.Media.Composition.MilColorF : ValueType {
    internal float r;
    internal float g;
    internal float b;
    internal float a;
}
internal class System.Windows.Media.Composition.MilColorI : ValueType {
    internal int r;
    internal int g;
    internal int b;
    internal int a;
}
internal enum System.Windows.Media.Composition.MilCompositingMode : Enum {
    public int value__;
    public static MilCompositingMode SourceOver;
    public static MilCompositingMode SourceCopy;
    public static MilCompositingMode SourceAdd;
    public static MilCompositingMode SourceAlphaMultiply;
    public static MilCompositingMode SourceInverseAlphaMultiply;
    public static MilCompositingMode SourceUnder;
    public static MilCompositingMode SourceOverNonPremultiplied;
    public static MilCompositingMode SourceInverseAlphaOverNonPremultiplied;
    public static MilCompositingMode DestInvert;
    public static MilCompositingMode Last;
    public static MilCompositingMode FORCE_DWORD;
}
internal static class System.Windows.Media.Composition.MilCoreApi : object {
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int MilComposition_SyncFlush(IntPtr pChannel);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int MilUtility_GetPointAtLengthFraction(MilMatrix3x2D* pMatrix, FillRule fillRule, Byte* pPathData, UInt32 nSize, double rFraction, Point& pt, Point& vecTangent);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int MilUtility_PolygonBounds(MilMatrix3x2D* pWorldMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, Point* pPoints, Byte* pTypes, UInt32 pointCount, UInt32 segmentCount, MilMatrix3x2D* pGeometryMatrix, double rTolerance, bool fRelative, bool fSkipHollows, Rect* pBounds);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int MilUtility_PolygonHitTest(MilMatrix3x2D* pGeometryMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, Point* pPoints, Byte* pTypes, UInt32 cPoints, UInt32 cSegments, double rTolerance, bool fRelative, Point* pHitPoint, Boolean& pDoesContain);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static int MilUtility_PathGeometryHitTest(MilMatrix3x2D* pMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, FillRule fillRule, Byte* pPathData, UInt32 nSize, double rTolerance, bool fRelative, Point* pHitPoint, Boolean& pDoesContain);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int MilUtility_PathGeometryHitTestPathGeometry(MilMatrix3x2D* pMatrix1, FillRule fillRule1, Byte* pPathData1, UInt32 nSize1, MilMatrix3x2D* pMatrix2, FillRule fillRule2, Byte* pPathData2, UInt32 nSize2, double rTolerance, bool fRelative, IntersectionDetail* pDetail);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int MilUtility_GeometryGetArea(FillRule fillRule, Byte* pPathData, UInt32 nSize, MilMatrix3x2D* pMatrix, double rTolerance, bool fRelative, Double* pArea);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static void MilUtility_ArcToBezier(Point ptStart, Size rRadii, double rRotation, bool fLargeArc, SweepDirection fSweepUp, Point ptEnd, MilMatrix3x2D* pMatrix, Point* pPt, Int32& cPieces);
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILCoreSegFlags : Enum {
    public int value__;
    public static MILCoreSegFlags SegTypeLine;
    public static MILCoreSegFlags SegTypeBezier;
    public static MILCoreSegFlags SegTypeMask;
    public static MILCoreSegFlags SegIsAGap;
    public static MILCoreSegFlags SegSmoothJoin;
    public static MILCoreSegFlags SegClosed;
    public static MILCoreSegFlags SegIsCurved;
    public static MILCoreSegFlags FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilGraphicsAccelerationCaps : ValueType {
    internal int TierValue;
    internal int HasWDDMSupport;
    internal UInt32 PixelShaderVersion;
    internal UInt32 VertexShaderVersion;
    internal UInt32 MaxTextureWidth;
    internal UInt32 MaxTextureHeight;
    internal int WindowCompatibleMode;
    internal UInt32 BitsPerPixel;
    internal UInt32 HasSSE2Support;
    internal UInt32 MaxPixelShader30InstructionSlots;
}
internal class System.Windows.Media.Composition.MilMatrix3x2D : ValueType {
    internal double S_11;
    internal double S_12;
    internal double S_21;
    internal double S_22;
    internal double DX;
    internal double DY;
}
internal class System.Windows.Media.Composition.MilMatrix4x4D : ValueType {
    internal double M_11;
    internal double M_12;
    internal double M_13;
    internal double M_14;
    internal double M_21;
    internal double M_22;
    internal double M_23;
    internal double M_24;
    internal double M_31;
    internal double M_32;
    internal double M_33;
    internal double M_34;
    internal double M_41;
    internal double M_42;
    internal double M_43;
    internal double M_44;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilPathFigureFlags : Enum {
    public int value__;
    public static MilPathFigureFlags HasGaps;
    public static MilPathFigureFlags HasCurves;
    public static MilPathFigureFlags IsClosed;
    public static MilPathFigureFlags IsFillable;
    public static MilPathFigureFlags IsRectangleData;
    public static MilPathFigureFlags Mask;
    public static MilPathFigureFlags FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilPathGeometryFlags : Enum {
    public int value__;
    public static MilPathGeometryFlags HasCurves;
    public static MilPathGeometryFlags BoundsValid;
    public static MilPathGeometryFlags HasGaps;
    public static MilPathGeometryFlags HasHollows;
    public static MilPathGeometryFlags IsRegionData;
    public static MilPathGeometryFlags Mask;
    public static MilPathGeometryFlags FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilPoint2F : ValueType {
    internal float X;
    internal float Y;
}
internal class System.Windows.Media.Composition.MilPoint3F : ValueType {
    internal float X;
    internal float Y;
    internal float Z;
}
internal class System.Windows.Media.Composition.MilQuaternionF : ValueType {
    internal float X;
    internal float Y;
    internal float Z;
    internal float W;
}
internal class System.Windows.Media.Composition.MilRectD : ValueType {
    internal double _left;
    internal double _top;
    internal double _right;
    internal double _bottom;
    internal static MilRectD Empty { get; }
    internal static MilRectD NaN { get; }
    internal Rect AsRect { get; }
    internal MilRectD(double left, double top, double right, double bottom);
    internal static MilRectD get_Empty();
    internal static MilRectD get_NaN();
    internal Rect get_AsRect();
}
internal class System.Windows.Media.Composition.MilRectF : ValueType {
    internal float _left;
    internal float _top;
    internal float _right;
    internal float _bottom;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilRenderOptionFlags : Enum {
    public int value__;
    public static MilRenderOptionFlags BitmapScalingMode;
    public static MilRenderOptionFlags EdgeMode;
    public static MilRenderOptionFlags CompositingMode;
    public static MilRenderOptionFlags ClearTypeHint;
    public static MilRenderOptionFlags TextRenderingMode;
    public static MilRenderOptionFlags TextHintingMode;
    public static MilRenderOptionFlags Last;
    public static MilRenderOptionFlags FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilRenderOptions : ValueType {
    internal MilRenderOptionFlags Flags;
    internal EdgeMode EdgeMode;
    internal MilCompositingMode CompositingMode;
    internal BitmapScalingMode BitmapScalingMode;
    internal ClearTypeHint ClearTypeHint;
    internal TextRenderingMode TextRenderingMode;
    internal TextHintingMode TextHintingMode;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILRTInitializationFlags : Enum {
    public int value__;
    public static MILRTInitializationFlags MIL_RT_INITIALIZE_DEFAULT;
    public static MILRTInitializationFlags MIL_RT_SOFTWARE_ONLY;
    public static MILRTInitializationFlags MIL_RT_HARDWARE_ONLY;
    public static MILRTInitializationFlags MIL_RT_NULL;
    public static MILRTInitializationFlags MIL_RT_TYPE_MASK;
    public static MILRTInitializationFlags MIL_RT_PRESENT_IMMEDIATELY;
    public static MILRTInitializationFlags MIL_RT_PRESENT_RETAIN_CONTENTS;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN;
    public static MILRTInitializationFlags MIL_RT_LINEAR_GAMMA;
    public static MILRTInitializationFlags MIL_RT_NEED_DESTINATION_ALPHA;
    public static MILRTInitializationFlags MIL_RT_ALLOW_LOW_PRECISION;
    public static MILRTInitializationFlags MIL_RT_SINGLE_THREADED_USAGE;
    public static MILRTInitializationFlags MIL_RT_RENDER_NONCLIENT;
    public static MILRTInitializationFlags MIL_RT_PRESENT_FLIP;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN_NO_AUTOROTATE;
    public static MILRTInitializationFlags MIL_RT_DISABLE_DISPLAY_CLIPPING;
    public static MILRTInitializationFlags MIL_RT_DISABLE_MULTIMON_DISPLAY_CLIPPING;
    public static MILRTInitializationFlags MIL_RT_IS_DISABLE_MULTIMON_DISPLAY_CLIPPING_VALID;
    public static MILRTInitializationFlags MIL_UCE_RT_ENABLE_OCCLUSION;
    public static MILRTInitializationFlags MIL_RT_USE_REF_RAST;
    public static MILRTInitializationFlags MIL_RT_USE_RGB_RAST;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN_TRANSPOSE_XY;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_MASK;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_HAL;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_BITBLT;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_ALPHABLEND;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_ULW;
    public static MILRTInitializationFlags FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILTransparencyFlags : Enum {
    public int value__;
    public static MILTransparencyFlags Opaque;
    public static MILTransparencyFlags ConstantAlpha;
    public static MILTransparencyFlags PerPixelAlpha;
    public static MILTransparencyFlags ColorKey;
    public static MILTransparencyFlags FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MILWindowLayerType : Enum {
    public int value__;
    public static MILWindowLayerType NotLayered;
    public static MILWindowLayerType SystemManagedLayer;
    public static MILWindowLayerType ApplicationManagedLayer;
    public static MILWindowLayerType FORCE_DWORD;
}
internal class System.Windows.Media.Composition.VisualProxy : ValueType {
    private static int PROXY_NOT_FOUND;
    private static int PROXY_STORED_INLINE;
    private Proxy _head;
    private Proxy[] _tail;
    internal int Count { get; }
    internal bool IsOnAnyChannel { get; }
    internal int get_Count();
    internal bool get_IsOnAnyChannel();
    internal bool IsOnChannel(Channel channel);
    internal bool CreateOrAddRefOnChannel(object instance, Channel channel, ResourceType resourceType);
    internal bool ReleaseOnChannel(Channel channel);
    internal Channel GetChannel(int index);
    internal ResourceHandle GetHandle(Channel channel);
    internal ResourceHandle GetHandle(int index);
    internal VisualProxyFlags GetFlags(Channel channel);
    internal VisualProxyFlags GetFlags(int index);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flags);
    internal void SetFlags(int index, bool value, VisualProxyFlags flags);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flags);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags conjunctionFlags);
}
public abstract class System.Windows.Media.CompositionTarget : DispatcherObject {
    internal MultiChannelResource _contentRoot;
    internal static ResourceType s_contentRootType;
    internal bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    internal Matrix WorldTransform { get; }
    internal Rect WorldClipBounds { get; }
    internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    public virtual void Dispose();
    internal bool get_IsDisposed();
    [SecurityCriticalAttribute]
public virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public virtual void set_RootVisual(Visual value);
    public abstract virtual Matrix get_TransformToDevice();
    public abstract virtual Matrix get_TransformFromDevice();
    internal object StateChangedCallback(object arg);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.AddRefOnChannel(Channel channel, Channel outOfBandChannel);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.ReleaseOnChannel(Channel channel, Channel outOfBandChannel);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.Render(bool inResize, Channel channel);
    internal Matrix get_WorldTransform();
    internal Rect get_WorldClipBounds();
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadWrite();
    public static void add_Rendering(EventHandler value);
    public static void remove_Rendering(EventHandler value);
}
public class System.Windows.Media.ContainerVisual : Visual {
    public VisualCollection Children { get; }
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public CacheMode CacheMode { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Effect Effect { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection XSnappingGuidelines { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection YSnappingGuidelines { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    protected int VisualChildrenCount { get; }
    public VisualCollection get_Children();
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public DoubleCollection get_XSnappingGuidelines();
    public void set_XSnappingGuidelines(DoubleCollection value);
    public DoubleCollection get_YSnappingGuidelines();
    public void set_YSnappingGuidelines(DoubleCollection value);
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    protected sealed virtual Visual GetVisualChild(int index);
    protected sealed virtual int get_VisualChildrenCount();
}
[FriendAccessAllowedAttribute]
public abstract class System.Windows.Media.Converters.BaseIListConverter : TypeConverter {
    internal TokenizerHelper _tokenizer;
    internal static char DelimiterChar;
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal abstract virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal abstract virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BoolIListConverter : BaseIListConverter {
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BrushValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CacheModeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CharIListConverter : BaseIListConverter {
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.DoubleCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.DoubleIListConverter : BaseIListConverter {
    internal sealed virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.GeometryValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.Int32CollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PathFigureCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointIListConverter : BaseIListConverter {
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.TransformValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.UShortIListConverter : BaseIListConverter {
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.VectorCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.DashStyle : Animatable {
    public static DependencyProperty OffsetProperty;
    public static DependencyProperty DashesProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Offset;
    internal static DoubleCollection s_Dashes;
    public double Offset { get; public set; }
    public DoubleCollection Dashes { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DashStyle(IEnumerable`1<double> dashes, double offset);
    private static DashStyle();
    [SecurityCriticalAttribute]
internal void GetDashData(MIL_PEN_DATA* pData, Double[]& dashArray);
    public DashStyle Clone();
    public DashStyle CloneCurrentValue();
    public double get_Offset();
    public void set_Offset(double value);
    public DoubleCollection get_Dashes();
    public void set_Dashes(DoubleCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public static class System.Windows.Media.DashStyles : object {
    public static DashStyle Solid { get; }
    public static DashStyle Dash { get; }
    public static DashStyle Dot { get; }
    public static DashStyle DashDot { get; }
    public static DashStyle DashDotDot { get; }
    public static DashStyle get_Solid();
    public static DashStyle get_Dash();
    public static DashStyle get_Dot();
    public static DashStyle get_DashDot();
    public static DashStyle get_DashDotDot();
}
[ValueSerializerAttribute("System.Windows.Media.Converters.DoubleCollectionValueSerializer")]
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.DoubleCollectionConverter")]
public class System.Windows.Media.DoubleCollection : Freezable {
    internal FrugalStructList`1<double> _collection;
    internal UInt32 _version;
    public double Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Double>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static DoubleCollection Empty { get; }
    public DoubleCollection(int capacity);
    public DoubleCollection(IEnumerable`1<double> collection);
    public DoubleCollection Clone();
    public DoubleCollection CloneCurrentValue();
    public sealed virtual void Add(double value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(double value);
    public sealed virtual int IndexOf(double value);
    public sealed virtual void Insert(int index, double value);
    public sealed virtual bool Remove(double value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Double[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Double>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<double> System.Collections.Generic.IEnumerable<System.Double>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static DoubleCollection get_Empty();
    internal double Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static DoubleCollection Parse(string source);
}
public class System.Windows.Media.DoubleCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Drawing : Animatable {
    public Rect Bounds { get; }
    public Rect get_Bounds();
    internal abstract virtual void WalkCurrentValue(DrawingContextWalker ctx);
    private sealed virtual override Rect System.Windows.Media.IDrawingContent.GetContentBounds(BoundsDrawingContextWalker ctx);
    private sealed virtual override void System.Windows.Media.IDrawingContent.WalkContent(DrawingContextWalker ctx);
    private sealed virtual override bool System.Windows.Media.IDrawingContent.HitTestPoint(Point point);
    private sealed virtual override IntersectionDetail System.Windows.Media.IDrawingContent.HitTestGeometry(PathGeometry geometry);
    private sealed virtual override void System.Windows.Media.IDrawingContent.PropagateChangedHandler(EventHandler handler, bool adding);
    internal Rect GetBounds();
    public Drawing Clone();
    public Drawing CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.DrawingBrush : TileBrush {
    public static DependencyProperty DrawingProperty;
    internal MultiChannelResource _duceResource;
    public Drawing Drawing { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DrawingBrush(Drawing drawing);
    private static DrawingBrush();
    protected virtual void GetContentBounds(Rect& contentBounds);
    public DrawingBrush Clone();
    public DrawingBrush CloneCurrentValue();
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.DrawingCollection : Animatable {
    internal FrugalStructList`1<Drawing> _collection;
    internal UInt32 _version;
    public Drawing Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static DrawingCollection Empty { get; }
    public DrawingCollection(int capacity);
    public DrawingCollection(IEnumerable`1<Drawing> collection);
    internal void TransactionalAppend(DrawingCollection collectionToAppend);
    public DrawingCollection Clone();
    public DrawingCollection CloneCurrentValue();
    public sealed virtual void Add(Drawing value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Drawing value);
    public sealed virtual int IndexOf(Drawing value);
    public sealed virtual void Insert(int index, Drawing value);
    public sealed virtual bool Remove(Drawing value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Drawing get_Item(int index);
    public sealed virtual void set_Item(int index, Drawing value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Drawing[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Drawing> System.Collections.Generic.IEnumerable<System.Windows.Media.Drawing>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static DrawingCollection get_Empty();
    internal Drawing Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Drawing value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public abstract class System.Windows.Media.DrawingContext : DispatcherObject {
    public void DrawText(FormattedText formattedText, Point origin);
    public abstract virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void DisposeCore();
    protected virtual void VerifyApiNonstructuralChange();
    public abstract virtual void DrawLine(Pen pen, Point point0, Point point1);
    public abstract virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public abstract virtual void DrawDrawing(Drawing drawing);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void PushClip(Geometry clipGeometry);
    public abstract virtual void PushOpacityMask(Brush opacityMask);
    public abstract virtual void PushOpacity(double opacity);
    public abstract virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public abstract virtual void PushTransform(Transform transform);
    public abstract virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal abstract virtual void PushGuidelineY1(double coordinate);
    internal abstract virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public abstract virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public abstract virtual void Pop();
}
internal class System.Windows.Media.DrawingContextDrawingContextWalker : DrawingContextWalker {
    public DrawingContextDrawingContextWalker(DrawingContext drawingContext);
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush opacityMask);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
}
internal abstract class System.Windows.Media.DrawingContextWalker : DrawingContext {
    internal bool ShouldStopWalking { get; internal set; }
    public sealed virtual void Close();
    protected virtual void DisposeCore();
    protected void StopWalking();
    internal bool get_ShouldStopWalking();
    internal void set_ShouldStopWalking(bool value);
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush opacityMask);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
}
internal class System.Windows.Media.DrawingDrawingContext : DrawingContext {
    protected Drawing _rootDrawing;
    protected DrawingGroup _currentDrawingGroup;
    internal bool CanBeInheritanceContext { get; internal set; }
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void Close();
    protected virtual void DisposeCore();
    protected virtual void CloseCore(DrawingCollection rootDrawingGroupChildren);
    protected virtual void VerifyApiNonstructuralChange();
    internal bool get_CanBeInheritanceContext();
    internal void set_CanBeInheritanceContext(bool value);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.DrawingGroup : Drawing {
    public static DependencyProperty ChildrenProperty;
    public static DependencyProperty ClipGeometryProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty GuidelineSetProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    internal MultiChannelResource _duceResource;
    internal static DrawingCollection s_Children;
    internal static double c_Opacity;
    internal static EdgeMode c_EdgeMode;
    internal static BitmapScalingMode c_BitmapScalingMode;
    internal static ClearTypeHint c_ClearTypeHint;
    public DrawingCollection Children { get; public set; }
    public Geometry ClipGeometry { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public Transform Transform { get; public set; }
    public GuidelineSet GuidelineSet { get; public set; }
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    private static DrawingGroup();
    public DrawingContext Open();
    public DrawingContext Append();
    internal void Close(DrawingCollection rootDrawingGroupChildren);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    public DrawingGroup Clone();
    public DrawingGroup CloneCurrentValue();
    public DrawingCollection get_Children();
    public void set_Children(DrawingCollection value);
    public Geometry get_ClipGeometry();
    public void set_ClipGeometry(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public GuidelineSet get_GuidelineSet();
    public void set_GuidelineSet(GuidelineSet value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
internal class System.Windows.Media.DrawingGroupDrawingContext : DrawingDrawingContext {
    internal DrawingGroupDrawingContext(DrawingGroup drawingGroup);
    protected virtual void CloseCore(DrawingCollection rootDrawingGroupChildren);
}
public class System.Windows.Media.DrawingImage : ImageSource {
    public static DependencyProperty DrawingProperty;
    internal MultiChannelResource _duceResource;
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    public Drawing Drawing { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DrawingImage(Drawing drawing);
    private static DrawingImage();
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    internal virtual Size get_Size();
    public DrawingImage Clone();
    public DrawingImage CloneCurrentValue();
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal static class System.Windows.Media.DrawingServices : object {
    internal static bool HitTestPoint(Drawing drawing, Point point);
    internal static IntersectionDetail HitTestGeometry(Drawing drawing, PathGeometry geometry);
    internal static DrawingGroup DrawingGroupFromRenderData(RenderData renderData);
}
public class System.Windows.Media.DrawingVisual : ContainerVisual {
    public DrawingGroup Drawing { get; }
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    public DrawingContext RenderOpen();
    internal virtual void RenderClose(IDrawingContent newContent);
    internal virtual void FreeContent(Channel channel);
    internal virtual Rect GetContentBounds();
    internal void WalkContent(DrawingContextWalker walker);
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual DrawingGroup GetDrawing();
    public DrawingGroup get_Drawing();
}
public enum System.Windows.Media.EdgeMode : Enum {
    public int value__;
    public static EdgeMode Unspecified;
    public static EdgeMode Aliased;
}
public class System.Windows.Media.Effects.BevelBitmapEffect : BitmapEffect {
    public static DependencyProperty BevelWidthProperty;
    public static DependencyProperty ReliefProperty;
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty SmoothnessProperty;
    public static DependencyProperty EdgeProfileProperty;
    internal static double c_BevelWidth;
    internal static double c_Relief;
    internal static double c_LightAngle;
    internal static double c_Smoothness;
    internal static EdgeProfile c_EdgeProfile;
    public double BevelWidth { get; public set; }
    public double Relief { get; public set; }
    public double LightAngle { get; public set; }
    public double Smoothness { get; public set; }
    public EdgeProfile EdgeProfile { get; public set; }
    private static BevelBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecuritySafeCriticalAttribute]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityTreatAsSafeAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public BevelBitmapEffect Clone();
    public BevelBitmapEffect CloneCurrentValue();
    public double get_BevelWidth();
    public void set_BevelWidth(double value);
    public double get_Relief();
    public void set_Relief(double value);
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Smoothness();
    public void set_Smoothness(double value);
    public EdgeProfile get_EdgeProfile();
    public void set_EdgeProfile(EdgeProfile value);
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Effects.BitmapEffect : Animatable {
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
protected abstract virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected static void SetValue(SafeHandle effect, string propertyName, object value);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityTreatAsSafeAttribute]
protected static SafeHandle CreateBitmapEffectOuter();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityTreatAsSafeAttribute]
protected static void InitializeBitmapEffect(SafeHandle outerObject, SafeHandle innerObject);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapSource GetOutput(BitmapEffectInput input);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public BitmapEffect Clone();
    public BitmapEffect CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Effects.BitmapEffectCollection : Animatable {
    internal FrugalStructList`1<BitmapEffect> _collection;
    internal UInt32 _version;
    public BitmapEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static BitmapEffectCollection Empty { get; }
    public BitmapEffectCollection(int capacity);
    public BitmapEffectCollection(IEnumerable`1<BitmapEffect> collection);
    public BitmapEffectCollection Clone();
    public BitmapEffectCollection CloneCurrentValue();
    public sealed virtual void Add(BitmapEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(BitmapEffect value);
    public sealed virtual int IndexOf(BitmapEffect value);
    public sealed virtual void Insert(int index, BitmapEffect value);
    public sealed virtual bool Remove(BitmapEffect value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual BitmapEffect get_Item(int index);
    public sealed virtual void set_Item(int index, BitmapEffect value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(BitmapEffect[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<BitmapEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.Effects.BitmapEffect>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static BitmapEffectCollection get_Empty();
    internal BitmapEffect Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(BitmapEffect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Effects.BitmapEffectGroup : BitmapEffect {
    public static DependencyProperty ChildrenProperty;
    internal static BitmapEffectCollection s_Children;
    public BitmapEffectCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static BitmapEffectGroup();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecuritySafeCriticalAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    public BitmapEffectGroup Clone();
    public BitmapEffectGroup CloneCurrentValue();
    public BitmapEffectCollection get_Children();
    public void set_Children(BitmapEffectCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Effects.BitmapEffectInput : Animatable {
    public static DependencyProperty InputProperty;
    public static DependencyProperty AreaToApplyEffectUnitsProperty;
    public static DependencyProperty AreaToApplyEffectProperty;
    internal static BitmapSource s_Input;
    internal static BrushMappingMode c_AreaToApplyEffectUnits;
    internal static Rect s_AreaToApplyEffect;
    public static BitmapSource ContextInputSource { get; }
    public BitmapSource Input { get; public set; }
    public BrushMappingMode AreaToApplyEffectUnits { get; public set; }
    public Rect AreaToApplyEffect { get; public set; }
    public BitmapEffectInput(BitmapSource input);
    private static BitmapEffectInput();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInput();
    public static BitmapSource get_ContextInputSource();
    public BitmapEffectInput Clone();
    public BitmapEffectInput CloneCurrentValue();
    public BitmapSource get_Input();
    public void set_Input(BitmapSource value);
    public BrushMappingMode get_AreaToApplyEffectUnits();
    public void set_AreaToApplyEffectUnits(BrushMappingMode value);
    public Rect get_AreaToApplyEffect();
    public void set_AreaToApplyEffect(Rect value);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Effects.BitmapEffectInputData : ValueType {
    public BitmapEffect BitmapEffect;
    public BitmapEffectInput BitmapEffectInput;
    public BitmapEffectInputData(BitmapEffect bitmapEffect, BitmapEffectInput bitmapEffectInput);
}
internal class System.Windows.Media.Effects.BitmapEffectState : object {
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
}
public class System.Windows.Media.Effects.BlurBitmapEffect : BitmapEffect {
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    internal static double c_Radius;
    internal static KernelType c_KernelType;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    private static BlurBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecuritySafeCriticalAttribute]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityTreatAsSafeAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public BlurBitmapEffect Clone();
    public BlurBitmapEffect CloneCurrentValue();
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.BlurEffect : Effect {
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    public static DependencyProperty RenderingBiasProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Radius;
    internal static KernelType c_KernelType;
    internal static RenderingBias c_RenderingBias;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    private static BlurEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    public BlurEffect Clone();
    public BlurEffect CloneCurrentValue();
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Effects.DropShadowBitmapEffect : BitmapEffect {
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty SoftnessProperty;
    internal static double c_ShadowDepth;
    internal static Color s_Color;
    internal static double c_Direction;
    internal static double c_Noise;
    internal static double c_Opacity;
    internal static double c_Softness;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public double Softness { get; public set; }
    private static DropShadowBitmapEffect();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public DropShadowBitmapEffect Clone();
    public DropShadowBitmapEffect CloneCurrentValue();
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_Softness();
    public void set_Softness(double value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.DropShadowEffect : Effect {
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty BlurRadiusProperty;
    public static DependencyProperty RenderingBiasProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_ShadowDepth;
    internal static Color s_Color;
    internal static double c_Direction;
    internal static double c_Opacity;
    internal static double c_BlurRadius;
    internal static RenderingBias c_RenderingBias;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Opacity { get; public set; }
    public double BlurRadius { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    private static DropShadowEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    public DropShadowEffect Clone();
    public DropShadowEffect CloneCurrentValue();
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_BlurRadius();
    public void set_BlurRadius(double value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.EdgeProfile : Enum {
    public int value__;
    public static EdgeProfile Linear;
    public static EdgeProfile CurvedIn;
    public static EdgeProfile CurvedOut;
    public static EdgeProfile BulgedUp;
}
public abstract class System.Windows.Media.Effects.Effect : Animatable {
    [BrowsableAttribute("False")]
public static Brush ImplicitInput { get; private set; }
    protected internal GeneralTransform EffectMapping { get; }
    private static Effect();
    [CompilerGeneratedAttribute]
public static Brush get_ImplicitInput();
    [CompilerGeneratedAttribute]
private static void set_ImplicitInput(Brush value);
    internal abstract virtual Rect GetRenderBounds(Rect contentBounds);
    protected internal virtual GeneralTransform get_EffectMapping();
    internal GeneralTransform CoerceToUnitSpaceGeneralTransform(GeneralTransform gt, Rect worldBounds);
    internal static Nullable`1<Point> UnitToWorld(Point unitPoint, Rect worldBounds);
    internal static Nullable`1<Point> WorldToUnit(Point worldPoint, Rect worldBounds);
    internal static Rect UnitToWorld(Rect unitRect, Rect worldBounds);
    internal static Nullable`1<Rect> WorldToUnit(Rect worldRect, Rect worldBounds);
    public Effect Clone();
    public Effect CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.Effects.EmbossBitmapEffect : BitmapEffect {
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty ReliefProperty;
    internal static double c_LightAngle;
    internal static double c_Relief;
    public double LightAngle { get; public set; }
    public double Relief { get; public set; }
    private static EmbossBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecuritySafeCriticalAttribute]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public EmbossBitmapEffect Clone();
    public EmbossBitmapEffect CloneCurrentValue();
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Relief();
    public void set_Relief(double value);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Effects.ImplicitInputBrush : Brush {
    internal MultiChannelResource _duceResource;
    public ImplicitInputBrush Clone();
    public ImplicitInputBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.KernelType : Enum {
    public int value__;
    public static KernelType Gaussian;
    public static KernelType Box;
}
public class System.Windows.Media.Effects.OuterGlowBitmapEffect : BitmapEffect {
    public static DependencyProperty GlowColorProperty;
    public static DependencyProperty GlowSizeProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    internal static Color s_GlowColor;
    internal static double c_GlowSize;
    internal static double c_Noise;
    internal static double c_Opacity;
    public Color GlowColor { get; public set; }
    public double GlowSize { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    private static OuterGlowBitmapEffect();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public OuterGlowBitmapEffect Clone();
    public OuterGlowBitmapEffect CloneCurrentValue();
    public Color get_GlowColor();
    public void set_GlowColor(Color value);
    public double get_GlowSize();
    public void set_GlowSize(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.PixelShader : Animatable {
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty ShaderRenderModeProperty;
    internal MultiChannelResource _duceResource;
    internal static Uri s_UriSource;
    internal static ShaderRenderMode c_ShaderRenderMode;
    internal short ShaderMajorVersion { get; private set; }
    internal short ShaderMinorVersion { get; private set; }
    public Uri UriSource { get; public set; }
    public ShaderRenderMode ShaderRenderMode { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PixelShader();
    public void SetStreamSource(Stream source);
    [CompilerGeneratedAttribute]
internal short get_ShaderMajorVersion();
    [CompilerGeneratedAttribute]
private void set_ShaderMajorVersion(short value);
    [CompilerGeneratedAttribute]
internal short get_ShaderMinorVersion();
    [CompilerGeneratedAttribute]
private void set_ShaderMinorVersion(short value);
    public static void add_InvalidPixelShaderEncountered(EventHandler value);
    public static void remove_InvalidPixelShaderEncountered(EventHandler value);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [CompilerGeneratedAttribute]
internal void add__shaderBytecodeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove__shaderBytecodeChanged(EventHandler value);
    public PixelShader Clone();
    public PixelShader CloneCurrentValue();
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public ShaderRenderMode get_ShaderRenderMode();
    public void set_ShaderRenderMode(ShaderRenderMode value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.Effects.RenderingBias : Enum {
    public int value__;
    public static RenderingBias Performance;
    public static RenderingBias Quality;
}
public enum System.Windows.Media.Effects.SamplingMode : Enum {
    public int value__;
    public static SamplingMode NearestNeighbor;
    public static SamplingMode Bilinear;
    public static SamplingMode Auto;
}
public abstract class System.Windows.Media.Effects.ShaderEffect : Effect {
    protected static DependencyProperty PixelShaderProperty;
    internal MultiChannelResource _duceResource;
    protected double PaddingTop { get; protected set; }
    protected double PaddingBottom { get; protected set; }
    protected double PaddingLeft { get; protected set; }
    protected double PaddingRight { get; protected set; }
    protected int DdxUvDdyUvRegisterIndex { get; protected set; }
    protected PixelShader PixelShader { get; protected set; }
    private static ShaderEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    protected double get_PaddingTop();
    protected void set_PaddingTop(double value);
    protected double get_PaddingBottom();
    protected void set_PaddingBottom(double value);
    protected double get_PaddingLeft();
    protected void set_PaddingLeft(double value);
    protected double get_PaddingRight();
    protected void set_PaddingRight(double value);
    protected int get_DdxUvDdyUvRegisterIndex();
    protected void set_DdxUvDdyUvRegisterIndex(int value);
    protected void UpdateShaderValue(DependencyProperty dp);
    protected static PropertyChangedCallback PixelShaderConstantCallback(int floatRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex, SamplingMode samplingMode);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex, SamplingMode samplingMode);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal static Type DetermineShaderConstantType(Type type, PixelShader pixelShader);
    internal static void ConvertValueToMilColorF(object value, MilColorF& newVal);
    internal static void ConvertValueToMilColorI(object value, MilColorI& newVal);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public ShaderEffect Clone();
    public ShaderEffect CloneCurrentValue();
    protected PixelShader get_PixelShader();
    protected void set_PixelShader(PixelShader value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.ShaderRenderMode : Enum {
    public int value__;
    public static ShaderRenderMode Auto;
    public static ShaderRenderMode SoftwareOnly;
    public static ShaderRenderMode HardwareOnly;
}
internal static class System.Windows.Media.Effects.ValidateEnums : object {
    public static bool IsShaderRenderModeValid(object valueObject);
    public static bool IsKernelTypeValid(object valueObject);
    public static bool IsEdgeProfileValid(object valueObject);
    public static bool IsRenderingBiasValid(object valueObject);
}
public class System.Windows.Media.EllipseGeometry : Geometry {
    internal static double c_arcAsBezier;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty CenterProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Point s_Center;
    public Rect Bounds { get; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point Center { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public EllipseGeometry(Rect rect);
    public EllipseGeometry(Point center, double radiusX, double radiusY);
    public EllipseGeometry(Point center, double radiusX, double radiusY, Transform transform);
    private static EllipseGeometry();
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Point center, double radiusX, double radiusY, Matrix geometryMatrix, double tolerance, ToleranceType type);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathGeometryData GetPathGeometryData();
    public EllipseGeometry Clone();
    public EllipseGeometry CloneCurrentValue();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_Center();
    public void set_Center(Point value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Media.EventProxyDescriptor : ValueType {
    internal Dispose pfnDispose;
    internal RaiseEvent pfnRaiseEvent;
    internal GCHandle m_handle;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void StaticDispose(EventProxyDescriptor& pEPD);
}
internal static class System.Windows.Media.EventProxyStaticPtrs : object {
    internal static Dispose pfnDispose;
    internal static RaiseEvent pfnRaiseEvent;
    private static EventProxyStaticPtrs();
}
internal class System.Windows.Media.EventProxyWrapper : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public int RaiseEvent(Byte[] buffer, UInt32 cb);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static EventProxyWrapper FromEPD(EventProxyDescriptor& epd);
    internal static int RaiseEvent(EventProxyDescriptor& pEPD, Byte[] buffer, UInt32 cb);
    [SecurityCriticalAttribute]
internal static SafeMILHandle CreateEventProxyWrapper(IInvokable invokable);
}
public class System.Windows.Media.ExceptionEventArgs : EventArgs {
    public Exception ErrorException { get; }
    internal ExceptionEventArgs(Exception errorException);
    public Exception get_ErrorException();
}
internal class System.Windows.Media.FactoryMaker : object {
    internal IntPtr FactoryPtr { get; }
    internal IntPtr ImagingFactoryPtr { get; }
    private static FactoryMaker();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void Dispose(bool fDisposing);
    [SecurityCriticalAttribute]
internal IntPtr get_FactoryPtr();
    [SecurityCriticalAttribute]
internal IntPtr get_ImagingFactoryPtr();
}
public class System.Windows.Media.FamilyTypeface : object {
    public FontStyle Style { get; public set; }
    public FontWeight Weight { get; public set; }
    public FontStretch Stretch { get; public set; }
    public double UnderlinePosition { get; public set; }
    public double UnderlineThickness { get; public set; }
    public double StrikethroughPosition { get; public set; }
    public double StrikethroughThickness { get; public set; }
    public double CapsHeight { get; public set; }
    public double XHeight { get; public set; }
    private bool MS.Internal.FontFace.ITypefaceMetrics.Symbol { get; }
    private StyleSimulations MS.Internal.FontFace.ITypefaceMetrics.StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public string DeviceFontName { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public CharacterMetricsDictionary DeviceFontCharacterMetrics { get; }
    private string MS.Internal.FontFace.IDeviceFont.Name { get; }
    internal FamilyTypeface(Typeface face);
    public FontStyle get_Style();
    public void set_Style(FontStyle value);
    public FontWeight get_Weight();
    public void set_Weight(FontWeight value);
    public FontStretch get_Stretch();
    public void set_Stretch(FontStretch value);
    public sealed virtual double get_UnderlinePosition();
    public void set_UnderlinePosition(double value);
    public sealed virtual double get_UnderlineThickness();
    public void set_UnderlineThickness(double value);
    public sealed virtual double get_StrikethroughPosition();
    public void set_StrikethroughPosition(double value);
    public sealed virtual double get_StrikethroughThickness();
    public void set_StrikethroughThickness(double value);
    public sealed virtual double get_CapsHeight();
    public void set_CapsHeight(double value);
    public sealed virtual double get_XHeight();
    public void set_XHeight(double value);
    private sealed virtual override bool MS.Internal.FontFace.ITypefaceMetrics.get_Symbol();
    private sealed virtual override StyleSimulations MS.Internal.FontFace.ITypefaceMetrics.get_StyleSimulations();
    public sealed virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
    public bool Equals(FamilyTypeface typeface);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public CharacterMetricsDictionary get_DeviceFontCharacterMetrics();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private sealed virtual override string MS.Internal.FontFace.IDeviceFont.get_Name();
    private sealed virtual override bool MS.Internal.FontFace.IDeviceFont.ContainsCharacter(int unicodeScalar);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.FontFace.IDeviceFont.GetAdvanceWidths(Char* characterString, int characterLength, double emSize, Int32* pAdvances);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FamilyTypefaceCollection : object {
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FamilyTypeface Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal FamilyTypefaceCollection(ICollection`1<Typeface> innerList);
    public sealed virtual IEnumerator`1<FamilyTypeface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FamilyTypeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FamilyTypeface item);
    public sealed virtual void CopyTo(FamilyTypeface[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Remove(FamilyTypeface item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(FamilyTypeface item);
    public sealed virtual void Insert(int index, FamilyTypeface item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual FamilyTypeface get_Item(int index);
    public sealed virtual void set_Item(int index, FamilyTypeface value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public enum System.Windows.Media.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule Nonzero;
}
public class System.Windows.Media.FontEmbeddingManager : object {
    [CLSCompliantAttribute("False")]
public ICollection`1<Uri> GlyphTypefaceUris { get; }
    private static FontEmbeddingManager();
    public void RecordUsage(GlyphRun glyphRun);
    public ICollection`1<Uri> get_GlyphTypefaceUris();
    [CLSCompliantAttribute("False")]
public ICollection`1<ushort> GetUsedGlyphs(Uri glyphTypeface);
}
public enum System.Windows.Media.FontEmbeddingRight : Enum {
    public int value__;
    public static FontEmbeddingRight Installable;
    public static FontEmbeddingRight InstallableButNoSubsetting;
    public static FontEmbeddingRight InstallableButWithBitmapsOnly;
    public static FontEmbeddingRight InstallableButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight RestrictedLicense;
    public static FontEmbeddingRight PreviewAndPrint;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsetting;
    public static FontEmbeddingRight PreviewAndPrintButWithBitmapsOnly;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight Editable;
    public static FontEmbeddingRight EditableButNoSubsetting;
    public static FontEmbeddingRight EditableButWithBitmapsOnly;
    public static FontEmbeddingRight EditableButNoSubsettingAndWithBitmapsOnly;
}
[TypeConverterAttribute("System.Windows.Media.FontFamilyConverter")]
[ValueSerializerAttribute("System.Windows.Media.FontFamilyValueSerializer")]
[LocalizabilityAttribute("14")]
public class System.Windows.Media.FontFamily : object {
    internal static CanonicalFontFamilyReference NullFontFamilyCanonicalName;
    internal static string GlobalUI;
    internal static FontFamily FontFamilyGlobalUI;
    [DesignerSerializationVisibilityAttribute("2")]
public LanguageSpecificStringDictionary FamilyNames { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FamilyTypefaceCollection FamilyTypefaces { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FontFamilyMapCollection FamilyMaps { get; }
    public string Source { get; }
    public Uri BaseUri { get; }
    internal FontFamilyIdentifier FamilyIdentifier { get; }
    public double Baseline { get; public set; }
    public double LineSpacing { get; public set; }
    internal IFontFamily FirstFontFamily { get; }
    public FontFamily(string familyName);
    public FontFamily(Uri baseUri, string familyName);
    internal FontFamily(FontFamilyIdentifier familyIdentifier);
    private static FontFamily();
    public LanguageSpecificStringDictionary get_FamilyNames();
    public FamilyTypefaceCollection get_FamilyTypefaces();
    public FontFamilyMapCollection get_FamilyMaps();
    public string get_Source();
    public Uri get_BaseUri();
    public virtual string ToString();
    internal FontFamilyIdentifier get_FamilyIdentifier();
    public double get_Baseline();
    public void set_Baseline(double value);
    public double get_LineSpacing();
    public void set_LineSpacing(double value);
    internal double GetLineSpacingForDisplayMode(double emSize, double pixelsPerDip);
    [CLSCompliantAttribute("False")]
public ICollection`1<Typeface> GetTypefaces();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal IFontFamily get_FirstFontFamily();
    internal static IFontFamily FindFontFamilyFromFriendlyNameList(string friendlyNameList);
    internal static IFontFamily SafeLookupFontFamily(CanonicalFontFamilyReference canonicalName, Boolean& nullFont);
    internal static IFontFamily LookupFontFamily(CanonicalFontFamilyReference canonicalName);
    internal IFontFamily FindFirstFontFamilyAndFace(FontStyle& style, FontWeight& weight, FontStretch& stretch);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static IFontFamily LookupFontFamilyAndFace(CanonicalFontFamilyReference canonicalFamilyReference, FontStyle& style, FontWeight& weight, FontStretch& stretch);
}
public class System.Windows.Media.FontFamilyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object o);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.FontFamilyMap : object {
    internal static int LastUnicodeScalar;
    internal static FontFamilyMap Default;
    [DesignerSerializationOptionsAttribute("1")]
public string Unicode { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string Target { get; public set; }
    public double Scale { get; public set; }
    public XmlLanguage Language { get; public set; }
    internal bool IsSimpleFamilyMap { get; }
    internal Range[] Ranges { get; }
    internal FontFamilyMap(int firstChar, int lastChar, XmlLanguage language, string targetFamilyName, double scaleInEm);
    private static FontFamilyMap();
    public void set_Unicode(string value);
    public string get_Unicode();
    public string get_Target();
    public void set_Target(string value);
    public double get_Scale();
    public void set_Scale(double value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    internal bool get_IsSimpleFamilyMap();
    internal static bool MatchLanguage(XmlLanguage familyMapLanguage, XmlLanguage language);
    internal static bool MatchCulture(XmlLanguage familyMapLanguage, CultureInfo culture);
    internal Range[] get_Ranges();
    internal static bool ParseHexNumber(string numString, Int32& index, Int32& number);
    internal bool InRange(int ch);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FontFamilyMapCollection : object {
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FontFamilyMap Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal FontFamilyMapCollection(CompositeFontInfo fontInfo);
    public sealed virtual IEnumerator`1<FontFamilyMap> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FontFamilyMap item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FontFamilyMap item);
    public sealed virtual void CopyTo(FontFamilyMap[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Remove(FontFamilyMap item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(FontFamilyMap item);
    public sealed virtual void Insert(int index, FontFamilyMap item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual FontFamilyMap get_Item(int index);
    public sealed virtual void set_Item(int index, FontFamilyMap value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
public class System.Windows.Media.FontFamilyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public static class System.Windows.Media.Fonts : object {
    public static ICollection`1<FontFamily> SystemFontFamilies { get; }
    public static ICollection`1<Typeface> SystemTypefaces { get; }
    private static Fonts();
    public static ICollection`1<FontFamily> GetFontFamilies(string location);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri, string location);
    public static ICollection`1<Typeface> GetTypefaces(string location);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri, string location);
    public static ICollection`1<FontFamily> get_SystemFontFamilies();
    public static ICollection`1<Typeface> get_SystemTypefaces();
}
public class System.Windows.Media.FormattedText : object {
    public string Text { get; }
    public double PixelsPerDip { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public double LineHeight { get; public set; }
    public double MaxTextWidth { get; public set; }
    public double MaxTextHeight { get; public set; }
    public int MaxLineCount { get; public set; }
    public TextTrimming Trimming { get; public set; }
    public double Height { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double MinWidth { get; }
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode, double pixelsPerDip);
    public string get_Text();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    public void SetForegroundBrush(Brush foregroundBrush);
    public void SetForegroundBrush(Brush foregroundBrush, int startIndex, int count);
    public void SetFontFamily(string fontFamily);
    public void SetFontFamily(string fontFamily, int startIndex, int count);
    public void SetFontFamily(FontFamily fontFamily);
    public void SetFontFamily(FontFamily fontFamily, int startIndex, int count);
    public void SetFontSize(double emSize);
    public void SetFontSize(double emSize, int startIndex, int count);
    public void SetCulture(CultureInfo culture);
    public void SetCulture(CultureInfo culture, int startIndex, int count);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution, int startIndex, int count);
    public void SetFontWeight(FontWeight weight);
    public void SetFontWeight(FontWeight weight, int startIndex, int count);
    public void SetFontStyle(FontStyle style);
    public void SetFontStyle(FontStyle style, int startIndex, int count);
    public void SetFontStretch(FontStretch stretch);
    public void SetFontStretch(FontStretch stretch, int startIndex, int count);
    public void SetFontTypeface(Typeface typeface);
    public void SetFontTypeface(Typeface typeface, int startIndex, int count);
    public void SetTextDecorations(TextDecorationCollection textDecorations);
    public void SetTextDecorations(TextDecorationCollection textDecorations, int startIndex, int count);
    public void set_FlowDirection(FlowDirection value);
    public FlowDirection get_FlowDirection();
    public void set_TextAlignment(TextAlignment value);
    public TextAlignment get_TextAlignment();
    public void set_LineHeight(double value);
    public double get_LineHeight();
    public void set_MaxTextWidth(double value);
    public double get_MaxTextWidth();
    public void SetMaxTextWidths(Double[] maxTextWidths);
    public Double[] GetMaxTextWidths();
    public void set_MaxTextHeight(double value);
    public double get_MaxTextHeight();
    public void set_MaxLineCount(int value);
    public int get_MaxLineCount();
    public void set_Trimming(TextTrimming value);
    public TextTrimming get_Trimming();
    public double get_Height();
    public double get_Extent();
    public double get_Baseline();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    public double get_MinWidth();
    public Geometry BuildHighlightGeometry(Point origin);
    public Geometry BuildGeometry(Point origin);
    public Geometry BuildHighlightGeometry(Point origin, int startIndex, int count);
    internal void Draw(DrawingContext dc, Point origin);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.GeneralTransform : Animatable {
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    public abstract virtual bool TryTransform(Point inPoint, Point& result);
    public Point Transform(Point point);
    public abstract virtual Rect TransformBounds(Rect rect);
    public abstract virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    public GeneralTransform Clone();
    public GeneralTransform CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeneralTransformCollection : Animatable {
    internal FrugalStructList`1<GeneralTransform> _collection;
    internal UInt32 _version;
    public GeneralTransform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeneralTransformCollection Empty { get; }
    public GeneralTransformCollection(int capacity);
    public GeneralTransformCollection(IEnumerable`1<GeneralTransform> collection);
    public GeneralTransformCollection Clone();
    public GeneralTransformCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform value);
    public sealed virtual int IndexOf(GeneralTransform value);
    public sealed virtual void Insert(int index, GeneralTransform value);
    public sealed virtual bool Remove(GeneralTransform value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GeneralTransform get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GeneralTransform[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform> System.Collections.Generic.IEnumerable<System.Windows.Media.GeneralTransform>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeneralTransformCollection get_Empty();
    internal GeneralTransform Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(GeneralTransform value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GeneralTransformGroup : GeneralTransform {
    public static DependencyProperty ChildrenProperty;
    internal static GeneralTransformCollection s_Children;
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    public GeneralTransformCollection Children { get; public set; }
    private static GeneralTransformGroup();
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    public GeneralTransformGroup Clone();
    public GeneralTransformGroup CloneCurrentValue();
    public GeneralTransformCollection get_Children();
    public void set_Children(GeneralTransformCollection value);
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.GeometryValueSerializer")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Geometry : Animatable {
    public static DependencyProperty TransformProperty;
    internal static Transform s_Transform;
    public Transform Transform { get; public set; }
    public static Geometry Empty { get; }
    public Rect Bounds { get; }
    public static double StandardFlatteningTolerance { get; }
    private static Geometry();
    public Geometry Clone();
    public Geometry CloneCurrentValue();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public static Geometry Parse(string source);
    public static Geometry get_Empty();
    public virtual Rect get_Bounds();
    public static double get_StandardFlatteningTolerance();
    public virtual Rect GetRenderBounds(Pen pen, double tolerance, ToleranceType type);
    public Rect GetRenderBounds(Pen pen);
    internal virtual bool AreClose(Geometry geometry);
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    internal Rect GetBoundsInternal(Pen pen, Matrix matrix);
    [SecurityCriticalAttribute]
internal static Rect GetBoundsHelper(Pen pen, Matrix* pWorldMatrix, Point* pPoints, Byte* pTypes, UInt32 pointCount, UInt32 segmentCount, Matrix* pGeometryMatrix, double tolerance, ToleranceType type, bool fSkipHollows);
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal Geometry GetTransformedCopy(Transform transform);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransform();
    [SecurityCriticalAttribute]
public virtual double GetArea(double tolerance, ToleranceType type);
    public double GetArea();
    public abstract virtual bool IsEmpty();
    public abstract virtual bool MayHaveCurves();
    public bool FillContains(Point hitPoint, double tolerance, ToleranceType type);
    public bool FillContains(Point hitPoint);
    public bool StrokeContains(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    [SecurityCriticalAttribute]
internal bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type, Point* pPoints, UInt32 pointCount, Byte* pTypes, UInt32 typeCount);
    public bool StrokeContains(Pen pen, Point hitPoint);
    public bool FillContains(Geometry geometry, double tolerance, ToleranceType type);
    public bool FillContains(Geometry geometry);
    public virtual IntersectionDetail FillContainsWithDetail(Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail FillContainsWithDetail(Geometry geometry);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry);
    [SecurityCriticalAttribute]
public virtual PathGeometry GetFlattenedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetFlattenedPathGeometry();
    [SecurityCriticalAttribute]
public virtual PathGeometry GetWidenedPathGeometry(Pen pen, double tolerance, ToleranceType type);
    public PathGeometry GetWidenedPathGeometry(Pen pen);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform);
    [SecurityCriticalAttribute]
public virtual PathGeometry GetOutlinedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetOutlinedPathGeometry();
    internal abstract virtual PathGeometry GetAsPathGeometry();
    internal abstract virtual PathGeometryData GetPathGeometryData();
    internal PathFigureCollection GetPathFigureCollection();
    internal Matrix GetCombinedMatrix(Transform transform);
    internal abstract virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual bool IsObviouslyEmpty();
    internal virtual bool CanSerializeToString();
    internal static PathGeometryData GetEmptyPathGeometryData();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeometryCollection : Animatable {
    internal FrugalStructList`1<Geometry> _collection;
    internal UInt32 _version;
    public Geometry Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeometryCollection Empty { get; }
    public GeometryCollection(int capacity);
    public GeometryCollection(IEnumerable`1<Geometry> collection);
    public GeometryCollection Clone();
    public GeometryCollection CloneCurrentValue();
    public sealed virtual void Add(Geometry value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Geometry value);
    public sealed virtual int IndexOf(Geometry value);
    public sealed virtual void Insert(int index, Geometry value);
    public sealed virtual bool Remove(Geometry value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Geometry get_Item(int index);
    public sealed virtual void set_Item(int index, Geometry value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Geometry[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Geometry> System.Collections.Generic.IEnumerable<System.Windows.Media.Geometry>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeometryCollection get_Empty();
    internal Geometry Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Geometry value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public enum System.Windows.Media.GeometryCombineMode : Enum {
    public int value__;
    public static GeometryCombineMode Union;
    public static GeometryCombineMode Intersect;
    public static GeometryCombineMode Xor;
    public static GeometryCombineMode Exclude;
}
public class System.Windows.Media.GeometryConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.GeometryDrawing : Drawing {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty PenProperty;
    public static DependencyProperty GeometryProperty;
    internal MultiChannelResource _duceResource;
    public Brush Brush { get; public set; }
    public Pen Pen { get; public set; }
    public Geometry Geometry { get; public set; }
    private static GeometryDrawing();
    public GeometryDrawing(Brush brush, Pen pen, Geometry geometry);
    public GeometryDrawing Clone();
    public GeometryDrawing CloneCurrentValue();
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public Geometry get_Geometry();
    public void set_Geometry(Geometry value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeometryGroup : Geometry {
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static FillRule c_FillRule;
    internal static GeometryCollection s_Children;
    public FillRule FillRule { get; public set; }
    public GeometryCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static GeometryGroup();
    public GeometryGroup Clone();
    public GeometryGroup CloneCurrentValue();
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public GeometryCollection get_Children();
    public void set_Children(GeometryCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    public virtual bool IsEmpty();
    internal virtual bool IsObviouslyEmpty();
    public virtual bool MayHaveCurves();
}
public class System.Windows.Media.GeometryHitTestParameters : HitTestParameters {
    public Geometry HitGeometry { get; }
    internal PathGeometry InternalHitGeometry { get; }
    internal Rect Bounds { get; }
    public GeometryHitTestParameters(Geometry geometry);
    public Geometry get_HitGeometry();
    internal PathGeometry get_InternalHitGeometry();
    internal Rect get_Bounds();
    internal void PushMatrix(Matrix& newMatrix);
    internal void PopMatrix();
    internal void EmergencyRestoreOriginalTransform();
}
public class System.Windows.Media.GeometryHitTestResult : HitTestResult {
    public IntersectionDetail IntersectionDetail { get; }
    public Visual VisualHit { get; }
    public GeometryHitTestResult(Visual visualHit, IntersectionDetail intersectionDetail);
    public IntersectionDetail get_IntersectionDetail();
    public Visual get_VisualHit();
}
public class System.Windows.Media.GlyphRun : object {
    internal static double RelativeFlatteningTolerance;
    internal static int MaxGlyphCount;
    internal static int MaxStackAlloc;
    public float PixelsPerDip { get; public set; }
    public Point BaselineOrigin { get; public set; }
    public double FontRenderingEmSize { get; public set; }
    public GlyphTypeface GlyphTypeface { get; public set; }
    public int BidiLevel { get; public set; }
    public bool IsSideways { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.BoolIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<bool> CaretStops { get; public set; }
    public bool IsHitTestable { get; }
    [TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<ushort> ClusterMap { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.CharIListConverter")]
public IList`1<char> Characters { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
public IList`1<ushort> GlyphIndices { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.DoubleIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<double> AdvanceWidths { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.PointIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<Point> GlyphOffsets { get; public set; }
    public XmlLanguage Language { get; public set; }
    public string DeviceFontName { get; public set; }
    internal int GlyphCount { get; }
    internal int CodepointCount { get; }
    public GlyphRun(float pixelsPerDip);
    [CLSCompliantAttribute("False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
[CLSCompliantAttribute("False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    private static GlyphRun();
    internal static GlyphRun TryCreate(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language, TextFormattingMode textLayout);
    public double GetDistanceFromCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetCaretCharacterHitFromDistance(double distance, Boolean& isInside);
    public CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public float get_PixelsPerDip();
    public void set_PixelsPerDip(float value);
    public Point get_BaselineOrigin();
    public void set_BaselineOrigin(Point value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public GlyphTypeface get_GlyphTypeface();
    public void set_GlyphTypeface(GlyphTypeface value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public IList`1<bool> get_CaretStops();
    public void set_CaretStops(IList`1<bool> value);
    public bool get_IsHitTestable();
    public IList`1<ushort> get_ClusterMap();
    public void set_ClusterMap(IList`1<ushort> value);
    public IList`1<char> get_Characters();
    public void set_Characters(IList`1<char> value);
    public IList`1<ushort> get_GlyphIndices();
    public void set_GlyphIndices(IList`1<ushort> value);
    public IList`1<double> get_AdvanceWidths();
    public void set_AdvanceWidths(IList`1<double> value);
    public IList`1<Point> get_GlyphOffsets();
    public void set_GlyphOffsets(IList`1<Point> value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    internal Point GetGlyphOffset(int i);
    internal int get_GlyphCount();
    internal int get_CodepointCount();
    public Rect ComputeInkBoundingBox();
    public Geometry BuildGeometry();
    public Rect ComputeAlignmentBox();
    internal void EmitBackground(DrawingContext dc, Brush backgroundBrush);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
public class System.Windows.Media.GlyphRunDrawing : Drawing {
    public static DependencyProperty GlyphRunProperty;
    public static DependencyProperty ForegroundBrushProperty;
    internal MultiChannelResource _duceResource;
    public GlyphRun GlyphRun { get; public set; }
    public Brush ForegroundBrush { get; public set; }
    private static GlyphRunDrawing();
    public GlyphRunDrawing(Brush foregroundBrush, GlyphRun glyphRun);
    public GlyphRunDrawing Clone();
    public GlyphRunDrawing CloneCurrentValue();
    public GlyphRun get_GlyphRun();
    public void set_GlyphRun(GlyphRun value);
    public Brush get_ForegroundBrush();
    public void set_ForegroundBrush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.GlyphsSerializer : object {
    public GlyphsSerializer(GlyphRun glyphRun);
    public void ComputeContentStrings(String& characters, String& indices, String& caretStops);
}
public class System.Windows.Media.GlyphTypeface : object {
    [FriendAccessAllowedAttribute]
internal CodeAccessPermission CriticalFileReadPermission { get; }
    [FriendAccessAllowedAttribute]
internal CodeAccessPermission CriticalUriDiscoveryPermission { get; }
    public Uri FontUri { get; public set; }
    public IDictionary`2<CultureInfo, string> FamilyNames { get; }
    public IDictionary`2<CultureInfo, string> FaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FamilyNames { get; }
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.ITypefaceMetrics.AdjustedFaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FaceNames { get; }
    public IDictionary`2<CultureInfo, string> VersionStrings { get; }
    public IDictionary`2<CultureInfo, string> Copyrights { get; }
    public IDictionary`2<CultureInfo, string> ManufacturerNames { get; }
    public IDictionary`2<CultureInfo, string> Trademarks { get; }
    public IDictionary`2<CultureInfo, string> DesignerNames { get; }
    public IDictionary`2<CultureInfo, string> Descriptions { get; }
    public IDictionary`2<CultureInfo, string> VendorUrls { get; }
    public IDictionary`2<CultureInfo, string> DesignerUrls { get; }
    public IDictionary`2<CultureInfo, string> LicenseDescriptions { get; }
    public IDictionary`2<CultureInfo, string> SampleTexts { get; }
    public FontStyle Style { get; }
    public FontWeight Weight { get; }
    public FontStretch Stretch { get; }
    public double Version { get; }
    public double Height { get; }
    public double Baseline { get; }
    public double CapsHeight { get; }
    public double XHeight { get; }
    public bool Symbol { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public FontEmbeddingRight EmbeddingRights { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.CapsHeight { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.XHeight { get; }
    private bool MS.Internal.FontFace.ITypefaceMetrics.Symbol { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.UnderlinePosition { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.UnderlineThickness { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.StrikethroughPosition { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.StrikethroughThickness { get; }
    public IDictionary`2<ushort, double> AdvanceWidths { get; }
    public IDictionary`2<ushort, double> AdvanceHeights { get; }
    public IDictionary`2<ushort, double> LeftSideBearings { get; }
    public IDictionary`2<ushort, double> RightSideBearings { get; }
    public IDictionary`2<ushort, double> TopSideBearings { get; }
    public IDictionary`2<ushort, double> BottomSideBearings { get; }
    public IDictionary`2<ushort, double> DistancesFromHorizontalBaselineToBlackBoxBottom { get; }
    public IDictionary`2<int, ushort> CharacterToGlyphMap { get; }
    public StyleSimulations StyleSimulations { get; public set; }
    public int GlyphCount { get; }
    internal Font FontDWrite { get; }
    internal FontSource FontSource { get; }
    internal int FaceIndex { get; }
    internal FontFaceLayoutInfo FontFaceLayoutInfo { get; }
    internal ushort BlankGlyphIndex { get; }
    internal FontTechnology FontTechnology { get; }
    internal ushort DesignEmHeight { get; }
    internal IntPtr GetDWriteFontAddRef { get; }
    public GlyphTypeface(Uri typefaceSource);
    public GlyphTypeface(Uri typefaceSource, StyleSimulations styleSimulations);
    [SecurityCriticalAttribute]
internal GlyphTypeface(Font font);
    [SecurityCriticalAttribute]
public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public virtual bool Equals(object o);
    [CLSCompliantAttribute("False")]
public Geometry GetGlyphOutline(ushort glyphIndex, double renderingEmSize, double hintingEmSize);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public Byte[] ComputeSubset(ICollection`1<ushort> glyphs);
    [SecurityCriticalAttribute]
public Stream GetFontStream();
    [SecurityCriticalAttribute]
internal CodeAccessPermission get_CriticalFileReadPermission();
    [SecurityCriticalAttribute]
internal CodeAccessPermission get_CriticalUriDiscoveryPermission();
    [SecurityCriticalAttribute]
public Uri get_FontUri();
    [SecurityCriticalAttribute]
public void set_FontUri(Uri value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public IDictionary`2<CultureInfo, string> get_FamilyNames();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_FaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FamilyNames();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.ITypefaceMetrics.get_AdjustedFaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FaceNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_VersionStrings();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Copyrights();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_ManufacturerNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Trademarks();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_DesignerNames();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_Descriptions();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_VendorUrls();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_DesignerUrls();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_LicenseDescriptions();
    [SecurityCriticalAttribute]
public IDictionary`2<CultureInfo, string> get_SampleTexts();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public FontStyle get_Style();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public FontWeight get_Weight();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public FontStretch get_Stretch();
    [SecurityCriticalAttribute]
public double get_Version();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_Height();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_Baseline();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_CapsHeight();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_XHeight();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public bool get_Symbol();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_UnderlinePosition();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_UnderlineThickness();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public double get_StrikethroughPosition();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public double get_StrikethroughThickness();
    [SecurityCriticalAttribute]
public FontEmbeddingRight get_EmbeddingRights();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_CapsHeight();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_XHeight();
    private sealed virtual override bool MS.Internal.FontFace.ITypefaceMetrics.get_Symbol();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_UnderlinePosition();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_UnderlineThickness();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_StrikethroughPosition();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_StrikethroughThickness();
    public IDictionary`2<ushort, double> get_AdvanceWidths();
    public IDictionary`2<ushort, double> get_AdvanceHeights();
    public IDictionary`2<ushort, double> get_LeftSideBearings();
    public IDictionary`2<ushort, double> get_RightSideBearings();
    public IDictionary`2<ushort, double> get_TopSideBearings();
    public IDictionary`2<ushort, double> get_BottomSideBearings();
    public IDictionary`2<ushort, double> get_DistancesFromHorizontalBaselineToBlackBoxBottom();
    [SecurityCriticalAttribute]
public IDictionary`2<int, ushort> get_CharacterToGlyphMap();
    public sealed virtual StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public int get_GlyphCount();
    [SecuritySafeCriticalAttribute]
internal bool HasCharacter(UInt32 unicodeValue);
    [SecurityCriticalAttribute]
internal Font get_FontDWrite();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal double GetAdvanceWidth(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    [SecuritySafeCriticalAttribute]
internal void DemandPermissionsForFontInformation();
    internal static double BaselineHelper(GlyphMetrics metrics);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void GetGlyphMetrics(ushort glyph, double renderingEmSize, double scalingFactor, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, Double& aw, Double& ah, Double& lsb, Double& rsb, Double& tsb, Double& bsb, Double& baseline);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void GetGlyphMetrics(UInt16[] glyphs, int glyphsLength, double renderingEmSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, GlyphMetrics[] glyphMetrics);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal Geometry ComputeGlyphOutline(ushort glyphIndex, bool sideways, double renderingEmSize);
    [SecurityCriticalAttribute]
internal void GetAdvanceWidthsUnshaped(Char* unsafeCharString, int stringLength, double emSize, float pixelsPerDip, double scalingFactor, Int32* advanceWidthsUnshaped, bool nullFont, TextFormattingMode textFormattingMode, bool isSideways);
    internal GlyphRun ComputeUnshapedGlyphRun(Point origin, CharacterBufferRange charBufferRange, IList`1<double> charWidths, double emSize, float pixelsPerDip, double emHintingSize, bool nullGlyph, CultureInfo cultureInfo, string deviceFontName, TextFormattingMode textFormattingMode);
    internal void GetGlyphIndicesOptimized(CharacterBufferRange characters, UInt16[] glyphIndices, float pixelsPerDip);
    internal void GetGlyphMetricsOptimized(CharacterBufferRange characters, double emSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, GlyphMetrics[] glyphMetrics);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void GetGlyphMetricsOptimized(CharacterBufferRange characters, double emSize, float pixelsPerDip, UInt16[] glyphIndices, GlyphMetrics[] glyphMetrics, TextFormattingMode textFormattingMode, bool isSideways);
    internal FontSource get_FontSource();
    [SecurityCriticalAttribute]
internal int get_FaceIndex();
    internal FontFaceLayoutInfo get_FontFaceLayoutInfo();
    internal ushort get_BlankGlyphIndex();
    internal FontTechnology get_FontTechnology();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal ushort get_DesignEmHeight();
    [SecurityCriticalAttribute]
internal IntPtr get_GetDWriteFontAddRef();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[ContentPropertyAttribute("GradientStops")]
public abstract class System.Windows.Media.GradientBrush : Brush {
    public static DependencyProperty ColorInterpolationModeProperty;
    public static DependencyProperty MappingModeProperty;
    public static DependencyProperty SpreadMethodProperty;
    public static DependencyProperty GradientStopsProperty;
    internal static ColorInterpolationMode c_ColorInterpolationMode;
    internal static BrushMappingMode c_MappingMode;
    internal static GradientSpreadMethod c_SpreadMethod;
    internal static GradientStopCollection s_GradientStops;
    public ColorInterpolationMode ColorInterpolationMode { get; public set; }
    public BrushMappingMode MappingMode { get; public set; }
    public GradientSpreadMethod SpreadMethod { get; public set; }
    public GradientStopCollection GradientStops { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static GradientBrush();
    protected GradientBrush(GradientStopCollection gradientStopCollection);
    public GradientBrush Clone();
    public GradientBrush CloneCurrentValue();
    public ColorInterpolationMode get_ColorInterpolationMode();
    public void set_ColorInterpolationMode(ColorInterpolationMode value);
    public BrushMappingMode get_MappingMode();
    public void set_MappingMode(BrushMappingMode value);
    public GradientSpreadMethod get_SpreadMethod();
    public void set_SpreadMethod(GradientSpreadMethod value);
    public GradientStopCollection get_GradientStops();
    public void set_GradientStops(GradientStopCollection value);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.GradientSpreadMethod : Enum {
    public int value__;
    public static GradientSpreadMethod Pad;
    public static GradientSpreadMethod Reflect;
    public static GradientSpreadMethod Repeat;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GradientStop : Animatable {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty OffsetProperty;
    internal static Color s_Color;
    internal static double c_Offset;
    public Color Color { get; public set; }
    public double Offset { get; public set; }
    public GradientStop(Color color, double offset);
    private static GradientStop();
    public GradientStop Clone();
    public GradientStop CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Offset();
    public void set_Offset(double value);
    protected virtual Freezable CreateInstanceCore();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GradientStopCollection : Animatable {
    internal FrugalStructList`1<GradientStop> _collection;
    internal UInt32 _version;
    public GradientStop Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GradientStopCollection Empty { get; }
    public GradientStopCollection(int capacity);
    public GradientStopCollection(IEnumerable`1<GradientStop> collection);
    public GradientStopCollection Clone();
    public GradientStopCollection CloneCurrentValue();
    public sealed virtual void Add(GradientStop value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GradientStop value);
    public sealed virtual int IndexOf(GradientStop value);
    public sealed virtual void Insert(int index, GradientStop value);
    public sealed virtual bool Remove(GradientStop value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GradientStop get_Item(int index);
    public sealed virtual void set_Item(int index, GradientStop value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GradientStop[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GradientStop> System.Collections.Generic.IEnumerable<System.Windows.Media.GradientStop>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GradientStopCollection get_Empty();
    internal GradientStop Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(GradientStop value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static GradientStopCollection Parse(string source);
}
public class System.Windows.Media.GuidelineSet : Animatable {
    public static DependencyProperty GuidelinesXProperty;
    public static DependencyProperty GuidelinesYProperty;
    internal static DependencyProperty IsDynamicProperty;
    internal MultiChannelResource _duceResource;
    internal static DoubleCollection s_GuidelinesX;
    internal static DoubleCollection s_GuidelinesY;
    internal static bool c_IsDynamic;
    public DoubleCollection GuidelinesX { get; public set; }
    public DoubleCollection GuidelinesY { get; public set; }
    internal bool IsDynamic { get; internal set; }
    private static GuidelineSet();
    internal GuidelineSet(Double[] guidelinesX, Double[] guidelinesY, bool isDynamic);
    public GuidelineSet(Double[] guidelinesX, Double[] guidelinesY);
    public GuidelineSet Clone();
    public GuidelineSet CloneCurrentValue();
    public DoubleCollection get_GuidelinesX();
    public void set_GuidelinesX(DoubleCollection value);
    public DoubleCollection get_GuidelinesY();
    public void set_GuidelinesY(DoubleCollection value);
    internal bool get_IsDynamic();
    internal void set_IsDynamic(bool value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
internal abstract class System.Windows.Media.HitTestDrawingContextWalker : DrawingContextWalker {
    protected bool _contains;
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    internal abstract virtual bool get_IsHit();
    internal abstract virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer video, Rect rectangle);
}
public enum System.Windows.Media.HitTestFilterBehavior : Enum {
    public int value__;
    public static HitTestFilterBehavior ContinueSkipChildren;
    public static HitTestFilterBehavior ContinueSkipSelfAndChildren;
    public static HitTestFilterBehavior ContinueSkipSelf;
    public static HitTestFilterBehavior Continue;
    public static HitTestFilterBehavior Stop;
}
public class System.Windows.Media.HitTestFilterCallback : MulticastDelegate {
    public HitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(DependencyObject potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(DependencyObject potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Media.HitTestParameters : object {
}
public abstract class System.Windows.Media.HitTestResult : object {
    public DependencyObject VisualHit { get; }
    internal HitTestResult(DependencyObject visualHit);
    public DependencyObject get_VisualHit();
}
public enum System.Windows.Media.HitTestResultBehavior : Enum {
    public int value__;
    public static HitTestResultBehavior Stop;
    public static HitTestResultBehavior Continue;
}
public class System.Windows.Media.HitTestResultCallback : MulticastDelegate {
    public HitTestResultCallback(object object, IntPtr method);
    public virtual HitTestResultBehavior Invoke(HitTestResult result);
    public virtual IAsyncResult BeginInvoke(HitTestResult result, AsyncCallback callback, object object);
    public virtual HitTestResultBehavior EndInvoke(IAsyncResult result);
}
internal class System.Windows.Media.HitTestWithGeometryDrawingContextWalker : HitTestDrawingContextWalker {
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    internal HitTestWithGeometryDrawingContextWalker(PathGeometry geometry);
    internal virtual bool get_IsHit();
    internal virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    public virtual void Pop();
}
internal class System.Windows.Media.HitTestWithPointDrawingContextWalker : HitTestDrawingContextWalker {
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    internal HitTestWithPointDrawingContextWalker(Point point);
    internal virtual bool get_IsHit();
    internal virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
}
public class System.Windows.Media.HostVisual : ContainerVisual {
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    internal virtual Rect GetContentBounds();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void FreeContent(Channel channel);
    internal void BeginHosting(VisualTarget target);
    internal void EndHosting();
    internal object DoHandleDuplication(object channel);
}
internal static class System.Windows.Media.HTFBInterpreter : object {
    internal static int c_DoHitTest;
    internal static int c_IncludeChidren;
    internal static int c_Stop;
    internal static bool DoHitTest(HitTestFilterBehavior behavior);
    internal static bool IncludeChildren(HitTestFilterBehavior behavior);
    internal static bool Stop(HitTestFilterBehavior behavior);
    internal static bool SkipSubgraph(HitTestFilterBehavior behavior);
}
internal interface System.Windows.Media.ICompositionTarget {
    public abstract virtual void Render(bool inResize, Channel channel);
    public abstract virtual void AddRefOnChannel(Channel channel, Channel outOfBandChannel);
    public abstract virtual void ReleaseOnChannel(Channel channel, Channel outOfBandChannel);
}
internal interface System.Windows.Media.ICyclicBrush {
    public abstract virtual void FireOnChanged();
    public abstract virtual void RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
}
internal interface System.Windows.Media.IDrawingContent {
    public abstract virtual Rect GetContentBounds(BoundsDrawingContextWalker ctx);
    public abstract virtual void WalkContent(DrawingContextWalker walker);
    public abstract virtual bool HitTestPoint(Point point);
    public abstract virtual IntersectionDetail HitTestGeometry(PathGeometry geometry);
    public abstract virtual void PropagateChangedHandler(EventHandler handler, bool adding);
}
internal interface System.Windows.Media.IFreezeFreezables {
    public bool FreezeFreezables { get; }
    public abstract virtual bool get_FreezeFreezables();
    public abstract virtual bool TryFreeze(string value, Freezable freezable);
    public abstract virtual Freezable TryGetFreezable(string value);
}
internal interface System.Windows.Media.IInvokable {
    public abstract virtual void RaiseEvent(Byte[] buffer, int cb);
}
public class System.Windows.Media.ImageBrush : TileBrush {
    public static DependencyProperty ImageSourceProperty;
    internal MultiChannelResource _duceResource;
    public ImageSource ImageSource { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static ImageBrush();
    public ImageBrush(ImageSource image);
    public ImageBrush Clone();
    public ImageBrush CloneCurrentValue();
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    protected virtual void GetContentBounds(Rect& contentBounds);
}
public class System.Windows.Media.ImageDrawing : Drawing {
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static Rect s_Rect;
    public ImageSource ImageSource { get; public set; }
    public Rect Rect { get; public set; }
    private static ImageDrawing();
    public ImageDrawing(ImageSource imageSource, Rect rect);
    public ImageDrawing Clone();
    public ImageDrawing CloneCurrentValue();
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
}
public abstract class System.Windows.Media.ImageMetadata : Freezable {
    public ImageMetadata Clone();
}
[TypeConverterAttribute("System.Windows.Media.ImageSourceConverter")]
[ValueSerializerAttribute("System.Windows.Media.ImageSourceValueSerializer")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.ImageSource : Animatable {
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    public ImageSource Clone();
    public ImageSource CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual ImageMetadata get_Metadata();
    internal virtual Size get_Size();
    internal virtual bool CanSerializeToString();
    protected static double PixelsToDIPs(double dpi, int pixels);
}
public class System.Windows.Media.ImageSourceConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.ImageSourceValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public enum System.Windows.Media.Imaging.BitmapCacheOption : Enum {
    public int value__;
    public static BitmapCacheOption Default;
    public static BitmapCacheOption OnDemand;
    public static BitmapCacheOption OnLoad;
    public static BitmapCacheOption None;
}
public abstract class System.Windows.Media.Imaging.BitmapCodecInfo : object {
    public Guid ContainerFormat { get; }
    public string Author { get; }
    public Version Version { get; }
    public Version SpecificationVersion { get; }
    public string FriendlyName { get; }
    public string DeviceManufacturer { get; }
    public string DeviceModels { get; }
    public string MimeTypes { get; }
    public string FileExtensions { get; }
    public bool SupportsAnimation { get; }
    public bool SupportsLossless { get; }
    public bool SupportsMultipleFrames { get; }
    internal BitmapCodecInfo(SafeMILHandle codecInfoHandle);
    [SecurityCriticalAttribute]
public virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
public virtual string get_Author();
    [SecurityCriticalAttribute]
public virtual Version get_Version();
    [SecurityCriticalAttribute]
public virtual Version get_SpecificationVersion();
    [SecurityCriticalAttribute]
public virtual string get_FriendlyName();
    [SecurityCriticalAttribute]
public virtual string get_DeviceManufacturer();
    [SecurityCriticalAttribute]
public virtual string get_DeviceModels();
    [SecurityCriticalAttribute]
public virtual string get_MimeTypes();
    [SecurityCriticalAttribute]
public virtual string get_FileExtensions();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsAnimation();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsLossless();
    [SecurityCriticalAttribute]
public virtual bool get_SupportsMultipleFrames();
}
internal class System.Windows.Media.Imaging.BitmapCodecInfoInternal : BitmapCodecInfo {
    internal BitmapCodecInfoInternal(SafeMILHandle codecInfoHandle);
}
[FlagsAttribute]
public enum System.Windows.Media.Imaging.BitmapCreateOptions : Enum {
    public int value__;
    public static BitmapCreateOptions None;
    public static BitmapCreateOptions PreservePixelFormat;
    public static BitmapCreateOptions DelayCreation;
    public static BitmapCreateOptions IgnoreColorProfile;
    public static BitmapCreateOptions IgnoreImageCache;
}
public abstract class System.Windows.Media.Imaging.BitmapDecoder : DispatcherObject {
    internal ReadOnlyCollection`1<ColorContext> _readOnlycolorContexts;
    internal List`1<BitmapFrame> _frames;
    internal ReadOnlyCollection`1<BitmapFrame> _readOnlyFrames;
    internal Stream _stream;
    internal Uri _uri;
    internal Uri _baseUri;
    [SecurityCriticalAttribute]
internal Stream _uriStream;
    internal BitmapCreateOptions _createOptions;
    internal BitmapCacheOption _cacheOption;
    internal UniqueEventHelper _downloadEvent;
    internal UniqueEventHelper`1<DownloadProgressEventArgs> _progressEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _failedEvent;
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapMetadata Metadata { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public bool IsDownloading { get; }
    internal SafeMILHandle InternalDecoder { get; }
    internal bool IsMetadataFixedSize { get; }
    internal object SyncObject { get; }
    internal ReadOnlyCollection`1<ColorContext> InternalColorContexts { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static BitmapDecoder();
    internal BitmapDecoder(bool isBuiltIn);
    [SecurityCriticalAttribute]
internal BitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, Guid expectedClsId);
    [SecurityCriticalAttribute]
internal BitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, Guid expectedClsId);
    [SecurityCriticalAttribute]
internal BitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool isOriginalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual override void Finalize();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static BitmapDecoder CreateFromUriOrStream(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy, bool insertInDecoderCache);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapDecoder Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public virtual BitmapPalette get_Palette();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Thumbnail();
    [SecurityCriticalAttribute]
public virtual BitmapMetadata get_Metadata();
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Preview();
    public virtual bool get_IsDownloading();
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    public virtual string ToString();
    internal SafeMILHandle get_InternalDecoder();
    internal virtual bool get_IsMetadataFixedSize();
    internal object get_SyncObject();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ColorContext> get_InternalColorContexts();
    internal void CheckOriginalWritable();
    [SecurityCriticalAttribute]
internal static SafeMILHandle SetupDecoderFromUriOrStream(Uri uri, Stream stream, BitmapCacheOption cacheOption, Guid& clsId, Boolean& isOriginalWritable, Stream& uriStream, UnmanagedMemoryStream& unmanagedMemoryStream, SafeFileHandle& safeFilehandle);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void CloseStream();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void SetupFrames(BitmapDecoder decoder, ReadOnlyCollection`1<BitmapFrame> frames);
    internal bool CanConvertToString();
    internal abstract virtual void SealObject();
}
internal static class System.Windows.Media.Imaging.BitmapDownload : object {
    internal static AutoResetEvent _waitEvent;
    [SecurityCriticalAttribute]
internal static Queue _workQueue;
    internal static Hashtable _uriTable;
    internal static AsyncCallback _readCallback;
    internal static AsyncCallback _responseCallback;
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static BitmapDownload();
    [SecurityCriticalAttribute]
internal static void BeginDownload(BitmapDecoder decoder, Uri uri, RequestCachePolicy uriCachePolicy, Stream stream);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void DownloadThreadProc();
}
public abstract class System.Windows.Media.Imaging.BitmapEncoder : DispatcherObject {
    internal bool _supportsPreview;
    internal bool _supportsGlobalThumbnail;
    internal bool _supportsGlobalMetadata;
    internal bool _supportsFrameThumbnails;
    internal bool _supportsFrameMetadata;
    internal bool _supportsMultipleFrames;
    internal bool _supportsColorContext;
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; public set; }
    public BitmapSource Thumbnail { get; public set; }
    public BitmapMetadata Metadata { get; public set; }
    public BitmapSource Preview { get; public set; }
    public BitmapCodecInfo CodecInfo { get; }
    public BitmapPalette Palette { get; public set; }
    public IList`1<BitmapFrame> Frames { get; public set; }
    internal Guid ContainerFormat { get; }
    internal bool IsMetadataFixedSize { get; }
    internal BitmapEncoder(bool isBuiltIn);
    [SecurityCriticalAttribute]
public static BitmapEncoder Create(Guid containerFormat);
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual void set_ColorContexts(ReadOnlyCollection`1<ColorContext> value);
    public virtual BitmapSource get_Thumbnail();
    public virtual void set_Thumbnail(BitmapSource value);
    public virtual BitmapMetadata get_Metadata();
    public virtual void set_Metadata(BitmapMetadata value);
    public virtual BitmapSource get_Preview();
    public virtual void set_Preview(BitmapSource value);
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual BitmapPalette get_Palette();
    public virtual void set_Palette(BitmapPalette value);
    public virtual IList`1<BitmapFrame> get_Frames();
    public virtual void set_Frames(IList`1<BitmapFrame> value);
    [SecurityCriticalAttribute]
public virtual void Save(Stream stream);
    internal virtual Guid get_ContainerFormat();
    internal virtual bool get_IsMetadataFixedSize();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal abstract virtual void SealObject();
}
public abstract class System.Windows.Media.Imaging.BitmapFrame : BitmapSource {
    internal BitmapSource _thumbnail;
    [SecurityCriticalAttribute]
internal BitmapMetadata _metadata;
    internal ReadOnlyCollection`1<ColorContext> _readOnlycolorContexts;
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    internal BitmapFrame(bool useVirtuals);
    internal static BitmapFrame CreateFromUriOrStream(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri);
    public static BitmapFrame Create(Uri bitmapUri, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Stream bitmapStream);
    public static BitmapFrame Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(BitmapSource source);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public abstract virtual Uri get_BaseUri();
    public abstract virtual void set_BaseUri(Uri value);
    public abstract virtual BitmapSource get_Thumbnail();
    public abstract virtual BitmapDecoder get_Decoder();
    public abstract virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public abstract virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    internal virtual BitmapMetadata get_InternalMetadata();
    internal virtual void set_InternalMetadata(BitmapMetadata value);
}
internal class System.Windows.Media.Imaging.BitmapFrameDecode : BitmapFrame {
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public ImageMetadata Metadata { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public bool IsDownloading { get; }
    internal bool ShouldCloneEventDelegates { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapDecoder decoder);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapFrameDecode frameDecode);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, LateBoundBitmapDecoder decoder);
    public virtual Uri get_BaseUri();
    public virtual void set_BaseUri(Uri value);
    public virtual BitmapSource get_Thumbnail();
    public virtual ImageMetadata get_Metadata();
    public virtual BitmapDecoder get_Decoder();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual bool get_IsDownloading();
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void UpdateDecoder(BitmapDecoder decoder);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual bool get_ShouldCloneEventDelegates();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual BitmapMetadata get_InternalMetadata();
    internal virtual void set_InternalMetadata(BitmapMetadata value);
}
internal class System.Windows.Media.Imaging.BitmapFrameEncode : BitmapFrame {
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public ImageMetadata Metadata { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal BitmapFrameEncode(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public virtual Uri get_BaseUri();
    public virtual void set_BaseUri(Uri value);
    public virtual BitmapSource get_Thumbnail();
    public virtual ImageMetadata get_Metadata();
    public virtual BitmapDecoder get_Decoder();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void FinalizeCreation();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual BitmapMetadata get_InternalMetadata();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void set_InternalMetadata(BitmapMetadata value);
}
public class System.Windows.Media.Imaging.BitmapImage : BitmapSource {
    public static DependencyProperty UriCachePolicyProperty;
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty StreamSourceProperty;
    public static DependencyProperty DecodePixelWidthProperty;
    public static DependencyProperty DecodePixelHeightProperty;
    public static DependencyProperty RotationProperty;
    public static DependencyProperty SourceRectProperty;
    public static DependencyProperty CreateOptionsProperty;
    public static DependencyProperty CacheOptionProperty;
    internal static RequestCachePolicy s_UriCachePolicy;
    internal static Uri s_UriSource;
    internal static Stream s_StreamSource;
    internal static int c_DecodePixelWidth;
    internal static int c_DecodePixelHeight;
    internal static Rotation c_Rotation;
    internal static Int32Rect s_SourceRect;
    internal static BitmapCreateOptions s_CreateOptions;
    internal static BitmapCacheOption s_CacheOption;
    public Uri BaseUri { get; public set; }
    public bool IsDownloading { get; }
    public ImageMetadata Metadata { get; }
    [TypeConverterAttribute("System.Windows.Media.RequestCachePolicyConverter")]
public RequestCachePolicy UriCachePolicy { get; public set; }
    public Uri UriSource { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public Stream StreamSource { get; public set; }
    public int DecodePixelWidth { get; public set; }
    public int DecodePixelHeight { get; public set; }
    public Rotation Rotation { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public BitmapCreateOptions CreateOptions { get; public set; }
    public BitmapCacheOption CacheOption { get; public set; }
    public BitmapImage(Uri uriSource);
    public BitmapImage(Uri uriSource, RequestCachePolicy uriCachePolicy);
    private static BitmapImage();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    public virtual bool get_IsDownloading();
    public virtual ImageMetadata get_Metadata();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    public BitmapImage Clone();
    public BitmapImage CloneCurrentValue();
    public RequestCachePolicy get_UriCachePolicy();
    public void set_UriCachePolicy(RequestCachePolicy value);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public Stream get_StreamSource();
    public void set_StreamSource(Stream value);
    public int get_DecodePixelWidth();
    public void set_DecodePixelWidth(int value);
    public int get_DecodePixelHeight();
    public void set_DecodePixelHeight(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public BitmapCreateOptions get_CreateOptions();
    public void set_CreateOptions(BitmapCreateOptions value);
    public BitmapCacheOption get_CacheOption();
    public void set_CacheOption(BitmapCacheOption value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
internal class System.Windows.Media.Imaging.BitmapInitialize : object {
    public bool IsInInit { get; }
    public bool IsInitAtLeastOnce { get; }
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public void SetPrologue();
    public bool get_IsInInit();
    public bool get_IsInitAtLeastOnce();
    public void EnsureInitializedComplete();
    public void Reset();
}
public class System.Windows.Media.Imaging.BitmapMetadata : ImageMetadata {
    public string Format { get; }
    public string Location { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public ReadOnlyCollection`1<string> Author { get; public set; }
    public string Title { get; public set; }
    public int Rating { get; public set; }
    public string Subject { get; public set; }
    public string Comment { get; public set; }
    public string DateTaken { get; public set; }
    public string ApplicationName { get; public set; }
    public string Copyright { get; public set; }
    public string CameraManufacturer { get; public set; }
    public string CameraModel { get; public set; }
    public ReadOnlyCollection`1<string> Keywords { get; public set; }
    internal Guid GuidFormat { get; }
    internal SafeMILHandle InternalMetadataHandle { get; }
    internal object SyncObject { get; }
    internal BitmapMetadataBlockWriter BlockWriter { get; }
    [SecurityCriticalAttribute]
public BitmapMetadata(string containerFormat);
    [SecurityCriticalAttribute]
internal BitmapMetadata(SafeMILHandle metadataHandle, bool readOnly, bool fixedSize, object syncObject);
    internal BitmapMetadata(BitmapMetadata bitmapMetadata);
    public BitmapMetadata Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
public string get_Format();
    [SecurityCriticalAttribute]
public string get_Location();
    public bool get_IsReadOnly();
    public bool get_IsFixedSize();
    [SecurityCriticalAttribute]
public void SetQuery(string query, object value);
    [SecurityCriticalAttribute]
public object GetQuery(string query);
    [SecurityCriticalAttribute]
public void RemoveQuery(string query);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    [SecurityCriticalAttribute]
public bool ContainsQuery(string query);
    public ReadOnlyCollection`1<string> get_Author();
    public void set_Author(ReadOnlyCollection`1<string> value);
    public string get_Title();
    public void set_Title(string value);
    public int get_Rating();
    public void set_Rating(int value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_DateTaken();
    public void set_DateTaken(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_CameraManufacturer();
    public void set_CameraManufacturer(string value);
    public string get_CameraModel();
    public void set_CameraModel(string value);
    public ReadOnlyCollection`1<string> get_Keywords();
    public void set_Keywords(ReadOnlyCollection`1<string> value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Guid get_GuidFormat();
    [SecurityCriticalAttribute]
internal SafeMILHandle get_InternalMetadataHandle();
    internal object get_SyncObject();
    internal BitmapMetadataBlockWriter get_BlockWriter();
}
public class System.Windows.Media.Imaging.BitmapMetadataBlob : object {
    public BitmapMetadataBlob(Byte[] blob);
    public Byte[] GetBlobValue();
    internal Byte[] InternalGetBlobValue();
}
internal class System.Windows.Media.Imaging.BitmapMetadataEnumerator : ValueType {
    [SecurityCriticalAttribute]
private SafeMILHandle _enumeratorHandle;
    private string _current;
    private bool _fStarted;
    private object System.Collections.IEnumerator.Current { get; }
    public string Current { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal BitmapMetadataEnumerator(SafeMILHandle metadataHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public sealed virtual bool MoveNext();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Reset();
    public sealed virtual string get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Windows.Media.Imaging.BitmapPalette : DispatcherObject {
    public IList`1<Color> Colors { get; }
    internal SafeMILHandle InternalPalette { get; }
    public BitmapPalette(IList`1<Color> colors);
    [SecurityCriticalAttribute]
public BitmapPalette(BitmapSource bitmapSource, int maxColorCount);
    [SecuritySafeCriticalAttribute]
internal BitmapPalette(WICPaletteType paletteType, bool addtransparentColor);
    internal BitmapPalette(SafeMILHandle unmanagedPalette);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static BitmapPalette CreateFromBitmapSource(BitmapSource source);
    public IList`1<Color> get_Colors();
    [SecurityCriticalAttribute]
internal SafeMILHandle get_InternalPalette();
    internal static bool DoesPaletteHaveAlpha(BitmapPalette palette);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static SafeMILHandle CreateInternalPalette();
}
public static class System.Windows.Media.Imaging.BitmapPalettes : object {
    public static BitmapPalette BlackAndWhite { get; }
    public static BitmapPalette BlackAndWhiteTransparent { get; }
    public static BitmapPalette Halftone8 { get; }
    public static BitmapPalette Halftone8Transparent { get; }
    public static BitmapPalette Halftone27 { get; }
    public static BitmapPalette Halftone27Transparent { get; }
    public static BitmapPalette Halftone64 { get; }
    public static BitmapPalette Halftone64Transparent { get; }
    public static BitmapPalette Halftone125 { get; }
    public static BitmapPalette Halftone125Transparent { get; }
    public static BitmapPalette Halftone216 { get; }
    public static BitmapPalette Halftone216Transparent { get; }
    public static BitmapPalette Halftone252 { get; }
    public static BitmapPalette Halftone252Transparent { get; }
    public static BitmapPalette Halftone256 { get; }
    public static BitmapPalette Halftone256Transparent { get; }
    public static BitmapPalette Gray4 { get; }
    public static BitmapPalette Gray4Transparent { get; }
    public static BitmapPalette Gray16 { get; }
    public static BitmapPalette Gray16Transparent { get; }
    public static BitmapPalette Gray256 { get; }
    public static BitmapPalette Gray256Transparent { get; }
    public static BitmapPalette WebPalette { get; }
    public static BitmapPalette WebPaletteTransparent { get; }
    public static BitmapPalette get_BlackAndWhite();
    public static BitmapPalette get_BlackAndWhiteTransparent();
    public static BitmapPalette get_Halftone8();
    public static BitmapPalette get_Halftone8Transparent();
    public static BitmapPalette get_Halftone27();
    public static BitmapPalette get_Halftone27Transparent();
    public static BitmapPalette get_Halftone64();
    public static BitmapPalette get_Halftone64Transparent();
    public static BitmapPalette get_Halftone125();
    public static BitmapPalette get_Halftone125Transparent();
    public static BitmapPalette get_Halftone216();
    public static BitmapPalette get_Halftone216Transparent();
    public static BitmapPalette get_Halftone252();
    public static BitmapPalette get_Halftone252Transparent();
    public static BitmapPalette get_Halftone256();
    public static BitmapPalette get_Halftone256Transparent();
    public static BitmapPalette get_Gray4();
    public static BitmapPalette get_Gray4Transparent();
    public static BitmapPalette get_Gray16();
    public static BitmapPalette get_Gray16Transparent();
    public static BitmapPalette get_Gray256();
    public static BitmapPalette get_Gray256Transparent();
    public static BitmapPalette get_WebPalette();
    public static BitmapPalette get_WebPaletteTransparent();
    internal static BitmapPalette FromMILPaletteType(WICPaletteType type, bool hasAlpha);
}
public class System.Windows.Media.Imaging.BitmapSizeOptions : object {
    public bool PreservesAspectRatio { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public Rotation Rotation { get; }
    internal bool DoesScale { get; }
    internal WICBitmapTransformOptions WICTransformOptions { get; }
    public bool get_PreservesAspectRatio();
    public int get_PixelWidth();
    public int get_PixelHeight();
    public Rotation get_Rotation();
    public static BitmapSizeOptions FromEmptyOptions();
    public static BitmapSizeOptions FromHeight(int pixelHeight);
    public static BitmapSizeOptions FromWidth(int pixelWidth);
    public static BitmapSizeOptions FromWidthAndHeight(int pixelWidth, int pixelHeight);
    public static BitmapSizeOptions FromRotation(Rotation rotation);
    internal void GetScaledWidthAndHeight(UInt32 width, UInt32 height, UInt32& newWidth, UInt32& newHeight);
    internal bool get_DoesScale();
    internal WICBitmapTransformOptions get_WICTransformOptions();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Imaging.BitmapSource : ImageSource {
    internal BitmapInitialize _bitmapInit;
    [SecurityCriticalAttribute]
internal BitmapSourceSafeMILHandle _wicSource;
    [SecurityCriticalAttribute]
internal BitmapSourceSafeMILHandle _convertedDUCEPtr;
    internal object _syncObject;
    internal bool _isSourceCached;
    internal bool _needsUpdate;
    internal bool _isColorCorrected;
    internal UniqueEventHelper _downloadEvent;
    internal UniqueEventHelper`1<DownloadProgressEventArgs> _progressEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _failedEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _decodeFailedEvent;
    internal PixelFormat _format;
    internal int _pixelWidth;
    internal int _pixelHeight;
    internal double _dpiX;
    internal double _dpiY;
    internal BitmapPalette _palette;
    internal MultiChannelResource _duceResource;
    public PixelFormat Format { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double DpiX { get; }
    public double DpiY { get; }
    public BitmapPalette Palette { get; }
    public bool IsDownloading { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    internal bool DelayCreation { get; internal set; }
    internal bool CreationCompleted { get; internal set; }
    internal object SyncObject { get; }
    internal bool IsSourceCached { get; internal set; }
    internal BitmapSourceSafeMILHandle WicSourceHandle { get; internal set; }
    internal BitmapSourceSafeMILHandle DUCECompatiblePtr { get; }
    internal bool ShouldCloneEventDelegates { get; }
    internal bool UsableWithoutCache { get; }
    internal bool HasCompatibleFormat { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal BitmapSource(bool useVirtuals);
    private static BitmapSource();
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    [SecurityCriticalAttribute]
public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    public BitmapSource Clone();
    public BitmapSource CloneCurrentValue();
    public virtual PixelFormat get_Format();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual double get_DpiX();
    public virtual double get_DpiY();
    public virtual BitmapPalette get_Palette();
    public virtual bool get_IsDownloading();
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void add_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Array pixels, int stride, int offset);
    [SecurityCriticalAttribute]
public virtual void CopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    internal virtual Size get_Size();
    internal bool get_DelayCreation();
    internal void set_DelayCreation(bool value);
    internal bool get_CreationCompleted();
    internal void set_CreationCompleted(bool value);
    internal void CompleteDelayedCreation();
    internal virtual void FinalizeCreation();
    internal object get_SyncObject();
    internal bool get_IsSourceCached();
    internal void set_IsSourceCached(bool value);
    [SecurityCriticalAttribute]
internal BitmapSourceSafeMILHandle get_WicSourceHandle();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_WicSourceHandle(BitmapSourceSafeMILHandle value);
    [SecurityCriticalAttribute]
internal virtual void UpdateCachedSettings();
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal void CriticalCopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    [SecurityCriticalAttribute]
internal void CriticalCopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected void CheckIfSiteOfOrigin();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    [SecurityCriticalAttribute]
internal virtual BitmapSourceSafeMILHandle get_DUCECompatiblePtr();
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateBitmapSourceResource(Channel channel, bool skipOnChannelCheck);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void RecoverFromDecodeFailure(Exception e);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal static PixelFormat GetClosestDUCEFormat(PixelFormat format, BitmapPalette palette);
    [SecurityCriticalAttribute]
internal static BitmapSourceSafeMILHandle CreateCachedBitmap(BitmapFrame frame, BitmapSourceSafeMILHandle wicSource, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapPalette palette);
    internal void RegisterDownloadEventSource(BitmapSource eventSource);
    internal void UnregisterDownloadEventSource();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    internal virtual bool get_ShouldCloneEventDelegates();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal bool get_UsableWithoutCache();
    internal bool get_HasCompatibleFormat();
    internal static bool IsCompatibleFormat(PixelFormat format);
}
internal class System.Windows.Media.Imaging.BitmapSourceSafeMILHandle : SafeMILHandle {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static BitmapSourceSafeMILHandle();
    [SecurityCriticalAttribute]
internal BitmapSourceSafeMILHandle(IntPtr handle);
    [SecurityCriticalAttribute]
internal BitmapSourceSafeMILHandle(IntPtr handle, SafeMILHandle copyMemoryPressureFrom);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CalculateSize();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.Imaging.BitmapVisualManager : DispatcherObject {
    public BitmapVisualManager(RenderTargetBitmap bitmapTarget);
    public void Render(Visual visual);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Render(Visual visual, Matrix worldTransform, Rect windowClip);
}
public class System.Windows.Media.Imaging.BmpBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public BmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public BmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal BmpBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.BmpBitmapEncoder : BitmapEncoder {
    internal Guid ContainerFormat { get; }
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.CachedBitmap : BitmapSource {
    public CachedBitmap(BitmapSource source, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal CachedBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    [SecurityCriticalAttribute]
internal CachedBitmap(BitmapSourceSafeMILHandle bitmap);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal CachedBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    public CachedBitmap Clone();
    public CachedBitmap CloneCurrentValue();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.ColorConvertedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceColorContextProperty;
    public static DependencyProperty DestinationColorContextProperty;
    public static DependencyProperty DestinationFormatProperty;
    internal static BitmapSource s_Source;
    internal static ColorContext s_SourceColorContext;
    internal static ColorContext s_DestinationColorContext;
    internal static PixelFormat s_DestinationFormat;
    public BitmapSource Source { get; public set; }
    public ColorContext SourceColorContext { get; public set; }
    public ColorContext DestinationColorContext { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public ColorConvertedBitmap(BitmapSource source, ColorContext sourceColorContext, ColorContext destinationColorContext, PixelFormat format);
    private static ColorConvertedBitmap();
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    public ColorConvertedBitmap Clone();
    public ColorConvertedBitmap CloneCurrentValue();
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public ColorContext get_SourceColorContext();
    public void set_SourceColorContext(ColorContext value);
    public ColorContext get_DestinationColorContext();
    public void set_DestinationColorContext(ColorContext value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.CroppedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceRectProperty;
    internal static BitmapSource s_Source;
    internal static Int32Rect s_SourceRect;
    public BitmapSource Source { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public CroppedBitmap(BitmapSource source, Int32Rect sourceRect);
    private static CroppedBitmap();
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    public CroppedBitmap Clone();
    public CroppedBitmap CloneCurrentValue();
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.DownloadProgressEventArgs : EventArgs {
    public int Progress { get; }
    internal DownloadProgressEventArgs(int percentComplete);
    public int get_Progress();
}
public class System.Windows.Media.Imaging.FormatConvertedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty DestinationFormatProperty;
    public static DependencyProperty DestinationPaletteProperty;
    public static DependencyProperty AlphaThresholdProperty;
    internal static BitmapSource s_Source;
    internal static PixelFormat s_DestinationFormat;
    internal static BitmapPalette s_DestinationPalette;
    internal static double c_AlphaThreshold;
    public BitmapSource Source { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public BitmapPalette DestinationPalette { get; public set; }
    public double AlphaThreshold { get; public set; }
    public FormatConvertedBitmap(BitmapSource source, PixelFormat destinationFormat, BitmapPalette destinationPalette, double alphaThreshold);
    private static FormatConvertedBitmap();
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    public FormatConvertedBitmap Clone();
    public FormatConvertedBitmap CloneCurrentValue();
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public BitmapPalette get_DestinationPalette();
    public void set_DestinationPalette(BitmapPalette value);
    public double get_AlphaThreshold();
    public void set_AlphaThreshold(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.GifBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public GifBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public GifBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal GifBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.GifBitmapEncoder : BitmapEncoder {
    internal Guid ContainerFormat { get; }
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.IconBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public IconBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public IconBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal IconBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
internal static class System.Windows.Media.Imaging.ImagingCache : object {
    private static ImagingCache();
    internal static void AddToImageCache(Uri uri, object obj);
    internal static void RemoveFromImageCache(Uri uri);
    internal static object CheckImageCache(Uri uri);
    internal static void AddToDecoderCache(Uri uri, object obj);
    internal static void RemoveFromDecoderCache(Uri uri);
    internal static object CheckDecoderCache(Uri uri);
}
public class System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter : BitmapMetadata {
    [SecurityCriticalAttribute]
internal InPlaceBitmapMetadataWriter(SafeMILHandle fmeHandle, SafeMILHandle metadataHandle, object syncObject);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static InPlaceBitmapMetadataWriter CreateFromFrameDecode(BitmapSourceSafeMILHandle frameHandle, object syncObject);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static InPlaceBitmapMetadataWriter CreateFromDecoder(SafeMILHandle decoderHandle, object syncObject);
    [SecurityCriticalAttribute]
public bool TrySave();
    public InPlaceBitmapMetadataWriter Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.JpegBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public JpegBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public JpegBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal JpegBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.JpegBitmapEncoder : BitmapEncoder {
    public int QualityLevel { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    internal Guid ContainerFormat { get; }
    public int get_QualityLevel();
    public void set_QualityLevel(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.LateBoundBitmapDecoder : BitmapDecoder {
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public BitmapDecoder Decoder { get; }
    public bool IsDownloading { get; }
    [SecurityCriticalAttribute]
internal LateBoundBitmapDecoder(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy requestCachePolicy);
    [SecurityCriticalAttribute]
public virtual BitmapPalette get_Palette();
    [SecurityCriticalAttribute]
public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Thumbnail();
    [SecurityCriticalAttribute]
public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    [SecurityCriticalAttribute]
public virtual BitmapSource get_Preview();
    public BitmapDecoder get_Decoder();
    public virtual bool get_IsDownloading();
    internal object DownloadCallback(object arg);
    internal object ProgressCallback(object arg);
    internal object ExceptionCallback(object arg);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.PngBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public PngBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public PngBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal PngBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.PngBitmapEncoder : BitmapEncoder {
    public PngInterlaceOption Interlace { get; public set; }
    internal Guid ContainerFormat { get; }
    public PngInterlaceOption get_Interlace();
    public void set_Interlace(PngInterlaceOption value);
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public enum System.Windows.Media.Imaging.PngInterlaceOption : Enum {
    public int value__;
    public static PngInterlaceOption Default;
    public static PngInterlaceOption On;
    public static PngInterlaceOption Off;
}
internal class System.Windows.Media.Imaging.PROPARRAY : ValueType {
    internal UInt32 cElems;
    internal IntPtr pElems;
}
internal class System.Windows.Media.Imaging.PROPBAG2 : ValueType {
    internal UInt32 dwType;
    internal ushort vt;
    internal ushort cfType;
    internal IntPtr dwHint;
    [SecurityCriticalAttribute]
internal IntPtr pstrName;
    internal Guid clsid;
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Init(string name);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Clear();
}
internal class System.Windows.Media.Imaging.PROPVARIANT : ValueType {
    internal ushort varType;
    internal ushort wReserved1;
    internal ushort wReserved2;
    internal ushort wReserved3;
    internal byte bVal;
    internal sbyte cVal;
    internal ushort uiVal;
    internal short iVal;
    internal UInt32 uintVal;
    internal int intVal;
    internal ulong ulVal;
    internal long lVal;
    internal float fltVal;
    internal double dblVal;
    internal short boolVal;
    internal IntPtr pclsidVal;
    internal IntPtr pszVal;
    internal IntPtr pwszVal;
    internal IntPtr punkVal;
    internal PROPARRAY ca;
    internal FILETIME filetime;
    internal bool RequiresSyncObject { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void InitVector(Array array, Type type, VarEnum varEnum);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Init(Array array, Type type, VarEnum vt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Init(String[] value, bool fAscii);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Init(object value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal object ToObject(object syncObject);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_RequiresSyncObject();
}
internal class System.Windows.Media.Imaging.QueueEntry : object {
    internal List`1<WeakReference> decoders;
    internal Uri inputUri;
    internal Stream inputStream;
    internal Stream outputStream;
    internal string streamPath;
    internal Byte[] readBuffer;
    internal long contentLength;
    internal string contentType;
    internal int lastPercent;
    internal WebRequest webRequest;
}
public class System.Windows.Media.Imaging.RenderTargetBitmap : BitmapSource {
    internal SafeMILHandle MILRenderTarget { get; }
    [SecurityCriticalAttribute]
public RenderTargetBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Render(Visual visual);
    [SecurityCriticalAttribute]
public void Clear();
    [SecurityCriticalAttribute]
internal SafeMILHandle get_MILRenderTarget();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void RenderTargetContentsChanged();
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
}
public enum System.Windows.Media.Imaging.Rotation : Enum {
    public int value__;
    public static Rotation Rotate0;
    public static Rotation Rotate90;
    public static Rotation Rotate180;
    public static Rotation Rotate270;
}
public class System.Windows.Media.Imaging.TiffBitmapDecoder : BitmapDecoder {
    internal bool IsMetadataFixedSize { get; }
    [SecurityCriticalAttribute]
public TiffBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public TiffBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal TiffBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual bool get_IsMetadataFixedSize();
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.TiffBitmapEncoder : BitmapEncoder {
    public TiffCompressOption Compression { get; public set; }
    internal Guid ContainerFormat { get; }
    internal bool IsMetadataFixedSize { get; }
    public TiffCompressOption get_Compression();
    public void set_Compression(TiffCompressOption value);
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    internal virtual bool get_IsMetadataFixedSize();
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public enum System.Windows.Media.Imaging.TiffCompressOption : Enum {
    public int value__;
    public static TiffCompressOption Default;
    public static TiffCompressOption None;
    public static TiffCompressOption Ccitt3;
    public static TiffCompressOption Ccitt4;
    public static TiffCompressOption Lzw;
    public static TiffCompressOption Rle;
    public static TiffCompressOption Zip;
}
public class System.Windows.Media.Imaging.TransformedBitmap : BitmapSource {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty TransformProperty;
    internal static BitmapSource s_Source;
    internal static Transform s_Transform;
    public BitmapSource Source { get; public set; }
    public Transform Transform { get; public set; }
    public TransformedBitmap(BitmapSource source, Transform newTransform);
    private static TransformedBitmap();
    public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
public sealed virtual void EndInit();
    internal bool CheckTransform(Transform newTransform);
    internal void GetParamsFromTransform(Transform newTransform, Double& scaleX, Double& scaleY, WICBitmapTransformOptions& options);
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    public TransformedBitmap Clone();
    public TransformedBitmap CloneCurrentValue();
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
internal class System.Windows.Media.Imaging.UnknownBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
internal UnknownBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
internal class System.Windows.Media.Imaging.UnknownBitmapEncoder : BitmapEncoder {
    internal Guid ContainerFormat { get; }
    [SecurityCriticalAttribute]
public UnknownBitmapEncoder(Guid containerFormat);
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
internal class System.Windows.Media.Imaging.UnmanagedBitmapWrapper : BitmapSource {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public UnmanagedBitmapWrapper(BitmapSourceSafeMILHandle bitmapSource);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal UnmanagedBitmapWrapper(bool initialize);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
internal static class System.Windows.Media.Imaging.ValidateEnums : object {
    public static bool IsRotationValid(object valueObject);
}
public class System.Windows.Media.Imaging.WmpBitmapDecoder : BitmapDecoder {
    [SecurityCriticalAttribute]
public WmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
public WmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    [SecurityCriticalAttribute]
internal WmpBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.WmpBitmapEncoder : BitmapEncoder {
    public float ImageQualityLevel { get; public set; }
    public bool Lossless { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public bool UseCodecOptions { get; public set; }
    public byte QualityLevel { get; public set; }
    public byte SubsamplingLevel { get; public set; }
    public byte OverlapLevel { get; public set; }
    public short HorizontalTileSlices { get; public set; }
    public short VerticalTileSlices { get; public set; }
    public bool FrequencyOrder { get; public set; }
    public bool InterleavedAlpha { get; public set; }
    public byte AlphaQualityLevel { get; public set; }
    public bool CompressedDomainTranscode { get; public set; }
    public byte ImageDataDiscardLevel { get; public set; }
    public byte AlphaDataDiscardLevel { get; public set; }
    public bool IgnoreOverlap { get; public set; }
    internal Guid ContainerFormat { get; }
    public float get_ImageQualityLevel();
    public void set_ImageQualityLevel(float value);
    public bool get_Lossless();
    public void set_Lossless(bool value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    public bool get_UseCodecOptions();
    public void set_UseCodecOptions(bool value);
    public byte get_QualityLevel();
    public void set_QualityLevel(byte value);
    public byte get_SubsamplingLevel();
    public void set_SubsamplingLevel(byte value);
    public byte get_OverlapLevel();
    public void set_OverlapLevel(byte value);
    public short get_HorizontalTileSlices();
    public void set_HorizontalTileSlices(short value);
    public short get_VerticalTileSlices();
    public void set_VerticalTileSlices(short value);
    public bool get_FrequencyOrder();
    public void set_FrequencyOrder(bool value);
    public bool get_InterleavedAlpha();
    public void set_InterleavedAlpha(bool value);
    public byte get_AlphaQualityLevel();
    public void set_AlphaQualityLevel(byte value);
    public bool get_CompressedDomainTranscode();
    public void set_CompressedDomainTranscode(bool value);
    public byte get_ImageDataDiscardLevel();
    public void set_ImageDataDiscardLevel(byte value);
    public byte get_AlphaDataDiscardLevel();
    public void set_AlphaDataDiscardLevel(byte value);
    public bool get_IgnoreOverlap();
    public void set_IgnoreOverlap(bool value);
    [SecurityCriticalAttribute]
internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    [SecurityCriticalAttribute]
internal virtual Guid get_ContainerFormat();
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.WriteableBitmap : BitmapSource {
    public IntPtr BackBuffer { get; private set; }
    public int BackBufferStride { get; }
    [SecurityCriticalAttribute]
public WriteableBitmap(BitmapSource source);
    [SecurityCriticalAttribute]
public WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette);
    [SecurityCriticalAttribute]
public void AddDirtyRect(Int32Rect dirtyRect);
    public WriteableBitmap Clone();
    public WriteableBitmap CloneCurrentValue();
    public void Lock();
    [SecurityCriticalAttribute]
public bool TryLock(Duration timeout);
    [SecurityCriticalAttribute]
public void Unlock();
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    [SecurityCriticalAttribute]
public void WritePixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual void CloneCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual bool FreezeCore(bool isChecking);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    [SecurityCriticalAttribute]
internal virtual void FinalizeCreation();
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateBitmapSourceResource(Channel channel, bool skipOnChannelCheck);
    [SecurityCriticalAttribute]
public IntPtr get_BackBuffer();
    [SecurityCriticalAttribute]
private void set_BackBuffer(IntPtr value);
    public int get_BackBufferStride();
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.Int32CollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Int32CollectionConverter")]
public class System.Windows.Media.Int32Collection : Freezable {
    internal FrugalStructList`1<int> _collection;
    internal UInt32 _version;
    public int Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Int32>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Int32Collection Empty { get; }
    public Int32Collection(int capacity);
    public Int32Collection(IEnumerable`1<int> collection);
    public Int32Collection Clone();
    public Int32Collection CloneCurrentValue();
    public sealed virtual void Add(int value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int value);
    public sealed virtual int IndexOf(int value);
    public sealed virtual void Insert(int index, int value);
    public sealed virtual bool Remove(int value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Int32[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Int32>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Int32Collection get_Empty();
    internal int Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(int value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Int32Collection Parse(string source);
}
public class System.Windows.Media.Int32CollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.IntersectionDetail : Enum {
    public int value__;
    public static IntersectionDetail NotCalculated;
    public static IntersectionDetail Empty;
    public static IntersectionDetail FullyInside;
    public static IntersectionDetail FullyContains;
    public static IntersectionDetail Intersects;
}
public class System.Windows.Media.InvalidWmpVersionException : SystemException {
    public InvalidWmpVersionException(string message);
    protected InvalidWmpVersionException(SerializationInfo info, StreamingContext context);
    public InvalidWmpVersionException(string message, Exception innerException);
}
internal enum System.Windows.Media.KnownColor : Enum {
    public UInt32 value__;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor Gray;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGreen;
    public static KnownColor LightGray;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Transparent;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
    public static KnownColor UnknownColor;
}
internal static class System.Windows.Media.KnownColors : object {
    private static KnownColors();
    public static SolidColorBrush ColorStringToKnownBrush(string s);
    public static bool IsKnownSolidColorBrush(SolidColorBrush scp);
    public static SolidColorBrush SolidColorBrushFromUint(UInt32 argb);
    internal static string MatchColor(string colorString, Boolean& isKnownColor, Boolean& isNumericColor, Boolean& isContextColor, Boolean& isScRgbColor);
    internal static KnownColor ColorStringToKnownColor(string colorString);
    internal static KnownColor ArgbStringToKnownColor(string argbString);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.LanguageSpecificStringDictionary : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public string Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<XmlLanguage> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<string> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    internal LanguageSpecificStringDictionary(IDictionary`2<XmlLanguage, string> innerDictionary);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<XmlLanguage, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(XmlLanguage key, String& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<XmlLanguage, string> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<XmlLanguage, string> item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(XmlLanguage key, string value);
    public sealed virtual bool ContainsKey(XmlLanguage key);
    public sealed virtual bool Remove(XmlLanguage key);
    public sealed virtual string get_Item(XmlLanguage key);
    public sealed virtual void set_Item(XmlLanguage key, string value);
    public sealed virtual ICollection`1<XmlLanguage> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
public class System.Windows.Media.LinearGradientBrush : GradientBrush {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_StartPoint;
    internal static Point s_EndPoint;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static LinearGradientBrush();
    public LinearGradientBrush(Color startColor, Color endColor, double angle);
    public LinearGradientBrush(Color startColor, Color endColor, Point startPoint, Point endPoint);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, double angle);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, Point startPoint, Point endPoint);
    public LinearGradientBrush Clone();
    public LinearGradientBrush CloneCurrentValue();
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.LineGeometry : Geometry {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_StartPoint;
    internal static Point s_EndPoint;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    public Rect Bounds { get; }
    private static LineGeometry();
    public LineGeometry(Point startPoint, Point endPoint);
    public LineGeometry(Point startPoint, Point endPoint, Transform transform);
    public LineGeometry Clone();
    public LineGeometry CloneCurrentValue();
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Point pt1, Point pt2, Matrix geometryMatrix, double tolerance, ToleranceType type);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometryData GetPathGeometryData();
}
public class System.Windows.Media.LineSegment : PathSegment {
    public static DependencyProperty PointProperty;
    internal static Point s_Point;
    public Point Point { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static LineSegment();
    public LineSegment(Point point, bool isStroked);
    internal LineSegment(Point point, bool isStroked, bool isSmoothJoin);
    public LineSegment Clone();
    public LineSegment CloneCurrentValue();
    public Point get_Point();
    public void set_Point(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
internal class System.Windows.Media.MapClass : object {
    public Map`1<bool> _map_ofBrushes;
    internal bool IsEmpty { get; }
    internal bool get_IsEmpty();
}
internal class System.Windows.Media.MatrixStack : object {
    public bool IsEmpty { get; }
    private static MatrixStack();
    public void Push(Matrix& matrix, bool combine);
    public void Push(Transform transform, bool combine);
    public void Push(Vector offset, bool combine);
    public void Pop();
    public Matrix Peek();
    public bool get_IsEmpty();
    public void Optimize();
}
public class System.Windows.Media.MatrixTransform : Transform {
    public static DependencyProperty MatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix s_Matrix;
    public Matrix Matrix { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static MatrixTransform();
    public MatrixTransform(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public MatrixTransform(Matrix matrix);
    public MatrixTransform Clone();
    public MatrixTransform CloneCurrentValue();
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
}
public abstract class System.Windows.Media.Media3D.AffineTransform3D : Transform3D {
    public bool IsAffine { get; }
    public virtual bool get_IsAffine();
    public AffineTransform3D Clone();
    public AffineTransform3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.AmbientLight : Light {
    internal MultiChannelResource _duceResource;
    internal int EffectiveValuesInitialSize { get; }
    public AmbientLight(Color ambientColor);
    public AmbientLight Clone();
    public AmbientLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.AxisAngleRotation3D : Rotation3D {
    internal static Quaternion c_dirtyQuaternion;
    public static DependencyProperty AxisProperty;
    public static DependencyProperty AngleProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Axis;
    internal static double c_Angle;
    internal Quaternion InternalQuaternion { get; }
    public Vector3D Axis { get; public set; }
    public double Angle { get; public set; }
    public AxisAngleRotation3D(Vector3D axis, double angle);
    private static AxisAngleRotation3D();
    internal virtual Quaternion get_InternalQuaternion();
    internal void AxisPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void AnglePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    public AxisAngleRotation3D Clone();
    public AxisAngleRotation3D CloneCurrentValue();
    public Vector3D get_Axis();
    public void set_Axis(Vector3D value);
    public double get_Angle();
    public void set_Angle(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.Camera : Animatable {
    public static DependencyProperty TransformProperty;
    internal static Transform3D s_Transform;
    public Transform3D Transform { get; public set; }
    private static Camera();
    internal abstract virtual RayHitTestParameters RayFromViewportPoint(Point point, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    internal abstract virtual Matrix3D GetViewMatrix();
    internal abstract virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal static void PrependInverseTransform(Transform3D transform, Matrix3D& viewMatrix);
    internal static void PrependInverseTransform(Matrix3D matrix, Matrix3D& viewMatrix);
    public Camera Clone();
    public Camera CloneCurrentValue();
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ContainerUIElement3D : UIElement3D {
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected virtual Visual3D GetVisual3DChild(int index);
    protected virtual int get_Visual3DChildrenCount();
    public Visual3DCollection get_Children();
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public class System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point4DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.QuaternionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Rect3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Size3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.DiffuseMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty AmbientColorProperty;
    public static DependencyProperty BrushProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Color s_AmbientColor;
    internal static Brush s_Brush;
    public Color Color { get; public set; }
    public Color AmbientColor { get; public set; }
    public Brush Brush { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DiffuseMaterial(Brush brush);
    private static DiffuseMaterial();
    public DiffuseMaterial Clone();
    public DiffuseMaterial CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    public Color get_AmbientColor();
    public void set_AmbientColor(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.DirectionalLight : Light {
    public static DependencyProperty DirectionProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Direction;
    public Vector3D Direction { get; public set; }
    public DirectionalLight(Color diffuseColor, Vector3D direction);
    private static DirectionalLight();
    public DirectionalLight Clone();
    public DirectionalLight CloneCurrentValue();
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.EmissiveMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Brush s_Brush;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public EmissiveMaterial(Brush brush);
    private static EmissiveMaterial();
    public EmissiveMaterial Clone();
    public EmissiveMaterial CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.GeneralTransform2DTo3D : Freezable {
    internal GeneralTransform2DTo3D(GeneralTransform transform2D, Viewport2DVisual3D containingVisual3D, GeneralTransform3D transform3D);
    public bool TryTransform(Point inPoint, Point3D& result);
    public Point3D Transform(Point point);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.GeneralTransform3D : Animatable {
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public abstract virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public Point3D Transform(Point3D point);
    public abstract virtual Rect3D TransformBounds(Rect3D rect);
    public abstract virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal abstract virtual Transform3D get_AffineTransform();
    public GeneralTransform3D Clone();
    public GeneralTransform3D CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.GeneralTransform3DCollection : Animatable {
    internal FrugalStructList`1<GeneralTransform3D> _collection;
    internal UInt32 _version;
    public GeneralTransform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeneralTransform3DCollection Empty { get; }
    public GeneralTransform3DCollection(int capacity);
    public GeneralTransform3DCollection(IEnumerable`1<GeneralTransform3D> collection);
    public GeneralTransform3DCollection Clone();
    public GeneralTransform3DCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform3D value);
    public sealed virtual int IndexOf(GeneralTransform3D value);
    public sealed virtual void Insert(int index, GeneralTransform3D value);
    public sealed virtual bool Remove(GeneralTransform3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GeneralTransform3D get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GeneralTransform3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.GeneralTransform3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeneralTransform3DCollection get_Empty();
    internal GeneralTransform3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(GeneralTransform3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Media3D.GeneralTransform3DGroup : GeneralTransform3D {
    public static DependencyProperty ChildrenProperty;
    internal static GeneralTransform3DCollection s_Children;
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public GeneralTransform3DCollection Children { get; public set; }
    private static GeneralTransform3DGroup();
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public GeneralTransform3DGroup Clone();
    public GeneralTransform3DGroup CloneCurrentValue();
    public GeneralTransform3DCollection get_Children();
    public void set_Children(GeneralTransform3DCollection value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.GeneralTransform3DTo2D : Freezable {
    internal GeneralTransform3DTo2D(Matrix3D projectionTransform, GeneralTransform transformBetween2D);
    public bool TryTransform(Point3D inPoint, Point& result);
    public Point Transform(Point3D point);
    public Rect TransformBounds(Rect3D rect3D);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Geometry3D : Animatable {
    public Rect3D Bounds { get; }
    public abstract virtual Rect3D get_Bounds();
    internal void RayHitTest(RayHitTestParameters rayParams, FaceType facesToHit);
    internal abstract virtual void RayHitTestCore(RayHitTestParameters rayParams, FaceType hitTestableFaces);
    public Geometry3D Clone();
    public Geometry3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.Media3D.GeometryModel3D : Model3D {
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty BackMaterialProperty;
    internal MultiChannelResource _duceResource;
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public Material BackMaterial { get; public set; }
    public GeometryModel3D(Geometry3D geometry, Material material);
    private static GeometryModel3D();
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal void MaterialPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void BackMaterialPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    public GeometryModel3D Clone();
    public GeometryModel3D CloneCurrentValue();
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public Material get_BackMaterial();
    public void set_BackMaterial(Material value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.HitTestParameters3D : object {
    internal Visual3D CurrentVisual;
    internal Model3D CurrentModel;
    internal GeometryModel3D CurrentGeometry;
    internal bool HasWorldTransformMatrix { get; }
    internal Matrix3D WorldTransformMatrix { get; }
    internal bool HasModelTransformMatrix { get; }
    internal Matrix3D ModelTransformMatrix { get; }
    internal bool HasHitTestProjectionMatrix { get; }
    internal Matrix3D HitTestProjectionMatrix { get; internal set; }
    internal void PushVisualTransform(Transform3D transform);
    internal void PushModelTransform(Transform3D transform);
    internal void PopTransform(Transform3D transform);
    internal bool get_HasWorldTransformMatrix();
    internal Matrix3D get_WorldTransformMatrix();
    internal bool get_HasModelTransformMatrix();
    internal Matrix3D get_ModelTransformMatrix();
    internal bool get_HasHitTestProjectionMatrix();
    internal Matrix3D get_HitTestProjectionMatrix();
    internal void set_HitTestProjectionMatrix(Matrix3D value);
}
public abstract class System.Windows.Media.Media3D.Light : Model3D {
    public static DependencyProperty ColorProperty;
    internal static Color s_Color;
    public Color Color { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Light();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    public Light Clone();
    public Light CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Material : Animatable {
    public Material Clone();
    public Material CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.MaterialCollection : Animatable {
    internal FrugalStructList`1<Material> _collection;
    internal UInt32 _version;
    public Material Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static MaterialCollection Empty { get; }
    public MaterialCollection(int capacity);
    public MaterialCollection(IEnumerable`1<Material> collection);
    public MaterialCollection Clone();
    public MaterialCollection CloneCurrentValue();
    public sealed virtual void Add(Material value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Material value);
    public sealed virtual int IndexOf(Material value);
    public sealed virtual void Insert(int index, Material value);
    public sealed virtual bool Remove(Material value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Material get_Item(int index);
    public sealed virtual void set_Item(int index, Material value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Material[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Material> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Material>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static MaterialCollection get_Empty();
    internal Material Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Material value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.MaterialGroup : Material {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static MaterialCollection s_Children;
    public MaterialCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static MaterialGroup();
    public MaterialGroup Clone();
    public MaterialGroup CloneCurrentValue();
    public MaterialCollection get_Children();
    public void set_Children(MaterialCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Matrix3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer")]
public class System.Windows.Media.Media3D.Matrix3D : ValueType {
    private double _m11;
    private double _m12;
    private double _m13;
    private double _m14;
    private double _m21;
    private double _m22;
    private double _m23;
    private double _m24;
    private double _m31;
    private double _m32;
    private double _m33;
    private double _m34;
    private double _offsetX;
    private double _offsetY;
    private double _offsetZ;
    private double _m44;
    private bool _isNotKnownToBeIdentity;
    private static int c_identityHashCode;
    public static Matrix3D Identity { get; }
    public bool IsIdentity { get; }
    public bool IsAffine { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M13 { get; public set; }
    public double M14 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double M23 { get; public set; }
    public double M24 { get; public set; }
    public double M31 { get; public set; }
    public double M32 { get; public set; }
    public double M33 { get; public set; }
    public double M34 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public double M44 { get; public set; }
    public Matrix3D(double m11, double m12, double m13, double m14, double m21, double m22, double m23, double m24, double m31, double m32, double m33, double m34, double offsetX, double offsetY, double offsetZ, double m44);
    private static Matrix3D();
    public static Matrix3D get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public void Prepend(Matrix3D matrix);
    public void Append(Matrix3D matrix);
    public void Rotate(Quaternion quaternion);
    public void RotatePrepend(Quaternion quaternion);
    public void RotateAt(Quaternion quaternion, Point3D center);
    public void RotateAtPrepend(Quaternion quaternion, Point3D center);
    public void Scale(Vector3D scale);
    public void ScalePrepend(Vector3D scale);
    public void ScaleAt(Vector3D scale, Point3D center);
    public void ScaleAtPrepend(Vector3D scale, Point3D center);
    public void Translate(Vector3D offset);
    public void TranslatePrepend(Vector3D offset);
    public static Matrix3D op_Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public static Matrix3D Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public Point3D Transform(Point3D point);
    public void Transform(Point3D[] points);
    public Point4D Transform(Point4D point);
    public void Transform(Point4D[] points);
    public Vector3D Transform(Vector3D vector);
    public void Transform(Vector3D[] vectors);
    public bool get_IsAffine();
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M13();
    public void set_M13(double value);
    public double get_M14();
    public void set_M14(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_M23();
    public void set_M23(double value);
    public double get_M24();
    public void set_M24(double value);
    public double get_M31();
    public void set_M31(double value);
    public double get_M32();
    public void set_M32(double value);
    public double get_M33();
    public void set_M33(double value);
    public double get_M34();
    public void set_M34(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public double get_M44();
    public void set_M44(double value);
    internal void SetScaleMatrix(Vector3D& scale);
    internal void SetScaleMatrix(Vector3D& scale, Point3D& center);
    internal void SetTranslationMatrix(Vector3D& offset);
    internal static Matrix3D CreateRotationMatrix(Quaternion& quaternion, Point3D& center);
    internal void MultiplyPoint(Point3D& point);
    internal void MultiplyPoint(Point4D& point);
    internal void MultiplyVector(Vector3D& vector);
    internal double GetNormalizedAffineDeterminant();
    internal bool NormalizedAffineInvert();
    internal bool InvertCore();
    public static bool op_Equality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Inequality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool Equals(Matrix3D matrix1, Matrix3D matrix2);
    public virtual bool Equals(object o);
    public bool Equals(Matrix3D value);
    public virtual int GetHashCode();
    public static Matrix3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Matrix3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Media.Media3D.Matrix3DStack : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public Matrix3D Top { get; }
    public void Clear();
    public Matrix3D Pop();
    public void Push(Matrix3D matrix);
    public int get_Count();
    public bool get_IsEmpty();
    public Matrix3D get_Top();
}
public class System.Windows.Media.Media3D.MatrixCamera : Camera {
    public static DependencyProperty ViewMatrixProperty;
    public static DependencyProperty ProjectionMatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix3D s_ViewMatrix;
    internal static Matrix3D s_ProjectionMatrix;
    public Matrix3D ViewMatrix { get; public set; }
    public Matrix3D ProjectionMatrix { get; public set; }
    public MatrixCamera(Matrix3D viewMatrix, Matrix3D projectionMatrix);
    private static MatrixCamera();
    internal virtual Matrix3D GetViewMatrix();
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    public MatrixCamera Clone();
    public MatrixCamera CloneCurrentValue();
    public Matrix3D get_ViewMatrix();
    public void set_ViewMatrix(Matrix3D value);
    public Matrix3D get_ProjectionMatrix();
    public void set_ProjectionMatrix(Matrix3D value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.MatrixTransform3D : Transform3D {
    public static DependencyProperty MatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix3D s_Matrix;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Matrix3D Matrix { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public MatrixTransform3D(Matrix3D matrix);
    private static MatrixTransform3D();
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    internal virtual void Append(Matrix3D& matrix);
    public MatrixTransform3D Clone();
    public MatrixTransform3D CloneCurrentValue();
    public Matrix3D get_Matrix();
    public void set_Matrix(Matrix3D value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.MeshGeometry3D : Geometry3D {
    public static DependencyProperty PositionsProperty;
    public static DependencyProperty NormalsProperty;
    public static DependencyProperty TextureCoordinatesProperty;
    public static DependencyProperty TriangleIndicesProperty;
    internal MultiChannelResource _duceResource;
    internal static Point3DCollection s_Positions;
    internal static Vector3DCollection s_Normals;
    internal static PointCollection s_TextureCoordinates;
    internal static Int32Collection s_TriangleIndices;
    public Rect3D Bounds { get; }
    public Point3DCollection Positions { get; public set; }
    public Vector3DCollection Normals { get; public set; }
    public PointCollection TextureCoordinates { get; public set; }
    public Int32Collection TriangleIndices { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static MeshGeometry3D();
    public virtual Rect3D get_Bounds();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal Rect GetTextureCoordinateBounds();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams, FaceType hitTestableFaces);
    public MeshGeometry3D Clone();
    public MeshGeometry3D CloneCurrentValue();
    public Point3DCollection get_Positions();
    public void set_Positions(Point3DCollection value);
    public Vector3DCollection get_Normals();
    public void set_Normals(Vector3DCollection value);
    public PointCollection get_TextureCoordinates();
    public void set_TextureCoordinates(PointCollection value);
    public Int32Collection get_TriangleIndices();
    public void set_TriangleIndices(Int32Collection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Model3D : Animatable {
    public static DependencyProperty TransformProperty;
    internal static Transform3D s_Transform;
    public Rect3D Bounds { get; }
    public Transform3D Transform { get; public set; }
    private static Model3D();
    public Rect3D get_Bounds();
    internal void RayHitTest(RayHitTestParameters rayParams);
    internal abstract virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal Rect3D CalculateSubgraphBoundsOuterSpace();
    internal abstract virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    public Model3D Clone();
    public Model3D CloneCurrentValue();
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Model3DCollection : Animatable {
    internal FrugalStructList`1<Model3D> _collection;
    internal UInt32 _version;
    public Model3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Model3DCollection Empty { get; }
    public Model3DCollection(int capacity);
    public Model3DCollection(IEnumerable`1<Model3D> collection);
    public Model3DCollection Clone();
    public Model3DCollection CloneCurrentValue();
    public sealed virtual void Add(Model3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Model3D value);
    public sealed virtual int IndexOf(Model3D value);
    public sealed virtual void Insert(int index, Model3D value);
    public sealed virtual bool Remove(Model3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Model3D get_Item(int index);
    public sealed virtual void set_Item(int index, Model3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Model3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Model3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Model3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Model3DCollection get_Empty();
    internal Model3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Model3D value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Model3DGroup : Model3D {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static Model3DCollection s_Children;
    internal static Model3DGroup EmptyGroup { get; }
    public Model3DCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Model3DGroup();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    internal static Model3DGroup get_EmptyGroup();
    public Model3DGroup Clone();
    public Model3DGroup CloneCurrentValue();
    public Model3DCollection get_Children();
    public void set_Children(Model3DCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[ContentPropertyAttribute("Model")]
public class System.Windows.Media.Media3D.ModelUIElement3D : UIElement3D {
    public static DependencyProperty ModelProperty;
    public Model3D Model { get; public set; }
    private static ModelUIElement3D();
    public Model3D get_Model();
    public void set_Model(Model3D value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ModelVisual3D : Visual3D {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty TransformProperty;
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public Model3D Content { get; public set; }
    public Transform3D Transform { get; public set; }
    private static ModelVisual3D();
    protected sealed virtual Visual3D GetVisual3DChild(int index);
    protected sealed virtual int get_Visual3DChildrenCount();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Visual3DCollection get_Children();
    public Model3D get_Content();
    public void set_Content(Model3D value);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
}
public class System.Windows.Media.Media3D.OrthographicCamera : ProjectionCamera {
    public static DependencyProperty WidthProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Width;
    public double Width { get; public set; }
    public OrthographicCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double width);
    private static OrthographicCamera();
    internal Matrix3D GetProjectionMatrix(double aspectRatio, double zn, double zf);
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    public OrthographicCamera Clone();
    public OrthographicCamera CloneCurrentValue();
    public double get_Width();
    public void set_Width(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.PerspectiveCamera : ProjectionCamera {
    public static DependencyProperty FieldOfViewProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_FieldOfView;
    public double FieldOfView { get; public set; }
    public PerspectiveCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double fieldOfView);
    private static PerspectiveCamera();
    internal Matrix3D GetProjectionMatrix(double aspectRatio, double zn, double zf);
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    public PerspectiveCamera Clone();
    public PerspectiveCamera CloneCurrentValue();
    public double get_FieldOfView();
    public void set_FieldOfView(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DConverter")]
public class System.Windows.Media.Media3D.Point3D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Point3D(double x, double y, double z);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Point3D op_Addition(Point3D point, Vector3D vector);
    public static Point3D Add(Point3D point, Vector3D vector);
    public static Point3D op_Subtraction(Point3D point, Vector3D vector);
    public static Point3D Subtract(Point3D point, Vector3D vector);
    public static Vector3D op_Subtraction(Point3D point1, Point3D point2);
    public static Vector3D Subtract(Point3D point1, Point3D point2);
    internal static void Subtract(Point3D& p1, Point3D& p2, Vector3D& result);
    public static Point3D op_Multiply(Point3D point, Matrix3D matrix);
    public static Point3D Multiply(Point3D point, Matrix3D matrix);
    public static Vector3D op_Explicit(Point3D point);
    public static Point4D op_Explicit(Point3D point);
    public static bool op_Equality(Point3D point1, Point3D point2);
    public static bool op_Inequality(Point3D point1, Point3D point2);
    public static bool Equals(Point3D point1, Point3D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point3D value);
    public virtual int GetHashCode();
    public static Point3D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DCollectionConverter")]
public class System.Windows.Media.Media3D.Point3DCollection : Freezable {
    internal FrugalStructList`1<Point3D> _collection;
    internal UInt32 _version;
    public Point3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Point3DCollection Empty { get; }
    public Point3DCollection(int capacity);
    public Point3DCollection(IEnumerable`1<Point3D> collection);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
    public Point3DCollection Clone();
    public Point3DCollection CloneCurrentValue();
    public sealed virtual void Add(Point3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point3D value);
    public sealed virtual int IndexOf(Point3D value);
    public sealed virtual void Insert(int index, Point3D value);
    public sealed virtual bool Remove(Point3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Point3D get_Item(int index);
    public sealed virtual void set_Item(int index, Point3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Point3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Point3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Point3DCollection get_Empty();
    internal Point3D Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(Point3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Point3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Point3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Point3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point4DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point4DConverter")]
public class System.Windows.Media.Media3D.Point4D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _w;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    public Point4D(double x, double y, double z, double w);
    public void Offset(double deltaX, double deltaY, double deltaZ, double deltaW);
    public static Point4D op_Addition(Point4D point1, Point4D point2);
    public static Point4D Add(Point4D point1, Point4D point2);
    public static Point4D op_Subtraction(Point4D point1, Point4D point2);
    public static Point4D Subtract(Point4D point1, Point4D point2);
    public static Point4D op_Multiply(Point4D point, Matrix3D matrix);
    public static Point4D Multiply(Point4D point, Matrix3D matrix);
    public static bool op_Equality(Point4D point1, Point4D point2);
    public static bool op_Inequality(Point4D point1, Point4D point2);
    public static bool Equals(Point4D point1, Point4D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point4D value);
    public virtual int GetHashCode();
    public static Point4D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Point4DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.PointLight : PointLightBase {
    internal MultiChannelResource _duceResource;
    public PointLight(Color diffuseColor, Point3D position);
    public PointLight Clone();
    public PointLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.PointLightBase : Light {
    public static DependencyProperty PositionProperty;
    public static DependencyProperty RangeProperty;
    public static DependencyProperty ConstantAttenuationProperty;
    public static DependencyProperty LinearAttenuationProperty;
    public static DependencyProperty QuadraticAttenuationProperty;
    internal static Point3D s_Position;
    internal static double c_Range;
    internal static double c_ConstantAttenuation;
    internal static double c_LinearAttenuation;
    internal static double c_QuadraticAttenuation;
    public Point3D Position { get; public set; }
    public double Range { get; public set; }
    public double ConstantAttenuation { get; public set; }
    public double LinearAttenuation { get; public set; }
    public double QuadraticAttenuation { get; public set; }
    private static PointLightBase();
    public PointLightBase Clone();
    public PointLightBase CloneCurrentValue();
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public double get_Range();
    public void set_Range(double value);
    public double get_ConstantAttenuation();
    public void set_ConstantAttenuation(double value);
    public double get_LinearAttenuation();
    public void set_LinearAttenuation(double value);
    public double get_QuadraticAttenuation();
    public void set_QuadraticAttenuation(double value);
}
public abstract class System.Windows.Media.Media3D.ProjectionCamera : Camera {
    public static DependencyProperty NearPlaneDistanceProperty;
    public static DependencyProperty FarPlaneDistanceProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty LookDirectionProperty;
    public static DependencyProperty UpDirectionProperty;
    internal static double c_NearPlaneDistance;
    internal static double c_FarPlaneDistance;
    internal static Point3D s_Position;
    internal static Vector3D s_LookDirection;
    internal static Vector3D s_UpDirection;
    public double NearPlaneDistance { get; public set; }
    public double FarPlaneDistance { get; public set; }
    public Point3D Position { get; public set; }
    public Vector3D LookDirection { get; public set; }
    public Vector3D UpDirection { get; public set; }
    private static ProjectionCamera();
    internal virtual Matrix3D GetViewMatrix();
    internal static Matrix3D CreateViewMatrix(Transform3D transform, Point3D& position, Vector3D& lookDirection, Vector3D& upDirection);
    public ProjectionCamera Clone();
    public ProjectionCamera CloneCurrentValue();
    public double get_NearPlaneDistance();
    public void set_NearPlaneDistance(double value);
    public double get_FarPlaneDistance();
    public void set_FarPlaneDistance(double value);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public Vector3D get_LookDirection();
    public void set_LookDirection(Vector3D value);
    public Vector3D get_UpDirection();
    public void set_UpDirection(Vector3D value);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.QuaternionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.QuaternionValueSerializer")]
public class System.Windows.Media.Media3D.Quaternion : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _w;
    private bool _isNotDistinguishedIdentity;
    public static Quaternion Identity { get; }
    public Vector3D Axis { get; }
    public double Angle { get; }
    public bool IsNormalized { get; }
    public bool IsIdentity { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    public Quaternion(double x, double y, double z, double w);
    public Quaternion(Vector3D axisOfRotation, double angleInDegrees);
    private static Quaternion();
    public static Quaternion get_Identity();
    public Vector3D get_Axis();
    public double get_Angle();
    public bool get_IsNormalized();
    public bool get_IsIdentity();
    public void Conjugate();
    public void Invert();
    public void Normalize();
    public static Quaternion op_Addition(Quaternion left, Quaternion right);
    public static Quaternion Add(Quaternion left, Quaternion right);
    public static Quaternion op_Subtraction(Quaternion left, Quaternion right);
    public static Quaternion Subtract(Quaternion left, Quaternion right);
    public static Quaternion op_Multiply(Quaternion left, Quaternion right);
    public static Quaternion Multiply(Quaternion left, Quaternion right);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t, bool useShortestPath);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    public static bool op_Equality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool op_Inequality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool Equals(Quaternion quaternion1, Quaternion quaternion2);
    public virtual bool Equals(object o);
    public bool Equals(Quaternion value);
    public virtual int GetHashCode();
    public static Quaternion Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.QuaternionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.QuaternionRotation3D : Rotation3D {
    public static DependencyProperty QuaternionProperty;
    internal MultiChannelResource _duceResource;
    internal static Quaternion s_Quaternion;
    internal Quaternion InternalQuaternion { get; }
    public Quaternion Quaternion { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public QuaternionRotation3D(Quaternion quaternion);
    private static QuaternionRotation3D();
    internal virtual Quaternion get_InternalQuaternion();
    public QuaternionRotation3D Clone();
    public QuaternionRotation3D CloneCurrentValue();
    public Quaternion get_Quaternion();
    public void set_Quaternion(Quaternion value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.RayHitTestParameters : HitTestParameters3D {
    public Point3D Origin { get; }
    public Vector3D Direction { get; }
    internal bool IsRay { get; }
    public RayHitTestParameters(Point3D origin, Vector3D direction);
    public Point3D get_Origin();
    public Vector3D get_Direction();
    internal void ReportResult(MeshGeometry3D meshHit, Point3D pointHit, double distanceToRayOrigin, int vertexIndex1, int vertexIndex2, int vertexIndex3, Point barycentric);
    internal HitTestResultBehavior RaiseCallback(HitTestResultCallback resultCallback, HitTestFilterCallback filterCallback, HitTestResultBehavior lastResult);
    internal HitTestResultBehavior RaiseCallback(HitTestResultCallback resultCallback, HitTestFilterCallback filterCallback, HitTestResultBehavior lastResult, double distanceAdjustment);
    internal void GetLocalLine(Point3D& origin, Vector3D& direction);
    internal void ClearResults();
    internal bool get_IsRay();
}
public abstract class System.Windows.Media.Media3D.RayHitTestResult : HitTestResult {
    public Visual3D VisualHit { get; }
    public Model3D ModelHit { get; }
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    internal RayHitTestResult(Visual3D visualHit, Model3D modelHit);
    public Visual3D get_VisualHit();
    public Model3D get_ModelHit();
    public abstract virtual Point3D get_PointHit();
    public abstract virtual double get_DistanceToRayOrigin();
    internal abstract virtual void SetDistanceToRayOrigin(double distance);
    internal static int CompareByDistanceToRayOrigin(RayHitTestResult x, RayHitTestResult y);
}
public class System.Windows.Media.Media3D.RayMeshGeometry3DHitTestResult : RayHitTestResult {
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    public int VertexIndex1 { get; }
    public int VertexIndex2 { get; }
    public int VertexIndex3 { get; }
    public double VertexWeight1 { get; }
    public double VertexWeight2 { get; }
    public double VertexWeight3 { get; }
    public MeshGeometry3D MeshHit { get; }
    internal RayMeshGeometry3DHitTestResult(Visual3D visualHit, Model3D modelHit, MeshGeometry3D meshHit, Point3D pointHit, double distanceToRayOrigin, int vertexIndex1, int vertexIndex2, int vertexIndex3, Point barycentricCoordinate);
    public virtual Point3D get_PointHit();
    public virtual double get_DistanceToRayOrigin();
    public int get_VertexIndex1();
    public int get_VertexIndex2();
    public int get_VertexIndex3();
    public double get_VertexWeight1();
    public double get_VertexWeight2();
    public double get_VertexWeight3();
    public MeshGeometry3D get_MeshHit();
    internal virtual void SetDistanceToRayOrigin(double distance);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Rect3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Rect3DValueSerializer")]
public class System.Windows.Media.Media3D.Rect3D : ValueType {
    internal static Rect3D Infinite;
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _sizeX;
    internal double _sizeY;
    internal double _sizeZ;
    public static Rect3D Empty { get; }
    public bool IsEmpty { get; }
    public Point3D Location { get; public set; }
    public Size3D Size { get; public set; }
    public double SizeX { get; public set; }
    public double SizeY { get; public set; }
    public double SizeZ { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Rect3D(Point3D location, Size3D size);
    public Rect3D(double x, double y, double z, double sizeX, double sizeY, double sizeZ);
    internal Rect3D(Point3D point1, Point3D point2);
    internal Rect3D(Point3D point, Vector3D vector);
    private static Rect3D();
    public static Rect3D get_Empty();
    public bool get_IsEmpty();
    public Point3D get_Location();
    public void set_Location(Point3D value);
    public Size3D get_Size();
    public void set_Size(Size3D value);
    public double get_SizeX();
    public void set_SizeX(double value);
    public double get_SizeY();
    public void set_SizeY(double value);
    public double get_SizeZ();
    public void set_SizeZ(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Contains(Point3D point);
    public bool Contains(double x, double y, double z);
    public bool Contains(Rect3D rect);
    public bool IntersectsWith(Rect3D rect);
    public void Intersect(Rect3D rect);
    public static Rect3D Intersect(Rect3D rect1, Rect3D rect2);
    public void Union(Rect3D rect);
    public static Rect3D Union(Rect3D rect1, Rect3D rect2);
    public void Union(Point3D point);
    public static Rect3D Union(Rect3D rect, Point3D point);
    public void Offset(Vector3D offsetVector);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Rect3D Offset(Rect3D rect, Vector3D offsetVector);
    public static Rect3D Offset(Rect3D rect, double offsetX, double offsetY, double offsetZ);
    public static bool op_Equality(Rect3D rect1, Rect3D rect2);
    public static bool op_Inequality(Rect3D rect1, Rect3D rect2);
    public static bool Equals(Rect3D rect1, Rect3D rect2);
    public virtual bool Equals(object o);
    public bool Equals(Rect3D value);
    public virtual int GetHashCode();
    public static Rect3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Rect3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.RotateTransform3D : AffineTransform3D {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public static DependencyProperty RotationProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_CenterX;
    internal static double c_CenterY;
    internal static double c_CenterZ;
    internal static Rotation3D s_Rotation;
    public Matrix3D Value { get; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public Rotation3D Rotation { get; public set; }
    public RotateTransform3D(Rotation3D rotation);
    public RotateTransform3D(Rotation3D rotation, Point3D center);
    public RotateTransform3D(Rotation3D rotation, double centerX, double centerY, double centerZ);
    private static RotateTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public RotateTransform3D Clone();
    public RotateTransform3D CloneCurrentValue();
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public Rotation3D get_Rotation();
    public void set_Rotation(Rotation3D value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.Rotation3D : Animatable {
    public static Rotation3D Identity { get; }
    internal Quaternion InternalQuaternion { get; }
    private static Rotation3D();
    public static Rotation3D get_Identity();
    internal abstract virtual Quaternion get_InternalQuaternion();
    public Rotation3D Clone();
    public Rotation3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.ScaleTransform3D : AffineTransform3D {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty ScaleZProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_ScaleX;
    internal static double c_ScaleY;
    internal static double c_ScaleZ;
    internal static double c_CenterX;
    internal static double c_CenterY;
    internal static double c_CenterZ;
    public Matrix3D Value { get; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double ScaleZ { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public ScaleTransform3D(Vector3D scale);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ);
    public ScaleTransform3D(Vector3D scale, Point3D center);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ, double centerX, double centerY, double centerZ);
    private static ScaleTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public ScaleTransform3D Clone();
    public ScaleTransform3D CloneCurrentValue();
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_ScaleZ();
    public void set_ScaleZ(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Size3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Size3DValueSerializer")]
public class System.Windows.Media.Media3D.Size3D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    public static Size3D Empty { get; }
    public bool IsEmpty { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Size3D(double x, double y, double z);
    private static Size3D();
    public static Size3D get_Empty();
    public bool get_IsEmpty();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Vector3D op_Explicit(Size3D size);
    public static Point3D op_Explicit(Size3D size);
    public static bool op_Equality(Size3D size1, Size3D size2);
    public static bool op_Inequality(Size3D size1, Size3D size2);
    public static bool Equals(Size3D size1, Size3D size2);
    public virtual bool Equals(object o);
    public bool Equals(Size3D value);
    public virtual int GetHashCode();
    public static Size3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Size3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.SpecularMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    public static DependencyProperty SpecularPowerProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Brush s_Brush;
    internal static double c_SpecularPower;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    public double SpecularPower { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public SpecularMaterial(Brush brush, double specularPower);
    private static SpecularMaterial();
    public SpecularMaterial Clone();
    public SpecularMaterial CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_SpecularPower();
    public void set_SpecularPower(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.SpotLight : PointLightBase {
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OuterConeAngleProperty;
    public static DependencyProperty InnerConeAngleProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Direction;
    internal static double c_OuterConeAngle;
    internal static double c_InnerConeAngle;
    public Vector3D Direction { get; public set; }
    public double OuterConeAngle { get; public set; }
    public double InnerConeAngle { get; public set; }
    public SpotLight(Color diffuseColor, Point3D position, Vector3D direction, double outerConeAngle, double innerConeAngle);
    private static SpotLight();
    public SpotLight Clone();
    public SpotLight CloneCurrentValue();
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public double get_OuterConeAngle();
    public void set_OuterConeAngle(double value);
    public double get_InnerConeAngle();
    public void set_InnerConeAngle(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Transform3D : GeneralTransform3D {
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public static Transform3D Identity { get; }
    public bool IsAffine { get; }
    public Matrix3D Value { get; }
    public Point3D Transform(Point3D point);
    public Vector3D Transform(Vector3D vector);
    public Point4D Transform(Point4D point);
    public void Transform(Point3D[] points);
    public void Transform(Vector3D[] vectors);
    public void Transform(Point4D[] points);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public static Transform3D get_Identity();
    public abstract virtual bool get_IsAffine();
    public abstract virtual Matrix3D get_Value();
    internal abstract virtual void Append(Matrix3D& matrix);
    public Transform3D Clone();
    public Transform3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Transform3DCollection : Animatable {
    internal FrugalStructList`1<Transform3D> _collection;
    internal UInt32 _version;
    public Transform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Transform3DCollection Empty { get; }
    public Transform3DCollection(int capacity);
    public Transform3DCollection(IEnumerable`1<Transform3D> collection);
    public Transform3DCollection Clone();
    public Transform3DCollection CloneCurrentValue();
    public sealed virtual void Add(Transform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform3D value);
    public sealed virtual int IndexOf(Transform3D value);
    public sealed virtual void Insert(int index, Transform3D value);
    public sealed virtual bool Remove(Transform3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Transform3D get_Item(int index);
    public sealed virtual void set_Item(int index, Transform3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Transform3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Transform3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Transform3DCollection get_Empty();
    internal Transform3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Transform3D value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Transform3DGroup : Transform3D {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static Transform3DCollection s_Children;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Transform3DCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Transform3DGroup();
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    internal virtual void Append(Matrix3D& matrix);
    public Transform3DGroup Clone();
    public Transform3DGroup CloneCurrentValue();
    public Transform3DCollection get_Children();
    public void set_Children(Transform3DCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.TranslateTransform3D : AffineTransform3D {
    public static DependencyProperty OffsetXProperty;
    public static DependencyProperty OffsetYProperty;
    public static DependencyProperty OffsetZProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_OffsetX;
    internal static double c_OffsetY;
    internal static double c_OffsetZ;
    public Matrix3D Value { get; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public TranslateTransform3D(Vector3D offset);
    public TranslateTransform3D(double offsetX, double offsetY, double offsetZ);
    private static TranslateTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public TranslateTransform3D Clone();
    public TranslateTransform3D CloneCurrentValue();
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DConverter")]
public class System.Windows.Media.Media3D.Vector3D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Vector3D(double x, double y, double z);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double AngleBetween(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_UnaryNegation(Vector3D vector);
    public void Negate();
    public static Vector3D op_Addition(Vector3D vector1, Vector3D vector2);
    public static Vector3D Add(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_Subtraction(Vector3D vector1, Vector3D vector2);
    public static Vector3D Subtract(Vector3D vector1, Vector3D vector2);
    public static Point3D op_Addition(Vector3D vector, Point3D point);
    public static Point3D Add(Vector3D vector, Point3D point);
    public static Point3D op_Subtraction(Vector3D vector, Point3D point);
    public static Point3D Subtract(Vector3D vector, Point3D point);
    public static Vector3D op_Multiply(Vector3D vector, double scalar);
    public static Vector3D Multiply(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(double scalar, Vector3D vector);
    public static Vector3D Multiply(double scalar, Vector3D vector);
    public static Vector3D op_Division(Vector3D vector, double scalar);
    public static Vector3D Divide(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(Vector3D vector, Matrix3D matrix);
    public static Vector3D Multiply(Vector3D vector, Matrix3D matrix);
    public static double DotProduct(Vector3D vector1, Vector3D vector2);
    internal static double DotProduct(Vector3D& vector1, Vector3D& vector2);
    public static Vector3D CrossProduct(Vector3D vector1, Vector3D vector2);
    internal static void CrossProduct(Vector3D& vector1, Vector3D& vector2, Vector3D& result);
    public static Point3D op_Explicit(Vector3D vector);
    public static Size3D op_Explicit(Vector3D vector);
    public static bool op_Equality(Vector3D vector1, Vector3D vector2);
    public static bool op_Inequality(Vector3D vector1, Vector3D vector2);
    public static bool Equals(Vector3D vector1, Vector3D vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector3D value);
    public virtual int GetHashCode();
    public static Vector3D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DCollectionConverter")]
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Vector3DCollection : Freezable {
    internal FrugalStructList`1<Vector3D> _collection;
    internal UInt32 _version;
    public Vector3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Vector3DCollection Empty { get; }
    public Vector3DCollection(int capacity);
    public Vector3DCollection(IEnumerable`1<Vector3D> collection);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
    public Vector3DCollection Clone();
    public Vector3DCollection CloneCurrentValue();
    public sealed virtual void Add(Vector3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector3D value);
    public sealed virtual int IndexOf(Vector3D value);
    public sealed virtual void Insert(int index, Vector3D value);
    public sealed virtual bool Remove(Vector3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Vector3D get_Item(int index);
    public sealed virtual void set_Item(int index, Vector3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Vector3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Vector3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Vector3DCollection get_Empty();
    internal Vector3D Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(Vector3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Vector3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Vector3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Vector3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Visual")]
public class System.Windows.Media.Media3D.Viewport2DVisual3D : Visual3D {
    public static DependencyProperty VisualProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty IsVisualHostMaterialProperty;
    public static DependencyProperty CacheModeProperty;
    public Visual Visual { get; public set; }
    public Geometry3D Geometry { get; public set; }
    internal Point3DCollection InternalPositionsCache { get; internal set; }
    internal PointCollection InternalTextureCoordinatesCache { get; internal set; }
    internal Int32Collection InternalTriangleIndicesCache { get; internal set; }
    public Material Material { get; public set; }
    public CacheMode CacheMode { get; public set; }
    protected int Visual3DChildrenCount { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    private static Viewport2DVisual3D();
    internal static bool Get3DPointFor2DCoordinate(Point point, Point3D& point3D, Point3DCollection positions, PointCollection textureCoords, Int32Collection triIndices);
    internal static Point TextureCoordsToVisualCoords(Point uv, Visual visual);
    internal static Point TextureCoordsToVisualCoords(Point uv, Rect descBounds);
    internal static bool GetIntersectionInfo(RayHitTestResult rayHitResult, Point& outputPoint);
    internal static Point VisualCoordsToTextureCoords(Point pt, Visual visual);
    internal static Point VisualCoordsToTextureCoords(Point pt, Rect descBounds);
    public Visual get_Visual();
    public void set_Visual(Visual value);
    internal static void OnVisualChanged(object sender, DependencyPropertyChangedEventArgs e);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    internal static void OnGeometryChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal Point3DCollection get_InternalPositionsCache();
    internal void set_InternalPositionsCache(Point3DCollection value);
    internal PointCollection get_InternalTextureCoordinatesCache();
    internal void set_InternalTextureCoordinatesCache(PointCollection value);
    internal Int32Collection get_InternalTriangleIndicesCache();
    internal void set_InternalTriangleIndicesCache(Int32Collection value);
    public Material get_Material();
    public void set_Material(Material value);
    internal static void OnMaterialPropertyChanged(object sender, DependencyPropertyChangedEventArgs e);
    public static void SetIsVisualHostMaterial(Material element, bool value);
    public static bool GetIsVisualHostMaterial(Material element);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    internal static void OnCacheModeChanged(object sender, DependencyPropertyChangedEventArgs e);
    protected virtual int get_Visual3DChildrenCount();
    protected virtual Visual3D GetVisual3DChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Viewport3DVisual : Visual {
    public static DependencyProperty CameraProperty;
    public static DependencyProperty ViewportProperty;
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    public Camera Camera { get; public set; }
    public Rect Viewport { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    private static Viewport3DVisual();
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    public Camera get_Camera();
    public void set_Camera(Camera value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Visual3DCollection get_Children();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.AddChild(Visual3D child);
    private sealed virtual override void MS.Internal.IVisual3DContainer.RemoveChild(Visual3D child);
    private sealed virtual override int MS.Internal.IVisual3DContainer.GetChildrenCount();
    private sealed virtual override Visual3D MS.Internal.IVisual3DContainer.GetChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal virtual HitTestResultBehavior HitTestPointInternal(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    internal Point WorldToViewport(Point4D point);
    internal virtual Rect GetHitTestBounds();
    internal virtual Rect CalculateSubgraphBoundsInnerSpace(bool renderBounds);
    internal Rect3D ComputeSubgraphBounds3D();
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual void PrecomputeContent();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void FreeContent(Channel channel);
    internal void Visual3DTreeChanged();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    [FriendAccessAllowedAttribute]
internal void SetInheritanceContextForChildren(DependencyObject inheritanceContextForChildren);
}
public abstract class System.Windows.Media.Media3D.Visual3D : DependencyObject {
    public static DependencyProperty TransformProperty;
    internal VisualProxy _proxy;
    public Transform3D Transform { get; public set; }
    internal bool InternalIsVisible { get; internal set; }
    protected Model3D Visual3DModel { get; protected set; }
    internal Rect3D VisualContentBounds { get; }
    [FriendAccessAllowedAttribute]
internal Rect Visual2DContentBounds { get; }
    internal Rect3D BBoxSubgraph { get; }
    internal Rect3D VisualDescendantBounds { get; }
    protected int Visual3DChildrenCount { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal DependencyObject InternalVisualParent { get; }
    internal int ParentIndex { get; internal set; }
    internal bool IsVisualChildrenIterationInProgress { get; internal set; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    public bool HasAnimatedProperties { get; }
    private static Visual3D();
    internal bool IsOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected void AddVisual3DChild(Visual3D child);
    protected void RemoveVisual3DChild(Visual3D child);
    internal bool get_InternalIsVisible();
    internal void set_InternalIsVisible(bool value);
    protected Model3D get_Visual3DModel();
    protected void set_Visual3DModel(Model3D value);
    internal virtual void FireOnVisualParentChanged(DependencyObject oldParent);
    internal void add_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal void remove_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal static void ProcessAncestorChangedNotificationRecursive(DependencyObject e, AncestorChangedEventArgs args);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal bool DoesRayHitSubgraphBounds(RayHitTestParameters rayParams);
    internal void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
    internal HitTestResultBehavior RayHitTest(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal HitTestResultBehavior HitTestChildren(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal static HitTestResultBehavior HitTestChildren(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams, IVisual3DContainer container);
    internal void RayHitTestInternal(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal void RenderChanged(object sender, EventArgs e);
    internal Rect3D get_VisualContentBounds();
    internal Rect get_Visual2DContentBounds();
    internal Rect3D get_BBoxSubgraph();
    internal Rect3D GetContentBounds();
    internal Rect3D CalculateSubgraphBoundsOuterSpace();
    internal Rect3D CalculateSubgraphBoundsInnerSpace();
    internal Rect3D get_VisualDescendantBounds();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(DependencyObject other);
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(DependencyObject other);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(DependencyObject other);
    internal void SetParent(Visual newParent);
    internal void SetParent(Visual3D newParent);
    protected virtual int get_Visual3DChildrenCount();
    protected virtual Visual3D GetVisual3DChild(int index);
    private sealed virtual override void MS.Internal.IVisual3DContainer.AddChild(Visual3D child);
    private sealed virtual override void MS.Internal.IVisual3DContainer.RemoveChild(Visual3D child);
    private sealed virtual override int MS.Internal.IVisual3DContainer.GetChildrenCount();
    private sealed virtual override Visual3D MS.Internal.IVisual3DContainer.GetChild(int index);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyBoundsEqual(Rect3D bounds1, Rect3D bounds2, string errorString);
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyCachedSubgraphBounds();
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyCachedContentBounds();
    internal void PrecomputeRecursive(Rect3D& bboxSubgraph);
    internal void RenderRecursive(RenderContext ctx);
    internal void RenderContent(RenderContext ctx, bool isOnChannel);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    internal void SetFlagsToRoot(bool value, VisualFlags flag);
    internal DependencyObject FindFirstAncestorWithFlagsAnd(VisualFlags flag);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    internal void FreeDUCEResources(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal void ReleaseOnChannelCore(Channel channel);
    internal void DisconnectAttachedResource(VisualProxyFlags correspondingFlag, IResource attachedResource);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    public GeneralTransform3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform3D TransformToDescendant(Visual3D descendant);
    public GeneralTransform3DTo2D TransformToAncestor(Visual ancestor);
    internal GeneralTransform3DTo2D InternalTransformToAncestor(Visual ancestor);
    internal DependencyObject get_InternalVisualParent();
    internal int get_ParentIndex();
    internal void set_ParentIndex(int value);
    [FriendAccessAllowedAttribute]
internal bool get_IsVisualChildrenIterationInProgress();
    [FriendAccessAllowedAttribute]
internal void set_IsVisualChildrenIterationInProgress(bool value);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(bool value, VisualFlags Flags);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(VisualFlags flags);
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal bool CheckFlagsOr(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsOr(VisualFlags flags);
    internal static bool DoAnyChildrenHaveABitSet(Visual3D pe, VisualFlags flag);
    internal static void PropagateFlags(Visual3D e, VisualFlags flags, VisualProxyFlags proxyFlags);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Visual3DCollection : object {
    public Visual3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal int InternalCount { get; }
    internal Visual3DCollection(IVisual3DContainer owner);
    public sealed virtual void Add(Visual3D value);
    public sealed virtual void Insert(int index, Visual3D value);
    public sealed virtual bool Remove(Visual3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(Visual3D[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual bool Contains(Visual3D value);
    public sealed virtual int IndexOf(Visual3D value);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Visual3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Visual3D>.GetEnumerator();
    public sealed virtual Visual3D get_Item(int index);
    public sealed virtual void set_Item(int index, Visual3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    internal Visual3D InternalGetItem(int index);
    internal int get_InternalCount();
}
public class System.Windows.Media.MediaClock : Clock {
    public MediaTimeline Timeline { get; }
    internal bool NeedsTicksWhenActive { get; }
    internal MediaPlayer Player { get; internal set; }
    protected internal MediaClock(MediaTimeline media);
    public MediaTimeline get_Timeline();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void Stopped();
    protected virtual void SpeedChanged();
    protected virtual void DiscontinuousTimeMovement();
    internal virtual bool get_NeedsTicksWhenActive();
    internal MediaPlayer get_Player();
    internal void set_Player(MediaPlayer value);
}
internal class System.Windows.Media.MediaContext : DispatcherObject {
    internal static bool IsClockSupported { get; }
    internal static bool ShouldRenderEvenWhenNoDisplayDevicesAreAvailable { get; }
    internal int Tier { get; }
    internal UInt32 PixelShaderVersion { get; private set; }
    internal UInt32 MaxPixelShader30InstructionSlots { get; private set; }
    internal bool HasSSE2Support { get; private set; }
    internal Size MaxTextureSize { get; private set; }
    internal static long CurrentTicks { get; }
    private TimeSpan System.Windows.Media.Animation.IClock.CurrentTime { get; }
    internal static MediaContext CurrentMediaContext { get; }
    internal bool WriteAccessEnabled { get; }
    internal TimeManager TimeManager { get; }
    internal Channel Channel { get; }
    internal Channel OutOfBandChannel { get; }
    internal bool IsConnected { get; }
    private static MediaContext();
    internal MediaContext(Dispatcher dispatcher);
    internal static bool get_IsClockSupported();
    [CompilerGeneratedAttribute]
internal static bool get_ShouldRenderEvenWhenNoDisplayDevicesAreAvailable();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void NotifySyncChannelMessage(Channel channel);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void NotifyChannelMessage();
    internal void PostInvalidateRenderMode();
    [CompilerGeneratedAttribute]
internal void add_InvalidPixelShaderEncountered(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_InvalidPixelShaderEncountered(EventHandler value);
    internal int get_Tier();
    [CompilerGeneratedAttribute]
internal UInt32 get_PixelShaderVersion();
    [CompilerGeneratedAttribute]
private void set_PixelShaderVersion(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_MaxPixelShader30InstructionSlots();
    [CompilerGeneratedAttribute]
private void set_MaxPixelShader30InstructionSlots(UInt32 value);
    [CompilerGeneratedAttribute]
internal bool get_HasSSE2Support();
    [CompilerGeneratedAttribute]
private void set_HasSSE2Support(bool value);
    [CompilerGeneratedAttribute]
internal Size get_MaxTextureSize();
    [CompilerGeneratedAttribute]
private void set_MaxTextureSize(Size value);
    [CompilerGeneratedAttribute]
internal void add_TierChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_TierChanged(EventHandler value);
    internal static long get_CurrentTicks();
    private sealed virtual override TimeSpan System.Windows.Media.Animation.IClock.get_CurrentTime();
    internal void CreateChannels();
    internal static MediaContext From(Dispatcher dispatcher);
    internal static MediaContext get_CurrentMediaContext();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void Dispose();
    internal static void RegisterICompositionTarget(Dispatcher dispatcher, ICompositionTarget iv);
    internal static void UnregisterICompositionTarget(Dispatcher dispatcher, ICompositionTarget iv);
    internal void BeginInvokeOnRender(DispatcherOperationCallback callback, object arg);
    [FriendAccessAllowedAttribute]
internal LoadedOrUnloadedOperation AddLoadedOrUnloadedCallback(DispatcherOperationCallback callback, DependencyObject target);
    [FriendAccessAllowedAttribute]
internal void RemoveLoadedOrUnloadedCallback(LoadedOrUnloadedOperation op);
    internal void PostRender();
    internal void Resize(ICompositionTarget resizedCompositionTarget);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void CompleteRender();
    internal void VerifyWriteAccess();
    internal bool get_WriteAccessEnabled();
    internal void PushReadOnlyAccess();
    internal void PopReadOnlyAccess();
    internal TimeManager get_TimeManager();
    internal void add_RenderComplete(EventHandler value);
    internal void remove_RenderComplete(EventHandler value);
    internal void add_ResourcesUpdated(ResourcesUpdatedHandler value);
    internal void remove_ResourcesUpdated(ResourcesUpdatedHandler value);
    internal Channel AllocateSyncChannel();
    internal void ReleaseSyncChannel(Channel channel);
    internal Channel get_Channel();
    internal Channel get_OutOfBandChannel();
    internal bool get_IsConnected();
    internal BoundsDrawingContextWalker AcquireBoundsDrawingContextWalker();
    internal void ReleaseBoundsDrawingContextWalker(BoundsDrawingContextWalker ctx);
    internal ChannelSet GetChannels();
    [CompilerGeneratedAttribute]
internal void add_Rendering(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Rendering(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_CommittingBatch(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CommittingBatch(EventHandler value);
}
internal class System.Windows.Media.MediaContextNotificationWindow : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static MediaContextNotificationWindow();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal MediaContextNotificationWindow(MediaContext ownerMediaContext);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SetAsChannelNotificationWindow();
}
internal class System.Windows.Media.MediaEventsHelper : object {
    internal MediaEventsHelper(MediaPlayer mediaPlayer);
    [SecurityCriticalAttribute]
internal static void CreateMediaEventsHelper(MediaPlayer mediaPlayer, MediaEventsHelper& eventsHelper, SafeMILHandle& unmanagedProxy);
    internal void SetSender(MediaPlayer sender);
    internal void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void add_MediaOpened(EventHandler value);
    internal void remove_MediaOpened(EventHandler value);
    internal void add_MediaPrerolled(EventHandler value);
    internal void remove_MediaPrerolled(EventHandler value);
    internal void add_MediaEnded(EventHandler value);
    internal void remove_MediaEnded(EventHandler value);
    internal void add_BufferingStarted(EventHandler value);
    internal void remove_BufferingStarted(EventHandler value);
    internal void add_BufferingEnded(EventHandler value);
    internal void remove_BufferingEnded(EventHandler value);
    internal void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void add_NewFrame(EventHandler value);
    internal void remove_NewFrame(EventHandler value);
    internal void RaiseMediaFailed(Exception e);
    private sealed virtual override void System.Windows.Media.IInvokable.RaiseEvent(Byte[] buffer, int cb);
}
public class System.Windows.Media.MediaPlayer : Animatable {
    internal ShareableDUCEMultiChannelResource _duceResource;
    public bool IsBuffering { get; }
    public bool CanPause { get; }
    public double DownloadProgress { get; }
    public double BufferingProgress { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public Uri Source { get; }
    public double Volume { get; public set; }
    public double Balance { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public bool IsMuted { get; public set; }
    public Duration NaturalDuration { get; }
    public TimeSpan Position { get; public set; }
    public double SpeedRatio { get; public set; }
    public MediaClock Clock { get; public set; }
    public bool get_IsBuffering();
    public bool get_CanPause();
    public double get_DownloadProgress();
    public double get_BufferingProgress();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public Uri get_Source();
    public double get_Volume();
    public void set_Volume(double value);
    public double get_Balance();
    public void set_Balance(double value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public Duration get_NaturalDuration();
    public void set_Position(TimeSpan value);
    public TimeSpan get_Position();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void add_MediaOpened(EventHandler value);
    public void remove_MediaOpened(EventHandler value);
    public void add_MediaEnded(EventHandler value);
    public void remove_MediaEnded(EventHandler value);
    public void add_BufferingStarted(EventHandler value);
    public void remove_BufferingStarted(EventHandler value);
    public void add_BufferingEnded(EventHandler value);
    public void remove_BufferingEnded(EventHandler value);
    public void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    public void Open(Uri source);
    public void Play();
    public void Pause();
    public void Stop();
    public void Close();
    [SecurityCriticalAttribute]
private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    [SecurityCriticalAttribute]
internal ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected void ReadPreamble();
    protected void WritePreamble();
    internal void SetSpeedRatio(double value);
    internal void SetSource(Uri source);
    internal void SetPosition(TimeSpan value);
}
internal class System.Windows.Media.MediaPlayerState : object {
    internal bool IsBuffering { get; }
    internal bool CanPause { get; }
    internal double DownloadProgress { get; }
    internal double BufferingProgress { get; }
    internal int NaturalVideoHeight { get; }
    internal int NaturalVideoWidth { get; }
    internal bool HasAudio { get; }
    internal bool HasVideo { get; }
    internal Uri Source { get; }
    internal double Volume { get; internal set; }
    internal double Balance { get; internal set; }
    internal bool ScrubbingEnabled { get; internal set; }
    internal bool IsMuted { get; internal set; }
    internal Duration NaturalDuration { get; }
    internal TimeSpan Position { get; internal set; }
    internal double SpeedRatio { get; internal set; }
    internal Dispatcher Dispatcher { get; }
    internal MediaClock Clock { get; }
    internal MediaPlayerState(MediaPlayer mediaPlayer);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
protected virtual override void Finalize();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_IsBuffering();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_CanPause();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal double get_DownloadProgress();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal double get_BufferingProgress();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int get_NaturalVideoHeight();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int get_NaturalVideoWidth();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_HasAudio();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_HasVideo();
    internal Uri get_Source();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal double get_Volume();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set_Volume(double value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal double get_Balance();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_Balance(double value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_ScrubbingEnabled();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void set_ScrubbingEnabled(bool value);
    internal bool get_IsMuted();
    internal void set_IsMuted(bool value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Duration get_NaturalDuration();
    internal void set_Position(TimeSpan value);
    internal TimeSpan get_Position();
    internal double get_SpeedRatio();
    internal void set_SpeedRatio(double value);
    internal Dispatcher get_Dispatcher();
    internal void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void add_MediaOpened(EventHandler value);
    internal void remove_MediaOpened(EventHandler value);
    internal void add_MediaEnded(EventHandler value);
    internal void remove_MediaEnded(EventHandler value);
    internal void add_BufferingStarted(EventHandler value);
    internal void remove_BufferingStarted(EventHandler value);
    internal void add_BufferingEnded(EventHandler value);
    internal void remove_BufferingEnded(EventHandler value);
    internal void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void add_NewFrame(EventHandler value);
    internal void remove_NewFrame(EventHandler value);
    internal MediaClock get_Clock();
    internal void SetClock(MediaClock clock, MediaPlayer player);
    internal void Open(Uri source);
    internal void Play();
    internal void Pause();
    internal void Stop();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Close();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SendCommandMedia(Channel channel, ResourceHandle handle, bool notifyUceDirectly);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void SetPosition(TimeSpan value);
    internal void SetSpeedRatio(double value);
    internal void SetSource(Uri source);
}
public class System.Windows.Media.MediaScriptCommandEventArgs : EventArgs {
    public string ParameterType { get; }
    public string ParameterValue { get; }
    internal MediaScriptCommandEventArgs(string parameterType, string parameterValue);
    public string get_ParameterType();
    public string get_ParameterValue();
}
internal static class System.Windows.Media.MediaSystem : object {
    internal static bool IsTransportConnected { get; internal set; }
    internal static bool ForceSoftwareRendering { get; }
    internal static Channel ServiceChannel { get; }
    internal static IntPtr Connection { get; }
    internal static bool AnimationSmoothing { get; }
    private static MediaSystem();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static bool Startup(MediaContext mc);
    internal static bool ConnectChannels(MediaContext mc);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void Shutdown(MediaContext mc);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void NotifyRedirectionEnvironmentChanged();
    internal static void AssertSameContext(DispatcherObject reference, DispatcherObject other);
    internal static bool get_IsTransportConnected();
    internal static void set_IsTransportConnected(bool value);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static bool get_ForceSoftwareRendering();
    [SecurityCriticalAttribute]
internal static Channel get_ServiceChannel();
    [SecurityCriticalAttribute]
internal static IntPtr get_Connection();
    internal static bool get_AnimationSmoothing();
}
public class System.Windows.Media.MediaTimeline : Timeline {
    public static DependencyProperty SourceProperty;
    internal static Uri s_Source;
    internal static UInt32 LastTimelineFlag;
    internal ITypeDescriptorContext _context;
    public Uri Source { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    private static MediaTimeline();
    public MediaTimeline(Uri source);
    internal MediaTimeline(ITypeDescriptorContext context, Uri source);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    public MediaTimeline Clone();
    public MediaTimeline CloneCurrentValue();
    public Uri get_Source();
    public void set_Source(Uri value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected internal virtual Clock AllocateClock();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public MediaClock CreateClock();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public virtual string ToString();
}
internal class System.Windows.Media.MILCMD_DRAW_DRAWING : ValueType {
    public UInt32 hDrawing;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_DRAWING(UInt32 hDrawing);
}
internal class System.Windows.Media.MILCMD_DRAW_ELLIPSE : ValueType {
    public Point center;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_ELLIPSE(UInt32 hBrush, UInt32 hPen, Point center, double radiusX, double radiusY);
}
internal class System.Windows.Media.MILCMD_DRAW_ELLIPSE_ANIMATE : ValueType {
    public Point center;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hCenterAnimations;
    public UInt32 hRadiusXAnimations;
    public UInt32 hRadiusYAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_ELLIPSE_ANIMATE(UInt32 hBrush, UInt32 hPen, Point center, UInt32 hCenterAnimations, double radiusX, UInt32 hRadiusXAnimations, double radiusY, UInt32 hRadiusYAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_GEOMETRY : ValueType {
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hGeometry;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_GEOMETRY(UInt32 hBrush, UInt32 hPen, UInt32 hGeometry);
}
internal class System.Windows.Media.MILCMD_DRAW_GLYPH_RUN : ValueType {
    public UInt32 hForegroundBrush;
    public UInt32 hGlyphRun;
    public MILCMD_DRAW_GLYPH_RUN(UInt32 hForegroundBrush, UInt32 hGlyphRun);
}
internal class System.Windows.Media.MILCMD_DRAW_IMAGE : ValueType {
    public Rect rectangle;
    public UInt32 hImageSource;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_IMAGE(UInt32 hImageSource, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_IMAGE_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hImageSource;
    public UInt32 hRectangleAnimations;
    public MILCMD_DRAW_IMAGE_ANIMATE(UInt32 hImageSource, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_LINE : ValueType {
    public Point point0;
    public Point point1;
    public UInt32 hPen;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_LINE(UInt32 hPen, Point point0, Point point1);
}
internal class System.Windows.Media.MILCMD_DRAW_LINE_ANIMATE : ValueType {
    public Point point0;
    public Point point1;
    public UInt32 hPen;
    public UInt32 hPoint0Animations;
    public UInt32 hPoint1Animations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_LINE_ANIMATE(UInt32 hPen, Point point0, UInt32 hPoint0Animations, Point point1, UInt32 hPoint1Animations);
}
internal class System.Windows.Media.MILCMD_DRAW_RECTANGLE : ValueType {
    public Rect rectangle;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_RECTANGLE(UInt32 hBrush, UInt32 hPen, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_RECTANGLE_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hRectangleAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_RECTANGLE_ANIMATE(UInt32 hBrush, UInt32 hPen, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_ROUNDED_RECTANGLE : ValueType {
    public Rect rectangle;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_ROUNDED_RECTANGLE(UInt32 hBrush, UInt32 hPen, Rect rectangle, double radiusX, double radiusY);
}
internal class System.Windows.Media.MILCMD_DRAW_ROUNDED_RECTANGLE_ANIMATE : ValueType {
    public Rect rectangle;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hRectangleAnimations;
    public UInt32 hRadiusXAnimations;
    public UInt32 hRadiusYAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_ROUNDED_RECTANGLE_ANIMATE(UInt32 hBrush, UInt32 hPen, Rect rectangle, UInt32 hRectangleAnimations, double radiusX, UInt32 hRadiusXAnimations, double radiusY, UInt32 hRadiusYAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_VIDEO : ValueType {
    public Rect rectangle;
    public UInt32 hPlayer;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_VIDEO(UInt32 hPlayer, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_VIDEO_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hPlayer;
    public UInt32 hRectangleAnimations;
    public MILCMD_DRAW_VIDEO_ANIMATE(UInt32 hPlayer, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_POP : ValueType {
}
internal class System.Windows.Media.MILCMD_PUSH_CLIP : ValueType {
    public UInt32 hClipGeometry;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_CLIP(UInt32 hClipGeometry);
}
internal class System.Windows.Media.MILCMD_PUSH_EFFECT : ValueType {
    public UInt32 hEffect;
    public UInt32 hEffectInput;
    public MILCMD_PUSH_EFFECT(UInt32 hEffect, UInt32 hEffectInput);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_SET : ValueType {
    public UInt32 hGuidelines;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_GUIDELINE_SET(UInt32 hGuidelines);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_Y1 : ValueType {
    public double coordinate;
    public MILCMD_PUSH_GUIDELINE_Y1(double coordinate);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_Y2 : ValueType {
    public double leadingCoordinate;
    public double offsetToDrivenCoordinate;
    public MILCMD_PUSH_GUIDELINE_Y2(double leadingCoordinate, double offsetToDrivenCoordinate);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY : ValueType {
    public double opacity;
    public MILCMD_PUSH_OPACITY(double opacity);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY_ANIMATE : ValueType {
    public double opacity;
    public UInt32 hOpacityAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_OPACITY_ANIMATE(double opacity, UInt32 hOpacityAnimations);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY_MASK : ValueType {
    public MilRectF boundingBoxCacheLocalSpace;
    public UInt32 hOpacityMask;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_OPACITY_MASK(UInt32 hOpacityMask);
}
internal class System.Windows.Media.MILCMD_PUSH_TRANSFORM : ValueType {
    public UInt32 hTransform;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_TRANSFORM(UInt32 hTransform);
}
internal static class System.Windows.Media.MILUtilities : object {
    internal static D3DMATRIX D3DMATRIXIdentity;
    private static MILUtilities();
    [SecurityCriticalAttribute]
internal static void ConvertToD3DMATRIX(Matrix* matrix, D3DMATRIX* d3dMatrix);
    [SecurityCriticalAttribute]
internal static void ConvertFromD3DMATRIX(D3DMATRIX* d3dMatrix, Matrix* matrix);
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static void MILCopyPixelBuffer(Byte* pOutputBuffer, UInt32 outputBufferSize, UInt32 outputBufferStride, UInt32 outputBufferOffsetInBits, Byte* pInputBuffer, UInt32 inputBufferSize, UInt32 inputBufferStride, UInt32 inputBufferOffsetInBits, UInt32 height, UInt32 copyWidthInBits);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Rect ProjectBounds(Matrix3D& viewProjMatrix, Rect3D& originalBox);
}
public enum System.Windows.Media.NumberCultureSource : Enum {
    public int value__;
    public static NumberCultureSource Text;
    public static NumberCultureSource User;
    public static NumberCultureSource Override;
}
public class System.Windows.Media.NumberSubstitution : object {
    public static DependencyProperty CultureSourceProperty;
    public static DependencyProperty CultureOverrideProperty;
    public static DependencyProperty SubstitutionProperty;
    public NumberCultureSource CultureSource { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CultureOverride { get; public set; }
    public NumberSubstitutionMethod Substitution { get; public set; }
    public NumberSubstitution(NumberCultureSource source, CultureInfo cultureOverride, NumberSubstitutionMethod substitution);
    private static NumberSubstitution();
    public NumberCultureSource get_CultureSource();
    public void set_CultureSource(NumberCultureSource value);
    public CultureInfo get_CultureOverride();
    public void set_CultureOverride(CultureInfo value);
    public NumberSubstitutionMethod get_Substitution();
    public void set_Substitution(NumberSubstitutionMethod value);
    public static void SetCultureSource(DependencyObject target, NumberCultureSource value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberCultureSource GetCultureSource(DependencyObject target);
    public static void SetCultureOverride(DependencyObject target, CultureInfo value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public static CultureInfo GetCultureOverride(DependencyObject target);
    public static void SetSubstitution(DependencyObject target, NumberSubstitutionMethod value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberSubstitutionMethod GetSubstitution(DependencyObject target);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum System.Windows.Media.NumberSubstitutionMethod : Enum {
    public int value__;
    public static NumberSubstitutionMethod AsCulture;
    public static NumberSubstitutionMethod Context;
    public static NumberSubstitutionMethod European;
    public static NumberSubstitutionMethod NativeNational;
    public static NumberSubstitutionMethod Traditional;
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Segments")]
public class System.Windows.Media.PathFigure : Animatable {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty IsFilledProperty;
    public static DependencyProperty SegmentsProperty;
    public static DependencyProperty IsClosedProperty;
    internal static Point s_StartPoint;
    internal static bool c_IsFilled;
    internal static PathSegmentCollection s_Segments;
    internal static bool c_IsClosed;
    public Point StartPoint { get; public set; }
    public bool IsFilled { get; public set; }
    public PathSegmentCollection Segments { get; public set; }
    public bool IsClosed { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PathFigure();
    public PathFigure(Point start, IEnumerable`1<PathSegment> segments, bool closed);
    public PathFigure Clone();
    public PathFigure CloneCurrentValue();
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public PathSegmentCollection get_Segments();
    public void set_Segments(PathSegmentCollection value);
    public bool get_IsClosed();
    public void set_IsClosed(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    public PathFigure GetFlattenedPathFigure(double tolerance, ToleranceType type);
    public PathFigure GetFlattenedPathFigure();
    public bool MayHaveCurves();
    internal PathFigure GetTransformedCopy(Matrix matrix);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal bool CanSerializeToString();
    internal string ConvertToString(string format, IFormatProvider provider);
    internal void SerializeData(StreamGeometryContext ctx);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.PathFigureCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PathFigureCollectionValueSerializer")]
public class System.Windows.Media.PathFigureCollection : Animatable {
    internal FrugalStructList`1<PathFigure> _collection;
    internal UInt32 _version;
    public PathFigure Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PathFigureCollection Empty { get; }
    public PathFigureCollection(int capacity);
    public PathFigureCollection(IEnumerable`1<PathFigure> collection);
    public PathFigureCollection Clone();
    public PathFigureCollection CloneCurrentValue();
    public sealed virtual void Add(PathFigure value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathFigure value);
    public sealed virtual int IndexOf(PathFigure value);
    public sealed virtual void Insert(int index, PathFigure value);
    public sealed virtual bool Remove(PathFigure value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual PathFigure get_Item(int index);
    public sealed virtual void set_Item(int index, PathFigure value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(PathFigure[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathFigure> System.Collections.Generic.IEnumerable<System.Windows.Media.PathFigure>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PathFigureCollection get_Empty();
    internal PathFigure Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(PathFigure value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static PathFigureCollection Parse(string source);
    internal bool CanSerializeToString();
}
public class System.Windows.Media.PathFigureCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Figures")]
public class System.Windows.Media.PathGeometry : Geometry {
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty FiguresProperty;
    internal MultiChannelResource _duceResource;
    internal static FillRule c_FillRule;
    internal static PathFigureCollection s_Figures;
    internal PathGeometryInternalFlags _flags;
    internal MilRectD _bounds;
    public FillRule FillRule { get; public set; }
    public PathFigureCollection Figures { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Rect Bounds { get; }
    private static PathGeometry();
    public PathGeometry(IEnumerable`1<PathFigure> figures);
    public PathGeometry(IEnumerable`1<PathFigure> figures, FillRule fillRule, Transform transform);
    public PathGeometry Clone();
    public PathGeometry CloneCurrentValue();
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public PathFigureCollection get_Figures();
    public void set_Figures(PathFigureCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    public static PathGeometry CreateFromGeometry(Geometry geometry);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ParsePathGeometryData(PathGeometryData pathData, CapacityStreamGeometryContext ctx);
    protected virtual void OnChanged();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    public void AddGeometry(Geometry geometry);
    [SecurityCriticalAttribute]
public void GetPointAtFractionLength(double progress, Point& point, Point& tangent);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static PathGeometry InternalCombine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public void Clear();
    public virtual Rect get_Bounds();
    internal static Rect GetPathBounds(PathGeometryData pathData, Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type, bool skipHollows);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static MilRectD GetPathBoundsAsRB(PathGeometryData pathData, Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type, bool skipHollows);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static IntersectionDetail HitTestWithPathGeometry(Geometry geometry1, Geometry geometry2, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal void SetDirty();
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void FiguresPropertyChangedHook(DependencyPropertyChangedEventArgs e);
}
[FlagsAttribute]
internal enum System.Windows.Media.PathGeometryInternalFlags : Enum {
    public int value__;
    public static PathGeometryInternalFlags None;
    public static PathGeometryInternalFlags Invalid;
    public static PathGeometryInternalFlags Dirty;
    public static PathGeometryInternalFlags BoundsValid;
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.PathSegment : Animatable {
    public static DependencyProperty IsStrokedProperty;
    public static DependencyProperty IsSmoothJoinProperty;
    internal static bool c_IsStroked;
    internal static bool c_IsSmoothJoin;
    internal static bool c_isStrokedDefault;
    public bool IsStroked { get; public set; }
    public bool IsSmoothJoin { get; public set; }
    private static PathSegment();
    public PathSegment Clone();
    public PathSegment CloneCurrentValue();
    public bool get_IsStroked();
    public void set_IsStroked(bool value);
    public bool get_IsSmoothJoin();
    public void set_IsSmoothJoin(bool value);
    internal abstract virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal abstract virtual bool IsCurved();
    internal abstract virtual string ConvertToString(string format, IFormatProvider provider);
    internal abstract virtual void SerializeData(StreamGeometryContext ctx);
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.PathSegmentCollection : Animatable {
    internal FrugalStructList`1<PathSegment> _collection;
    internal UInt32 _version;
    public PathSegment Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PathSegmentCollection Empty { get; }
    public PathSegmentCollection(int capacity);
    public PathSegmentCollection(IEnumerable`1<PathSegment> collection);
    public PathSegmentCollection Clone();
    public PathSegmentCollection CloneCurrentValue();
    public sealed virtual void Add(PathSegment value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathSegment value);
    public sealed virtual int IndexOf(PathSegment value);
    public sealed virtual void Insert(int index, PathSegment value);
    public sealed virtual bool Remove(PathSegment value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual PathSegment get_Item(int index);
    public sealed virtual void set_Item(int index, PathSegment value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(PathSegment[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathSegment> System.Collections.Generic.IEnumerable<System.Windows.Media.PathSegment>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PathSegmentCollection get_Empty();
    internal PathSegment Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(PathSegment value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    internal bool CanSerializeToString();
    internal string ConvertToString(string format, IFormatProvider provider);
}
internal class System.Windows.Media.PathStreamGeometryContext : CapacityStreamGeometryContext {
    private static PathStreamGeometryContext();
    internal PathStreamGeometryContext(FillRule fillRule, Transform transform);
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
    internal virtual void SetClosedState(bool isClosed);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    public virtual void Close();
    internal PathGeometry GetPathGeometry();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Pen : Animatable {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ThicknessProperty;
    public static DependencyProperty StartLineCapProperty;
    public static DependencyProperty EndLineCapProperty;
    public static DependencyProperty DashCapProperty;
    public static DependencyProperty LineJoinProperty;
    public static DependencyProperty MiterLimitProperty;
    public static DependencyProperty DashStyleProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Thickness;
    internal static PenLineCap c_StartLineCap;
    internal static PenLineCap c_EndLineCap;
    internal static PenLineCap c_DashCap;
    internal static PenLineJoin c_LineJoin;
    internal static double c_MiterLimit;
    internal static DashStyle s_DashStyle;
    public Brush Brush { get; public set; }
    public double Thickness { get; public set; }
    public PenLineCap StartLineCap { get; public set; }
    public PenLineCap EndLineCap { get; public set; }
    public PenLineCap DashCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    public DashStyle DashStyle { get; public set; }
    internal bool DoesNotContainGaps { get; }
    private static Pen();
    public Pen(Brush brush, double thickness);
    internal Pen(Brush brush, double thickness, PenLineCap startLineCap, PenLineCap endLineCap, PenLineCap dashCap, PenLineJoin lineJoin, double miterLimit, DashStyle dashStyle);
    public Pen Clone();
    public Pen CloneCurrentValue();
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_Thickness();
    public void set_Thickness(double value);
    public PenLineCap get_StartLineCap();
    public void set_StartLineCap(PenLineCap value);
    public PenLineCap get_EndLineCap();
    public void set_EndLineCap(PenLineCap value);
    public PenLineCap get_DashCap();
    public void set_DashCap(PenLineCap value);
    public PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    [SecurityCriticalAttribute]
internal void GetBasicPenData(MIL_PEN_DATA* pData, Double[]& dashArray);
    internal bool get_DoesNotContainGaps();
    internal static bool ContributesToBounds(Pen pen);
}
public enum System.Windows.Media.PenLineCap : Enum {
    public int value__;
    public static PenLineCap Flat;
    public static PenLineCap Square;
    public static PenLineCap Round;
    public static PenLineCap Triangle;
}
public enum System.Windows.Media.PenLineJoin : Enum {
    public int value__;
    public static PenLineJoin Miter;
    public static PenLineJoin Bevel;
    public static PenLineJoin Round;
}
[TypeConverterAttribute("System.Windows.Media.PixelFormatConverter")]
public class System.Windows.Media.PixelFormat : ValueType {
    private PixelFormatFlags _flags;
    private PixelFormatEnum _format;
    private UInt32 _bitsPerPixel;
    private SecurityCriticalDataForSet`1<Guid> _guidFormat;
    public int BitsPerPixel { get; }
    public IList`1<PixelFormatChannelMask> Masks { get; }
    internal int InternalBitsPerPixel { get; }
    internal bool HasAlpha { get; }
    internal bool Palettized { get; }
    internal PixelFormatEnum Format { get; }
    internal Guid Guid { get; }
    [SecurityCriticalAttribute]
internal PixelFormat(Guid guidPixelFormat);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal PixelFormat(PixelFormatEnum format);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal PixelFormat(string pixelFormatString);
    private static PixelFormat();
    public static bool op_Equality(PixelFormat left, PixelFormat right);
    public static bool op_Inequality(PixelFormat left, PixelFormat right);
    public static bool Equals(PixelFormat left, PixelFormat right);
    public sealed virtual bool Equals(PixelFormat pixelFormat);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int get_BitsPerPixel();
    [SecurityCriticalAttribute]
public IList`1<PixelFormatChannelMask> get_Masks();
    [SecurityCriticalAttribute]
internal IntPtr CreatePixelFormatInfo();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int get_InternalBitsPerPixel();
    internal bool get_HasAlpha();
    internal bool get_Palettized();
    internal PixelFormatEnum get_Format();
    internal Guid get_Guid();
    public virtual string ToString();
    [SecurityCriticalAttribute]
internal static PixelFormat GetPixelFormat(SafeMILHandle bitmapSource);
    internal static PixelFormat GetPixelFormat(Guid pixelFormatGuid);
    internal static PixelFormat GetPixelFormat(PixelFormatEnum pixelFormatEnum);
}
public class System.Windows.Media.PixelFormatChannelMask : ValueType {
    private Byte[] _mask;
    public IList`1<byte> Mask { get; }
    internal PixelFormatChannelMask(Byte[] mask);
    public IList`1<byte> get_Mask();
    public static bool op_Equality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool Equals(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool op_Inequality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.PixelFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object o);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[FlagsAttribute]
internal enum System.Windows.Media.PixelFormatFlags : Enum {
    public int value__;
    public static PixelFormatFlags BitsPerPixelMask;
    public static PixelFormatFlags BitsPerPixelUndefined;
    public static PixelFormatFlags BitsPerPixel1;
    public static PixelFormatFlags BitsPerPixel2;
    public static PixelFormatFlags BitsPerPixel4;
    public static PixelFormatFlags BitsPerPixel8;
    public static PixelFormatFlags BitsPerPixel16;
    public static PixelFormatFlags BitsPerPixel24;
    public static PixelFormatFlags BitsPerPixel32;
    public static PixelFormatFlags BitsPerPixel48;
    public static PixelFormatFlags BitsPerPixel64;
    public static PixelFormatFlags BitsPerPixel96;
    public static PixelFormatFlags BitsPerPixel128;
    public static PixelFormatFlags IsGray;
    public static PixelFormatFlags IsCMYK;
    public static PixelFormatFlags IsSRGB;
    public static PixelFormatFlags IsScRGB;
    public static PixelFormatFlags Premultiplied;
    public static PixelFormatFlags ChannelOrderMask;
    public static PixelFormatFlags ChannelOrderRGB;
    public static PixelFormatFlags ChannelOrderBGR;
    public static PixelFormatFlags ChannelOrderARGB;
    public static PixelFormatFlags ChannelOrderABGR;
    public static PixelFormatFlags Palettized;
    public static PixelFormatFlags NChannelAlpha;
    public static PixelFormatFlags IsNChannel;
}
public static class System.Windows.Media.PixelFormats : object {
    public static PixelFormat Default { get; }
    public static PixelFormat Indexed1 { get; }
    public static PixelFormat Indexed2 { get; }
    public static PixelFormat Indexed4 { get; }
    public static PixelFormat Indexed8 { get; }
    public static PixelFormat BlackWhite { get; }
    public static PixelFormat Gray2 { get; }
    public static PixelFormat Gray4 { get; }
    public static PixelFormat Gray8 { get; }
    public static PixelFormat Bgr555 { get; }
    public static PixelFormat Bgr565 { get; }
    public static PixelFormat Rgb128Float { get; }
    public static PixelFormat Bgr24 { get; }
    public static PixelFormat Rgb24 { get; }
    public static PixelFormat Bgr101010 { get; }
    public static PixelFormat Bgr32 { get; }
    public static PixelFormat Bgra32 { get; }
    public static PixelFormat Pbgra32 { get; }
    public static PixelFormat Rgb48 { get; }
    public static PixelFormat Rgba64 { get; }
    public static PixelFormat Prgba64 { get; }
    public static PixelFormat Gray16 { get; }
    public static PixelFormat Gray32Float { get; }
    public static PixelFormat Rgba128Float { get; }
    public static PixelFormat Prgba128Float { get; }
    public static PixelFormat Cmyk32 { get; }
    public static PixelFormat get_Default();
    public static PixelFormat get_Indexed1();
    public static PixelFormat get_Indexed2();
    public static PixelFormat get_Indexed4();
    public static PixelFormat get_Indexed8();
    public static PixelFormat get_BlackWhite();
    public static PixelFormat get_Gray2();
    public static PixelFormat get_Gray4();
    public static PixelFormat get_Gray8();
    public static PixelFormat get_Bgr555();
    public static PixelFormat get_Bgr565();
    public static PixelFormat get_Rgb128Float();
    public static PixelFormat get_Bgr24();
    public static PixelFormat get_Rgb24();
    public static PixelFormat get_Bgr101010();
    public static PixelFormat get_Bgr32();
    public static PixelFormat get_Bgra32();
    public static PixelFormat get_Pbgra32();
    public static PixelFormat get_Rgb48();
    public static PixelFormat get_Rgba64();
    public static PixelFormat get_Prgba64();
    public static PixelFormat get_Gray16();
    public static PixelFormat get_Gray32Float();
    public static PixelFormat get_Rgba128Float();
    public static PixelFormat get_Prgba128Float();
    public static PixelFormat get_Cmyk32();
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.PointCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PointCollectionValueSerializer")]
public class System.Windows.Media.PointCollection : Freezable {
    internal FrugalStructList`1<Point> _collection;
    internal UInt32 _version;
    public Point Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Point>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PointCollection Empty { get; }
    public PointCollection(int capacity);
    public PointCollection(IEnumerable`1<Point> collection);
    public PointCollection Clone();
    public PointCollection CloneCurrentValue();
    public sealed virtual void Add(Point value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point value);
    public sealed virtual int IndexOf(Point value);
    public sealed virtual void Insert(int index, Point value);
    public sealed virtual bool Remove(Point value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Point[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Point>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point> System.Collections.Generic.IEnumerable<System.Windows.Point>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PointCollection get_Empty();
    internal Point Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(Point value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static PointCollection Parse(string source);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
}
public class System.Windows.Media.PointCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.PointHitTestParameters : HitTestParameters {
    public Point HitPoint { get; }
    public PointHitTestParameters(Point point);
    public Point get_HitPoint();
    internal void SetHitPoint(Point hitPoint);
}
public class System.Windows.Media.PointHitTestResult : HitTestResult {
    public Point PointHit { get; }
    public Visual VisualHit { get; }
    public PointHitTestResult(Visual visualHit, Point pointHit);
    public Point get_PointHit();
    public Visual get_VisualHit();
}
public class System.Windows.Media.PolyBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyBezierSegment();
    public PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    public PolyBezierSegment Clone();
    public PolyBezierSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.PolyLineSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyLineSegment();
    public PolyLineSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyLineSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    public PolyLineSegment Clone();
    public PolyLineSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.PolyQuadraticBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyQuadraticBezierSegment();
    public PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    public PolyQuadraticBezierSegment Clone();
    public PolyQuadraticBezierSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.QuadraticBezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    internal static Point s_Point1;
    internal static Point s_Point2;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    private static QuadraticBezierSegment();
    public QuadraticBezierSegment(Point point1, Point point2, bool isStroked);
    internal QuadraticBezierSegment(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public QuadraticBezierSegment Clone();
    public QuadraticBezierSegment CloneCurrentValue();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.RadialGradientBrush : GradientBrush {
    public static DependencyProperty CenterProperty;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty GradientOriginProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_Center;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Point s_GradientOrigin;
    public Point Center { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point GradientOrigin { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static RadialGradientBrush();
    public RadialGradientBrush(Color startColor, Color endColor);
    public RadialGradientBrush(GradientStopCollection gradientStopCollection);
    public RadialGradientBrush Clone();
    public RadialGradientBrush CloneCurrentValue();
    public Point get_Center();
    public void set_Center(Point value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_GradientOrigin();
    public void set_GradientOrigin(Point value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.RectangleGeometry : Geometry {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Rect s_Rect;
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Rect Rect { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Rect Bounds { get; }
    private static RectangleGeometry();
    public RectangleGeometry(Rect rect);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY, Transform transform);
    public RectangleGeometry Clone();
    public RectangleGeometry CloneCurrentValue();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    public virtual Rect get_Bounds();
    internal virtual bool AreClose(Geometry geometry);
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Rect rect, double radiusX, double radiusY, Matrix geometryMatrix, double tolerance, ToleranceType type);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal static bool IsRounded(double radiusX, double radiusY);
    internal bool IsRounded();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathGeometryData GetPathGeometryData();
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
}
public static class System.Windows.Media.RenderCapability : object {
    public static int Tier { get; }
    [ObsoleteAttribute("IsShaderEffectSoftwareRenderingSupported property is deprecated.  Use IsPixelShaderVersionSupportedInSoftware static method instead.")]
public static bool IsShaderEffectSoftwareRenderingSupported { get; }
    public static Size MaxHardwareTextureSize { get; }
    public static int get_Tier();
    public static bool IsPixelShaderVersionSupported(short majorVersionRequested, short minorVersionRequested);
    public static bool IsPixelShaderVersionSupportedInSoftware(short majorVersionRequested, short minorVersionRequested);
    public static bool get_IsShaderEffectSoftwareRenderingSupported();
    public static int MaxPixelShaderInstructionSlots(short majorVersionRequested, short minorVersionRequested);
    public static Size get_MaxHardwareTextureSize();
    public static void add_TierChanged(EventHandler value);
    public static void remove_TierChanged(EventHandler value);
}
internal class System.Windows.Media.RenderContext : object {
    internal Channel Channel { get; }
    internal ResourceHandle Root { get; }
    internal Channel get_Channel();
    internal ResourceHandle get_Root();
    internal void Initialize(Channel channel, ResourceHandle root);
}
internal class System.Windows.Media.RenderData : Freezable {
    internal int BitmapEffectStackDepth { get; internal set; }
    public int DataSize { get; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public void DrawingContextWalk(DrawingContextWalker ctx);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public void BaseValueDrawingContextWalk(DrawingContextWalker ctx);
    [SecurityCriticalAttribute]
public void WriteDataRecord(MILCMD id, Byte* pbRecord, int cbRecordSize);
    public sealed virtual Rect GetContentBounds(BoundsDrawingContextWalker ctx);
    public sealed virtual void WalkContent(DrawingContextWalker walker);
    public sealed virtual bool HitTestPoint(Point point);
    public sealed virtual IntersectionDetail HitTestGeometry(PathGeometry geometry);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public sealed virtual void PropagateChangedHandler(EventHandler handler, bool adding);
    internal int get_BitmapEffectStackDepth();
    internal void set_BitmapEffectStackDepth(int value);
    internal void BeginTopLevelBitmapEffect(int stackDepth);
    internal void EndTopLevelBitmapEffect();
    public int get_DataSize();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    public UInt32 AddDependentResource(object o);
}
internal class System.Windows.Media.RenderDataDrawingContext : DrawingContext {
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawLine(Pen pen, Point point0, Point point1);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawDrawing(Drawing drawing);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void PushClip(Geometry clipGeometry);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void PushOpacityMask(Brush opacityMask);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void PushOpacity(double opacity);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void PushTransform(Transform transform);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void PushGuidelineSet(GuidelineSet guidelines);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void PushGuidelineY1(double coordinate);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
public virtual void Pop();
    internal RenderData GetRenderData();
    public virtual void Close();
    protected virtual void DisposeCore();
    protected virtual void CloseCore(RenderData renderData);
    protected virtual void VerifyApiNonstructuralChange();
}
internal static class System.Windows.Media.Renderer : object {
    [SecurityCriticalAttribute]
public static void Render(IntPtr pRenderTarget, Channel channel, Visual visual, int width, int height, double dpiX, double dpiY);
    [SecurityCriticalAttribute]
internal static void Render(IntPtr pRenderTarget, Channel channel, Visual visual, int width, int height, double dpiX, double dpiY, Matrix worldTransform, Rect windowClip);
}
public class System.Windows.Media.RenderingEventArgs : EventArgs {
    public TimeSpan RenderingTime { get; }
    internal RenderingEventArgs(TimeSpan renderingTime);
    public TimeSpan get_RenderingTime();
}
public static class System.Windows.Media.RenderOptions : object {
    public static DependencyProperty EdgeModeProperty;
    public static DependencyProperty BitmapScalingModeProperty;
    public static DependencyProperty ClearTypeHintProperty;
    public static DependencyProperty CachingHintProperty;
    public static DependencyProperty CacheInvalidationThresholdMinimumProperty;
    public static DependencyProperty CacheInvalidationThresholdMaximumProperty;
    public static RenderMode ProcessRenderMode { get; public set; }
    private static RenderOptions();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static EdgeMode GetEdgeMode(DependencyObject target);
    public static void SetEdgeMode(DependencyObject target, EdgeMode edgeMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static BitmapScalingMode GetBitmapScalingMode(DependencyObject target);
    public static void SetBitmapScalingMode(DependencyObject target, BitmapScalingMode bitmapScalingMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ClearTypeHint GetClearTypeHint(DependencyObject target);
    public static void SetClearTypeHint(DependencyObject target, ClearTypeHint clearTypeHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static CachingHint GetCachingHint(DependencyObject target);
    public static void SetCachingHint(DependencyObject target, CachingHint cachingHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMinimum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMinimum(DependencyObject target, double cacheInvalidationThresholdMinimum);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMaximum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMaximum(DependencyObject target, double cacheInvalidationThresholdMaximum);
    [SecurityCriticalAttribute]
public static RenderMode get_ProcessRenderMode();
    [SecurityCriticalAttribute]
public static void set_ProcessRenderMode(RenderMode value);
}
public class System.Windows.Media.RequestCachePolicyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.RotateTransform : Transform {
    public static DependencyProperty AngleProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Angle;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public double Angle { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static RotateTransform();
    public RotateTransform(double angle);
    public RotateTransform(double angle, double centerX, double centerY);
    public RotateTransform Clone();
    public RotateTransform CloneCurrentValue();
    public double get_Angle();
    public void set_Angle(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
}
internal class System.Windows.Media.SafeMediaHandle : SafeMILHandle {
    [SecurityCriticalAttribute]
internal SafeMediaHandle(IntPtr handle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeMILHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal SafeMILHandle(IntPtr handle);
    [SecurityCriticalAttribute]
internal void UpdateEstimatedSize(long estimatedSize);
    internal void CopyMemoryPressure(SafeMILHandle original);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeMILHandleMemoryPressure : object {
    [SecurityCriticalAttribute]
internal SafeMILHandleMemoryPressure(long gcPressure);
    internal void AddRef();
    [SecurityCriticalAttribute]
internal void Release();
}
internal class System.Windows.Media.SafeProfileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal SafeProfileHandle(IntPtr profile);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeReversePInvokeWrapper : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
internal SafeReversePInvokeWrapper(IntPtr delegatePtr);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
public class System.Windows.Media.ScaleTransform : Transform {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_ScaleX;
    internal static double c_ScaleY;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static ScaleTransform();
    public ScaleTransform(double scaleX, double scaleY);
    public ScaleTransform(double scaleX, double scaleY, double centerX, double centerY);
    public ScaleTransform Clone();
    public ScaleTransform CloneCurrentValue();
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
}
public class System.Windows.Media.SkewTransform : Transform {
    public static DependencyProperty AngleXProperty;
    public static DependencyProperty AngleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_AngleX;
    internal static double c_AngleY;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static SkewTransform();
    public SkewTransform(double angleX, double angleY);
    public SkewTransform(double angleX, double angleY, double centerX, double centerY);
    public SkewTransform Clone();
    public SkewTransform CloneCurrentValue();
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
}
public class System.Windows.Media.SolidColorBrush : Brush {
    public static DependencyProperty ColorProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    public Color Color { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static SolidColorBrush();
    public SolidColorBrush(Color color);
    public SolidColorBrush Clone();
    public SolidColorBrush CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    [FriendAccessAllowedAttribute]
internal static bool SerializeOn(BinaryWriter writer, string stringValue);
    public static object DeserializeFrom(BinaryReader reader);
    internal static object DeserializeFrom(BinaryReader reader, ITypeDescriptorContext context);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
internal static class System.Windows.Media.StaticPtrs : object {
    internal static Dispose pfnDispose;
    internal static Read pfnRead;
    [SecurityCriticalAttribute]
internal static Seek pfnSeek;
    internal static Stat pfnStat;
    internal static Write pfnWrite;
    [SecurityCriticalAttribute]
internal static CopyTo pfnCopyTo;
    internal static SetSize pfnSetSize;
    internal static Commit pfnCommit;
    internal static Revert pfnRevert;
    internal static LockRegion pfnLockRegion;
    internal static UnlockRegion pfnUnlockRegion;
    internal static Clone pfnClone;
    internal static CanWrite pfnCanWrite;
    internal static CanSeek pfnCanSeek;
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static StaticPtrs();
}
internal class System.Windows.Media.StreamAsIStream : object {
    protected Stream dataStream;
    public int Clone(IntPtr& stream);
    public int Commit(UInt32 grfCommitFlags);
    [SecurityCriticalAttribute]
public int CopyTo(IntPtr pstm, long cb, Int64& cbRead, Int64& cbWritten);
    public int LockRegion(long libOffset, long cb, UInt32 dwLockType);
    public int Read(Byte[] buffer, UInt32 cb, UInt32& cbRead);
    public int Revert();
    [SecurityCriticalAttribute]
public int Seek(long offset, UInt32 origin, Int64* plibNewPostion);
    public int SetSize(long value);
    public int Stat(STATSTG& statstg, UInt32 grfStatFlag);
    public int UnlockRegion(long libOffset, long cb, UInt32 dwLockType);
    public int Write(Byte[] buffer, UInt32 cb, UInt32& cbWritten);
    public int CanWrite(Boolean& canWrite);
    public int CanSeek(Boolean& canSeek);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static StreamAsIStream FromSD(StreamDescriptor& sd);
    internal static int Clone(StreamDescriptor& pSD, IntPtr& stream);
    internal static int Commit(StreamDescriptor& pSD, UInt32 grfCommitFlags);
    [SecurityCriticalAttribute]
internal static int CopyTo(StreamDescriptor& pSD, IntPtr pstm, long cb, Int64& cbRead, Int64& cbWritten);
    internal static int LockRegion(StreamDescriptor& pSD, long libOffset, long cb, UInt32 dwLockType);
    internal static int Read(StreamDescriptor& pSD, Byte[] buffer, UInt32 cb, UInt32& cbRead);
    internal static int Revert(StreamDescriptor& pSD);
    [SecurityCriticalAttribute]
internal static int Seek(StreamDescriptor& pSD, long offset, UInt32 origin, Int64* plibNewPostion);
    internal static int SetSize(StreamDescriptor& pSD, long value);
    internal static int Stat(StreamDescriptor& pSD, STATSTG& statstg, UInt32 grfStatFlag);
    internal static int UnlockRegion(StreamDescriptor& pSD, long libOffset, long cb, UInt32 dwLockType);
    internal static int Write(StreamDescriptor& pSD, Byte[] buffer, UInt32 cb, UInt32& cbWritten);
    internal static int CanWrite(StreamDescriptor& pSD, Boolean& canWrite);
    internal static int CanSeek(StreamDescriptor& pSD, Boolean& canSeek);
    [SecurityCriticalAttribute]
internal static IntPtr IStreamMemoryFrom(IntPtr comStream);
    [SecurityCriticalAttribute]
internal static IntPtr IStreamFrom(IntPtr memoryBuffer, int bufferSize);
    [SecurityCriticalAttribute]
internal static IntPtr IStreamFrom(Stream stream);
}
internal class System.Windows.Media.StreamDescriptor : ValueType {
    internal Dispose pfnDispose;
    internal Read pfnRead;
    [SecurityCriticalAttribute]
internal Seek pfnSeek;
    internal Stat pfnStat;
    internal Write pfnWrite;
    [SecurityCriticalAttribute]
internal CopyTo pfnCopyTo;
    internal SetSize pfnSetSize;
    internal Commit pfnCommit;
    internal Revert pfnRevert;
    internal LockRegion pfnLockRegion;
    internal UnlockRegion pfnUnlockRegion;
    internal Clone pfnClone;
    internal CanWrite pfnCanWrite;
    internal CanSeek pfnCanSeek;
    internal GCHandle m_handle;
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void StaticDispose(StreamDescriptor& pSD);
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
public class System.Windows.Media.StreamGeometry : Geometry {
    public static DependencyProperty FillRuleProperty;
    internal static FillRule c_FillRule;
    internal MultiChannelResource _duceResource;
    public FillRule FillRule { get; public set; }
    public Rect Bounds { get; }
    private static StreamGeometry();
    public StreamGeometry Clone();
    public StreamGeometry CloneCurrentValue();
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Freezable CreateInstanceCore();
    public StreamGeometryContext Open();
    public void Clear();
    [SecurityCriticalAttribute]
public virtual bool IsEmpty();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void SetDirty();
    public virtual Rect get_Bounds();
    [SecurityCriticalAttribute]
public virtual bool MayHaveCurves();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool HasHollows();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool HasGaps();
    internal void Close(Byte[] _buffer);
    protected virtual void OnChanged();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
internal class System.Windows.Media.StreamGeometryCallbackContext : ByteStreamGeometryContext {
    internal StreamGeometryCallbackContext(StreamGeometry owner);
    protected virtual void CloseCore(Byte[] data);
}
public abstract class System.Windows.Media.StreamGeometryContext : DispatcherObject {
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
    public abstract virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public abstract virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public abstract virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public abstract virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal virtual void DisposeCore();
    internal abstract virtual void SetClosedState(bool closed);
}
public enum System.Windows.Media.Stretch : Enum {
    public int value__;
    public static Stretch None;
    public static Stretch Fill;
    public static Stretch Uniform;
    public static Stretch UniformToFill;
}
[FlagsAttribute]
public enum System.Windows.Media.StyleSimulations : Enum {
    public int value__;
    public static StyleSimulations None;
    public static StyleSimulations BoldSimulation;
    public static StyleSimulations ItalicSimulation;
    public static StyleSimulations BoldItalicSimulation;
}
public enum System.Windows.Media.SweepDirection : Enum {
    public int value__;
    public static SweepDirection Counterclockwise;
    public static SweepDirection Clockwise;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffect : Animatable {
    public static DependencyProperty TransformProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty PositionStartProperty;
    public static DependencyProperty PositionCountProperty;
    internal static int c_PositionStart;
    internal static int c_PositionCount;
    public Transform Transform { get; public set; }
    public Geometry Clip { get; public set; }
    public Brush Foreground { get; public set; }
    public int PositionStart { get; public set; }
    public int PositionCount { get; public set; }
    private static TextEffect();
    public TextEffect(Transform transform, Brush foreground, Geometry clip, int positionStart, int positionCount);
    public TextEffect Clone();
    public TextEffect CloneCurrentValue();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public int get_PositionStart();
    public void set_PositionStart(int value);
    public int get_PositionCount();
    public void set_PositionCount(int value);
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TextEffectCollection : Animatable {
    internal FrugalStructList`1<TextEffect> _collection;
    internal UInt32 _version;
    public TextEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TextEffectCollection Empty { get; }
    public TextEffectCollection(int capacity);
    public TextEffectCollection(IEnumerable`1<TextEffect> collection);
    public TextEffectCollection Clone();
    public TextEffectCollection CloneCurrentValue();
    public sealed virtual void Add(TextEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextEffect value);
    public sealed virtual int IndexOf(TextEffect value);
    public sealed virtual void Insert(int index, TextEffect value);
    public sealed virtual bool Remove(TextEffect value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual TextEffect get_Item(int index);
    public sealed virtual void set_Item(int index, TextEffect value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(TextEffect[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.TextEffect>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TextEffectCollection get_Empty();
    internal TextEffect Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(TextEffect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
internal enum System.Windows.Media.TextFormatting.BreakStrategies : Enum {
    public int value__;
    public static BreakStrategies BreakCJK;
    public static BreakStrategies KeepCJK;
    public static BreakStrategies Max;
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TextFormatting.CharacterBufferRange : ValueType {
    private CharacterBufferReference _charBufferRef;
    private int _length;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public static CharacterBufferRange Empty { get; }
    internal bool IsEmpty { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    internal char Item { get; }
    public CharacterBufferRange(Char[] characterArray, int offsetToFirstChar, int characterLength);
    public CharacterBufferRange(string characterString, int offsetToFirstChar, int characterLength);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public CharacterBufferRange(Char* unsafeCharacterString, int characterLength);
    internal CharacterBufferRange(CharacterBufferReference characterBufferReference, int characterLength);
    internal CharacterBufferRange(CharacterBufferRange characterBufferRange, int offsetToFirstChar, int characterLength);
    internal CharacterBufferRange(string charString);
    internal CharacterBufferRange(CharacterBuffer charBuffer, int offsetToFirstChar, int characterLength);
    internal CharacterBufferRange(TextRun textRun);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferRange value);
    public static bool op_Equality(CharacterBufferRange left, CharacterBufferRange right);
    public static bool op_Inequality(CharacterBufferRange left, CharacterBufferRange right);
    public CharacterBufferReference get_CharacterBufferReference();
    public int get_Length();
    public static CharacterBufferRange get_Empty();
    internal bool get_IsEmpty();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
    internal char get_Item(int index);
}
public class System.Windows.Media.TextFormatting.CharacterBufferReference : ValueType {
    private CharacterBuffer _charBuffer;
    private int _offsetToFirstChar;
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    public CharacterBufferReference(Char[] characterArray, int offsetToFirstChar);
    public CharacterBufferReference(string characterString, int offsetToFirstChar);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public CharacterBufferReference(Char* unsafeCharacterString, int characterLength);
    internal CharacterBufferReference(CharacterBuffer charBuffer, int offsetToFirstChar);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferReference value);
    public static bool op_Equality(CharacterBufferReference left, CharacterBufferReference right);
    public static bool op_Inequality(CharacterBufferReference left, CharacterBufferReference right);
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
}
public class System.Windows.Media.TextFormatting.CharacterHit : ValueType {
    private int _firstCharacterIndex;
    private int _trailingLength;
    public int FirstCharacterIndex { get; }
    public int TrailingLength { get; }
    public CharacterHit(int firstCharacterIndex, int trailingLength);
    public int get_FirstCharacterIndex();
    public int get_TrailingLength();
    public static bool op_Equality(CharacterHit left, CharacterHit right);
    public static bool op_Inequality(CharacterHit left, CharacterHit right);
    public sealed virtual bool Equals(CharacterHit obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.TextFormatting.CultureSpecificCharacterBufferRange : object {
    public CultureInfo CultureInfo { get; }
    public CharacterBufferRange CharacterBufferRange { get; }
    public CultureSpecificCharacterBufferRange(CultureInfo culture, CharacterBufferRange characterBufferRange);
    public CultureInfo get_CultureInfo();
    public CharacterBufferRange get_CharacterBufferRange();
}
public class System.Windows.Media.TextFormatting.IndexedGlyphRun : object {
    public int TextSourceCharacterIndex { get; }
    public int TextSourceLength { get; }
    public GlyphRun GlyphRun { get; }
    internal IndexedGlyphRun(int textSourceCharacterIndex, int textSourceCharacterLength, GlyphRun glyphRun);
    public int get_TextSourceCharacterIndex();
    public int get_TextSourceLength();
    public GlyphRun get_GlyphRun();
}
[FlagsAttribute]
public enum System.Windows.Media.TextFormatting.InvertAxes : Enum {
    public int value__;
    public static InvertAxes None;
    public static InvertAxes Horizontal;
    public static InvertAxes Vertical;
    public static InvertAxes Both;
}
public class System.Windows.Media.TextFormatting.MinMaxParagraphWidth : ValueType {
    private double _minWidth;
    private double _maxWidth;
    public double MinWidth { get; }
    public double MaxWidth { get; }
    internal MinMaxParagraphWidth(double minWidth, double maxWidth);
    public double get_MinWidth();
    public double get_MaxWidth();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MinMaxParagraphWidth value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
    public static bool op_Inequality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
}
public class System.Windows.Media.TextFormatting.TextBounds : object {
    public Rect Rectangle { get; }
    public IList`1<TextRunBounds> TextRunBounds { get; }
    public FlowDirection FlowDirection { get; }
    internal TextBounds(Rect bounds, FlowDirection flowDirection, IList`1<TextRunBounds> runBounds);
    public Rect get_Rectangle();
    public IList`1<TextRunBounds> get_TextRunBounds();
    public FlowDirection get_FlowDirection();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextBreakpoint : object {
    public bool IsTruncated { get; }
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual TextLineBreak GetTextLineBreak();
    [SecurityCriticalAttribute]
internal abstract virtual SecurityCriticalDataForSet`1<IntPtr> GetTextPenaltyResource();
    public abstract virtual bool get_IsTruncated();
    public abstract virtual int get_Length();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_TextHeight();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
}
public class System.Windows.Media.TextFormatting.TextCharacters : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextCharacters(Char[] characterArray, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public TextCharacters(Char* unsafeCharacterString, int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    private sealed virtual override IList`1<TextShapeableSymbols> MS.Internal.TextFormatting.ITextSymbols.GetTextShapeableSymbols(GlyphingCache glyphingCache, CharacterBufferReference characterBufferReference, int length, bool rightToLeft, bool isRightToLeftParagraph, CultureInfo digitCulture, TextModifierScope textModifierScope, TextFormattingMode textFormattingMode, bool isSideways);
    private sealed virtual override void MS.Internal.TextFormatting.IShapeableTextCollector.Add(IList`1<TextShapeableSymbols> shapeables, CharacterBufferRange characterBufferRange, TextRunProperties textRunProperties, ItemProps textItem, ShapeTypeface shapeTypeface, double emScale, bool nullShape, TextFormattingMode textFormattingMode);
}
public class System.Windows.Media.TextFormatting.TextCollapsedRange : object {
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public double Width { get; }
    internal TextCollapsedRange(int cp, int length, double width);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public double get_Width();
}
public abstract class System.Windows.Media.TextFormatting.TextCollapsingProperties : object {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public abstract virtual double get_Width();
    public abstract virtual TextRun get_Symbol();
    public abstract virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextFormatting.TextCollapsingStyle : Enum {
    public int value__;
    public static TextCollapsingStyle TrailingCharacter;
    public static TextCollapsingStyle TrailingWord;
}
public abstract class System.Windows.Media.TextFormatting.TextEmbeddedObject : TextRun {
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    public abstract virtual LineBreakCondition get_BreakBefore();
    public abstract virtual LineBreakCondition get_BreakAfter();
    public abstract virtual bool get_HasFixedSize();
    public abstract virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public abstract virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
}
public class System.Windows.Media.TextFormatting.TextEmbeddedObjectMetrics : object {
    public double Width { get; }
    public double Height { get; }
    public double Baseline { get; }
    public TextEmbeddedObjectMetrics(double width, double height, double baseline);
    public double get_Width();
    public double get_Height();
    public double get_Baseline();
}
public class System.Windows.Media.TextFormatting.TextEndOfLine : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfLine(int length);
    public TextEndOfLine(int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextEndOfParagraph : TextEndOfLine {
    public TextEndOfParagraph(int length);
    public TextEndOfParagraph(int length, TextRunProperties textRunProperties);
}
public class System.Windows.Media.TextFormatting.TextEndOfSegment : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfSegment(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextFormatter : object {
    private static TextFormatter();
    public static TextFormatter Create(TextFormattingMode textFormattingMode);
    public static TextFormatter Create();
    [FriendAccessAllowedAttribute]
internal static TextFormatter CreateFromContext(TextFormatterContext soleContext);
    [FriendAccessAllowedAttribute]
internal static TextFormatter CreateFromContext(TextFormatterContext soleContext, TextFormattingMode textFormattingMode);
    [FriendAccessAllowedAttribute]
internal static TextFormatter FromCurrentDispatcher();
    [FriendAccessAllowedAttribute]
internal static TextFormatter FromCurrentDispatcher(TextFormattingMode textFormattingMode);
    public virtual void Dispose();
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    [FriendAccessAllowedAttribute]
internal abstract virtual TextLine RecreateLine(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    [FriendAccessAllowedAttribute]
internal abstract virtual TextParagraphCache CreateParagraphCache(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.TextFormatting.TextFormatterContext : object {
    internal object Owner { get; internal set; }
    internal Exception CallbackException { get; internal set; }
    internal Rect BoundingBox { get; }
    internal ICollection`1<IndexedGlyphRun> IndexedGlyphRuns { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> Ploc { get; }
    internal TextPenaltyModule GetTextPenaltyModule();
    [SecurityCriticalAttribute]
internal void Release();
    [SecurityCriticalAttribute]
internal object get_Owner();
    [SecurityCriticalAttribute]
internal void set_Owner(object value);
    [SecurityCriticalAttribute]
internal Exception get_CallbackException();
    [SecurityCriticalAttribute]
internal void set_CallbackException(Exception value);
    internal void EmptyBoundingBox();
    internal Rect get_BoundingBox();
    internal void ClearIndexedGlyphRuns();
    internal ICollection`1<IndexedGlyphRun> get_IndexedGlyphRuns();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Destroy();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SetBreaking(BreakStrategies breaking);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal LsErr CreateLine(int cpFirst, int lineLength, int maxWidth, LineFlags lineFlags, IntPtr previousLineBreakRecord, IntPtr& ploline, LsLInfo& plslineInfo, Int32& maxDepth, LsLineWidths& lineWidths);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal LsErr CreateBreaks(int cpFirst, IntPtr previousLineBreakRecord, IntPtr ploparabreak, IntPtr ptslinevariantRestriction, LsBreaks& lsbreaks, Int32& bestFitIndex);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal LsErr CreateParaBreakingSession(int cpFirst, int maxWidth, IntPtr previousLineBreakRecord, IntPtr& ploparabreak, Boolean& penalizedAsJustified);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void SetDoc(bool isDisplay, bool isReferencePresentationEqual, LsDevRes& deviceInfo);
    [SecurityCriticalAttribute]
internal void SetTabs(int incrementalTab, LsTbd* tabStops, int tabStopCount);
    internal static void ThrowExceptionFromLsError(string message, LsErr lserr);
    internal static bool IsSpecialCharacter(char c);
    internal SecurityCriticalDataForSet`1<IntPtr> get_Ploc();
}
public class System.Windows.Media.TextFormatting.TextHidden : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextHidden(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextLexicalBreaks : object {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual int GetNextBreak(int currentIndex);
    public abstract virtual int GetPreviousBreak(int currentIndex);
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextLexicalService : object {
    public abstract virtual bool IsCultureSupported(CultureInfo culture);
    public abstract virtual TextLexicalBreaks AnalyzeText(Char[] characterSource, int length, CultureInfo textCulture);
}
public abstract class System.Windows.Media.TextFormatting.TextLine : object {
    public double PixelsPerDip { get; public set; }
    public bool HasOverflowed { get; }
    public bool HasCollapsed { get; }
    public bool IsTruncated { get; }
    public int Length { get; }
    public int TrailingWhitespaceLength { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double OverhangAfter { get; }
    protected TextLine(double pixelsPerDip);
    public abstract virtual void Dispose();
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public abstract virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public abstract virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public abstract virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public abstract virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    [FriendAccessAllowedAttribute]
internal bool IsAtCaretCharacterHit(CharacterHit characterHit, int cpFirst);
    public abstract virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public abstract virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    public abstract virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public abstract virtual bool get_HasOverflowed();
    public abstract virtual bool get_HasCollapsed();
    public virtual bool get_IsTruncated();
    public abstract virtual TextLineBreak GetTextLineBreak();
    public abstract virtual int get_Length();
    public abstract virtual int get_TrailingWhitespaceLength();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_TextHeight();
    public abstract virtual double get_Extent();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual double get_OverhangLeading();
    public abstract virtual double get_OverhangTrailing();
    public abstract virtual double get_OverhangAfter();
}
public class System.Windows.Media.TextFormatting.TextLineBreak : object {
    internal TextModifierScope TextModifierScope { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> BreakRecord { get; }
    internal TextLineBreak(TextModifierScope currentScope, SecurityCriticalDataForSet`1<IntPtr> breakRecord);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public TextLineBreak Clone();
    internal TextModifierScope get_TextModifierScope();
    internal SecurityCriticalDataForSet`1<IntPtr> get_BreakRecord();
}
public abstract class System.Windows.Media.TextFormatting.TextMarkerProperties : object {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public abstract virtual double get_Offset();
    public abstract virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextModifier : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public bool HasDirectionalEmbedding { get; }
    public FlowDirection FlowDirection { get; }
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual TextRunProperties ModifyProperties(TextRunProperties properties);
    public abstract virtual bool get_HasDirectionalEmbedding();
    public abstract virtual FlowDirection get_FlowDirection();
}
internal class System.Windows.Media.TextFormatting.TextModifierScope : object {
    public TextModifierScope ParentScope { get; }
    public TextModifier TextModifier { get; }
    public int TextSourceCharacterIndex { get; }
    internal TextModifierScope(TextModifierScope parentScope, TextModifier modifier, int cp);
    public TextModifierScope get_ParentScope();
    public TextModifier get_TextModifier();
    public int get_TextSourceCharacterIndex();
    internal TextRunProperties ModifyProperties(TextRunProperties properties);
    internal TextModifierScope CloneStack();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.TextFormatting.TextParagraphCache : object {
    internal FullTextState FullText { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> Ploparabreak { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TextParagraphCache(FormatSettings settings, int firstCharIndex, int paragraphWidth);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal IList`1<TextBreakpoint> FormatBreakpoints(int firstCharIndex, TextLineBreak previousLineBreak, IntPtr breakpointRestrictionHandle, double maxLineWidth, Int32& bestFitIndex);
    internal FullTextState get_FullText();
    internal SecurityCriticalDataForSet`1<IntPtr> get_Ploparabreak();
}
public abstract class System.Windows.Media.TextFormatting.TextParagraphProperties : object {
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public double ParagraphIndent { get; }
    public double DefaultIncrementalTab { get; }
    public IList`1<TextTabProperties> Tabs { get; }
    internal TextLexicalService Hyphenator { get; internal set; }
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextAlignment get_TextAlignment();
    public abstract virtual double get_LineHeight();
    public abstract virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public abstract virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextWrapping get_TextWrapping();
    public abstract virtual TextMarkerProperties get_TextMarkerProperties();
    public abstract virtual double get_Indent();
    public virtual double get_ParagraphIndent();
    public virtual double get_DefaultIncrementalTab();
    public virtual IList`1<TextTabProperties> get_Tabs();
    [FriendAccessAllowedAttribute]
internal virtual TextLexicalService get_Hyphenator();
    [FriendAccessAllowedAttribute]
internal virtual void set_Hyphenator(TextLexicalService value);
}
public abstract class System.Windows.Media.TextFormatting.TextRun : object {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public abstract virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual int get_Length();
    public abstract virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextRunBounds : object {
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public Rect Rectangle { get; }
    public TextRun TextRun { get; }
    internal TextRunBounds(Rect bounds, int cpFirst, int cpEnd, TextRun textRun);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public Rect get_Rectangle();
    public TextRun get_TextRun();
}
public class System.Windows.Media.TextFormatting.TextRunCache : object {
    internal TextRunCacheImp Imp { get; internal set; }
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    public void Invalidate();
    [FriendAccessAllowedAttribute]
internal IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    internal TextRunCacheImp get_Imp();
    internal void set_Imp(TextRunCacheImp value);
}
public abstract class System.Windows.Media.TextFormatting.TextRunProperties : object {
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public CultureInfo CultureInfo { get; }
    public TextEffectCollection TextEffects { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public double PixelsPerDip { get; public set; }
    public abstract virtual Typeface get_Typeface();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual double get_FontHintingEmSize();
    public abstract virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual Brush get_ForegroundBrush();
    public abstract virtual Brush get_BackgroundBrush();
    public abstract virtual CultureInfo get_CultureInfo();
    public abstract virtual TextEffectCollection get_TextEffects();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual NumberSubstitution get_NumberSubstitution();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
}
public abstract class System.Windows.Media.TextFormatting.TextRunTypographyProperties : object {
    public bool StandardLigatures { get; }
    public bool ContextualLigatures { get; }
    public bool DiscretionaryLigatures { get; }
    public bool HistoricalLigatures { get; }
    public bool ContextualAlternates { get; }
    public bool HistoricalForms { get; }
    public bool Kerning { get; }
    public bool CapitalSpacing { get; }
    public bool CaseSensitiveForms { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public bool SlashedZero { get; }
    public bool MathematicalGreek { get; }
    public bool EastAsianExpertForms { get; }
    public FontVariants Variants { get; }
    public FontCapitals Capitals { get; }
    public FontFraction Fraction { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public int StandardSwashes { get; }
    public int ContextualSwashes { get; }
    public int StylisticAlternates { get; }
    public int AnnotationAlternates { get; }
    internal DWriteFontFeature[] CachedFeatureSet { get; internal set; }
    public abstract virtual bool get_StandardLigatures();
    public abstract virtual bool get_ContextualLigatures();
    public abstract virtual bool get_DiscretionaryLigatures();
    public abstract virtual bool get_HistoricalLigatures();
    public abstract virtual bool get_ContextualAlternates();
    public abstract virtual bool get_HistoricalForms();
    public abstract virtual bool get_Kerning();
    public abstract virtual bool get_CapitalSpacing();
    public abstract virtual bool get_CaseSensitiveForms();
    public abstract virtual bool get_StylisticSet1();
    public abstract virtual bool get_StylisticSet2();
    public abstract virtual bool get_StylisticSet3();
    public abstract virtual bool get_StylisticSet4();
    public abstract virtual bool get_StylisticSet5();
    public abstract virtual bool get_StylisticSet6();
    public abstract virtual bool get_StylisticSet7();
    public abstract virtual bool get_StylisticSet8();
    public abstract virtual bool get_StylisticSet9();
    public abstract virtual bool get_StylisticSet10();
    public abstract virtual bool get_StylisticSet11();
    public abstract virtual bool get_StylisticSet12();
    public abstract virtual bool get_StylisticSet13();
    public abstract virtual bool get_StylisticSet14();
    public abstract virtual bool get_StylisticSet15();
    public abstract virtual bool get_StylisticSet16();
    public abstract virtual bool get_StylisticSet17();
    public abstract virtual bool get_StylisticSet18();
    public abstract virtual bool get_StylisticSet19();
    public abstract virtual bool get_StylisticSet20();
    public abstract virtual bool get_SlashedZero();
    public abstract virtual bool get_MathematicalGreek();
    public abstract virtual bool get_EastAsianExpertForms();
    public abstract virtual FontVariants get_Variants();
    public abstract virtual FontCapitals get_Capitals();
    public abstract virtual FontFraction get_Fraction();
    public abstract virtual FontNumeralStyle get_NumeralStyle();
    public abstract virtual FontNumeralAlignment get_NumeralAlignment();
    public abstract virtual FontEastAsianWidths get_EastAsianWidths();
    public abstract virtual FontEastAsianLanguage get_EastAsianLanguage();
    public abstract virtual int get_StandardSwashes();
    public abstract virtual int get_ContextualSwashes();
    public abstract virtual int get_StylisticAlternates();
    public abstract virtual int get_AnnotationAlternates();
    protected void OnPropertiesChanged();
    internal DWriteFontFeature[] get_CachedFeatureSet();
    internal void set_CachedFeatureSet(DWriteFontFeature[] value);
}
internal class System.Windows.Media.TextFormatting.TextShapeableCharacters : TextShapeableSymbols {
    internal static ushort DefaultMaxClusterSize;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    internal double EmSize { get; }
    internal ItemProps ItemProps { get; }
    internal bool NeedsMaxClusterSize { get; }
    internal bool IsShapingRequired { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal double Height { get; }
    internal double Baseline { get; }
    internal double UnderlinePosition { get; }
    internal double UnderlineThickness { get; }
    internal double StrikethroughPosition { get; }
    internal double StrikethroughThickness { get; }
    internal bool IsSymbol { get; }
    internal GlyphTypeface GlyphTypeFace { get; }
    internal ushort MaxClusterSize { get; }
    internal TextShapeableCharacters(CharacterBufferRange characterRange, TextRunProperties properties, double emSize, ItemProps textItem, ShapeTypeface shapeTypeface, bool nullShape, TextFormattingMode textFormattingMode, bool isSideways);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    internal sealed virtual GlyphRun ComputeShapedGlyphRun(Point origin, Char[] characterString, UInt16[] clusterMap, UInt16[] glyphIndices, IList`1<double> glyphAdvances, IList`1<Point> glyphOffsets, bool rightToLeft, bool sideways);
    internal sealed virtual GlyphRun ComputeUnshapedGlyphRun(Point origin, Char[] characterString, IList`1<double> characterAdvances);
    internal sealed virtual void Draw(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal virtual double get_EmSize();
    internal virtual ItemProps get_ItemProps();
    [SecurityCriticalAttribute]
internal sealed virtual void GetAdvanceWidthsUnshaped(Char* characterString, int characterLength, double scalingFactor, Int32* advanceWidthsUnshaped);
    internal sealed virtual bool get_NeedsMaxClusterSize();
    internal sealed virtual bool CanShapeTogether(TextShapeableSymbols shapeable);
    internal sealed virtual bool get_IsShapingRequired();
    internal sealed virtual bool get_NeedsCaretInfo();
    internal sealed virtual bool get_HasExtendedCharacter();
    internal sealed virtual double get_Height();
    internal sealed virtual double get_Baseline();
    internal sealed virtual double get_UnderlinePosition();
    internal sealed virtual double get_UnderlineThickness();
    internal sealed virtual double get_StrikethroughPosition();
    internal sealed virtual double get_StrikethroughThickness();
    internal bool get_IsSymbol();
    internal virtual GlyphTypeface get_GlyphTypeFace();
    internal sealed virtual ushort get_MaxClusterSize();
}
public class System.Windows.Media.TextFormatting.TextSimpleMarkerProperties : TextMarkerProperties {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public TextSimpleMarkerProperties(TextMarkerStyle style, double offset, int autoNumberingIndex, TextParagraphProperties textParagraphProperties);
    public sealed virtual double get_Offset();
    public sealed virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextSource : object {
    public double PixelsPerDip { get; public set; }
    public abstract virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
}
public class System.Windows.Media.TextFormatting.TextSpan`1 : object {
    public int Length { get; }
    public T Value { get; }
    public TextSpan`1(int length, T value);
    public int get_Length();
    public T get_Value();
}
public enum System.Windows.Media.TextFormatting.TextTabAlignment : Enum {
    public int value__;
    public static TextTabAlignment Left;
    public static TextTabAlignment Center;
    public static TextTabAlignment Right;
    public static TextTabAlignment Character;
}
public class System.Windows.Media.TextFormatting.TextTabProperties : object {
    public TextTabAlignment Alignment { get; }
    public double Location { get; }
    public int TabLeader { get; }
    public int AligningCharacter { get; }
    public TextTabProperties(TextTabAlignment alignment, double location, int tabLeader, int aligningChar);
    public TextTabAlignment get_Alignment();
    public double get_Location();
    public int get_TabLeader();
    public int get_AligningCharacter();
}
public class System.Windows.Media.TextFormatting.TextTrailingCharacterEllipsis : TextCollapsingProperties {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingCharacterEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public class System.Windows.Media.TextFormatting.TextTrailingWordEllipsis : TextCollapsingProperties {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingWordEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextFormattingMode : Enum {
    public int value__;
    public static TextFormattingMode Ideal;
    public static TextFormattingMode Display;
}
public enum System.Windows.Media.TextHintingMode : Enum {
    public int value__;
    public static TextHintingMode Auto;
    public static TextHintingMode Fixed;
    public static TextHintingMode Animated;
}
public enum System.Windows.Media.TextRenderingMode : Enum {
    public int value__;
    public static TextRenderingMode Auto;
    public static TextRenderingMode Aliased;
    public static TextRenderingMode Grayscale;
    public static TextRenderingMode ClearType;
}
public abstract class System.Windows.Media.TileBrush : Brush {
    public static DependencyProperty ViewportUnitsProperty;
    public static DependencyProperty ViewboxUnitsProperty;
    public static DependencyProperty ViewportProperty;
    public static DependencyProperty ViewboxProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty TileModeProperty;
    public static DependencyProperty AlignmentXProperty;
    public static DependencyProperty AlignmentYProperty;
    internal static BrushMappingMode c_ViewportUnits;
    internal static BrushMappingMode c_ViewboxUnits;
    internal static Rect s_Viewport;
    internal static Rect s_Viewbox;
    internal static Stretch c_Stretch;
    internal static TileMode c_TileMode;
    internal static AlignmentX c_AlignmentX;
    internal static AlignmentY c_AlignmentY;
    internal static CachingHint c_CachingHint;
    internal static double c_CacheInvalidationThresholdMinimum;
    internal static double c_CacheInvalidationThresholdMaximum;
    public BrushMappingMode ViewportUnits { get; public set; }
    public BrushMappingMode ViewboxUnits { get; public set; }
    public Rect Viewport { get; public set; }
    public Rect Viewbox { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    private static TileBrush();
    public TileBrush Clone();
    public TileBrush CloneCurrentValue();
    public BrushMappingMode get_ViewportUnits();
    public void set_ViewportUnits(BrushMappingMode value);
    public BrushMappingMode get_ViewboxUnits();
    public void set_ViewboxUnits(BrushMappingMode value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Rect get_Viewbox();
    public void set_Viewbox(Rect value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    public AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
    protected abstract virtual void GetContentBounds(Rect& contentBounds);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void GetTileBrushMapping(Rect shapeFillBounds, Matrix& tileBrushMapping);
}
public enum System.Windows.Media.TileMode : Enum {
    public int value__;
    public static TileMode None;
    public static TileMode Tile;
    public static TileMode FlipX;
    public static TileMode FlipY;
    public static TileMode FlipXY;
}
public enum System.Windows.Media.ToleranceType : Enum {
    public int value__;
    public static ToleranceType Absolute;
    public static ToleranceType Relative;
}
[ValueSerializerAttribute("System.Windows.Media.Converters.TransformValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.TransformConverter")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Transform : GeneralTransform {
    public static Transform Identity { get; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    private static Transform();
    public Transform Clone();
    public Transform CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public static Transform Parse(string source);
    public static Transform get_Identity();
    public abstract virtual Matrix get_Value();
    internal abstract virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
    [SecurityCriticalAttribute]
internal virtual void ConvertToD3DMATRIX(D3DMATRIX* milMatrix);
    internal static void GetTransformValue(Transform transform, Matrix& currentTransformValue);
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TransformCollection : Animatable {
    internal FrugalStructList`1<Transform> _collection;
    internal UInt32 _version;
    public Transform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TransformCollection Empty { get; }
    public TransformCollection(int capacity);
    public TransformCollection(IEnumerable`1<Transform> collection);
    public TransformCollection Clone();
    public TransformCollection CloneCurrentValue();
    public sealed virtual void Add(Transform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform value);
    public sealed virtual int IndexOf(Transform value);
    public sealed virtual void Insert(int index, Transform value);
    public sealed virtual bool Remove(Transform value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Transform get_Item(int index);
    public sealed virtual void set_Item(int index, Transform value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Transform[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform> System.Collections.Generic.IEnumerable<System.Windows.Media.Transform>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TransformCollection get_Empty();
    internal Transform Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(Transform value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.Media.TransformConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.TransformGroup : Transform {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static TransformCollection s_Children;
    public TransformCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static TransformGroup();
    public TransformGroup Clone();
    public TransformGroup CloneCurrentValue();
    public TransformCollection get_Children();
    public void set_Children(TransformCollection value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
}
public class System.Windows.Media.TranslateTransform : Transform {
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_X;
    internal static double c_Y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    private static TranslateTransform();
    public TranslateTransform(double offsetX, double offsetY);
    public TranslateTransform Clone();
    public TranslateTransform CloneCurrentValue();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
}
internal static class System.Windows.Media.TypeConverterHelper : object {
    internal static UriHolder GetUriFromUriContext(ITypeDescriptorContext context, object inputString);
}
public class System.Windows.Media.Typeface : object {
    public FontFamily FontFamily { get; }
    public FontWeight Weight { get; }
    public FontStyle Style { get; }
    public FontStretch Stretch { get; }
    public bool IsObliqueSimulated { get; }
    public bool IsBoldSimulated { get; }
    internal FontFamily FallbackFontFamily { get; }
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public LanguageSpecificStringDictionary FaceNames { get; }
    internal bool Symbol { get; }
    internal bool NullFont { get; }
    internal FontStyle CanonicalStyle { get; }
    internal FontWeight CanonicalWeight { get; }
    internal FontStretch CanonicalStretch { get; }
    public Typeface(string typefaceName);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch, FontFamily fallbackFontFamily);
    public FontFamily get_FontFamily();
    public FontWeight get_Weight();
    public FontStyle get_Style();
    public FontStretch get_Stretch();
    public bool get_IsObliqueSimulated();
    public bool get_IsBoldSimulated();
    public bool TryGetGlyphTypeface(GlyphTypeface& glyphTypeface);
    internal FontFamily get_FallbackFontFamily();
    public double get_XHeight();
    public double get_CapsHeight();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public LanguageSpecificStringDictionary get_FaceNames();
    internal double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal bool get_Symbol();
    internal bool get_NullFont();
    internal GlyphTypeface TryGetGlyphTypeface();
    internal FontStyle get_CanonicalStyle();
    internal FontWeight get_CanonicalWeight();
    internal FontStretch get_CanonicalStretch();
    internal bool CheckFastPathNominalGlyphs(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, CultureInfo cultureInfo, TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, Int32& stringLengthFit);
    internal void GetCharacterNominalWidthsAndIdealWidth(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double toIdeal, TextFormattingMode textFormattingMode, bool isSideways, Int32[]& nominalWidths);
    internal void GetCharacterNominalWidthsAndIdealWidth(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double toIdeal, TextFormattingMode textFormattingMode, bool isSideways, Int32[]& nominalWidths, Int32& idealWidth);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal bool CompareFallbackFontFamily(FontFamily fallbackFontFamily);
}
internal class System.Windows.Media.UniqueEventHelper : object {
    internal void AddEvent(EventHandler handler);
    internal void RemoveEvent(EventHandler handler);
    internal void InvokeEvents(object sender, EventArgs args);
    internal UniqueEventHelper Clone();
}
internal class System.Windows.Media.UniqueEventHelper`1 : object {
    internal void AddEvent(EventHandler`1<TEventArgs> handler);
    internal void RemoveEvent(EventHandler`1<TEventArgs> handler);
    internal void InvokeEvents(object sender, TEventArgs args);
    internal UniqueEventHelper`1<TEventArgs> Clone();
}
internal class System.Windows.Media.UriHolder : ValueType {
    internal Uri BaseUri;
    internal Uri OriginalUri;
}
[FriendAccessAllowedAttribute]
internal static class System.Windows.Media.ValidateEnums : object {
    public static bool IsAlignmentXValid(object valueObject);
    public static bool IsAlignmentYValid(object valueObject);
    public static bool IsBrushMappingModeValid(object valueObject);
    public static bool IsCachingHintValid(object valueObject);
    public static bool IsColorInterpolationModeValid(object valueObject);
    public static bool IsGeometryCombineModeValid(object valueObject);
    public static bool IsEdgeModeValid(object valueObject);
    public static bool IsBitmapScalingModeValid(object valueObject);
    public static bool IsClearTypeHintValid(object valueObject);
    public static bool IsTextRenderingModeValid(object valueObject);
    public static bool IsTextHintingModeValid(object valueObject);
    public static bool IsFillRuleValid(object valueObject);
    public static bool IsGradientSpreadMethodValid(object valueObject);
    public static bool IsPenLineCapValid(object valueObject);
    public static bool IsPenLineJoinValid(object valueObject);
    public static bool IsStretchValid(object valueObject);
    public static bool IsTileModeValid(object valueObject);
    public static bool IsSweepDirectionValid(object valueObject);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.VectorCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.VectorCollectionValueSerializer")]
public class System.Windows.Media.VectorCollection : Freezable {
    internal FrugalStructList`1<Vector> _collection;
    internal UInt32 _version;
    public Vector Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Vector>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static VectorCollection Empty { get; }
    public VectorCollection(int capacity);
    public VectorCollection(IEnumerable`1<Vector> collection);
    public VectorCollection Clone();
    public VectorCollection CloneCurrentValue();
    public sealed virtual void Add(Vector value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector value);
    public sealed virtual int IndexOf(Vector value);
    public sealed virtual void Insert(int index, Vector value);
    public sealed virtual bool Remove(Vector value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Vector get_Item(int index);
    public sealed virtual void set_Item(int index, Vector value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Vector[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Vector>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector> System.Collections.Generic.IEnumerable<System.Windows.Vector>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static VectorCollection get_Empty();
    internal Vector Internal_GetItem(int i);
    internal int AddWithoutFiringPublicEvents(Vector value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static VectorCollection Parse(string source);
}
public class System.Windows.Media.VectorCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.VideoDrawing : Drawing {
    public static DependencyProperty PlayerProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static Rect s_Rect;
    public MediaPlayer Player { get; public set; }
    public Rect Rect { get; public set; }
    private static VideoDrawing();
    public VideoDrawing Clone();
    public VideoDrawing CloneCurrentValue();
    public MediaPlayer get_Player();
    public void set_Player(MediaPlayer value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
}
public abstract class System.Windows.Media.Visual : DependencyObject {
    internal static UncommonField`1<BitmapEffectState> BitmapEffectStateField;
    internal int _parentIndex;
    internal DependencyObject _parent;
    internal VisualProxy _proxy;
    internal static UncommonField`1<int> DpiIndex;
    internal bool IsVisualChildrenIterationInProgress { get; internal set; }
    internal bool IsRootElement { get; internal set; }
    internal Rect VisualContentBounds { get; }
    internal Rect VisualDescendantBounds { get; }
    protected int VisualChildrenCount { get; }
    internal int InternalVisualChildrenCount { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    internal bool HasVisualChildren { get; }
    internal UInt32 TreeLevel { get; internal set; }
    protected DependencyObject VisualParent { get; }
    internal DependencyObject InternalVisualParent { get; }
    protected internal Transform VisualTransform { get; protected set; }
    protected internal Effect VisualEffect { get; protected set; }
    internal Effect VisualEffectInternal { get; internal set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffect VisualBitmapEffect { get; protected set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffectInput VisualBitmapEffectInput { get; protected set; }
    internal bool BitmapEffectEmulationDisabled { get; internal set; }
    internal BitmapEffect VisualBitmapEffectInternal { get; internal set; }
    internal BitmapEffectInput VisualBitmapEffectInputInternal { get; internal set; }
    protected internal CacheMode VisualCacheMode { get; protected set; }
    protected internal Nullable`1<Rect> VisualScrollableAreaClip { get; protected set; }
    protected internal Geometry VisualClip { get; protected set; }
    protected internal Vector VisualOffset { get; protected set; }
    protected internal double VisualOpacity { get; protected set; }
    protected internal EdgeMode VisualEdgeMode { get; protected set; }
    protected internal BitmapScalingMode VisualBitmapScalingMode { get; protected set; }
    protected internal ClearTypeHint VisualClearTypeHint { get; protected internal set; }
    protected internal TextRenderingMode VisualTextRenderingMode { get; protected internal set; }
    protected internal TextHintingMode VisualTextHintingMode { get; protected internal set; }
    protected internal Brush VisualOpacityMask { get; protected set; }
    protected internal DoubleCollection VisualXSnappingGuidelines { get; protected set; }
    protected internal DoubleCollection VisualYSnappingGuidelines { get; protected set; }
    internal EventHandler ClipChangedHandler { get; }
    internal EventHandler ScrollableAreaClipChangedHandler { get; }
    internal EventHandler TransformChangedHandler { get; }
    internal EventHandler EffectChangedHandler { get; }
    internal EventHandler CacheModeChangedHandler { get; }
    internal EventHandler GuidelinesChangedHandler { get; }
    internal EventHandler OpacityMaskChangedHandler { get; }
    internal EventHandler ContentsChangedHandler { get; }
    internal Visual(ResourceType resourceType);
    private static Visual();
    internal bool IsOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    [FriendAccessAllowedAttribute]
internal bool get_IsVisualChildrenIterationInProgress();
    [FriendAccessAllowedAttribute]
internal void set_IsVisualChildrenIterationInProgress(bool value);
    internal bool get_IsRootElement();
    internal void set_IsRootElement(bool value);
    internal virtual Rect GetContentBounds();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void RenderClose(IDrawingContent newContent);
    internal Rect get_VisualContentBounds();
    internal Rect get_VisualDescendantBounds();
    internal Rect CalculateSubgraphBoundsInnerSpace();
    internal Rect CalculateSubgraphRenderBoundsInnerSpace();
    internal virtual Rect CalculateSubgraphBoundsInnerSpace(bool renderBounds);
    internal Rect CalculateSubgraphBoundsOuterSpace();
    internal Rect CalculateSubgraphRenderBoundsOuterSpace();
    internal virtual void FreeContent(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal virtual void AddRefOnChannelForCyclicBrush(ICyclicBrush cyclicBrush, Channel channel);
    internal virtual void ReleaseOnChannelForCyclicBrush(ICyclicBrush cyclicBrush, Channel channel);
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(DependencyObject value);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(DependencyObject value);
    internal void Precompute();
    internal virtual void PrecomputeContent();
    internal void PrecomputeRecursive(Rect& bboxSubgraph);
    internal void Render(RenderContext ctx, UInt32 childIndex);
    internal virtual void RenderRecursive(RenderContext ctx);
    internal bool Enter();
    internal void Exit();
    internal void InvalidateHitTestBounds();
    internal virtual Rect GetHitTestBounds();
    internal HitTestResult HitTest(Point point);
    internal HitTestResult HitTest(Point point, bool include2DOn3D);
    internal void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    internal HitTestResultBehavior HitTestPoint(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters pointParams);
    internal GeneralTransform TransformToOuterSpace();
    internal HitTestResultBehavior HitTestGeometry(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, GeometryHitTestParameters geometryParams);
    internal virtual HitTestResultBehavior HitTestPointInternal(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual int get_VisualChildrenCount();
    internal int get_InternalVisualChildrenCount();
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal bool get_HasVisualChildren();
    protected virtual Visual GetVisualChild(int index);
    internal Visual InternalGetVisualChild(int index);
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal void InternalAddVisualChild(Visual child);
    internal void InternalRemoveVisualChild(Visual child);
    protected void AddVisualChild(Visual child);
    protected void RemoveVisualChild(Visual child);
    [FriendAccessAllowedAttribute]
internal void InvalidateZOrder();
    internal UInt32 get_TreeLevel();
    internal void set_TreeLevel(UInt32 value);
    protected DependencyObject get_VisualParent();
    internal DependencyObject get_InternalVisualParent();
    [FriendAccessAllowedAttribute]
internal void InternalSetOffsetWorkaround(Vector offset);
    [FriendAccessAllowedAttribute]
internal void InternalSetTransformWorkaround(Transform transform);
    protected internal Transform get_VisualTransform();
    protected void set_VisualTransform(Transform value);
    protected internal Effect get_VisualEffect();
    protected void set_VisualEffect(Effect value);
    internal Effect get_VisualEffectInternal();
    internal void set_VisualEffectInternal(Effect value);
    protected internal BitmapEffect get_VisualBitmapEffect();
    protected void set_VisualBitmapEffect(BitmapEffect value);
    protected internal BitmapEffectInput get_VisualBitmapEffectInput();
    protected void set_VisualBitmapEffectInput(BitmapEffectInput value);
    internal void BitmapEffectEmulationChanged(object sender, EventArgs e);
    internal bool get_BitmapEffectEmulationDisabled();
    internal void set_BitmapEffectEmulationDisabled(bool value);
    internal BitmapEffect get_VisualBitmapEffectInternal();
    internal void set_VisualBitmapEffectInternal(BitmapEffect value);
    internal BitmapEffectInput get_VisualBitmapEffectInputInternal();
    internal void set_VisualBitmapEffectInputInternal(BitmapEffectInput value);
    protected internal CacheMode get_VisualCacheMode();
    protected void set_VisualCacheMode(CacheMode value);
    protected internal Nullable`1<Rect> get_VisualScrollableAreaClip();
    protected void set_VisualScrollableAreaClip(Nullable`1<Rect> value);
    protected internal Geometry get_VisualClip();
    protected void set_VisualClip(Geometry value);
    internal void ChangeVisualClip(Geometry newClip, bool dontSetWhenClose);
    protected internal Vector get_VisualOffset();
    protected void set_VisualOffset(Vector value);
    protected internal double get_VisualOpacity();
    protected void set_VisualOpacity(double value);
    protected internal EdgeMode get_VisualEdgeMode();
    protected void set_VisualEdgeMode(EdgeMode value);
    protected internal BitmapScalingMode get_VisualBitmapScalingMode();
    protected void set_VisualBitmapScalingMode(BitmapScalingMode value);
    protected internal ClearTypeHint get_VisualClearTypeHint();
    protected internal void set_VisualClearTypeHint(ClearTypeHint value);
    protected internal TextRenderingMode get_VisualTextRenderingMode();
    protected internal void set_VisualTextRenderingMode(TextRenderingMode value);
    protected internal TextHintingMode get_VisualTextHintingMode();
    protected internal void set_VisualTextHintingMode(TextHintingMode value);
    protected internal Brush get_VisualOpacityMask();
    protected void set_VisualOpacityMask(Brush value);
    protected internal DoubleCollection get_VisualXSnappingGuidelines();
    protected void set_VisualXSnappingGuidelines(DoubleCollection value);
    protected internal DoubleCollection get_VisualYSnappingGuidelines();
    protected void set_VisualYSnappingGuidelines(DoubleCollection value);
    internal void DisconnectAttachedResource(VisualProxyFlags correspondingFlag, IResource attachedResource);
    internal virtual DrawingGroup GetDrawing();
    internal virtual void FireOnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    internal void add_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal void remove_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal static void ProcessAncestorChangedNotificationRecursive(DependencyObject e, AncestorChangedEventArgs args);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    internal void SetFlagsToRoot(bool value, VisualFlags flag);
    internal DependencyObject FindFirstAncestorWithFlagsAnd(VisualFlags flag);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    public GeneralTransform TransformToAncestor(Visual ancestor);
    public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform TransformToDescendant(Visual descendant);
    public GeneralTransform TransformToVisual(Visual visual);
    internal bool TrySimpleTransformToAncestor(Visual ancestor, bool inverse, GeneralTransform& generalTransform, Matrix& simpleTransform);
    internal bool TrySimpleTransformToAncestor(Visual3D ancestor, GeneralTransform2DTo3D& transformTo3D);
    internal DpiScale GetDpi();
    public Point PointToScreen(Point point);
    public Point PointFromScreen(Point point);
    internal EventHandler get_ClipChangedHandler();
    internal void ClipChanged(object sender, EventArgs e);
    internal EventHandler get_ScrollableAreaClipChangedHandler();
    internal void ScrollableAreaClipChanged(object sender, EventArgs e);
    internal EventHandler get_TransformChangedHandler();
    internal void TransformChanged(object sender, EventArgs e);
    internal EventHandler get_EffectChangedHandler();
    internal void EffectChanged(object sender, EventArgs e);
    internal EventHandler get_CacheModeChangedHandler();
    internal void CacheModeChanged(object sender, EventArgs e);
    internal EventHandler get_GuidelinesChangedHandler();
    internal void GuidelinesChanged(object sender, EventArgs e);
    internal EventHandler get_OpacityMaskChangedHandler();
    internal void OpacityMaskChanged(object sender, EventArgs e);
    internal EventHandler get_ContentsChangedHandler();
    internal virtual void ContentsChanged(object sender, EventArgs e);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(bool value, VisualFlags flags);
    internal void SetDpiScaleVisualFlags(DpiRecursiveChangeArgs args);
    internal void RecursiveSetDpiScaleVisualFlags(DpiRecursiveChangeArgs args);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(VisualFlags flags);
    internal bool CheckFlagsOr(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsOr(VisualFlags flags);
    internal static void SetTreeBits(DependencyObject e, VisualFlags treeFlag, VisualFlags nodeFlag);
    internal static void ClearTreeBits(DependencyObject e, VisualFlags treeFlag, VisualFlags nodeFlag);
    internal static void PropagateFlags(Visual e, VisualFlags flags, VisualProxyFlags proxyFlags);
    internal void PropagateChangedFlags();
}
public class System.Windows.Media.VisualBrush : TileBrush {
    public static DependencyProperty VisualProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    internal MultiChannelResource _duceResource;
    internal static bool c_AutoLayoutContent;
    public Visual Visual { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static VisualBrush();
    public VisualBrush(Visual visual);
    public VisualBrush Clone();
    public VisualBrush CloneCurrentValue();
    public Visual get_Visual();
    public void set_Visual(Visual value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    protected virtual Freezable CreateInstanceCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.FireOnChanged();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
    internal void AddRefResource(Visual visual, Channel channel);
    internal void ReleaseResource(Visual visual, Channel channel);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal bool Enter();
    internal void Exit();
    protected virtual void GetContentBounds(Rect& contentBounds);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.VisualCollection : object {
    internal int InternalCount { get; }
    internal Visual[] InternalArray { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal int InternalCapacity { get; internal set; }
    public int Capacity { get; public set; }
    public Visual Item { get; public set; }
    public VisualCollection(Visual parent);
    internal int get_InternalCount();
    internal Visual[] get_InternalArray();
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(Visual other);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(Visual other);
    internal void VerifyNotReadOnly();
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Visual[] array, int index);
    internal int get_InternalCapacity();
    internal void set_InternalCapacity(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public Visual get_Item(int index);
    public void set_Item(int index, Visual value);
    public int Add(Visual visual);
    public int IndexOf(Visual visual);
    public void Remove(Visual visual);
    internal void SetReadOnly();
    public bool Contains(Visual visual);
    public void Clear();
    public void Insert(int index, Visual visual);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    internal void Move(Visual visual, Visual destination);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator GetEnumerator();
}
internal class System.Windows.Media.VisualDrawingContext : RenderDataDrawingContext {
    internal VisualDrawingContext(Visual ownerVisual);
    protected virtual void CloseCore(RenderData renderData);
}
[FlagsAttribute]
internal enum System.Windows.Media.VisualFlags : Enum {
    public UInt32 value__;
    public static VisualFlags None;
    public static VisualFlags IsSubtreeDirtyForPrecompute;
    public static VisualFlags ShouldPostRender;
    public static VisualFlags IsUIElement;
    public static VisualFlags IsLayoutSuspended;
    public static VisualFlags IsVisualChildrenIterationInProgress;
    public static VisualFlags Are3DContentBoundsValid;
    public static VisualFlags FindCommonAncestor;
    public static VisualFlags IsLayoutIslandRoot;
    public static VisualFlags UseLayoutRounding;
    public static VisualFlags VisibilityCache_Visible;
    public static VisualFlags VisibilityCache_TakesSpace;
    public static VisualFlags RegisteredForAncestorChanged;
    public static VisualFlags SubTreeHoldsAncestorChanged;
    public static VisualFlags NodeIsCyclicBrushRoot;
    public static VisualFlags NodeHasEffect;
    public static VisualFlags IsViewport3DVisual;
    public static VisualFlags ReentrancyFlag;
    public static VisualFlags HasChildren;
    public static VisualFlags BitmapEffectEmulationDisabled;
    public static VisualFlags DpiScaleFlag1;
    public static VisualFlags DpiScaleFlag2;
    public static VisualFlags TreeLevelBit0;
    public static VisualFlags TreeLevelBit1;
    public static VisualFlags TreeLevelBit2;
    public static VisualFlags TreeLevelBit3;
    public static VisualFlags TreeLevelBit4;
    public static VisualFlags TreeLevelBit5;
    public static VisualFlags TreeLevelBit6;
    public static VisualFlags TreeLevelBit7;
    public static VisualFlags TreeLevelBit8;
    public static VisualFlags TreeLevelBit9;
    public static VisualFlags TreeLevelBit10;
}
[FlagsAttribute]
internal enum System.Windows.Media.VisualProxyFlags : Enum {
    public UInt32 value__;
    public static VisualProxyFlags None;
    public static VisualProxyFlags IsSubtreeDirtyForRender;
    public static VisualProxyFlags IsTransformDirty;
    public static VisualProxyFlags IsClipDirty;
    public static VisualProxyFlags IsContentDirty;
    public static VisualProxyFlags IsOpacityDirty;
    public static VisualProxyFlags IsOpacityMaskDirty;
    public static VisualProxyFlags IsOffsetDirty;
    public static VisualProxyFlags IsClearTypeHintDirty;
    public static VisualProxyFlags IsGuidelineCollectionDirty;
    public static VisualProxyFlags IsEdgeModeDirty;
    public static VisualProxyFlags IsContentConnected;
    public static VisualProxyFlags IsContentNodeConnected;
    public static VisualProxyFlags IsConnectedToParent;
    public static VisualProxyFlags Viewport3DVisual_IsCameraDirty;
    public static VisualProxyFlags Viewport3DVisual_IsViewportDirty;
    public static VisualProxyFlags IsBitmapScalingModeDirty;
    public static VisualProxyFlags IsDeleteResourceInProgress;
    public static VisualProxyFlags IsChildrenZOrderDirty;
    public static VisualProxyFlags IsEffectDirty;
    public static VisualProxyFlags IsCacheModeDirty;
    public static VisualProxyFlags IsScrollableAreaClipDirty;
    public static VisualProxyFlags IsTextRenderingModeDirty;
    public static VisualProxyFlags IsTextHintingModeDirty;
}
public class System.Windows.Media.VisualTarget : CompositionTarget {
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    internal Channel OutOfBandChannel { get; }
    public VisualTarget(HostVisual hostVisual);
    internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    [SecurityCriticalAttribute]
public virtual void Dispose();
    internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    internal Channel get_OutOfBandChannel();
}
public static class System.Windows.Media.VisualTreeHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool IsVisualType(DependencyObject reference);
    public static int GetChildrenCount(DependencyObject reference);
    public static DependencyObject GetChild(DependencyObject reference, int childIndex);
    public static DpiScale GetDpi(Visual visual);
    public static void SetRootDpi(Visual visual, DpiScale dpiInfo);
    public static DependencyObject GetParent(DependencyObject reference);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetParentInternal(DependencyObject reference);
    internal static Visual GetContainingVisual2D(DependencyObject reference);
    internal static Visual3D GetContainingVisual3D(DependencyObject reference);
    internal static bool IsAncestorOf(DependencyObject reference, DependencyObject descendant);
    internal static bool IsAncestorOf(DependencyObject ancestor, DependencyObject descendant, Type stopType);
    internal static DependencyObject FindCommonAncestor(DependencyObject reference, DependencyObject otherVisual);
    public static Geometry GetClip(Visual reference);
    public static double GetOpacity(Visual reference);
    public static Brush GetOpacityMask(Visual reference);
    public static Vector GetOffset(Visual reference);
    public static Transform GetTransform(Visual reference);
    public static DoubleCollection GetXSnappingGuidelines(Visual reference);
    public static DoubleCollection GetYSnappingGuidelines(Visual reference);
    public static DrawingGroup GetDrawing(Visual reference);
    public static Rect GetContentBounds(Visual reference);
    public static Rect3D GetContentBounds(Visual3D reference);
    public static Rect GetDescendantBounds(Visual reference);
    public static Rect3D GetDescendantBounds(Visual3D reference);
    public static BitmapEffect GetBitmapEffect(Visual reference);
    public static BitmapEffectInput GetBitmapEffectInput(Visual reference);
    public static Effect GetEffect(Visual reference);
    public static CacheMode GetCacheMode(Visual reference);
    public static EdgeMode GetEdgeMode(Visual reference);
    public static HitTestResult HitTest(Visual reference, Point point);
    [FriendAccessAllowedAttribute]
internal static HitTestResult HitTest(Visual reference, Point point, bool include2DOn3D);
    public static void HitTest(Visual reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public static void HitTest(Visual3D reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
}
public enum System.Windows.Modifiability : Enum {
    public int value__;
    public static Modifiability Unmodifiable;
    public static Modifiability Modifiable;
    public static Modifiability Inherit;
}
internal class System.Windows.MouseCaptureWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.MouseOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public static class System.Windows.Navigation.BaseUriHelper : object {
    public static DependencyProperty BaseUriProperty;
    internal static Uri SiteOfOriginBaseUri { get; }
    internal static Uri PackAppBaseUri { get; }
    internal static Uri BaseUri { get; internal set; }
    internal static Assembly ResourceAssembly { get; internal set; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static BaseUriHelper();
    [SecurityCriticalAttribute]
public static Uri GetBaseUri(DependencyObject element);
    [FriendAccessAllowedAttribute]
internal static Uri get_SiteOfOriginBaseUri();
    [FriendAccessAllowedAttribute]
internal static Uri get_PackAppBaseUri();
    internal static bool IsPackApplicationUri(Uri uri);
    [FriendAccessAllowedAttribute]
internal static void GetAssemblyAndPartNameFromPackAppUri(Uri uri, Assembly& assembly, String& partName);
    [FriendAccessAllowedAttribute]
internal static Assembly GetLoadedAssembly(string assemblyName, string assemblyVersion, string assemblyKey);
    [FriendAccessAllowedAttribute]
internal static void GetAssemblyNameAndPart(Uri uri, String& partName, String& assemblyName, String& assemblyVersion, String& assemblyKey);
    [FriendAccessAllowedAttribute]
internal static bool IsComponentEntryAssembly(string component);
    [FriendAccessAllowedAttribute]
internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    [FriendAccessAllowedAttribute]
internal static Uri MakeRelativeToSiteOfOriginIfPossible(Uri sUri);
    [FriendAccessAllowedAttribute]
internal static Uri ConvertPackUriToAbsoluteExternallyVisibleUri(Uri packUri);
    [FriendAccessAllowedAttribute]
internal static Uri FixFileUri(Uri uri);
    [FriendAccessAllowedAttribute]
internal static Uri get_BaseUri();
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static void set_BaseUri(Uri value);
    internal static Assembly get_ResourceAssembly();
    [FriendAccessAllowedAttribute]
internal static void set_ResourceAssembly(Assembly value);
    internal static Uri AppendAssemblyVersion(Uri uri, Assembly assemblyInfo);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Uri GetBaseUriCore(DependencyObject element);
}
internal class System.Windows.OleDragSource : object {
    public OleDragSource(DependencyObject dragSource);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropSource.OleQueryContinueDrag(int escapeKey, int grfkeyState);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropSource.OleGiveFeedback(int effect);
}
internal class System.Windows.OleDropTarget : DispatcherObject {
    public OleDropTarget(IntPtr handle);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragEnter(object data, int dragDropKeyStates, long point, Int32& effects);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragOver(int dragDropKeyStates, long point, Int32& effects);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragLeave();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDrop(object data, int dragDropKeyStates, long point, Int32& effects);
}
internal class System.Windows.OleServicesContext : object {
    internal static OleServicesContext CurrentOleServicesContext { get; }
    private static OleServicesContext();
    internal static OleServicesContext get_CurrentOleServicesContext();
    [SecurityCriticalAttribute]
internal int OleSetClipboard(IDataObject dataObject);
    [SecurityCriticalAttribute]
internal int OleGetClipboard(IDataObject& dataObject);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal int OleFlushClipboard();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int OleIsCurrentClipboard(IDataObject dataObject);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OleDoDragDrop(IDataObject dataObject, IOleDropSource dropSource, int allowedEffects, Int32[] finalEffect);
    [SecurityCriticalAttribute]
internal int OleRegisterDragDrop(HandleRef windowHandle, IOleDropTarget dropTarget);
    [SecurityCriticalAttribute]
internal int OleRevokeDragDrop(HandleRef windowHandle);
}
public abstract class System.Windows.PresentationSource : DispatcherObject {
    public CompositionTarget CompositionTarget { get; }
    public Visual RootVisual { get; public set; }
    public bool IsDisposed { get; }
    public static IEnumerable CurrentSources { get; }
    internal static IEnumerable CriticalCurrentSources { get; }
    [SecurityCriticalAttribute]
private static PresentationSource();
    [SecurityCriticalAttribute]
internal virtual IInputProvider GetInputProvider(Type inputDevice);
    [SecurityCriticalAttribute]
public static PresentationSource FromVisual(Visual visual);
    [SecurityCriticalAttribute]
public static PresentationSource FromDependencyObject(DependencyObject dependencyObject);
    [SecurityCriticalAttribute]
public static void AddSourceChangedHandler(IInputElement element, SourceChangedEventHandler handler);
    public static void RemoveSourceChangedHandler(IInputElement e, SourceChangedEventHandler handler);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static void OnAncestorChanged(ContentElement ce);
    [SecurityCriticalAttribute]
public CompositionTarget get_CompositionTarget();
    public abstract virtual Visual get_RootVisual();
    [SecurityCriticalAttribute]
public abstract virtual void set_RootVisual(Visual value);
    internal void PushMenuMode();
    internal void PopMenuMode();
    internal virtual void OnEnterMenuMode();
    internal virtual void OnLeaveMenuMode();
    public abstract virtual bool get_IsDisposed();
    [SecurityCriticalAttribute]
public static IEnumerable get_CurrentSources();
    [CompilerGeneratedAttribute]
public void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ContentRendered(EventHandler value);
    protected abstract virtual CompositionTarget GetCompositionTargetCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected void RootChanged(Visual oldRoot, Visual newRoot);
    protected void AddSource();
    protected void RemoveSource();
    protected void ClearContentRenderedListeners();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static void OnVisualAncestorChanged(DependencyObject uie, AncestorChangedEventArgs e);
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
internal static PresentationSource CriticalFromVisual(DependencyObject v);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static PresentationSource CriticalFromVisual(DependencyObject v, bool enable2DTo3DTransition);
    internal static object FireContentRendered(object arg);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool UnderSamePresentationSource(DependencyObject[] visuals);
    [SecurityCriticalAttribute]
internal static IEnumerable get_CriticalCurrentSources();
}
public class System.Windows.QueryContinueDragEventArgs : RoutedEventArgs {
    public bool EscapePressed { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragAction Action { get; public set; }
    internal QueryContinueDragEventArgs(bool escapePressed, DragDropKeyStates dragDropKeyStates);
    public bool get_EscapePressed();
    public DragDropKeyStates get_KeyStates();
    public DragAction get_Action();
    public void set_Action(DragAction value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.QueryContinueDragEventHandler : MulticastDelegate {
    public QueryContinueDragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryContinueDragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryContinueDragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Readability : Enum {
    public int value__;
    public static Readability Unreadable;
    public static Readability Readable;
    public static Readability Inherit;
}
internal class System.Windows.ReadOnlyPropertyMetadata : PropertyMetadata {
    internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    public ReadOnlyPropertyMetadata(object defaultValue, GetReadOnlyValueCallback getValueCallback, PropertyChangedCallback propertyChangedCallback);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
}
[AttributeUsageAttribute("1")]
public class System.Windows.Resources.AssemblyAssociatedContentFileAttribute : Attribute {
    public string RelativeContentFilePath { get; }
    public AssemblyAssociatedContentFileAttribute(string relativeContentFilePath);
    public string get_RelativeContentFilePath();
}
internal abstract class System.Windows.ReverseInheritProperty : object {
    protected DependencyPropertyKey FlagKey;
    protected CoreFlags FlagCache;
    protected CoreFlags FlagChanged;
    protected CoreFlags FlagOldOriginCache;
    protected CoreFlags FlagNewOriginCache;
    internal ReverseInheritProperty(DependencyPropertyKey flagKey, CoreFlags flagCache, CoreFlags flagChanged);
    internal ReverseInheritProperty(DependencyPropertyKey flagKey, CoreFlags flagCache, CoreFlags flagChanged, CoreFlags flagOldOriginCache, CoreFlags flagNewOriginCache);
    internal abstract virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
    internal void OnOriginValueChanged(DependencyObject oldOrigin, DependencyObject newOrigin, DeferredElementTreeState& oldTreeState);
    internal void OnOriginValueChanged(DependencyObject oldOrigin, DependencyObject newOrigin, IList`1<DependencyObject> otherOrigins, DeferredElementTreeState& oldTreeState, Action`2<DependencyObject, bool> originChangedAction);
}
[ValueSerializerAttribute("System.Windows.Markup.RoutedEventValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[TypeConverterAttribute("System.Windows.Markup.RoutedEventConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.RoutedEvent : object {
    public string Name { get; }
    public RoutingStrategy RoutingStrategy { get; }
    public Type HandlerType { get; }
    public Type OwnerType { get; }
    internal int GlobalIndex { get; }
    internal RoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    public RoutedEvent AddOwner(Type ownerType);
    public string get_Name();
    public RoutingStrategy get_RoutingStrategy();
    public Type get_HandlerType();
    internal bool IsLegalHandler(Delegate handler);
    public Type get_OwnerType();
    public virtual string ToString();
    internal int get_GlobalIndex();
}
public class System.Windows.RoutedEventArgs : EventArgs {
    public RoutedEvent RoutedEvent { get; public set; }
    public bool Handled { get; public set; }
    public object Source { get; public set; }
    public object OriginalSource { get; }
    internal bool UserInitiated { get; }
    public RoutedEventArgs(RoutedEvent routedEvent);
    public RoutedEventArgs(RoutedEvent routedEvent, object source);
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    internal void OverrideRoutedEvent(RoutedEvent newRoutedEvent);
    [SecurityCriticalAttribute]
public bool get_Handled();
    [SecurityCriticalAttribute]
public void set_Handled(bool value);
    public object get_Source();
    public void set_Source(object value);
    internal void OverrideSource(object source);
    public object get_OriginalSource();
    protected virtual void OnSetSource(object source);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal void InvokeHandler(Delegate handler, object target);
    [FriendAccessAllowedAttribute]
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal bool get_UserInitiated();
    [SecurityCriticalAttribute]
internal void MarkAsUserInitiated();
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal void ClearUserInitiated();
}
public class System.Windows.RoutedEventHandler : MulticastDelegate {
    public RoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.RoutedEventHandlerInfo : ValueType {
    private Delegate _handler;
    private bool _handledEventsToo;
    public Delegate Handler { get; }
    public bool InvokeHandledEventsToo { get; }
    internal RoutedEventHandlerInfo(Delegate handler, bool handledEventsToo);
    public Delegate get_Handler();
    public bool get_InvokeHandledEventsToo();
    internal void InvokeHandler(object target, RoutedEventArgs routedEventArgs);
    public virtual bool Equals(object obj);
    public bool Equals(RoutedEventHandlerInfo handlerInfo);
    public virtual int GetHashCode();
    public static bool op_Equality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
    public static bool op_Inequality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
}
internal class System.Windows.RoutedEventHandlerInfoList : object {
    internal RoutedEventHandlerInfo[] Handlers;
    internal RoutedEventHandlerInfoList Next;
    internal bool Contains(RoutedEventHandlerInfoList handlers);
}
internal class System.Windows.RouteItem : ValueType {
    private object _target;
    private RoutedEventHandlerInfo _routedEventHandlerInfo;
    internal object Target { get; }
    internal RouteItem(object target, RoutedEventHandlerInfo routedEventHandlerInfo);
    internal object get_Target();
    internal void InvokeHandler(RoutedEventArgs routedEventArgs);
    public virtual bool Equals(object o);
    public bool Equals(RouteItem routeItem);
    public virtual int GetHashCode();
    public static bool op_Equality(RouteItem routeItem1, RouteItem routeItem2);
    public static bool op_Inequality(RouteItem routeItem1, RouteItem routeItem2);
}
public enum System.Windows.RoutingStrategy : Enum {
    public int value__;
    public static RoutingStrategy Tunnel;
    public static RoutingStrategy Bubble;
    public static RoutingStrategy Direct;
}
public class System.Windows.SizeChangedInfo : object {
    internal SizeChangedInfo Next;
    public Size PreviousSize { get; }
    public Size NewSize { get; }
    public bool WidthChanged { get; }
    public bool HeightChanged { get; }
    internal UIElement Element { get; }
    public SizeChangedInfo(UIElement element, Size previousSize, bool widthChanged, bool heightChanged);
    public Size get_PreviousSize();
    public Size get_NewSize();
    public bool get_WidthChanged();
    public bool get_HeightChanged();
    internal void Update(bool widthChanged, bool heightChanged);
    internal UIElement get_Element();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.SizeToContent : Enum {
    public int value__;
    public static SizeToContent Manual;
    public static SizeToContent Width;
    public static SizeToContent Height;
    public static SizeToContent WidthAndHeight;
}
public class System.Windows.SourceChangedEventArgs : RoutedEventArgs {
    public PresentationSource OldSource { get; }
    public PresentationSource NewSource { get; }
    public IInputElement Element { get; }
    public IInputElement OldParent { get; }
    [SecurityCriticalAttribute]
public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource);
    [SecurityCriticalAttribute]
public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource, IInputElement element, IInputElement oldParent);
    [SecurityCriticalAttribute]
public PresentationSource get_OldSource();
    [SecurityCriticalAttribute]
public PresentationSource get_NewSource();
    public IInputElement get_Element();
    public IInputElement get_OldParent();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SourceChangedEventHandler : MulticastDelegate {
    public SourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.SourceItem : ValueType {
    private int _startIndex;
    private object _source;
    internal int StartIndex { get; }
    internal object Source { get; }
    internal SourceItem(int startIndex, object source);
    internal int get_StartIndex();
    internal object get_Source();
    public virtual bool Equals(object o);
    public bool Equals(SourceItem sourceItem);
    public virtual int GetHashCode();
    public static bool op_Equality(SourceItem sourceItem1, SourceItem sourceItem2);
    public static bool op_Inequality(SourceItem sourceItem1, SourceItem sourceItem2);
}
public class System.Windows.StrokeCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
internal class System.Windows.StylusCaptureWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.StylusOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Right;
    public static TextAlignment Center;
    public static TextAlignment Justify;
}
public enum System.Windows.TextDataFormat : Enum {
    public int value__;
    public static TextDataFormat Text;
    public static TextDataFormat UnicodeText;
    public static TextDataFormat Rtf;
    public static TextDataFormat Html;
    public static TextDataFormat CommaSeparatedValue;
    public static TextDataFormat Xaml;
}
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecoration : Animatable {
    public static DependencyProperty PenProperty;
    public static DependencyProperty PenOffsetProperty;
    public static DependencyProperty PenOffsetUnitProperty;
    public static DependencyProperty PenThicknessUnitProperty;
    public static DependencyProperty LocationProperty;
    internal static double c_PenOffset;
    internal static TextDecorationUnit c_PenOffsetUnit;
    internal static TextDecorationUnit c_PenThicknessUnit;
    internal static TextDecorationLocation c_Location;
    public Pen Pen { get; public set; }
    public double PenOffset { get; public set; }
    public TextDecorationUnit PenOffsetUnit { get; public set; }
    public TextDecorationUnit PenThicknessUnit { get; public set; }
    public TextDecorationLocation Location { get; public set; }
    public TextDecoration(TextDecorationLocation location, Pen pen, double penOffset, TextDecorationUnit penOffsetUnit, TextDecorationUnit penThicknessUnit);
    private static TextDecoration();
    internal bool ValueEquals(TextDecoration textDecoration);
    public TextDecoration Clone();
    public TextDecoration CloneCurrentValue();
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public double get_PenOffset();
    public void set_PenOffset(double value);
    public TextDecorationUnit get_PenOffsetUnit();
    public void set_PenOffsetUnit(TextDecorationUnit value);
    public TextDecorationUnit get_PenThicknessUnit();
    public void set_PenThicknessUnit(TextDecorationUnit value);
    public TextDecorationLocation get_Location();
    public void set_Location(TextDecorationLocation value);
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.TextDecorationCollectionConverter")]
public class System.Windows.TextDecorationCollection : Animatable {
    internal FrugalStructList`1<TextDecoration> _collection;
    internal UInt32 _version;
    public TextDecoration Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TextDecorationCollection Empty { get; }
    public TextDecorationCollection(int capacity);
    public TextDecorationCollection(IEnumerable`1<TextDecoration> collection);
    [FriendAccessAllowedAttribute]
internal bool ValueEquals(TextDecorationCollection textDecorations);
    [CLSCompliantAttribute("False")]
public void Add(IEnumerable`1<TextDecoration> textDecorations);
    public bool TryRemove(IEnumerable`1<TextDecoration> textDecorations, TextDecorationCollection& result);
    public TextDecorationCollection Clone();
    public TextDecorationCollection CloneCurrentValue();
    public sealed virtual void Add(TextDecoration value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextDecoration value);
    public sealed virtual int IndexOf(TextDecoration value);
    public sealed virtual void Insert(int index, TextDecoration value);
    public sealed virtual bool Remove(TextDecoration value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual TextDecoration get_Item(int index);
    public sealed virtual void set_Item(int index, TextDecoration value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(TextDecoration[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextDecoration> System.Collections.Generic.IEnumerable<System.Windows.TextDecoration>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TextDecorationCollection get_Empty();
    internal TextDecoration Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal int AddWithoutFiringPublicEvents(TextDecoration value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.TextDecorationCollectionConverter : TypeConverter {
    private static TextDecorationCollectionConverter();
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object input);
    public static TextDecorationCollection ConvertFromString(string text);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.TextDecorationLocation : Enum {
    public int value__;
    public static TextDecorationLocation Underline;
    public static TextDecorationLocation OverLine;
    public static TextDecorationLocation Strikethrough;
    public static TextDecorationLocation Baseline;
}
public static class System.Windows.TextDecorations : object {
    public static TextDecorationCollection Underline { get; }
    public static TextDecorationCollection Strikethrough { get; }
    public static TextDecorationCollection OverLine { get; }
    public static TextDecorationCollection Baseline { get; }
    private static TextDecorations();
    public static TextDecorationCollection get_Underline();
    public static TextDecorationCollection get_Strikethrough();
    public static TextDecorationCollection get_OverLine();
    public static TextDecorationCollection get_Baseline();
}
public enum System.Windows.TextDecorationUnit : Enum {
    public int value__;
    public static TextDecorationUnit FontRecommended;
    public static TextDecorationUnit FontRenderingEmSize;
    public static TextDecorationUnit Pixel;
}
public enum System.Windows.TextMarkerStyle : Enum {
    public int value__;
    public static TextMarkerStyle None;
    public static TextMarkerStyle Disc;
    public static TextMarkerStyle Circle;
    public static TextMarkerStyle Square;
    public static TextMarkerStyle Box;
    public static TextMarkerStyle LowerRoman;
    public static TextMarkerStyle UpperRoman;
    public static TextMarkerStyle LowerLatin;
    public static TextMarkerStyle UpperLatin;
    public static TextMarkerStyle Decimal;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextTrimming : Enum {
    public int value__;
    public static TextTrimming None;
    public static TextTrimming CharacterEllipsis;
    public static TextTrimming WordEllipsis;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextWrapping : Enum {
    public int value__;
    public static TextWrapping WrapWithOverflow;
    public static TextWrapping NoWrap;
    public static TextWrapping Wrap;
}
[UidPropertyAttribute("Uid")]
public class System.Windows.UIElement : Visual {
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    internal static DependencyPropertyKey IsMouseDirectlyOverPropertyKey;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    internal static EventPrivateKey IsMouseDirectlyOverChangedKey;
    internal static DependencyPropertyKey IsMouseOverPropertyKey;
    public static DependencyProperty IsMouseOverProperty;
    internal static DependencyPropertyKey IsStylusOverPropertyKey;
    public static DependencyProperty IsStylusOverProperty;
    internal static DependencyPropertyKey IsKeyboardFocusWithinPropertyKey;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    internal static EventPrivateKey IsKeyboardFocusWithinChangedKey;
    internal static DependencyPropertyKey IsMouseCapturedPropertyKey;
    public static DependencyProperty IsMouseCapturedProperty;
    internal static EventPrivateKey IsMouseCapturedChangedKey;
    internal static DependencyPropertyKey IsMouseCaptureWithinPropertyKey;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    internal static EventPrivateKey IsMouseCaptureWithinChangedKey;
    internal static DependencyPropertyKey IsStylusDirectlyOverPropertyKey;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    internal static EventPrivateKey IsStylusDirectlyOverChangedKey;
    internal static DependencyPropertyKey IsStylusCapturedPropertyKey;
    public static DependencyProperty IsStylusCapturedProperty;
    internal static EventPrivateKey IsStylusCapturedChangedKey;
    internal static DependencyPropertyKey IsStylusCaptureWithinPropertyKey;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    internal static EventPrivateKey IsStylusCaptureWithinChangedKey;
    internal static DependencyPropertyKey IsKeyboardFocusedPropertyKey;
    public static DependencyProperty IsKeyboardFocusedProperty;
    internal static EventPrivateKey IsKeyboardFocusedChangedKey;
    internal static DependencyPropertyKey AreAnyTouchesDirectlyOverPropertyKey;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    internal static DependencyPropertyKey AreAnyTouchesOverPropertyKey;
    public static DependencyProperty AreAnyTouchesOverProperty;
    internal static DependencyPropertyKey AreAnyTouchesCapturedPropertyKey;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    internal static DependencyPropertyKey AreAnyTouchesCapturedWithinPropertyKey;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AllowDropProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RenderTransformProperty;
    public static DependencyProperty RenderTransformOriginProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty EffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    public static DependencyProperty CacheModeProperty;
    public static DependencyProperty UidProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VisibilityProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ClipToBoundsProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    internal static DependencyPropertyKey IsFocusedPropertyKey;
    public static DependencyProperty IsFocusedProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsEnabledProperty;
    internal static EventPrivateKey IsEnabledChangedKey;
    public static DependencyProperty IsHitTestVisibleProperty;
    internal static EventPrivateKey IsHitTestVisibleChangedKey;
    internal static DependencyPropertyKey IsVisiblePropertyKey;
    public static DependencyProperty IsVisibleProperty;
    internal static EventPrivateKey IsVisibleChangedKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    internal static EventPrivateKey FocusableChangedKey;
    public static DependencyProperty IsManipulationEnabledProperty;
    public static RoutedEvent ManipulationStartingEvent;
    public static RoutedEvent ManipulationStartedEvent;
    public static RoutedEvent ManipulationDeltaEvent;
    public static RoutedEvent ManipulationInertiaStartingEvent;
    public static RoutedEvent ManipulationBoundaryFeedbackEvent;
    public static RoutedEvent ManipulationCompletedEvent;
    internal Request MeasureRequest;
    internal Request ArrangeRequest;
    internal static List`1<double> DpiScaleXValues;
    internal static List`1<double> DpiScaleYValues;
    internal static object DpiLock;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    internal SizeChangedInfo sizeChangedInfo;
    internal static FocusWithinProperty FocusWithinProperty;
    internal static MouseOverProperty MouseOverProperty;
    internal static MouseCaptureWithinProperty MouseCaptureWithinProperty;
    internal static StylusOverProperty StylusOverProperty;
    internal static StylusCaptureWithinProperty StylusCaptureWithinProperty;
    internal static TouchesOverProperty TouchesOverProperty;
    internal static TouchesCapturedWithinProperty TouchesCapturedWithinProperty;
    internal static int MAX_ELEMENTS_IN_ROUTE;
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    public bool AllowDrop { get; public set; }
    protected StylusPlugInCollection StylusPlugIns { get; }
    public Size DesiredSize { get; }
    internal Size PreviousConstraint { get; }
    public bool IsMeasureValid { get; }
    public bool IsArrangeValid { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Size RenderSize { get; public set; }
    public Transform RenderTransform { get; public set; }
    public Point RenderTransformOrigin { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    public Effect Effect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public string Uid { get; public set; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool ClipToBounds { get; public set; }
    public Geometry Clip { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    [ObsoleteAttribute("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")]
[DesignerSerializationVisibilityAttribute("0")]
public int PersistId { get; }
    internal Rect PreviousArrangeRect { get; }
    [CustomCategoryAttribute("Touch_Category")]
public bool IsManipulationEnabled { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal bool HasAutomationPeer { get; internal set; }
    internal bool SnapsToDevicePixelsCache { get; internal set; }
    internal bool ClipToBoundsCache { get; internal set; }
    internal bool MeasureDirty { get; internal set; }
    internal bool ArrangeDirty { get; internal set; }
    internal bool MeasureInProgress { get; internal set; }
    internal bool ArrangeInProgress { get; internal set; }
    internal bool NeverMeasured { get; internal set; }
    internal bool NeverArranged { get; internal set; }
    internal bool MeasureDuringArrange { get; internal set; }
    internal bool AreTransformsClean { get; internal set; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static UIElement();
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    [SecurityCriticalAttribute]
internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    [SecurityCriticalAttribute]
internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RegisterEvents(Type type);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchLeave(TouchEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    protected StylusPlugInCollection get_StylusPlugIns();
    public Size get_DesiredSize();
    internal Size get_PreviousConstraint();
    internal void InvalidateMeasureInternal();
    internal void InvalidateArrangeInternal();
    public bool get_IsMeasureValid();
    public bool get_IsArrangeValid();
    public void InvalidateMeasure();
    public void InvalidateArrange();
    public void InvalidateVisual();
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    public void add_LayoutUpdated(EventHandler value);
    public void remove_LayoutUpdated(EventHandler value);
    internal static void PropagateSuspendLayout(Visual v);
    internal static void PropagateResumeLayout(Visual parent, Visual v);
    public void Measure(Size availableSize);
    internal void GetUIParentOrICH(UIElement& uiParent, IContentHost& ich);
    internal UIElement GetUIParentWithinLayoutIsland();
    public void Arrange(Rect finalRect);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal static Size RoundLayoutSize(Size size, double dpiScaleX, double dpiScaleY);
    internal static double RoundLayoutValue(double value, double dpiScale);
    internal static Rect RoundLayoutRect(Rect rect, double dpiScaleX, double dpiScaleY);
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
internal static DpiScale EnsureDpiScale();
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo info);
    protected virtual Size MeasureCore(Size availableSize);
    protected virtual void ArrangeCore(Rect finalRect);
    public Size get_RenderSize();
    public void set_RenderSize(Size value);
    internal virtual Rect GetHitTestBounds();
    public Transform get_RenderTransform();
    public void set_RenderTransform(Transform value);
    public Point get_RenderTransformOrigin();
    public void set_RenderTransformOrigin(Point value);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    internal DependencyObject GetUIParent();
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    internal DependencyObject GetUIParentNo3DTraversal();
    protected internal virtual DependencyObject GetUIParentCore();
    public void UpdateLayout();
    internal static void BuildRouteHelper(DependencyObject e, EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal virtual void AddSynchronizedInputPreOpportunityHandlerCore(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    [FriendAccessAllowedAttribute]
internal static void AddHandler(DependencyObject d, RoutedEvent routedEvent, Delegate handler);
    [FriendAccessAllowedAttribute]
internal static void RemoveHandler(DependencyObject d, RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnPresentationSourceChanged(bool attached);
    public Point TranslatePoint(Point point, UIElement relativeTo);
    public IInputElement InputHitTest(Point point);
    internal void InputHitTest(Point pt, IInputElement& enabledHit, IInputElement& rawHit);
    internal void InputHitTest(Point pt, IInputElement& enabledHit, IInputElement& rawHit, HitTestResult& rawHitResult);
    internal static void RaiseEventImpl(DependencyObject sender, RoutedEventArgs args);
    public sealed virtual bool get_IsMouseDirectlyOver();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public bool get_IsInputMethodEnabled();
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public string get_Uid();
    public void set_Uid(string value);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    [FriendAccessAllowedAttribute]
internal DrawingContext RenderOpen();
    internal virtual void RenderClose(IDrawingContent newContent);
    [SecurityCriticalAttribute]
internal virtual void FreeContent(Channel channel);
    internal virtual Rect GetContentBounds();
    internal void WalkContent(DrawingContextWalker walker);
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual DrawingGroup GetDrawing();
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    internal void InvokeAccessKey(AccessKeyEventArgs e);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public bool get_IsVisible();
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateIsVisibleCache();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal AutomationPeer CreateGenericRootAutomationPeer();
    public int get_PersistId();
    [FriendAccessAllowedAttribute]
internal void SetPersistId(int value);
    [FriendAccessAllowedAttribute]
internal Rect get_PreviousArrangeRect();
    internal static void SynchronizeForceInheritProperties(UIElement uiElement, ContentElement contentElement, UIElement3D uiElement3D, DependencyObject parent);
    internal static void InvalidateForceInheritPropertyOnChildren(Visual v, DependencyProperty property);
    public bool get_IsManipulationEnabled();
    public void set_IsManipulationEnabled(bool value);
    public void add_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    public void remove_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    public void add_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    public void remove_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);
    public void add_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    public void remove_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    public void add_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    public void remove_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    public void add_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    public void remove_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    public void add_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    public void remove_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
    internal bool get_SnapsToDevicePixelsCache();
    internal void set_SnapsToDevicePixelsCache(bool value);
    internal bool get_ClipToBoundsCache();
    internal void set_ClipToBoundsCache(bool value);
    internal bool get_MeasureDirty();
    internal void set_MeasureDirty(bool value);
    internal bool get_ArrangeDirty();
    internal void set_ArrangeDirty(bool value);
    internal bool get_MeasureInProgress();
    internal void set_MeasureInProgress(bool value);
    internal bool get_ArrangeInProgress();
    internal void set_ArrangeInProgress(bool value);
    internal bool get_NeverMeasured();
    internal void set_NeverMeasured(bool value);
    internal bool get_NeverArranged();
    internal void set_NeverArranged(bool value);
    internal bool get_MeasureDuringArrange();
    internal void set_MeasureDuringArrange(bool value);
    internal bool get_AreTransformsClean();
    internal void set_AreTransformsClean(bool value);
}
public abstract class System.Windows.UIElement3D : Visual3D {
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    public static DependencyProperty AllowDropProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VisibilityProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    internal static EventPrivateKey IsHitTestVisibleChangedKey;
    public static DependencyProperty IsVisibleProperty;
    internal static EventPrivateKey IsVisibleChangedKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    public bool AllowDrop { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal bool HasAutomationPeer { get; internal set; }
    [SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute]
private static UIElement3D();
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    [SecurityCriticalAttribute]
internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    [SecurityCriticalAttribute]
internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected internal virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected internal virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    public void InvalidateModel();
    protected virtual void OnUpdateModel();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    protected internal DependencyObject GetUIParentCore();
    internal virtual void OnPresentationSourceChanged(bool attached);
    public sealed virtual bool get_IsMouseDirectlyOver();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public bool get_IsInputMethodEnabled();
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    internal void InvokeAccessKey(AccessKeyEventArgs e);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public bool get_IsVisible();
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateIsVisibleCache();
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    internal static void InvalidateForceInheritPropertyOnChildren(Visual3D v, DependencyProperty property);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
}
public class System.Windows.UIPropertyMetadata : PropertyMetadata {
    public bool IsAnimationProhibited { get; public set; }
    public UIPropertyMetadata(object defaultValue);
    public UIPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    internal virtual PropertyMetadata CreateInstance();
    public bool get_IsAnimationProhibited();
    public void set_IsAnimationProhibited(bool value);
}
internal static class System.Windows.ValidateEnums : object {
    public static bool IsTextDecorationLocationValid(object valueObject);
    public static bool IsTextDecorationUnitValid(object valueObject);
}
public enum System.Windows.Visibility : Enum {
    public byte value__;
    public static Visibility Visible;
    public static Visibility Hidden;
    public static Visibility Collapsed;
}
[NativeCppClassAttribute]
internal enum vc_attributes.AccessType : Enum {
    public int value__;
}
[NativeCppClassAttribute]
internal enum vc_attributes.YesNoMaybe : Enum {
    public int value__;
}
