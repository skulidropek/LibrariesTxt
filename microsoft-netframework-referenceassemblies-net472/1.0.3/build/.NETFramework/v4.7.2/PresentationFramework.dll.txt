public abstract class Microsoft.Win32.CommonDialog : object {
    public object Tag { get; public set; }
    [SecurityCriticalAttribute]
public abstract virtual void Reset();
    [SecurityCriticalAttribute]
public virtual Nullable`1<bool> ShowDialog();
    [SecurityCriticalAttribute]
public Nullable`1<bool> ShowDialog(Window owner);
    public object get_Tag();
    public void set_Tag(object value);
    [SecurityCriticalAttribute]
protected virtual IntPtr HookProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    protected abstract virtual bool RunDialog(IntPtr hwndOwner);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CheckPermissionsToShowDialog();
    [SecurityCriticalAttribute]
internal void MoveToScreenCenter(HandleRef hWnd);
}
public abstract class Microsoft.Win32.FileDialog : CommonDialog {
    public bool AddExtension { get; public set; }
    public bool CheckFileExists { get; public set; }
    public bool CheckPathExists { get; public set; }
    public string DefaultExt { get; public set; }
    public bool DereferenceLinks { get; public set; }
    public string SafeFileName { get; }
    public String[] SafeFileNames { get; }
    public string FileName { get; public set; }
    public String[] FileNames { get; }
    public string Filter { get; public set; }
    public int FilterIndex { get; public set; }
    public string InitialDirectory { get; public set; }
    public bool RestoreDirectory { get; public set; }
    public string Title { get; public set; }
    public bool ValidateNames { get; public set; }
    internal String[] FileNamesInternal { get; }
    protected int Options { get; }
    public IList`1<FileDialogCustomPlace> CustomPlaces { get; public set; }
    [SecurityCriticalAttribute]
public virtual void Reset();
    public virtual string ToString();
    public bool get_AddExtension();
    [SecurityCriticalAttribute]
public void set_AddExtension(bool value);
    public virtual bool get_CheckFileExists();
    [SecurityCriticalAttribute]
public virtual void set_CheckFileExists(bool value);
    public bool get_CheckPathExists();
    [SecurityCriticalAttribute]
public void set_CheckPathExists(bool value);
    public string get_DefaultExt();
    public void set_DefaultExt(string value);
    public bool get_DereferenceLinks();
    [SecurityCriticalAttribute]
public void set_DereferenceLinks(bool value);
    [SecurityCriticalAttribute]
public string get_SafeFileName();
    [SecurityCriticalAttribute]
public String[] get_SafeFileNames();
    [SecurityCriticalAttribute]
public string get_FileName();
    [SecurityCriticalAttribute]
public void set_FileName(string value);
    [SecurityCriticalAttribute]
public String[] get_FileNames();
    public string get_Filter();
    public void set_Filter(string value);
    public int get_FilterIndex();
    public void set_FilterIndex(int value);
    public string get_InitialDirectory();
    [SecurityCriticalAttribute]
public void set_InitialDirectory(string value);
    public bool get_RestoreDirectory();
    [SecurityCriticalAttribute]
public void set_RestoreDirectory(bool value);
    public string get_Title();
    [SecurityCriticalAttribute]
public void set_Title(string value);
    public bool get_ValidateNames();
    [SecurityCriticalAttribute]
public void set_ValidateNames(bool value);
    [CompilerGeneratedAttribute]
public void add_FileOk(CancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FileOk(CancelEventHandler value);
    [SecurityCriticalAttribute]
protected virtual IntPtr HookProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    protected void OnFileOk(CancelEventArgs e);
    [SecurityCriticalAttribute]
protected virtual bool RunDialog(IntPtr hwndOwner);
    internal bool GetOption(int option);
    [SecurityCriticalAttribute]
internal void SetOption(int option, bool value);
    [SecurityCriticalAttribute]
internal bool MessageBoxWithFocusRestore(string message, MessageBoxButton buttons, MessageBoxImage image);
    [SecurityCriticalAttribute]
internal virtual bool PromptUserIfAppropriate(string fileName);
    internal abstract virtual bool RunFileDialog(OPENFILENAME_I ofn);
    [SecurityCriticalAttribute]
internal String[] get_FileNamesInternal();
    protected int get_Options();
    [CompilerGeneratedAttribute]
public IList`1<FileDialogCustomPlace> get_CustomPlaces();
    [CompilerGeneratedAttribute]
public void set_CustomPlaces(IList`1<FileDialogCustomPlace> value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal abstract virtual IFileDialog CreateVistaDialog();
    [SecurityCriticalAttribute]
internal abstract virtual String[] ProcessVistaFiles(IFileDialog dialog);
    [SecurityCriticalAttribute]
internal virtual void PrepareVistaDialog(IFileDialog dialog);
}
public class Microsoft.Win32.FileDialogCustomPlace : object {
    public Guid KnownFolder { get; private set; }
    public string Path { get; private set; }
    public FileDialogCustomPlace(Guid knownFolder);
    public FileDialogCustomPlace(string path);
    [CompilerGeneratedAttribute]
public Guid get_KnownFolder();
    [CompilerGeneratedAttribute]
private void set_KnownFolder(Guid value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public static class Microsoft.Win32.FileDialogCustomPlaces : object {
    public static FileDialogCustomPlace RoamingApplicationData { get; }
    public static FileDialogCustomPlace LocalApplicationData { get; }
    public static FileDialogCustomPlace Cookies { get; }
    public static FileDialogCustomPlace Contacts { get; }
    public static FileDialogCustomPlace Favorites { get; }
    public static FileDialogCustomPlace Programs { get; }
    public static FileDialogCustomPlace Music { get; }
    public static FileDialogCustomPlace Pictures { get; }
    public static FileDialogCustomPlace SendTo { get; }
    public static FileDialogCustomPlace StartMenu { get; }
    public static FileDialogCustomPlace Startup { get; }
    public static FileDialogCustomPlace System { get; }
    public static FileDialogCustomPlace Templates { get; }
    public static FileDialogCustomPlace Desktop { get; }
    public static FileDialogCustomPlace Documents { get; }
    public static FileDialogCustomPlace ProgramFiles { get; }
    public static FileDialogCustomPlace ProgramFilesCommon { get; }
    public static FileDialogCustomPlace get_RoamingApplicationData();
    public static FileDialogCustomPlace get_LocalApplicationData();
    public static FileDialogCustomPlace get_Cookies();
    public static FileDialogCustomPlace get_Contacts();
    public static FileDialogCustomPlace get_Favorites();
    public static FileDialogCustomPlace get_Programs();
    public static FileDialogCustomPlace get_Music();
    public static FileDialogCustomPlace get_Pictures();
    public static FileDialogCustomPlace get_SendTo();
    public static FileDialogCustomPlace get_StartMenu();
    public static FileDialogCustomPlace get_Startup();
    public static FileDialogCustomPlace get_System();
    public static FileDialogCustomPlace get_Templates();
    public static FileDialogCustomPlace get_Desktop();
    public static FileDialogCustomPlace get_Documents();
    public static FileDialogCustomPlace get_ProgramFiles();
    public static FileDialogCustomPlace get_ProgramFilesCommon();
}
public class Microsoft.Win32.OpenFileDialog : FileDialog {
    public bool Multiselect { get; public set; }
    public bool ReadOnlyChecked { get; public set; }
    public bool ShowReadOnly { get; public set; }
    [SecurityCriticalAttribute]
public Stream OpenFile();
    [SecurityCriticalAttribute]
public Stream[] OpenFiles();
    [SecurityCriticalAttribute]
public virtual void Reset();
    public bool get_Multiselect();
    [SecurityCriticalAttribute]
public void set_Multiselect(bool value);
    public bool get_ReadOnlyChecked();
    [SecurityCriticalAttribute]
public void set_ReadOnlyChecked(bool value);
    public bool get_ShowReadOnly();
    [SecurityCriticalAttribute]
public void set_ShowReadOnly(bool value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void CheckPermissionsToShowDialog();
    [SecurityCriticalAttribute]
internal virtual bool RunFileDialog(OPENFILENAME_I ofn);
    [SecurityCriticalAttribute]
internal virtual String[] ProcessVistaFiles(IFileDialog dialog);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IFileDialog CreateVistaDialog();
}
public class Microsoft.Win32.SaveFileDialog : FileDialog {
    public bool CreatePrompt { get; public set; }
    public bool OverwritePrompt { get; public set; }
    [SecurityCriticalAttribute]
public Stream OpenFile();
    [SecurityCriticalAttribute]
public virtual void Reset();
    public bool get_CreatePrompt();
    [SecurityCriticalAttribute]
public void set_CreatePrompt(bool value);
    public bool get_OverwritePrompt();
    [SecurityCriticalAttribute]
public void set_OverwritePrompt(bool value);
    [SecurityCriticalAttribute]
internal virtual bool PromptUserIfAppropriate(string fileName);
    [SecurityCriticalAttribute]
internal virtual bool RunFileDialog(OPENFILENAME_I ofn);
    [SecurityCriticalAttribute]
internal virtual String[] ProcessVistaFiles(IFileDialog dialog);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IFileDialog CreateVistaDialog();
}
internal class MS.Internal.Annotations.Anchoring.AttachedAnnotation : object {
    public Annotation Annotation { get; }
    public AnnotationResource Anchor { get; }
    public object AttachedAnchor { get; }
    public object ResolvedAnchor { get; }
    public object FullyAttachedAnchor { get; }
    public AttachmentLevel AttachmentLevel { get; }
    public DependencyObject Parent { get; }
    public Point AnchorPoint { get; }
    public AnnotationStore Store { get; }
    internal AttachedAnnotation(LocatorManager manager, Annotation annotation, AnnotationResource anchor, object attachedAnchor, AttachmentLevel attachmentLevel);
    internal AttachedAnnotation(LocatorManager manager, Annotation annotation, AnnotationResource anchor, object attachedAnchor, AttachmentLevel attachmentLevel, DependencyObject parent);
    public sealed virtual bool IsAnchorEqual(object o);
    public sealed virtual Annotation get_Annotation();
    public sealed virtual AnnotationResource get_Anchor();
    public sealed virtual object get_AttachedAnchor();
    public sealed virtual object get_ResolvedAnchor();
    public sealed virtual object get_FullyAttachedAnchor();
    public sealed virtual AttachmentLevel get_AttachmentLevel();
    public sealed virtual DependencyObject get_Parent();
    public sealed virtual Point get_AnchorPoint();
    public sealed virtual AnnotationStore get_Store();
    internal void Update(object attachedAnchor, AttachmentLevel attachmentLevel, DependencyObject parent);
    internal void SetFullyAttachedAnchor(object fullyAttachedAnchor);
}
internal class MS.Internal.Annotations.Anchoring.DataIdProcessor : SubTreeProcessor {
    public static string Id;
    public static DependencyProperty DataIdProperty;
    public static DependencyProperty FetchAnnotationsAsBatchProperty;
    public DataIdProcessor(LocatorManager manager);
    private static DataIdProcessor();
    public virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual IList`1<IAttachedAnnotation> PostProcessNode(DependencyObject node, bool childrenCalledProcessAnnotations, Boolean& calledProcessAnnotations);
    public virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    public static void SetDataId(DependencyObject d, string id);
    [DesignerSerializationVisibilityAttribute("0")]
public static string GetDataId(DependencyObject d);
    public static void SetFetchAnnotationsAsBatch(DependencyObject d, bool id);
    [DesignerSerializationVisibilityAttribute("0")]
public static bool GetFetchAnnotationsAsBatch(DependencyObject d);
    internal string GetNodeId(DependencyObject d);
}
internal class MS.Internal.Annotations.Anchoring.FixedPageProcessor : SubTreeProcessor {
    public static string Id;
    unknown bool UseLogicalTree {internal set; }
    public FixedPageProcessor(LocatorManager manager);
    private static FixedPageProcessor();
    public virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal void set_UseLogicalTree(bool value);
    internal static ContentLocatorPart CreateLocatorPart(int page);
}
internal class MS.Internal.Annotations.Anchoring.FixedTextSelectionProcessor : SelectionProcessor {
    private static FixedTextSelectionProcessor();
    public virtual bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
}
internal class MS.Internal.Annotations.Anchoring.LocatorManager : DispatcherObject {
    public static DependencyProperty SubTreeProcessorIdProperty;
    public LocatorManager(AnnotationStore store);
    private static LocatorManager();
    public void RegisterSubTreeProcessor(SubTreeProcessor processor, string processorId);
    public SubTreeProcessor GetSubTreeProcessor(DependencyObject node);
    public SubTreeProcessor GetSubTreeProcessorForLocatorPart(ContentLocatorPart locatorPart);
    public void RegisterSelectionProcessor(SelectionProcessor processor, Type selectionType);
    public SelectionProcessor GetSelectionProcessor(Type selectionType);
    public SelectionProcessor GetSelectionProcessorForLocatorPart(ContentLocatorPart locatorPart);
    public IList`1<IAttachedAnnotation> ProcessAnnotations(DependencyObject node);
    public IList`1<ContentLocatorBase> GenerateLocators(object selection);
    public object ResolveLocator(ContentLocatorBase locator, int offset, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public static void SetSubTreeProcessorId(DependencyObject d, string id);
    [DesignerSerializationVisibilityAttribute("0")]
public static string GetSubTreeProcessorId(DependencyObject d);
    internal IList`1<IAttachedAnnotation> ProcessSubTree(DependencyObject subTree);
    internal object FindAttachedAnchor(DependencyObject startNode, ContentLocator[] prefixes, ContentLocatorBase locator, AttachmentLevel& attachmentLevel);
}
internal class MS.Internal.Annotations.Anchoring.PathNode : object {
    internal static DependencyProperty HiddenParentProperty;
    public DependencyObject Node { get; }
    public IList Children { get; }
    internal PathNode(DependencyObject node);
    private static PathNode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DependencyObject get_Node();
    public IList get_Children();
    internal static PathNode BuildPathForElements(ICollection nodes);
    internal static DependencyObject GetParent(DependencyObject node);
}
internal abstract class MS.Internal.Annotations.Anchoring.SelectionProcessor : object {
    public abstract virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public abstract virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public abstract virtual UIElement GetParent(object selection);
    public abstract virtual Point GetAnchorPoint(object selection);
    public abstract virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public abstract virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public abstract virtual XmlQualifiedName[] GetLocatorPartTypes();
}
internal abstract class MS.Internal.Annotations.Anchoring.SubTreeProcessor : object {
    protected LocatorManager Manager { get; }
    protected SubTreeProcessor(LocatorManager manager);
    public abstract virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual IList`1<IAttachedAnnotation> PostProcessNode(DependencyObject node, bool childrenCalledProcessAnnotations, Boolean& calledProcessAnnotations);
    public abstract virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public abstract virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public abstract virtual XmlQualifiedName[] GetLocatorPartTypes();
    protected LocatorManager get_Manager();
}
internal class MS.Internal.Annotations.Anchoring.TextSelectionHelper : object {
    public static bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public static IList`1<DependencyObject> GetSelectedNodes(object selection);
    public static UIElement GetParent(object selection);
    public static UIElement GetParent(ITextPointer pointer);
    public static Point GetAnchorPoint(object selection);
    public static Point GetAnchorPointForPointer(ITextPointer pointer);
    public static Point GetPointForPointer(ITextPointer pointer);
    public static Rect GetAnchorRectangle(ITextPointer pointer);
    public static IDocumentPaginatorSource GetPointerPage(ITextPointer pointer, Int32& pageNumber);
    internal static void CheckSelection(object selection, ITextPointer& start, ITextPointer& end, IList`1& segments);
    internal static ITextView GetDocumentPageTextView(ITextPointer pointer);
    internal static List`1<ITextView> GetDocumentPageTextViews(TextSegment segment);
}
internal class MS.Internal.Annotations.Anchoring.TextSelectionProcessor : SelectionProcessor {
    internal static string SegmentAttribute;
    internal static string CountAttribute;
    internal static string IncludeOverlaps;
    internal static Char[] Separator;
    internal static XmlQualifiedName CharacterRangeElementName;
    unknown bool Clamping {internal set; }
    private static TextSelectionProcessor();
    public virtual bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal void set_Clamping(bool value);
    internal static void GetMaxMinLocatorPartValues(ContentLocatorPart locatorPart, Int32& startOffset, Int32& endOffset);
    internal void SetTargetDocumentPageView(DocumentPageView target);
}
internal class MS.Internal.Annotations.Anchoring.TextViewSelectionProcessor : SelectionProcessor {
    private static TextViewSelectionProcessor();
    public virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal static TextRange GetTextViewTextRange(ITextView textView, Int32& startOffset, Int32& endOffset);
}
internal class MS.Internal.Annotations.Anchoring.TreeNodeSelectionProcessor : SelectionProcessor {
    private static TreeNodeSelectionProcessor();
    public virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
}
internal class MS.Internal.Annotations.AnnotationMap : object {
    internal bool IsEmpty { get; }
    private static AnnotationMap();
    internal void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    internal void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    internal bool get_IsEmpty();
    internal List`1<IAttachedAnnotation> GetAttachedAnnotations(Guid annotationId);
    internal List`1<IAttachedAnnotation> GetAllAttachedAnnotations();
}
internal class MS.Internal.Annotations.AnnotationObservableCollection`1 : ObservableCollection`1<T> {
    internal string CountString;
    internal string IndexerName;
    public AnnotationObservableCollection`1(List`1<T> list);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
    protected virtual void ProtectedClearItems();
    protected virtual void ProtectedSetItem(int index, T item);
    protected void ObservableCollectionSetItem(int index, T item);
    protected virtual void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e);
}
internal class MS.Internal.Annotations.AnnotationResourceCollection : AnnotationObservableCollection`1<AnnotationResource> {
    [CompilerGeneratedAttribute]
public void add_ItemChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ItemChanged(PropertyChangedEventHandler value);
    protected virtual void ProtectedClearItems();
    protected virtual void ProtectedSetItem(int index, AnnotationResource item);
    protected virtual void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e);
}
internal class MS.Internal.Annotations.AnnotationXmlConstants : ValueType {
}
internal enum MS.Internal.Annotations.AttachedAnnotationAction : Enum {
    public int value__;
    public static AttachedAnnotationAction Loaded;
    public static AttachedAnnotationAction Unloaded;
    public static AttachedAnnotationAction AnchorModified;
    public static AttachedAnnotationAction Added;
    public static AttachedAnnotationAction Deleted;
}
internal class MS.Internal.Annotations.AttachedAnnotationChangedEventArgs : EventArgs {
    public AttachedAnnotationAction Action { get; }
    public IAttachedAnnotation AttachedAnnotation { get; }
    public object PreviousAttachedAnchor { get; }
    public AttachmentLevel PreviousAttachmentLevel { get; }
    internal AttachedAnnotationChangedEventArgs(AttachedAnnotationAction action, IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public AttachedAnnotationAction get_Action();
    public IAttachedAnnotation get_AttachedAnnotation();
    public object get_PreviousAttachedAnchor();
    public AttachmentLevel get_PreviousAttachmentLevel();
    internal static AttachedAnnotationChangedEventArgs Added(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Loaded(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Deleted(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Unloaded(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Modified(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
}
internal class MS.Internal.Annotations.AttachedAnnotationChangedEventHandler : MulticastDelegate {
    public AttachedAnnotationChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AttachedAnnotationChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AttachedAnnotationChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum MS.Internal.Annotations.AttachmentLevel : Enum {
    public int value__;
    public static AttachmentLevel Full;
    public static AttachmentLevel StartPortion;
    public static AttachmentLevel MiddlePortion;
    public static AttachmentLevel EndPortion;
    public static AttachmentLevel Incomplete;
    public static AttachmentLevel Unresolved;
}
internal class MS.Internal.Annotations.Component.AdornerPresentationContext : PresentationContext {
    public UIElement Host { get; }
    public PresentationContext EnclosingContext { get; }
    private static AdornerPresentationContext();
    internal static void HostComponent(AdornerLayer adornerLayer, IAnnotationComponent component, UIElement annotatedElement, bool reorder);
    internal static void SetTypeZLevel(Type type, int level);
    internal static void SetZLevelRange(int level, int min, int max);
    public virtual UIElement get_Host();
    public virtual PresentationContext get_EnclosingContext();
    public virtual void AddToHost(IAnnotationComponent component);
    public virtual void RemoveFromHost(IAnnotationComponent component, bool reorder);
    public virtual void InvalidateTransform(IAnnotationComponent component);
    public virtual void BringToFront(IAnnotationComponent component);
    public virtual void SendToBack(IAnnotationComponent component);
    public virtual bool Equals(object o);
    public static bool op_Equality(AdornerPresentationContext left, AdornerPresentationContext right);
    public static bool op_Inequality(AdornerPresentationContext c1, AdornerPresentationContext c2);
    public virtual int GetHashCode();
    public void UpdateComponentZOrder(IAnnotationComponent component);
}
internal class MS.Internal.Annotations.Component.AnnotationAdorner : Adorner {
    protected int VisualChildrenCount { get; }
    internal IAnnotationComponent AnnotationComponent { get; }
    public AnnotationAdorner(IAnnotationComponent component, UIElement annotatedElement);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal void RemoveChildren();
    internal void InvalidateTransform();
    internal IAnnotationComponent get_AnnotationComponent();
}
internal class MS.Internal.Annotations.Component.AnnotationComponentManager : DependencyObject {
    internal AnnotationComponentManager(AnnotationService service);
    internal void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation, bool reorder);
    internal void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation, bool reorder);
}
internal class MS.Internal.Annotations.Component.AnnotationHighlightLayer : HighlightLayer {
    internal Type OwnerType { get; }
    internal void AddRange(IHighlightRange highlightRange);
    internal void RemoveRange(IHighlightRange highlightRange);
    internal void ModifiedRange(IHighlightRange highlightRange);
    internal void ActivateRange(IHighlightRange highlightRange, bool activate);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer staticTextPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class MS.Internal.Annotations.Component.HighlightComponent : Canvas {
    public static DependencyProperty HighlightBrushProperty;
    public static string HighlightResourceName;
    public static string ColorsContentName;
    public static string BackgroundAttributeName;
    public static string ActiveBackgroundAttributeName;
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public static XmlQualifiedName TypeName { get; }
    public Color DefaultBackground { get; public set; }
    public Color DefaultActiveBackground { get; public set; }
    unknown Brush HighlightBrush {public set; }
    public UIElement AnnotatedElement { get; }
    public bool IsDirty { get; public set; }
    private Color MS.Internal.Annotations.Component.IHighlightRange.Background { get; }
    private Color MS.Internal.Annotations.Component.IHighlightRange.SelectedBackground { get; }
    private TextAnchor MS.Internal.Annotations.Component.IHighlightRange.Range { get; }
    private int MS.Internal.Annotations.Component.IHighlightRange.Priority { get; }
    private bool MS.Internal.Annotations.Component.IHighlightRange.HighlightContent { get; }
    public HighlightComponent(int priority, bool highlightContent, XmlQualifiedName type);
    private static HighlightComponent();
    public sealed virtual IList get_AttachedAnnotations();
    public sealed virtual PresentationContext get_PresentationContext();
    public sealed virtual void set_PresentationContext(PresentationContext value);
    public sealed virtual int get_ZOrder();
    public sealed virtual void set_ZOrder(int value);
    public static XmlQualifiedName get_TypeName();
    public Color get_DefaultBackground();
    public void set_DefaultBackground(Color value);
    public Color get_DefaultActiveBackground();
    public void set_DefaultActiveBackground(Color value);
    public void set_HighlightBrush(Brush value);
    public sealed virtual UIElement get_AnnotatedElement();
    public sealed virtual bool get_IsDirty();
    public sealed virtual void set_IsDirty(bool value);
    public sealed virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public sealed virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public void Activate(bool active);
    private sealed virtual override void MS.Internal.Annotations.Component.IHighlightRange.AddChild(Shape child);
    private sealed virtual override void MS.Internal.Annotations.Component.IHighlightRange.RemoveChild(Shape child);
    private sealed virtual override Color MS.Internal.Annotations.Component.IHighlightRange.get_Background();
    private sealed virtual override Color MS.Internal.Annotations.Component.IHighlightRange.get_SelectedBackground();
    private sealed virtual override TextAnchor MS.Internal.Annotations.Component.IHighlightRange.get_Range();
    private sealed virtual override int MS.Internal.Annotations.Component.IHighlightRange.get_Priority();
    private sealed virtual override bool MS.Internal.Annotations.Component.IHighlightRange.get_HighlightContent();
    internal bool IsSelected(ITextRange selection);
    internal static void GetCargoColors(Annotation annot, Nullable`1& backgroundColor, Nullable`1& activeBackgroundColor);
}
internal interface MS.Internal.Annotations.Component.IAnnotationComponent {
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public bool IsDirty { get; public set; }
    public UIElement AnnotatedElement { get; }
    public abstract virtual IList get_AttachedAnnotations();
    public abstract virtual PresentationContext get_PresentationContext();
    public abstract virtual void set_PresentationContext(PresentationContext value);
    public abstract virtual int get_ZOrder();
    public abstract virtual void set_ZOrder(int value);
    public abstract virtual bool get_IsDirty();
    public abstract virtual void set_IsDirty(bool value);
    public abstract virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public abstract virtual UIElement get_AnnotatedElement();
    public abstract virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public abstract virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public abstract virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
}
internal interface MS.Internal.Annotations.Component.IHighlightRange {
    public Color Background { get; }
    public Color SelectedBackground { get; }
    public TextAnchor Range { get; }
    public int Priority { get; }
    public bool HighlightContent { get; }
    public abstract virtual void AddChild(Shape child);
    public abstract virtual void RemoveChild(Shape child);
    public abstract virtual Color get_Background();
    public abstract virtual Color get_SelectedBackground();
    public abstract virtual TextAnchor get_Range();
    public abstract virtual int get_Priority();
    public abstract virtual bool get_HighlightContent();
}
internal class MS.Internal.Annotations.Component.MarkedHighlightComponent : Canvas {
    public static DependencyProperty MarkerBrushProperty;
    public static DependencyProperty StrokeThicknessProperty;
    internal static Color DefaultAnchorBackground;
    internal static Color DefaultMarkerColor;
    internal static Color DefaultActiveAnchorBackground;
    internal static Color DefaultActiveMarkerColor;
    internal static double MarkerStrokeThickness;
    internal static double ActiveMarkerStrokeThickness;
    internal static double MarkerVerticalSpace;
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public UIElement AnnotatedElement { get; }
    public bool IsDirty { get; public set; }
    unknown bool Focused {public set; }
    unknown Brush MarkerBrush {public set; }
    unknown double StrokeThickness {public set; }
    internal HighlightComponent HighlightAnchor { get; internal set; }
    public MarkedHighlightComponent(XmlQualifiedName type, DependencyObject host);
    private static MarkedHighlightComponent();
    public sealed virtual IList get_AttachedAnnotations();
    public sealed virtual PresentationContext get_PresentationContext();
    public sealed virtual void set_PresentationContext(PresentationContext value);
    public sealed virtual int get_ZOrder();
    public sealed virtual void set_ZOrder(int value);
    public sealed virtual UIElement get_AnnotatedElement();
    public sealed virtual bool get_IsDirty();
    public sealed virtual void set_IsDirty(bool value);
    public sealed virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public sealed virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public void set_Focused(bool value);
    public void set_MarkerBrush(Brush value);
    public void set_StrokeThickness(double value);
    internal void SetTabIndex(int index);
    internal HighlightComponent get_HighlightAnchor();
    internal void set_HighlightAnchor(HighlightComponent value);
}
internal abstract class MS.Internal.Annotations.Component.PresentationContext : object {
    public UIElement Host { get; }
    public PresentationContext EnclosingContext { get; }
    public abstract virtual UIElement get_Host();
    public abstract virtual PresentationContext get_EnclosingContext();
    public abstract virtual void AddToHost(IAnnotationComponent component);
    public abstract virtual void RemoveFromHost(IAnnotationComponent component, bool reorder);
    public abstract virtual void InvalidateTransform(IAnnotationComponent component);
    public abstract virtual void BringToFront(IAnnotationComponent component);
    public abstract virtual void SendToBack(IAnnotationComponent component);
}
internal interface MS.Internal.Annotations.IAttachedAnnotation {
    public object AttachedAnchor { get; }
    public object FullyAttachedAnchor { get; }
    public AttachmentLevel AttachmentLevel { get; }
    public DependencyObject Parent { get; }
    public Point AnchorPoint { get; }
    public AnnotationStore Store { get; }
    public abstract virtual object get_AttachedAnchor();
    public abstract virtual object get_FullyAttachedAnchor();
    public abstract virtual AttachmentLevel get_AttachmentLevel();
    public abstract virtual DependencyObject get_Parent();
    public abstract virtual Point get_AnchorPoint();
    public abstract virtual bool IsAnchorEqual(object o);
    public abstract virtual AnnotationStore get_Store();
}
internal interface MS.Internal.Annotations.INotifyPropertyChanged2 {
}
internal interface MS.Internal.Annotations.IOwnedObject {
    public bool Owned { get; public set; }
    public abstract virtual bool get_Owned();
    public abstract virtual void set_Owned(bool value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Annotations.ObservableDictionary : object {
    public int Count { get; }
    public string Item { get; public set; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    public sealed virtual void Add(string key, string val);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public sealed virtual bool TryGetValue(string key, String& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> pair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] target, int startIndex);
    public sealed virtual int get_Count();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
internal class MS.Internal.Annotations.Serializer : object {
    public Serializer(Type type);
    public void Serialize(XmlWriter writer, object obj);
    public object Deserialize(XmlReader reader);
}
internal class MS.Internal.Annotations.Storage.StoreAnnotationsMap : object {
    internal StoreAnnotationsMap(AnnotationAuthorChangedEventHandler authorChanged, AnnotationResourceChangedEventHandler anchorChanged, AnnotationResourceChangedEventHandler cargoChanged);
    public void AddAnnotation(Annotation annotation, bool dirty);
    public void RemoveAnnotation(Guid id);
    public Dictionary`2<Guid, Annotation> FindAnnotations(ContentLocator anchorLocator);
    public Dictionary`2<Guid, Annotation> FindAnnotations();
    public Annotation FindAnnotation(Guid id);
    public List`1<Annotation> FindDirtyAnnotations();
    public void ValidateDirtyAnnotations();
}
internal class MS.Internal.Annotations.XmlElementCollection : ObservableCollection`1<XmlElement> {
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, XmlElement item);
    protected virtual void SetItem(int index, XmlElement item);
}
internal enum MS.Internal.AppModel.AppCommands : Enum {
    public int value__;
    public static AppCommands Edit_Cut;
    public static AppCommands Edit_Copy;
    public static AppCommands Edit_Paste;
    public static AppCommands Edit_SelectAll;
    public static AppCommands Edit_Find;
    public static AppCommands Edit_Digitalsignatures;
    public static AppCommands Edit_Digitalsignatures_SignDocument;
    public static AppCommands Edit_Digitalsignatures_RequestSignature;
    public static AppCommands Edit_Digitalsignatures_ViewSignature;
    public static AppCommands Edit_Permission;
    public static AppCommands Edit_Permission_Set;
    public static AppCommands Edit_Permission_View;
    public static AppCommands Edit_Permission_Restrict;
    public static AppCommands View_StatusBar;
    public static AppCommands View_Stop;
    public static AppCommands View_Refresh;
    public static AppCommands View_FullScreen;
    public static AppCommands View_Zoom;
    public static AppCommands View_Zoom_In;
    public static AppCommands View_Zoom_Out;
    public static AppCommands View_Zoom_400;
    public static AppCommands View_Zoom_250;
    public static AppCommands View_Zoom_150;
    public static AppCommands View_Zoom_100;
    public static AppCommands View_Zoom_75;
    public static AppCommands View_Zoom_50;
    public static AppCommands View_Zoom_25;
    public static AppCommands View_Zoom_PageWidth;
    public static AppCommands View_Zoom_WholePage;
    public static AppCommands View_Zoom_TwoPages;
    public static AppCommands View_Zoom_Thumbnails;
}
internal class MS.Internal.AppModel.ApplicationProxyInternal : MarshalByRefObject {
    [DebuggerBrowsableAttribute("0")]
internal RootBrowserWindowProxy RootBrowserWindowProxy { get; }
    internal RootBrowserWindow RootBrowserWindow { get; private set; }
    internal bool RootBrowserWindowCreated { get; }
    internal OleCmdHelper OleCmdHelper { get; }
    internal static ApplicationProxyInternal Current { get; }
    internal Uri Uri { get; private set; }
    unknown object StreamContainer {internal set; }
    public virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CreateRootBrowserWindow();
    internal bool FocusedElementWantsBackspace();
    [SecurityCriticalAttribute]
internal int Run(InitData initData);
    internal void Show(bool show);
    internal void Move(Rect windowRect);
    [SecurityCriticalAttribute]
internal void PostShutdown();
    internal void Activate(bool fActivate);
    internal bool CanInvokeJournalEntry(int entryId);
    [SecurityCriticalAttribute]
internal Byte[] GetSaveHistoryBytes(bool persistEntireJournal, Int32& journalEntryId, String& uriString, String& titleString);
    [SecurityCriticalAttribute]
internal void LoadHistoryStream(MemoryStream loadStream, bool firstLoadFromHistory);
    internal bool IsAppLoaded();
    internal bool IsShutdown();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Cleanup();
    internal RootBrowserWindowProxy get_RootBrowserWindowProxy();
    internal RootBrowserWindow get_RootBrowserWindow();
    [SecurityCriticalAttribute]
private void set_RootBrowserWindow(RootBrowserWindow value);
    internal bool get_RootBrowserWindowCreated();
    internal OleCmdHelper get_OleCmdHelper();
    [SecurityCriticalAttribute]
internal static ApplicationProxyInternal get_Current();
    internal Uri get_Uri();
    [SecurityCriticalAttribute]
private void set_Uri(Uri value);
    [SecurityCriticalAttribute]
internal void SetDebugSecurityZoneURL(Uri debugSecurityZoneURL);
    [SecurityCriticalAttribute]
internal void set_StreamContainer(object value);
}
internal enum MS.Internal.AppModel.AppMenus : Enum {
    public int value__;
    public static AppMenus EditMenu;
    public static AppMenus ViewMenu;
}
internal static class MS.Internal.AppModel.AppModelKnownContentFactory : object {
    internal static object BamlConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static object XamlConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    internal static object HtmlXappConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
}
internal static class MS.Internal.AppModel.AppSecurityManager : object {
    private static AppSecurityManager();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void SafeLaunchBrowserDemandWhenUnsafe(Uri originatingUri, Uri destinationUri, bool fIsTopLevel);
    internal static LaunchResult SafeLaunchBrowserOnlyIfPossible(Uri originatingUri, Uri destinationUri, bool fIsTopLevel);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static LaunchResult SafeLaunchBrowserOnlyIfPossible(Uri originatingUri, Uri destinationUri, string targetName, bool fIsTopLevel);
    [SecurityCriticalAttribute]
internal static void UnsafeLaunchBrowser(Uri uri, string targetFrame);
    [SecurityCriticalAttribute]
internal static void ShellExecuteDefaultBrowser(Uri uri);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ClearSecurityManager();
    [SecurityCriticalAttribute]
internal static int MapUrlToZone(Uri url);
}
internal class MS.Internal.AppModel.BamlStream : Stream {
    private Assembly System.Windows.Markup.IStreamInfo.Assembly { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [SecurityCriticalAttribute]
internal BamlStream(Stream stream, Assembly assembly);
    private sealed virtual override Assembly System.Windows.Markup.IStreamInfo.get_Assembly();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool Equals(object obj);
    public virtual void Flush();
    public virtual int GetHashCode();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal static class MS.Internal.AppModel.CLSID : object {
    public static string EnumerableObjectCollection;
    public static string FileOpenDialog;
    public static string FileSaveDialog;
    public static string ShellLink;
    public static string TaskbarList;
    public static string WebBrowser;
    public static string DestinationList;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
}
internal class MS.Internal.AppModel.COMDLG_FILTERSPEC : ValueType {
    public string pszName;
    public string pszSpec;
}
internal class MS.Internal.AppModel.CommandWithArgument : object {
    public RoutedCommand Command { get; }
    [SecurityCriticalAttribute]
public CommandWithArgument(RoutedCommand command);
    [SecurityCriticalAttribute]
public CommandWithArgument(RoutedCommand command, object argument);
    [SecurityCriticalAttribute]
public bool Execute(IInputElement target, object argument);
    [SecurityCriticalAttribute]
public bool QueryEnabled(IInputElement target, object argument);
    public RoutedCommand get_Command();
}
internal class MS.Internal.AppModel.ContentFilePart : PackagePart {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ContentFilePart(Package container, Uri uri);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
}
internal abstract class MS.Internal.AppModel.CustomJournalStateInternal : object {
    internal virtual void PrepareForSerialization();
}
internal class MS.Internal.AppModel.DataStreams : object {
    internal bool HasAnyData { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_HasAnyData();
    internal void PrepareForSerialization();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Save(object root);
    internal void Load(object root);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Clear();
}
internal enum MS.Internal.AppModel.EditingCommandIds : Enum {
    public UInt32 value__;
    public static EditingCommandIds Backspace;
    public static EditingCommandIds Delete;
}
[FlagsAttribute]
internal enum MS.Internal.AppModel.HostingFlags : Enum {
    public int value__;
    public static HostingFlags hfHostedInIE;
    public static HostingFlags hfHostedInWebOC;
    public static HostingFlags hfHostedInIEorWebOC;
    public static HostingFlags hfHostedInMozilla;
    public static HostingFlags hfHostedInFrame;
    public static HostingFlags hfIsBrowserLowIntegrityProcess;
    public static HostingFlags hfInDebugMode;
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("12337d35-94c6-48a0-bce7-6a9c69d4d600")]
internal interface MS.Internal.AppModel.IApplicationDestinations {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual void RemoveDestination(object punk);
    public abstract virtual void RemoveAllDestinations();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")]
internal interface MS.Internal.AppModel.IApplicationDocumentLists {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object GetList(ADLT listtype, UInt32 cItemsDesired, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("5FFAD804-61C8-445c-8C31-A2101C64C510")]
internal interface MS.Internal.AppModel.IBrowserCallbackServices {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void OnBeforeShowNavigationWindow();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void PostReadyStateChange(int readyState);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void DelegateNavigation(string url, string targetName, string headers);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool UpdateAddressBar(string url);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void UpdateBackForwardState();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void UpdateTravelLog(bool addNewEntry);
    public abstract virtual bool UpdateProgress(long cBytesCompleted, long cBytesTotal);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool ChangeDownloadState(bool fIsDownloading);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool IsDownlevelPlatform();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool IsShuttingDown();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual bool TabOut(bool forward);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void ProcessUnhandledException(string pErrorMsg);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual int GetOleClientSite(Object& oleClientSite);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual int UpdateCommands();
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual IntPtr CreateWebBrowserControlInBrowserProcess();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("a0aa9153-65b4-3b57-9f2b-126f9c76c9f5")]
internal interface MS.Internal.AppModel.IBrowserHostServices {
    [SecurityCriticalAttribute]
public abstract virtual int Run(string strUrl, string strFragment, MimeType mime, string strDebugSecurityZoneURL, string strApplicationId, object storageIUnknown, object loadByteArray, HostingFlags hostingFlags, INativeProgressPage nativeProgressPage, string bstrProgressAssemblyName, string bstrProgressClassName, string bstrErrorAssemblyName, string bstrErrorClassName, IHostBrowser hostBrowser);
    [SecurityCriticalAttribute]
public abstract virtual void SetParent(IntPtr parentHandle);
    public abstract virtual void Show(bool showView);
    public abstract virtual void Move(int x, int y, int width, int height);
    [SecurityCriticalAttribute]
public abstract virtual void SetBrowserCallback(object browserCallback);
    public abstract virtual bool IsAppLoaded();
    public abstract virtual int GetApplicationExitCode();
    public abstract virtual bool CanInvokeJournalEntry(int entryId);
    public abstract virtual void SaveHistory(object ucomIStream, bool persistEntireJournal, Int32& entryIndex, String& url, String& title);
    [SecurityCriticalAttribute]
public abstract virtual void LoadHistory(object ucomIStream);
    public abstract virtual int QueryStatus(Guid guidCmdGroup, UInt32 command, UInt32& flags);
    [SecurityCriticalAttribute]
public abstract virtual int ExecCommand(Guid guidCmdGroup, UInt32 command, object arg);
    [SecurityCriticalAttribute]
public abstract virtual void PostShutdown();
    public abstract virtual void Activate(bool fActivated);
    public abstract virtual void TabInto(bool forward);
    public abstract virtual bool FocusedElementWantsBackspace();
}
internal static class MS.Internal.AppModel.IconHelper : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void GetDefaultIconHandles(IconHandle& largeIconHandle, IconHandle& smallIconHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static void GetIconHandlesFromImageSource(ImageSource image, IconHandle& largeIconHandle, IconHandle& smallIconHandle);
    [SecurityCriticalAttribute]
public static IconHandle CreateIconHandleFromImageSource(ImageSource image, Size size);
    [SecurityCriticalAttribute]
internal static IconHandle CreateIconCursor(Byte[] colorArray, int width, int height, int xHotspot, int yHotspot, bool isIcon);
    internal static int AlignToBytes(double original, int nBytesCount);
}
internal interface MS.Internal.AppModel.IContentContainer {
    public abstract virtual void OnContentReady(ContentType contentType, object content, Uri uri, object navState);
    public abstract virtual void OnNavigationProgress(Uri uri, long bytesRead, long maxBytes);
    public abstract virtual void OnStreamClosed(Uri uri);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("6332debf-87b5-4670-90c0-5e57b408a49e")]
internal interface MS.Internal.AppModel.ICustomDestinationList {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object BeginList(UInt32& pcMaxSlots, Guid& riid);
    public abstract virtual HRESULT AppendCategory(string pszCategory, IObjectArray poa);
    public abstract virtual void AppendKnownCategory(KDC category);
    public abstract virtual HRESULT AddUserTasks(IObjectArray poa);
    public abstract virtual void CommitList();
    public abstract virtual object GetRemovedDestinations(Guid& riid);
    public abstract virtual void DeleteList(string pszAppID);
    public abstract virtual void AbortList();
}
internal interface MS.Internal.AppModel.IDownloader {
    public NavigationService Downloader { get; }
    public abstract virtual NavigationService get_Downloader();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ContentRendered(EventHandler value);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IEnumIDList {
    public abstract virtual HRESULT Next(UInt32 celt, IntPtr& rgelt, Int32& pceltFetched);
    public abstract virtual HRESULT Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumIDList Clone();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("42f85136-db7e-439c-85f1-e4075d135fc8")]
internal interface MS.Internal.AppModel.IFileDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual string GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP alignment);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("973510DB-7D7F-452B-8975-74A85828D354")]
internal interface MS.Internal.AppModel.IFileDialogEvents {
    public abstract virtual HRESULT OnFileOk(IFileDialog pfd);
    public abstract virtual HRESULT OnFolderChanging(IFileDialog pfd, IShellItem psiFolder);
    public abstract virtual HRESULT OnFolderChange(IFileDialog pfd);
    public abstract virtual HRESULT OnSelectionChange(IFileDialog pfd);
    public abstract virtual HRESULT OnShareViolation(IFileDialog pfd, IShellItem psi, FDESVR& pResponse);
    public abstract virtual HRESULT OnTypeChange(IFileDialog pfd);
    public abstract virtual HRESULT OnOverwrite(IFileDialog pfd, IShellItem psi, FDEOR& pResponse);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("d57c7288-d4ad-4768-be02-9d969532d960")]
internal interface MS.Internal.AppModel.IFileOpenDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual void GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP fdcp);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
    public abstract virtual IShellItemArray GetResults();
    public abstract virtual IShellItemArray GetSelectedItems();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("84bccd23-5fde-4cdb-aea4-af64b83d78ab")]
internal interface MS.Internal.AppModel.IFileSaveDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual void GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP fdcp);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
    public abstract virtual void SetSaveAsItem(IShellItem psi);
    public abstract virtual void SetProperties(object pStore);
    public abstract virtual void SetCollectedProperties(object pList, int fAppendDefault);
    public abstract virtual object GetProperties();
    public abstract virtual void ApplyProperties(IShellItem psi, object pStore, IntPtr& hwnd, object pSink);
}
[GuidAttribute("AD5D6F02-5F4E-4D77-9FC0-381981317144")]
[InterfaceTypeAttribute("1")]
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface MS.Internal.AppModel.IHostBrowser {
    public abstract virtual string DetermineTopLevel(Boolean& pbIsTopLevel);
    public abstract virtual void Navigate(string url, string targetName, string headers);
    public abstract virtual void GoBack();
    public abstract virtual void GoForward();
    public abstract virtual void SetTitle(string title);
    public abstract virtual long SetStatusText(string text);
    public abstract virtual void SetWidth(UInt32 width);
    public abstract virtual void SetHeight(UInt32 height);
    public abstract virtual UInt32 GetWidth();
    public abstract virtual UInt32 GetHeight();
    public abstract virtual int GetLeft();
    public abstract virtual int GetTop();
    public abstract virtual string GetCookie_DoNotUse(string url, string cookieName, bool thirdParty);
    public abstract virtual void SetCookie_NoNotUse(string url, string cookieName, string cookieData, bool thirdParty, string P3PHeader);
    public abstract virtual HRESULT GetUserAgentString(String& userAgent);
    public abstract virtual void CreateWebBrowserControl_DoNotUse(IntPtr& ppWebBrowser);
    public abstract virtual void TabOut_v35SP1QFE(bool forward);
}
[GuidAttribute("AD5D6F03-0002-4D77-9FC0-381981317144")]
[InterfaceTypeAttribute("1")]
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface MS.Internal.AppModel.IHostBrowser2 {
    public object HostScriptObject { get; }
    public string PluginName { get; }
    public string PluginVersion { get; }
    public abstract virtual void TabOut_DoNotUse(bool forward);
    public abstract virtual object get_HostScriptObject();
    public abstract virtual string get_PluginName();
    public abstract virtual string get_PluginVersion();
}
internal interface MS.Internal.AppModel.IHostService {
    public RootBrowserWindowProxy RootBrowserWindowProxy { get; }
    public IntPtr HostWindowHandle { get; }
    public abstract virtual RootBrowserWindowProxy get_RootBrowserWindowProxy();
    [SecurityCriticalAttribute]
public abstract virtual IntPtr get_HostWindowHandle();
}
internal static class MS.Internal.AppModel.IID : object {
    public static string Accessible;
    public static string EnumIdList;
    public static string EnumObjects;
    public static string FileDialog;
    public static string FileDialogEvents;
    public static string FileOpenDialog;
    public static string FileSaveDialog;
    public static string ModalWindow;
    public static string ObjectArray;
    public static string ObjectCollection;
    public static string PropertyStore;
    public static string ShellFolder;
    public static string ShellLink;
    public static string ShellItem;
    public static string ShellItem2;
    public static string ShellItemArray;
    public static string TaskbarList;
    public static string TaskbarList2;
    public static string Unknown;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static string CustomDestinationList;
    public static string ObjectWithAppUserModelId;
    public static string ObjectWithProgId;
    public static string TaskbarList3;
    public static string TaskbarList4;
}
internal interface MS.Internal.AppModel.IJournalNavigationScopeHost {
    public NavigationService NavigationService { get; }
    public abstract virtual NavigationService get_NavigationService();
    public abstract virtual void VerifyContextAndObjectState();
    public abstract virtual void OnJournalAvailable();
    public abstract virtual bool GoBackOverride();
    public abstract virtual bool GoForwardOverride();
}
internal interface MS.Internal.AppModel.IJournalState {
    public abstract virtual CustomJournalStateInternal GetJournalState(JournalReason journalReason);
    public abstract virtual void RestoreJournalState(CustomJournalStateInternal state);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("b4db1657-70d7-485e-8e3e-6fcb5a5c1802")]
internal interface MS.Internal.AppModel.IModalWindow {
    public abstract virtual HRESULT Show(IntPtr parent);
}
[GuidAttribute("1f681651-1024-4798-af36-119bbe5e5665")]
[InterfaceTypeAttribute("1")]
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface MS.Internal.AppModel.INativeProgressPage {
    public abstract virtual HRESULT Show();
    public abstract virtual HRESULT Hide();
    public abstract virtual HRESULT ShowProgressMessage(string message);
    public abstract virtual HRESULT SetApplicationName(string appName);
    public abstract virtual HRESULT SetPublisherName(string publisherName);
    public abstract virtual HRESULT OnDownloadProgress(ulong bytesDownloaded, ulong bytesTotal);
}
internal interface MS.Internal.AppModel.INavigator {
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    public abstract virtual JournalNavigationScope GetJournal(bool create);
    public abstract virtual bool get_CanGoForward();
    public abstract virtual bool get_CanGoBack();
    public abstract virtual void GoForward();
    public abstract virtual void GoBack();
    public abstract virtual void AddBackEntry(CustomContentState state);
    public abstract virtual JournalEntry RemoveBackEntry();
    public abstract virtual IEnumerable get_BackStack();
    public abstract virtual IEnumerable get_ForwardStack();
}
internal interface MS.Internal.AppModel.INavigatorBase {
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public abstract virtual Uri get_Source();
    public abstract virtual void set_Source(Uri value);
    public abstract virtual Uri get_CurrentSource();
    public abstract virtual object get_Content();
    public abstract virtual void set_Content(object value);
    public abstract virtual bool Navigate(Uri source);
    public abstract virtual bool Navigate(Uri source, object extraData);
    public abstract virtual bool Navigate(object content);
    public abstract virtual bool Navigate(object content, object extraData);
    public abstract virtual void StopLoading();
    public abstract virtual void Refresh();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
}
internal interface MS.Internal.AppModel.INavigatorImpl {
    public abstract virtual void OnSourceUpdatedFromNavService(bool journalOrCancel);
    public abstract virtual Visual FindRootViewer();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface MS.Internal.AppModel.IObjectArray {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface MS.Internal.AppModel.IObjectCollection {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
    public abstract virtual void AddObject(object punk);
    public abstract virtual void AddFromArray(IObjectArray poaSource);
    public abstract virtual void RemoveObjectAt(UInt32 uiIndex);
    public abstract virtual void Clear();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("36db0196-9665-46d1-9ba7-d3709eecf9ed")]
internal interface MS.Internal.AppModel.IObjectWithAppUserModelId {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual string GetAppID();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")]
internal interface MS.Internal.AppModel.IObjectWithProgId {
    public abstract virtual void SetProgID(string pszProgID);
    public abstract virtual string GetProgID();
}
internal interface MS.Internal.AppModel.IProgressPage2 {
    public abstract virtual void ShowProgressMessage(string message);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")]
internal interface MS.Internal.AppModel.IPropertyStore {
    public abstract virtual UInt32 GetCount();
    public abstract virtual PKEY GetAt(UInt32 iProp);
    [SecurityCriticalAttribute]
public abstract virtual void GetValue(PKEY& pkey, PROPVARIANT pv);
    [SecurityCriticalAttribute]
public abstract virtual void SetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void Commit();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IShellFolder {
    public abstract virtual void ParseDisplayName(IntPtr hwnd, IBindCtx pbc, string pszDisplayName, Int32& pchEaten, IntPtr& ppidl, UInt32& pdwAttributes);
    public abstract virtual IEnumIDList EnumObjects(IntPtr hwnd, SHCONTF grfFlags);
    public abstract virtual object BindToObject(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual object BindToStorage(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual HRESULT CompareIDs(IntPtr lParam, IntPtr pidl1, IntPtr pidl2);
    public abstract virtual object CreateViewObject(IntPtr hwndOwner, Guid& riid);
    public abstract virtual void GetAttributesOf(UInt32 cidl, IntPtr apidl, SFGAO& rgfInOut);
    public abstract virtual object GetUIObjectOf(IntPtr hwndOwner, UInt32 cidl, IntPtr apidl, Guid& riid, UInt32& rgfReserved);
    public abstract virtual void GetDisplayNameOf(IntPtr pidl, SHGDN uFlags, IntPtr& pName);
    public abstract virtual void SetNameOf(IntPtr hwnd, IntPtr pidl, string pszName, SHGDN uFlags, IntPtr& ppidlOut);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
internal interface MS.Internal.AppModel.IShellItem {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual UInt32 GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("7e9fb0d3-919f-4307-ab2e-9b1860310c93")]
internal interface MS.Internal.AppModel.IShellItem2 {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
    public abstract virtual object GetPropertyStore(GPS flags, Guid& riid);
    public abstract virtual object GetPropertyStoreWithCreateObject(GPS flags, object punkCreateObject, Guid& riid);
    public abstract virtual object GetPropertyStoreForKeys(IntPtr rgKeys, UInt32 cKeys, GPS flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(IntPtr keyType, Guid& riid);
    public abstract virtual void Update(IBindCtx pbc);
    [SecurityCriticalAttribute]
public abstract virtual void GetProperty(IntPtr key, PROPVARIANT pv);
    public abstract virtual Guid GetCLSID(IntPtr key);
    public abstract virtual FILETIME GetFileTime(IntPtr key);
    public abstract virtual int GetInt32(IntPtr key);
    public abstract virtual string GetString(IntPtr key);
    public abstract virtual UInt32 GetUInt32(IntPtr key);
    public abstract virtual ulong GetUInt64(IntPtr key);
    public abstract virtual bool GetBool(IntPtr key);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("B63EA76D-1F85-456F-A19C-48159EFA858B")]
internal interface MS.Internal.AppModel.IShellItemArray {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& rbhid, Guid& riid);
    public abstract virtual object GetPropertyStore(int flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(PKEY& keyType, Guid& riid);
    public abstract virtual UInt32 GetAttributes(SIATTRIBFLAGS dwAttribFlags, UInt32 sfgaoMask);
    public abstract virtual UInt32 GetCount();
    public abstract virtual IShellItem GetItemAt(UInt32 dwIndex);
    public abstract virtual object EnumItems();
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IShellLinkW {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, WIN32_FIND_DATAW pfd, SLGP fFlags);
    public abstract virtual IntPtr GetIDList();
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszFile, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual short GetHotKey();
    public abstract virtual void SetHotKey(short wHotKey);
    public abstract virtual UInt32 GetShowCmd();
    public abstract virtual void SetShowCmd(UInt32 iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, UInt32 dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, UInt32 fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("56FDF342-FD6D-11d0-958A-006097C9A090")]
internal interface MS.Internal.AppModel.ITaskbarList {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("602D4995-B13A-429b-A66E-1935E44F4317")]
internal interface MS.Internal.AppModel.ITaskbarList2 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface MS.Internal.AppModel.ITaskbarList3 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IconHandle hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
}
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface MS.Internal.AppModel.ITaskbarList4 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IconHandle hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
    public abstract virtual HRESULT SetTabProperties(IntPtr hwndTab, STPF stpFlags);
}
internal class MS.Internal.AppModel.JournalEntryGroupState : object {
    internal Guid NavigationServiceId { get; internal set; }
    internal UInt32 ContentId { get; internal set; }
    internal DataStreams JournalDataStreams { get; internal set; }
    internal JournalEntry GroupExitEntry { get; internal set; }
    internal JournalEntryGroupState(Guid navSvcId, UInt32 contentId);
    internal Guid get_NavigationServiceId();
    internal void set_NavigationServiceId(Guid value);
    internal UInt32 get_ContentId();
    internal void set_ContentId(UInt32 value);
    internal DataStreams get_JournalDataStreams();
    internal void set_JournalDataStreams(DataStreams value);
    internal JournalEntry get_GroupExitEntry();
    internal void set_GroupExitEntry(JournalEntry value);
}
internal class MS.Internal.AppModel.JournalEntryKeepAlive : JournalEntry {
    internal object KeepAliveRoot { get; }
    internal JournalEntryKeepAlive(JournalEntryGroupState jeGroupState, Uri uri, object keepAliveRoot);
    internal object get_KeepAliveRoot();
    internal virtual bool IsAlive();
    internal virtual void SaveState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal abstract class MS.Internal.AppModel.JournalEntryPageFunction : JournalEntry {
    internal static int _NoParentPage;
    internal Guid PageFunctionId { get; internal set; }
    internal Guid ParentPageFunctionId { get; internal set; }
    internal JournalEntryPageFunction(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    protected JournalEntryPageFunction(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Guid get_PageFunctionId();
    internal void set_PageFunctionId(Guid value);
    internal Guid get_ParentPageFunctionId();
    internal void set_ParentPageFunctionId(Guid value);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal abstract virtual PageFunctionBase ResumePageFunction();
    internal static int GetParentPageJournalIndex(NavigationService NavigationService, Journal journal, PageFunctionBase endingPF);
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionKeepAlive : JournalEntryPageFunction {
    internal PageFunctionBase KeepAlivePageFunction { get; }
    internal JournalEntryPageFunctionKeepAlive(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal PageFunctionBase get_KeepAlivePageFunction();
    internal virtual PageFunctionBase ResumePageFunction();
    internal virtual void SaveState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal abstract class MS.Internal.AppModel.JournalEntryPageFunctionSaver : JournalEntryPageFunction {
    internal JournalEntryPageFunctionSaver(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    protected JournalEntryPageFunctionSaver(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
    internal virtual void RestoreState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionType : JournalEntryPageFunctionSaver {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal JournalEntryPageFunctionType(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    [SecurityCriticalAttribute]
protected JournalEntryPageFunctionType(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual PageFunctionBase ResumePageFunction();
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionUri : JournalEntryPageFunctionSaver {
    internal JournalEntryPageFunctionUri(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction, Uri markupUri);
    protected JournalEntryPageFunctionUri(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual PageFunctionBase ResumePageFunction();
}
internal enum MS.Internal.AppModel.JournalEntryType : Enum {
    public byte value__;
    public static JournalEntryType Navigable;
    public static JournalEntryType UiLess;
}
internal class MS.Internal.AppModel.JournalEntryUri : JournalEntry {
    internal JournalEntryUri(JournalEntryGroupState jeGroupState, Uri uri);
    protected JournalEntryUri(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
}
internal class MS.Internal.AppModel.JournalNavigationScope : DependencyObject {
    internal static DependencyProperty CanGoBackProperty;
    internal static DependencyProperty CanGoForwardProperty;
    internal static DependencyProperty BackStackProperty;
    internal static DependencyProperty ForwardStackProperty;
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    internal Journal Journal { get; internal set; }
    internal NavigationService RootNavigationService { get; }
    internal INavigatorBase NavigatorHost { get; }
    internal JournalNavigationScope(IJournalNavigationScopeHost host);
    private static JournalNavigationScope();
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual object get_Content();
    public sealed virtual void set_Content(object value);
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void GoForward();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void GoBack();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    internal void EnsureJournal();
    internal bool CanInvokeJournalEntry(int entryId);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool NavigateToEntry(int index);
    internal bool NavigateToEntry(JournalEntry entry);
    internal void AbortJournalNavigation();
    internal INavigatorBase FindTarget(string name);
    internal static void ClearDPValues(DependencyObject navigator);
    internal Journal get_Journal();
    internal void set_Journal(Journal value);
    internal NavigationService get_RootNavigationService();
    internal INavigatorBase get_NavigatorHost();
}
internal enum MS.Internal.AppModel.JournalReason : Enum {
    public int value__;
    public static JournalReason NewContentNavigation;
    public static JournalReason FragmentNavigation;
    public static JournalReason AddBackEntry;
}
internal enum MS.Internal.AppModel.LaunchResult : Enum {
    public int value__;
    public static LaunchResult Launched;
    public static LaunchResult NotLaunched;
    public static LaunchResult NotLaunchedDueToPrompt;
}
internal static class MS.Internal.AppModel.MimeObjectFactory : object {
    private static MimeObjectFactory();
    internal static object GetObjectAndCloseStream(Stream s, ContentType contentType, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    internal static void Register(ContentType contentType, StreamToObjectFactoryDelegate method);
}
internal enum MS.Internal.AppModel.MimeType : Enum {
    public int value__;
    public static MimeType Unknown;
    public static MimeType Document;
    public static MimeType Application;
    public static MimeType Markup;
}
internal static class MS.Internal.AppModel.NativeMethods2 : object {
    [SecurityCriticalAttribute]
internal static void SHAddToRecentDocs(string path);
    [SecurityCriticalAttribute]
internal static void SHAddToRecentDocs(IShellLinkW shellLink);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static HRESULT SHCreateItemFromParsingName(string pszPath, IBindCtx pbc, Guid& riid, Object& ppv);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static HRESULT SHGetFolderPathEx(Guid& rfid, KF_FLAG dwFlags, IntPtr hToken, StringBuilder pszPath, UInt32 cchPath);
    internal static void SetCurrentProcessExplicitAppUserModelID(string AppID);
    internal static HRESULT GetCurrentProcessExplicitAppUserModelID(String& AppID);
}
internal class MS.Internal.AppModel.NativeProgressPageProxy : object {
    public Uri DeploymentPath { get; public set; }
    public DispatcherOperationCallback StopCallback { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public string ApplicationName { get; public set; }
    public string PublisherName { get; public set; }
    [SecurityCriticalAttribute]
internal NativeProgressPageProxy(INativeProgressPage npp);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void ShowProgressMessage(string message);
    public sealed virtual void set_DeploymentPath(Uri value);
    public sealed virtual Uri get_DeploymentPath();
    public sealed virtual void set_StopCallback(DispatcherOperationCallback value);
    public sealed virtual DispatcherOperationCallback get_StopCallback();
    public sealed virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public sealed virtual DispatcherOperationCallback get_RefreshCallback();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void set_ApplicationName(string value);
    public sealed virtual string get_ApplicationName();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void set_PublisherName(string value);
    public sealed virtual string get_PublisherName();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void UpdateProgress(long bytesDownloaded, long bytesTotal);
}
internal static class MS.Internal.AppModel.NavigationHelper : object {
    internal static Visual FindRootViewer(ContentControl navigator, string contentPresenterName);
}
internal enum MS.Internal.AppModel.NavigationStatus : Enum {
    public int value__;
    public static NavigationStatus Idle;
    public static NavigationStatus Navigating;
    public static NavigationStatus NavigationFailed;
    public static NavigationStatus Navigated;
    public static NavigationStatus Stopped;
}
internal class MS.Internal.AppModel.OleCmdHelper : MarshalByRefObject {
    internal static int OLECMDERR_E_NOTSUPPORTED;
    internal static int OLECMDERR_E_DISABLED;
    internal static int OLECMDERR_E_UNKNOWNGROUP;
    internal static UInt32 CommandUnsupported;
    internal static UInt32 CommandEnabled;
    internal static UInt32 CommandDisabled;
    internal static Guid CGID_ApplicationCommands;
    internal static Guid CGID_EditingCommands;
    private static OleCmdHelper();
    [SecurityCriticalAttribute]
internal void QueryStatus(Guid guidCmdGroup, UInt32 cmdId, UInt32& flags);
    [SecurityCriticalAttribute]
internal void ExecCommand(Guid guidCmdGroup, UInt32 commandId, object arg);
}
internal class MS.Internal.AppModel.PKEY : ValueType {
    private Guid _fmtid;
    private UInt32 _pid;
    public static PKEY Title;
    public static PKEY AppUserModel_ID;
    public static PKEY AppUserModel_IsDestListSeparator;
    public static PKEY AppUserModel_RelaunchCommand;
    public static PKEY AppUserModel_RelaunchDisplayNameResource;
    public static PKEY AppUserModel_RelaunchIconResource;
    private static PKEY();
}
internal class MS.Internal.AppModel.RequestSetStatusBarEventArgs : RoutedEventArgs {
    internal string Text { get; }
    internal static RequestSetStatusBarEventArgs Clear { get; }
    [SecurityCriticalAttribute]
internal RequestSetStatusBarEventArgs(string text);
    [SecurityCriticalAttribute]
internal RequestSetStatusBarEventArgs(Uri targetUri);
    internal string get_Text();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static RequestSetStatusBarEventArgs get_Clear();
}
internal class MS.Internal.AppModel.ResourceContainer : Package {
    internal static string XamlExt;
    internal static string BamlExt;
    internal static ResourceManagerWrapper ApplicationResourceManagerWrapper { get; }
    internal static FileShare FileShare { get; }
    private static ResourceContainer();
    internal static ResourceManagerWrapper get_ApplicationResourceManagerWrapper();
    internal static FileShare get_FileShare();
    public virtual bool PartExists(Uri uri);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual PackagePart GetPartCore(Uri uri);
    protected virtual PackagePart CreatePartCore(Uri uri, string contentType, CompressionOption compressionOption);
    protected virtual void DeletePartCore(Uri uri);
    protected virtual PackagePart[] GetPartsCore();
    protected virtual void FlushCore();
}
internal class MS.Internal.AppModel.ResourcePart : PackagePart {
    [SecurityCriticalAttribute]
public ResourcePart(Package container, Uri uri, string name, ResourceManagerWrapper rmWrapper);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
}
internal class MS.Internal.AppModel.ReturnEventSaver : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void _Detach(PageFunctionBase pf);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void _Attach(object caller, PageFunctionBase child);
}
internal class MS.Internal.AppModel.ReturnEventSaverInfo : ValueType {
    internal string _delegateTypeName;
    internal string _targetTypeName;
    internal string _delegateMethodName;
    internal bool _delegateInSamePF;
    internal ReturnEventSaverInfo(string delegateTypeName, string targetTypeName, string delegateMethodName, bool fSamePf);
}
internal class MS.Internal.AppModel.RootBrowserWindow : NavigationWindow {
    internal bool HasTravelLogIntegration { get; }
    private static RootBrowserWindow();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnInitialized(EventArgs args);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual void OnStateChanged(EventArgs e);
    protected virtual void OnLocationChanged(EventArgs e);
    protected virtual void OnClosing(CancelEventArgs e);
    protected virtual void OnClosed(EventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnContentRendered(EventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    [SecurityCriticalAttribute]
internal static RootBrowserWindow CreateAndInitialize();
    [SecurityCriticalAttribute]
internal virtual void CreateAllStyle();
    [SecurityCriticalAttribute]
internal virtual HwndSourceParameters CreateHwndSourceParameters();
    [SecurityCriticalAttribute]
internal virtual void CreateSourceWindowDuringShow();
    internal virtual void TryClearingMainWindow();
    internal virtual void CorrectStyleForBorderlessWindowCase();
    internal virtual void GetRequestedDimensions(Double& requestedLeft, Double& requestedTop, Double& requestedWidth, Double& requestedHeight);
    [SecurityCriticalAttribute]
internal virtual void SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight);
    internal virtual int nCmdForShow();
    internal virtual bool HandleWmNcHitTestMsg(IntPtr lParam, IntPtr& refInt);
    internal virtual WindowMinMax GetWindowMinMax();
    internal virtual void WmMoveChangedHelper();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ResizeMove(int xDeviceUnits, int yDeviceUnits, int widthDeviceUnits, int heightDeviceUnits);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateTitle(string titleStr);
    [SecurityCriticalAttribute]
internal void SetStatusBarText(string statusString);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateHeight(double newHeightLogicalUnits);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateWidth(double newWidthLogicalUnits);
    internal void SetJournalForBrowserInterop(Journal journal);
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.OnJournalAvailable();
    [SecurityCriticalAttribute]
private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoBackOverride();
    [SecurityCriticalAttribute]
private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoForwardOverride();
    internal virtual void VerifyApiSupported();
    internal virtual void ClearResizeGripControl(Control oldCtrl);
    internal virtual void SetResizeGripControl(Control ctrl);
    internal void AddLayoutUpdatedHandler();
    internal void TabInto(bool forward);
    internal bool get_HasTravelLogIntegration();
}
internal class MS.Internal.AppModel.RootBrowserWindowProxy : MarshalByRefObject {
    internal RootBrowserWindow RootBrowserWindow { get; }
    internal RootBrowserWindowProxy(RootBrowserWindow rbw);
    internal RootBrowserWindow get_RootBrowserWindow();
    internal void TabInto(bool forward);
}
internal static class MS.Internal.AppModel.ShellUtil : object {
    [SecurityCriticalAttribute]
public static string GetPathFromShellItem(IShellItem item);
    [SecurityCriticalAttribute]
public static string GetPathForKnownFolder(Guid knownFolder);
    [SecurityCriticalAttribute]
public static IShellItem2 GetShellItemForPath(string path);
}
internal class MS.Internal.AppModel.StreamToObjectFactoryDelegate : MulticastDelegate {
    public StreamToObjectFactoryDelegate(object object, IntPtr method);
    public virtual object Invoke(Stream s, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    public virtual IAsyncResult BeginInvoke(Stream s, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter, AsyncCallback callback, object object);
    public virtual object EndInvoke(XamlReader& asyncObjectConverter, IAsyncResult result);
}
internal class MS.Internal.AppModel.SubStream : ValueType {
    internal string _propertyName;
    internal Byte[] _data;
    internal SubStream(string propertyName, Byte[] dataBytes);
}
internal class MS.Internal.AppModel.THUMBBUTTON : ValueType {
    public static int THBN_CLICKED;
    public THB dwMask;
    public UInt32 iId;
    public UInt32 iBitmap;
    public IntPtr hIcon;
    public string szTip;
    public THBF dwFlags;
}
internal class MS.Internal.AppModel.XappLauncherApp : Application {
    [SecurityCriticalAttribute]
internal XappLauncherApp(Uri deploymentManifest, string applicationId, IBrowserCallbackServices browser, ApplicationRunnerCallback applicationRunner, INativeProgressPage nativeProgressPage, string progressPageAssembly, string progressPageClass, string errorPageAssembly, string errorPageClass);
    internal virtual void PerformNavigationStateChangeTasks(bool isNavigationInitiator, bool playNavigatingSound, NavigationStateChange state);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void HandleRefresh();
    internal void UserStop();
    internal void AbortActivation();
}
internal class MS.Internal.AssemblyFilter : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static AssemblyFilter();
    [SecurityCriticalAttribute]
internal void FilterCallback(object sender, AssemblyLoadEventArgs args);
}
internal class MS.Internal.Automation.TextAdaptor : object {
    private ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.DocumentRange { get; }
    private SupportedTextSelection System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection { get; }
    internal TextAdaptor(AutomationPeer textPeer, ITextContainer textContainer);
    public sealed virtual void Dispose();
    internal Rect[] GetBoundingRectangles(ITextPointer start, ITextPointer end, bool clipToView, bool transformToScreen);
    internal ITextView GetUpdatedTextView();
    internal void Select(ITextPointer start, ITextPointer end);
    internal void ScrollIntoView(ITextPointer start, ITextPointer end, bool alignToTop);
    private sealed virtual override ITextRangeProvider[] System.Windows.Automation.Provider.ITextProvider.GetSelection();
    private sealed virtual override ITextRangeProvider[] System.Windows.Automation.Provider.ITextProvider.GetVisibleRanges();
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.RangeFromChild(IRawElementProviderSimple childElementProvider);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.RangeFromPoint(Point location);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.get_DocumentRange();
    private sealed virtual override SupportedTextSelection System.Windows.Automation.Provider.ITextProvider.get_SupportedTextSelection();
}
internal class MS.Internal.Automation.TextRangeAdaptor : object {
    private static TextRangeAdaptor();
    internal TextRangeAdaptor(TextAdaptor textAdaptor, ITextPointer start, ITextPointer end, AutomationPeer textPeer);
    internal static bool MoveToInsertionPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.Clone();
    private sealed virtual override bool System.Windows.Automation.Provider.ITextRangeProvider.Compare(ITextRangeProvider range);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(TextUnit unit);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(int attributeId, object value, bool backward);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.FindText(string text, bool backward, bool ignoreCase);
    private sealed virtual override object System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(int attributeId);
    private sealed virtual override Double[] System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement();
    private sealed virtual override string System.Windows.Automation.Provider.ITextRangeProvider.GetText(int maxLength);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.Move(TextUnit unit, int count);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(bool alignToTop);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITextRangeProvider.GetChildren();
}
internal static class MS.Internal.Commands.CommandHelpers : object {
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, InputGesture inputGesture);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, Key key);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, Key key);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2, InputGesture inputGesture3, InputGesture inputGesture4);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, Key key, ModifierKeys modifierKeys, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, string srid1, string srid2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, string srid1, string srid2);
    internal static bool CanExecuteCommandSource(ICommandSource commandSource);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ExecuteCommandSource(ICommandSource commandSource);
    [SecurityCriticalAttribute]
internal static void CriticalExecuteCommandSource(ICommandSource commandSource, bool userInitiated);
    internal static void ExecuteCommand(ICommand command, object parameter, IInputElement target);
}
internal class MS.Internal.Controls.ActiveXContainer : object {
    internal ActiveXHost ActiveXHost { get; }
    [SecurityCriticalAttribute]
internal ActiveXContainer(ActiveXHost host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.ParseDisplayName(object pbc, string pszDisplayName, Int32[] pchEaten, Object[] ppmkOut);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.EnumObjects(int grfFlags, IEnumUnknown& ppenum);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.LockContainer(bool fLock);
    [SecurityCriticalAttribute]
private sealed virtual override IntPtr MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.GetWindow();
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.ContextSensitiveHelp(int fEnterMode);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.GetBorder(COMRECT lprectBorder);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.RequestBorderSpace(COMRECT pborderwidths);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetBorderSpace(COMRECT pborderwidths);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetActiveObject(IOleInPlaceActiveObject pActiveObject, string pszObjName);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.InsertMenus(IntPtr hmenuShared, tagOleMenuGroupWidths lpMenuWidths);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.RemoveMenus(IntPtr hmenuShared);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetStatusText(string pszStatusText);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.EnableModeless(bool fEnable);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.TranslateAccelerator(MSG& lpmsg, short wID);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnUIActivate(ActiveXHost site);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnUIDeactivate(ActiveXHost site);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnInPlaceDeactivate(ActiveXHost site);
    [SecurityCriticalAttribute]
internal ActiveXHost get_ActiveXHost();
}
internal class MS.Internal.Controls.ActiveXHelper : object {
    public static int sinkAttached;
    public static int inTransition;
    public static int processingKeyUp;
    public static int LogPixelsX { get; }
    public static int LogPixelsY { get; }
    private static ActiveXHelper();
    public static int Pix2HM(int pix, int logP);
    public static int HM2Pix(int hm, int logP);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int get_LogPixelsX();
    public static void ResetLogPixelsX();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static int get_LogPixelsY();
    public static void ResetLogPixelsY();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static object CreateIDispatchSTAForwarder(object pDispatchDelegate);
}
internal class MS.Internal.Controls.ActiveXSite : object {
    internal COMRECT HostBounds { get; }
    internal ActiveXHost Host { get; }
    [SecurityCriticalAttribute]
internal ActiveXSite(ActiveXHost host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.OnControlInfoChanged();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.LockInPlaceActive(int fLock);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.GetExtendedControl(Object& ppDisp);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TransformCoords(POINT pPtlHimetric, POINTF pPtfContainer, int dwFlags);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TranslateAccelerator(MSG& pMsg, int grfModifiers);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.OnFocus(int fGotFocus);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.ShowPropertyFrame();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.SaveObject();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.GetMoniker(int dwAssign, int dwWhichMoniker, Object& moniker);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.GetContainer(IOleContainer& container);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.ShowObject();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.OnShowWindow(int fShow);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.RequestNewObjectLayout();
    [SecurityCriticalAttribute]
private sealed virtual override IntPtr MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.GetWindow();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.ContextSensitiveHelp(int fEnterMode);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.CanInPlaceActivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceActivate();
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnUIActivate();
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext(IOleInPlaceFrame& ppFrame, IOleInPlaceUIWindow& ppDoc, COMRECT lprcPosRect, COMRECT lprcClipRect, OLEINPLACEFRAMEINFO lpFrameInfo);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.Scroll(SIZE scrollExtant);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnUIDeactivate(int fUndoable);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceDeactivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.DiscardUndoState();
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.DeactivateAndUndo();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnPosRectChange(COMRECT lprcPosRect);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal COMRECT get_HostBounds();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.IPropertyNotifySink.OnChanged(int dispid);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IPropertyNotifySink.OnRequestEdit(int dispid);
    [SecurityCriticalAttribute]
internal virtual void OnPropertyChanged(int dispid);
    [SecurityCriticalAttribute]
internal ActiveXHost get_Host();
    [SecurityCriticalAttribute]
internal void StartEvents();
    [SecurityCriticalAttribute]
internal void StopEvents();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal int OnActiveXRectChange(COMRECT lprcPosRect);
}
internal class MS.Internal.Controls.ConnectionPointCookie : object {
    [SecurityCriticalAttribute]
internal ConnectionPointCookie(object source, object sink, Type eventInterface);
    [SecurityCriticalAttribute]
internal void Disconnect();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual override void Finalize();
}
internal class MS.Internal.Controls.ContentModelTreeEnumerator : ModelTreeEnumerator {
    protected bool IsUnchanged { get; }
    internal ContentModelTreeEnumerator(ContentControl contentControl, object content);
    protected virtual bool get_IsUnchanged();
}
internal class MS.Internal.Controls.EmptyEnumerable : object {
    public static IEnumerable Instance { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static IEnumerable get_Instance();
}
internal class MS.Internal.Controls.EmptyEnumerator : object {
    public static IEnumerator Instance { get; }
    public object Current { get; }
    public static IEnumerator get_Instance();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
}
internal class MS.Internal.Controls.EnumUnknown : object {
    internal EnumUnknown(Object[] arr);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IEnumUnknown.Next(int celt, IntPtr rgelt, IntPtr pceltFetched);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IEnumUnknown.Skip(int celt);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.IEnumUnknown.Reset();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.IEnumUnknown.Clone(IEnumUnknown& ppenum);
}
internal class MS.Internal.Controls.HeaderedContentModelTreeEnumerator : ModelTreeEnumerator {
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal HeaderedContentModelTreeEnumerator(HeaderedContentControl headeredContentControl, object content, object header);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual bool get_IsUnchanged();
}
internal class MS.Internal.Controls.HeaderedItemsModelTreeEnumerator : ModelTreeEnumerator {
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal HeaderedItemsModelTreeEnumerator(HeaderedItemsControl headeredItemsControl, IEnumerator items, object header);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual void Reset();
    protected virtual bool get_IsUnchanged();
}
internal interface MS.Internal.Controls.IGeneratorHost {
    public ItemCollection View { get; }
    public int AlternationCount { get; }
    public abstract virtual ItemCollection get_View();
    public abstract virtual bool IsItemItsOwnContainer(object item);
    public abstract virtual DependencyObject GetContainerForItem(object item);
    public abstract virtual void PrepareItemContainer(DependencyObject container, object item);
    public abstract virtual void ClearContainerForItem(DependencyObject container, object item);
    public abstract virtual bool IsHostForItemContainer(DependencyObject container);
    public abstract virtual GroupStyle GetGroupStyle(CollectionViewGroup group, int level);
    public abstract virtual void SetIsGrouping(bool isGrouping);
    public abstract virtual int get_AlternationCount();
}
internal class MS.Internal.Controls.InkCanvasFeedbackAdorner : Adorner {
    internal InkCanvasFeedbackAdorner(InkCanvas inkCanvas);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void UpdateBounds(Rect rect);
}
internal class MS.Internal.Controls.InkCanvasInnerCanvas : Panel {
    protected internal IEnumerator LogicalChildren { get; }
    internal IEnumerator PrivateLogicalChildren { get; }
    internal InkCanvas InkCanvas { get; }
    internal InkCanvasInnerCanvas(InkCanvas inkCanvas);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal UIElement HitTestOnElements(Point point);
    internal IEnumerator get_PrivateLogicalChildren();
    internal InkCanvas get_InkCanvas();
}
internal class MS.Internal.Controls.InkCanvasSelectionAdorner : Adorner {
    internal InkCanvasSelectionAdorner(UIElement adornedElement);
    internal InkCanvasSelectionHitResult SelectionHandleHitTest(Point point);
    internal void UpdateSelectionWireFrame(Rect strokesBounds, List`1<Rect> hatchBounds);
    protected virtual void OnRender(DrawingContext drawingContext);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Controls.InnerItemCollectionView : CollectionView {
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public IEnumerable SourceCollection { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NeedsRefresh { get; }
    internal ItemCollection ItemCollection { get; }
    internal IEnumerator LogicalChildren { get; }
    internal int RawCount { get; }
    public InnerItemCollectionView(int capacity, ItemCollection itemCollection);
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool Contains(object item);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int Add(object item);
    public sealed virtual void Clear();
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void Remove(object item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual IEnumerable get_SourceCollection();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_NeedsRefresh();
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    internal ItemCollection get_ItemCollection();
    internal IEnumerator get_LogicalChildren();
    internal int get_RawCount();
}
internal abstract class MS.Internal.Controls.ModelTreeEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    protected object Content { get; }
    protected int Index { get; protected set; }
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal ModelTreeEnumerator(object content);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    protected object get_Content();
    protected int get_Index();
    protected void set_Index(int value);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual void Reset();
    protected abstract virtual bool get_IsUnchanged();
    protected void VerifyUnchanged();
}
internal class MS.Internal.Controls.StickyNote.LockHelper : object {
    public bool IsLocked(LockFlag flag);
}
internal static class MS.Internal.Controls.StickyNote.SNBConstants : object {
    internal static string c_CloseButtonId;
    internal static string c_TitleThumbId;
    internal static string c_BottomRightResizeThumbId;
    internal static string c_ContentControlId;
    internal static string c_IconButtonId;
    internal static string c_CopyMenuId;
    internal static string c_PasteMenuId;
    internal static string c_ClipboardSeparatorId;
    internal static string c_DeleteMenuId;
    internal static string c_InkMenuId;
    internal static string c_SelectMenuId;
    internal static string c_EraseMenuId;
    internal static string MetaResourceName;
    internal static string TextResourceName;
    internal static string InkResourceName;
}
internal class MS.Internal.Controls.StickyNote.SNCAnnotation : object {
    public static XmlToken AllValues;
    public static XmlToken PositionValues;
    public static XmlToken Sizes;
    public static XmlToken AllContents;
    public static XmlToken NegativeAllContents;
    public bool IsNewAnnotation { get; }
    public bool HasInkData { get; }
    public bool HasTextData { get; }
    private static SNCAnnotation();
    public SNCAnnotation(Annotation annotation);
    public static void UpdateAnnotation(XmlToken token, StickyNoteControl snc, SNCAnnotation sncAnnotation);
    public static void UpdateStickyNoteControl(XmlToken token, StickyNoteControl snc, SNCAnnotation sncAnnotation);
    public bool get_IsNewAnnotation();
    public bool get_HasInkData();
    public bool get_HasTextData();
}
internal abstract class MS.Internal.Controls.StickyNote.StickyNoteContentControl : object {
    protected FrameworkElement _innerControl;
    protected static long MaxBufferSize;
    public bool IsEmpty { get; }
    public StickyNoteType Type { get; }
    public FrameworkElement InnerControl { get; }
    protected StickyNoteContentControl(FrameworkElement innerControl);
    public abstract virtual void Save(XmlNode node);
    public abstract virtual void Load(XmlNode node);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual StickyNoteType get_Type();
    public FrameworkElement get_InnerControl();
    protected void SetInnerControl(FrameworkElement innerControl);
}
internal static class MS.Internal.Controls.StickyNote.StickyNoteContentControlFactory : object {
    public static StickyNoteContentControl CreateContentControl(StickyNoteType type, UIElement content);
}
[FlagsAttribute]
internal enum MS.Internal.Controls.StickyNote.XmlToken : Enum {
    public int value__;
    public static XmlToken MetaData;
    public static XmlToken Left;
    public static XmlToken Top;
    public static XmlToken XOffset;
    public static XmlToken YOffset;
    public static XmlToken Width;
    public static XmlToken Height;
    public static XmlToken IsExpanded;
    public static XmlToken Author;
    public static XmlToken Text;
    public static XmlToken Ink;
    public static XmlToken ZOrder;
}
internal class MS.Internal.Controls.TemplatedAdorner : Adorner {
    public FrameworkElement ReferenceElement { get; public set; }
    protected int VisualChildrenCount { get; }
    public TemplatedAdorner(UIElement adornedElement, ControlTemplate adornerTemplate);
    public void ClearChild();
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public FrameworkElement get_ReferenceElement();
    public void set_ReferenceElement(FrameworkElement value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size size);
    internal virtual bool NeedsUpdate(Size oldSize);
}
internal class MS.Internal.Controls.ValidationErrorCollection : ObservableCollection`1<ValidationError> {
    public static ReadOnlyObservableCollection`1<ValidationError> Empty;
    private static ValidationErrorCollection();
}
internal class MS.Internal.Controls.ValidationRuleCollection : Collection`1<ValidationRule> {
    protected virtual void InsertItem(int index, ValidationRule item);
    protected virtual void SetItem(int index, ValidationRule item);
}
[ClassInterfaceAttribute("0")]
internal class MS.Internal.Controls.WebBrowserEvent : InternalDispatchObject`1<DWebBrowserEvents2> {
    [SecurityCriticalAttribute]
public WebBrowserEvent(WebBrowser parent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void BeforeNavigate2(object pDisp, Object& url, Object& flags, Object& targetFrameName, Object& postData, Object& headers, Boolean& cancel);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void NavigateComplete2(object pDisp, Object& url);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void DocumentComplete(object pDisp, Object& url);
    [SecurityCriticalAttribute]
public sealed virtual void CommandStateChange(long command, bool enable);
    [SecurityCriticalAttribute]
public sealed virtual void TitleChange(string text);
    [SecurityCriticalAttribute]
public sealed virtual void SetSecureLockIcon(int secureLockIcon);
    [SecurityCriticalAttribute]
public sealed virtual void NewWindow2(Object& ppDisp, Boolean& cancel);
    [SecurityCriticalAttribute]
public sealed virtual void ProgressChange(int progress, int progressMax);
    [SecurityCriticalAttribute]
public sealed virtual void StatusTextChange(string text);
    [SecurityCriticalAttribute]
public sealed virtual void DownloadBegin();
    [SecurityCriticalAttribute]
public sealed virtual void FileDownload(Boolean& activeDocument, Boolean& cancel);
    [SecurityCriticalAttribute]
public sealed virtual void PrivacyImpactedStateChange(bool bImpacted);
    [SecurityCriticalAttribute]
public sealed virtual void UpdatePageStatus(object pDisp, Object& nPage, Object& fDone);
    [SecurityCriticalAttribute]
public sealed virtual void PrintTemplateTeardown(object pDisp);
    [SecurityCriticalAttribute]
public sealed virtual void PrintTemplateInstantiation(object pDisp);
    [SecurityCriticalAttribute]
public sealed virtual void NavigateError(object pDisp, Object& url, Object& frame, Object& statusCode, Boolean& cancel);
    [SecurityCriticalAttribute]
public sealed virtual void ClientToHostWindow(Int64& cX, Int64& cY);
    [SecurityCriticalAttribute]
public sealed virtual void WindowClosing(bool isChildWindow, Boolean& cancel);
    [SecurityCriticalAttribute]
public sealed virtual void WindowSetHeight(int height);
    [SecurityCriticalAttribute]
public sealed virtual void WindowSetWidth(int width);
    [SecurityCriticalAttribute]
public sealed virtual void WindowSetTop(int top);
    [SecurityCriticalAttribute]
public sealed virtual void WindowSetLeft(int left);
    [SecurityCriticalAttribute]
public sealed virtual void WindowSetResizable(bool resizable);
    [SecurityCriticalAttribute]
public sealed virtual void OnTheaterMode(bool theaterMode);
    [SecurityCriticalAttribute]
public sealed virtual void OnFullScreen(bool fullScreen);
    [SecurityCriticalAttribute]
public sealed virtual void OnStatusBar(bool statusBar);
    [SecurityCriticalAttribute]
public sealed virtual void OnMenuBar(bool menuBar);
    [SecurityCriticalAttribute]
public sealed virtual void OnToolBar(bool toolBar);
    [SecurityCriticalAttribute]
public sealed virtual void OnVisible(bool visible);
    [SecurityCriticalAttribute]
public sealed virtual void OnQuit();
    [SecurityCriticalAttribute]
public sealed virtual void PropertyChange(string szProperty);
    [SecurityCriticalAttribute]
public sealed virtual void DownloadComplete();
    [SecurityCriticalAttribute]
public sealed virtual void SetPhishingFilterStatus(UInt32 phishingFilterStatus);
    [SecurityCriticalAttribute]
public sealed virtual void WindowStateChanged(UInt32 dwFlags, UInt32 dwValidFlagsMask);
}
internal class MS.Internal.Controls.WebBrowserSite : ActiveXSite {
    [SecurityCriticalAttribute]
internal WebBrowserSite(WebBrowser host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ShowContextMenu(int dwID, POINT pt, object pcmdtReserved, object pdispReserved);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetHostInfo(DOCHOSTUIINFO info);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.EnableModeless(bool fEnable);
    [SecuritySafeCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ShowUI(int dwID, IOleInPlaceActiveObject activeObject, IOleCommandTarget commandTarget, IOleInPlaceFrame frame, IOleInPlaceUIWindow doc);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.HideUI();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.UpdateUI();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.OnDocWindowActivate(bool fActivate);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.OnFrameWindowActivate(bool fActivate);
    [SecuritySafeCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ResizeBorder(COMRECT rect, IOleInPlaceUIWindow doc, bool fFrameWindow);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetOptionKeyPath(String[] pbstrKey, int dw);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetDropTarget(IOleDropTarget pDropTarget, IOleDropTarget& ppDropTarget);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetExternal(Object& ppDispatch);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.TranslateAccelerator(MSG& msg, Guid& group, int nCmdID);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.TranslateUrl(int dwTranslate, string strUrlIn, String& pstrUrlOut);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.FilterDataObject(IDataObject pDO, IDataObject& ppDORet);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TranslateAccelerator(MSG& msg, int grfModifiers);
}
internal class MS.Internal.Data.AbandonedGroupItem : object {
    public LiveShapingItem Item { get; }
    public CollectionViewGroupInternal Group { get; }
    public AbandonedGroupItem(LiveShapingItem lsi, CollectionViewGroupInternal group);
    public LiveShapingItem get_Item();
    public CollectionViewGroupInternal get_Group();
}
internal class MS.Internal.Data.AccessorInfo : object {
    internal object Accessor { get; }
    internal Type PropertyType { get; }
    internal Object[] Args { get; }
    internal int Generation { get; internal set; }
    internal AccessorInfo(object accessor, Type propertyType, Object[] args);
    internal object get_Accessor();
    internal Type get_PropertyType();
    internal Object[] get_Args();
    internal int get_Generation();
    internal void set_Generation(int value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.AccessorTable : object {
    internal AccessorInfo Item { get; internal set; }
    internal bool TraceSize { get; internal set; }
    internal AccessorInfo get_Item(SourceValueType sourceValueType, Type type, string name);
    internal void set_Item(SourceValueType sourceValueType, Type type, string name, AccessorInfo value);
    internal void PrintStats();
    internal bool get_TraceSize();
    internal void set_TraceSize(bool value);
}
internal class MS.Internal.Data.AsyncDataRequest : object {
    public object Result { get; }
    public AsyncRequestStatus Status { get; }
    public Exception Exception { get; }
    internal Object[] Args { get; }
    internal AsyncDataRequest(object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_Result();
    public AsyncRequestStatus get_Status();
    public Exception get_Exception();
    public object DoWork();
    public bool DoBeginWork();
    public void Complete(object result);
    public void Cancel();
    public void Fail(Exception exception);
    internal Object[] get_Args();
}
internal class MS.Internal.Data.AsyncGetValueRequest : AsyncDataRequest {
    public object SourceItem { get; }
    internal AsyncGetValueRequest(object item, string propertyName, object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_SourceItem();
}
internal class MS.Internal.Data.AsyncRequestCallback : MulticastDelegate {
    public AsyncRequestCallback(object object, IntPtr method);
    public virtual object Invoke(AsyncDataRequest request);
    public virtual IAsyncResult BeginInvoke(AsyncDataRequest request, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal enum MS.Internal.Data.AsyncRequestStatus : Enum {
    public int value__;
    public static AsyncRequestStatus Waiting;
    public static AsyncRequestStatus Working;
    public static AsyncRequestStatus Completed;
    public static AsyncRequestStatus Cancelled;
    public static AsyncRequestStatus Failed;
}
internal class MS.Internal.Data.AsyncSetValueRequest : AsyncDataRequest {
    public object TargetItem { get; }
    public object Value { get; }
    internal AsyncSetValueRequest(object item, string propertyName, object value, object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_TargetItem();
    public object get_Value();
}
internal class MS.Internal.Data.BindingCollection : Collection`1<BindingBase> {
    internal BindingCollection(BindingBase owner, BindingCollectionChangedCallback callback);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, BindingBase item);
    protected virtual void SetItem(int index, BindingBase item);
}
internal class MS.Internal.Data.BindingCollectionChangedCallback : MulticastDelegate {
    public BindingCollectionChangedCallback(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Data.BindingExpressionUncommonField : UncommonField`1<BindingExpression> {
    internal void SetValue(DependencyObject instance, BindingExpression bindingExpr);
    internal void ClearValue(DependencyObject instance);
}
internal class MS.Internal.Data.BindingValueChangedEventArgs : EventArgs {
    public object OldValue { get; }
    public object NewValue { get; }
    internal BindingValueChangedEventArgs(object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
}
internal abstract class MS.Internal.Data.BindingWorker : object {
    internal Type SourcePropertyType { get; }
    internal bool CanUpdate { get; }
    internal BindingExpression ParentBindingExpression { get; }
    internal Type TargetPropertyType { get; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    protected Binding ParentBinding { get; }
    protected bool IsDynamic { get; }
    internal bool IsReflective { get; }
    protected bool IgnoreSourcePropertyChange { get; }
    protected object DataItem { get; }
    protected DependencyObject TargetElement { get; }
    protected DependencyProperty TargetProperty { get; }
    protected DataBindEngine Engine { get; }
    protected Dispatcher Dispatcher { get; }
    protected BindingStatusInternal Status { get; protected set; }
    private static BindingWorker();
    protected BindingWorker(BindingExpression b);
    internal virtual Type get_SourcePropertyType();
    internal virtual bool get_CanUpdate();
    internal BindingExpression get_ParentBindingExpression();
    internal Type get_TargetPropertyType();
    internal virtual bool get_IsDBNullValidForUpdate();
    internal virtual object get_SourceItem();
    internal virtual string get_SourcePropertyName();
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual object RawValue();
    internal virtual void UpdateValue(object value);
    internal virtual void RefreshValue();
    internal virtual bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal virtual void OnSourceInvalidation(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal virtual bool IsPathCurrent();
    protected Binding get_ParentBinding();
    protected bool get_IsDynamic();
    internal bool get_IsReflective();
    protected bool get_IgnoreSourcePropertyChange();
    protected object get_DataItem();
    protected DependencyObject get_TargetElement();
    protected DependencyProperty get_TargetProperty();
    protected DataBindEngine get_Engine();
    protected Dispatcher get_Dispatcher();
    protected BindingStatusInternal get_Status();
    protected void set_Status(BindingStatusInternal value);
    protected void SetTransferIsPending(bool value);
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
}
internal class MS.Internal.Data.ClrBindingWorker : BindingWorker {
    internal Type SourcePropertyType { get; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal bool CanUpdate { get; }
    internal bool TransfersDefaultValue { get; }
    internal bool ValidatesOnNotifyDataErrors { get; }
    internal ClrBindingWorker(BindingExpression b, DataBindEngine engine);
    private static ClrBindingWorker();
    internal virtual Type get_SourcePropertyType();
    internal virtual bool get_IsDBNullValidForUpdate();
    internal virtual object get_SourceItem();
    internal virtual string get_SourcePropertyName();
    internal virtual bool get_CanUpdate();
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual object RawValue();
    internal virtual void RefreshValue();
    internal virtual void UpdateValue(object value);
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal virtual void OnSourceInvalidation(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal virtual bool IsPathCurrent();
    internal bool get_TransfersDefaultValue();
    internal bool get_ValidatesOnNotifyDataErrors();
    internal void CancelPendingTasks();
    internal bool AsyncGet(object item, int level);
    internal void ReplaceCurrentItem(ICollectionView oldCollectionView, ICollectionView newCollectionView);
    internal void NewValueAvailable(bool dependencySourcesChanged, bool initialValue, bool isASubPropertyChange);
    internal void SetupDefaultValueConverter(Type type);
    internal bool IsValidValue(object value);
    internal void OnSourcePropertyChanged(object o, string propName);
    internal void OnDataErrorsChanged(INotifyDataErrorInfo indei, string propName);
    internal void OnXmlValueChanged();
    internal void UseNewXmlItem(object item);
    internal object GetResultNode();
    internal DependencyObject CheckTarget();
    internal void ReportGetValueError(int k, object item, Exception ex);
    internal void ReportSetValueError(int k, object item, object value, Exception ex);
    internal void ReportRawValueErrors(int k, object item, object info);
    internal void ReportBadXPath(TraceEventType traceType);
}
internal class MS.Internal.Data.CollectionRecord : object {
    public SynchronizationInfo SynchronizationInfo;
    public ViewTable ViewTable { get; public set; }
    public bool IsAlive { get; }
    public ViewTable get_ViewTable();
    public void set_ViewTable(ViewTable value);
    public bool get_IsAlive();
}
internal class MS.Internal.Data.CollectionViewGroupInternal : CollectionViewGroup {
    public bool IsBottomLevel { get; }
    internal GroupDescription GroupBy { get; internal set; }
    internal int FullCount { get; internal set; }
    internal int LastIndex { get; internal set; }
    internal object SeedItem { get; }
    internal CollectionViewGroupInternal Parent { get; }
    internal CollectionViewGroupInternal(object name, CollectionViewGroupInternal parent, bool isExplicit);
    private static CollectionViewGroupInternal();
    public virtual bool get_IsBottomLevel();
    internal GroupDescription get_GroupBy();
    internal void set_GroupBy(GroupDescription value);
    internal int get_FullCount();
    internal void set_FullCount(int value);
    internal int get_LastIndex();
    internal void set_LastIndex(int value);
    internal object get_SeedItem();
    internal void Add(object item);
    internal int Remove(object item, bool returnLeafIndex);
    internal void Clear();
    internal int LeafIndexOf(object item);
    internal int LeafIndexFromItem(object item, int index);
    internal object LeafAt(int index);
    internal IEnumerator GetLeafEnumerator();
    internal int Insert(object item, object seed, IComparer comparer);
    protected virtual int FindIndex(object item, object seed, IComparer comparer, int low, int high);
    internal bool Move(object item, IList list, Int32& oldIndex, Int32& newIndex);
    protected virtual void OnGroupByChanged();
    internal void AddSubgroupToMap(object nameKey, CollectionViewGroupInternal subgroup);
    internal CollectionViewGroupInternal GetSubgroupFromMap(object nameKey);
    internal CollectionViewGroupInternal get_Parent();
    protected void ChangeCounts(object item, int delta);
}
internal class MS.Internal.Data.CollectionViewGroupRoot : CollectionViewGroupInternal {
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    internal IComparer ActiveComparer { get; internal set; }
    internal CultureInfo Culture { get; }
    internal bool IsDataInGroupOrder { get; internal set; }
    internal CollectionView View { get; }
    internal CollectionViewGroupRoot(CollectionView view);
    private static CollectionViewGroupRoot();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual GroupDescriptionSelectorCallback get_GroupBySelector();
    public virtual void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    protected virtual void OnGroupByChanged();
    [CompilerGeneratedAttribute]
internal void add_GroupDescriptionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_GroupDescriptionChanged(EventHandler value);
    internal IComparer get_ActiveComparer();
    internal void set_ActiveComparer(IComparer value);
    internal CultureInfo get_Culture();
    internal bool get_IsDataInGroupOrder();
    internal void set_IsDataInGroupOrder(bool value);
    internal CollectionView get_View();
    internal void Initialize();
    internal void AddToSubgroups(object item, LiveShapingItem lsi, bool loading);
    internal bool RemoveFromSubgroups(object item);
    internal void RemoveItemFromSubgroupsByExhaustiveSearch(object item);
    internal void InsertSpecialItem(int index, object item, bool loading);
    internal void RemoveSpecialItem(int index, object item, bool loading);
    internal void MoveWithinSubgroups(object item, LiveShapingItem lsi, IList list, int oldIndex, int newIndex);
    protected virtual int FindIndex(object item, object seed, IComparer comparer, int low, int high);
    internal void RestoreGrouping(LiveShapingItem lsi, List`1<AbandonedGroupItem> deleteList);
    internal void DeleteAbandonedGroupItems(List`1<AbandonedGroupItem> deleteList);
}
internal class MS.Internal.Data.CollectionViewProxy : CollectionView {
    public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollectionView ProxiedView { get; }
    private NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition { get; private set; }
    private bool System.ComponentModel.IEditableCollectionView.CanAddNew { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsAddingNew { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentAddItem { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanRemove { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanCancelEdit { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsEditingItem { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentEditItem { get; }
    private bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveSorting { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveFiltering { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveGrouping { get; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveSorting { get; private set; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveFiltering { get; private set; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveGrouping { get; private set; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveSortingProperties { get; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveFilteringProperties { get; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveGroupingProperties { get; }
    private ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.ItemProperties { get; }
    internal CollectionViewProxy(ICollectionView view);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual IEnumerable get_SourceCollection();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual void Refresh();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    public virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    public virtual void add_CurrentChanged(EventHandler value);
    public virtual void remove_CurrentChanged(EventHandler value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public ICollectionView get_ProxiedView();
    public virtual int IndexOf(object item);
    public virtual bool PassesFilter(object item);
    public virtual object GetItemAt(int index);
    public virtual void DetachFromSourceCollection();
    private sealed virtual override NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.get_NewItemPlaceholderPosition();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanAddNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.AddNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelNew();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsAddingNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentAddItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanRemove();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.Remove(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.EditItem(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitEdit();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanCancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsEditingItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentEditItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionViewAddNewItem.get_CanAddNewItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(object newItem);
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveSorting();
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveFiltering();
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveGrouping();
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveSorting();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveSorting(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveFiltering();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveFiltering(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveGrouping();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveGrouping(Nullable`1<bool> value);
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveSortingProperties();
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveFilteringProperties();
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveGroupingProperties();
    private sealed virtual override ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.get_ItemProperties();
    protected virtual IEnumerator GetEnumerator();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
}
internal class MS.Internal.Data.CommitManager : object {
    internal bool IsEmpty { get; }
    private static CommitManager();
    internal bool get_IsEmpty();
    internal void AddBindingGroup(BindingGroup bindingGroup);
    internal void RemoveBindingGroup(BindingGroup bindingGroup);
    internal void AddBinding(BindingExpressionBase binding);
    internal void RemoveBinding(BindingExpressionBase binding);
    internal List`1<BindingGroup> GetBindingGroupsInScope(DependencyObject element);
    internal List`1<BindingExpressionBase> GetBindingsInScope(DependencyObject element);
    internal bool Purge();
}
internal class MS.Internal.Data.CompositeCollectionView : CollectionView {
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public bool CanFilter { get; }
    internal CompositeCollectionView(CompositeCollection collection);
    private static CompositeCollectionView();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool get_CanFilter();
    public virtual bool Contains(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    internal void OnContainedCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    internal virtual bool HasReliableHashCodes();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
}
internal class MS.Internal.Data.DataBindEngine : DispatcherObject {
    internal static int CrossThreadThreshold;
    internal PathParser PathParser { get; }
    internal ValueConverterContext ValueConverterContext { get; }
    internal AccessorTable AccessorTable { get; }
    internal bool IsShutDown { get; }
    internal bool CleanupEnabled { get; internal set; }
    internal IAsyncDataDispatcher AsyncDataDispatcher { get; }
    internal static DataBindEngine CurrentDataBindEngine { get; }
    internal ViewManager ViewManager { get; }
    internal CommitManager CommitManager { get; }
    internal PathParser get_PathParser();
    internal ValueConverterContext get_ValueConverterContext();
    internal AccessorTable get_AccessorTable();
    internal bool get_IsShutDown();
    internal bool get_CleanupEnabled();
    internal void set_CleanupEnabled(bool value);
    internal IAsyncDataDispatcher get_AsyncDataDispatcher();
    internal static DataBindEngine get_CurrentDataBindEngine();
    internal ViewManager get_ViewManager();
    internal CommitManager get_CommitManager();
    internal void AddTask(IDataBindEngineClient c, TaskOps op);
    internal void CancelTask(IDataBindEngineClient c, TaskOps op);
    internal void CancelTasks(IDataBindEngineClient c);
    internal object Run(object arg);
    internal ViewRecord GetViewRecord(object collection, CollectionViewSource key, Type collectionViewType, bool createView, Func`2<object, object> GetSourceItem);
    internal void RegisterCollectionSynchronizationCallback(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    internal IValueConverter GetDefaultValueConverter(Type sourceType, Type targetType, bool targetToSource);
    internal void AddAsyncRequest(DependencyObject target, AsyncDataRequest request);
    internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext);
    internal void RegisterForCacheChanges(object item, object descriptor);
    internal void ScheduleCleanup();
    internal bool Cleanup();
    internal DataBindOperation Marshal(DispatcherOperationCallback method, object arg, int cost);
    internal void ChangeCost(DataBindOperation op, int delta);
}
internal class MS.Internal.Data.DataBindOperation : object {
    public int Cost { get; public set; }
    public DataBindOperation(DispatcherOperationCallback method, object arg, int cost);
    public int get_Cost();
    public void set_Cost(int value);
    public void Invoke();
}
[ExtensionAttribute]
internal static class MS.Internal.Data.DataExtensionMethods : object {
    [ExtensionAttribute]
internal static int Search(IList list, int index, int count, object value, IComparer comparer);
    [ExtensionAttribute]
internal static int Search(IList list, object value, IComparer comparer);
    [ExtensionAttribute]
internal static void Move(IList list, int oldIndex, int newIndex);
    [ExtensionAttribute]
internal static void Sort(IList list, IComparer comparer);
}
internal class MS.Internal.Data.DefaultAsyncDataDispatcher : object {
    private sealed virtual override void MS.Internal.Data.IAsyncDataDispatcher.AddRequest(AsyncDataRequest request);
    private sealed virtual override void MS.Internal.Data.IAsyncDataDispatcher.CancelAllRequests();
}
internal class MS.Internal.Data.DefaultValueConverter : object {
    internal static IValueConverter ValueConverterNotNeeded;
    protected Type _sourceType;
    protected Type _targetType;
    protected DataBindEngine Engine { get; }
    protected DefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    private static DefaultValueConverter();
    internal static IValueConverter Create(Type sourceType, Type targetType, bool targetToSource, DataBindEngine engine);
    internal static TypeConverter GetConverter(Type type);
    internal static object TryParse(object o, Type targetType, CultureInfo culture);
    protected object ConvertFrom(object o, Type destinationType, DependencyObject targetElement, CultureInfo culture);
    protected object ConvertTo(object o, Type destinationType, DependencyObject targetElement, CultureInfo culture);
    protected void EnsureConverter(Type type);
    protected DataBindEngine get_Engine();
}
internal class MS.Internal.Data.DifferencingCollection : ObservableCollection`1<object> {
    internal DifferencingCollection(IEnumerable enumerable);
    private static DifferencingCollection();
    internal void Update(IEnumerable enumerable);
}
internal class MS.Internal.Data.DisplayMemberTemplateSelector : DataTemplateSelector {
    public DisplayMemberTemplateSelector(string displayMemberPath, string stringFormat);
    public virtual DataTemplate SelectTemplate(object item, DependencyObject container);
}
internal enum MS.Internal.Data.DrillIn : Enum {
    public int value__;
    public static DrillIn Never;
    public static DrillIn IfNeeded;
    public static DrillIn Always;
}
internal abstract class MS.Internal.Data.DynamicIndexerAccessor : DynamicObjectAccessor {
    protected DynamicIndexerAccessor(Type ownerType, string propertyName);
    public abstract virtual object GetValue(object component, Object[] args);
    public abstract virtual void SetValue(object component, Object[] args, object value);
}
internal class MS.Internal.Data.DynamicObjectAccessor : object {
    public Type OwnerType { get; }
    public string PropertyName { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected DynamicObjectAccessor(Type ownerType, string propertyName);
    public Type get_OwnerType();
    public string get_PropertyName();
    public bool get_IsReadOnly();
    public Type get_PropertyType();
    public static string MissingMemberErrorString(object target, string name);
}
internal abstract class MS.Internal.Data.DynamicPropertyAccessor : DynamicObjectAccessor {
    protected DynamicPropertyAccessor(Type ownerType, string propertyName);
    public abstract virtual object GetValue(object component);
    public abstract virtual void SetValue(object component, object value);
}
internal class MS.Internal.Data.DynamicValueConverter : object {
    internal DynamicValueConverter(bool targetToSourceNeeded);
    internal DynamicValueConverter(bool targetToSourceNeeded, Type sourceType, Type targetType);
    internal object Convert(object value, Type targetType);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type sourceType, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ElementObjectRef : ObjectRef {
    internal ElementObjectRef(string name);
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    public virtual string ToString();
    internal virtual string Identify();
}
internal class MS.Internal.Data.EnumerableCollectionView : CollectionView {
    public CultureInfo Culture { get; public set; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NeedsRefresh { get; }
    internal EnumerableCollectionView(IEnumerable source);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_NeedsRefresh();
    public virtual int IndexOf(object item);
    public virtual bool PassesFilter(object item);
    public virtual object GetItemAt(int index);
    protected virtual IEnumerator GetEnumerator();
    protected virtual void RefreshOverride();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
}
internal class MS.Internal.Data.ExplicitObjectRef : ObjectRef {
    protected bool ProtectedUsesMentor { get; }
    internal ExplicitObjectRef(object o);
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    protected virtual bool get_ProtectedUsesMentor();
    internal virtual string Identify();
}
internal interface MS.Internal.Data.IAsyncDataDispatcher {
    public abstract virtual void AddRequest(AsyncDataRequest request);
    public abstract virtual void CancelAllRequests();
}
internal interface MS.Internal.Data.IDataBindEngineClient {
    public DependencyObject TargetElement { get; }
    public abstract virtual void TransferValue();
    public abstract virtual void UpdateValue();
    public abstract virtual bool AttachToContext(bool lastChance);
    public abstract virtual void VerifySourceReference(bool lastChance);
    public abstract virtual void OnTargetUpdated();
    public abstract virtual DependencyObject get_TargetElement();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.IndexedEnumerable : object {
    internal int Count { get; }
    internal bool IsEmpty { get; }
    internal object Item { get; }
    internal IEnumerable Enumerable { get; }
    internal ICollection Collection { get; }
    internal IList List { get; }
    internal CollectionView CollectionView { get; }
    internal IndexedEnumerable(IEnumerable collection);
    internal IndexedEnumerable(IEnumerable collection, Predicate`1<object> filterCallback);
    internal int IndexOf(object item);
    internal int get_Count();
    internal bool get_IsEmpty();
    internal object get_Item(int index);
    internal IEnumerable get_Enumerable();
    internal ICollection get_Collection();
    internal IList get_List();
    internal CollectionView get_CollectionView();
    public sealed virtual IEnumerator GetEnumerator();
    internal static void CopyTo(IEnumerable collection, Array array, int index);
    internal void Invalidate();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
internal class MS.Internal.Data.IndexerParamInfo : ValueType {
    public string parenString;
    public string valueString;
    public IndexerParamInfo(string paren, string value);
}
internal class MS.Internal.Data.IndexerPropertyInfo : PropertyInfo {
    internal static IndexerPropertyInfo Instance { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    private static IndexerPropertyInfo();
    internal static IndexerPropertyInfo get_Instance();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type get_PropertyType();
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type get_DeclaringType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
}
internal class MS.Internal.Data.InterfaceConverter : object {
    internal InterfaceConverter(Type sourceType, Type targetType);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ListSourceConverter : object {
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.LivePropertyInfo : ValueType {
    private string _path;
    private DependencyProperty _dp;
    public string Path { get; }
    public DependencyProperty Property { get; }
    public LivePropertyInfo(string path, DependencyProperty dp);
    public string get_Path();
    public DependencyProperty get_Property();
}
internal class MS.Internal.Data.LiveShapingBlock : RBNode`1<LiveShapingItem> {
    internal LiveShapingList List { get; }
    internal LiveShapingBlock(bool b);
    internal LiveShapingList get_List();
    public virtual LiveShapingItem SetItemAt(int offset, LiveShapingItem lsi);
    protected virtual void Copy(RBNode`1<LiveShapingItem> sourceNode, int sourceOffset, RBNode`1<LiveShapingItem> destNode, int destOffset, int count);
    internal RBFinger`1<LiveShapingItem> GetFinger(LiveShapingItem lsi);
    internal void FindPosition(LiveShapingItem item, RBFinger`1& oldFinger, RBFinger`1& newFinger, Comparison`1<LiveShapingItem> comparison);
}
[FlagsAttribute]
internal enum MS.Internal.Data.LiveShapingFlags : Enum {
    public int value__;
    public static LiveShapingFlags Sorting;
    public static LiveShapingFlags Filtering;
    public static LiveShapingFlags Grouping;
}
internal class MS.Internal.Data.LiveShapingItem : DependencyObject {
    internal object Item { get; internal set; }
    internal LiveShapingBlock Block { get; internal set; }
    internal bool IsSortDirty { get; internal set; }
    internal bool IsSortPendingClean { get; internal set; }
    internal bool IsFilterDirty { get; internal set; }
    internal bool IsGroupDirty { get; internal set; }
    internal bool FailsFilter { get; internal set; }
    internal bool ForwardChanges { get; internal set; }
    internal bool IsDeleted { get; internal set; }
    internal int StartingIndex { get; internal set; }
    internal List`1<CollectionViewGroupInternal> ParentGroups { get; }
    internal CollectionViewGroupInternal ParentGroup { get; }
    internal LiveShapingItem(object item, LiveShapingList list, bool filtered, LiveShapingBlock block, bool oneTime);
    private static LiveShapingItem();
    internal object get_Item();
    internal void set_Item(object value);
    internal LiveShapingBlock get_Block();
    internal void set_Block(LiveShapingBlock value);
    internal bool get_IsSortDirty();
    internal void set_IsSortDirty(bool value);
    internal bool get_IsSortPendingClean();
    internal void set_IsSortPendingClean(bool value);
    internal bool get_IsFilterDirty();
    internal void set_IsFilterDirty(bool value);
    internal bool get_IsGroupDirty();
    internal void set_IsGroupDirty(bool value);
    internal bool get_FailsFilter();
    internal void set_FailsFilter(bool value);
    internal bool get_ForwardChanges();
    internal void set_ForwardChanges(bool value);
    internal bool get_IsDeleted();
    internal void set_IsDeleted(bool value);
    internal void FindPosition(RBFinger`1& oldFinger, RBFinger`1& newFinger, Comparison`1<LiveShapingItem> comparison);
    internal RBFinger`1<LiveShapingItem> GetFinger();
    internal int get_StartingIndex();
    internal void set_StartingIndex(int value);
    internal int GetAndClearStartingIndex();
    internal void SetBinding(string path, DependencyProperty dp, bool oneTime, bool enableXT);
    internal object GetValue(string path, DependencyProperty dp);
    internal void Clear();
    internal void OnCrossThreadPropertyChange(DependencyProperty dp);
    internal void AddParentGroup(CollectionViewGroupInternal group);
    internal void RemoveParentGroup(CollectionViewGroupInternal group);
    internal List`1<CollectionViewGroupInternal> get_ParentGroups();
    internal CollectionViewGroupInternal get_ParentGroup();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.LiveShapingList : object {
    internal ICollectionViewLiveShaping View { get; }
    internal Dictionary`2<string, DependencyProperty> ObservedProperties { get; }
    internal List`1<LiveShapingItem> SortDirtyItems { get; }
    internal List`1<LiveShapingItem> FilterDirtyItems { get; }
    internal List`1<LiveShapingItem> GroupDirtyItems { get; }
    internal bool IsRestoringLiveSorting { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal LiveShapingList(ICollectionViewLiveShaping view, LiveShapingFlags flags, IComparer comparer);
    private static LiveShapingList();
    internal ICollectionViewLiveShaping get_View();
    internal Dictionary`2<string, DependencyProperty> get_ObservedProperties();
    internal void SetLiveShapingProperties(LiveShapingFlags flags);
    internal int Search(int index, int count, object value);
    internal void Sort();
    internal int CompareLiveShapingItems(LiveShapingItem x, LiveShapingItem y);
    internal void Move(int oldIndex, int newIndex);
    internal void RestoreLiveSortingByInsertionSort(Action`3<NotifyCollectionChangedEventArgs, int, int> RaiseMoveEvent);
    internal void AddFilteredItem(object item);
    internal void AddFilteredItem(LiveShapingItem lsi);
    internal void SetStartingIndexForFilteredItem(object item, int value);
    internal void RemoveFilteredItem(LiveShapingItem lsi);
    internal void RemoveFilteredItem(object item);
    internal void ReplaceFilteredItem(object oldItem, object newItem);
    internal int IndexOf(LiveShapingItem lsi);
    internal void InitializeItem(LiveShapingItem lsi, object item, bool filtered, bool oneTime);
    internal void ClearItem(LiveShapingItem lsi);
    internal void OnItemPropertyChanged(LiveShapingItem lsi, DependencyProperty dp);
    internal void OnItemPropertyChangedCrossThread(LiveShapingItem lsi, DependencyProperty dp);
    [CompilerGeneratedAttribute]
internal void add_LiveShapingDirty(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_LiveShapingDirty(EventHandler value);
    internal void FindPosition(LiveShapingItem lsi, Int32& oldIndex, Int32& newIndex);
    internal List`1<LiveShapingItem> get_SortDirtyItems();
    internal List`1<LiveShapingItem> get_FilterDirtyItems();
    internal List`1<LiveShapingItem> get_GroupDirtyItems();
    internal LiveShapingItem ItemAt(int index);
    internal bool get_IsRestoringLiveSorting();
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    internal bool VerifyLiveSorting(LiveShapingItem lsi);
}
internal class MS.Internal.Data.LiveShapingTree : RBTree`1<LiveShapingItem> {
    internal LiveShapingList List { get; }
    internal LiveShapingBlock PlaceholderBlock { get; }
    internal LiveShapingTree(LiveShapingList list);
    internal LiveShapingList get_List();
    internal LiveShapingBlock get_PlaceholderBlock();
    internal virtual RBNode`1<LiveShapingItem> NewNode();
    internal void Move(int oldIndex, int newIndex);
    internal void RestoreLiveSortingByInsertionSort(Action`3<NotifyCollectionChangedEventArgs, int, int> RaiseMoveEvent);
    internal void FindPosition(LiveShapingItem lsi, Int32& oldIndex, Int32& newIndex);
    internal void ReplaceAt(int index, object item);
    internal LiveShapingItem FindItem(object item);
    public virtual int IndexOf(LiveShapingItem lsi);
}
internal abstract class MS.Internal.Data.ObjectRef : object {
    internal bool UsesMentor { get; }
    protected bool ProtectedUsesMentor { get; }
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    internal virtual object GetDataObject(DependencyObject d, ObjectRefArgs args);
    internal bool TreeContextIsRequired(DependencyObject target);
    protected virtual bool ProtectedTreeContextIsRequired(DependencyObject target);
    internal bool get_UsesMentor();
    protected virtual bool get_ProtectedUsesMentor();
    internal abstract virtual string Identify();
}
internal class MS.Internal.Data.ObjectRefArgs : object {
    internal bool IsTracing { get; internal set; }
    internal bool ResolveNamesInTemplate { get; internal set; }
    internal bool NameResolvedInOuterScope { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsTracing();
    [CompilerGeneratedAttribute]
internal void set_IsTracing(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ResolveNamesInTemplate();
    [CompilerGeneratedAttribute]
internal void set_ResolveNamesInTemplate(bool value);
    [CompilerGeneratedAttribute]
internal bool get_NameResolvedInOuterScope();
    [CompilerGeneratedAttribute]
internal void set_NameResolvedInOuterScope(bool value);
}
internal class MS.Internal.Data.ObjectSourceConverter : DefaultValueConverter {
    public ObjectSourceConverter(Type targetType, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ObjectTargetConverter : DefaultValueConverter {
    public ObjectTargetConverter(Type sourceType, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ParameterCollection : Collection`1<object> {
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    protected bool IsReadOnly { get; protected set; }
    protected bool IsFixedSize { get; }
    public ParameterCollection(ParameterCollectionChanged parametersChanged);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, object value);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, object value);
    protected virtual bool get_IsReadOnly();
    protected virtual void set_IsReadOnly(bool value);
    protected bool get_IsFixedSize();
    internal void SetReadOnly(bool isReadOnly);
    internal void ClearInternal();
}
internal class MS.Internal.Data.ParameterCollectionChanged : MulticastDelegate {
    public ParameterCollectionChanged(object object, IntPtr method);
    public virtual void Invoke(ParameterCollection parameters);
    public virtual IAsyncResult BeginInvoke(ParameterCollection parameters, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Data.PathParser : object {
    public string Error { get; }
    private static PathParser();
    public string get_Error();
    public SourceValueInfo[] Parse(string path);
}
internal class MS.Internal.Data.PropertyPathWorker : object {
    internal static object IListIndexOutOfRange;
    internal int Length { get; }
    internal PropertyPathStatus Status { get; }
    internal DependencyObject TreeContext { get; internal set; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal bool NeedsDirectNotification { get; private set; }
    internal PropertyPathWorker(PropertyPath path);
    internal PropertyPathWorker(PropertyPath path, ClrBindingWorker host, bool isDynamic, DataBindEngine engine);
    private static PropertyPathWorker();
    internal int get_Length();
    internal PropertyPathStatus get_Status();
    internal DependencyObject get_TreeContext();
    internal void set_TreeContext(DependencyObject value);
    internal void SetTreeContext(WeakReference wr);
    internal bool get_IsDBNullValidForUpdate();
    internal object get_SourceItem();
    internal string get_SourcePropertyName();
    internal bool get_NeedsDirectNotification();
    private void set_NeedsDirectNotification(bool value);
    internal object GetItem(int level);
    internal object GetAccessor(int level);
    internal Object[] GetIndexerArguments(int level);
    internal Type GetType(int level);
    internal IDisposable SetContext(object rootItem);
    internal void AttachToRootItem(object rootItem);
    internal void DetachFromRootItem();
    internal object GetValue(object item, int level);
    internal void SetValue(object item, object value);
    internal object RawValue();
    internal void RefreshValue();
    internal int LevelForPropertyChange(object item, string propertyName);
    internal void OnPropertyChangedAtLevel(int level);
    internal void OnCurrentChanged(ICollectionView collectionView);
    internal bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal void OnDependencyPropertyChanged(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal void OnNewValue(int level, object value);
    internal SourceValueInfo GetSourceValueInfo(int level);
    internal static bool IsIndexedProperty(PropertyInfo pi);
    internal bool IsPathCurrent(object rootItem);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
internal class MS.Internal.Data.RBFinger`1 : ValueType {
    [CompilerGeneratedAttribute]
private RBNode`1<T> <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Found>k__BackingField;
    public RBNode`1<T> Node { get; public set; }
    public int Offset { get; public set; }
    public int Index { get; public set; }
    public bool Found { get; public set; }
    public T Item { get; }
    public bool IsValid { get; }
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public bool get_Found();
    [CompilerGeneratedAttribute]
public void set_Found(bool value);
    public T get_Item();
    public void SetItem(T x);
    public bool get_IsValid();
    public static RBFinger`1<T> op_Addition(RBFinger`1<T> finger, int delta);
    public static RBFinger`1<T> op_Subtraction(RBFinger`1<T> finger, int delta);
    public static int op_Subtraction(RBFinger`1<T> f1, RBFinger`1<T> f2);
    public static RBFinger`1<T> op_Increment(RBFinger`1<T> finger);
    public static RBFinger`1<T> op_Decrement(RBFinger`1<T> finger);
    public static bool op_LessThan(RBFinger`1<T> f1, RBFinger`1<T> f2);
    public static bool op_GreaterThan(RBFinger`1<T> f1, RBFinger`1<T> f2);
}
internal class MS.Internal.Data.RBNode`1 : object {
    protected static int MaxSize;
    protected static int BinarySearchThreshold;
    public RBNode`1<T> LeftChild { get; public set; }
    public RBNode`1<T> RightChild { get; public set; }
    public RBNode`1<T> Parent { get; public set; }
    public bool IsRed { get; public set; }
    public bool HasData { get; }
    public int Size { get; public set; }
    public int LeftSize { get; public set; }
    protected RBNode`1(bool b);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_LeftChild();
    [CompilerGeneratedAttribute]
public void set_LeftChild(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_RightChild();
    [CompilerGeneratedAttribute]
public void set_RightChild(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public bool get_IsRed();
    [CompilerGeneratedAttribute]
public void set_IsRed(bool value);
    public virtual bool get_HasData();
    public int get_Size();
    public void set_Size(int value);
    public int get_LeftSize();
    public void set_LeftSize(int value);
    public T GetItemAt(int offset);
    public virtual T SetItemAt(int offset, T x);
    public int OffsetOf(T x);
    internal RBNode`1<T> GetSuccessor();
    internal RBNode`1<T> GetPredecessor();
    protected RBFinger`1<T> FindIndex(int index, bool exists);
    protected RBFinger`1<T> Find(T x, Comparison`1<T> comparison);
    protected RBFinger`1<T> BoundedSearch(T x, int low, int high, Comparison`1<T> comparison);
    protected RBFinger`1<T> LocateItem(RBFinger`1<T> finger, Comparison`1<T> comparison);
    protected virtual void Copy(RBNode`1<T> sourceNode, int sourceOffset, RBNode`1<T> destNode, int destOffset, int count);
    protected void ReInsert(RBFinger`1& oldFinger, RBFinger`1<T> newFinger);
    protected void RemoveAt(RBFinger`1& finger);
    protected RBNode`1<T> InsertNodeAfter(RBNode`1<T> node);
    protected RBTree`1<T> GetRoot(RBNode`1<T> node);
    protected RBTree`1<T> GetRootAndIndex(RBNode`1<T> node, Int32& index);
    internal void InsertAt(int offset, T x, RBNode`1<T> successor, RBNode`1<T> succsucc);
    protected RBNode`1<T> InsertNode(RBTree`1<T> root, RBNode`1<T> parent, RBNode`1<T> node, int index, RBNode`1& newNode);
    protected void ChangeSize(int delta);
    protected RBNode`1<T> DeleteNode(RBNode`1<T> parent, RBNode`1<T> node, int index);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string name);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.RBTree`1 : RBNode`1<T> {
    public bool HasData { get; }
    public Comparison`1<T> Comparison { get; public set; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public virtual bool get_HasData();
    public Comparison`1<T> get_Comparison();
    public void set_Comparison(Comparison`1<T> value);
    public RBFinger`1<T> BoundedSearch(T x, int low, int high);
    public void Insert(T x);
    public void Sort();
    public void QuickSort();
    public void InsertionSort();
    internal RBNode`1<T> InsertNode(int index);
    internal void RemoveNode(int index);
    internal virtual RBNode`1<T> NewNode();
    internal void ForEach(Action`1<T> action);
    internal void ForEachUntil(Func`2<T, bool> action);
    internal int IndexOf(T item, Func`3<T, T, bool> AreEqual);
    public virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("MS.Internal.Data.RBTree`1/<GetEnumerator>d__38")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("MS.Internal.Data.RBTree`1/<System-Collections-IEnumerable-GetEnumerator>d__39")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void LoadTree(string s);
}
internal class MS.Internal.Data.RelativeObjectRef : ObjectRef {
    internal bool ReturnsDataContext { get; }
    protected bool ProtectedUsesMentor { get; }
    internal RelativeObjectRef(RelativeSource relativeSource);
    public virtual string ToString();
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    internal virtual object GetDataObject(DependencyObject d, ObjectRefArgs args);
    internal bool get_ReturnsDataContext();
    protected virtual bool ProtectedTreeContextIsRequired(DependencyObject target);
    protected virtual bool get_ProtectedUsesMentor();
    internal virtual string Identify();
}
internal class MS.Internal.Data.SortFieldComparer : object {
    internal IComparer BaseComparer { get; }
    internal SortFieldComparer(SortDescriptionCollection sortFields, CultureInfo culture);
    internal IComparer get_BaseComparer();
    public sealed virtual int Compare(object o1, object o2);
    internal static void SortHelper(ArrayList al, IComparer comparer);
}
internal class MS.Internal.Data.SourceDefaultValueConverter : DefaultValueConverter {
    public SourceDefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.SourceValueInfo : ValueType {
    public SourceValueType type;
    public DrillIn drillIn;
    public string name;
    public FrugalObjectList`1<IndexerParamInfo> paramList;
    public string propertyName;
    public SourceValueInfo(SourceValueType t, DrillIn d, string n);
    public SourceValueInfo(SourceValueType t, DrillIn d, FrugalObjectList`1<IndexerParamInfo> list);
}
internal enum MS.Internal.Data.SourceValueType : Enum {
    public int value__;
    public static SourceValueType Property;
    public static SourceValueType Indexer;
    public static SourceValueType Direct;
}
internal class MS.Internal.Data.StaticPropertyChangedEventManager : WeakEventManager {
    private static StaticPropertyChangedEventManager();
    public static void AddHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void RemoveHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
}
internal class MS.Internal.Data.SynchronizationInfo : ValueType {
    public static SynchronizationInfo None;
    private object _context;
    private MethodInfo _callbackMethod;
    private WeakReference _callbackTarget;
    public bool IsSynchronized { get; }
    public bool IsAlive { get; }
    public SynchronizationInfo(object context, CollectionSynchronizationCallback callback);
    private static SynchronizationInfo();
    public bool get_IsSynchronized();
    public void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    public bool get_IsAlive();
}
internal class MS.Internal.Data.SystemConvertConverter : object {
    public SystemConvertConverter(Type sourceType, Type targetType);
    private static SystemConvertConverter();
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
    public static bool CanConvert(Type sourceType, Type targetType);
}
internal class MS.Internal.Data.TargetDefaultValueConverter : DefaultValueConverter {
    public TargetDefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal enum MS.Internal.Data.TaskOps : Enum {
    public int value__;
    public static TaskOps TransferValue;
    public static TaskOps UpdateValue;
    public static TaskOps AttachToContext;
    public static TaskOps VerifySourceReference;
    public static TaskOps RaiseTargetUpdatedEvent;
}
internal class MS.Internal.Data.ValueChangedEventArgs : EventArgs {
    internal PropertyDescriptor PropertyDescriptor { get; }
    internal ValueChangedEventArgs(PropertyDescriptor pd);
    internal PropertyDescriptor get_PropertyDescriptor();
}
internal class MS.Internal.Data.ValueChangedEventManager : WeakEventManager {
    public static void AddListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    public static void RemoveListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    public static void AddHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    public static void RemoveHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
}
internal class MS.Internal.Data.ValueConverterContext : object {
    public Uri BaseUri { get; public set; }
    internal bool IsInUse { get; }
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public virtual object GetService(Type serviceType);
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    internal void SetTargetElement(DependencyObject target);
    internal bool get_IsInUse();
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
}
internal class MS.Internal.Data.ValueTable : object {
    private static ValueTable();
    internal static bool ShouldCache(object item, PropertyDescriptor pd);
    internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext);
    internal void RegisterForChanges(object item, PropertyDescriptor pd, DataBindEngine engine);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal bool Purge();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.ViewManager : HybridDictionary {
    internal static WeakReference StaticWeakRef;
    internal static WeakReference NullWeakRef;
    public CollectionRecord Item { get; }
    internal static ViewManager Current { get; }
    private static ViewManager();
    public CollectionRecord get_Item(object o);
    internal void Add(object collection, CollectionRecord cr);
    internal ViewRecord GetViewRecord(object collection, CollectionViewSource cvs, Type collectionViewType, bool createView, Func`2<object, object> GetSourceItem);
    internal void RegisterCollectionSynchronizationCallback(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    internal SynchronizationInfo GetSynchronizationInfo(IEnumerable collection);
    public void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    internal static ViewManager get_Current();
    internal bool Purge();
}
internal class MS.Internal.Data.ViewRecord : object {
    internal ICollectionView View { get; }
    internal int Version { get; internal set; }
    internal bool IsInitialized { get; }
    internal ViewRecord(ICollectionView view);
    internal ICollectionView get_View();
    internal int get_Version();
    internal void set_Version(int value);
    internal bool get_IsInitialized();
    internal void InitializeView();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.ViewTable : HybridDictionary {
    internal ViewRecord Item { get; internal set; }
    internal ViewRecord get_Item(CollectionViewSource cvs);
    internal void set_Item(CollectionViewSource cvs, ViewRecord value);
    internal bool Purge();
}
internal class MS.Internal.Data.WeakDependencySource : object {
    internal DependencyObject DependencyObject { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal WeakDependencySource(DependencyObject item, DependencyProperty dp);
    internal WeakDependencySource(WeakReference wr, DependencyProperty dp);
    internal DependencyObject get_DependencyObject();
    internal DependencyProperty get_DependencyProperty();
}
internal class MS.Internal.Data.WeakRefKey : ValueType {
    private WeakReference _weakRef;
    private int _hashCode;
    internal object Target { get; }
    internal WeakRefKey(object target);
    internal object get_Target();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.XDeferredAxisSource : object {
    public IEnumerable Item { get; }
    internal IEnumerable FullCollection { get; }
    internal XDeferredAxisSource(object component, PropertyDescriptor pd);
    public IEnumerable get_Item(string name);
    internal IEnumerable get_FullCollection();
}
internal class MS.Internal.Data.XmlBindingWorker : BindingWorker {
    internal XmlBindingWorker(ClrBindingWorker worker, bool collectionMode);
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual object RawValue();
    internal void ReportBadXPath(TraceEventType traceType);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
}
internal class MS.Internal.Data.XmlDataCollection : ReadOnlyObservableCollection`1<XmlNode> {
    internal XmlNamespaceManager XmlNamespaceManager { get; internal set; }
    internal XmlDataProvider ParentXmlDataProvider { get; }
    internal XmlDataCollection(XmlDataProvider xmlDataProvider);
    internal XmlNamespaceManager get_XmlNamespaceManager();
    internal void set_XmlNamespaceManager(XmlNamespaceManager value);
    internal XmlDataProvider get_ParentXmlDataProvider();
    internal bool CollectionHasChanged(XmlNodeList nodes);
    internal void SynchronizeCollection(XmlNodeList nodes);
}
internal class MS.Internal.Data.XmlNodeChangedEventManager : WeakEventManager {
    public static void AddListener(XmlDocument source, IWeakEventListener listener);
    public static void RemoveListener(XmlDocument source, IWeakEventListener listener);
    public static void AddHandler(XmlDocument source, EventHandler`1<XmlNodeChangedEventArgs> handler);
    public static void RemoveHandler(XmlDocument source, EventHandler`1<XmlNodeChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
internal static class MS.Internal.DeploymentExceptionMapper : object {
    internal static MissingDependencyType GetWinFXRequirement(Exception e, InPlaceHostingManager hostingManager, String& version, Uri& fwlinkUri);
    internal static void GetErrorTextFromException(Exception e, String& errorTitle, String& errorMessage);
    internal static bool ConstructFwlinkUrl(string version, Uri& fwlinkUri);
}
internal class MS.Internal.Documents.Application.DocumentApplicationJournalEntry : CustomContentState {
    public string JournalEntryName { get; }
    public DocumentApplicationJournalEntry(object state, string name);
    public DocumentApplicationJournalEntry(object state);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void Replay(NavigationService navigationService, NavigationMode mode);
    public virtual string get_JournalEntryName();
}
internal class MS.Internal.Documents.BreakRecordTableInvalidatedEventHandler : MulticastDelegate {
    public BreakRecordTableInvalidatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.ColumnResult : object {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal Rect LayoutBox { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal TextContentRange TextContentRange { get; }
    [SecurityCriticalAttribute]
internal ColumnResult(FlowDocumentPage page, FSTRACKDESCRIPTION& trackDesc, Vector contentOffset);
    [SecurityCriticalAttribute]
internal ColumnResult(BaseParaClient subpage, FSTRACKDESCRIPTION& trackDesc, Vector contentOffset);
    internal bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
    internal Rect get_LayoutBox();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal bool get_HasTextContent();
    internal TextContentRange get_TextContentRange();
}
internal class MS.Internal.Documents.ContainerParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal ContainerParagraphResult(ContainerParaClient paraClient);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal virtual bool get_HasTextContent();
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.Documents.ContentElementCollection`2 : object {
    protected static int c_defaultCapacity;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TItem Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TParent Owner { get; }
    protected TItem[] Items { get; private set; }
    protected int Size { get; protected set; }
    protected int Version { get; protected set; }
    protected int DefaultCapacity { get; }
    internal int PrivateCapacity { get; internal set; }
    internal ContentElementCollection`2(TParent owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TItem[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    public abstract virtual void Add(TItem item);
    public abstract virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual int IndexOf(TItem item);
    public abstract virtual void Insert(int index, TItem item);
    public abstract virtual bool Remove(TItem item);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public abstract virtual TItem get_Item(int index);
    public abstract virtual void set_Item(int index, TItem value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public TParent get_Owner();
    protected TItem[] get_Items();
    private void set_Items(TItem[] value);
    protected int get_Size();
    protected void set_Size(int value);
    protected int get_Version();
    protected void set_Version(int value);
    protected int get_DefaultCapacity();
    internal void EnsureCapacity(int min);
    internal abstract virtual void PrivateConnectChild(int index, TItem item);
    internal abstract virtual void PrivateDisconnectChild(TItem item);
    internal void PrivateRemove(TItem item);
    internal bool BelongsToOwner(TItem item);
    internal int get_PrivateCapacity();
    internal void set_PrivateCapacity(int value);
}
internal static class MS.Internal.Documents.ContentHostHelper : object {
    internal static IContentHost FindContentHost(ContentElement contentElement);
}
internal class MS.Internal.Documents.DesiredSizeChangedEventArgs : EventArgs {
    internal UIElement Child { get; }
    internal DesiredSizeChangedEventArgs(UIElement child);
    internal UIElement get_Child();
}
internal class MS.Internal.Documents.DesiredSizeChangedEventHandler : MulticastDelegate {
    public DesiredSizeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesiredSizeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesiredSizeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.DocumentGrid : FrameworkElement {
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public int FirstVisiblePageNumber { get; }
    public double Scale { get; }
    public int MaxPagesAcross { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool ShowPageBorders { get; public set; }
    public bool LockViewModes { get; public set; }
    public ITextContainer TextContainer { get; }
    public ITextView TextView { get; }
    public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public DocumentViewer DocumentViewerOwner { get; public set; }
    protected int VisualChildrenCount { get; }
    private static DocumentGrid();
    internal DocumentPage GetDocumentPageFromPoint(Point point);
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual Rect MakeVisible(Visual v, Rect r);
    public sealed virtual Rect MakeVisible(object o, Rect r, int pageNumber);
    public sealed virtual void MakeSelectionVisible();
    public sealed virtual void MakePageVisible(int pageNumber);
    public sealed virtual void ScrollToNextRow();
    public sealed virtual void ScrollToPreviousRow();
    public sealed virtual void ScrollToHome();
    public sealed virtual void ScrollToEnd();
    public sealed virtual void SetScale(double scale);
    public sealed virtual void SetColumns(int columns);
    public sealed virtual void FitColumns(int columns);
    public sealed virtual void FitToPageWidth();
    public sealed virtual void FitToPageHeight();
    public sealed virtual void ViewThumbnails();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual double get_VerticalOffset();
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual DynamicDocumentPaginator get_Content();
    public sealed virtual void set_Content(DynamicDocumentPaginator value);
    public sealed virtual int get_PageCount();
    public sealed virtual int get_FirstVisiblePageNumber();
    public sealed virtual double get_Scale();
    public sealed virtual int get_MaxPagesAcross();
    public sealed virtual double get_VerticalPageSpacing();
    public sealed virtual void set_VerticalPageSpacing(double value);
    public sealed virtual double get_HorizontalPageSpacing();
    public sealed virtual void set_HorizontalPageSpacing(double value);
    public sealed virtual bool get_ShowPageBorders();
    public sealed virtual void set_ShowPageBorders(bool value);
    public sealed virtual bool get_LockViewModes();
    public sealed virtual void set_LockViewModes(bool value);
    public sealed virtual ITextContainer get_TextContainer();
    public sealed virtual ITextView get_TextView();
    public sealed virtual ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public sealed virtual DocumentViewer get_DocumentViewerOwner();
    public sealed virtual void set_DocumentViewerOwner(DocumentViewer value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
}
internal static class MS.Internal.Documents.DocumentGridContextMenu : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RegisterClassHandler();
}
internal class MS.Internal.Documents.DocumentGridPage : FrameworkElement {
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; public set; }
    public DocumentPageView DocumentPageView { get; }
    public bool ShowPageBorders { get; public set; }
    public bool IsPageLoaded { get; }
    protected int VisualChildrenCount { get; }
    public DocumentGridPage(DocumentPaginator paginator);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public DocumentPageView get_DocumentPageView();
    public bool get_ShowPageBorders();
    public void set_ShowPageBorders(bool value);
    public bool get_IsPageLoaded();
    [CompilerGeneratedAttribute]
public void add_PageLoaded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageLoaded(EventHandler value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected sealed virtual Size MeasureOverride(Size availableSize);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    protected void Dispose();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class MS.Internal.Documents.DocumentPageHost : FrameworkElement {
    internal Point CachedOffset;
    internal Visual PageVisual { get; internal set; }
    protected int VisualChildrenCount { get; }
    internal static void DisconnectPageVisual(Visual pageVisual);
    internal Visual get_PageVisual();
    internal void set_PageVisual(Visual value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
}
internal class MS.Internal.Documents.DocumentPageTextView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal DocumentPageView DocumentPageView { get; }
    internal DocumentPageTextView(DocumentPageView owner, ITextContainer textContainer);
    internal DocumentPageTextView(FlowDocumentView owner, ITextContainer textContainer);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal void OnPageConnected();
    internal void OnPageDisconnected();
    internal void OnTransformChanged();
    internal virtual bool Validate();
    internal virtual bool Validate(ITextPointer position);
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal DocumentPageView get_DocumentPageView();
}
internal class MS.Internal.Documents.DocumentsTrace : object {
    public bool IsEnabled { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static DocumentsTrace();
    public DocumentsTrace(string switchName);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public DocumentsTrace(string switchName, bool initialState);
    [ConditionalAttribute("DEBUG")]
public void Trace(string message);
    [ConditionalAttribute("DEBUG")]
public void TraceCallers(int Depth);
    [ConditionalAttribute("DEBUG")]
public void Indent();
    [ConditionalAttribute("DEBUG")]
public void Unindent();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[ConditionalAttribute("DEBUG")]
public void Enable();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
[ConditionalAttribute("DEBUG")]
public void Disable();
    public bool get_IsEnabled();
}
internal static class MS.Internal.Documents.DocumentViewerConstants : object {
    public static double MinimumZoom { get; }
    public static double MaximumZoom { get; }
    public static double MinimumScale { get; }
    public static double MinimumThumbnailsScale { get; }
    public static double MaximumScale { get; }
    public static int MaximumMaxPagesAcross { get; }
    public static double get_MinimumZoom();
    public static double get_MaximumZoom();
    public static double get_MinimumScale();
    public static double get_MinimumThumbnailsScale();
    public static double get_MaximumScale();
    public static int get_MaximumMaxPagesAcross();
}
internal static class MS.Internal.Documents.DocumentViewerHelper : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ToggleFindToolBar(Decorator findToolBarHost, EventHandler handlerFindClicked, bool enable);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static ITextRange Find(FindToolBar findToolBar, TextEditor textEditor, ITextView textView, ITextView masterPageTextView);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ShowFindUnsuccessfulMessage(FindToolBar findToolBar);
    internal static bool IsLogicalDescendent(DependencyObject child, DependencyObject parent);
    internal static void KeyDownHelper(KeyEventArgs e, DependencyObject findToolBarHost);
    internal static void OnContextMenuOpening(FlowDocument document, Control viewer, ContextMenuEventArgs e);
    internal static Rect CalculateVisibleRect(Rect visibleRect, Visual originalVisual);
}
internal class MS.Internal.Documents.FigureParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal FigureParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect, Boolean& success);
}
internal class MS.Internal.Documents.FixedDocumentPaginator : DynamicDocumentPaginator {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    internal FixedDocumentPaginator(FixedDocument document);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void CancelAsync(object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void NotifyGetPageCompleted(GetPageCompletedEventArgs e);
    internal void NotifyPaginationCompleted(EventArgs e);
    internal void NotifyPaginationProgress(PaginationProgressEventArgs e);
    internal void NotifyPagesChanged(PagesChangedEventArgs e);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal class MS.Internal.Documents.FixedDocumentSequencePaginator : DynamicDocumentPaginator {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    internal FixedDocumentSequencePaginator(FixedDocumentSequence document);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void CancelAsync(object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void NotifyGetPageCompleted(GetPageCompletedEventArgs e);
    internal void NotifyPaginationCompleted(EventArgs e);
    internal void NotifyPaginationProgress(PaginationProgressEventArgs e);
    internal void NotifyPagesChanged(PagesChangedEventArgs e);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal abstract class MS.Internal.Documents.FloaterBaseParagraphResult : ParagraphResult {
    internal FloaterBaseParagraphResult(BaseParaClient paraClient);
}
internal class MS.Internal.Documents.FloaterParagraphResult : FloaterBaseParagraphResult {
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal FloaterParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect, Boolean& success);
}
internal class MS.Internal.Documents.FlowDocumentFormatter : object {
    internal FlowDocumentPage DocumentPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentFormatter.IsLayoutDataValid { get; }
    internal FlowDocumentFormatter(FlowDocument document);
    internal void Format(Size constraint);
    internal void Arrange(Size arrangeSize, Rect viewport);
    internal FlowDocumentPage get_DocumentPage();
    [CompilerGeneratedAttribute]
internal void add_ContentInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ContentInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_Suspended(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Suspended(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.Suspend();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentFormatter.get_IsLayoutDataValid();
}
internal class MS.Internal.Documents.FlowDocumentPaginator : DynamicDocumentPaginator {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    private bool MS.Internal.Documents.IFlowDocumentFormatter.IsLayoutDataValid { get; }
    internal FlowDocumentPaginator(FlowDocument document);
    private static FlowDocumentPaginator();
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual void CancelAsync(object userState);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void InitiateNextAsyncOperation();
    internal void CancelAllAsyncOperations();
    internal void OnPagesChanged(int pageStart, int pageCount);
    internal void OnPaginationProgress(int pageStart, int pageCount);
    internal void OnPaginationCompleted();
    [CompilerGeneratedAttribute]
internal void add_BreakRecordTableInvalidated(BreakRecordTableInvalidatedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BreakRecordTableInvalidated(BreakRecordTableInvalidatedEventHandler value);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.Suspend();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentFormatter.get_IsLayoutDataValid();
}
internal class MS.Internal.Documents.FlowDocumentPrintingState : object {
    internal XpsDocumentWriter XpsDocumentWriter;
    internal Size PageSize;
    internal Thickness PagePadding;
    internal double ColumnWidth;
    internal bool IsSelectionEnabled;
}
internal class MS.Internal.Documents.FlowDocumentView : FrameworkElement {
    protected int VisualChildrenCount { get; }
    internal FlowDocument Document { get; internal set; }
    internal FlowDocumentPage DocumentPage { get; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.VerticalOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    private static FlowDocumentView();
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    internal void SuspendLayout();
    internal void ResumeLayout();
    internal FlowDocument get_Document();
    internal void set_Document(FlowDocument value);
    internal FlowDocumentPage get_DocumentPage();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_HorizontalOffset();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_VerticalOffset();
    private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal interface MS.Internal.Documents.IAcceptInsertion {
    public int InsertionIndex { get; public set; }
    public abstract virtual int get_InsertionIndex();
    public abstract virtual void set_InsertionIndex(int value);
}
internal interface MS.Internal.Documents.IDocumentScrollInfo {
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public int FirstVisiblePageNumber { get; }
    public double Scale { get; }
    public int MaxPagesAcross { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool ShowPageBorders { get; public set; }
    public bool LockViewModes { get; public set; }
    public ITextView TextView { get; }
    public ITextContainer TextContainer { get; }
    public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    public DocumentViewer DocumentViewerOwner { get; public set; }
    public abstract virtual void MakePageVisible(int pageNumber);
    public abstract virtual void MakeSelectionVisible();
    public abstract virtual Rect MakeVisible(object o, Rect r, int pageNumber);
    public abstract virtual void ScrollToNextRow();
    public abstract virtual void ScrollToPreviousRow();
    public abstract virtual void ScrollToHome();
    public abstract virtual void ScrollToEnd();
    public abstract virtual void SetScale(double scale);
    public abstract virtual void SetColumns(int columns);
    public abstract virtual void FitColumns(int columns);
    public abstract virtual void FitToPageWidth();
    public abstract virtual void FitToPageHeight();
    public abstract virtual void ViewThumbnails();
    public abstract virtual DynamicDocumentPaginator get_Content();
    public abstract virtual void set_Content(DynamicDocumentPaginator value);
    public abstract virtual int get_PageCount();
    public abstract virtual int get_FirstVisiblePageNumber();
    public abstract virtual double get_Scale();
    public abstract virtual int get_MaxPagesAcross();
    public abstract virtual double get_VerticalPageSpacing();
    public abstract virtual void set_VerticalPageSpacing(double value);
    public abstract virtual double get_HorizontalPageSpacing();
    public abstract virtual void set_HorizontalPageSpacing(double value);
    public abstract virtual bool get_ShowPageBorders();
    public abstract virtual void set_ShowPageBorders(bool value);
    public abstract virtual bool get_LockViewModes();
    public abstract virtual void set_LockViewModes(bool value);
    public abstract virtual ITextView get_TextView();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public abstract virtual DocumentViewer get_DocumentViewerOwner();
    public abstract virtual void set_DocumentViewerOwner(DocumentViewer value);
}
internal interface MS.Internal.Documents.IFlowDocumentFormatter {
    public bool IsLayoutDataValid { get; }
    public abstract virtual void OnContentInvalidated(bool affectsLayout);
    public abstract virtual void OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    public abstract virtual void Suspend();
    public abstract virtual bool get_IsLayoutDataValid();
}
internal interface MS.Internal.Documents.IFlowDocumentViewer {
    public ContentPosition ContentPosition { get; public set; }
    public ITextSelection TextSelection { get; public set; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    public int PageNumber { get; }
    public int PageCount { get; }
    public abstract virtual void PreviousPage();
    public abstract virtual void NextPage();
    public abstract virtual void FirstPage();
    public abstract virtual void LastPage();
    public abstract virtual void Print();
    public abstract virtual void CancelPrint();
    public abstract virtual void ShowFindResult(ITextRange findResult);
    public abstract virtual bool CanGoToPage(int pageNumber);
    public abstract virtual void GoToPage(int pageNumber);
    public abstract virtual void SetDocument(FlowDocument document);
    public abstract virtual ContentPosition get_ContentPosition();
    public abstract virtual void set_ContentPosition(ContentPosition value);
    public abstract virtual ITextSelection get_TextSelection();
    public abstract virtual void set_TextSelection(ITextSelection value);
    public abstract virtual bool get_CanGoToPreviousPage();
    public abstract virtual bool get_CanGoToNextPage();
    public abstract virtual int get_PageNumber();
    public abstract virtual int get_PageCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PageNumberChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PageNumberChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PageCountChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PageCountChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PrintStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PrintStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PrintCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PrintCompleted(EventHandler value);
}
internal interface MS.Internal.Documents.IIndexedChild`1 {
    public int Index { get; public set; }
    public abstract virtual void OnEnterParentTree();
    public abstract virtual void OnExitParentTree();
    public abstract virtual void OnAfterExitParentTree(TParent parent);
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
}
internal interface MS.Internal.Documents.IParentUndoUnit {
    public IUndoUnit LastUnit { get; }
    public IParentUndoUnit OpenedUnit { get; }
    public string Description { get; public set; }
    public bool Locked { get; }
    public object Container { get; public set; }
    public abstract virtual void Clear();
    public abstract virtual void Open(IParentUndoUnit newUnit);
    public abstract virtual void Close(UndoCloseAction closeAction);
    public abstract virtual void Close(IParentUndoUnit closingUnit, UndoCloseAction closeAction);
    public abstract virtual void Add(IUndoUnit newUnit);
    public abstract virtual void OnNextAdd();
    public abstract virtual void OnNextDiscard();
    public abstract virtual IUndoUnit get_LastUnit();
    public abstract virtual IParentUndoUnit get_OpenedUnit();
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual bool get_Locked();
    public abstract virtual object get_Container();
    public abstract virtual void set_Container(object value);
}
internal interface MS.Internal.Documents.IUndoUnit {
    public abstract virtual void Do();
    public abstract virtual bool Merge(IUndoUnit unit);
}
internal abstract class MS.Internal.Documents.LineResult : object {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal abstract virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal abstract virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal abstract virtual ITextPointer GetContentEndPosition();
    internal abstract virtual ITextPointer GetEllipsesPosition();
    internal abstract virtual int GetContentEndPositionCP();
    internal abstract virtual int GetEllipsesPositionCP();
    internal abstract virtual ITextPointer get_StartPosition();
    internal abstract virtual ITextPointer get_EndPosition();
    internal abstract virtual int get_StartPositionCP();
    internal abstract virtual int get_EndPositionCP();
    internal abstract virtual Rect get_LayoutBox();
    internal abstract virtual double get_Baseline();
}
internal class MS.Internal.Documents.MultiPageTextView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal MultiPageTextView(DocumentViewerBase viewer, UIElement renderScope, ITextContainer textContainer);
    protected virtual void OnUpdated(EventArgs e);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    internal virtual void BringPointIntoViewAsync(Point point, object userState);
    internal virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    internal virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    internal virtual void CancelAsync(object userState);
    internal void OnPagesUpdated();
    internal void OnPageLayoutChanged();
    internal ITextView GetPageTextViewFromPosition(ITextPointer position);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
}
internal class MS.Internal.Documents.PageCache : object {
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public bool DynamicPageSizes { get; }
    public bool IsContentRightToLeft { get; }
    public bool IsPaginationCompleted { get; }
    public void set_Content(DynamicDocumentPaginator value);
    public DynamicDocumentPaginator get_Content();
    public int get_PageCount();
    public bool get_DynamicPageSizes();
    public bool get_IsContentRightToLeft();
    public bool get_IsPaginationCompleted();
    [CompilerGeneratedAttribute]
public void add_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PageCacheChanged(PageCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageCacheChanged(PageCacheChangedEventHandler value);
    public Size GetPageSize(int pageNumber);
    public bool IsPageDirty(int pageNumber);
}
internal class MS.Internal.Documents.PageCacheChange : object {
    public int Start { get; }
    public int Count { get; }
    public PageCacheChangeType Type { get; }
    public PageCacheChange(int start, int count, PageCacheChangeType type);
    public int get_Start();
    public int get_Count();
    public PageCacheChangeType get_Type();
}
internal class MS.Internal.Documents.PageCacheChangedEventArgs : EventArgs {
    public List`1<PageCacheChange> Changes { get; }
    public PageCacheChangedEventArgs(List`1<PageCacheChange> changes);
    public List`1<PageCacheChange> get_Changes();
}
internal class MS.Internal.Documents.PageCacheChangedEventHandler : MulticastDelegate {
    public PageCacheChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PageCacheChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PageCacheChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum MS.Internal.Documents.PageCacheChangeType : Enum {
    public int value__;
    public static PageCacheChangeType Add;
    public static PageCacheChangeType Remove;
    public static PageCacheChangeType Update;
}
internal class MS.Internal.Documents.PageCacheEntry : ValueType {
    public Size PageSize;
    public bool Dirty;
}
internal class MS.Internal.Documents.PageDestroyedWatcher : object {
    public void AddPage(DocumentPage page);
    public void RemovePage(DocumentPage page);
    public bool IsDestroyed(DocumentPage page);
}
internal abstract class MS.Internal.Documents.ParagraphResult : object {
    protected BaseParaClient _paraClient;
    protected Rect _layoutBox;
    protected DependencyObject _element;
    protected bool _hasTextContent;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal Rect LayoutBox { get; }
    internal DependencyObject Element { get; }
    internal bool HasTextContent { get; }
    internal ParagraphResult(BaseParaClient paraClient);
    internal ParagraphResult(BaseParaClient paraClient, Rect layoutBox, DependencyObject element);
    internal virtual bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
    internal Rect get_LayoutBox();
    internal DependencyObject get_Element();
    internal virtual bool get_HasTextContent();
}
internal class MS.Internal.Documents.ParentUndoUnit : object {
    public string Description { get; public set; }
    public IParentUndoUnit OpenedUnit { get; }
    public IUndoUnit LastUnit { get; }
    public bool Locked { get; protected set; }
    public object Container { get; public set; }
    protected IParentUndoUnit DeepestOpenUnit { get; }
    protected object TopContainer { get; }
    protected Stack Units { get; }
    public ParentUndoUnit(string description);
    public virtual void Open(IParentUndoUnit newUnit);
    public virtual void Close(UndoCloseAction closeAction);
    public virtual void Close(IParentUndoUnit unit, UndoCloseAction closeAction);
    public virtual void Add(IUndoUnit unit);
    public virtual void Clear();
    public virtual void OnNextAdd();
    public virtual void OnNextDiscard();
    public virtual void Do();
    public virtual bool Merge(IUndoUnit unit);
    public sealed virtual string get_Description();
    public sealed virtual void set_Description(string value);
    public sealed virtual IParentUndoUnit get_OpenedUnit();
    public sealed virtual IUndoUnit get_LastUnit();
    public virtual bool get_Locked();
    protected virtual void set_Locked(bool value);
    public sealed virtual object get_Container();
    public sealed virtual void set_Container(object value);
    protected void Init(string description);
    protected void SetOpenedUnit(IParentUndoUnit value);
    protected void SetLastUnit(IUndoUnit value);
    protected virtual IParentUndoUnit CreateParentUndoUnitForSelf();
    protected IParentUndoUnit get_DeepestOpenUnit();
    protected object get_TopContainer();
    protected Stack get_Units();
}
internal class MS.Internal.Documents.ReaderPageViewer : FlowDocumentPageViewer {
    private ContentPosition MS.Internal.Documents.IFlowDocumentViewer.ContentPosition { get; private set; }
    private ITextSelection MS.Internal.Documents.IFlowDocumentViewer.TextSelection { get; private set; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPreviousPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToNextPage { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageNumber { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageCount { get; }
    protected virtual void OnPrintCompleted();
    protected virtual void OnPrintCommand();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.PreviousPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.NextPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.FirstPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.LastPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.Print();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.CancelPrint();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.ShowFindResult(ITextRange findResult);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.GoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.SetDocument(FlowDocument document);
    private sealed virtual override ContentPosition MS.Internal.Documents.IFlowDocumentViewer.get_ContentPosition();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_ContentPosition(ContentPosition value);
    private sealed virtual override ITextSelection MS.Internal.Documents.IFlowDocumentViewer.get_TextSelection();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_TextSelection(ITextSelection value);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToPreviousPage();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToNextPage();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageNumber();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageCount();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintCompleted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintCompleted(EventHandler value);
}
internal class MS.Internal.Documents.ReaderScrollViewer : FlowDocumentScrollViewer {
    private ContentPosition MS.Internal.Documents.IFlowDocumentViewer.ContentPosition { get; private set; }
    private ITextSelection MS.Internal.Documents.IFlowDocumentViewer.TextSelection { get; private set; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPreviousPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToNextPage { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageNumber { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageCount { get; }
    protected virtual void OnPrintCompleted();
    protected virtual void OnPrintCommand();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.PreviousPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.NextPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.FirstPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.LastPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.Print();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.CancelPrint();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.ShowFindResult(ITextRange findResult);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.GoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.SetDocument(FlowDocument document);
    private sealed virtual override ContentPosition MS.Internal.Documents.IFlowDocumentViewer.get_ContentPosition();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_ContentPosition(ContentPosition value);
    private sealed virtual override ITextSelection MS.Internal.Documents.IFlowDocumentViewer.get_TextSelection();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_TextSelection(ITextSelection value);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToPreviousPage();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToNextPage();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageNumber();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageCount();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintCompleted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintCompleted(EventHandler value);
}
internal class MS.Internal.Documents.ReaderTwoPageViewer : ReaderPageViewer {
    private static ReaderTwoPageViewer();
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
}
internal class MS.Internal.Documents.RowCache : object {
    public PageCache PageCache { get; public set; }
    public int RowCount { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public double Scale { get; public set; }
    public double ExtentHeight { get; }
    public double ExtentWidth { get; }
    public bool HasValidLayout { get; }
    public void set_PageCache(PageCache value);
    public PageCache get_PageCache();
    public int get_RowCount();
    public void set_VerticalPageSpacing(double value);
    public double get_VerticalPageSpacing();
    public void set_HorizontalPageSpacing(double value);
    public double get_HorizontalPageSpacing();
    public void set_Scale(double value);
    public double get_Scale();
    public double get_ExtentHeight();
    public double get_ExtentWidth();
    public bool get_HasValidLayout();
    [CompilerGeneratedAttribute]
public void add_RowCacheChanged(RowCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RowCacheChanged(RowCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RowLayoutCompleted(RowLayoutCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RowLayoutCompleted(RowLayoutCompletedEventHandler value);
    public RowInfo GetRow(int index);
    public RowInfo GetRowForPageNumber(int pageNumber);
    public int GetRowIndexForPageNumber(int pageNumber);
    public int GetRowIndexForVerticalOffset(double offset);
    public void GetVisibleRowIndices(double startOffset, double endOffset, Int32& startRowIndex, Int32& rowCount);
    public void RecalcLayoutForScaleOrSpacing();
    public void RecalcRows(int pivotPage, int columns);
}
internal class MS.Internal.Documents.RowCacheChange : object {
    public int Start { get; }
    public int Count { get; }
    public RowCacheChange(int start, int count);
    public int get_Start();
    public int get_Count();
}
internal class MS.Internal.Documents.RowCacheChangedEventArgs : EventArgs {
    public List`1<RowCacheChange> Changes { get; }
    public RowCacheChangedEventArgs(List`1<RowCacheChange> changes);
    public List`1<RowCacheChange> get_Changes();
}
internal class MS.Internal.Documents.RowCacheChangedEventHandler : MulticastDelegate {
    public RowCacheChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RowCacheChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RowCacheChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.RowInfo : object {
    public Size RowSize { get; }
    public double VerticalOffset { get; public set; }
    public int FirstPage { get; public set; }
    public int PageCount { get; }
    public void AddPage(Size pageSize);
    public void ClearPages();
    public Size get_RowSize();
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public int get_FirstPage();
    public void set_FirstPage(int value);
    public int get_PageCount();
}
internal class MS.Internal.Documents.RowLayoutCompletedEventArgs : EventArgs {
    public int PivotRowIndex { get; }
    public RowLayoutCompletedEventArgs(int pivotRowIndex);
    public int get_PivotRowIndex();
}
internal class MS.Internal.Documents.RowLayoutCompletedEventHandler : MulticastDelegate {
    public RowLayoutCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RowLayoutCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RowLayoutCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.RowParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<ParagraphResult> CellParagraphs { get; }
    internal bool HasTextContent { get; }
    internal RowParagraphResult(BaseParaClient paraClient, int index, Rect rowRect, RowParagraph rowParagraph);
    internal ReadOnlyCollection`1<ParagraphResult> get_CellParagraphs();
    internal virtual bool get_HasTextContent();
}
internal class MS.Internal.Documents.ScrollData : object {
    internal bool CanVerticallyScroll { get; internal set; }
    internal bool CanHorizontallyScroll { get; internal set; }
    internal double ExtentWidth { get; internal set; }
    internal double ExtentHeight { get; internal set; }
    internal double ViewportWidth { get; }
    internal double ViewportHeight { get; }
    internal double HorizontalOffset { get; }
    internal double VerticalOffset { get; }
    internal ScrollViewer ScrollOwner { get; }
    internal Vector Offset { get; internal set; }
    internal Size Extent { get; internal set; }
    internal Size Viewport { get; internal set; }
    internal void LineUp(UIElement owner);
    internal void LineDown(UIElement owner);
    internal void LineLeft(UIElement owner);
    internal void LineRight(UIElement owner);
    internal void PageUp(UIElement owner);
    internal void PageDown(UIElement owner);
    internal void PageLeft(UIElement owner);
    internal void PageRight(UIElement owner);
    internal void MouseWheelUp(UIElement owner);
    internal void MouseWheelDown(UIElement owner);
    internal void MouseWheelLeft(UIElement owner);
    internal void MouseWheelRight(UIElement owner);
    internal void SetHorizontalOffset(UIElement owner, double offset);
    internal void SetVerticalOffset(UIElement owner, double offset);
    internal Rect MakeVisible(UIElement owner, Visual visual, Rect rectangle);
    internal void SetScrollOwner(UIElement owner, ScrollViewer value);
    internal bool get_CanVerticallyScroll();
    internal void set_CanVerticallyScroll(bool value);
    internal bool get_CanHorizontallyScroll();
    internal void set_CanHorizontallyScroll(bool value);
    internal double get_ExtentWidth();
    internal void set_ExtentWidth(double value);
    internal double get_ExtentHeight();
    internal void set_ExtentHeight(double value);
    internal double get_ViewportWidth();
    internal double get_ViewportHeight();
    internal double get_HorizontalOffset();
    internal double get_VerticalOffset();
    internal ScrollViewer get_ScrollOwner();
    internal Vector get_Offset();
    internal void set_Offset(Vector value);
    internal Size get_Extent();
    internal void set_Extent(Size value);
    internal Size get_Viewport();
    internal void set_Viewport(Size value);
}
internal class MS.Internal.Documents.SubpageParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal SubpageParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Documents.TableColumnCollectionInternal : ContentElementCollection`2<Table, TableColumn> {
    public TableColumn Item { get; public set; }
    internal TableColumnCollectionInternal(Table owner);
    public virtual void Add(TableColumn item);
    public virtual void Clear();
    public virtual void Insert(int index, TableColumn item);
    internal virtual void PrivateConnectChild(int index, TableColumn item);
    internal virtual void PrivateDisconnectChild(TableColumn item);
    public virtual bool Remove(TableColumn item);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public virtual TableColumn get_Item(int index);
    public virtual void set_Item(int index, TableColumn value);
}
internal class MS.Internal.Documents.TableParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal TableParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPoint(Point point, bool snapToText);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal CellParaClient GetCellParaClientFromPosition(ITextPointer position);
    internal CellParaClient GetCellAbove(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellParaClient GetCellBelow(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellInfo GetCellInfoFromPoint(Point point);
    internal Rect GetRectangleFromRowEndPosition(ITextPointer position);
    internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal virtual bool get_HasTextContent();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Documents.TableTextElementCollectionInternal`2 : ContentElementCollection`2<TParent, TElementType> {
    public TElementType Item { get; public set; }
    internal TableTextElementCollectionInternal`2(TParent owner);
    public virtual void Add(TElementType item);
    public virtual void Clear();
    public virtual void Insert(int index, TElementType item);
    public virtual bool Remove(TElementType item);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    internal virtual void PrivateConnectChild(int index, TElementType item);
    internal virtual void PrivateDisconnectChild(TElementType item);
    internal int FindInsertionIndex(TElementType item);
    internal void InternalAdd(TElementType item);
    internal void InternalRemove(TElementType item);
    public virtual TElementType get_Item(int index);
    public virtual void set_Item(int index, TElementType value);
}
internal static class MS.Internal.Documents.TextContainerHelper : object {
    internal static int ElementEdgeCharacterLength;
    internal static int EmbeddedObjectLength { get; }
    private static TextContainerHelper();
    internal static List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end, ITextPointer ownerContentStart);
    internal static bool IsImmediateAutomationChild(ITextPointer elementStart, ITextPointer ownerContentStart);
    internal static AutomationPeer GetEnclosingAutomationPeer(ITextPointer start, ITextPointer end, ITextPointer& elementStart, ITextPointer& elementEnd);
    internal static TextContentRange GetTextContentRangeForTextElement(TextElement textElement);
    internal static TextContentRange GetTextContentRangeForTextElementEdge(TextElement textElement, ElementEdge edge);
    internal static ITextPointer GetContentStart(ITextContainer textContainer, DependencyObject element);
    internal static int GetElementLength(ITextContainer textContainer, DependencyObject element);
    internal static int get_EmbeddedObjectLength();
    internal static ITextPointer GetTextPointerFromCP(ITextContainer textContainer, int cp, LogicalDirection direction);
    internal static StaticTextPointer GetStaticTextPointerFromCP(ITextContainer textContainer, int cp);
    internal static ITextPointer GetTextPointerForEmbeddedObject(FrameworkElement embeddedObject);
    internal static int GetCPFromElement(ITextContainer textContainer, DependencyObject element, ElementEdge edge);
    internal static int GetCchFromElement(ITextContainer textContainer, DependencyObject element);
    internal static int GetCPFromEmbeddedObject(UIElement embeddedObject, ElementEdge edge);
}
internal class MS.Internal.Documents.TextContentRange : object {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal TextContentRange(int cpFirst, int cpLast, ITextContainer textContainer);
    internal void Merge(TextContentRange other);
    internal ReadOnlyCollection`1<TextSegment> GetTextSegments();
    internal bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
}
internal class MS.Internal.Documents.TextDocumentView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal TextDocumentView(FlowDocumentPage owner, ITextContainer textContainer);
    private static TextDocumentView();
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal CellInfo GetCellInfoFromPoint(Point point, Table tableFilter);
    internal void OnUpdated();
    internal void Invalidate();
    internal static bool Contains(ITextPointer position, ReadOnlyCollection`1<TextSegment> segments);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal static Geometry GetTightBoundingGeometryFromTextPositionsHelper(ReadOnlyCollection`1<ParagraphResult> paragraphs, ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    internal static Geometry GetTightBoundingGeometryFromTextPositionsHelper(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
}
internal class MS.Internal.Documents.TextParagraphResult : ParagraphResult {
    internal ReadOnlyCollection`1<LineResult> Lines { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Floaters { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Figures { get; }
    internal bool HasTextContent { get; }
    internal TextParagraphResult(TextParaClient paraClient);
    internal Rect GetRectangleFromTextPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    internal bool IsAtCaretUnitBoundary(ITextPointer position);
    internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position, bool strict);
    internal ReadOnlyCollection`1<LineResult> get_Lines();
    internal ReadOnlyCollection`1<ParagraphResult> get_Floaters();
    internal ReadOnlyCollection`1<ParagraphResult> get_Figures();
    internal virtual bool get_HasTextContent();
}
internal class MS.Internal.Documents.TextParagraphView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal ReadOnlyCollection`1<LineResult> Lines { get; }
    internal TextParagraphView(TextBlock owner, ITextContainer textContainer);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal static ITextPointer GetTextPositionFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText);
    internal static int GetLineFromPosition(ReadOnlyCollection`1<LineResult> lines, ITextPointer position);
    internal void OnUpdated();
    internal void Invalidate();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal ReadOnlyCollection`1<LineResult> get_Lines();
    internal static int GetLineFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText);
}
internal abstract class MS.Internal.Documents.TextViewBase : object {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    private UIElement System.Windows.Documents.ITextView.RenderScope { get; }
    private ITextContainer System.Windows.Documents.ITextView.TextContainer { get; }
    private bool System.Windows.Documents.ITextView.IsValid { get; }
    private bool System.Windows.Documents.ITextView.RendersOwnSelection { get; }
    private ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.TextSegments { get; }
    internal abstract virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRectangleFromTextPosition(ITextPointer position);
    internal abstract virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal abstract virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal abstract virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal abstract virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal abstract virtual bool Contains(ITextPointer position);
    internal static void BringRectIntoViewMinimally(ITextView textView, Rect rect);
    internal virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    internal virtual void BringPointIntoViewAsync(Point point, object userState);
    internal virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    internal virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    internal virtual void CancelAsync(object userState);
    internal virtual bool Validate();
    internal virtual bool Validate(Point point);
    internal virtual bool Validate(ITextPointer position);
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal abstract virtual UIElement get_RenderScope();
    internal abstract virtual ITextContainer get_TextContainer();
    internal abstract virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal abstract virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler value);
    protected virtual void OnBringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventArgs e);
    protected virtual void OnBringPointIntoViewCompleted(BringPointIntoViewCompletedEventArgs e);
    protected virtual void OnBringLineIntoViewCompleted(BringLineIntoViewCompletedEventArgs e);
    protected virtual void OnBringPageIntoViewCompleted(BringPageIntoViewCompletedEventArgs e);
    protected virtual void OnUpdated(EventArgs e);
    protected virtual Transform GetAggregateTransform(Transform firstTransform, Transform secondTransform);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetTextPositionFromPoint(Point point, bool snapToText);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRectangleFromTextPosition(ITextPointer position);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    private sealed virtual override Geometry System.Windows.Documents.ITextView.GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    private sealed virtual override bool System.Windows.Documents.ITextView.IsAtCaretUnitBoundary(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetBackspaceCaretUnitPosition(ITextPointer position);
    private sealed virtual override TextSegment System.Windows.Documents.ITextView.GetLineRange(ITextPointer position);
    private sealed virtual override ReadOnlyCollection`1<GlyphRun> System.Windows.Documents.ITextView.GetGlyphRuns(ITextPointer start, ITextPointer end);
    private sealed virtual override bool System.Windows.Documents.ITextView.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPositionIntoViewAsync(ITextPointer position, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPointIntoViewAsync(Point point, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.CancelAsync(object userState);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate();
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(Point point);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.ThrottleBackgroundTasksForUserInput();
    private sealed virtual override UIElement System.Windows.Documents.ITextView.get_RenderScope();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextView.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_IsValid();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_RendersOwnSelection();
    private sealed virtual override ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.get_TextSegments();
}
internal class MS.Internal.Documents.UIElementIsland : ContainerVisual {
    internal UIElement Root { get; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal UIElementIsland(UIElement child);
    internal Size DoLayout(Size availableSize, bool horizontalAutoSize, bool verticalAutoSize);
    internal UIElement get_Root();
    [CompilerGeneratedAttribute]
internal void add_DesiredSizeChanged(DesiredSizeChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DesiredSizeChanged(DesiredSizeChangedEventHandler value);
    public sealed virtual void Dispose();
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.Documents.UIElementParagraphResult : FloaterBaseParagraphResult {
    internal bool HasTextContent { get; }
    internal UIElementParagraphResult(BaseParaClient paraClient);
    internal virtual bool get_HasTextContent();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
}
internal enum MS.Internal.Documents.UndoCloseAction : Enum {
    public int value__;
    public static UndoCloseAction Commit;
    public static UndoCloseAction Rollback;
    public static UndoCloseAction Discard;
}
internal class MS.Internal.Documents.UndoManager : object {
    internal bool IsImeSupportModeEnabled { get; internal set; }
    internal int UndoLimit { get; internal set; }
    internal UndoState State { get; }
    internal bool IsEnabled { get; internal set; }
    internal IParentUndoUnit OpenedUnit { get; }
    internal IUndoUnit LastUnit { get; }
    internal IParentUndoUnit LastReopenedUnit { get; }
    internal int UndoCount { get; }
    internal int RedoCount { get; }
    internal static int UndoLimitDefaultValue { get; }
    internal int MinUndoStackCount { get; internal set; }
    protected IParentUndoUnit DeepestOpenUnit { get; }
    protected List`1<IUndoUnit> UndoStack { get; }
    protected Stack RedoStack { get; }
    private static UndoManager();
    internal static void AttachUndoManager(DependencyObject scope, UndoManager undoManager);
    internal static void DetachUndoManager(DependencyObject scope);
    internal static UndoManager GetUndoManager(DependencyObject target);
    internal void Open(IParentUndoUnit unit);
    internal void Reopen(IParentUndoUnit unit);
    internal void Close(UndoCloseAction closeAction);
    internal void Close(IParentUndoUnit unit, UndoCloseAction closeAction);
    internal void Add(IUndoUnit unit);
    internal void Clear();
    internal void Undo(int count);
    internal void Redo(int count);
    internal virtual void OnNextDiscard();
    internal IUndoUnit PeekUndoStack();
    internal Stack SetRedoStack(Stack value);
    internal bool get_IsImeSupportModeEnabled();
    internal void set_IsImeSupportModeEnabled(bool value);
    internal int get_UndoLimit();
    internal void set_UndoLimit(int value);
    internal UndoState get_State();
    internal bool get_IsEnabled();
    internal void set_IsEnabled(bool value);
    internal IParentUndoUnit get_OpenedUnit();
    internal IUndoUnit get_LastUnit();
    internal IParentUndoUnit get_LastReopenedUnit();
    internal int get_UndoCount();
    internal int get_RedoCount();
    internal static int get_UndoLimitDefaultValue();
    internal IUndoUnit GetUndoUnit(int index);
    internal void RemoveUndoRange(int index, int count);
    internal int get_MinUndoStackCount();
    internal void set_MinUndoStackCount(int value);
    protected void SetState(UndoState value);
    protected void SetOpenedUnit(IParentUndoUnit value);
    protected void SetLastUnit(IUndoUnit value);
    protected IParentUndoUnit get_DeepestOpenUnit();
    protected List`1<IUndoUnit> get_UndoStack();
    protected Stack get_RedoStack();
}
internal enum MS.Internal.Documents.UndoState : Enum {
    public int value__;
    public static UndoState Normal;
    public static UndoState Undo;
    public static UndoState Redo;
    public static UndoState Rollback;
}
internal abstract class MS.Internal.FixedPageInfo : object {
    internal int GlyphRunCount { get; }
    internal abstract virtual GlyphRunInfo GlyphRunAtPosition(int position);
    internal abstract virtual int get_GlyphRunCount();
}
internal static class MS.Internal.FrameworkAppContextSwitches : object {
    internal static string DoNotApplyLayoutRoundingToMarginsAndBorderThicknessSwitchName;
    internal static string GridStarDefinitionsCanExceedAvailableSpaceSwitchName;
    internal static string SelectionPropertiesCanLagBehindSelectionChangedEventSwitchName;
    internal static string DoNotUseFollowParentWhenBindingToADODataRelationSwitchName;
    internal static string UseAdornerForTextboxSelectionRenderingSwitchName;
    internal static string AppendLocalAssemblyVersionForSourceUriSwitchName;
    public static bool DoNotApplyLayoutRoundingToMarginsAndBorderThickness { get; }
    public static bool GridStarDefinitionsCanExceedAvailableSpace { get; }
    public static bool SelectionPropertiesCanLagBehindSelectionChangedEvent { get; }
    public static bool DoNotUseFollowParentWhenBindingToADODataRelation { get; }
    public static bool UseLegacyAccessibilityFeatures { get; }
    public static bool UseLegacyAccessibilityFeatures2 { get; }
    public static bool UseAdornerForTextboxSelectionRendering { get; }
    public static bool AppendLocalAssemblyVersionForSourceUri { get; }
    public static bool get_DoNotApplyLayoutRoundingToMarginsAndBorderThickness();
    public static bool get_GridStarDefinitionsCanExceedAvailableSpace();
    public static bool get_SelectionPropertiesCanLagBehindSelectionChangedEvent();
    public static bool get_DoNotUseFollowParentWhenBindingToADODataRelation();
    public static bool get_UseLegacyAccessibilityFeatures();
    public static bool get_UseLegacyAccessibilityFeatures2();
    public static bool get_UseAdornerForTextboxSelectionRendering();
    public static bool get_AppendLocalAssemblyVersionForSourceUri();
}
internal class MS.Internal.FrameworkObject : ValueType {
    private FrameworkElement _fe;
    private FrameworkContentElement _fce;
    private DependencyObject _do;
    internal FrameworkElement FE { get; }
    internal FrameworkContentElement FCE { get; }
    internal DependencyObject DO { get; }
    internal bool IsFE { get; }
    internal bool IsFCE { get; }
    internal bool IsValid { get; }
    internal DependencyObject Parent { get; }
    internal int TemplateChildIndex { get; }
    internal DependencyObject TemplatedParent { get; }
    internal Style ThemeStyle { get; }
    internal XmlLanguage Language { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkObject FrameworkParent { get; }
    internal Style Style { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal DependencyObject EffectiveParent { get; }
    internal FrameworkObject PreferVisualParent { get; }
    internal bool IsLoaded { get; }
    internal bool IsInitialized { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal InheritanceBehavior InheritanceBehavior { get; }
    internal bool StoresParentTemplateValues { get; internal set; }
    unknown bool HasResourceReference {internal set; }
    unknown bool HasTemplateChanged {internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal FrameworkObject(DependencyObject d);
    internal FrameworkObject(DependencyObject d, bool throwIfNeither);
    internal FrameworkObject(FrameworkElement fe, FrameworkContentElement fce);
    internal void Reset(DependencyObject d);
    internal FrameworkElement get_FE();
    internal FrameworkContentElement get_FCE();
    internal DependencyObject get_DO();
    internal bool get_IsFE();
    internal bool get_IsFCE();
    internal bool get_IsValid();
    internal DependencyObject get_Parent();
    internal int get_TemplateChildIndex();
    internal DependencyObject get_TemplatedParent();
    internal Style get_ThemeStyle();
    internal XmlLanguage get_Language();
    internal FrameworkTemplate get_TemplateInternal();
    internal FrameworkObject get_FrameworkParent();
    internal static FrameworkObject GetContainingFrameworkElement(DependencyObject current);
    internal Style get_Style();
    internal void set_Style(Style value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal DependencyObject get_EffectiveParent();
    internal FrameworkObject get_PreferVisualParent();
    internal bool get_IsLoaded();
    internal bool get_IsInitialized();
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal InheritanceBehavior get_InheritanceBehavior();
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal void set_HasResourceReference(bool value);
    internal void set_HasTemplateChanged(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal static bool IsEffectiveAncestor(DependencyObject d1, DependencyObject d2);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal void BeginInit();
    internal void EndInit();
    internal object FindName(string name, DependencyObject& scopeOwner);
    internal FrameworkObject GetPreferVisualParent(bool force);
    internal void RaiseEvent(RoutedEventArgs args);
    internal void OnLoaded(RoutedEventArgs args);
    internal void OnUnloaded(RoutedEventArgs args);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    internal void OnInheritedPropertyChanged(InheritablePropertyChangeInfo& info);
    internal void SetShouldLookupImplicitStyles();
    internal void add_Loaded(RoutedEventHandler value);
    internal void remove_Loaded(RoutedEventHandler value);
    internal void add_Unloaded(RoutedEventHandler value);
    internal void remove_Unloaded(RoutedEventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    public virtual string ToString();
}
internal class MS.Internal.Globalization.BamlConnectionIdNode : BamlTreeNode {
    internal BamlConnectionIdNode(int connectionId);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal static class MS.Internal.Globalization.BamlConst : object {
    internal static string ContentSuffix;
    internal static string LiteralContentSuffix;
    internal static char KeySeperator;
    internal static char ChildStart;
    internal static char ChildEnd;
    internal static char EscapeChar;
}
internal class MS.Internal.Globalization.BamlContentPropertyNode : BamlTreeNode {
    internal BamlContentPropertyNode(string assemblyName, string typeFullName, string propertyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlDefAttributeNode : BamlTreeNode {
    internal BamlDefAttributeNode(string name, string value);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndComplexPropertyNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndConstructorNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndDocumentNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndElementNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEventNode : BamlTreeNode {
    internal BamlEventNode(string eventName, string handlerName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlLiteralContentNode : BamlTreeNode {
    internal string Content { get; internal set; }
    internal BamlLiteralContentNode(string literalContent);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Content();
    internal void set_Content(string value);
}
internal class MS.Internal.Globalization.BamlPIMappingNode : BamlTreeNode {
    internal BamlPIMappingNode(string xmlNamespace, string clrNamespace, string assemblyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlPresentationOptionsAttributeNode : BamlTreeNode {
    internal BamlPresentationOptionsAttributeNode(string name, string value);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlPropertyNode : BamlStartComplexPropertyNode {
    internal string Value { get; internal set; }
    internal int Index { get; internal set; }
    internal BamlPropertyNode(string assemblyName, string ownerTypeFullName, string propertyName, string value, BamlAttributeUsage usage);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Value();
    internal void set_Value(string value);
    internal int get_Index();
    internal void set_Index(int value);
}
internal static class MS.Internal.Globalization.BamlResourceContentUtil : object {
    private static BamlResourceContentUtil();
    internal static string EscapeString(string content);
    internal static string UnescapeString(string content);
    internal static BamlStringToken[] ParseChildPlaceholder(string input);
}
internal class MS.Internal.Globalization.BamlResourceDeserializer : object {
    internal static BamlTree LoadBaml(Stream bamlStream);
}
internal class MS.Internal.Globalization.BamlResourceSerializer : object {
    internal static void Serialize(BamlLocalizer localizer, BamlTree tree, Stream output);
}
internal class MS.Internal.Globalization.BamlRoutedEventNode : BamlTreeNode {
    internal BamlRoutedEventNode(string assemblyName, string ownerTypeFullName, string eventIdName, string handlerName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlStartComplexPropertyNode : BamlTreeNode {
    protected string _assemblyName;
    protected string _ownerTypeFullName;
    protected string _propertyName;
    internal string AssemblyName { get; }
    internal string PropertyName { get; }
    internal string OwnerTypeFullName { get; }
    public ILocalizabilityInheritable LocalizabilityAncestor { get; public set; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal BamlStartComplexPropertyNode(string assemblyName, string ownerTypeFullName, string propertyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_AssemblyName();
    internal string get_PropertyName();
    internal string get_OwnerTypeFullName();
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public void set_LocalizabilityAncestor(ILocalizabilityInheritable value);
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStartConstructorNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlStartDocumentNode : BamlTreeNode {
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStartElementNode : BamlTreeNode {
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string Content { get; internal set; }
    internal string Uid { get; internal set; }
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal BamlStartElementNode(string assemblyName, string typeFullName, bool isInjected, bool useTypeConverter);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal void InsertProperty(BamlTreeNode child);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_Content();
    internal void set_Content(string value);
    internal string get_Uid();
    internal void set_Uid(string value);
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStringToken : ValueType {
    internal TokenType Type;
    internal string Value;
    internal BamlStringToken(TokenType type, string value);
}
internal class MS.Internal.Globalization.BamlTextNode : BamlTreeNode {
    internal string Content { get; }
    internal BamlTextNode(string text);
    internal BamlTextNode(string text, string typeConverterAssemblyName, string typeConverterName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Content();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Globalization.BamlTree : object {
    internal BamlTreeNode Root { get; }
    internal int Size { get; }
    internal BamlTreeNode Item { get; }
    internal BamlTree(BamlTreeNode root, int size);
    internal BamlTreeNode get_Root();
    internal int get_Size();
    internal BamlTreeNode get_Item(int i);
    internal BamlTree Copy();
    internal void AddTreeNode(BamlTreeNode node);
}
internal class MS.Internal.Globalization.BamlTreeMap : object {
    internal BamlLocalizationDictionary LocalizationDictionary { get; }
    internal InternalBamlLocalizabilityResolver Resolver { get; }
    internal BamlTreeMap(BamlLocalizer localizer, BamlTree tree, BamlLocalizabilityResolver resolver, TextReader comments);
    internal BamlLocalizationDictionary get_LocalizationDictionary();
    internal InternalBamlLocalizabilityResolver get_Resolver();
    internal BamlTreeNode MapKeyToBamlTreeNode(BamlLocalizableResourceKey key, BamlTree tree);
    internal BamlStartElementNode MapUidToBamlTreeElementNode(string uid, BamlTree tree);
    internal void EnsureMap();
    internal static BamlLocalizableResourceKey GetKey(BamlTreeNode node);
}
internal abstract class MS.Internal.Globalization.BamlTreeNode : object {
    protected BamlNodeType _nodeType;
    protected List`1<BamlTreeNode> _children;
    protected BamlTreeNode _parent;
    internal BamlNodeType NodeType { get; internal set; }
    internal List`1<BamlTreeNode> Children { get; internal set; }
    internal BamlTreeNode Parent { get; internal set; }
    internal bool Formatted { get; internal set; }
    internal bool Visited { get; internal set; }
    internal bool Unidentifiable { get; internal set; }
    internal BamlTreeNode(BamlNodeType type);
    internal void AddChild(BamlTreeNode child);
    internal abstract virtual BamlTreeNode Copy();
    internal abstract virtual void Serialize(BamlWriter writer);
    internal BamlNodeType get_NodeType();
    internal void set_NodeType(BamlNodeType value);
    internal List`1<BamlTreeNode> get_Children();
    internal void set_Children(List`1<BamlTreeNode> value);
    internal BamlTreeNode get_Parent();
    internal void set_Parent(BamlTreeNode value);
    internal bool get_Formatted();
    internal void set_Formatted(bool value);
    internal bool get_Visited();
    internal void set_Visited(bool value);
    internal bool get_Unidentifiable();
    internal void set_Unidentifiable(bool value);
}
internal static class MS.Internal.Globalization.BamlTreeUpdater : object {
    internal static void UpdateTree(BamlTree tree, BamlTreeMap treeMap, BamlLocalizationDictionary dictionary);
}
internal class MS.Internal.Globalization.BamlXmlnsPropertyNode : BamlTreeNode {
    internal BamlXmlnsPropertyNode(string prefix, string xmlns);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal interface MS.Internal.Globalization.ILocalizabilityInheritable {
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    public abstract virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public abstract virtual LocalizabilityAttribute get_InheritableAttribute();
    public abstract virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public abstract virtual bool get_IsIgnored();
    public abstract virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.InternalBamlLocalizabilityResolver : BamlLocalizabilityResolver {
    internal InternalBamlLocalizabilityResolver(BamlLocalizer localizer, BamlLocalizabilityResolver externalResolver, TextReader comments);
    internal void AddClassAndAssembly(string className, string assemblyName);
    internal void InitLocalizabilityCache();
    internal void ReleaseLocalizabilityCache();
    internal LocalizabilityGroup GetLocalizabilityComment(BamlStartElementNode node, string localName);
    internal string GetStringComment(BamlStartElementNode node, string localName);
    internal void RaiseErrorNotifyEvent(BamlLocalizerErrorNotifyEventArgs e);
    public virtual ElementLocalizability GetElementLocalizability(string assembly, string className);
    public virtual LocalizabilityAttribute GetPropertyLocalizability(string assembly, string className, string property);
    public virtual string ResolveFormattingTagToClass(string formattingTag);
    public virtual string ResolveAssemblyFromClass(string className);
}
internal class MS.Internal.Globalization.LocalizabilityGroup : object {
    internal Modifiability Modifiability;
    internal Readability Readability;
    internal LocalizationCategory Category;
    internal LocalizabilityAttribute Override(LocalizabilityAttribute attribute);
}
internal class MS.Internal.Globalization.LocalizableResourceBuilder : object {
    internal LocalizableResourceBuilder(InternalBamlLocalizabilityResolver resolver);
    internal BamlLocalizableResource BuildFromNode(BamlLocalizableResourceKey key, BamlTreeNode node);
    internal bool TryGetContent(BamlLocalizableResourceKey key, BamlTreeNode currentNode, String& content);
}
internal static class MS.Internal.Globalization.LocComments : object {
    internal static string LocDocumentRoot;
    internal static string LocResourcesElement;
    internal static string LocCommentsElement;
    internal static string LocFileNameAttribute;
    internal static string LocCommentIDAttribute;
    internal static string LocCommentsAttribute;
    internal static string LocLocalizabilityAttribute;
    private static LocComments();
    internal static bool IsLocLocalizabilityProperty(string type, string property);
    internal static bool IsLocCommentsProperty(string type, string property);
    internal static PropertyComment[] ParsePropertyLocalizabilityAttributes(string input);
    internal static PropertyComment[] ParsePropertyComments(string input);
}
internal class MS.Internal.Globalization.PropertyComment : object {
    internal string PropertyName { get; internal set; }
    internal object Value { get; internal set; }
    internal string get_PropertyName();
    internal void set_PropertyName(string value);
    internal object get_Value();
    internal void set_Value(object value);
}
internal abstract class MS.Internal.GlyphRunInfo : object {
    internal Point StartPosition { get; }
    internal Point EndPosition { get; }
    internal double WidthEmFontSize { get; }
    internal double HeightEmFontSize { get; }
    internal bool GlyphsHaveSidewaysOrientation { get; }
    internal int BidiLevel { get; }
    internal UInt32 LanguageID { get; }
    internal string UnicodeString { get; }
    internal abstract virtual Point get_StartPosition();
    internal abstract virtual Point get_EndPosition();
    internal abstract virtual double get_WidthEmFontSize();
    internal abstract virtual double get_HeightEmFontSize();
    internal abstract virtual bool get_GlyphsHaveSidewaysOrientation();
    internal abstract virtual int get_BidiLevel();
    internal abstract virtual UInt32 get_LanguageID();
    internal abstract virtual string get_UnicodeString();
}
internal static class MS.Internal.Hashing.PresentationFramework.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
internal static class MS.Internal.Helper : object {
    private static Helper();
    internal static object ResourceFailureThrow(object key);
    internal static object FindTemplateResourceFromAppOrSystem(DependencyObject target, ArrayList keys, int exactMatch, Int32& bestMatch);
    internal static DependencyObject FindMentor(DependencyObject d);
    internal static bool HasDefaultValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasDefaultOrInheritedValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasUnmodifiedDefaultValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasUnmodifiedDefaultOrInheritedValue(DependencyObject d, DependencyProperty dp);
    internal static void DowncastToFEorFCE(DependencyObject d, FrameworkElement& fe, FrameworkContentElement& fce, bool throwIfNeither);
    internal static void CheckStyleAndStyleSelector(string name, DependencyProperty styleProperty, DependencyProperty styleSelectorProperty, DependencyObject d);
    internal static void CheckTemplateAndTemplateSelector(string name, DependencyProperty templateProperty, DependencyProperty templateSelectorProperty, DependencyObject d);
    internal static bool IsTemplateSelectorDefined(DependencyProperty templateSelectorProperty, DependencyObject d);
    internal static bool IsTemplateDefined(DependencyProperty templateProperty, DependencyObject d);
    internal static object FindNameInTemplate(string name, DependencyObject templatedParent);
    internal static IGeneratorHost GeneratorHostForElement(DependencyObject element);
    internal static DependencyObject GetTemplatedParent(DependencyObject d);
    internal static XmlDataProvider XmlDataProviderForElement(DependencyObject d);
    internal static Size MeasureElementWithSingleChild(UIElement element, Size constraint);
    internal static Size ArrangeElementWithSingleChild(UIElement element, Size arrangeSize);
    internal static bool IsDoubleValid(double value);
    internal static void CheckCanReceiveMarkupExtension(MarkupExtension markupExtension, IServiceProvider serviceProvider, DependencyObject& targetDependencyObject, DependencyProperty& targetDependencyProperty);
    internal static string GetEffectiveStringFormat(string stringFormat);
    internal static object ReadItemValue(DependencyObject owner, object item, int dpIndex);
    internal static void StoreItemValue(DependencyObject owner, object item, int dpIndex, object value);
    internal static void ClearItemValue(DependencyObject owner, object item, int dpIndex);
    internal static List`1<KeyValuePair`2<int, object>> GetItemValues(DependencyObject owner, object item);
    internal static List`1<KeyValuePair`2<int, object>> GetItemValues(DependencyObject owner, object item, WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>> itemValueStorage);
    internal static List`1<KeyValuePair`2<int, object>> EnsureItemValues(DependencyObject owner, object item);
    internal static WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>> EnsureItemValueStorage(DependencyObject owner);
    internal static void SetItemValuesOnContainer(DependencyObject owner, DependencyObject container, object item);
    internal static void StoreItemValues(IContainItemStorage owner, DependencyObject container, object item);
    internal static void ClearItemValueStorage(DependencyObject owner);
    internal static void ClearItemValueStorage(DependencyObject owner, Int32[] dpIndices);
    internal static void ApplyCorrectionFactorToPixelHeaderSize(ItemsControl scrollingItemsControl, FrameworkElement virtualizingElement, Panel itemsHost, Size& headerSize);
    internal static HierarchicalVirtualizationItemDesiredSizes ApplyCorrectionFactorToItemDesiredSizes(FrameworkElement virtualizingElement, Panel itemsHost);
    internal static void ComputeCorrectionFactor(ItemsControl scrollingItemsControl, FrameworkElement virtualizingElement, Panel itemsHost, FrameworkElement headerElement);
    internal static void ClearVirtualizingElement(IHierarchicalVirtualizationAndScrollInfo virtualizingElement);
    internal static T FindTemplatedDescendant(FrameworkElement searchStart, FrameworkElement templatedParent);
    internal static T FindVisualAncestor(DependencyObject element, Func`2<DependencyObject, bool> shouldContinueFunc);
    internal static void InvalidateMeasureOnPath(DependencyObject pathStartElement, DependencyObject pathEndElement, bool duringMeasure);
    internal static void InvalidateMeasureOnPath(DependencyObject pathStartElement, DependencyObject pathEndElement, bool duringMeasure, bool includePathEnd);
    internal static void InvalidateMeasureForSubtree(DependencyObject d);
    internal static bool IsAnyAncestorOf(DependencyObject ancestor, DependencyObject element);
    internal static DependencyObject FindAnyAncestor(DependencyObject element, Predicate`1<DependencyObject> predicate);
    internal static DependencyObject GetAnyParent(DependencyObject element);
    internal static bool IsDefaultValue(DependencyProperty dp, DependencyObject element);
    internal static bool IsComposing(DependencyObject d, DependencyProperty dp);
    internal static bool IsComposing(TextBoxBase tbb);
}
internal class MS.Internal.InheritedPropertyChangedEventArgs : EventArgs {
    internal InheritablePropertyChangeInfo Info { get; }
    internal InheritedPropertyChangedEventArgs(InheritablePropertyChangeInfo& info);
    internal InheritablePropertyChangeInfo get_Info();
}
internal class MS.Internal.InheritedPropertyChangedEventHandler : MulticastDelegate {
    public InheritedPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InheritedPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InheritedPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class MS.Internal.Ink.ClipboardData : object {
    [SecurityCriticalAttribute]
internal bool CopyToDataObject(IDataObject dataObject);
    internal void PasteFromDataObject(IDataObject dataObject);
    internal abstract virtual bool CanPaste(IDataObject dataObject);
    protected abstract virtual bool CanCopy();
    protected abstract virtual void DoCopy(IDataObject dataObject);
    protected abstract virtual void DoPaste(IDataObject dataObject);
}
internal class MS.Internal.Ink.ClipboardProcessor : object {
    internal IEnumerable`1<InkCanvasClipboardFormat> PreferredFormats { get; internal set; }
    internal ClipboardProcessor(InkCanvas inkCanvas);
    internal bool CheckDataFormats(IDataObject dataObject);
    [SecurityCriticalAttribute]
internal InkCanvasClipboardDataFormats CopySelectedData(IDataObject dataObject);
    internal bool PasteData(IDataObject dataObject, StrokeCollection& newStrokes, List`1& newElements);
    [IteratorStateMachineAttribute("MS.Internal.Ink.ClipboardProcessor/<get_PreferredFormats>d__5")]
internal IEnumerable`1<InkCanvasClipboardFormat> get_PreferredFormats();
    internal void set_PreferredFormats(IEnumerable`1<InkCanvasClipboardFormat> value);
}
internal class MS.Internal.Ink.DrawingAttributesDefaultValueFactory : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal abstract class MS.Internal.Ink.EditingBehavior : object {
    public Cursor Cursor { get; }
    protected InkCanvas InkCanvas { get; }
    protected EditingCoordinator EditingCoordinator { get; }
    internal EditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    public void Activate();
    public void Deactivate();
    public void Commit(bool commit);
    public void UpdateTransform();
    public Cursor get_Cursor();
    protected abstract virtual void OnActivate();
    protected abstract virtual void OnDeactivate();
    protected abstract virtual void OnCommit(bool commit);
    protected abstract virtual Cursor GetCurrentCursor();
    protected void SelfDeactivate();
    protected Matrix GetElementTransformMatrix();
    protected virtual void OnTransformChanged();
    protected InkCanvas get_InkCanvas();
    protected EditingCoordinator get_EditingCoordinator();
}
internal class MS.Internal.Ink.EditingCoordinator : object {
    internal bool MoveEnabled { get; internal set; }
    internal bool UserIsEditing { get; internal set; }
    internal bool StylusOrMouseIsDown { get; }
    internal bool ResizeEnabled { get; internal set; }
    internal LassoSelectionBehavior LassoSelectionBehavior { get; }
    internal SelectionEditingBehavior SelectionEditingBehavior { get; }
    internal InkCanvasEditingMode ActiveEditingMode { get; }
    internal SelectionEditor SelectionEditor { get; }
    internal bool IsInMidStroke { get; }
    internal bool IsStylusInverted { get; }
    internal InkCollectionBehavior InkCollectionBehavior { get; }
    internal EditingCoordinator(InkCanvas inkCanvas);
    [SecurityCriticalAttribute]
internal void ActivateDynamicBehavior(EditingBehavior dynamicBehavior, InputDevice inputDevice);
    internal void DeactivateDynamicBehavior();
    internal void UpdateActiveEditingState();
    internal void UpdateEditingState(bool inverted);
    internal void UpdatePointEraserCursor();
    internal void InvalidateTransform();
    internal void InvalidateBehaviorCursor(EditingBehavior behavior);
    internal bool IsCursorValid(EditingBehavior behavior);
    internal bool IsTransformValid(EditingBehavior behavior);
    internal IStylusEditing ChangeStylusEditingMode(StylusEditingBehavior sourceBehavior, InkCanvasEditingMode newMode);
    [ConditionalAttribute("DEBUG")]
internal void DebugCheckActiveBehavior(EditingBehavior behavior);
    internal bool get_MoveEnabled();
    internal void set_MoveEnabled(bool value);
    internal bool get_UserIsEditing();
    internal void set_UserIsEditing(bool value);
    internal bool get_StylusOrMouseIsDown();
    internal InputDevice GetInputDeviceForReset();
    internal bool get_ResizeEnabled();
    internal void set_ResizeEnabled(bool value);
    internal LassoSelectionBehavior get_LassoSelectionBehavior();
    internal SelectionEditingBehavior get_SelectionEditingBehavior();
    internal InkCanvasEditingMode get_ActiveEditingMode();
    internal SelectionEditor get_SelectionEditor();
    internal bool get_IsInMidStroke();
    internal bool get_IsStylusInverted();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnInkCanvasDeviceDown(object sender, InputEventArgs args);
    internal void OnInkCanvasDeviceUp(object sender, InputEventArgs args);
    internal Cursor GetActiveBehaviorCursor();
    internal InkCollectionBehavior get_InkCollectionBehavior();
}
internal abstract class MS.Internal.Ink.ElementsClipboardData : ClipboardData {
    internal List`1<UIElement> Elements { get; }
    protected List`1<UIElement> ElementList { get; protected set; }
    internal ElementsClipboardData(UIElement[] elements);
    internal List`1<UIElement> get_Elements();
    protected List`1<UIElement> get_ElementList();
    protected void set_ElementList(List`1<UIElement> value);
}
internal class MS.Internal.Ink.EraserBehavior : StylusEditingBehavior {
    internal EraserBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual Cursor GetCurrentCursor();
    protected virtual void OnTransformChanged();
}
internal abstract class MS.Internal.Ink.HighContrastCallback : object {
    internal Dispatcher Dispatcher { get; }
    internal abstract virtual void TurnHighContrastOn(Color highContrastColor);
    internal abstract virtual void TurnHighContrastOff();
    internal abstract virtual Dispatcher get_Dispatcher();
}
internal static class MS.Internal.Ink.HighContrastHelper : object {
    private static HighContrastHelper();
    internal static void RegisterHighContrastCallback(HighContrastCallback highContrastCallback);
    internal static void OnSettingChanged();
}
[FlagsAttribute]
internal enum MS.Internal.Ink.InkCanvasClipboardDataFormats : Enum {
    public int value__;
    public static InkCanvasClipboardDataFormats None;
    public static InkCanvasClipboardDataFormats XAML;
    public static InkCanvasClipboardDataFormats ISF;
}
internal class MS.Internal.Ink.InkCanvasSelection : object {
    internal StrokeCollection SelectedStrokes { get; }
    internal ReadOnlyCollection`1<UIElement> SelectedElements { get; }
    internal bool HasSelection { get; }
    internal Rect SelectionBounds { get; }
    internal InkCanvasSelection(InkCanvas inkCanvas);
    internal StrokeCollection get_SelectedStrokes();
    internal ReadOnlyCollection`1<UIElement> get_SelectedElements();
    internal bool get_HasSelection();
    internal Rect get_SelectionBounds();
    internal void StartFeedbackAdorner(Rect feedbackRect, InkCanvasSelectionHitResult activeSelectionHitResult);
    internal void UpdateFeedbackAdorner(Rect feedbackRect);
    internal void EndFeedbackAdorner(Rect finalRectangle);
    internal void Select(StrokeCollection strokes, IList`1<UIElement> elements, bool raiseSelectionChanged);
    internal void CommitChanges(Rect finalRectangle, bool raiseEvent);
    internal void RemoveElement(UIElement removedElement);
    internal void UpdateElementBounds(UIElement element, Matrix transform);
    internal void UpdateElementBounds(UIElement originalElement, UIElement updatedElement, Matrix transform);
    internal void TransformStrokes(StrokeCollection strokes, Matrix matrix);
    internal InkCanvasSelectionHitResult HitTestSelection(Point pointOnInkCanvas);
    internal void SelectionIsDifferentThanCurrent(StrokeCollection strokes, Boolean& strokesAreDifferent, IList`1<UIElement> elements, Boolean& elementsAreDifferent);
}
internal class MS.Internal.Ink.InkCollectionBehavior : StylusEditingBehavior {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal InkCollectionBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void ResetDynamicRenderer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual Cursor GetCurrentCursor();
    [SecurityCriticalAttribute]
protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    [SecurityCriticalAttribute]
protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnTransformChanged();
}
internal class MS.Internal.Ink.ISFClipboardData : ClipboardData {
    internal StrokeCollection Strokes { get; }
    internal ISFClipboardData(StrokeCollection strokes);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    [SecurityCriticalAttribute]
protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
    internal StrokeCollection get_Strokes();
}
internal interface MS.Internal.Ink.IStylusEditing {
    public abstract virtual void AddStylusPoints(StylusPointCollection stylusPoints, bool userInitiated);
}
internal class MS.Internal.Ink.LassoHelper : object {
    public static double MinDistanceSquared;
    public Visual Visual { get; }
    private static LassoHelper();
    public Visual get_Visual();
    public Point[] AddPoints(List`1<Point> points);
    public bool ArePointsInLasso(Point[] points, int percentIntersect);
}
internal class MS.Internal.Ink.LassoSelectionBehavior : StylusEditingBehavior {
    internal LassoSelectionBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnCommitWithoutStylusInput(bool commit);
    protected virtual Cursor GetCurrentCursor();
}
internal static class MS.Internal.Ink.PenCursorManager : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Cursor GetPenCursor(DrawingAttributes drawingAttributes, bool isHollow, bool isRightToLeft, double dpiScaleX, double dpiScaleY);
    internal static Cursor GetPointEraserCursor(StylusShape stylusShape, Matrix tranform, double dpiScaleX, double dpiScaleY);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Cursor GetStrokeEraserCursor();
    internal static Cursor GetSelectionCursor(InkCanvasSelectionHitResult hitResult, bool isRightToLeft);
}
internal class MS.Internal.Ink.SelectionEditingBehavior : EditingBehavior {
    internal SelectionEditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual void OnCommit(bool commit);
    protected virtual Cursor GetCurrentCursor();
}
internal class MS.Internal.Ink.SelectionEditor : EditingBehavior {
    internal SelectionEditor(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void OnInkCanvasSelectionChanged();
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual void OnCommit(bool commit);
    protected virtual Cursor GetCurrentCursor();
}
internal class MS.Internal.Ink.StrokeCollectionDefaultValueFactory : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal abstract class MS.Internal.Ink.StylusEditingBehavior : EditingBehavior {
    internal StylusEditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void SwitchToMode(InkCanvasEditingMode mode);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.Ink.IStylusEditing.AddStylusPoints(StylusPointCollection stylusPoints, bool userInitiated);
    protected abstract virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected sealed virtual void OnCommit(bool commit);
    [SecurityCriticalAttribute]
protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    [SecurityCriticalAttribute]
protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnCommitWithoutStylusInput(bool commit);
}
internal class MS.Internal.Ink.TextClipboardData : ElementsClipboardData {
    internal TextClipboardData(string text);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
}
internal class MS.Internal.Ink.XamlClipboardData : ElementsClipboardData {
    internal XamlClipboardData(UIElement[] elements);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    [SecurityCriticalAttribute]
protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
}
internal enum MS.Internal.Interop.CHUNK_BREAKTYPE : Enum {
    public int value__;
    public static CHUNK_BREAKTYPE CHUNK_NO_BREAK;
    public static CHUNK_BREAKTYPE CHUNK_EOW;
    public static CHUNK_BREAKTYPE CHUNK_EOS;
    public static CHUNK_BREAKTYPE CHUNK_EOP;
    public static CHUNK_BREAKTYPE CHUNK_EOC;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.CHUNKSTATE : Enum {
    public int value__;
    public static CHUNKSTATE CHUNK_TEXT;
    public static CHUNKSTATE CHUNK_VALUE;
    public static CHUNKSTATE CHUNK_FILTER_OWNED_VALUE;
}
internal enum MS.Internal.Interop.FilterErrorCode : Enum {
    public int value__;
    public static FilterErrorCode FILTER_E_END_OF_CHUNKS;
    public static FilterErrorCode FILTER_E_NO_MORE_TEXT;
    public static FilterErrorCode FILTER_E_NO_MORE_VALUES;
    public static FilterErrorCode FILTER_E_ACCESS;
    public static FilterErrorCode FILTER_W_MONIKER_CLIPPED;
    public static FilterErrorCode FILTER_E_NO_TEXT;
    public static FilterErrorCode FILTER_E_NO_VALUES;
    public static FilterErrorCode FILTER_E_EMBEDDING_UNAVAILABLE;
    public static FilterErrorCode FILTER_E_LINK_UNAVAILABLE;
    public static FilterErrorCode FILTER_S_LAST_TEXT;
    public static FilterErrorCode FILTER_S_LAST_VALUES;
    public static FilterErrorCode FILTER_E_PASSWORD;
    public static FilterErrorCode FILTER_E_UNKNOWNFORMAT;
}
internal class MS.Internal.Interop.FILTERREGION : ValueType {
    private UInt32 idChunk;
    private UInt32 cwcStart;
    private UInt32 cwcExtent;
}
internal class MS.Internal.Interop.FULLPROPSPEC : ValueType {
    internal Guid guid;
    internal PROPSPEC property;
}
[ComVisibleAttribute("True")]
[GuidAttribute("89BCB740-6119-101A-BCB7-00DD010655AF")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IFilter {
    public abstract virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public abstract virtual STAT_CHUNK GetChunk();
    public abstract virtual void GetText(UInt32& pcwcBuffer, IntPtr pBuffer);
    public abstract virtual IntPtr GetValue();
    public abstract virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
}
[FlagsAttribute]
internal enum MS.Internal.Interop.IFILTER_FLAGS : Enum {
    public int value__;
    public static IFILTER_FLAGS IFILTER_FLAGS_NONE;
    public static IFILTER_FLAGS IFILTER_FLAGS_OLE_PROPERTIES;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.IFILTER_INIT : Enum {
    public int value__;
    public static IFILTER_INIT IFILTER_INIT_CANON_PARAGRAPHS;
    public static IFILTER_INIT IFILTER_INIT_HARD_LINE_BREAKS;
    public static IFILTER_INIT IFILTER_INIT_CANON_HYPHENS;
    public static IFILTER_INIT IFILTER_INIT_CANON_SPACES;
    public static IFILTER_INIT IFILTER_INIT_APPLY_INDEX_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_APPLY_OTHER_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_INDEXING_ONLY;
    public static IFILTER_INIT IFILTER_INIT_SEARCH_LINKS;
    public static IFILTER_INIT IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_FILTER_OWNED_VALUE_OK;
}
internal abstract class MS.Internal.Interop.InternalDispatchObject`1 : object {
    private Type System.Reflection.IReflect.UnderlyingSystemType { get; }
    private sealed virtual override FieldInfo System.Reflection.IReflect.GetField(string name, BindingFlags bindingAttr);
    private sealed virtual override FieldInfo[] System.Reflection.IReflect.GetFields(BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMember(string name, BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMembers(BindingFlags bindingAttr);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override MethodInfo[] System.Reflection.IReflect.GetMethods(BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo[] System.Reflection.IReflect.GetProperties(BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr);
    private sealed virtual override object System.Reflection.IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    private sealed virtual override Type System.Reflection.IReflect.get_UnderlyingSystemType();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual int GetCurFile(String& ppszFileName);
}
[ComVisibleAttribute("True")]
[GuidAttribute("00000109-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistStream {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pstm);
    public abstract virtual void Save(IStream pstm, bool fRemember);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
}
[ComVisibleAttribute("True")]
[GuidAttribute("00000109-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistStreamWithArrays {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pstm);
    public abstract virtual void Save(IStream pstm, bool fRemember);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
}
[ComVisibleAttribute("True")]
[GuidAttribute("0000000C-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IStream {
    public abstract virtual void Read(IntPtr bufferBase, int sizeInBytes, IntPtr refToNumBytesRead);
    public abstract virtual void Write(IntPtr bufferBase, int sizeInBytes, IntPtr refToNumBytesWritten);
    public abstract virtual void Seek(long offset, int origin, IntPtr refToNewOffsetNullAllowed);
    public abstract virtual void SetSize(long newSize);
    public abstract virtual void CopyTo(IStream targetStream, long bytesToCopy, IntPtr refToNumBytesRead, IntPtr refToNumBytesWritten);
    public abstract virtual void Commit(int commitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long offset, long sizeInBytes, int lockType);
    public abstract virtual void UnlockRegion(long offset, long sizeInBytes, int lockType);
    public abstract virtual void Stat(STATSTG& statStructure, int statFlag);
    public abstract virtual void Clone(IStream& newStream);
}
internal enum MS.Internal.Interop.PID_STG : Enum {
    public int value__;
    public static PID_STG DIRECTORY;
    public static PID_STG CLASSID;
    public static PID_STG STORAGETYPE;
    public static PID_STG VOLUME_ID;
    public static PID_STG PARENT_WORKID;
    public static PID_STG SECONDARYSTORE;
    public static PID_STG FILEINDEX;
    public static PID_STG LASTCHANGEUSN;
    public static PID_STG NAME;
    public static PID_STG PATH;
    public static PID_STG SIZE;
    public static PID_STG ATTRIBUTES;
    public static PID_STG WRITETIME;
    public static PID_STG CREATETIME;
    public static PID_STG ACCESSTIME;
    public static PID_STG CHANGETIME;
    public static PID_STG ALLOCSIZE;
    public static PID_STG CONTENTS;
    public static PID_STG SHORTNAME;
}
internal class MS.Internal.Interop.STAT_CHUNK : ValueType {
    internal UInt32 idChunk;
    internal CHUNK_BREAKTYPE breakType;
    internal CHUNKSTATE flags;
    internal UInt32 locale;
    internal FULLPROPSPEC attribute;
    internal UInt32 idChunkSource;
    internal UInt32 cwcStartSource;
    internal UInt32 cwcLenSource;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.STGM_FLAGS : Enum {
    public int value__;
    public static STGM_FLAGS CREATE;
    public static STGM_FLAGS MODE;
    public static STGM_FLAGS READ;
    public static STGM_FLAGS WRITE;
    public static STGM_FLAGS READWRITE;
    public static STGM_FLAGS ACCESS;
    public static STGM_FLAGS SHARE_DENY_NONE;
    public static STGM_FLAGS SHARE_DENY_READ;
    public static STGM_FLAGS SHARE_DENY_WRITE;
    public static STGM_FLAGS SHARE_EXCLUSIVE;
    public static STGM_FLAGS SHARING;
}
internal class MS.Internal.IO.Packaging.ByteStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [SecurityCriticalAttribute]
internal ByteStream(object underlyingStream, FileAccess openAccess);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual long get_Length();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual long get_Position();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void set_Position(long value);
    public virtual void Flush();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
    internal void CheckDisposedStatus();
}
internal class MS.Internal.IO.Packaging.ContentDescriptor : object {
    internal static string ResourceKeyName;
    internal static string ResourceName;
    internal bool HasIndexableContent { get; internal set; }
    internal bool IsInline { get; internal set; }
    internal string ContentProp { get; internal set; }
    internal string TitleProp { get; internal set; }
    internal ContentDescriptor(bool hasIndexableContent, bool isInline, string contentProp, string titleProp);
    internal ContentDescriptor(bool hasIndexableContent);
    internal bool get_HasIndexableContent();
    internal void set_HasIndexableContent(bool value);
    internal bool get_IsInline();
    internal void set_IsInline(bool value);
    internal string get_ContentProp();
    internal void set_ContentProp(string value);
    internal string get_TitleProp();
    internal void set_TitleProp(string value);
}
internal class MS.Internal.IO.Packaging.CorePropertiesFilter : object {
    internal CorePropertiesFilter(PackageProperties coreProperties);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public sealed virtual ManagedChunk GetChunk();
    public sealed virtual string GetText(int bufferCharacterCount);
    public sealed virtual object GetValue();
}
internal class MS.Internal.IO.Packaging.CorePropertyEnumerator : object {
    internal Guid CurrentGuid { get; }
    internal UInt32 CurrentPropId { get; }
    internal object CurrentValue { get; }
    internal CorePropertyEnumerator(PackageProperties coreProperties, IFILTER_INIT grfFlags, ManagedFullPropSpec[] attributes);
    internal bool MoveNext();
    internal Guid get_CurrentGuid();
    internal UInt32 get_CurrentPropId();
    internal object get_CurrentValue();
}
internal class MS.Internal.IO.Packaging.ElementTableKey : object {
    public static string XamlNamespace;
    public static string FixedMarkupNamespace;
    internal string XmlNamespace { get; }
    internal string BaseName { get; }
    internal ElementTableKey(string xmlNamespace, string baseName);
    private static ElementTableKey();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_XmlNamespace();
    internal string get_BaseName();
}
internal class MS.Internal.IO.Packaging.EncryptedPackageFilter : object {
    internal EncryptedPackageFilter(EncryptedPackageEnvelope encryptedPackage);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public sealed virtual STAT_CHUNK GetChunk();
    public sealed virtual void GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
}
internal class MS.Internal.IO.Packaging.FixedPageContentExtractor : object {
    internal bool AtEndOfPage { get; }
    internal FixedPageContentExtractor(XmlNode fixedPage);
    internal string NextGlyphContent(Boolean& inline, UInt32& lcid);
    internal bool get_AtEndOfPage();
}
internal interface MS.Internal.IO.Packaging.IManagedFilter {
    public abstract virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public abstract virtual ManagedChunk GetChunk();
    public abstract virtual string GetText(int bufferCharacterCount);
    public abstract virtual object GetValue();
}
internal class MS.Internal.IO.Packaging.IndexingContentUnit : ManagedChunk {
    internal string Text { get; }
    internal IndexingContentUnit(string contents, UInt32 chunkID, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid);
    internal void InitIndexingContentUnit(string contents, UInt32 chunkID, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid);
    internal string get_Text();
}
internal class MS.Internal.IO.Packaging.IndexingFilterMarshaler : object {
    internal static Guid PSGUID_STORAGE;
    internal static int _int16Size;
    internal bool ThrowOnEndOfChunks { get; internal set; }
    internal IndexingFilterMarshaler(IManagedFilter managedFilter);
    private static IndexingFilterMarshaler();
    internal static ManagedFullPropSpec[] MarshalFullPropSpecArray(UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    [SecurityCriticalAttribute]
internal static void MarshalStringToPtr(string s, UInt32& bufCharacterCount, IntPtr p);
    [SecurityCriticalAttribute]
internal static void MarshalPropSpec(ManagedPropSpec propSpec, PROPSPEC& native);
    [SecurityCriticalAttribute]
internal static void MarshalFullPropSpec(ManagedFullPropSpec fullPropSpec, FULLPROPSPEC& native);
    [SecurityCriticalAttribute]
internal static STAT_CHUNK MarshalChunk(ManagedChunk chunk);
    [SecurityCriticalAttribute]
internal static IntPtr MarshalPropVariant(object obj);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    [SecurityCriticalAttribute]
public sealed virtual STAT_CHUNK GetChunk();
    [SecurityCriticalAttribute]
public sealed virtual void GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    [SecurityCriticalAttribute]
public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
    internal bool get_ThrowOnEndOfChunks();
    internal void set_ThrowOnEndOfChunks(bool value);
}
internal class MS.Internal.IO.Packaging.ManagedChunk : object {
    internal UInt32 ID { get; internal set; }
    internal CHUNKSTATE Flags { get; }
    internal CHUNK_BREAKTYPE BreakType { get; internal set; }
    internal UInt32 Locale { get; internal set; }
    internal UInt32 ChunkSource { get; }
    internal UInt32 StartSource { get; }
    internal UInt32 LenSource { get; }
    internal ManagedFullPropSpec Attribute { get; internal set; }
    internal ManagedChunk(UInt32 index, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid, CHUNKSTATE flags);
    internal UInt32 get_ID();
    internal void set_ID(UInt32 value);
    internal CHUNKSTATE get_Flags();
    internal CHUNK_BREAKTYPE get_BreakType();
    internal void set_BreakType(CHUNK_BREAKTYPE value);
    internal UInt32 get_Locale();
    internal void set_Locale(UInt32 value);
    internal UInt32 get_ChunkSource();
    internal UInt32 get_StartSource();
    internal UInt32 get_LenSource();
    internal ManagedFullPropSpec get_Attribute();
    internal void set_Attribute(ManagedFullPropSpec value);
}
internal class MS.Internal.IO.Packaging.ManagedFullPropSpec : object {
    internal Guid Guid { get; }
    internal ManagedPropSpec Property { get; }
    internal ManagedFullPropSpec(Guid guid, UInt32 propId);
    internal ManagedFullPropSpec(FULLPROPSPEC nativePropSpec);
    internal Guid get_Guid();
    internal ManagedPropSpec get_Property();
}
internal class MS.Internal.IO.Packaging.ManagedIStream : object {
    internal ManagedIStream(Stream ioStream);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Read(Byte[] buffer, int bufferSize, IntPtr bytesReadPtr);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Seek(long offset, int origin, IntPtr newPositionPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.SetSize(long libNewSize);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Stat(STATSTG& streamStats, int grfStatFlag);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Write(Byte[] buffer, int bufferSize, IntPtr bytesWrittenPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Clone(IStream& streamCopy);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.CopyTo(IStream targetStream, long bufferSize, IntPtr buffer, IntPtr bytesWrittenPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Commit(int flags);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.LockRegion(long offset, long byteCount, int lockType);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Revert();
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.UnlockRegion(long offset, long byteCount, int lockType);
}
internal class MS.Internal.IO.Packaging.ManagedPropSpec : object {
    internal PropSpecType PropType { get; }
    internal string PropName { get; internal set; }
    internal UInt32 PropId { get; internal set; }
    internal ManagedPropSpec(UInt32 id);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ManagedPropSpec(PROPSPEC propSpec);
    internal PropSpecType get_PropType();
    internal string get_PropName();
    internal void set_PropName(string value);
    internal UInt32 get_PropId();
    internal void set_PropId(UInt32 value);
}
internal class MS.Internal.IO.Packaging.PackageFilter : object {
    internal PackageFilter(Package package);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public sealed virtual STAT_CHUNK GetChunk();
    public sealed virtual void GetText(UInt32& bufferCharacterCount, IntPtr pBuffer);
    public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
}
[SecurityCriticalAttribute("1")]
internal class MS.Internal.IO.Packaging.UnsafeIndexingFilterStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal UnsafeIndexingFilterStream(IStream oleStream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
}
internal class MS.Internal.IO.Packaging.XamlFilter : object {
    private static XamlFilter();
    internal XamlFilter(Stream stream);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public sealed virtual ManagedChunk GetChunk();
    public sealed virtual string GetText(int bufferCharacterCount);
    public sealed virtual object GetValue();
    internal IndexingContentUnit NextContentUnit();
}
internal class MS.Internal.IO.Packaging.XmlFixedPageInfo : FixedPageInfo {
    internal int GlyphRunCount { get; }
    internal XmlFixedPageInfo(XmlNode fixedPageNode);
    internal virtual GlyphRunInfo GlyphRunAtPosition(int position);
    internal virtual int get_GlyphRunCount();
}
internal class MS.Internal.IO.Packaging.XmlGlyphRunInfo : GlyphRunInfo {
    internal Point StartPosition { get; }
    internal Point EndPosition { get; }
    internal double WidthEmFontSize { get; }
    internal double HeightEmFontSize { get; }
    internal bool GlyphsHaveSidewaysOrientation { get; }
    internal int BidiLevel { get; }
    internal UInt32 LanguageID { get; }
    internal string UnicodeString { get; }
    internal XmlGlyphRunInfo(XmlNode glyphsNode);
    internal virtual Point get_StartPosition();
    internal virtual Point get_EndPosition();
    internal virtual double get_WidthEmFontSize();
    internal virtual double get_HeightEmFontSize();
    internal virtual bool get_GlyphsHaveSidewaysOrientation();
    internal virtual int get_BidiLevel();
    internal virtual UInt32 get_LanguageID();
    internal virtual string get_UnicodeString();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0B8732A6-AF74-498c-A251-9DC86B0538B0")]
internal class MS.Internal.IO.Packaging.XpsFilter : object {
    private static XpsFilter();
    private sealed virtual override IFILTER_FLAGS MS.Internal.Interop.IFilter.Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    private sealed virtual override STAT_CHUNK MS.Internal.Interop.IFilter.GetChunk();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.Interop.IFilter.GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    private sealed virtual override IntPtr MS.Internal.Interop.IFilter.GetValue();
    private sealed virtual override IntPtr MS.Internal.Interop.IFilter.BindRegion(FILTERREGION origPos, Guid& riid);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.GetClassID(Guid& pClassID);
    private sealed virtual override int MS.Internal.Interop.IPersistFile.GetCurFile(String& ppszFileName);
    private sealed virtual override int MS.Internal.Interop.IPersistFile.IsDirty();
    private sealed virtual override void MS.Internal.Interop.IPersistFile.Load(string pszFileName, int dwMode);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.Save(string pszFileName, bool fRemember);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.SaveCompleted(string pszFileName);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.GetClassID(Guid& pClassID);
    private sealed virtual override int MS.Internal.Interop.IPersistStream.IsDirty();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.Interop.IPersistStream.Load(IStream stream);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.Save(IStream stream, bool fClearDirty);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.GetSizeMax(Int64& pcbSize);
}
internal class MS.Internal.KnownBoxes.SizeBox : object {
    internal double Width { get; internal set; }
    internal double Height { get; internal set; }
    internal SizeBox(double width, double height);
    internal SizeBox(Size size);
    internal double get_Width();
    internal void set_Width(double value);
    internal double get_Height();
    internal void set_Height(double value);
}
internal static class MS.Internal.LayoutDump : object {
    private static LayoutDump();
    internal static string DumpLayoutAndVisualTreeToString(string tagName, Visual root);
    internal static void DumpLayoutAndVisualTree(XmlTextWriter writer, string tagName, Visual root);
    internal static void DumpLayoutTreeToFile(string tagName, UIElement root, string fileName);
    internal static string DumpLayoutTreeToString(string tagName, UIElement root);
    internal static void DumpLayoutTree(XmlTextWriter writer, string tagName, UIElement root);
    internal static void AddUIElementDumpHandler(Type type, DumpCustomUIElement dumper);
    internal static void AddDocumentPageDumpHandler(Type type, DumpCustomDocumentPage dumper);
    internal static void DumpVisual(XmlTextWriter writer, Visual visual, Visual parent);
    internal static void DumpDocumentPage(XmlTextWriter writer, DocumentPage page, Visual parent);
    internal static void DumpUIElementChildren(XmlTextWriter writer, string tagName, Visual visualParent);
    internal static void DumpPoint(XmlTextWriter writer, string tagName, Point point);
    internal static void DumpSize(XmlTextWriter writer, string tagName, Size size);
    internal static void DumpRect(XmlTextWriter writer, string tagName, Rect rect);
    internal static void GetUIElementsFromVisual(Visual visual, List`1<UIElement> uiElements);
}
internal class MS.Internal.ListOfObject : object {
    private object System.Collections.Generic.IList<System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Object>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Object>.IsReadOnly { get; }
    internal ListOfObject(IList list);
    private sealed virtual override int System.Collections.Generic.IList<System.Object>.IndexOf(object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.Insert(int index, object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.RemoveAt(int index);
    private sealed virtual override object System.Collections.Generic.IList<System.Object>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.set_Item(int index, object value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Add(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Contains(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.CopyTo(Object[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Object>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Remove(object item);
    private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.Markup.StaticExtension : StaticExtension {
    public StaticExtension(string member);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal enum MS.Internal.MissingDependencyType : Enum {
    public int value__;
    public static MissingDependencyType Others;
    public static MissingDependencyType WinFX;
    public static MissingDependencyType CLR;
}
internal class MS.Internal.Navigation.BindStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream Stream { get; }
    private Assembly System.Windows.Markup.IStreamInfo.Assembly { get; }
    internal BindStream(Stream stream, long maxBytes, Uri uri, IContentContainer cc, Dispatcher callbackDispatcher);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    [SecurityCriticalAttribute]
public virtual ObjRef CreateObjRef(Type requestedType);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool Equals(object obj);
    public virtual void Flush();
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public Stream get_Stream();
    private sealed virtual override Assembly System.Windows.Markup.IStreamInfo.get_Assembly();
}
internal static class MS.Internal.NetfxVersionHelper : object {
    internal static string FrameworkRegKey { get; }
    internal static string FrameworkRegKeyFullPath { get; }
    private static NetfxVersionHelper();
    [SecuritySafeCriticalAttribute]
internal static int GetNetFXReleaseVersion();
    internal static string GetTargetFrameworkVersion();
    internal static string get_FrameworkRegKey();
    internal static string get_FrameworkRegKeyFullPath();
}
internal class MS.Internal.Permissions.UserInitiatedNavigationPermission : InternalParameterlessPermissionBase {
    public UserInitiatedNavigationPermission(PermissionState state);
    public virtual IPermission Copy();
}
internal class MS.Internal.PrePostDescendentsWalker`1 : DescendentsWalker`1<T> {
    public PrePostDescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> preCallback, VisitedCallback`1<T> postCallback, T data);
    public virtual void StartWalk(DependencyObject startNode, bool skipStartNode);
    protected virtual void _VisitNode(DependencyObject d, bool visitedViaVisualTree);
}
internal static class MS.Internal.PresentationFramework.AnimatedTypeHelpers : object {
    internal static Thickness InterpolateThickness(Thickness from, Thickness to, double progress);
    internal static Thickness AddThickness(Thickness value1, Thickness value2);
    internal static Thickness SubtractThickness(Thickness value1, Thickness value2);
    internal static double GetSegmentLengthThickness(Thickness from, Thickness to);
    internal static Thickness ScaleThickness(Thickness value, double factor);
    internal static bool IsValidAnimationValueThickness(Thickness value);
    internal static Thickness GetZeroValueThickness(Thickness baseValue);
}
internal static class MS.Internal.PresentationFramework.BuildInfo : object {
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_VERSION;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
[ConditionalAttribute("COMMONDPS")]
internal class MS.Internal.PresentationFramework.CommonDependencyPropertyAttribute : Attribute {
}
internal static class MS.Internal.PresentationFramework.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.PresentationFramework.FriendAccessAllowedAttribute : Attribute {
}
internal enum MS.Internal.PresentationFramework.Interop.OperatingSystemVersion : Enum {
    public int value__;
    public static OperatingSystemVersion WindowsXPSP2;
    public static OperatingSystemVersion WindowsXPSP3;
    public static OperatingSystemVersion WindowsVista;
    public static OperatingSystemVersion WindowsVistaSP1;
    public static OperatingSystemVersion WindowsVistaSP2;
    public static OperatingSystemVersion Windows7;
    public static OperatingSystemVersion Windows7SP1;
    public static OperatingSystemVersion Windows8;
    public static OperatingSystemVersion Windows8Point1;
    public static OperatingSystemVersion Windows10;
    public static OperatingSystemVersion Windows10TH2;
    public static OperatingSystemVersion Windows10RS1;
    public static OperatingSystemVersion Windows10RS2;
    public static OperatingSystemVersion Windows10RS3;
}
internal static class MS.Internal.PresentationFramework.Interop.OSVersionHelper : object {
    internal static bool IsOsWindows10RS3OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS2OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS1OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH2OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH1OrGreater { get; internal set; }
    internal static bool IsOsWindows10OrGreater { get; internal set; }
    internal static bool IsOsWindows8Point1OrGreater { get; internal set; }
    internal static bool IsOsWindows8OrGreater { get; internal set; }
    internal static bool IsOsWindows7SP1OrGreater { get; internal set; }
    internal static bool IsOsWindows7OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaOrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP3OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPOrGreater { get; internal set; }
    internal static bool IsOsWindowsServer { get; internal set; }
    [SecurityCriticalAttribute]
private static OSVersionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8Point1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8Point1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7SP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7SP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsServer();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsServer(bool value);
    internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer);
    internal static OperatingSystemVersion GetOsVersion();
}
[SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute("1")]
internal static class MS.Internal.PresentationFramework.PresentationNativeLoader : object {
    internal static void EnsureLoaded();
}
internal static class MS.Internal.PresentationFramework.SafeSecurityHelper : object {
    internal static string IMAGE;
    internal static string GetAssemblyPartialName(Assembly assembly);
    internal static string GetFullAssemblyNameFromPartialName(Assembly protoAssembly, string partialName);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Point ClientToScreen(UIElement relativeTo, Point point);
    internal static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsFeatureDisabled(KeyToRead key);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsConnectedToPresentationSource(Visual visual);
}
internal static class MS.Internal.PresentationFramework.SecurityHelper : object {
    internal static WebBrowserPermission CachedWebBrowserPermission { get; }
    private static SecurityHelper();
    [SecuritySafeCriticalAttribute]
internal static bool CheckUnmanagedCodePermission();
    [SecurityCriticalAttribute]
internal static void DemandUnmanagedCode();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ThrowExceptionIfSettingTrueInPartialTrust(Boolean& value);
    [SecurityCriticalAttribute]
internal static void DemandWebBrowserPermission();
    [SecurityCriticalAttribute]
internal static WebBrowserPermission get_CachedWebBrowserPermission();
    [SecuritySafeCriticalAttribute]
internal static bool CallerAndAppDomainHaveUnrestrictedWebBrowserPermission();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasUserInitiatedNavigationPermission();
    [SecurityCriticalAttribute]
internal static CodeAccessPermission CreateUserInitiatedNavigationPermission();
    [SecurityCriticalAttribute]
internal static void DemandPrintDialogPermissions();
    [SecuritySafeCriticalAttribute]
internal static bool CallerHasMemberAccessReflectionPermission();
    [SecuritySafeCriticalAttribute]
internal static Exception GetExceptionForHR(int hr);
    [SecurityCriticalAttribute]
internal static void DemandUIWindowPermission();
    [SecurityCriticalAttribute]
internal static void DemandUnrestrictedUIPermission();
    [SecurityCriticalAttribute]
internal static void DemandUnrestrictedFileIOPermission();
    [SecurityCriticalAttribute]
internal static void DemandFileDialogOpenPermission();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ShowMessageBoxHelper(Window parent, string text, string title, MessageBoxButton buttons, MessageBoxImage image);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void ShowMessageBoxHelper(IntPtr parentHwnd, string text, string title, MessageBoxButton buttons, MessageBoxImage image);
    [SecurityCriticalAttribute]
internal static void DemandPlugInSerializerPermissions();
    internal static bool AreStringTypesEqual(string m1, string m2);
}
internal static class MS.Internal.Printing.NativeMethods : object {
    internal static UInt32 PD_ALLPAGES;
    internal static UInt32 PD_SELECTION;
    internal static UInt32 PD_PAGENUMS;
    internal static UInt32 PD_NOSELECTION;
    internal static UInt32 PD_NOPAGENUMS;
    internal static UInt32 PD_USEDEVMODECOPIESANDCOLLATE;
    internal static UInt32 PD_DISABLEPRINTTOFILE;
    internal static UInt32 PD_HIDEPRINTTOFILE;
    internal static UInt32 PD_CURRENTPAGE;
    internal static UInt32 PD_NOCURRENTPAGE;
    internal static UInt32 PD_RESULT_CANCEL;
    internal static UInt32 PD_RESULT_PRINT;
    internal static UInt32 PD_RESULT_APPLY;
    internal static UInt32 START_PAGE_GENERAL;
}
internal static class MS.Internal.Printing.UnsafeNativeMethods : object {
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int PrintDlgEx(IntPtr pdex);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr GlobalFree(IntPtr hMem);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr GlobalLock(IntPtr hMem);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool GlobalUnlock(IntPtr hMem);
}
internal class MS.Internal.Printing.Win32PrintDialog : object {
    internal PrintTicket PrintTicket { get; internal set; }
    internal PrintQueue PrintQueue { get; internal set; }
    internal UInt32 MinPage { get; internal set; }
    internal UInt32 MaxPage { get; internal set; }
    internal PageRangeSelection PageRangeSelection { get; internal set; }
    internal PageRange PageRange { get; internal set; }
    internal bool PageRangeEnabled { get; internal set; }
    internal bool SelectedPagesEnabled { get; internal set; }
    internal bool CurrentPageEnabled { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal UInt32 ShowDialog();
    [SecurityCriticalAttribute]
internal PrintTicket get_PrintTicket();
    [SecurityCriticalAttribute]
internal void set_PrintTicket(PrintTicket value);
    [SecurityCriticalAttribute]
internal PrintQueue get_PrintQueue();
    [SecurityCriticalAttribute]
internal void set_PrintQueue(PrintQueue value);
    internal UInt32 get_MinPage();
    internal void set_MinPage(UInt32 value);
    internal UInt32 get_MaxPage();
    internal void set_MaxPage(UInt32 value);
    internal PageRangeSelection get_PageRangeSelection();
    internal void set_PageRangeSelection(PageRangeSelection value);
    internal PageRange get_PageRange();
    internal void set_PageRange(PageRange value);
    internal bool get_PageRangeEnabled();
    internal void set_PageRangeEnabled(bool value);
    internal bool get_SelectedPagesEnabled();
    internal void set_SelectedPagesEnabled(bool value);
    internal bool get_CurrentPageEnabled();
    internal void set_CurrentPageEnabled(bool value);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("e7b92912-c7ca-4629-8f39-0f537cfab57e")]
internal interface MS.Internal.Progressivity.IByteRangeDownloaderService {
    [SecurityCriticalAttribute]
public abstract virtual void InitializeByteRangeDownloader(string url, string tempFile, SafeWaitHandle eventHandle);
    public abstract virtual void RequestDownloadByteRanges(Int32[] byteRanges, int size);
    public abstract virtual void GetDownloadedByteRanges(Int32[]& byteRanges, Int32& size);
    public abstract virtual void ReleaseByteRangeDownloader();
}
internal class MS.Internal.PtsHost.AttachedObject : EmbeddedObject {
    internal BaseParagraph Para;
    internal DependencyObject Element { get; }
    internal AttachedObject(int dcp, BaseParagraph para);
    internal virtual void Dispose();
    internal virtual void Update(EmbeddedObject newObject);
    internal virtual DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.BackgroundFormatInfo : object {
    internal int LastCPUninterruptible { get; }
    internal DateTime BackgroundFormatStopTime { get; }
    internal int CchAllText { get; }
    internal static bool IsBackgroundFormatEnabled { get; }
    internal bool DoesFinalDTRCoverRestOfText { get; }
    internal int CPInterrupted { get; internal set; }
    internal double ViewportHeight { get; internal set; }
    internal BackgroundFormatInfo(StructuralCache structuralCache);
    private static BackgroundFormatInfo();
    internal void UpdateBackgroundFormatInfo();
    internal void ThrottleBackgroundFormatting();
    internal void BackgroundFormat(IFlowDocumentFormatter formatter, bool ignoreThrottle);
    internal int get_LastCPUninterruptible();
    internal DateTime get_BackgroundFormatStopTime();
    internal int get_CchAllText();
    internal static bool get_IsBackgroundFormatEnabled();
    internal bool get_DoesFinalDTRCoverRestOfText();
    internal int get_CPInterrupted();
    internal void set_CPInterrupted(int value);
    internal double get_ViewportHeight();
    internal void set_ViewportHeight(double value);
}
internal abstract class MS.Internal.PtsHost.BaseParaClient : UnmanagedHandle {
    protected BaseParagraph _paragraph;
    protected SecurityCriticalDataForSet`1<IntPtr> _paraHandle;
    protected FSRECT _rect;
    protected int _dvrTopSpace;
    protected ParagraphVisual _visual;
    protected PageContext _pageContext;
    protected FlowDirection _flowDirectionParent;
    protected FlowDirection _flowDirection;
    internal ParagraphVisual Visual { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal BaseParagraph Paragraph { get; }
    internal FSRECT Rect { get; }
    internal FlowDirection ThisFlowDirection { get; }
    internal FlowDirection ParentFlowDirection { get; }
    internal FlowDirection PageFlowDirection { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected BaseParaClient(BaseParagraph paragraph);
    [SecurityCriticalAttribute]
internal void Arrange(IntPtr pfspara, FSRECT rcPara, int dvrTopSpace, UInt32 fswdirParent);
    internal virtual int GetFirstTextLineBaseline();
    internal void TransferDisplayInfo(BaseParaClient oldParaClient);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void GetRectanglesForParagraphElement(List`1& rectangles);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal abstract virtual ParagraphResult CreateParagraphResult();
    internal abstract virtual TextContentRange GetTextContentRange();
    internal virtual ParagraphVisual get_Visual();
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    internal BaseParagraph get_Paragraph();
    internal FSRECT get_Rect();
    internal FlowDirection get_ThisFlowDirection();
    internal FlowDirection get_ParentFlowDirection();
    internal FlowDirection get_PageFlowDirection();
    protected virtual void OnArrange();
}
internal abstract class MS.Internal.PtsHost.BaseParagraph : UnmanagedHandle {
    protected FSKCHANGE _changeType;
    protected bool _stopAsking;
    protected int _lastFormatCch;
    internal BaseParagraph Next;
    internal BaseParagraph Previous;
    protected StructuralCache _structuralCache;
    protected DependencyObject _element;
    internal int ParagraphStartCharacterPosition { get; }
    internal int ParagraphEndCharacterPosition { get; }
    internal int Cch { get; }
    internal int LastFormatCch { get; }
    internal StructuralCache StructuralCache { get; }
    internal DependencyObject Element { get; }
    protected BaseParagraph(DependencyObject element, StructuralCache structuralCache);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal abstract virtual void GetParaProperties(FSPAP& fspap);
    internal abstract virtual void CreateParaclient(IntPtr& pfsparaclient);
    internal virtual void SetUpdateInfo(FSKCHANGE fskch, bool stopAsking);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateLastFormatPositions();
    protected void GetParaProperties(FSPAP& fspap, bool ignoreElementProps);
    internal int get_ParagraphStartCharacterPosition();
    internal int get_ParagraphEndCharacterPosition();
    internal int get_Cch();
    internal int get_LastFormatCch();
    internal StructuralCache get_StructuralCache();
    internal DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.BreakRecordTable : object {
    internal int Count { get; }
    internal bool IsClean { get; }
    internal BreakRecordTable(FlowDocumentPaginator owner);
    internal PageBreakRecord GetPageBreakRecord(int pageNumber);
    internal FlowDocumentPage GetCachedDocumentPage(int pageNumber);
    internal bool GetPageNumberForContentPosition(TextPointer contentPosition, Int32& pageNumber);
    internal void OnInvalidateLayout();
    internal void OnInvalidateLayout(ITextPointer start, ITextPointer end);
    internal void OnInvalidateRender();
    internal void OnInvalidateRender(ITextPointer start, ITextPointer end);
    internal void UpdateEntry(int pageNumber, FlowDocumentPage page, PageBreakRecord brOut, TextPointer dependentMax);
    internal bool HasPageBreakRecord(int pageNumber);
    internal int get_Count();
    internal bool get_IsClean();
}
internal class MS.Internal.PtsHost.CellInfo : object {
    internal TableCell Cell { get; }
    internal Double[] TableColumnWidths { get; }
    internal double TableAutofitWidth { get; }
    internal Rect TableArea { get; }
    internal Rect CellArea { get; }
    internal CellInfo(TableParaClient tpc, CellParaClient cpc);
    internal void Adjust(Point ptAdjust);
    internal TableCell get_Cell();
    internal Double[] get_TableColumnWidths();
    internal double get_TableAutofitWidth();
    internal Rect get_TableArea();
    internal Rect get_CellArea();
}
internal class MS.Internal.PtsHost.CellParaClient : SubpageParaClient {
    internal TableCell Cell { get; }
    internal Table Table { get; }
    internal CellParagraph CellParagraph { get; }
    internal int ColumnIndex { get; }
    unknown double ArrangeHeight {internal set; }
    internal TableParaClient TableParaClient { get; }
    internal CellParaClient(CellParagraph cellParagraph, TableParaClient tableParaClient);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Arrange(int du, int dv, FSRECT rcTable, FlowDirection tableFlowDirection, PageContext pageContext);
    internal void ValidateVisual();
    [SecurityCriticalAttribute]
internal void FormatCellFinite(Size subpageSize, IntPtr breakRecordIn, bool isEmptyOk, UInt32 fswdir, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, Int32& dvrUsed, IntPtr& breakRecordOut);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void FormatCellBottomless(UInt32 fswdir, double width, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateBottomlessCell(UInt32 fswdir, double width, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal double CalculateCellWidth(TableParaClient tableParaClient);
    internal TableCell get_Cell();
    internal Table get_Table();
    internal CellParagraph get_CellParagraph();
    internal int get_ColumnIndex();
    internal void set_ArrangeHeight(double value);
    internal TableParaClient get_TableParaClient();
}
internal class MS.Internal.PtsHost.CellParagraph : SubpageParagraph {
    internal TableCell Cell { get; }
    internal CellParagraph(DependencyObject element, StructuralCache structuralCache);
    internal TableCell get_Cell();
    [SecurityCriticalAttribute]
internal void FormatCellFinite(TableParaClient tableParaClient, IntPtr pfsbrkcellIn, IntPtr pfsFtnRejector, int fEmptyOK, UInt32 fswdirTable, int dvrAvailable, FSFMTR& pfmtr, IntPtr& ppfscell, IntPtr& pfsbrkcellOut, Int32& dvrUsed);
    internal void FormatCellBottomless(TableParaClient tableParaClient, UInt32 fswdirTable, FSFMTRBL& fmtrbl, IntPtr& ppfscell, Int32& dvrUsed);
    internal void UpdateBottomlessCell(CellParaClient cellParaClient, TableParaClient tableParaClient, UInt32 fswdirTable, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal void SetCellHeight(CellParaClient cellParaClient, TableParaClient tableParaClient, IntPtr subpageBreakRecord, int fBrokenHere, UInt32 fswdirTable, int dvrActual);
    internal void UpdGetCellChange(Int32& fWidthChanged, FSKCHANGE& fskchCell);
}
internal class MS.Internal.PtsHost.ColumnPropertiesGroup : object {
    internal double ColumnWidth { get; }
    internal bool IsColumnWidthFlexible { get; }
    internal ColumnSpaceDistribution ColumnSpaceDistribution { get; }
    internal double ColumnGap { get; }
    internal Brush ColumnRuleBrush { get; }
    internal double ColumnRuleWidth { get; }
    internal bool ColumnWidthAuto { get; }
    internal bool ColumnGapAuto { get; }
    internal ColumnPropertiesGroup(DependencyObject o);
    internal double get_ColumnWidth();
    internal bool get_IsColumnWidthFlexible();
    internal ColumnSpaceDistribution get_ColumnSpaceDistribution();
    internal double get_ColumnGap();
    internal Brush get_ColumnRuleBrush();
    internal double get_ColumnRuleWidth();
    internal bool get_ColumnWidthAuto();
    internal bool get_ColumnGapAuto();
}
internal class MS.Internal.PtsHost.ContainerParaClient : BaseParaClient {
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal ContainerParaClient(ContainerParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    internal void SetChunkInfo(bool isFirstChunk, bool isLastChunk);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual int GetFirstTextLineBaseline();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
}
internal class MS.Internal.PtsHost.ContainerParagraph : BaseParagraph {
    internal ContainerParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    private sealed virtual override void MS.Internal.PtsHost.ISegment.GetFirstPara(Int32& fSuccessful, IntPtr& firstParaName);
    private sealed virtual override void MS.Internal.PtsHost.ISegment.GetNextPara(BaseParagraph prevParagraph, Int32& fFound, IntPtr& nextParaName);
    private sealed virtual override void MS.Internal.PtsHost.ISegment.UpdGetFirstChangeInSegment(Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
    internal void UpdGetSegmentChange(FSKCHANGE& fskch);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    [SecurityCriticalAttribute]
internal void FormatParaFinite(ContainerParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, int iArea, IntPtr footnoteRejector, IntPtr geometry, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, MarginCollapsingState mcs, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecOut, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace);
    [SecurityCriticalAttribute]
internal void FormatParaBottomless(ContainerParaClient paraClient, int iArea, IntPtr geometry, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    [SecurityCriticalAttribute]
internal void UpdateBottomlessPara(IntPtr pfspara, ContainerParaClient paraClient, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    protected virtual BaseParagraph GetParagraph(ITextPointer textPointer, bool fEmptyOk);
}
internal class MS.Internal.PtsHost.DirtyTextRange : ValueType {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionsAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionsRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromHighlightLayer>k__BackingField;
    internal int StartIndex { get; internal set; }
    internal int PositionsAdded { get; internal set; }
    internal int PositionsRemoved { get; internal set; }
    internal bool FromHighlightLayer { get; internal set; }
    internal DirtyTextRange(int startIndex, int positionsAdded, int positionsRemoved, bool fromHighlightLayer);
    internal DirtyTextRange(TextContainerChangeEventArgs change);
    [CompilerGeneratedAttribute]
internal int get_StartIndex();
    [CompilerGeneratedAttribute]
internal void set_StartIndex(int value);
    [CompilerGeneratedAttribute]
internal int get_PositionsAdded();
    [CompilerGeneratedAttribute]
internal void set_PositionsAdded(int value);
    [CompilerGeneratedAttribute]
internal int get_PositionsRemoved();
    [CompilerGeneratedAttribute]
internal void set_PositionsRemoved(int value);
    [CompilerGeneratedAttribute]
internal bool get_FromHighlightLayer();
    [CompilerGeneratedAttribute]
internal void set_FromHighlightLayer(bool value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PtsHost.DtrList : object {
    internal int Length { get; }
    internal DirtyTextRange Item { get; }
    internal void Merge(DirtyTextRange dtr);
    internal DirtyTextRange GetMergedRange();
    internal DtrList DtrsFromRange(int dcpNew, int cchOld);
    internal int get_Length();
    internal DirtyTextRange get_Item(int index);
}
internal abstract class MS.Internal.PtsHost.EmbeddedObject : object {
    internal int Dcp;
    internal DependencyObject Element { get; }
    protected EmbeddedObject(int dcp);
    internal virtual void Dispose();
    internal abstract virtual void Update(EmbeddedObject newObject);
    internal abstract virtual DependencyObject get_Element();
}
internal static class MS.Internal.PtsHost.ErrorHandler : object {
    internal static string PtsCacheAlreadyCreated;
    internal static string PtsCacheAlreadyDestroyed;
    internal static string NullPtsHost;
    internal static string CreateContextFailed;
    internal static string EnumIntegrationError;
    internal static string NoNeedToDestroyPtsPage;
    internal static string NotSupportedFiniteIncremental;
    internal static string NotSupportedFootnotes;
    internal static string NotSupportedCompositeColumns;
    internal static string NotSupportedDropCap;
    internal static string NotSupportedForcedLineBreaks;
    internal static string NotSupportedMultiSection;
    internal static string NotSupportedSubtrackShift;
    internal static string NullObjectInCreateHandle;
    internal static string InvalidHandle;
    internal static string HandleOutOfRange;
    internal static string BreakRecordDisposed;
    internal static string BreakRecordNotNeeded;
    internal static string BrokenParaHasMcs;
    internal static string BrokenParaHasTopSpace;
    internal static string GoalReachedHasBreakRecord;
    internal static string BrokenContentRequiresBreakRecord;
    internal static string PTSAssert;
    internal static string ParaHandleMismatch;
    internal static string PTSObjectsCountMismatch;
    internal static string SubmitForEmptyRange;
    internal static string SubmitInvalidList;
    internal static string HandledInsideSegmentPara;
    internal static string EmptyParagraph;
    internal static string ParaStartsWithEOP;
    internal static string FetchParaAtTextRangePosition;
    internal static string ParagraphCharacterCountMismatch;
    internal static string ContainerNeedsTextElement;
    internal static string CannotPositionInsideUIElement;
    internal static string CannotFindUIElement;
    internal static string InvalidDocumentPage;
    internal static string NoVisualToTransfer;
    internal static string UpdateShiftedNotValid;
    internal static string ColumnVisualCountMismatch;
    internal static string VisualTypeMismatch;
    internal static string EmbeddedObjectTypeMismatch;
    internal static string EmbeddedObjectOwnerMismatch;
    internal static string LineAlreadyDestroyed;
    internal static string OnlyOneRectIsExpected;
    internal static string NotInLineBoundary;
    internal static string FetchRunAtTextArrayStart;
    internal static string TextFormatterHostNotInitialized;
    internal static string NegativeCharacterIndex;
    internal static string NoClientDataForObjectRun;
    internal static string UnknownDOTypeInTextArray;
    internal static string NegativeObjectWidth;
    internal static string NoUIElementForObjectPosition;
    internal static string InlineObjectCacheCorrupted;
    private static ErrorHandler();
    internal static void Assert(bool condition, string message);
    internal static void Assert(bool condition, string format, Object[] args);
}
internal static class MS.Internal.PtsHost.FigureHelper : object {
    internal static bool IsVerticalPageAnchor(FigureVerticalAnchor verticalAnchor);
    internal static bool IsVerticalContentAnchor(FigureVerticalAnchor verticalAnchor);
    internal static bool IsHorizontalPageAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static bool IsHorizontalContentAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static bool IsHorizontalColumnAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static double CalculateFigureWidth(StructuralCache structuralCache, Figure figure, FigureLength figureLength, Boolean& isWidthAuto);
    internal static double CalculateFigureHeight(StructuralCache structuralCache, Figure figure, FigureLength figureLength, Boolean& isHeightAuto);
    internal static double CalculateFigureCommon(FigureLength figureLength);
    internal static void GetColumnMetrics(StructuralCache structuralCache, Int32& cColumns, Double& width, Double& gap, Double& rule);
}
internal class MS.Internal.PtsHost.FigureObject : AttachedObject {
    internal FigureObject(int dcp, FigureParagraph para);
}
internal class MS.Internal.PtsHost.FigureParaClient : BaseParaClient {
    internal IntPtr SubpageHandle { get; internal set; }
    internal FSRECT ContentRect { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FigureParaClient(FigureParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    internal void ArrangeFigure(FSRECT rcFigure, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal IntPtr get_SubpageHandle();
    [SecurityCriticalAttribute]
internal void set_SubpageHandle(IntPtr value);
    internal FSRECT get_ContentRect();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
}
internal class MS.Internal.PtsHost.FigureParagraph : BaseParagraph {
    internal FigureParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void GetFigureProperties(FigureParaClient paraClient, int fInTextLine, UInt32 fswdir, int fBottomUndefined, Int32& dur, Int32& dvr, FSFIGUREPROPS& fsfigprops, Int32& cPolygons, Int32& cVertices, Int32& durDistTextLeft, Int32& durDistTextRight, Int32& dvrDistTextTop, Int32& dvrDistTextBottom);
    [SecurityCriticalAttribute]
internal void GetFigurePolygons(FigureParaClient paraClient, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal void CalcFigurePosition(FigureParaClient paraClient, UInt32 fswdir, FSRECT& fsrcPage, FSRECT& fsrcMargin, FSRECT& fsrcTrack, FSRECT& fsrcFigurePreliminary, int fMustPosition, int fInTextLine, Int32& fPushToNextTrack, FSRECT& fsrcFlow, FSRECT& fsrcOverlap, FSBBOX& fsbbox, FSRECT& fsrcSearch);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
}
internal abstract class MS.Internal.PtsHost.FloaterBaseParaClient : BaseParaClient {
    protected FloaterBaseParaClient(FloaterBaseParagraph paragraph);
    internal virtual void ArrangeFloater(FSRECT rcFloater, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    internal abstract virtual TextContentRange GetTextContentRange();
}
internal abstract class MS.Internal.PtsHost.FloaterBaseParagraph : BaseParagraph {
    protected FloaterBaseParagraph(TextElement element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal abstract virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal abstract virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal abstract virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    [SecurityCriticalAttribute]
internal virtual void GetFloaterPolygons(FloaterBaseParaClient paraClient, UInt32 fswdirTrack, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal abstract virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    internal virtual void GetDvrUsedForFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, int dvrDisplaced, Int32& dvrUsed);
}
internal class MS.Internal.PtsHost.FloaterObject : AttachedObject {
    internal FloaterObject(int dcp, FloaterParagraph para);
}
internal class MS.Internal.PtsHost.FloaterParaClient : FloaterBaseParaClient {
    unknown IntPtr SubpageHandle {internal set; }
    internal FSRECT ContentRect { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FloaterParaClient(FloaterParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual void ArrangeFloater(FSRECT rcFloater, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    [SecurityCriticalAttribute]
internal void set_SubpageHandle(IntPtr value);
    internal FSRECT get_ContentRect();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
}
internal class MS.Internal.PtsHost.FloaterParagraph : FloaterBaseParagraph {
    internal FloaterParagraph(TextElement element, StructuralCache structuralCache);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    public virtual void Dispose();
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    [SecurityCriticalAttribute]
internal virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
}
internal class MS.Internal.PtsHost.FloatingRun : TextHidden {
    internal bool Figure { get; }
    internal FloatingRun(int length, bool figure);
    internal bool get_Figure();
}
internal class MS.Internal.PtsHost.FlowDocumentPage : DocumentPage {
    public Visual Visual { get; }
    internal IEnumerator`1<IInputElement> HostedElementsCore { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal bool UseSizingWorkaroundForTextBox { get; internal set; }
    internal Thickness Margin { get; }
    internal bool IsDisposed { get; }
    internal Size ContentSize { get; }
    internal bool FinitePage { get; }
    internal PageContext PageContext { get; }
    internal bool IncrementalUpdate { get; }
    internal StructuralCache StructuralCache { get; }
    internal int FormattedLinesCount { get; }
    internal bool IsLayoutDataValid { get; }
    internal TextPointer DependentMax { get; internal set; }
    internal Rect Viewport { get; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal FlowDocumentPage(StructuralCache structuralCache);
    protected virtual override void Finalize();
    public virtual void Dispose();
    public virtual Visual get_Visual();
    internal void FormatBottomless(Size pageSize, Thickness pageMargin);
    internal PageBreakRecord FormatFinite(Size pageSize, Thickness pageMargin, PageBreakRecord breakRecord);
    internal void Arrange(Size partitionSize);
    internal void ForceReformat();
    internal IInputElement InputHitTestCore(Point point);
    internal ReadOnlyCollection`1<Rect> GetRectanglesCore(ContentElement child, bool isLimitedToTextView);
    internal IEnumerator`1<IInputElement> get_HostedElementsCore();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
    internal void OnChildDesiredSizeChangedCore(UIElement child);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    [SecurityCriticalAttribute]
internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    [SecurityCriticalAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal void OnFormatLine();
    internal void EnsureValidVisuals();
    internal void UpdateViewport(FSRECT& viewport, bool drawBackground);
    internal bool get_UseSizingWorkaroundForTextBox();
    internal void set_UseSizingWorkaroundForTextBox(bool value);
    internal Thickness get_Margin();
    internal bool get_IsDisposed();
    internal Size get_ContentSize();
    internal bool get_FinitePage();
    internal PageContext get_PageContext();
    internal bool get_IncrementalUpdate();
    internal StructuralCache get_StructuralCache();
    internal int get_FormattedLinesCount();
    internal bool get_IsLayoutDataValid();
    internal TextPointer get_DependentMax();
    internal void set_DependentMax(TextPointer value);
    internal Rect get_Viewport();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.PtsHost.InlineObject : EmbeddedObject {
    internal DependencyObject Element { get; }
    internal InlineObject(int dcp, UIElementIsland uiElementIsland, TextParagraph para);
    internal virtual void Dispose();
    internal virtual void Update(EmbeddedObject newObject);
    internal virtual DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.InlineObjectRun : TextEmbeddedObject {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    internal UIElementIsland UIElementIsland { get; }
    internal InlineObjectRun(int cch, UIElement element, TextRunProperties textProps, TextParagraph host);
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    internal UIElementIsland get_UIElementIsland();
}
internal interface MS.Internal.PtsHost.ISegment {
    public abstract virtual void GetFirstPara(Int32& successful, IntPtr& firstParaName);
    public abstract virtual void GetNextPara(BaseParagraph currentParagraph, Int32& found, IntPtr& nextParaName);
    public abstract virtual void UpdGetFirstChangeInSegment(Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
}
internal class MS.Internal.PtsHost.Line : LineBase {
    internal int Start { get; }
    internal int Width { get; }
    internal int Height { get; }
    internal int Baseline { get; }
    internal bool EndOfParagraph { get; }
    internal int SafeLength { get; }
    internal int ActualLength { get; }
    internal int ContentLength { get; }
    internal int DependantLength { get; }
    internal bool IsTruncated { get; }
    internal FSFLRES FormattingResult { get; }
    internal Line(TextFormatterHost host, TextParaClient paraClient, int cpPara);
    public virtual void Dispose();
    internal void GetDvrSuppressibleBottomSpace(Int32& dvrSuppressible);
    internal void GetDurFigureAnchor(FigureParagraph paraFigure, UInt32 fswdir, Int32& dur);
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal void Format(FormattingContext ctx, int dcp, int width, int trackWidth, TextParagraphProperties lineProps, TextLineBreak textLineBreak);
    internal Size MeasureChild(InlineObjectRun inlineObject);
    internal ContainerVisual CreateVisual();
    internal Rect GetBoundsFromTextPosition(int textPosition, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal TextLineBreak GetTextLineBreak();
    internal CharacterHit GetTextPositionFromDistance(int urDistance);
    internal IInputElement InputHitTest(int urOffset);
    internal int GetEllipsesLength();
    internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, int dcpStart, int dcpEnd);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal int get_Start();
    internal int get_Width();
    internal int get_Height();
    internal int get_Baseline();
    internal bool get_EndOfParagraph();
    internal int get_SafeLength();
    internal int get_ActualLength();
    internal int get_ContentLength();
    internal int get_DependantLength();
    internal bool get_IsTruncated();
    internal FSFLRES get_FormattingResult();
    internal int CalculateUOffsetShift();
}
internal abstract class MS.Internal.PtsHost.LineBase : UnmanagedHandle {
    protected BaseParaClient _paraClient;
    protected bool _hasFigures;
    protected bool _hasFloaters;
    protected static int _syntheticCharacterLength;
    protected static int _elementEdgeCharacterLength;
    internal static int SyntheticCharacterLength { get; }
    internal bool HasFigures { get; }
    internal bool HasFloaters { get; }
    internal LineBase(BaseParaClient paraClient);
    private static LineBase();
    internal abstract virtual TextRun GetTextRun(int dcp);
    internal abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    protected TextRun HandleText(StaticTextPointer position);
    protected TextRun HandleElementStartEdge(StaticTextPointer position);
    protected TextRun HandleElementEndEdge(StaticTextPointer position);
    protected TextRun HandleEmbeddedObject(int dcp, StaticTextPointer position);
    internal static int get_SyntheticCharacterLength();
    internal bool get_HasFigures();
    internal bool get_HasFloaters();
}
internal class MS.Internal.PtsHost.LineBreakpoint : UnmanagedHandle {
    internal OptimalBreakSession OptimalBreakSession { get; }
    internal LineBreakpoint(OptimalBreakSession optimalBreakSession, TextBreakpoint textBreakpoint);
    public virtual void Dispose();
    internal OptimalBreakSession get_OptimalBreakSession();
}
internal class MS.Internal.PtsHost.LineBreakRecord : UnmanagedHandle {
    internal TextLineBreak TextLineBreak { get; }
    internal LineBreakRecord(PtsContext ptsContext, TextLineBreak textLineBreak);
    public virtual void Dispose();
    internal LineBreakRecord Clone();
    internal TextLineBreak get_TextLineBreak();
}
internal class MS.Internal.PtsHost.LineBreakRun : TextEndOfLine {
    internal FSFLRES BreakReason;
    internal LineBreakRun(int length, FSFLRES breakReason);
}
internal class MS.Internal.PtsHost.LineVisual : DrawingVisual {
    internal double WidthIncludingTrailingWhitespace;
    internal DrawingContext Open();
}
internal class MS.Internal.PtsHost.ListItemParagraph : ContainerParagraph {
    internal ListItemParagraph(DependencyObject element, StructuralCache structuralCache);
}
internal class MS.Internal.PtsHost.ListMarkerLine : LineBase {
    internal ListMarkerLine(TextFormatterHost host, ListParaClient paraClient);
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal void FormatAndDrawVisual(DrawingContext ctx, LineProperties lineProps, int ur, int vrBaseline);
}
internal class MS.Internal.PtsHost.ListMarkerSourceInfo : object {
    private static ListMarkerSourceInfo();
    internal static Thickness CalculatePadding(List list, double lineHeight, double pixelsPerDip);
}
internal class MS.Internal.PtsHost.ListParaClient : ContainerParaClient {
    internal ListParaClient(ListParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
}
internal class MS.Internal.PtsHost.ListParagraph : ContainerParagraph {
    internal ListParagraph(DependencyObject element, StructuralCache structuralCache);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    protected virtual BaseParagraph GetParagraph(ITextPointer textPointer, bool fEmptyOk);
}
internal class MS.Internal.PtsHost.MarginCollapsingState : UnmanagedHandle {
    internal int Margin { get; }
    internal MarginCollapsingState(PtsContext ptsContext, int margin);
    internal static void CollapseTopMargin(PtsContext ptsContext, MbpInfo mbp, MarginCollapsingState mcsCurrent, MarginCollapsingState& mcsNew, Int32& margin);
    internal static void CollapseBottomMargin(PtsContext ptsContext, MbpInfo mbp, MarginCollapsingState mcsCurrent, MarginCollapsingState& mcsNew, Int32& margin);
    internal MarginCollapsingState Clone();
    internal bool IsEqual(MarginCollapsingState mcs);
    internal void Collapse(MarginCollapsingState mcs);
    internal int get_Margin();
}
internal class MS.Internal.PtsHost.MbpInfo : object {
    internal int MBPLeft { get; }
    internal int MBPRight { get; }
    internal int MBPTop { get; }
    internal int MBPBottom { get; }
    internal int BPLeft { get; }
    internal int BPRight { get; }
    internal int BPTop { get; }
    internal int BPBottom { get; }
    internal int BorderLeft { get; }
    internal int BorderRight { get; }
    internal int BorderTop { get; }
    internal int BorderBottom { get; }
    internal int MarginLeft { get; }
    internal int MarginRight { get; }
    internal int MarginTop { get; }
    internal int MarginBottom { get; }
    internal Thickness Margin { get; internal set; }
    internal Thickness Border { get; internal set; }
    internal Thickness Padding { get; internal set; }
    internal Brush BorderBrush { get; }
    private static MbpInfo();
    internal static MbpInfo FromElement(DependencyObject o, double pixelsPerDip);
    internal void MirrorMargin();
    internal void MirrorBP();
    internal int get_MBPLeft();
    internal int get_MBPRight();
    internal int get_MBPTop();
    internal int get_MBPBottom();
    internal int get_BPLeft();
    internal int get_BPRight();
    internal int get_BPTop();
    internal int get_BPBottom();
    internal int get_BorderLeft();
    internal int get_BorderRight();
    internal int get_BorderTop();
    internal int get_BorderBottom();
    internal int get_MarginLeft();
    internal int get_MarginRight();
    internal int get_MarginTop();
    internal int get_MarginBottom();
    internal Thickness get_Margin();
    internal void set_Margin(Thickness value);
    internal Thickness get_Border();
    internal void set_Border(Thickness value);
    internal Thickness get_Padding();
    internal void set_Padding(Thickness value);
    internal Brush get_BorderBrush();
}
internal class MS.Internal.PtsHost.OptimalBreakSession : UnmanagedHandle {
    internal TextParagraphCache TextParagraphCache { get; }
    internal TextParagraph TextParagraph { get; }
    internal TextParaClient TextParaClient { get; }
    internal OptimalTextSource OptimalTextSource { get; }
    internal OptimalBreakSession(TextParagraph textParagraph, TextParaClient textParaClient, TextParagraphCache TextParagraphCache, OptimalTextSource optimalTextSource);
    public virtual void Dispose();
    internal TextParagraphCache get_TextParagraphCache();
    internal TextParagraph get_TextParagraph();
    internal TextParaClient get_TextParaClient();
    internal OptimalTextSource get_OptimalTextSource();
}
internal class MS.Internal.PtsHost.OptimalTextSource : LineBase {
    internal OptimalTextSource(TextFormatterHost host, int cpPara, int durTrack, TextParaClient paraClient, TextRunCache runCache);
    public virtual void Dispose();
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal FSFLRES GetFormatResultForBreakpoint(int dcp, TextBreakpoint textBreakpoint);
    internal Size MeasureChild(InlineObjectRun inlineObject);
}
internal class MS.Internal.PtsHost.PageBreakRecord : object {
    internal IntPtr BreakRecord { get; }
    internal int PageNumber { get; }
    internal PageBreakRecord(PtsContext ptsContext, SecurityCriticalDataForSet`1<IntPtr> br, int pageNumber);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal IntPtr get_BreakRecord();
    internal int get_PageNumber();
}
internal class MS.Internal.PtsHost.PageContext : object {
    internal FSRECT PageRect { get; internal set; }
    internal List`1<BaseParaClient> FloatingElementList { get; }
    internal FSRECT get_PageRect();
    internal void set_PageRect(FSRECT value);
    internal List`1<BaseParaClient> get_FloatingElementList();
    internal void AddFloatingParaClient(BaseParaClient floatingElement);
    internal void RemoveFloatingParaClient(BaseParaClient floatingElement);
}
internal class MS.Internal.PtsHost.PageVisual : DrawingVisual {
    internal Visual Child { get; internal set; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal PageVisual(FlowDocumentPage owner);
    internal void DrawBackground(Brush backgroundBrush, Rect renderBounds);
    internal Visual get_Child();
    internal void set_Child(Visual value);
    internal void ClearDrawingContext();
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.PtsHost.ParagraphBreakRun : TextEndOfParagraph {
    internal FSFLRES BreakReason;
    internal ParagraphBreakRun(int length, FSFLRES breakReason);
}
internal class MS.Internal.PtsHost.ParagraphElementVisual : ContainerVisual {
}
internal class MS.Internal.PtsHost.ParagraphVisual : DrawingVisual {
    internal void DrawBackgroundAndBorder(Brush backgroundBrush, Brush borderBrush, Thickness borderThickness, Rect renderBounds, bool isFirstChunk, bool isLastChunk);
    internal void DrawBackgroundAndBorderIntoContext(DrawingContext dc, Brush backgroundBrush, Brush borderBrush, Thickness borderThickness, Rect renderBounds, bool isFirstChunk, bool isLastChunk);
}
internal class MS.Internal.PtsHost.PtsCache : object {
    internal static PtsHost AcquireContext(PtsContext ptsContext, TextFormattingMode textFormattingMode);
    internal static void ReleaseContext(PtsContext ptsContext);
    [SecurityCriticalAttribute]
internal static void GetFloaterHandlerInfo(PtsHost ptsHost, IntPtr pobjectinfo);
    [SecurityCriticalAttribute]
internal static void GetTableObjHandlerInfo(PtsHost ptsHost, IntPtr pobjectinfo);
    internal static bool IsDisposed();
    protected virtual override void Finalize();
}
internal class MS.Internal.PtsHost.PtsContext : DispatcherObject {
    internal bool Disposed { get; }
    internal IntPtr Context { get; }
    internal bool IsOptimalParagraphEnabled { get; }
    internal TextFormatter TextFormatter { get; internal set; }
    internal Exception CallbackException { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal PtsContext(bool isOptimalParagraphEnabled, TextFormattingMode textFormattingMode);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void Dispose();
    internal IntPtr CreateHandle(object obj);
    internal void ReleaseHandle(IntPtr handle);
    internal bool IsValidHandle(IntPtr handle);
    internal object HandleToObject(IntPtr handle);
    internal void Enter();
    internal void Leave();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnPageCreated(SecurityCriticalDataForSet`1<IntPtr> ptsPage);
    internal void OnPageDisposed(SecurityCriticalDataForSet`1<IntPtr> ptsPage, bool disposing, bool enterContext);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnPageBreakRecordCreated(SecurityCriticalDataForSet`1<IntPtr> br);
    internal void OnPageBreakRecordDisposed(SecurityCriticalDataForSet`1<IntPtr> br, bool disposing);
    internal bool get_Disposed();
    internal IntPtr get_Context();
    internal bool get_IsOptimalParagraphEnabled();
    internal TextFormatter get_TextFormatter();
    internal void set_TextFormatter(TextFormatter value);
    internal Exception get_CallbackException();
    internal void set_CallbackException(Exception value);
}
internal static class MS.Internal.PtsHost.PtsHelper : object {
    internal static void UpdateMirroringTransform(FlowDirection parentFD, FlowDirection childFD, ContainerVisual visualChild, double width);
    internal static void ClipChildrenToRect(ContainerVisual visual, Rect rect);
    internal static void UpdateFloatingElementVisuals(ContainerVisual visual, List`1<BaseParaClient> floatingElementList);
    [SecurityCriticalAttribute]
internal static void ArrangeTrack(PtsContext ptsContext, FSTRACKDESCRIPTION& trackDesc, UInt32 fswdirTrack);
    [SecurityCriticalAttribute]
internal static void ArrangeParaList(PtsContext ptsContext, FSRECT rcTrackContent, FSPARADESCRIPTION[] arrayParaDesc, UInt32 fswdirTrack);
    [SecurityCriticalAttribute]
internal static void UpdateTrackVisuals(PtsContext ptsContext, VisualCollection visualCollection, FSKUPDATE fskupdInherited, FSTRACKDESCRIPTION& trackDesc);
    internal static void UpdateParaListVisuals(PtsContext ptsContext, VisualCollection visualCollection, FSKUPDATE fskupdInherited, FSPARADESCRIPTION[] arrayParaDesc);
    [SecurityCriticalAttribute]
internal static void UpdateViewportTrack(PtsContext ptsContext, FSTRACKDESCRIPTION& trackDesc, FSRECT& viewport);
    internal static void UpdateViewportParaList(PtsContext ptsContext, FSPARADESCRIPTION[] arrayParaDesc, FSRECT& viewport);
    [SecurityCriticalAttribute]
internal static IInputElement InputHitTestTrack(PtsContext ptsContext, FSPOINT pt, FSTRACKDESCRIPTION& trackDesc);
    internal static IInputElement InputHitTestParaList(PtsContext ptsContext, FSPOINT pt, FSRECT& rcTrack, FSPARADESCRIPTION[] arrayParaDesc);
    [SecurityCriticalAttribute]
internal static List`1<Rect> GetRectanglesInTrack(PtsContext ptsContext, ContentElement e, int start, int length, FSTRACKDESCRIPTION& trackDesc);
    internal static List`1<Rect> GetRectanglesInParaList(PtsContext ptsContext, ContentElement e, int start, int length, FSPARADESCRIPTION[] arrayParaDesc);
    internal static List`1<Rect> OffsetRectangleList(List`1<Rect> rectangleList, double xOffset, double yOffset);
    [SecurityCriticalAttribute]
internal static void SectionListFromPage(PtsContext ptsContext, IntPtr page, FSPAGEDETAILS& pageDetails, FSSECTIONDESCRIPTION[]& arraySectionDesc);
    [SecurityCriticalAttribute]
internal static void TrackListFromSubpage(PtsContext ptsContext, IntPtr subpage, FSSUBPAGEDETAILS& subpageDetails, FSTRACKDESCRIPTION[]& arrayTrackDesc);
    [SecurityCriticalAttribute]
internal static void TrackListFromSection(PtsContext ptsContext, IntPtr section, FSSECTIONDETAILS& sectionDetails, FSTRACKDESCRIPTION[]& arrayTrackDesc);
    [SecurityCriticalAttribute]
internal static void ParaListFromTrack(PtsContext ptsContext, IntPtr track, FSTRACKDETAILS& trackDetails, FSPARADESCRIPTION[]& arrayParaDesc);
    [SecurityCriticalAttribute]
internal static void ParaListFromSubtrack(PtsContext ptsContext, IntPtr subtrack, FSSUBTRACKDETAILS& subtrackDetails, FSPARADESCRIPTION[]& arrayParaDesc);
    [SecurityCriticalAttribute]
internal static void LineListSimpleFromTextPara(PtsContext ptsContext, IntPtr para, FSTEXTDETAILSFULL& textDetails, FSLINEDESCRIPTIONSINGLE[]& arrayLineDesc);
    [SecurityCriticalAttribute]
internal static void LineListCompositeFromTextPara(PtsContext ptsContext, IntPtr para, FSTEXTDETAILSFULL& textDetails, FSLINEDESCRIPTIONCOMPOSITE[]& arrayLineDesc);
    [SecurityCriticalAttribute]
internal static void LineElementListFromCompositeLine(PtsContext ptsContext, FSLINEDESCRIPTIONCOMPOSITE& lineDesc, FSLINEELEMENT[]& arrayLineElement);
    [SecurityCriticalAttribute]
internal static void AttachedObjectListFromParagraph(PtsContext ptsContext, IntPtr para, int cAttachedObject, FSATTACHEDOBJECTDESCRIPTION[]& arrayAttachedObjectDesc);
    [SecurityCriticalAttribute]
internal static TextContentRange TextContentRangeFromTrack(PtsContext ptsContext, IntPtr pfstrack);
    internal static double CalculatePageMarginAdjustment(StructuralCache structuralCache, double pageMarginWidth);
    internal static int CalculateColumnCount(ColumnPropertiesGroup columnProperties, double lineHeight, double pageWidth, double pageFontSize, FontFamily pageFontFamily, bool enableColumns);
    internal static void GetColumnMetrics(ColumnPropertiesGroup columnProperties, double pageWidth, double pageFontSize, FontFamily pageFontFamily, bool enableColumns, int cColumns, Double& lineHeight, Double& columnWidth, Double& freeSpace, Double& gapSpace);
    [SecurityCriticalAttribute]
internal static void GetColumnsInfo(ColumnPropertiesGroup columnProperties, double lineHeight, double pageWidth, double pageFontSize, FontFamily pageFontFamily, int cColumns, FSCOLUMNINFO* pfscolinfo, bool enableColumns);
}
internal class MS.Internal.PtsHost.PtsHost : object {
    internal IntPtr Context { get; internal set; }
    internal static int ContainerParagraphId { get; }
    internal static int SubpageParagraphId { get; }
    internal static int FloaterParagraphId { get; }
    internal static int TableParagraphId { get; }
    private static PtsHost();
    internal void EnterContext(PtsContext ptsContext);
    internal void LeaveContext(PtsContext ptsContext);
    internal IntPtr get_Context();
    [SecurityCriticalAttribute]
internal void set_Context(IntPtr value);
    internal static int get_ContainerParagraphId();
    internal static int get_SubpageParagraphId();
    internal static int get_FloaterParagraphId();
    internal static int get_TableParagraphId();
    internal void AssertFailed(string arg1, string arg2, int arg3, UInt32 arg4);
    internal int GetFigureProperties(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, int fInTextLine, UInt32 fswdir, int fBottomUndefined, Int32& dur, Int32& dvr, FSFIGUREPROPS& fsfigprops, Int32& cPolygons, Int32& cVertices, Int32& durDistTextLeft, Int32& durDistTextRight, Int32& dvrDistTextTop, Int32& dvrDistTextBottom);
    [SecurityCriticalAttribute]
internal int GetFigurePolygons(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal int CalcFigurePosition(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, UInt32 fswdir, FSRECT& fsrcPage, FSRECT& fsrcMargin, FSRECT& fsrcTrack, FSRECT& fsrcFigurePreliminary, int fMustPosition, int fInTextLine, Int32& fPushToNextTrack, FSRECT& fsrcFlow, FSRECT& fsrcOverlap, FSBBOX& fsbbox, FSRECT& fsrcSearch);
    internal int FSkipPage(IntPtr pfsclient, IntPtr nms, Int32& fSkip);
    internal int GetPageDimensions(IntPtr pfsclient, IntPtr nms, UInt32& fswdir, Int32& fHeaderFooterAtTopBottom, Int32& durPage, Int32& dvrPage, FSRECT& fsrcMargin);
    internal int GetNextSection(IntPtr pfsclient, IntPtr nmsCur, Int32& fSuccess, IntPtr& nmsNext);
    internal int GetSectionProperties(IntPtr pfsclient, IntPtr nms, Int32& fNewPage, UInt32& fswdir, Int32& fApplyColumnBalancing, Int32& ccol, Int32& cSegmentDefinedColumnSpanAreas, Int32& cHeightDefinedColumnSpanAreas);
    [SecurityCriticalAttribute]
internal int GetJustificationProperties(IntPtr pfsclient, IntPtr* rgnms, int cnms, int fLastSectionNotBroken, Int32& fJustify, FSKALIGNPAGE& fskal, Int32& fCancelAtLastColumn);
    internal int GetMainTextSegment(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmSegment);
    internal int GetHeaderSegment(IntPtr pfsclient, IntPtr nms, IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fHeaderPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirHeader, IntPtr& nmsHeader);
    internal int GetFooterSegment(IntPtr pfsclient, IntPtr nms, IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fFooterPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirFooter, IntPtr& nmsFooter);
    internal int UpdGetSegmentChange(IntPtr pfsclient, IntPtr nms, FSKCHANGE& fskch);
    [SecurityCriticalAttribute]
internal int GetSectionColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncol, FSCOLUMNINFO* fscolinfo, Int32& ccol);
    [SecurityCriticalAttribute]
internal int GetSegmentDefinedColumnSpanAreaInfo(IntPtr pfsclient, IntPtr nms, int cAreas, IntPtr* rgnmSeg, Int32* rgcColumns, Int32& cAreasActual);
    [SecurityCriticalAttribute]
internal int GetHeightDefinedColumnSpanAreaInfo(IntPtr pfsclient, IntPtr nms, int cAreas, Int32* rgdvrAreaHeight, Int32* rgcColumns, Int32& cAreasActual);
    internal int GetFirstPara(IntPtr pfsclient, IntPtr nms, Int32& fSuccessful, IntPtr& nmp);
    internal int GetNextPara(IntPtr pfsclient, IntPtr nms, IntPtr nmpCur, Int32& fFound, IntPtr& nmpNext);
    internal int UpdGetFirstChangeInSegment(IntPtr pfsclient, IntPtr nms, Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
    internal int UpdGetParaChange(IntPtr pfsclient, IntPtr nmp, FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal int GetParaProperties(IntPtr pfsclient, IntPtr nmp, FSPAP& fspap);
    internal int CreateParaclient(IntPtr pfsclient, IntPtr nmp, IntPtr& pfsparaclient);
    internal int TransferDisplayInfo(IntPtr pfsclient, IntPtr pfsparaclientOld, IntPtr pfsparaclientNew);
    internal int DestroyParaclient(IntPtr pfsclient, IntPtr pfsparaclient);
    internal int FInterruptFormattingAfterPara(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int vr, Int32& fInterruptFormatting);
    internal int GetEndnoteSeparators(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmsEndnoteSeparator, IntPtr& nmsEndnoteContSeparator, IntPtr& nmsEndnoteContNotice);
    internal int GetEndnoteSegment(IntPtr pfsclient, IntPtr nmsSection, Int32& fEndnotesPresent, IntPtr& nmsEndnotes);
    internal int GetNumberEndnoteColumns(IntPtr pfsclient, IntPtr nms, Int32& ccolEndnote);
    [SecurityCriticalAttribute]
internal int GetEndnoteColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncolEndnote, FSCOLUMNINFO* fscolinfoEndnote, Int32& ccolEndnote);
    internal int GetFootnoteSeparators(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmsFtnSeparator, IntPtr& nmsFtnContSeparator, IntPtr& nmsFtnContNotice);
    internal int FFootnoteBeneathText(IntPtr pfsclient, IntPtr nms, Int32& fFootnoteBeneathText);
    internal int GetNumberFootnoteColumns(IntPtr pfsclient, IntPtr nms, Int32& ccolFootnote);
    [SecurityCriticalAttribute]
internal int GetFootnoteColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncolFootnote, FSCOLUMNINFO* fscolinfoFootnote, Int32& ccolFootnote);
    internal int GetFootnoteSegment(IntPtr pfsclient, IntPtr nmftn, IntPtr& nmsFootnote);
    [SecurityCriticalAttribute]
internal int GetFootnotePresentationAndRejectionOrder(IntPtr pfsclient, int cFootnotes, IntPtr* rgProposedPresentationOrder, IntPtr* rgProposedRejectionOrder, Int32& fProposedPresentationOrderAccepted, IntPtr* rgFinalPresentationOrder, Int32& fProposedRejectionOrderAccepted, IntPtr* rgFinalRejectionOrder);
    internal int FAllowFootnoteSeparation(IntPtr pfsclient, IntPtr nmftn, Int32& fAllow);
    internal int DuplicateMcsclient(IntPtr pfsclient, IntPtr pmcsclientIn, IntPtr& pmcsclientNew);
    internal int DestroyMcsclient(IntPtr pfsclient, IntPtr pmcsclient);
    internal int FEqualMcsclient(IntPtr pfsclient, IntPtr pmcsclient1, IntPtr pmcsclient2, Int32& fEqual);
    internal int ConvertMcsclient(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, UInt32 fswdir, IntPtr pmcsclient, int fSuppressTopSpace, Int32& dvr);
    [SecurityCriticalAttribute]
internal int GetObjectHandlerInfo(IntPtr pfsclient, int idobj, IntPtr pObjectInfo);
    internal int CreateParaBreakingSession(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int fsdcpStart, IntPtr pfsbreakreclineclient, UInt32 fswdir, int urStartTrack, int durTrack, int urPageLeftMargin, IntPtr& ppfsparabreakingsession, Int32& fParagraphJustified);
    internal int DestroyParaBreakingSession(IntPtr pfsclient, IntPtr pfsparabreakingsession);
    internal int GetTextProperties(IntPtr pfsclient, IntPtr nmp, int iArea, FSTXTPROPS& fstxtprops);
    internal int GetNumberFootnotes(IntPtr pfsclient, IntPtr nmp, int fsdcpStart, int fsdcpLim, Int32& nFootnote);
    [SecurityCriticalAttribute]
internal int GetFootnotes(IntPtr pfsclient, IntPtr nmp, int fsdcpStart, int fsdcpLim, int nFootnotes, IntPtr* rgnmftn, Int32* rgdcp, Int32& cFootnotes);
    internal int FormatDropCap(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int fSuppressTopSpace, IntPtr& pfsdropc, Int32& fInMargin, Int32& dur, Int32& dvr, Int32& cPolygons, Int32& cVertices, Int32& durText);
    [SecurityCriticalAttribute]
internal int GetDropCapPolygons(IntPtr pfsclient, IntPtr pfsdropc, IntPtr nmp, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal int DestroyDropCap(IntPtr pfsclient, IntPtr pfsdropc);
    internal int FormatBottomText(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, IntPtr pfslineLast, int dvrLine, IntPtr& pmcsclientOut);
    internal int FormatLine(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr& pfsline, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal int FormatLineForced(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, int dvrAvailable, IntPtr& pfsline, Int32& dcpLine, IntPtr& ppbrlineOut, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend);
    [SecurityCriticalAttribute]
internal int FormatLineVariants(IntPtr pfsclient, IntPtr pfsparabreakingsession, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr lineVariantRestriction, int nLineVariantsAlloc, FSLINEVARIANT* rgfslinevariant, Int32& nLineVariantsActual, Int32& iLineVariantBest);
    internal int ReconstructLineVariant(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcpStart, IntPtr pbrlineIn, int dcpLine, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr& pfsline, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal int DestroyLine(IntPtr pfsclient, IntPtr pfsline);
    internal int DuplicateLineBreakRecord(IntPtr pfsclient, IntPtr pbrlineIn, IntPtr& pbrlineDup);
    internal int DestroyLineBreakRecord(IntPtr pfsclient, IntPtr pbrlineIn);
    internal int SnapGridVertical(IntPtr pfsclient, UInt32 fswdir, int vrMargin, int vrCurrent, Int32& vrNew);
    internal int GetDvrSuppressibleBottomSpace(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsline, UInt32 fswdir, Int32& dvrSuppressible);
    internal int GetDvrAdvance(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int dcp, UInt32 fswdir, Int32& dvr);
    internal int UpdGetChangeInText(IntPtr pfsclient, IntPtr nmp, Int32& dcpStart, Int32& ddcpOld, Int32& ddcpNew);
    internal int UpdGetDropCapChange(IntPtr pfsclient, IntPtr nmp, Int32& fChanged);
    internal int FInterruptFormattingText(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int dcp, int vr, Int32& fInterruptFormatting);
    internal int GetTextParaCache(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fSuppressTopSpace, Int32& fFound, Int32& dcpPara, Int32& urBBox, Int32& durBBox, Int32& dvrPara, FSKCLEAR& fskclear, IntPtr& pmcsclientAfterPara, Int32& cLines, Int32& fOptimalLines, Int32& fOptimalLineDcpsCached, Int32& dvrMinLineHeight);
    [SecurityCriticalAttribute]
internal int SetTextParaCache(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fSuppressTopSpace, int dcpPara, int urBBox, int durBBox, int dvrPara, FSKCLEAR fskclear, IntPtr pmcsclientAfterPara, int cLines, int fOptimalLines, Int32* rgdcpOptimalLines, int dvrMinLineHeight);
    [SecurityCriticalAttribute]
internal int GetOptimalLineDcpCache(IntPtr pfsclient, int cLines, Int32* rgdcp);
    internal int GetNumberAttachedObjectsBeforeTextLine(IntPtr pfsclient, IntPtr nmp, int dcpFirst, Int32& cAttachedObjects);
    [SecurityCriticalAttribute]
internal int GetAttachedObjectsBeforeTextLine(IntPtr pfsclient, IntPtr nmp, int dcpFirst, int nAttachedObjects, IntPtr* rgnmpAttachedObject, Int32* rgidobj, Int32* rgdcpAnchor, Int32& cObjects, Int32& fEndOfParagraph);
    internal int GetNumberAttachedObjectsInTextLine(IntPtr pfsclient, IntPtr pfsline, IntPtr nmp, int dcpFirst, int dcpLim, int fFoundAttachedObjectsBeforeLine, int dcpMaxAnchorAttachedObjectBeforeLine, Int32& cAttachedObjects);
    [SecurityCriticalAttribute]
internal int GetAttachedObjectsInTextLine(IntPtr pfsclient, IntPtr pfsline, IntPtr nmp, int dcpFirst, int dcpLim, int fFoundAttachedObjectsBeforeLine, int dcpMaxAnchorAttachedObjectBeforeLine, int nAttachedObjects, IntPtr* rgnmpAttachedObject, Int32* rgidobj, Int32* rgdcpAnchor, Int32& cObjects);
    internal int UpdGetAttachedObjectChange(IntPtr pfsclient, IntPtr nmp, IntPtr nmpObject, FSKCHANGE& fskchObject);
    internal int GetDurFigureAnchor(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsparaclientFigure, IntPtr pfsline, IntPtr nmpFigure, UInt32 fswdir, IntPtr pfsfmtlinein, Int32& dur);
    internal int GetFloaterProperties(IntPtr pfsclient, IntPtr nmFloater, UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    [SecurityCriticalAttribute]
internal int FormatFloaterContentFinite(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsbrkFloaterContentIn, int fBreakRecordFromPreviousPage, IntPtr nmFloater, IntPtr pftnrej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecpara, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal int FormatFloaterContentBottomless(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal int UpdateBottomlessFloaterContent(IntPtr pfsFloaterContent, IntPtr pfsparaclient, IntPtr nmFloater, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    [SecurityCriticalAttribute]
internal int GetFloaterPolygons(IntPtr pfsparaclient, IntPtr pfsFloaterContent, IntPtr nmFloater, UInt32 fswdirTrack, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    [SecurityCriticalAttribute]
internal int ClearUpdateInfoInFloaterContent(IntPtr pfsFloaterContent);
    [SecurityCriticalAttribute]
internal int CompareFloaterContents(IntPtr pfsFloaterContentOld, IntPtr pfsFloaterContentNew, FSCOMPRESULT& fscmpr);
    [SecurityCriticalAttribute]
internal int DestroyFloaterContent(IntPtr pfsFloaterContent);
    [SecurityCriticalAttribute]
internal int DuplicateFloaterContentBreakRecord(IntPtr pfsclient, IntPtr pfsbrkFloaterContent, IntPtr& pfsbrkFloaterContentDup);
    [SecurityCriticalAttribute]
internal int DestroyFloaterContentBreakRecord(IntPtr pfsclient, IntPtr pfsbrkFloaterContent);
    [SecurityCriticalAttribute]
internal int GetFloaterContentColumnBalancingInfo(IntPtr pfsFloaterContent, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    [SecurityCriticalAttribute]
internal int GetFloaterContentNumberFootnotes(IntPtr pfsFloaterContent, Int32& cftn);
    internal int GetFloaterContentFootnoteInfo(IntPtr pfsFloaterContent, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO& fsftninf, Int32& iftnLim);
    [SecurityCriticalAttribute]
internal int TransferDisplayInfoInFloaterContent(IntPtr pfsFloaterContentOld, IntPtr pfsFloaterContentNew);
    internal int GetMCSClientAfterFloater(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& pmcsclientOut);
    internal int GetDvrUsedForFloater(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, UInt32 fswdirTrack, IntPtr pmcsclientIn, int dvrDisplaced, Int32& dvrUsed);
    internal int SubtrackCreateContext(IntPtr pfsclient, IntPtr pfsc, IntPtr pfscbkobj, UInt32 ffi, int idobj, IntPtr& pfssobjc);
    internal int SubtrackDestroyContext(IntPtr pfssobjc);
    [SecurityCriticalAttribute]
internal int SubtrackFormatParaFinite(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr pfsobjbrk, int fBreakRecordFromPreviousPage, IntPtr nmp, int iArea, IntPtr pftnrej, IntPtr pfsgeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, int fBreakInside, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecpara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fBreakInsidePossible);
    [SecurityCriticalAttribute]
internal int SubtrackFormatParaBottomless(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    [SecurityCriticalAttribute]
internal int SubtrackUpdateBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    [SecurityCriticalAttribute]
internal int SubtrackSynchronizeBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsgeom, UInt32 fswdir, int dvrShift);
    [SecurityCriticalAttribute]
internal int SubtrackComparePara(IntPtr pfsparaclientOld, IntPtr pfsparaOld, IntPtr pfsparaclientNew, IntPtr pfsparaNew, UInt32 fswdir, FSCOMPRESULT& fscmpr, Int32& dvrShifted);
    [SecurityCriticalAttribute]
internal int SubtrackClearUpdateInfoInPara(IntPtr pfspara);
    [SecurityCriticalAttribute]
internal int SubtrackDestroyPara(IntPtr pfspara);
    [SecurityCriticalAttribute]
internal int SubtrackDuplicateBreakRecord(IntPtr pfssobjc, IntPtr pfsbrkrecparaOrig, IntPtr& pfsbrkrecparaDup);
    [SecurityCriticalAttribute]
internal int SubtrackDestroyBreakRecord(IntPtr pfssobjc, IntPtr pfsobjbrk);
    [SecurityCriticalAttribute]
internal int SubtrackGetColumnBalancingInfo(IntPtr pfspara, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    [SecurityCriticalAttribute]
internal int SubtrackGetNumberFootnotes(IntPtr pfspara, Int32& nftn);
    [SecurityCriticalAttribute]
internal int SubtrackGetFootnoteInfo(IntPtr pfspara, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO* pfsftninf, Int32& iftnLim);
    internal int SubtrackShiftVertical(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsshift, UInt32 fswdir, FSBBOX& pfsbbox);
    [SecurityCriticalAttribute]
internal int SubtrackTransferDisplayInfoPara(IntPtr pfsparaOld, IntPtr pfsparaNew);
    internal int SubpageCreateContext(IntPtr pfsclient, IntPtr pfsc, IntPtr pfscbkobj, UInt32 ffi, int idobj, IntPtr& pfssobjc);
    internal int SubpageDestroyContext(IntPtr pfssobjc);
    [SecurityCriticalAttribute]
internal int SubpageFormatParaFinite(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr pfsobjbrk, int fBreakRecordFromPreviousPage, IntPtr nmp, int iArea, IntPtr pftnrej, IntPtr pfsgeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, int fBreakInside, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecpara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fBreakInsidePossible);
    internal int SubpageFormatParaBottomless(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    [SecurityCriticalAttribute]
internal int SubpageUpdateBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal int SubpageSynchronizeBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsgeom, UInt32 fswdir, int dvrShift);
    [SecurityCriticalAttribute]
internal int SubpageComparePara(IntPtr pfsparaclientOld, IntPtr pfsparaOld, IntPtr pfsparaclientNew, IntPtr pfsparaNew, UInt32 fswdir, FSCOMPRESULT& fscmpr, Int32& dvrShifted);
    [SecurityCriticalAttribute]
internal int SubpageClearUpdateInfoInPara(IntPtr pfspara);
    [SecurityCriticalAttribute]
internal int SubpageDestroyPara(IntPtr pfspara);
    [SecurityCriticalAttribute]
internal int SubpageDuplicateBreakRecord(IntPtr pfssobjc, IntPtr pfsbrkrecparaOrig, IntPtr& pfsbrkrecparaDup);
    [SecurityCriticalAttribute]
internal int SubpageDestroyBreakRecord(IntPtr pfssobjc, IntPtr pfsobjbrk);
    [SecurityCriticalAttribute]
internal int SubpageGetColumnBalancingInfo(IntPtr pfspara, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    [SecurityCriticalAttribute]
internal int SubpageGetNumberFootnotes(IntPtr pfspara, Int32& nftn);
    [SecurityCriticalAttribute]
internal int SubpageGetFootnoteInfo(IntPtr pfspara, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO* pfsftninf, Int32& iftnLim);
    internal int SubpageShiftVertical(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsshift, UInt32 fswdir, FSBBOX& pfsbbox);
    [SecurityCriticalAttribute]
internal int SubpageTransferDisplayInfoPara(IntPtr pfsparaOld, IntPtr pfsparaNew);
    internal int GetTableProperties(IntPtr pfsclient, IntPtr nmTable, UInt32 fswdirTrack, FSTABLEOBJPROPS& fstableobjprops);
    internal int AutofitTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth);
    internal int UpdAutofitTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth, Int32& fNoChangeInCellWidths);
    internal int GetMCSClientAfterTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& ppmcsclientOut);
    internal int GetFirstHeaderRow(IntPtr pfsclient, IntPtr nmTable, int fRepeatedHeader, Int32& fFound, IntPtr& pnmFirstHeaderRow);
    internal int GetNextHeaderRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmHeaderRow, int fRepeatedHeader, Int32& fFound, IntPtr& pnmNextHeaderRow);
    internal int GetFirstFooterRow(IntPtr pfsclient, IntPtr nmTable, int fRepeatedFooter, Int32& fFound, IntPtr& pnmFirstFooterRow);
    internal int GetNextFooterRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmFooterRow, int fRepeatedFooter, Int32& fFound, IntPtr& pnmNextFooterRow);
    internal int GetFirstRow(IntPtr pfsclient, IntPtr nmTable, Int32& fFound, IntPtr& pnmFirstRow);
    internal int GetNextRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmRow, Int32& fFound, IntPtr& pnmNextRow);
    internal int UpdFChangeInHeaderFooter(IntPtr pfsclient, IntPtr nmTable, Int32& fHeaderChanged, Int32& fFooterChanged, Int32& fRepeatedHeaderChanged, Int32& fRepeatedFooterChanged);
    internal int UpdGetFirstChangeInTable(IntPtr pfsclient, IntPtr nmTable, Int32& fFound, Int32& fChangeFirst, IntPtr& pnmRowBeforeChange);
    internal int UpdGetRowChange(IntPtr pfsclient, IntPtr nmTable, IntPtr nmRow, FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal int UpdGetCellChange(IntPtr pfsclient, IntPtr nmRow, IntPtr nmCell, Int32& fWidthChanged, FSKCHANGE& fskchCell);
    internal int GetDistributionKind(IntPtr pfsclient, IntPtr nmTable, UInt32 fswdirTable, FSKTABLEHEIGHTDISTRIBUTION& tabledistr);
    internal int GetRowProperties(IntPtr pfsclient, IntPtr nmRow, UInt32 fswdirTable, FSTABLEROWPROPS& rowprops);
    [SecurityCriticalAttribute]
internal int GetCells(IntPtr pfsclient, IntPtr nmRow, int cCells, IntPtr* rgnmCell, FSTABLEKCELLMERGE* rgkcellmerge);
    internal int FInterruptFormattingTable(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmRow, int dvr, Int32& fInterrupt);
    [SecurityCriticalAttribute]
internal int CalcHorizontalBBoxOfRow(IntPtr pfsclient, IntPtr nmRow, int cCells, IntPtr* rgnmCell, IntPtr* rgpfscell, Int32& urBBox, Int32& durBBox);
    [SecurityCriticalAttribute]
internal int FormatCellFinite(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr pfsbrkcell, IntPtr nmCell, IntPtr pfsFtnRejector, int fEmptyOK, UInt32 fswdirTable, int dvrExtraHeight, int dvrAvailable, FSFMTR& pfmtr, IntPtr& ppfscell, IntPtr& pfsbrkcellOut, Int32& dvrUsed);
    internal int FormatCellBottomless(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmCell, UInt32 fswdirTable, FSFMTRBL& fmtrbl, IntPtr& ppfscell, Int32& dvrUsed);
    internal int UpdateBottomlessCell(IntPtr pfscell, IntPtr pfsparaclientTable, IntPtr nmCell, UInt32 fswdirTable, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal int CompareCells(IntPtr pfscellOld, IntPtr pfscellNew, FSCOMPRESULT& fscmpr);
    internal int ClearUpdateInfoInCell(IntPtr pfscell);
    internal int SetCellHeight(IntPtr pfscell, IntPtr pfsparaclientTable, IntPtr pfsbrkcell, IntPtr nmCell, int fBrokenHere, UInt32 fswdirTable, int dvrActual);
    [SecurityCriticalAttribute]
internal int DuplicateCellBreakRecord(IntPtr pfsclient, IntPtr pfsbrkcell, IntPtr& ppfsbrkcellDup);
    [SecurityCriticalAttribute]
internal int DestroyCellBreakRecord(IntPtr pfsclient, IntPtr pfsbrkcell);
    internal int DestroyCell(IntPtr pfsCell);
    internal int GetCellNumberFootnotes(IntPtr pfsCell, Int32& cFtn);
    internal int GetCellMinColumnBalancingStep(IntPtr pfscell, UInt32 fswdir, Int32& dvrMinStep);
    internal int TransferDisplayInfoCell(IntPtr pfscellOld, IntPtr pfscellNew);
}
internal class MS.Internal.PtsHost.PtsPage : object {
    internal bool _useSizingWorkaroundForTextBox;
    internal PageBreakRecord BreakRecord { get; }
    internal Size CalculatedSize { get; }
    internal Size ContentSize { get; }
    internal bool FinitePage { get; }
    internal PageContext PageContext { get; }
    internal bool IncrementalUpdate { get; }
    internal PtsContext PtsContext { get; }
    internal IntPtr PageHandle { get; }
    internal bool UseSizingWorkaroundForTextBox { get; internal set; }
    internal PtsPage(Section section);
    private static PtsPage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal bool PrepareForBottomlessUpdate();
    internal bool PrepareForFiniteUpdate(PageBreakRecord breakRecord);
    internal IInputElement InputHitTest(Point p);
    internal List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CreateBottomlessPage();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateBottomlessPage();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CreateFinitePage(PageBreakRecord breakRecord);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateFinitePage(PageBreakRecord breakRecord);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ArrangePage();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateViewport(FSRECT& viewport);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ClearUpdateInfo();
    internal ContainerVisual GetPageVisual();
    internal PageBreakRecord get_BreakRecord();
    internal Size get_CalculatedSize();
    internal Size get_ContentSize();
    internal bool get_FinitePage();
    internal PageContext get_PageContext();
    internal bool get_IncrementalUpdate();
    internal PtsContext get_PtsContext();
    internal IntPtr get_PageHandle();
    internal bool get_UseSizingWorkaroundForTextBox();
    internal void set_UseSizingWorkaroundForTextBox(bool value);
}
internal class MS.Internal.PtsHost.RowParagraph : BaseParagraph {
    internal TableRow Row { get; }
    internal Table Table { get; }
    internal CellParagraph[] Cells { get; }
    internal RowParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal void GetRowProperties(UInt32 fswdirTable, FSTABLEROWPROPS& rowprops);
    internal void FInterruptFormattingTable(int dvr, Int32& fInterrupt);
    [SecurityCriticalAttribute]
internal void CalcHorizontalBBoxOfRow(int cCells, IntPtr* rgnmCell, IntPtr* rgpfsCell, Int32& urBBox, Int32& durBBox);
    [SecurityCriticalAttribute]
internal void GetCells(int cCells, IntPtr* rgnmCell, FSTABLEKCELLMERGE* rgkcellmerge);
    internal void CalculateRowSpans();
    internal void GetRowHeight(FSKROWHEIGHTRESTRICTION& fskrowheight, Int32& dvrAboveBelow);
    internal TableRow get_Row();
    internal Table get_Table();
    internal CellParagraph[] get_Cells();
}
internal class MS.Internal.PtsHost.RowVisual : ContainerVisual {
    internal TableRow Row { get; }
    internal RowVisual(TableRow row);
    internal TableRow get_Row();
}
internal class MS.Internal.PtsHost.Section : UnmanagedHandle {
    internal bool CanUpdate { get; }
    internal StructuralCache StructuralCache { get; }
    internal DependencyObject Element { get; }
    internal Section(StructuralCache structuralCache);
    public virtual void Dispose();
    internal void FSkipPage(Int32& fSkip);
    internal void GetPageDimensions(UInt32& fswdir, Int32& fHeaderFooterAtTopBottom, Int32& durPage, Int32& dvrPage, FSRECT& fsrcMargin);
    [SecurityCriticalAttribute]
internal void GetJustificationProperties(IntPtr* rgnms, int cnms, int fLastSectionNotBroken, Int32& fJustify, FSKALIGNPAGE& fskal, Int32& fCancelAtLastColumn);
    internal void GetNextSection(Int32& fSuccess, IntPtr& nmsNext);
    internal void GetSectionProperties(Int32& fNewPage, UInt32& fswdir, Int32& fApplyColumnBalancing, Int32& ccol, Int32& cSegmentDefinedColumnSpanAreas, Int32& cHeightDefinedColumnSpanAreas);
    internal void GetMainTextSegment(IntPtr& nmSegment);
    internal void GetHeaderSegment(IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fHeaderPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirHeader, IntPtr& nmsHeader);
    internal void GetFooterSegment(IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fFooterPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirFooter, IntPtr& nmsFooter);
    [SecurityCriticalAttribute]
internal void GetSectionColumnInfo(UInt32 fswdir, int ncol, FSCOLUMNINFO* pfscolinfo, Int32& ccol);
    internal void GetEndnoteSegment(Int32& fEndnotesPresent, IntPtr& nmsEndnotes);
    internal void GetEndnoteSeparators(IntPtr& nmsEndnoteSeparator, IntPtr& nmsEndnoteContSeparator, IntPtr& nmsEndnoteContNotice);
    internal void InvalidateFormatCache();
    internal void ClearUpdateInfo();
    internal void InvalidateStructure();
    internal void DestroyStructure();
    internal void UpdateSegmentLastFormatPositions();
    internal bool get_CanUpdate();
    internal StructuralCache get_StructuralCache();
    internal DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.SectionVisual : DrawingVisual {
    internal void DrawColumnRules(FSTRACKDESCRIPTION[]& arrayColumnDesc, double columnVStart, double columnHeight, ColumnPropertiesGroup columnProperties);
}
internal class MS.Internal.PtsHost.StructuralCache : object {
    internal DependencyObject PropertyOwner { get; }
    internal FlowDocument FormattingOwner { get; }
    internal Section Section { get; }
    internal NaturalLanguageHyphenator Hyphenator { get; }
    internal PtsContext PtsContext { get; }
    internal DocumentFormatContext CurrentFormatContext { get; }
    internal DocumentArrangeContext CurrentArrangeContext { get; }
    internal TextFormatterHost TextFormatterHost { get; }
    internal TextContainer TextContainer { get; }
    internal FlowDirection PageFlowDirection { get; internal set; }
    internal bool ForceReformat { get; internal set; }
    internal bool DestroyStructure { get; }
    internal DtrList DtrList { get; }
    internal bool IsDeferredVisualCreationSupported { get; }
    internal BackgroundFormatInfo BackgroundFormatInfo { get; }
    internal bool IsOptimalParagraphEnabled { get; }
    internal bool IsFormattingInProgress { get; internal set; }
    internal bool IsContentChangeInProgress { get; internal set; }
    internal bool IsFormattedOnce { get; internal set; }
    internal StructuralCache(FlowDocument owner, TextContainer textContainer);
    protected virtual override void Finalize();
    internal IDisposable SetDocumentFormatContext(FlowDocumentPage currentPage);
    internal IDisposable SetDocumentArrangeContext(FlowDocumentPage currentPage);
    internal IDisposable SetDocumentVisualValidationContext(FlowDocumentPage currentPage);
    internal void DetectInvalidOperation();
    internal void OnInvalidOperationDetected();
    internal void InvalidateFormatCache(bool destroyStructure);
    internal void AddDirtyTextRange(DirtyTextRange dtr);
    internal DtrList DtrsFromRange(int dcpNew, int cchOld);
    internal void ClearUpdateInfo(bool destroyStructureCache);
    internal void ThrottleBackgroundFormatting();
    internal bool HasPtsContext();
    internal DependencyObject get_PropertyOwner();
    internal FlowDocument get_FormattingOwner();
    internal Section get_Section();
    internal NaturalLanguageHyphenator get_Hyphenator();
    internal PtsContext get_PtsContext();
    internal DocumentFormatContext get_CurrentFormatContext();
    internal DocumentArrangeContext get_CurrentArrangeContext();
    internal TextFormatterHost get_TextFormatterHost();
    internal TextContainer get_TextContainer();
    internal FlowDirection get_PageFlowDirection();
    internal void set_PageFlowDirection(FlowDirection value);
    internal bool get_ForceReformat();
    internal void set_ForceReformat(bool value);
    internal bool get_DestroyStructure();
    internal DtrList get_DtrList();
    internal bool get_IsDeferredVisualCreationSupported();
    internal BackgroundFormatInfo get_BackgroundFormatInfo();
    internal bool get_IsOptimalParagraphEnabled();
    internal bool get_IsFormattingInProgress();
    internal void set_IsFormattingInProgress(bool value);
    internal bool get_IsContentChangeInProgress();
    internal void set_IsContentChangeInProgress(bool value);
    internal bool get_IsFormattedOnce();
    internal void set_IsFormattedOnce(bool value);
}
internal class MS.Internal.PtsHost.SubpageParaClient : BaseParaClient {
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FSRECT ContentRect { get; }
    internal SubpageParaClient(SubpageParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    [SecurityCriticalAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    [SecurityCriticalAttribute]
internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal void SetChunkInfo(bool isFirstChunk, bool isLastChunk);
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
    internal FSRECT get_ContentRect();
}
internal class MS.Internal.PtsHost.SubpageParagraph : BaseParagraph {
    protected bool _isInterruptible;
    internal SubpageParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    [SecurityCriticalAttribute]
internal void FormatParaFinite(SubpageParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, MarginCollapsingState mcs, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecOut, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void FormatParaBottomless(SubpageParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    [SecurityCriticalAttribute]
internal void UpdateBottomlessPara(IntPtr pfspara, SubpageParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
}
internal class MS.Internal.PtsHost.TableParaClient : BaseParaClient {
    internal TableParagraph TableParagraph { get; }
    internal Table Table { get; }
    internal double TableDesiredWidth { get; }
    internal CalculatedColumn[] CalculatedColumns { get; }
    internal double AutofitWidth { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal TableParaClient(TableParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CellParaClient GetCellParaClientFromPoint(Point point, bool snapToText);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResultsForRow(int rowIndex, Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPoint(Point point, bool snapToText);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPosition(ITextPointer position);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CellParaClient GetCellParaClientFromPosition(ITextPointer position);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CellParaClient GetCellAbove(double suggestedX, int rowGroupIndex, int rowIndex);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal CellParaClient GetCellBelow(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellInfo GetCellInfoFromPoint(Point point);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Rect GetRectangleFromRowEndPosition(ITextPointer position);
    internal void AutofitTable(UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth);
    internal void UpdAutofitTable(UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth, Int32& fNoChangeInCellWidths);
    internal int Autofit(double availableWidth, Double& tableWidth);
    internal TableParagraph get_TableParagraph();
    internal Table get_Table();
    internal double get_TableDesiredWidth();
    internal CalculatedColumn[] get_CalculatedColumns();
    internal double get_AutofitWidth();
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
}
internal class MS.Internal.PtsHost.TableParagraph : BaseParagraph {
    internal Table Table { get; }
    internal TableParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& pfsparaclient);
    internal void GetTableProperties(UInt32 fswdirTrack, FSTABLEOBJPROPS& fstableobjprops);
    internal void GetMCSClientAfterTable(UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& ppmcsclientOut);
    internal void GetFirstHeaderRow(int fRepeatedHeader, Int32& fFound, IntPtr& pnmFirstHeaderRow);
    internal void GetNextHeaderRow(int fRepeatedHeader, IntPtr nmHeaderRow, Int32& fFound, IntPtr& pnmNextHeaderRow);
    internal void GetFirstFooterRow(int fRepeatedFooter, Int32& fFound, IntPtr& pnmFirstFooterRow);
    internal void GetNextFooterRow(int fRepeatedFooter, IntPtr nmFooterRow, Int32& fFound, IntPtr& pnmNextFooterRow);
    internal void GetFirstRow(Int32& fFound, IntPtr& pnmFirstRow);
    internal void GetNextRow(IntPtr nmRow, Int32& fFound, IntPtr& pnmNextRow);
    internal void UpdFChangeInHeaderFooter(Int32& fHeaderChanged, Int32& fFooterChanged, Int32& fRepeatedHeaderChanged, Int32& fRepeatedFooterChanged);
    internal void UpdGetFirstChangeInTable(Int32& fFound, Int32& fChangeFirst, IntPtr& pnmRowBeforeChange);
    internal void GetDistributionKind(UInt32 fswdirTable, FSKTABLEHEIGHTDISTRIBUTION& tabledistr);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal Table get_Table();
}
internal class MS.Internal.PtsHost.TextFormatterHost : TextSource {
    internal LineBase Context;
    internal TextFormatter TextFormatter;
    internal TextFormatterHost(TextFormatter textFormatter, TextFormattingMode textFormattingMode, double pixelsPerDip);
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
}
internal class MS.Internal.PtsHost.TextParaClient : BaseParaClient {
    internal TextParagraph TextParagraph { get; }
    internal bool HasEOP { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal TextParaClient(TextParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateViewport(FSRECT& viewport);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual IInputElement InputHitTest(FSPOINT pt);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual ParagraphResult CreateParagraphResult();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<LineResult> GetLineResults();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetFloaters();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ReadOnlyCollection`1<ParagraphResult> GetFigures();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual TextContentRange GetTextContentRange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void GetLineDetails(int dcpLine, Int32& cchContent, Int32& cchEllipses);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual int GetFirstTextLineBaseline();
    internal ITextPointer GetTextPosition(int dcp, LogicalDirection direction);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Rect GetRectangleFromTextPosition(ITextPointer position);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool IsAtCaretUnitBoundary(ITextPointer position);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ITextPointer GetTextPositionFromDistance(int dcpLine, double distance);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end);
    internal TextParagraph get_TextParagraph();
    internal bool get_HasEOP();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual bool get_IsFirstChunk();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual bool get_IsLastChunk();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
}
internal class MS.Internal.PtsHost.TextParagraph : BaseParagraph {
    internal TextRunCache TextRunCache { get; }
    internal LineProperties Properties { get; }
    internal bool IsOptimalParagraph { get; }
    internal TextParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal void GetTextProperties(int iArea, FSTXTPROPS& fstxtprops);
    internal void CreateOptimalBreakSession(TextParaClient textParaClient, int dcpStart, int durTrack, LineBreakRecord lineBreakRecord, OptimalBreakSession& optimalBreakSession, Boolean& isParagraphJustified);
    internal void GetNumberFootnotes(int fsdcpStart, int fsdcpLim, Int32& nFootnote);
    internal void FormatBottomText(int iArea, UInt32 fswdir, Line lastLine, int dvrLine, IntPtr& mcsClient);
    internal bool InterruptFormatting(int dcpCur, int vrCur);
    internal IList`1<TextBreakpoint> FormatLineVariants(TextParaClient textParaClient, TextParagraphCache textParagraphCache, OptimalTextSource optimalTextSource, int dcp, TextLineBreak textLineBreak, UInt32 fswdir, int urStartLine, int durLine, bool allowHyphenation, bool clearOnLeft, bool clearOnRight, bool treatAsFirstInPara, bool treatAsLastInPara, bool suppressTopSpace, IntPtr lineVariantRestriction, Int32& iLineBestVariant);
    internal void ReconstructLineVariant(TextParaClient paraClient, int iArea, int dcp, IntPtr pbrlineIn, int dcpLineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, bool fAllowHyphenation, bool fClearOnLeft, bool fClearOnRight, bool fTreatAsFirstInPara, bool fTreatAsLastInPara, bool fSuppressTopSpace, IntPtr& lineHandle, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal void FormatLine(TextParaClient paraClient, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, bool fAllowHyphenation, bool fClearOnLeft, bool fClearOnRight, bool fTreatAsFirstInPara, bool fTreatAsLastInPara, bool fSuppressTopSpace, IntPtr& lineHandle, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal void UpdGetChangeInText(Int32& dcpStart, Int32& ddcpOld, Int32& ddcpNew);
    internal void GetDvrAdvance(int dcp, UInt32 fswdir, Int32& dvr);
    internal int GetLastDcpAttachedObjectBeforeLine(int dcpFirst);
    internal int GetAttachedObjectCount(int dcpFirst, int dcpLast);
    internal List`1<AttachedObject> GetAttachedObjects(int dcpFirst, int dcpLast);
    internal void SubmitInlineObjects(int dcpStart, int dcpLim, List`1<InlineObject> inlineObjects);
    internal void SubmitAttachedObjects(int dcpStart, int dcpLim, List`1<AttachedObject> attachedObjects);
    internal List`1<InlineObject> InlineObjectsFromRange(int dcpStart, int dcpLast);
    internal void CalcLineAscentDescent(int dcp, Int32& dvrAscent, Int32& dvrDescent);
    internal virtual void SetUpdateInfo(FSKCHANGE fskch, bool stopAsking);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void InvalidateTextFormatCache();
    internal void FormatLineCore(Line line, IntPtr pbrLineIn, FormattingContext ctx, int dcp, int width, bool firstLine, int dcpLine);
    internal void FormatLineCore(Line line, IntPtr pbrLineIn, FormattingContext ctx, int dcp, int width, int trackWidth, bool firstLine, int dcpLine);
    internal Size MeasureChild(InlineObjectRun inlineObject);
    internal bool HasFiguresFloatersOrInlineObjects();
    internal bool HasFiguresOrFloaters();
    internal void UpdateTextContentRangeFromAttachedObjects(TextContentRange textContentRange, int dcpFirst, int dcpLast, FSATTACHEDOBJECTDESCRIPTION[] arrayAttachedObjectDesc);
    internal void OnUIElementDesiredSizeChanged(object sender, DesiredSizeChangedEventArgs e);
    internal TextRunCache get_TextRunCache();
    internal LineProperties get_Properties();
    internal bool get_IsOptimalParagraph();
}
internal class MS.Internal.PtsHost.TextParaLineResult : LineResult {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal int DcpLast { get; internal set; }
    internal TextParaLineResult(TextParaClient owner, int dcp, int cch, Rect layoutBox, double baseline);
    internal virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual ITextPointer GetContentEndPosition();
    internal virtual ITextPointer GetEllipsesPosition();
    internal virtual int GetContentEndPositionCP();
    internal virtual int GetEllipsesPositionCP();
    internal virtual ITextPointer get_StartPosition();
    internal virtual ITextPointer get_EndPosition();
    internal virtual int get_StartPositionCP();
    internal virtual int get_EndPositionCP();
    internal virtual Rect get_LayoutBox();
    internal virtual double get_Baseline();
    internal int get_DcpLast();
    internal void set_DcpLast(int value);
}
internal class MS.Internal.PtsHost.UIElementParaClient : FloaterBaseParaClient {
    internal UIElementParaClient(FloaterBaseParagraph paragraph);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnArrange();
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual TextContentRange GetTextContentRange();
}
internal class MS.Internal.PtsHost.UIElementParagraph : FloaterBaseParagraph {
    internal UIElementIsland UIElementIsland { get; }
    internal UIElementParagraph(TextElement element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    internal virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    internal UIElementIsland get_UIElementIsland();
}
internal class MS.Internal.PtsHost.UnmanagedHandle : object {
    internal IntPtr Handle { get; }
    internal PtsContext PtsContext { get; }
    protected UnmanagedHandle(PtsContext ptsContext);
    public virtual void Dispose();
    internal IntPtr get_Handle();
    internal PtsContext get_PtsContext();
}
internal static class MS.Internal.PtsHost.UnsafeNativeMethods.PTS : object {
    internal static int True;
    internal static int False;
    internal static int dvBottomUndefined;
    internal static int MaxFontSize;
    internal static int MaxPageSize;
    internal static int fsffiWordFlowTextFinite;
    internal static int fsffiWordClashFootnotesWithText;
    internal static int fsffiWordNewSectionAboveFootnotes;
    internal static int fsffiWordStopAfterFirstCollision;
    internal static int fsffiUseTextParaCache;
    internal static int fsffiKeepClientLines;
    internal static int fsffiUseTextQuickLoop;
    internal static int fsffiAvalonDisableOptimalInChains;
    internal static int fsffiWordAdjustTrackWidthsForFigureInWebView;
    internal static int fsidobjText;
    internal static int fsidobjFigure;
    internal static int fswdirDefault;
    internal static int fswdirES;
    internal static int fswdirEN;
    internal static int fswdirSE;
    internal static int fswdirSW;
    internal static int fswdirWS;
    internal static int fswdirWN;
    internal static int fswdirNE;
    internal static int fswdirNW;
    internal static int fUDirection;
    internal static int fVDirection;
    internal static int fUVertical;
    internal static int fserrNone;
    internal static int fserrOutOfMemory;
    internal static int fserrNotImplemented;
    internal static int fserrCallbackException;
    internal static int tserrNone;
    internal static int tserrInvalidParameter;
    internal static int tserrOutOfMemory;
    internal static int tserrNullOutputParameter;
    internal static int tserrInvalidLsContext;
    internal static int tserrInvalidLine;
    internal static int tserrInvalidDnode;
    internal static int tserrInvalidDeviceResolution;
    internal static int tserrInvalidRun;
    internal static int tserrMismatchLineContext;
    internal static int tserrContextInUse;
    internal static int tserrDuplicateSpecialCharacter;
    internal static int tserrInvalidAutonumRun;
    internal static int tserrFormattingFunctionDisabled;
    internal static int tserrUnfinishedDnode;
    internal static int tserrInvalidDnodeType;
    internal static int tserrInvalidPenDnode;
    internal static int tserrInvalidNonPenDnode;
    internal static int tserrInvalidBaselinePenDnode;
    internal static int tserrInvalidFormatterResult;
    internal static int tserrInvalidObjectIdFetched;
    internal static int tserrInvalidDcpFetched;
    internal static int tserrInvalidCpContentFetched;
    internal static int tserrInvalidBookmarkType;
    internal static int tserrSetDocDisabled;
    internal static int tserrFiniFunctionDisabled;
    internal static int tserrCurrentDnodeIsNotTab;
    internal static int tserrPendingTabIsNotResolved;
    internal static int tserrWrongFiniFunction;
    internal static int tserrInvalidBreakingClass;
    internal static int tserrBreakingTableNotSet;
    internal static int tserrInvalidModWidthClass;
    internal static int tserrModWidthPairsNotSet;
    internal static int tserrWrongTruncationPoint;
    internal static int tserrWrongBreak;
    internal static int tserrDupInvalid;
    internal static int tserrRubyInvalidVersion;
    internal static int tserrTatenakayokoInvalidVersion;
    internal static int tserrWarichuInvalidVersion;
    internal static int tserrWarichuInvalidData;
    internal static int tserrCreateSublineDisabled;
    internal static int tserrCurrentSublineDoesNotExist;
    internal static int tserrCpOutsideSubline;
    internal static int tserrHihInvalidVersion;
    internal static int tserrInsufficientQueryDepth;
    internal static int tserrInvalidBreakRecord;
    internal static int tserrInvalidPap;
    internal static int tserrContradictoryQueryInput;
    internal static int tserrLineIsNotActive;
    internal static int tserrTooLongParagraph;
    internal static int tserrTooManyCharsToGlyph;
    internal static int tserrWrongHyphenationPosition;
    internal static int tserrTooManyPriorities;
    internal static int tserrWrongGivenCp;
    internal static int tserrWrongCpFirstForGetBreaks;
    internal static int tserrWrongJustTypeForGetBreaks;
    internal static int tserrWrongJustTypeForCreateLineGivenCp;
    internal static int tserrTooLongGlyphContext;
    internal static int tserrInvalidCharToGlyphMapping;
    internal static int tserrInvalidMathUsage;
    internal static int tserrInconsistentChp;
    internal static int tserrStoppedInSubline;
    internal static int tserrPenPositionCouldNotBeUsed;
    internal static int tserrDebugFlagsInShip;
    internal static int tserrInvalidOrderTabs;
    internal static int tserrSystemRestrictionsExceeded;
    internal static int tserrInvalidPtsContext;
    internal static int tserrInvalidClientOutput;
    internal static int tserrInvalidObjectOutput;
    internal static int tserrInvalidGeometry;
    internal static int tserrInvalidFootnoteRejector;
    internal static int tserrInvalidFootnoteInfo;
    internal static int tserrOutputArrayTooSmall;
    internal static int tserrWordNotSupportedInBottomless;
    internal static int tserrPageTooLong;
    internal static int tserrInvalidQuery;
    internal static int tserrWrongWritingDirection;
    internal static int tserrPageNotClearedForUpdate;
    internal static int tserrInternalError;
    internal static int tserrNotImplemented;
    internal static int tserrClientAbort;
    internal static int tserrPageSizeMismatch;
    internal static int tserrCallbackException;
    internal static int fsfdbgCheckVariantsConsistency;
    internal static void IgnoreError(int fserr);
    internal static void Validate(int fserr);
    internal static void Validate(int fserr, PtsContext ptsContext);
    internal static void ValidateAndTrace(int fserr, PtsContext ptsContext);
    internal static void ValidateHandle(object handle);
    internal static int FromBoolean(bool condition);
    internal static bool ToBoolean(int flag);
    internal static FSKWRAP WrapDirectionToFskwrap(WrapDirection wrapDirection);
    internal static FSKCLEAR WrapDirectionToFskclear(WrapDirection wrapDirection);
    internal static FlowDirection FswdirToFlowDirection(UInt32 fswdir);
    internal static UInt32 FlowDirectionToFswdir(FlowDirection fd);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetFloaterHandlerInfo(FSFLOATERINIT& pfsfloaterinit, IntPtr pFloaterObjectInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int GetTableObjHandlerInfo(FSTABLEOBJINIT& pfstableobjinit, IntPtr pTableObjectInfo);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CreateInstalledObjectsInfo(FSIMETHODS& fssubtrackparamethods, FSIMETHODS& fssubpageparamethods, IntPtr& pInstalledObjects, Int32& cInstalledObjects);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DestroyInstalledObjectsInfo(IntPtr pInstalledObjects);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int CreateDocContext(FSCONTEXTINFO& fscontextinfo, IntPtr& pfscontext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int DestroyDocContext(IntPtr pfscontext);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCreatePageFinite(IntPtr pfscontext, IntPtr pfsBRPageStart, IntPtr fsnmSectStart, FSFMTR& pfsfmtrOut, IntPtr& ppfsPageOut, IntPtr& ppfsBRPageOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsUpdateFinitePage(IntPtr pfscontext, IntPtr pfspage, IntPtr pfsBRPageStart, IntPtr fsnmSectStart, FSFMTR& pfsfmtrOut, IntPtr& ppfsBRPageOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCreatePageBottomless(IntPtr pfscontext, IntPtr fsnmsect, FSFMTRBL& pfsfmtrbl, IntPtr& ppfspage);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsUpdateBottomlessPage(IntPtr pfscontext, IntPtr pfspage, IntPtr fsnmsect, FSFMTRBL& pfsfmtrbl);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsClearUpdateInfoInPage(IntPtr pfscontext, IntPtr pfspage);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroyPage(IntPtr pfscontext, IntPtr pfspage);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroyPageBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCreateSubpageFinite(IntPtr pfsContext, IntPtr pBRSubPageStart, int fFromPreviousPage, IntPtr nSeg, IntPtr pFtnRej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int lHeight, FSRECT& rcMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int fApplyColumnBalancing, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fAllowOverhangBottom, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pSubPage, IntPtr& pBRSubPageOut, Int32& dvrUsed, FSBBOX& fsBBox, IntPtr& pfsMcsClient, Int32& topSpace);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCreateSubpageBottomless(IntPtr pfsContext, IntPtr nSeg, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int urMargin, int durMargin, int vrMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fINterrruptible, FSFMTRBL& pfsfmtr, IntPtr& ppSubPage, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& pfsMcsClient, Int32& pTopSpace, Int32& fPageBecomesUninterruptible);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsUpdateBottomlessSubpage(IntPtr pfsContext, IntPtr pfsSubpage, IntPtr nmSeg, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int urMargin, int durMargin, int vrMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fINterrruptible, FSFMTRBL& pfsfmtr, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& pfsMcsClient, Int32& pTopSpace, Int32& fPageBecomesUninterruptible);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCompareSubpages(IntPtr pfsContext, IntPtr pfsSubpageOld, IntPtr pfsSubpageNew, FSCOMPRESULT& fsCompResult);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsClearUpdateInfoInSubpage(IntPtr pfscontext, IntPtr pSubpage);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroySubpage(IntPtr pfsContext, IntPtr pSubpage);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDuplicateSubpageBreakRecord(IntPtr pfsContext, IntPtr pBreakRecSubPageIn, IntPtr& ppBreakRecSubPageOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroySubpageBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsGetSubpageColumnBalancingInfo(IntPtr pfsContext, IntPtr pSubpage, UInt32& fswdir, Int32& lLineNumber, Int32& lLineHeights, Int32& lMinimumLineHeight);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsGetNumberSubpageFootnotes(IntPtr pfsContext, IntPtr pSubpage, Int32& cFootnotes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsGetSubpageFootnoteInfo(IntPtr pfsContext, IntPtr pSubpage, int cArraySize, int indexStart, UInt32& fswdir, FSFTNINFO* rgFootnoteInfo, Int32& indexLim);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsTransferDisplayInfoSubpage(IntPtr pfsContext, IntPtr pSubpageOld, IntPtr pfsSubpageNew);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsFormatSubtrackFinite(IntPtr pfsContext, IntPtr pfsBRSubtackIn, int fFromPreviousPage, IntPtr fsnmSegment, int iArea, IntPtr pfsFtnRej, IntPtr pfsGeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsRectToFill, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstpara, FSFMTR& pfsfmtr, IntPtr& ppfsSubtrack, IntPtr& pfsBRSubtrackOut, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsFormatSubtrackBottomless(IntPtr pfsContext, IntPtr fsnmSegment, int iArea, IntPtr pfsGeom, int fSuppressTopSpace, UInt32 fswdir, int ur, int dur, int vr, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, int fCanBeInterruptedIn, FSFMTRBL& pfsfmtrbl, IntPtr& ppfsSubtrack, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace, Int32& pfCanBeInterruptedOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsUpdateBottomlessSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack, IntPtr fsnmSegment, int iArea, IntPtr pfsGeom, int fSuppressTopSpace, UInt32 fswdir, int ur, int dur, int vr, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, int fCanBeInterruptedIn, FSFMTRBL& pfsfmtrbl, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace, Int32& pfCanBeInterruptedOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsSynchronizeBottomlessSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack, IntPtr pfsGeom, UInt32 fswdir, int vrShift);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsCompareSubtrack(IntPtr pfsContext, IntPtr pfsSubtrackOld, IntPtr pfsSubtrackNew, UInt32 fswdir, FSCOMPRESULT& fsCompResult, Int32& dvrShifted);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsClearUpdateInfoInSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroySubtrack(IntPtr pfsContext, IntPtr pfsSubtrack);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDuplicateSubtrackBreakRecord(IntPtr pfsContext, IntPtr pfsBRSubtrackIn, IntPtr& ppfsBRSubtrackOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsDestroySubtrackBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsGetSubtrackColumnBalancingInfo(IntPtr pfscontext, IntPtr pfsSubtrack, UInt32 fswdir, Int32& lLineNumber, Int32& lLineHeights, Int32& lMinimumLineHeight);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsGetNumberSubtrackFootnotes(IntPtr pfscontext, IntPtr pfsSubtrack, Int32& cFootnotes);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsTransferDisplayInfoSubtrack(IntPtr pfscontext, IntPtr pfsSubtrackOld, IntPtr pfsSubtrackNew);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryFloaterDetails(IntPtr pfsContext, IntPtr pfsfloater, FSFLOATERDETAILS& fsfloaterdetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryPageDetails(IntPtr pfsContext, IntPtr pPage, FSPAGEDETAILS& pPageDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryPageSectionList(IntPtr pfsContext, IntPtr pPage, int cArraySize, FSSECTIONDESCRIPTION* rgSectionDescription, Int32& cActualSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySectionDetails(IntPtr pfsContext, IntPtr pSection, FSSECTIONDETAILS& pSectionDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySectionBasicColumnList(IntPtr pfsContext, IntPtr pSection, int cArraySize, FSTRACKDESCRIPTION* rgColumnDescription, Int32& cActualSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTrackDetails(IntPtr pfsContext, IntPtr pTrack, FSTRACKDETAILS& pTrackDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTrackParaList(IntPtr pfsContext, IntPtr pTrack, int cParas, FSPARADESCRIPTION* rgParaDesc, Int32& cParaDesc);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySubpageDetails(IntPtr pfsContext, IntPtr pSubPage, FSSUBPAGEDETAILS& pSubPageDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySubpageBasicColumnList(IntPtr pfsContext, IntPtr pSubPage, int cArraySize, FSTRACKDESCRIPTION* rgColumnDescription, Int32& cActualSize);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySubtrackDetails(IntPtr pfsContext, IntPtr pSubTrack, FSSUBTRACKDETAILS& pSubTrackDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQuerySubtrackParaList(IntPtr pfsContext, IntPtr pSubTrack, int cParas, FSPARADESCRIPTION* rgParaDesc, Int32& cParaDesc);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTextDetails(IntPtr pfsContext, IntPtr pPara, FSTEXTDETAILS& pTextDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryLineListSingle(IntPtr pfsContext, IntPtr pPara, int cLines, FSLINEDESCRIPTIONSINGLE* rgLineDesc, Int32& cLineDesc);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryLineListComposite(IntPtr pfsContext, IntPtr pPara, int cElements, FSLINEDESCRIPTIONCOMPOSITE* rgLineDescription, Int32& cLineElements);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryLineCompositeElementList(IntPtr pfsContext, IntPtr pLine, int cElements, FSLINEELEMENT* rgLineElement, Int32& cLineElements);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryAttachedObjectList(IntPtr pfsContext, IntPtr pPara, int cAttachedObject, FSATTACHEDOBJECTDESCRIPTION* rgAttachedObjects, Int32& cAttachedObjectDesc);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryFigureObjectDetails(IntPtr pfsContext, IntPtr pPara, FSFIGUREDETAILS& fsFigureDetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTableObjDetails(IntPtr pfscontext, IntPtr pfstableobj, FSTABLEOBJDETAILS& pfstableobjdetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTableObjTableProperDetails(IntPtr pfscontext, IntPtr pfstableProper, FSTABLEDETAILS& pfstabledetailsProper);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTableObjRowList(IntPtr pfscontext, IntPtr pfstableProper, int cRows, FSTABLEROWDESCRIPTION* rgtablerowdescr, Int32& pcRowsActual);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTableObjRowDetails(IntPtr pfscontext, IntPtr pfstablerow, FSTABLEROWDETAILS& ptableorowdetails);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsQueryTableObjCellList(IntPtr pfscontext, IntPtr pfstablerow, int cCells, FSKUPDATE* rgfskupd, IntPtr* rgpfscell, FSTABLEKCELLMERGE* rgkcellmerge, Int32& pcCellsActual);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsTransformRectangle(UInt32 fswdirIn, FSRECT& rectPage, FSRECT& rectTransform, UInt32 fswdirOut, FSRECT& rectOut);
    [SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static int FsTransformBbox(UInt32 fswdirIn, FSRECT& rectPage, FSBBOX& bboxTransform, UInt32 fswdirOut, FSBBOX& bboxOut);
}
internal class MS.Internal.PtsHost.UpdateRecord : object {
    internal DirtyTextRange Dtr;
    internal BaseParagraph FirstPara;
    internal BaseParagraph SyncPara;
    internal FSKCHANGE ChangeType;
    internal UpdateRecord Next;
    internal bool InProcessing;
    internal void MergeWithNext();
}
internal class MS.Internal.PtsTable.CalculatedColumn : ValueType {
    private GridLength _userWidth;
    private double _durWidth;
    private double _durMinWidth;
    private double _durMaxWidth;
    private double _urOffset;
    private Flags _flags;
    internal int PtsWidthChanged { get; }
    internal double DurMinWidth { get; }
    internal double DurMaxWidth { get; }
    internal GridLength UserWidth { get; internal set; }
    internal double DurWidth { get; internal set; }
    internal double UrOffset { get; internal set; }
    internal void ValidateAuto(double durMinWidth, double durMaxWidth);
    internal int get_PtsWidthChanged();
    internal double get_DurMinWidth();
    internal double get_DurMaxWidth();
    internal GridLength get_UserWidth();
    internal void set_UserWidth(GridLength value);
    internal double get_DurWidth();
    internal void set_DurWidth(double value);
    internal double get_UrOffset();
    internal void set_UrOffset(double value);
}
internal class MS.Internal.PtsTable.RowSpanVector : object {
    private static RowSpanVector();
    internal void Register(TableCell cell);
    internal void GetFirstAvailableRange(Int32& firstAvailableIndex, Int32& firstOccupiedIndex);
    internal void GetNextAvailableRange(Int32& firstAvailableIndex, Int32& firstOccupiedIndex);
    internal void GetSpanCells(TableCell[]& cells, Boolean& isLastRowOfAnySpan);
    internal bool Empty();
}
internal class MS.Internal.SecurityMgrSite : object {
    [SecurityCriticalAttribute]
public sealed virtual void GetWindow(IntPtr& phwnd);
    public sealed virtual void EnableModeless(bool fEnable);
}
internal static class MS.Internal.SystemCoreHelper : object {
    internal static bool IsIDynamicMetaObjectProvider(object item);
    internal static object NewDynamicPropertyAccessor(Type ownerType, string propertyName);
    internal static object GetIndexerAccessor(int rank);
}
internal static class MS.Internal.SystemDataHelper : object {
    internal static bool IsDataView(IBindingList list);
    internal static bool IsDataRowView(object item);
    internal static bool IsSqlNull(object value);
    internal static bool IsSqlNullableType(Type type);
    internal static bool IsDataSetCollectionProperty(PropertyDescriptor pd);
    internal static object GetValue(object item, PropertyDescriptor pd, bool useFollowParent);
    internal static bool DetermineWhetherDBNullIsValid(object item, string columnName, object arg);
    internal static object NullValueForSqlNullableType(Type type);
}
internal static class MS.Internal.SystemXmlHelper : object {
    internal static bool IsXmlNode(object item);
    internal static bool IsXmlNamespaceManager(object item);
    internal static bool TryGetValueFromXmlNode(object item, string name, Object& value);
    internal static IComparer PrepareXmlComparer(IEnumerable collection, SortDescriptionCollection sort, CultureInfo culture);
    internal static bool IsEmptyXmlDataCollection(object parent);
    internal static string GetXmlTagName(object item, DependencyObject target);
    internal static object FindXmlNodeWithInnerText(IEnumerable items, object innerText, Int32& index);
    internal static object GetInnerText(object item);
}
internal static class MS.Internal.SystemXmlLinqHelper : object {
    internal static bool IsXElement(object item);
    internal static string GetXElementTagName(object item);
    internal static bool IsXLinqCollectionProperty(PropertyDescriptor pd);
    internal static bool IsXLinqNonIdempotentProperty(PropertyDescriptor pd);
}
internal static class MS.Internal.Telemetry.NetFxVersionTraceLogger : object {
    private static NetFxVersionTraceLogger();
    internal static void LogVersionDetails();
}
internal static class MS.Internal.Telemetry.PresentationFramework.ControlsTraceLogger : object {
    private static ControlsTraceLogger();
    internal static void LogUsedControlsDetails();
    internal static void AddControl(TelemetryControls control);
}
internal class MS.Internal.Telemetry.PresentationFramework.EventSourceActivity : object {
    private Guid _id;
    internal EventSource EventSource { get; }
    internal Guid Id { get; }
    internal EventSourceActivity(EventSource eventSource);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions, Guid parentActivityId);
    internal EventSourceActivity(EventSourceActivity parentActivity);
    internal EventSourceActivity(EventSourceActivity parentActivity, EventSourceOptions startStopOptions);
    internal EventSource get_EventSource();
    internal Guid get_Id();
    internal void Start(string eventName);
    internal void Start(string eventName, T data);
    internal void Stop(string eventName);
    internal void Stop(string eventName, T data);
    internal void Write(string eventName);
    internal void Write(string eventName, EventSourceOptions options);
    internal void Write(string eventName, T data);
    internal void Write(string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
}
[FlagsAttribute]
internal enum MS.Internal.Telemetry.PresentationFramework.TelemetryControls : Enum {
    public long value__;
    public static TelemetryControls None;
    public static TelemetryControls Border;
    public static TelemetryControls Button;
    public static TelemetryControls Calendar;
    public static TelemetryControls Canvas;
    public static TelemetryControls CheckBox;
    public static TelemetryControls ComboBox;
    public static TelemetryControls ContentControl;
    public static TelemetryControls DataGrid;
    public static TelemetryControls DatePicker;
    public static TelemetryControls DockPanel;
    public static TelemetryControls DocumentViewer;
    public static TelemetryControls Expander;
    public static TelemetryControls Frame;
    public static TelemetryControls Grid;
    public static TelemetryControls GridSplitter;
    public static TelemetryControls GroupBox;
    public static TelemetryControls Image;
    public static TelemetryControls Label;
    public static TelemetryControls ListBox;
    public static TelemetryControls ListView;
    public static TelemetryControls MediaElement;
    public static TelemetryControls Menu;
    public static TelemetryControls PasswordBox;
    public static TelemetryControls ProgressBar;
    public static TelemetryControls RadioButton;
    public static TelemetryControls RichTextBox;
    public static TelemetryControls ScrollBar;
    public static TelemetryControls ScrollViewer;
    public static TelemetryControls Separator;
    public static TelemetryControls Slider;
    public static TelemetryControls StackPanel;
    public static TelemetryControls StatusBar;
    public static TelemetryControls TabControl;
    public static TelemetryControls TextBlock;
    public static TelemetryControls TextBox;
    public static TelemetryControls ToolBar;
    public static TelemetryControls ToolBarPanel;
    public static TelemetryControls ToolBarTray;
    public static TelemetryControls TreeView;
    public static TelemetryControls ViewBox;
    public static TelemetryControls WebBrowser;
    public static TelemetryControls WrapPanel;
    public static TelemetryControls FlowDocument;
}
internal class MS.Internal.Telemetry.PresentationFramework.TelemetryEventSource : EventSource {
    internal static EventKeywords Reserved44Keyword;
    internal static EventKeywords TelemetryKeyword;
    internal static EventKeywords MeasuresKeyword;
    internal static EventKeywords CriticalDataKeyword;
    internal static EventTags CoreData;
    internal static EventTags InjectXToken;
    internal static EventTags RealtimeLatency;
    internal static EventTags NormalLatency;
    internal static EventTags CriticalPersistence;
    internal static EventTags NormalPersistence;
    internal static EventTags DropPii;
    internal static EventTags HashPii;
    internal static EventTags MarkPii;
    internal static EventFieldTags DropPiiField;
    internal static EventFieldTags HashPiiField;
    internal TelemetryEventSource(string eventSourceName);
    private static TelemetryEventSource();
    internal static EventSourceOptions TelemetryOptions();
    internal static EventSourceOptions MeasuresOptions();
    internal static EventSourceOptions CriticalDataOptions();
}
internal static class MS.Internal.Telemetry.PresentationFramework.TraceLoggingProvider : object {
    private static TraceLoggingProvider();
    internal static EventSource GetProvider();
}
internal class MS.Internal.Text.ComplexLine : Line {
    internal ComplexLine(TextBlock owner);
    private static ComplexLine();
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    internal virtual void Arrange(VisualCollection vc, Vector lineOffset);
    internal virtual bool HasInlineObjects();
    internal virtual IInputElement InputHitTest(double offset);
}
internal static class MS.Internal.Text.DynamicPropertyReader : object {
    internal static Typeface GetTypeface(DependencyObject element);
    internal static Typeface GetModifiedTypeface(DependencyObject element, FontFamily fontFamily);
    internal static TextDecorationCollection GetTextDecorationsForInlineObject(DependencyObject element, TextDecorationCollection textDecorations);
    internal static TextDecorationCollection GetTextDecorations(DependencyObject element);
    internal static TextEffectCollection GetTextEffects(DependencyObject element);
    internal static bool GetKeepTogether(DependencyObject element);
    internal static bool GetKeepWithNext(DependencyObject element);
    internal static int GetMinWidowLines(DependencyObject element);
    internal static int GetMinOrphanLines(DependencyObject element);
    internal static double GetLineHeightValue(DependencyObject d);
    internal static Brush GetBackgroundBrush(DependencyObject element);
    internal static Brush GetBackgroundBrushForInlineObject(StaticTextPointer position);
    internal static BaselineAlignment GetBaselineAlignment(DependencyObject element);
    internal static BaselineAlignment GetBaselineAlignmentForInlineObject(DependencyObject element);
    internal static CultureInfo GetCultureInfo(DependencyObject element);
    internal static NumberSubstitution GetNumberSubstitution(DependencyObject element);
}
internal class MS.Internal.Text.InlineObject : TextEmbeddedObject {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    internal int Dcp { get; }
    internal UIElement Element { get; }
    internal InlineObject(int dcp, int cch, UIElement element, TextRunProperties textProps, TextBlock host);
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    internal int get_Dcp();
    internal UIElement get_Element();
}
internal abstract class MS.Internal.Text.Line : TextSource {
    protected TextBlock _owner;
    protected TextLine _line;
    protected int _dcp;
    protected static int _syntheticCharacterLength;
    protected bool _mirror;
    protected TextAlignment _textAlignment;
    protected bool _showParagraphEllipsis;
    protected double _wrappingWidth;
    internal double Width { get; }
    internal double Start { get; }
    internal double Height { get; }
    internal double BaselineOffset { get; }
    internal bool EndOfParagraph { get; }
    internal int Length { get; }
    internal int ContentLength { get; }
    protected bool ShowEllipsis { get; }
    protected bool HasLineBreak { get; }
    protected bool IsXOffsetAdjusted { get; }
    protected bool IsWidthAdjusted { get; }
    internal Line(TextBlock owner);
    private static Line();
    public sealed virtual void Dispose();
    internal void Format(int dcp, double width, TextParagraphProperties lineProperties, TextLineBreak textLineBreak, TextRunCache textRunCache, bool showParagraphEllipsis);
    internal virtual void Arrange(VisualCollection vc, Vector lineOffset);
    internal void Render(DrawingContext ctx, Point lineOffset);
    internal Rect GetBoundsFromTextPosition(int characterIndex, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal CharacterHit GetTextPositionFromDistance(double distance);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal virtual bool HasInlineObjects();
    internal virtual IInputElement InputHitTest(double offset);
    internal TextLineBreak GetTextLineBreak();
    internal int GetEllipsesLength();
    internal double GetCollapsedWidth();
    internal double get_Width();
    internal double get_Start();
    internal double get_Height();
    internal double get_BaselineOffset();
    internal bool get_EndOfParagraph();
    internal int get_Length();
    internal int get_ContentLength();
    protected Rect GetBoundsFromPosition(int cp, int cch, FlowDirection& flowDirection);
    protected TextCollapsingProperties GetCollapsingProps(double wrappingWidth, LineProperties paraProperties);
    protected double CalculateXOffsetShift();
    protected bool get_ShowEllipsis();
    protected bool get_HasLineBreak();
    protected bool get_IsXOffsetAdjusted();
    protected bool get_IsWidthAdjusted();
}
internal class MS.Internal.Text.LineMetrics : ValueType {
    private UInt32 _packedData;
    private double _width;
    private double _height;
    private double _start;
    private double _baseline;
    private TextLineBreak _textLineBreak;
    internal int Length { get; }
    internal double Width { get; }
    internal double Height { get; }
    internal double Start { get; }
    internal double Baseline { get; }
    internal bool HasInlineObjects { get; }
    internal TextLineBreak TextLineBreak { get; }
    internal LineMetrics(int length, double width, double height, double baseline, bool hasInlineObjects, TextLineBreak textLineBreak);
    internal LineMetrics(LineMetrics source, double start, double width);
    private static LineMetrics();
    internal LineMetrics Dispose(bool returnUpdatedMetrics);
    internal int get_Length();
    internal double get_Width();
    internal double get_Height();
    internal double get_Start();
    internal double get_Baseline();
    internal bool get_HasInlineObjects();
    internal TextLineBreak get_TextLineBreak();
}
internal class MS.Internal.Text.LineProperties : TextParagraphProperties {
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    internal TextAlignment TextAlignmentInternal { get; }
    internal bool IgnoreTextAlignment { get; internal set; }
    internal LineStackingStrategy LineStackingStrategy { get; }
    internal TextTrimming TextTrimming { get; }
    internal bool HasFirstLineProperties { get; }
    internal TextParagraphProperties FirstLineProps { get; }
    internal LineProperties(DependencyObject element, DependencyObject contentHost, TextProperties defaultTextProperties, MarkerProperties markerProperties);
    internal LineProperties(DependencyObject element, DependencyObject contentHost, TextProperties defaultTextProperties, MarkerProperties markerProperties, TextAlignment textAlignment);
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    public virtual bool get_FirstLineInParagraph();
    public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual TextWrapping get_TextWrapping();
    public virtual TextMarkerProperties get_TextMarkerProperties();
    public virtual double get_Indent();
    internal double CalcLineAdvanceForTextParagraph(TextParagraph textParagraph, int dcp, double lineAdvance);
    internal double CalcLineAdvance(double lineAdvance);
    internal TextAlignment get_TextAlignmentInternal();
    internal bool get_IgnoreTextAlignment();
    internal void set_IgnoreTextAlignment(bool value);
    internal LineStackingStrategy get_LineStackingStrategy();
    internal TextTrimming get_TextTrimming();
    internal bool get_HasFirstLineProperties();
    internal TextParagraphProperties get_FirstLineProps();
    internal TextParagraphProperties GetParaEllipsisLineProps(bool firstLine);
}
internal class MS.Internal.Text.MarkerProperties : object {
    internal MarkerProperties(List list, int index);
    internal TextMarkerProperties GetTextMarkerProperties(TextParagraphProperties textParaProps);
}
internal class MS.Internal.Text.SimpleLine : Line {
    internal SimpleLine(TextBlock owner, string content, TextRunProperties textProps);
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
}
internal static class MS.Internal.Text.TextDpi : object {
    internal static double MinWidth { get; }
    internal static double MaxWidth { get; }
    internal static double get_MinWidth();
    internal static double get_MaxWidth();
    internal static int ToTextDpi(double d);
    internal static double FromTextDpi(int i);
    internal static FSPOINT ToTextPoint(Point point);
    internal static FSVECTOR ToTextSize(Size size);
    internal static Rect FromTextRect(FSRECT fsrect);
    internal static void EnsureValidLineOffset(Double& offset);
    internal static void SnapToTextDpi(Size& size);
    internal static void EnsureValidLineWidth(Double& width);
    internal static void EnsureValidLineWidth(Size& size);
    internal static void EnsureValidLineWidth(Int32& width);
    internal static void EnsureValidPageSize(Size& size);
    internal static void EnsureValidPageWidth(Double& width);
    internal static void EnsureValidPageMargin(Thickness& pageMargin, Size pageSize);
    internal static void EnsureValidObjSize(Size& size);
}
internal class MS.Internal.Text.TextLineResult : LineResult {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal TextLineResult(TextBlock owner, int dcp, int cch, Rect layoutBox, double baseline, int index);
    internal virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual ITextPointer GetContentEndPosition();
    internal virtual ITextPointer GetEllipsesPosition();
    internal virtual int GetContentEndPositionCP();
    internal virtual int GetEllipsesPositionCP();
    internal virtual ITextPointer get_StartPosition();
    internal virtual ITextPointer get_EndPosition();
    internal virtual int get_StartPositionCP();
    internal virtual int get_EndPositionCP();
    internal virtual Rect get_LayoutBox();
    internal virtual double get_Baseline();
}
internal class MS.Internal.Text.TextProperties : TextRunProperties {
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public TextEffectCollection TextEffects { get; }
    internal TextProperties(FrameworkElement target, bool isTypographyDefaultValue);
    internal TextProperties(DependencyObject target, StaticTextPointer position, bool inlineObjects, bool getBackground, double pixelsPerDip);
    internal TextProperties(TextProperties source, TextDecorationCollection textDecorations);
    public virtual Typeface get_Typeface();
    public virtual double get_FontRenderingEmSize();
    public virtual double get_FontHintingEmSize();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual Brush get_ForegroundBrush();
    public virtual Brush get_BackgroundBrush();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual CultureInfo get_CultureInfo();
    public virtual NumberSubstitution get_NumberSubstitution();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual TextEffectCollection get_TextEffects();
    internal void SetBackgroundBrush(Brush backgroundBrush);
    internal void SetForegroundBrush(Brush foregroundBrush);
}
internal class MS.Internal.Text.TextSpanModifier : TextModifier {
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public bool HasDirectionalEmbedding { get; }
    public FlowDirection FlowDirection { get; }
    public TextSpanModifier(int length, TextDecorationCollection textDecorations, Brush foregroundBrush);
    public TextSpanModifier(int length, TextDecorationCollection textDecorations, Brush foregroundBrush, FlowDirection flowDirection);
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    public sealed virtual TextRunProperties ModifyProperties(TextRunProperties properties);
    public virtual bool get_HasDirectionalEmbedding();
    public virtual FlowDirection get_FlowDirection();
}
internal class MS.Internal.Text.TypographyProperties : TextRunTypographyProperties {
    public bool StandardLigatures { get; }
    public bool ContextualLigatures { get; }
    public bool DiscretionaryLigatures { get; }
    public bool HistoricalLigatures { get; }
    public bool CaseSensitiveForms { get; }
    public bool ContextualAlternates { get; }
    public bool HistoricalForms { get; }
    public bool Kerning { get; }
    public bool CapitalSpacing { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public FontFraction Fraction { get; }
    public bool SlashedZero { get; }
    public bool MathematicalGreek { get; }
    public bool EastAsianExpertForms { get; }
    public FontVariants Variants { get; }
    public FontCapitals Capitals { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public int StandardSwashes { get; }
    public int ContextualSwashes { get; }
    public int StylisticAlternates { get; }
    public int AnnotationAlternates { get; }
    public virtual bool get_StandardLigatures();
    public void SetStandardLigatures(bool value);
    public virtual bool get_ContextualLigatures();
    public void SetContextualLigatures(bool value);
    public virtual bool get_DiscretionaryLigatures();
    public void SetDiscretionaryLigatures(bool value);
    public virtual bool get_HistoricalLigatures();
    public void SetHistoricalLigatures(bool value);
    public virtual bool get_CaseSensitiveForms();
    public void SetCaseSensitiveForms(bool value);
    public virtual bool get_ContextualAlternates();
    public void SetContextualAlternates(bool value);
    public virtual bool get_HistoricalForms();
    public void SetHistoricalForms(bool value);
    public virtual bool get_Kerning();
    public void SetKerning(bool value);
    public virtual bool get_CapitalSpacing();
    public void SetCapitalSpacing(bool value);
    public virtual bool get_StylisticSet1();
    public void SetStylisticSet1(bool value);
    public virtual bool get_StylisticSet2();
    public void SetStylisticSet2(bool value);
    public virtual bool get_StylisticSet3();
    public void SetStylisticSet3(bool value);
    public virtual bool get_StylisticSet4();
    public void SetStylisticSet4(bool value);
    public virtual bool get_StylisticSet5();
    public void SetStylisticSet5(bool value);
    public virtual bool get_StylisticSet6();
    public void SetStylisticSet6(bool value);
    public virtual bool get_StylisticSet7();
    public void SetStylisticSet7(bool value);
    public virtual bool get_StylisticSet8();
    public void SetStylisticSet8(bool value);
    public virtual bool get_StylisticSet9();
    public void SetStylisticSet9(bool value);
    public virtual bool get_StylisticSet10();
    public void SetStylisticSet10(bool value);
    public virtual bool get_StylisticSet11();
    public void SetStylisticSet11(bool value);
    public virtual bool get_StylisticSet12();
    public void SetStylisticSet12(bool value);
    public virtual bool get_StylisticSet13();
    public void SetStylisticSet13(bool value);
    public virtual bool get_StylisticSet14();
    public void SetStylisticSet14(bool value);
    public virtual bool get_StylisticSet15();
    public void SetStylisticSet15(bool value);
    public virtual bool get_StylisticSet16();
    public void SetStylisticSet16(bool value);
    public virtual bool get_StylisticSet17();
    public void SetStylisticSet17(bool value);
    public virtual bool get_StylisticSet18();
    public void SetStylisticSet18(bool value);
    public virtual bool get_StylisticSet19();
    public void SetStylisticSet19(bool value);
    public virtual bool get_StylisticSet20();
    public void SetStylisticSet20(bool value);
    public virtual FontFraction get_Fraction();
    public void SetFraction(FontFraction value);
    public virtual bool get_SlashedZero();
    public void SetSlashedZero(bool value);
    public virtual bool get_MathematicalGreek();
    public void SetMathematicalGreek(bool value);
    public virtual bool get_EastAsianExpertForms();
    public void SetEastAsianExpertForms(bool value);
    public virtual FontVariants get_Variants();
    public void SetVariants(FontVariants value);
    public virtual FontCapitals get_Capitals();
    public void SetCapitals(FontCapitals value);
    public virtual FontNumeralStyle get_NumeralStyle();
    public void SetNumeralStyle(FontNumeralStyle value);
    public virtual FontNumeralAlignment get_NumeralAlignment();
    public void SetNumeralAlignment(FontNumeralAlignment value);
    public virtual FontEastAsianWidths get_EastAsianWidths();
    public void SetEastAsianWidths(FontEastAsianWidths value);
    public virtual FontEastAsianLanguage get_EastAsianLanguage();
    public void SetEastAsianLanguage(FontEastAsianLanguage value);
    public virtual int get_StandardSwashes();
    public void SetStandardSwashes(int value);
    public virtual int get_ContextualSwashes();
    public void SetContextualSwashes(int value);
    public virtual int get_StylisticAlternates();
    public void SetStylisticAlternates(int value);
    public virtual int get_AnnotationAlternates();
    public void SetAnnotationAlternates(int value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(TypographyProperties first, TypographyProperties second);
    public static bool op_Inequality(TypographyProperties first, TypographyProperties second);
}
internal static class MS.Internal.TraceData : object {
    public static AvTraceDetails NoMentor { get; }
    public static AvTraceDetails NoDataContext { get; }
    public static AvTraceDetails BadValueAtTransfer { get; }
    public static AvTraceDetails WorkerUpdateFailed { get; }
    public static AvTraceDetails RequiresExplicitCulture { get; }
    public static AvTraceDetails NoValueToTransfer { get; }
    public static AvTraceDetails BindingGroupMultipleInheritance { get; }
    public static AvTraceDetails MissingDataItem { get; }
    public static AvTraceDetails MissingInfo { get; }
    public static AvTraceDetails NullDataItem { get; }
    public static AvTraceDetails ItemTemplateForDirectItem { get; }
    public static AvTraceDetails MultiValueConverterMissingForTransfer { get; }
    public static AvTraceDetails MultiValueConverterMissingForUpdate { get; }
    public static AvTraceDetails MultiValueConverterMismatch { get; }
    public static AvTraceDetails MultiBindingHasNoConverter { get; }
    public static AvTraceDetails ObjectDataProviderHasNoSource { get; }
    public static AvTraceDetails ObjDPCreateFailed { get; }
    public static AvTraceDetails ObjDPInvokeFailed { get; }
    public static AvTraceDetails RefPreviousNotInContext { get; }
    public static AvTraceDetails RefNoWrapperInChildren { get; }
    public static AvTraceDetails RefAncestorTypeNotSpecified { get; }
    public static AvTraceDetails RefAncestorLevelInvalid { get; }
    public static AvTraceDetails XmlBindingToNonXml { get; }
    public static AvTraceDetails XmlBindingToNonXmlCollection { get; }
    public static AvTraceDetails CannotGetXmlNodeCollection { get; }
    public static AvTraceDetails XmlDPInlineDocError { get; }
    public static AvTraceDetails XmlNamespaceNotSet { get; }
    public static AvTraceDetails XmlDPAsyncDocError { get; }
    public static AvTraceDetails XmlDPSelectNodesFailed { get; }
    public static AvTraceDetails CollectionViewIsUnsupported { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceData();
    public static bool IsExtendedTraceEnabled(object element, TraceDataLevel level);
    public static void OnTrace(AvTraceBuilder traceBuilder, Object[] parameters, int start);
    public static void Describe(AvTraceBuilder traceBuilder, object o);
    public static void DescribeSourceObject(AvTraceBuilder traceBuilder, object o);
    public static string DescribeSourceObject(object o);
    public static void DescribeTarget(AvTraceBuilder traceBuilder, DependencyObject targetElement, DependencyProperty targetProperty);
    public static string DescribeTarget(DependencyObject targetElement, DependencyProperty targetProperty);
    public static string Identify(object o);
    public static string IdentifyWeakEvent(Type type);
    public static string IdentifyAccessor(object accessor);
    public static string IdentifyException(Exception ex);
    public static AvTraceDetails CannotCreateDefaultValueConverter(Object[] args);
    public static AvTraceDetails get_NoMentor();
    public static AvTraceDetails get_NoDataContext();
    public static AvTraceDetails NoSource(Object[] args);
    public static AvTraceDetails get_BadValueAtTransfer();
    public static AvTraceDetails BadConverterForTransfer(Object[] args);
    public static AvTraceDetails BadConverterForUpdate(Object[] args);
    public static AvTraceDetails get_WorkerUpdateFailed();
    public static AvTraceDetails get_RequiresExplicitCulture();
    public static AvTraceDetails get_NoValueToTransfer();
    public static AvTraceDetails FallbackConversionFailed(Object[] args);
    public static AvTraceDetails TargetNullValueConversionFailed(Object[] args);
    public static AvTraceDetails BindingGroupNameMatchFailed(Object[] args);
    public static AvTraceDetails BindingGroupWrongProperty(Object[] args);
    public static AvTraceDetails get_BindingGroupMultipleInheritance();
    public static AvTraceDetails SharesProposedValuesRequriesImplicitBindingGroup(Object[] args);
    public static AvTraceDetails CannotGetClrRawValue(Object[] args);
    public static AvTraceDetails CannotSetClrRawValue(Object[] args);
    public static AvTraceDetails get_MissingDataItem();
    public static AvTraceDetails get_MissingInfo();
    public static AvTraceDetails get_NullDataItem();
    public static AvTraceDetails DefaultValueConverterFailed(Object[] args);
    public static AvTraceDetails DefaultValueConverterFailedForCulture(Object[] args);
    public static AvTraceDetails StyleAndStyleSelectorDefined(Object[] args);
    public static AvTraceDetails TemplateAndTemplateSelectorDefined(Object[] args);
    public static AvTraceDetails get_ItemTemplateForDirectItem();
    public static AvTraceDetails BadMultiConverterForUpdate(Object[] args);
    public static AvTraceDetails get_MultiValueConverterMissingForTransfer();
    public static AvTraceDetails get_MultiValueConverterMissingForUpdate();
    public static AvTraceDetails get_MultiValueConverterMismatch();
    public static AvTraceDetails get_MultiBindingHasNoConverter();
    public static AvTraceDetails UnsetValueInMultiBindingExpressionUpdate(Object[] args);
    public static AvTraceDetails get_ObjectDataProviderHasNoSource();
    public static AvTraceDetails get_ObjDPCreateFailed();
    public static AvTraceDetails get_ObjDPInvokeFailed();
    public static AvTraceDetails get_RefPreviousNotInContext();
    public static AvTraceDetails get_RefNoWrapperInChildren();
    public static AvTraceDetails get_RefAncestorTypeNotSpecified();
    public static AvTraceDetails get_RefAncestorLevelInvalid();
    public static AvTraceDetails ClrReplaceItem(Object[] args);
    public static AvTraceDetails NullItem(Object[] args);
    public static AvTraceDetails PlaceholderItem(Object[] args);
    public static AvTraceDetails DataErrorInfoFailed(Object[] args);
    public static AvTraceDetails DisallowTwoWay(Object[] args);
    public static AvTraceDetails get_XmlBindingToNonXml();
    public static AvTraceDetails get_XmlBindingToNonXmlCollection();
    public static AvTraceDetails get_CannotGetXmlNodeCollection();
    public static AvTraceDetails BadXPath(Object[] args);
    public static AvTraceDetails get_XmlDPInlineDocError();
    public static AvTraceDetails get_XmlNamespaceNotSet();
    public static AvTraceDetails get_XmlDPAsyncDocError();
    public static AvTraceDetails get_XmlDPSelectNodesFailed();
    public static AvTraceDetails get_CollectionViewIsUnsupported();
    public static AvTraceDetails CollectionChangedWithoutNotification(Object[] args);
    public static AvTraceDetails CannotSort(Object[] args);
    public static AvTraceDetails CreatedExpression(Object[] args);
    public static AvTraceDetails CreatedExpressionInParent(Object[] args);
    public static AvTraceDetails BindingPath(Object[] args);
    public static AvTraceDetails BindingXPathAndPath(Object[] args);
    public static AvTraceDetails ResolveDefaultMode(Object[] args);
    public static AvTraceDetails ResolveDefaultUpdate(Object[] args);
    public static AvTraceDetails AttachExpression(Object[] args);
    public static AvTraceDetails DetachExpression(Object[] args);
    public static AvTraceDetails UseMentor(Object[] args);
    public static AvTraceDetails DeferAttachToContext(Object[] args);
    public static AvTraceDetails SourceRequiresTreeContext(Object[] args);
    public static AvTraceDetails AttachToContext(Object[] args);
    public static AvTraceDetails PathRequiresTreeContext(Object[] args);
    public static AvTraceDetails NoMentorExtended(Object[] args);
    public static AvTraceDetails ContextElement(Object[] args);
    public static AvTraceDetails NullDataContext(Object[] args);
    public static AvTraceDetails RelativeSource(Object[] args);
    public static AvTraceDetails AncestorLookup(Object[] args);
    public static AvTraceDetails ElementNameQuery(Object[] args);
    public static AvTraceDetails ElementNameQueryTemplate(Object[] args);
    public static AvTraceDetails UseCVS(Object[] args);
    public static AvTraceDetails UseDataProvider(Object[] args);
    public static AvTraceDetails ActivateItem(Object[] args);
    public static AvTraceDetails Deactivate(Object[] args);
    public static AvTraceDetails GetRawValue(Object[] args);
    public static AvTraceDetails ConvertDBNull(Object[] args);
    public static AvTraceDetails UserConverter(Object[] args);
    public static AvTraceDetails NullConverter(Object[] args);
    public static AvTraceDetails DefaultConverter(Object[] args);
    public static AvTraceDetails FormattedValue(Object[] args);
    public static AvTraceDetails FormattingFailed(Object[] args);
    public static AvTraceDetails BadValueAtTransferExtended(Object[] args);
    public static AvTraceDetails UseFallback(Object[] args);
    public static AvTraceDetails TransferValue(Object[] args);
    public static AvTraceDetails UpdateRawValue(Object[] args);
    public static AvTraceDetails ValidationRuleFailed(Object[] args);
    public static AvTraceDetails UserConvertBack(Object[] args);
    public static AvTraceDetails DefaultConvertBack(Object[] args);
    public static AvTraceDetails Update(Object[] args);
    public static AvTraceDetails GotEvent(Object[] args);
    public static AvTraceDetails GotPropertyChanged(Object[] args);
    public static AvTraceDetails PriorityTransfer(Object[] args);
    public static AvTraceDetails ChildNotAttached(Object[] args);
    public static AvTraceDetails GetRawValueMulti(Object[] args);
    public static AvTraceDetails UserConvertBackMulti(Object[] args);
    public static AvTraceDetails GetValue(Object[] args);
    public static AvTraceDetails SetValue(Object[] args);
    public static AvTraceDetails ReplaceItemShort(Object[] args);
    public static AvTraceDetails ReplaceItemLong(Object[] args);
    public static AvTraceDetails GetInfo_Reuse(Object[] args);
    public static AvTraceDetails GetInfo_Null(Object[] args);
    public static AvTraceDetails GetInfo_Cache(Object[] args);
    public static AvTraceDetails GetInfo_Property(Object[] args);
    public static AvTraceDetails GetInfo_Indexer(Object[] args);
    public static AvTraceDetails XmlContextNode(Object[] args);
    public static AvTraceDetails XmlNewCollection(Object[] args);
    public static AvTraceDetails XmlSynchronizeCollection(Object[] args);
    public static AvTraceDetails SelectNodes(Object[] args);
    public static AvTraceDetails BeginQuery(Object[] args);
    public static AvTraceDetails QueryFinished(Object[] args);
    public static AvTraceDetails QueryResult(Object[] args);
    public static AvTraceDetails XmlLoadSource(Object[] args);
    public static AvTraceDetails XmlLoadDoc(Object[] args);
    public static AvTraceDetails XmlLoadInline(Object[] args);
    public static AvTraceDetails XmlBuildCollection(Object[] args);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal enum MS.Internal.TraceDataLevel : Enum {
    public int value__;
    public static TraceDataLevel CreateExpression;
    public static TraceDataLevel ShowPath;
    public static TraceDataLevel ResolveDefaults;
    public static TraceDataLevel Attach;
    public static TraceDataLevel AttachToContext;
    public static TraceDataLevel SourceLookup;
    public static TraceDataLevel Activate;
    public static TraceDataLevel Transfer;
    public static TraceDataLevel Update;
    public static TraceDataLevel Validation;
    public static TraceDataLevel Events;
    public static TraceDataLevel GetValue;
    public static TraceDataLevel ReplaceItem;
    public static TraceDataLevel GetInfo;
    public static TraceDataLevel ProviderQuery;
    public static TraceDataLevel XmlProvider;
    public static TraceDataLevel XmlBuildCollection;
}
internal static class MS.Internal.TraceHwndHost : object {
    public static AvTraceDetails HwndHostIn3D { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceHwndHost();
    public static AvTraceDetails get_HwndHostIn3D();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceMarkup : object {
    public static AvTraceDetails AddValueToAddChild { get; }
    public static AvTraceDetails AddValueToArray { get; }
    public static AvTraceDetails AddValueToDictionary { get; }
    public static AvTraceDetails AddValueToList { get; }
    public static AvTraceDetails BeginInit { get; }
    public static AvTraceDetails CreateMarkupExtension { get; }
    public static AvTraceDetails CreateObject { get; }
    public static AvTraceDetails EndInit { get; }
    public static AvTraceDetails Load { get; }
    public static AvTraceDetails ProcessConstructorParameter { get; }
    public static AvTraceDetails ProvideValue { get; }
    public static AvTraceDetails SetCPA { get; }
    public static AvTraceDetails SetPropertyValue { get; }
    public static AvTraceDetails ThrowException { get; }
    public static AvTraceDetails TypeConvert { get; }
    public static AvTraceDetails TypeConvertFallback { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceMarkup();
    public static AvTraceDetails get_AddValueToAddChild();
    public static AvTraceDetails get_AddValueToArray();
    public static AvTraceDetails get_AddValueToDictionary();
    public static AvTraceDetails get_AddValueToList();
    public static AvTraceDetails get_BeginInit();
    public static AvTraceDetails get_CreateMarkupExtension();
    public static AvTraceDetails get_CreateObject();
    public static AvTraceDetails get_EndInit();
    public static AvTraceDetails get_Load();
    public static AvTraceDetails get_ProcessConstructorParameter();
    public static AvTraceDetails get_ProvideValue();
    public static AvTraceDetails get_SetCPA();
    public static AvTraceDetails get_SetPropertyValue();
    public static AvTraceDetails get_ThrowException();
    public static AvTraceDetails get_TypeConvert();
    public static AvTraceDetails get_TypeConvertFallback();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TracePageFormatting : object {
    public static AvTraceDetails FormatPage { get; }
    public static AvTraceDetails PageFormattingError { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TracePageFormatting();
    public static AvTraceDetails get_FormatPage();
    public static AvTraceDetails get_PageFormattingError();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceResourceDictionary : object {
    public static AvTraceDetails AddResource { get; }
    public static AvTraceDetails RealizeDeferContent { get; }
    public static AvTraceDetails FoundResourceOnElement { get; }
    public static AvTraceDetails FoundResourceInStyle { get; }
    public static AvTraceDetails FoundResourceInTemplate { get; }
    public static AvTraceDetails FoundResourceInThemeStyle { get; }
    public static AvTraceDetails FoundResourceInApplication { get; }
    public static AvTraceDetails FoundResourceInTheme { get; }
    public static AvTraceDetails ResourceNotFound { get; }
    public static AvTraceDetails NewResourceDictionary { get; }
    public static AvTraceDetails FindResource { get; }
    public static AvTraceDetails SetKey { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceResourceDictionary();
    public static AvTraceDetails get_AddResource();
    public static AvTraceDetails get_RealizeDeferContent();
    public static AvTraceDetails get_FoundResourceOnElement();
    public static AvTraceDetails get_FoundResourceInStyle();
    public static AvTraceDetails get_FoundResourceInTemplate();
    public static AvTraceDetails get_FoundResourceInThemeStyle();
    public static AvTraceDetails get_FoundResourceInApplication();
    public static AvTraceDetails get_FoundResourceInTheme();
    public static AvTraceDetails get_ResourceNotFound();
    public static AvTraceDetails get_NewResourceDictionary();
    public static AvTraceDetails get_FindResource();
    public static AvTraceDetails get_SetKey();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceShell : object {
    public static AvTraceDetails NotOnWindows7 { get; }
    public static AvTraceDetails ExplorerTaskbarTimeout { get; }
    public static AvTraceDetails ExplorerTaskbarRetrying { get; }
    public static AvTraceDetails ExplorerTaskbarNotRunning { get; }
    public static AvTraceDetails RejectingJumpItemsBecauseCatastrophicFailure { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceShell();
    public static AvTraceDetails get_NotOnWindows7();
    public static AvTraceDetails get_ExplorerTaskbarTimeout();
    public static AvTraceDetails get_ExplorerTaskbarRetrying();
    public static AvTraceDetails get_ExplorerTaskbarNotRunning();
    public static AvTraceDetails NativeTaskbarError(Object[] args);
    public static AvTraceDetails get_RejectingJumpItemsBecauseCatastrophicFailure();
    public static AvTraceDetails RejectingJumpListCategoryBecauseNoRegisteredHandler(Object[] args);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal class MS.Internal.UncommonValueTable : ValueType {
    private Object[] _table;
    private UInt32 _bitmask;
    public bool HasValue(int id);
    public object GetValue(int id);
    public object GetValue(int id, object defaultValue);
    public void SetValue(int id, object value);
    public void ClearValue(int id);
}
internal static class MS.Internal.Utility.BindUriHelper : object {
    public static int MAX_URL_LENGTH;
    internal static Uri BaseUri { get; internal set; }
    private static BindUriHelper();
    internal static string UriToString(Uri uri);
    internal static Uri get_BaseUri();
    [SecurityCriticalAttribute]
internal static void set_BaseUri(Uri value);
    internal static bool DoSchemeAndHostMatch(Uri first, Uri second);
    internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    internal static string GetReferer(Uri destinationUri);
    internal static Uri GetResolvedUri(Uri originalUri);
    internal static Uri GetUriToNavigate(DependencyObject element, Uri baseUri, Uri inputUri);
    internal static bool StartWithFragment(Uri uri);
    internal static string GetFragment(Uri uri);
    internal static Uri GetUriRelativeToPackAppBase(Uri original);
    internal static bool IsXamlMimeType(ContentType mimeType);
}
internal class MS.Internal.Utility.MonitorWrapper : object {
    public bool Busy { get; }
    public IDisposable Enter();
    public void Exit();
    public bool get_Busy();
}
internal class MS.Internal.Utility.SponsorHelper : object {
    internal SponsorHelper(ILease lease, TimeSpan timespan);
    private sealed virtual override TimeSpan System.Runtime.Remoting.Lifetime.ISponsor.Renewal(ILease lease);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Register();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Unregister();
}
internal class MS.Internal.Utility.TraceLog : object {
    internal TraceLog(int size);
    internal void Add(string message, Object[] args);
    internal void WriteLog();
    internal static string IdFor(object o);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.WeakDictionary`2 : object {
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    [IteratorStateMachineAttribute("MS.Internal.WeakDictionary`2/<GetEnumerator>d__22")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.WeakHashSet`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("MS.Internal.WeakHashSet`1/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.WeakHashtable : Hashtable {
    private static WeakHashtable();
    public virtual void Clear();
    public virtual void Remove(object key);
    public void SetWeak(object key, object value);
}
[ExtensionAttribute]
internal static class MS.Internal.WindowsRuntime.ReflectionHelper : object {
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName);
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName, TArg arg);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetField(object obj, string fieldName);
    [ExtensionAttribute]
public static object ReflectionNew(Type type);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static object ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static TResult ReflectionStaticGetProperty(Type type, string propertyName);
}
internal enum MS.Internal.WindowsRuntime.Windows.Data.Text.AlternateNormalizationFormat : Enum {
    public int value__;
    public static AlternateNormalizationFormat NotNormalized;
    public static AlternateNormalizationFormat Number;
    public static AlternateNormalizationFormat Currency;
    public static AlternateNormalizationFormat Date;
    public static AlternateNormalizationFormat Time;
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.AlternateWordForm : object {
    public string AlternateText { get; }
    public AlternateNormalizationFormat NormalizationFormat { get; }
    public TextSegment SourceTextSegment { get; }
    public static Type WinRTType { get; }
    private static AlternateWordForm();
    public AlternateWordForm(object alternateWordForm);
    public string get_AlternateText();
    public AlternateNormalizationFormat get_NormalizationFormat();
    public TextSegment get_SourceTextSegment();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.TextSegment : object {
    public UInt32 Length { get; }
    public UInt32 StartPosition { get; }
    public static Type WinRTType { get; }
    private static TextSegment();
    public TextSegment(object textSegment);
    public UInt32 get_Length();
    public UInt32 get_StartPosition();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordSegment : object {
    public IReadOnlyList`1<AlternateWordForm> AlternateForms { get; }
    public TextSegment SourceTextSegment { get; }
    public string Text { get; }
    public static Type WinRTType { get; }
    private static WordSegment();
    public WordSegment(object wordSegment);
    public IReadOnlyList`1<AlternateWordForm> get_AlternateForms();
    public TextSegment get_SourceTextSegment();
    public string get_Text();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordSegmentsTokenizingHandler : MulticastDelegate {
    public WordSegmentsTokenizingHandler(object object, IntPtr method);
    public virtual void Invoke(IEnumerable`1<WordSegment> precedingWords, IEnumerable`1<WordSegment> words);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<WordSegment> precedingWords, IEnumerable`1<WordSegment> words, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordsSegmenter : object {
    public static string Undetermined;
    public string ResolvedLanguage { get; }
    public static Type WinRTType { get; }
    private static WordsSegmenter();
    public static WordsSegmenter Create(string language, bool shouldPreferNeutralSegmenter);
    public WordSegment GetTokenAt(string text, UInt32 startIndex);
    public IReadOnlyList`1<WordSegment> GetTokens(string text);
    public void Tokenize(string text, UInt32 startIndex, WordSegmentsTokenizingHandler handler);
    public string get_ResolvedLanguage();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Globalization.Language : object {
    public static string CurrentInputMethodLanguageTag { get; }
    public string DisplayName { get; }
    public string LanguageTag { get; }
    public string NativeName { get; }
    public string Script { get; }
    private static Language();
    public Language(string languageTag);
    public IReadOnlyList`1<string> GetExtensionSubtags(string singleton);
    public static bool IsWellFormed(string languageTag);
    public static bool TrySetInputMethodLanguageTag(string languageTag);
    public static string get_CurrentInputMethodLanguageTag();
    public string get_DisplayName();
    public string get_LanguageTag();
    public string get_NativeName();
    public string get_Script();
}
internal class MS.Internal.Xaml.Context.XamlContextStack`1 : object {
    public T CurrentFrame { get; }
    public T PreviousFrame { get; }
    public T PreviousPreviousFrame { get; }
    public int Depth { get; public set; }
    public string Frames { get; }
    public XamlContextStack`1(Func`1<T> creationDelegate);
    public XamlContextStack`1(XamlContextStack`1<T> source, bool copy);
    public T get_CurrentFrame();
    public T get_PreviousFrame();
    public T get_PreviousPreviousFrame();
    public T GetFrame(int depth);
    public void PushScope();
    public void PopScope();
    public int get_Depth();
    public void set_Depth(int value);
    public void Trim();
    public string get_Frames();
}
internal abstract class MS.Internal.Xaml.Context.XamlFrame : object {
    public int Depth { get; }
    public XamlFrame Previous { get; public set; }
    protected XamlFrame(XamlFrame source);
    public virtual XamlFrame Clone();
    public abstract virtual void Reset();
    public int get_Depth();
    public XamlFrame get_Previous();
    public void set_Previous(XamlFrame value);
}
internal class MS.Internal.Xaml.Parser.SpecialBracketCharacters : object {
    internal string StartBracketCharacters { get; }
    internal string EndBracketCharacters { get; }
    internal SpecialBracketCharacters(IReadOnlyDictionary`2<char, char> attributeList);
    private static SpecialBracketCharacters();
    internal void AddBracketCharacters(char openingBracket, char closingBracket);
    internal bool IsSpecialCharacter(char ch);
    internal bool StartsEscapeSequence(char ch);
    internal bool EndsEscapeSequence(char ch);
    internal bool Match(char start, char end);
    internal string get_StartBracketCharacters();
    internal string get_EndBracketCharacters();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
internal class MS.Utility.ItemStructMap`1 : ValueType {
    private static int SearchTypeThreshold;
    public Entry[] Entries;
    public int Count;
    public int EnsureEntry(int key);
    public int Search(int key);
}
internal static class MS.Win32.UxThemeWrapper : object {
    internal static bool IsActive { get; }
    internal static string ThemeName { get; }
    internal static string ThemeColor { get; }
    private static UxThemeWrapper();
    internal static bool get_IsActive();
    internal static string get_ThemeName();
    internal static string get_ThemeColor();
    internal static void OnThemeChanged();
}
internal enum Standard.AC : Enum {
    public byte value__;
    public static AC SRC_OVER;
    public static AC SRC_ALPHA;
}
internal enum Standard.APPDOCLISTTYPE : Enum {
    public int value__;
    public static APPDOCLISTTYPE ADLT_RECENT;
    public static APPDOCLISTTYPE ADLT_FREQUENT;
}
internal static class Standard.Assert : object {
    [ConditionalAttribute("DEBUG")]
public static void Evaluate(EvaluateFunction argument);
    [ObsoleteAttribute("Use Assert.AreEqual instead of Assert.Equals", "False")]
[ConditionalAttribute("DEBUG")]
public static void Equals(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreEqual(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreNotEqual(T notExpected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, bool result);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, ImplicationFunction result);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorEmpty(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorWhitespace(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotNull(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail();
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void IsNull(T item);
    [ConditionalAttribute("DEBUG")]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive);
    [ConditionalAttribute("DEBUG")]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive);
    [ConditionalAttribute("DEBUG")]
public static void IsApartmentState(ApartmentState expectedState);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNotNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotOnMainThread();
}
internal enum Standard.BI : Enum {
    public int value__;
    public static BI RGB;
}
internal class Standard.BITMAPINFO : ValueType {
    public BITMAPINFOHEADER bmiHeader;
    public RGBQUAD bmiColors;
}
internal class Standard.BITMAPINFOHEADER : ValueType {
    public int biSize;
    public int biWidth;
    public int biHeight;
    public short biPlanes;
    public short biBitCount;
    public BI biCompression;
    public int biSizeImage;
    public int biXPelsPerMeter;
    public int biYPelsPerMeter;
    public int biClrUsed;
    public int biClrImportant;
}
internal class Standard.BLENDFUNCTION : ValueType {
    public AC BlendOp;
    public byte BlendFlags;
    public byte SourceConstantAlpha;
    public AC AlphaFormat;
}
internal class Standard.CHANGEFILTERSTRUCT : ValueType {
    public UInt32 cbSize;
    public MSGFLTINFO ExtStatus;
}
internal static class Standard.CLSID : object {
    public static string TaskbarList;
    public static string EnumerableObjectCollection;
    public static string ShellLink;
    public static string DestinationList;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static T CoCreateInstance(string clsid);
}
internal enum Standard.CombineRgnResult : Enum {
    public int value__;
    public static CombineRgnResult ERROR;
    public static CombineRgnResult NULLREGION;
    public static CombineRgnResult SIMPLEREGION;
    public static CombineRgnResult COMPLEXREGION;
}
internal class Standard.CREATESTRUCT : ValueType {
    public IntPtr lpCreateParams;
    public IntPtr hInstance;
    public IntPtr hMenu;
    public IntPtr hwndParent;
    public int cy;
    public int cx;
    public int y;
    public int x;
    public WS style;
    public string lpszName;
    public string lpszClass;
    public WS_EX dwExStyle;
}
[FlagsAttribute]
internal enum Standard.CS : Enum {
    public UInt32 value__;
    public static CS VREDRAW;
    public static CS HREDRAW;
    public static CS DBLCLKS;
    public static CS OWNDC;
    public static CS CLASSDC;
    public static CS PARENTDC;
    public static CS NOCLOSE;
    public static CS SAVEBITS;
    public static CS BYTEALIGNCLIENT;
    public static CS BYTEALIGNWINDOW;
    public static CS GLOBALCLASS;
    public static CS IME;
    public static CS DROPSHADOW;
}
internal enum Standard.DeviceCap : Enum {
    public int value__;
    public static DeviceCap BITSPIXEL;
    public static DeviceCap PLANES;
    public static DeviceCap LOGPIXELSX;
    public static DeviceCap LOGPIXELSY;
}
internal enum Standard.DOGIF : Enum {
    public int value__;
    public static DOGIF DEFAULT;
    public static DOGIF TRAVERSE_LINK;
    public static DOGIF NO_HDROP;
    public static DOGIF NO_URL;
    public static DOGIF ONLY_IF_ONE;
}
internal static class Standard.DoubleUtilities : object {
    public static bool AreClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool IsFinite(double value);
    public static bool IsValidSize(double value);
}
internal static class Standard.DpiHelper : object {
    public static Point LogicalPixelsToDevice(Point logicalPoint, double dpiScaleX, double dpiScaleY);
    public static Point DevicePixelsToLogical(Point devicePoint, double dpiScaleX, double dpiScaleY);
    public static Rect LogicalRectToDevice(Rect logicalRectangle, double dpiScaleX, double dpiScaleY);
    public static Rect DeviceRectToLogical(Rect deviceRectangle, double dpiScaleX, double dpiScaleY);
    public static Size LogicalSizeToDevice(Size logicalSize, double dpiScaleX, double dpiScaleY);
    public static Size DeviceSizeToLogical(Size deviceSize, double dpiScaleX, double dpiScaleY);
    public static Thickness LogicalThicknessToDevice(Thickness logicalThickness, double dpiScaleX, double dpiScaleY);
}
internal enum Standard.DWM_SIT : Enum {
    public int value__;
    public static DWM_SIT None;
    public static DWM_SIT DISPLAYFRAME;
}
internal class Standard.DWM_TIMING_INFO : ValueType {
    public int cbSize;
    public UNSIGNED_RATIO rateRefresh;
    public ulong qpcRefreshPeriod;
    public UNSIGNED_RATIO rateCompose;
    public ulong qpcVBlank;
    public ulong cRefresh;
    public UInt32 cDXRefresh;
    public ulong qpcCompose;
    public ulong cFrame;
    public UInt32 cDXPresent;
    public ulong cRefreshFrame;
    public ulong cFrameSubmitted;
    public UInt32 cDXPresentSubmitted;
    public ulong cFrameConfirmed;
    public UInt32 cDXPresentConfirmed;
    public ulong cRefreshConfirmed;
    public UInt32 cDXRefreshConfirmed;
    public ulong cFramesLate;
    public UInt32 cFramesOutstanding;
    public ulong cFrameDisplayed;
    public ulong qpcFrameDisplayed;
    public ulong cRefreshFrameDisplayed;
    public ulong cFrameComplete;
    public ulong qpcFrameComplete;
    public ulong cFramePending;
    public ulong qpcFramePending;
    public ulong cFramesDisplayed;
    public ulong cFramesComplete;
    public ulong cFramesPending;
    public ulong cFramesAvailable;
    public ulong cFramesDropped;
    public ulong cFramesMissed;
    public ulong cRefreshNextDisplayed;
    public ulong cRefreshNextPresented;
    public ulong cRefreshesDisplayed;
    public ulong cRefreshesPresented;
    public ulong cRefreshStarted;
    public ulong cPixelsReceived;
    public ulong cPixelsDrawn;
    public ulong cBuffersEmpty;
}
internal enum Standard.DWMFLIP3D : Enum {
    public int value__;
    public static DWMFLIP3D DEFAULT;
    public static DWMFLIP3D EXCLUDEBELOW;
    public static DWMFLIP3D EXCLUDEABOVE;
}
internal enum Standard.DWMNCRP : Enum {
    public int value__;
    public static DWMNCRP USEWINDOWSTYLE;
    public static DWMNCRP DISABLED;
    public static DWMNCRP ENABLED;
}
internal enum Standard.DWMWA : Enum {
    public int value__;
    public static DWMWA NCRENDERING_ENABLED;
    public static DWMWA NCRENDERING_POLICY;
    public static DWMWA TRANSITIONS_FORCEDISABLED;
    public static DWMWA ALLOW_NCPAINT;
    public static DWMWA CAPTION_BUTTON_BOUNDS;
    public static DWMWA NONCLIENT_RTL_LAYOUT;
    public static DWMWA FORCE_ICONIC_REPRESENTATION;
    public static DWMWA FLIP3D_POLICY;
    public static DWMWA EXTENDED_FRAME_BOUNDS;
    public static DWMWA HAS_ICONIC_BITMAP;
    public static DWMWA DISALLOW_PEEK;
    public static DWMWA EXCLUDED_FROM_PEEK;
}
[FlagsAttribute]
internal enum Standard.ErrorModes : Enum {
    public int value__;
    public static ErrorModes Default;
    public static ErrorModes FailCriticalErrors;
    public static ErrorModes NoGpFaultErrorBox;
    public static ErrorModes NoAlignmentFaultExcept;
    public static ErrorModes NoOpenFileErrorBox;
}
internal enum Standard.Facility : Enum {
    public int value__;
    public static Facility Null;
    public static Facility Rpc;
    public static Facility Dispatch;
    public static Facility Storage;
    public static Facility Itf;
    public static Facility Win32;
    public static Facility Windows;
    public static Facility Control;
    public static Facility Ese;
    public static Facility WinCodec;
}
internal enum Standard.FO : Enum {
    public int value__;
    public static FO MOVE;
    public static FO COPY;
    public static FO DELETE;
    public static FO RENAME;
}
internal enum Standard.FOF : Enum {
    public ushort value__;
    public static FOF MULTIDESTFILES;
    public static FOF CONFIRMMOUSE;
    public static FOF SILENT;
    public static FOF RENAMEONCOLLISION;
    public static FOF NOCONFIRMATION;
    public static FOF WANTMAPPINGHANDLE;
    public static FOF ALLOWUNDO;
    public static FOF FILESONLY;
    public static FOF SIMPLEPROGRESS;
    public static FOF NOCONFIRMMKDIR;
    public static FOF NOERRORUI;
    public static FOF NOCOPYSECURITYATTRIBS;
    public static FOF NORECURSION;
    public static FOF NO_CONNECTED_ELEMENTS;
    public static FOF WANTNUKEWARNING;
    public static FOF NORECURSEREPARSE;
}
internal enum Standard.GCLP : Enum {
    public int value__;
    public static GCLP HBRBACKGROUND;
}
internal enum Standard.GPS : Enum {
    public int value__;
    public static GPS DEFAULT;
    public static GPS HANDLERPROPERTIESONLY;
    public static GPS READWRITE;
    public static GPS TEMPORARY;
    public static GPS FASTPROPERTIESONLY;
    public static GPS OPENSLOWITEM;
    public static GPS DELAYCREATION;
    public static GPS BESTEFFORT;
    public static GPS NO_OPLOCK;
    public static GPS MASK_VALID;
}
internal enum Standard.GWL : Enum {
    public int value__;
    public static GWL WNDPROC;
    public static GWL HINSTANCE;
    public static GWL HWNDPARENT;
    public static GWL STYLE;
    public static GWL EXSTYLE;
    public static GWL USERDATA;
    public static GWL ID;
}
[FlagsAttribute]
internal enum Standard.HCF : Enum {
    public int value__;
    public static HCF HIGHCONTRASTON;
    public static HCF AVAILABLE;
    public static HCF HOTKEYACTIVE;
    public static HCF CONFIRMHOTKEY;
    public static HCF HOTKEYSOUND;
    public static HCF INDICATOR;
    public static HCF HOTKEYAVAILABLE;
}
internal class Standard.HIGHCONTRAST : ValueType {
    public int cbSize;
    public HCF dwFlags;
    public IntPtr lpszDefaultScheme;
}
internal class Standard.HRESULT : ValueType {
    private UInt32 _value;
    public static HRESULT S_OK;
    public static HRESULT S_FALSE;
    public static HRESULT E_PENDING;
    public static HRESULT E_NOTIMPL;
    public static HRESULT E_NOINTERFACE;
    public static HRESULT E_POINTER;
    public static HRESULT E_ABORT;
    public static HRESULT E_FAIL;
    public static HRESULT E_UNEXPECTED;
    public static HRESULT STG_E_INVALIDFUNCTION;
    public static HRESULT REGDB_E_CLASSNOTREG;
    public static HRESULT DESTS_E_NO_MATCHING_ASSOC_HANDLER;
    public static HRESULT DESTS_E_NORECDOCS;
    public static HRESULT DESTS_E_NOTALLCLEARED;
    public static HRESULT E_ACCESSDENIED;
    public static HRESULT E_OUTOFMEMORY;
    public static HRESULT E_INVALIDARG;
    public static HRESULT INTSAFE_E_ARITHMETIC_OVERFLOW;
    public static HRESULT COR_E_OBJECTDISPOSED;
    public static HRESULT WC_E_GREATERTHAN;
    public static HRESULT WC_E_SYNTAX;
    public Facility Facility { get; }
    public int Code { get; }
    public bool Succeeded { get; }
    public bool Failed { get; }
    public HRESULT(UInt32 i);
    private static HRESULT();
    public static HRESULT Make(bool severe, Facility facility, int code);
    public Facility get_Facility();
    public static Facility GetFacility(int errorCode);
    public int get_Code();
    public static int GetCode(int error);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HRESULT hrLeft, HRESULT hrRight);
    public static bool op_Inequality(HRESULT hrLeft, HRESULT hrRight);
    public bool get_Succeeded();
    public bool get_Failed();
    public void ThrowIfFailed();
    public void ThrowIfFailed(string message);
    [SecurityCriticalAttribute]
public static void ThrowLastError();
}
internal enum Standard.HT : Enum {
    public int value__;
    public static HT ERROR;
    public static HT TRANSPARENT;
    public static HT NOWHERE;
    public static HT CLIENT;
    public static HT CAPTION;
    public static HT SYSMENU;
    public static HT GROWBOX;
    public static HT SIZE;
    public static HT MENU;
    public static HT HSCROLL;
    public static HT VSCROLL;
    public static HT MINBUTTON;
    public static HT MAXBUTTON;
    public static HT LEFT;
    public static HT RIGHT;
    public static HT TOP;
    public static HT TOPLEFT;
    public static HT TOPRIGHT;
    public static HT BOTTOM;
    public static HT BOTTOMLEFT;
    public static HT BOTTOMRIGHT;
    public static HT BORDER;
    public static HT REDUCE;
    public static HT ZOOM;
    public static HT SIZEFIRST;
    public static HT SIZELAST;
    public static HT OBJECT;
    public static HT CLOSE;
    public static HT HELP;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("12337d35-94c6-48a0-bce7-6a9c69d4d600")]
internal interface Standard.IApplicationDestinations {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual void RemoveDestination(object punk);
    public abstract virtual void RemoveAllDestinations();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")]
internal interface Standard.IApplicationDocumentLists {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object GetList(APPDOCLISTTYPE listtype, UInt32 cItemsDesired, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6332debf-87b5-4670-90c0-5e57b408a49e")]
internal interface Standard.ICustomDestinationList {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object BeginList(UInt32& pcMaxSlots, Guid& riid);
    public abstract virtual HRESULT AppendCategory(string pszCategory, IObjectArray poa);
    public abstract virtual void AppendKnownCategory(KDC category);
    public abstract virtual HRESULT AddUserTasks(IObjectArray poa);
    public abstract virtual void CommitList();
    public abstract virtual object GetRemovedDestinations(Guid& riid);
    public abstract virtual void DeleteList(string pszAppID);
    public abstract virtual void AbortList();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
internal interface Standard.IEnumIDList {
    public abstract virtual HRESULT Next(UInt32 celt, IntPtr& rgelt, Int32& pceltFetched);
    public abstract virtual HRESULT Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumIDList& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e")]
internal interface Standard.IEnumObjects {
    public abstract virtual void Next(UInt32 celt, Guid& riid, Object[] rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumObjects Clone();
}
internal static class Standard.IID : object {
    public static string EnumIdList;
    public static string EnumObjects;
    public static string HtmlDocument2;
    public static string ModalWindow;
    public static string ObjectArray;
    public static string ObjectCollection;
    public static string PropertyNotifySink;
    public static string PropertyStore;
    public static string ServiceProvider;
    public static string ShellFolder;
    public static string ShellLink;
    public static string ShellItem;
    public static string ShellItem2;
    public static string ShellItemArray;
    public static string TaskbarList;
    public static string TaskbarList2;
    public static string Unknown;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static string CustomDestinationList;
    public static string ObjectWithAppUserModelId;
    public static string ObjectWithProgId;
    public static string TaskbarList3;
    public static string TaskbarList4;
}
internal class Standard.INPUT : ValueType {
    public UInt32 type;
    public MOUSEINPUT mi;
}
internal enum Standard.INPUT_TYPE : Enum {
    public UInt32 value__;
    public static INPUT_TYPE MOUSE;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface Standard.IObjectArray {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface Standard.IObjectCollection {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
    public abstract virtual void AddObject(object punk);
    public abstract virtual void AddFromArray(IObjectArray poaSource);
    public abstract virtual void RemoveObjectAt(UInt32 uiIndex);
    public abstract virtual void Clear();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("36db0196-9665-46d1-9ba7-d3709eecf9ed")]
internal interface Standard.IObjectWithAppUserModelId {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual string GetAppID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")]
internal interface Standard.IObjectWithProgId {
    public abstract virtual void SetProgID(string pszProgID);
    public abstract virtual string GetProgID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")]
internal interface Standard.IPropertyStore {
    public abstract virtual UInt32 GetCount();
    public abstract virtual PKEY GetAt(UInt32 iProp);
    [SecurityCriticalAttribute]
public abstract virtual void GetValue(PKEY& pkey, PROPVARIANT pv);
    [SecurityCriticalAttribute]
public abstract virtual void SetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void Commit();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
internal interface Standard.IShellFolder {
    public abstract virtual void ParseDisplayName(IntPtr hwnd, IBindCtx pbc, string pszDisplayName, Int32& pchEaten, IntPtr& ppidl, UInt32& pdwAttributes);
    public abstract virtual IEnumIDList EnumObjects(IntPtr hwnd, SHCONTF grfFlags);
    public abstract virtual object BindToObject(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual object BindToStorage(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual HRESULT CompareIDs(IntPtr lParam, IntPtr pidl1, IntPtr pidl2);
    public abstract virtual object CreateViewObject(IntPtr hwndOwner, Guid& riid);
    public abstract virtual void GetAttributesOf(UInt32 cidl, IntPtr apidl, SFGAO& rgfInOut);
    public abstract virtual object GetUIObjectOf(IntPtr hwndOwner, UInt32 cidl, IntPtr apidl, Guid& riid, UInt32& rgfReserved);
    public abstract virtual void GetDisplayNameOf(IntPtr pidl, SHGDN uFlags, IntPtr& pName);
    public abstract virtual void SetNameOf(IntPtr hwnd, IntPtr pidl, string pszName, SHGDN uFlags, IntPtr& ppidlOut);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
internal interface Standard.IShellItem {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7e9fb0d3-919f-4307-ab2e-9b1860310c93")]
internal interface Standard.IShellItem2 {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
    public abstract virtual object GetPropertyStore(GPS flags, Guid& riid);
    public abstract virtual object GetPropertyStoreWithCreateObject(GPS flags, object punkCreateObject, Guid& riid);
    public abstract virtual object GetPropertyStoreForKeys(IntPtr rgKeys, UInt32 cKeys, GPS flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(IntPtr keyType, Guid& riid);
    public abstract virtual void Update(IBindCtx pbc);
    [SecurityCriticalAttribute]
public abstract virtual PROPVARIANT GetProperty(IntPtr key);
    public abstract virtual Guid GetCLSID(IntPtr key);
    public abstract virtual FILETIME GetFileTime(IntPtr key);
    public abstract virtual int GetInt32(IntPtr key);
    public abstract virtual string GetString(IntPtr key);
    public abstract virtual UInt32 GetUInt32(IntPtr key);
    public abstract virtual ulong GetUInt64(IntPtr key);
    public abstract virtual void GetBool(IntPtr key);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B63EA76D-1F85-456F-A19C-48159EFA858B")]
internal interface Standard.IShellItemArray {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& rbhid, Guid& riid);
    public abstract virtual object GetPropertyStore(int flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(PKEY& keyType, Guid& riid);
    public abstract virtual UInt32 GetAttributes(SIATTRIBFLAGS dwAttribFlags, UInt32 sfgaoMask);
    public abstract virtual UInt32 GetCount();
    public abstract virtual IShellItem GetItemAt(UInt32 dwIndex);
    public abstract virtual object EnumItems();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface Standard.IShellLinkW {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, WIN32_FIND_DATAW pfd, SLGP fFlags);
    public abstract virtual void GetIDList(IntPtr& ppidl);
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszFile, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual short GetHotKey();
    public abstract virtual void SetHotKey(short wHotKey);
    public abstract virtual UInt32 GetShowCmd();
    public abstract virtual void SetShowCmd(UInt32 iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, UInt32 dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, UInt32 fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("56FDF342-FD6D-11d0-958A-006097C9A090")]
internal interface Standard.ITaskbarList {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("602D4995-B13A-429b-A66E-1935E44F4317")]
internal interface Standard.ITaskbarList2 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface Standard.ITaskbarList3 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface Standard.ITaskbarList4 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
    public abstract virtual void SetTabProperties(IntPtr hwndTab, STPF stpFlags);
}
internal enum Standard.KDC : Enum {
    public int value__;
    public static KDC FREQUENT;
    public static KDC RECENT;
}
internal class Standard.LOGFONT : ValueType {
    public int lfHeight;
    public int lfWidth;
    public int lfEscapement;
    public int lfOrientation;
    public int lfWeight;
    public byte lfItalic;
    public byte lfUnderline;
    public byte lfStrikeOut;
    public byte lfCharSet;
    public byte lfOutPrecision;
    public byte lfClipPrecision;
    public byte lfQuality;
    public byte lfPitchAndFamily;
    public string lfFaceName;
}
internal class Standard.MARGINS : ValueType {
    public int cxLeftWidth;
    public int cxRightWidth;
    public int cyTopHeight;
    public int cyBottomHeight;
}
internal class Standard.MessageHandler : MulticastDelegate {
    public MessageHandler(object object, IntPtr method);
    public virtual IntPtr Invoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
[SecurityCriticalAttribute]
internal class Standard.MessageWindow : CriticalFinalizerObject {
    public IntPtr Handle { get; private set; }
    [SecurityCriticalAttribute]
private static MessageWindow();
    [SecurityCriticalAttribute]
public MessageWindow(CS classStyle, WS style, WS_EX exStyle, Rect location, string name, WndProc callback);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
private void set_Handle(IntPtr value);
    [SecurityCriticalAttribute]
protected virtual override void Finalize();
    [SecurityCriticalAttribute]
public void Release();
}
[FlagsAttribute]
internal enum Standard.MF : Enum {
    public UInt32 value__;
    public static MF DOES_NOT_EXIST;
    public static MF ENABLED;
    public static MF BYCOMMAND;
    public static MF GRAYED;
    public static MF DISABLED;
}
internal class Standard.MINMAXINFO : ValueType {
    public POINT ptReserved;
    public POINT ptMaxSize;
    public POINT ptMaxPosition;
    public POINT ptMinTrackSize;
    public POINT ptMaxTrackSize;
}
internal class Standard.MONITORINFO : object {
    public int cbSize;
    public RECT rcMonitor;
    public RECT rcWork;
    public int dwFlags;
}
internal enum Standard.MOUSEEVENTF : Enum {
    public int value__;
    public static MOUSEEVENTF LEFTDOWN;
    public static MOUSEEVENTF LEFTUP;
}
internal class Standard.MOUSEINPUT : ValueType {
    public int dx;
    public int dy;
    public int mouseData;
    public int dwFlags;
    public int time;
    public IntPtr dwExtraInfo;
}
internal enum Standard.MSGFLT : Enum {
    public int value__;
    public static MSGFLT RESET;
    public static MSGFLT ALLOW;
    public static MSGFLT DISALLOW;
}
internal enum Standard.MSGFLTINFO : Enum {
    public int value__;
    public static MSGFLTINFO NONE;
    public static MSGFLTINFO ALREADYALLOWED_FORWND;
    public static MSGFLTINFO ALREADYDISALLOWED_FORWND;
    public static MSGFLTINFO ALLOWED_HIGHER;
}
internal static class Standard.NativeMethods : object {
    [SecurityCriticalAttribute]
public static RECT AdjustWindowRectEx(RECT lpRect, WS dwStyle, bool bMenu, WS_EX dwExStyle);
    [SecurityCriticalAttribute]
public static HRESULT ChangeWindowMessageFilterEx(IntPtr hwnd, WM message, MSGFLT action, MSGFLTINFO& filterInfo);
    [SecurityCriticalAttribute]
public static CombineRgnResult CombineRgn(IntPtr hrgnDest, IntPtr hrgnSrc1, IntPtr hrgnSrc2, RGN fnCombineMode);
    [SecurityCriticalAttribute]
public static String[] CommandLineToArgvW(string cmdLine);
    [SecurityCriticalAttribute]
public static SafeHBITMAP CreateDIBSection(SafeDC hdc, BITMAPINFO& bitmapInfo, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    [SecurityCriticalAttribute]
public static IntPtr CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    [SecurityCriticalAttribute]
public static IntPtr CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    [SecurityCriticalAttribute]
public static IntPtr CreateRectRgnIndirect(RECT lprc);
    [SecurityCriticalAttribute]
public static IntPtr CreateSolidBrush(int crColor);
    [SecurityCriticalAttribute]
public static IntPtr CreateWindowEx(WS_EX dwExStyle, string lpClassName, string lpWindowName, WS dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    [SecurityCriticalAttribute]
public static IntPtr DefWindowProc(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
public static bool DeleteObject(IntPtr hObject);
    [SecurityCriticalAttribute]
public static bool DestroyIcon(IntPtr handle);
    [SecurityCriticalAttribute]
public static bool DestroyWindow(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static bool IsWindow(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static void DwmExtendFrameIntoClientArea(IntPtr hwnd, MARGINS& pMarInset);
    [SecurityCriticalAttribute]
public static bool DwmGetColorizationColor(UInt32& pcrColorization, Boolean& pfOpaqueBlend);
    [SecurityCriticalAttribute]
public static bool DwmIsCompositionEnabled();
    [SecurityCriticalAttribute]
public static bool DwmDefWindowProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam, IntPtr& plResult);
    [SecurityCriticalAttribute]
public static void DwmSetWindowAttributeFlip3DPolicy(IntPtr hwnd, DWMFLIP3D flip3dPolicy);
    [SecurityCriticalAttribute]
public static void DwmSetWindowAttributeDisallowPeek(IntPtr hwnd, bool disallowPeek);
    [SecurityCriticalAttribute]
public static MF EnableMenuItem(IntPtr hMenu, SC uIDEnableItem, MF uEnable);
    [SecurityCriticalAttribute]
public static void RemoveMenu(IntPtr hMenu, SC uPosition, MF uFlags);
    [SecurityCriticalAttribute]
public static void DrawMenuBar(IntPtr hWnd);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static bool FindClose(IntPtr handle);
    [SecurityCriticalAttribute]
public static SafeFindHandle FindFirstFileW(string lpFileName, WIN32_FIND_DATAW lpFindFileData);
    [SecurityCriticalAttribute]
public static bool FindNextFileW(SafeFindHandle hndFindFile, WIN32_FIND_DATAW lpFindFileData);
    [SecurityCriticalAttribute]
public static RECT GetClientRect(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static void GetCurrentThemeName(String& themeFileName, String& color, String& size);
    [SecurityCriticalAttribute]
public static bool IsThemeActive();
    [SecurityCriticalAttribute]
public static int GetDeviceCaps(SafeDC hdc, DeviceCap nIndex);
    [SecurityCriticalAttribute]
public static string GetModuleFileName(IntPtr hModule);
    [SecurityCriticalAttribute]
public static IntPtr GetModuleHandle(string lpModuleName);
    [SecurityCriticalAttribute]
public static MONITORINFO GetMonitorInfo(IntPtr hMonitor);
    [SecurityCriticalAttribute]
public static IntPtr GetStockObject(StockObject fnObject);
    [SecurityCriticalAttribute]
public static IntPtr GetSystemMenu(IntPtr hWnd, bool bRevert);
    [SecurityCriticalAttribute]
public static int GetSystemMetrics(SM nIndex);
    [SecurityCriticalAttribute]
public static IntPtr GetWindowLongPtr(IntPtr hwnd, GWL nIndex);
    [SecurityCriticalAttribute]
public static void SetWindowThemeAttribute(IntPtr hwnd, WINDOWTHEMEATTRIBUTETYPE eAttribute, WTA_OPTIONS& pvAttribute, UInt32 cbAttribute);
    [SecurityCriticalAttribute]
public static WINDOWPLACEMENT GetWindowPlacement(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static RECT GetWindowRect(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static Status GdipCreateBitmapFromStream(IStream stream, IntPtr& bitmap);
    [SecurityCriticalAttribute]
public static Status GdipCreateHBITMAPFromBitmap(IntPtr bitmap, IntPtr& hbmReturn, int background);
    [SecurityCriticalAttribute]
public static Status GdipCreateHICONFromBitmap(IntPtr bitmap, IntPtr& hbmReturn);
    [SecurityCriticalAttribute]
public static Status GdipDisposeImage(IntPtr image);
    [SecurityCriticalAttribute]
public static Status GdipImageForceValidation(IntPtr image);
    [SecurityCriticalAttribute]
public static Status GdiplusStartup(IntPtr& token, StartupInput input, StartupOutput& output);
    [SecurityCriticalAttribute]
public static Status GdiplusShutdown(IntPtr token);
    [SecurityCriticalAttribute]
public static bool IsWindowVisible(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static IntPtr MonitorFromWindow(IntPtr hwnd, UInt32 dwFlags);
    [SecurityCriticalAttribute]
public static void PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
public static short RegisterClassEx(WNDCLASSEX& lpwcx);
    [SecurityCriticalAttribute]
public static WM RegisterWindowMessage(string lpString);
    [SecurityCriticalAttribute]
public static IntPtr SetActiveWindow(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static IntPtr SetClassLongPtr(IntPtr hwnd, GCLP nIndex, IntPtr dwNewLong);
    [SecurityCriticalAttribute]
public static ErrorModes SetErrorMode(ErrorModes newMode);
    [SecurityCriticalAttribute]
public static void SetProcessWorkingSetSize(IntPtr hProcess, int dwMinimumWorkingSetSize, int dwMaximumWorkingSetSize);
    [SecurityCriticalAttribute]
public static IntPtr SetWindowLongPtr(IntPtr hwnd, GWL nIndex, IntPtr dwNewLong);
    [SecurityCriticalAttribute]
public static void SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool bRedraw);
    [SecurityCriticalAttribute]
public static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);
    [SecurityCriticalAttribute]
public static Win32Error SHFileOperation(SHFILEOPSTRUCT& lpFileOp);
    [SecurityCriticalAttribute]
public static bool ShowWindow(IntPtr hwnd, SW nCmdShow);
    [SecurityCriticalAttribute]
public static void SystemParametersInfo(SPI uiAction, int uiParam, string pvParam, SPIF fWinIni);
    [SecurityCriticalAttribute]
public static NONCLIENTMETRICS SystemParameterInfo_GetNONCLIENTMETRICS();
    [SecurityCriticalAttribute]
public static HIGHCONTRAST SystemParameterInfo_GetHIGHCONTRAST();
    [SecurityCriticalAttribute]
public static UInt32 TrackPopupMenuEx(IntPtr hmenu, UInt32 fuFlags, int x, int y, IntPtr hwnd, IntPtr lptpm);
    [SecurityCriticalAttribute]
public static IntPtr SelectObject(SafeDC hdc, IntPtr hgdiobj);
    [SecurityCriticalAttribute]
public static IntPtr SelectObject(SafeDC hdc, SafeHBITMAP hgdiobj);
    [SecurityCriticalAttribute]
public static int SendInput(int nInputs, INPUT& pInputs, int cbSize);
    [SecurityCriticalAttribute]
public static IntPtr SendMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    [SecurityCriticalAttribute]
public static void UnregisterClass(short atom, IntPtr hinstance);
    [SecurityCriticalAttribute]
public static void UnregisterClass(string lpClassName, IntPtr hInstance);
    [SecurityCriticalAttribute]
public static void UpdateLayeredWindow(IntPtr hwnd, SafeDC hdcDst, POINT& pptDst, SIZE& psize, SafeDC hdcSrc, POINT& pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    [SecurityCriticalAttribute]
public static void UpdateLayeredWindow(IntPtr hwnd, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    [SecurityCriticalAttribute]
public static void SHAddToRecentDocs(string path);
    [SecurityCriticalAttribute]
public static void SHAddToRecentDocs(IShellLinkW shellLink);
    [SecurityCriticalAttribute]
public static Nullable`1<DWM_TIMING_INFO> DwmGetCompositionTimingInfo(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static void DwmInvalidateIconicBitmaps(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static void DwmSetIconicThumbnail(IntPtr hwnd, IntPtr hbmp, DWM_SIT dwSITFlags);
    [SecurityCriticalAttribute]
public static void DwmSetIconicLivePreviewBitmap(IntPtr hwnd, IntPtr hbmp, RefPOINT pptClient, DWM_SIT dwSITFlags);
    [SecurityCriticalAttribute]
public static void SHGetItemFromDataObject(IDataObject pdtobj, DOGIF dwFlags, Guid& riid, Object& ppv);
    [SecurityCriticalAttribute]
public static HRESULT SHCreateItemFromParsingName(string pszPath, IBindCtx pbc, Guid& riid, Object& ppv);
    [SecurityCriticalAttribute]
public static bool Shell_NotifyIcon(NIM dwMessage, NOTIFYICONDATA lpdata);
    [SecurityCriticalAttribute]
public static void SetCurrentProcessExplicitAppUserModelID(string AppID);
    [SecurityCriticalAttribute]
public static HRESULT GetCurrentProcessExplicitAppUserModelID(String& AppID);
}
[FlagsAttribute]
internal enum Standard.NIF : Enum {
    public UInt32 value__;
    public static NIF MESSAGE;
    public static NIF ICON;
    public static NIF TIP;
    public static NIF STATE;
    public static NIF INFO;
    public static NIF GUID;
    public static NIF REALTIME;
    public static NIF SHOWTIP;
    public static NIF XP_MASK;
    public static NIF VISTA_MASK;
}
internal enum Standard.NIIF : Enum {
    public int value__;
    public static NIIF NONE;
    public static NIIF INFO;
    public static NIIF WARNING;
    public static NIIF ERROR;
    public static NIIF USER;
    public static NIIF NOSOUND;
    public static NIIF LARGE_ICON;
    public static NIIF NIIF_RESPECT_QUIET_TIME;
    public static NIIF XP_ICON_MASK;
}
internal enum Standard.NIM : Enum {
    public UInt32 value__;
    public static NIM ADD;
    public static NIM MODIFY;
    public static NIM DELETE;
    public static NIM SETFOCUS;
    public static NIM SETVERSION;
}
internal class Standard.NONCLIENTMETRICS : ValueType {
    public int cbSize;
    public int iBorderWidth;
    public int iScrollWidth;
    public int iScrollHeight;
    public int iCaptionWidth;
    public int iCaptionHeight;
    public LOGFONT lfCaptionFont;
    public int iSmCaptionWidth;
    public int iSmCaptionHeight;
    public LOGFONT lfSmCaptionFont;
    public int iMenuWidth;
    public int iMenuHeight;
    public LOGFONT lfMenuFont;
    public LOGFONT lfStatusFont;
    public LOGFONT lfMessageFont;
    public int iPaddedBorderWidth;
    public static NONCLIENTMETRICS VistaMetricsStruct { get; }
    public static NONCLIENTMETRICS XPMetricsStruct { get; }
    public static NONCLIENTMETRICS get_VistaMetricsStruct();
    public static NONCLIENTMETRICS get_XPMetricsStruct();
}
internal class Standard.NOTIFYICONDATA : object {
    public int cbSize;
    public IntPtr hWnd;
    public int uID;
    public NIF uFlags;
    public int uCallbackMessage;
    public IntPtr hIcon;
    public Char[] szTip;
    public UInt32 dwState;
    public UInt32 dwStateMask;
    public Char[] szInfo;
    public UInt32 uVersion;
    public Char[] szInfoTitle;
    public UInt32 dwInfoFlags;
    public Guid guidItem;
}
internal enum Standard.OLECMDEXECOPT : Enum {
    public int value__;
    public static OLECMDEXECOPT DODEFAULT;
    public static OLECMDEXECOPT PROMPTUSER;
    public static OLECMDEXECOPT DONTPROMPTUSER;
    public static OLECMDEXECOPT SHOWHELP;
}
internal enum Standard.OLECMDF : Enum {
    public int value__;
    public static OLECMDF SUPPORTED;
    public static OLECMDF ENABLED;
    public static OLECMDF LATCHED;
    public static OLECMDF NINCHED;
    public static OLECMDF INVISIBLE;
    public static OLECMDF DEFHIDEONCTXTMENU;
}
internal enum Standard.OLECMDID : Enum {
    public int value__;
    public static OLECMDID OPEN;
    public static OLECMDID NEW;
    public static OLECMDID SAVE;
    public static OLECMDID SAVEAS;
    public static OLECMDID SAVECOPYAS;
    public static OLECMDID PRINT;
    public static OLECMDID PRINTPREVIEW;
    public static OLECMDID PAGESETUP;
    public static OLECMDID SPELL;
    public static OLECMDID PROPERTIES;
    public static OLECMDID CUT;
    public static OLECMDID COPY;
    public static OLECMDID PASTE;
    public static OLECMDID PASTESPECIAL;
    public static OLECMDID UNDO;
    public static OLECMDID REDO;
    public static OLECMDID SELECTALL;
    public static OLECMDID CLEARSELECTION;
    public static OLECMDID ZOOM;
    public static OLECMDID GETZOOMRANGE;
    public static OLECMDID UPDATECOMMANDS;
    public static OLECMDID REFRESH;
    public static OLECMDID STOP;
    public static OLECMDID HIDETOOLBARS;
    public static OLECMDID SETPROGRESSMAX;
    public static OLECMDID SETPROGRESSPOS;
    public static OLECMDID SETPROGRESSTEXT;
    public static OLECMDID SETTITLE;
    public static OLECMDID SETDOWNLOADSTATE;
    public static OLECMDID STOPDOWNLOAD;
    public static OLECMDID ONTOOLBARACTIVATED;
    public static OLECMDID FIND;
    public static OLECMDID DELETE;
    public static OLECMDID HTTPEQUIV;
    public static OLECMDID HTTPEQUIV_DONE;
    public static OLECMDID ENABLE_INTERACTION;
    public static OLECMDID ONUNLOAD;
    public static OLECMDID PROPERTYBAG2;
    public static OLECMDID PREREFRESH;
    public static OLECMDID SHOWSCRIPTERROR;
    public static OLECMDID SHOWMESSAGE;
    public static OLECMDID SHOWFIND;
    public static OLECMDID SHOWPAGESETUP;
    public static OLECMDID SHOWPRINT;
    public static OLECMDID CLOSE;
    public static OLECMDID ALLOWUILESSSAVEAS;
    public static OLECMDID DONTDOWNLOADCSS;
    public static OLECMDID UPDATEPAGESTATUS;
    public static OLECMDID PRINT2;
    public static OLECMDID PRINTPREVIEW2;
    public static OLECMDID SETPRINTTEMPLATE;
    public static OLECMDID GETPRINTTEMPLATE;
    public static OLECMDID PAGEACTIONBLOCKED;
    public static OLECMDID PAGEACTIONUIQUERY;
    public static OLECMDID FOCUSVIEWCONTROLS;
    public static OLECMDID FOCUSVIEWCONTROLSQUERY;
    public static OLECMDID SHOWPAGEACTIONMENU;
}
internal class Standard.PKEY : ValueType {
    private Guid _fmtid;
    private UInt32 _pid;
    public static PKEY Title;
    public static PKEY AppUserModel_ID;
    public static PKEY AppUserModel_IsDestListSeparator;
    public static PKEY AppUserModel_RelaunchCommand;
    public static PKEY AppUserModel_RelaunchDisplayNameResource;
    public static PKEY AppUserModel_RelaunchIconResource;
    public PKEY(Guid fmtid, UInt32 pid);
    private static PKEY();
}
internal class Standard.POINT : ValueType {
    public int x;
    public int y;
}
internal enum Standard.READYSTATE : Enum {
    public int value__;
    public static READYSTATE UNINITIALIZED;
    public static READYSTATE LOADING;
    public static READYSTATE LOADED;
    public static READYSTATE INTERACTIVE;
    public static READYSTATE COMPLETE;
}
internal class Standard.RECT : ValueType {
    private int _left;
    private int _top;
    private int _right;
    private int _bottom;
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public POINT Position { get; }
    public SIZE Size { get; }
    public void Offset(int dx, int dy);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public int get_Width();
    public int get_Height();
    public POINT get_Position();
    public SIZE get_Size();
    public static RECT Union(RECT rect1, RECT rect2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Standard.RefPOINT : object {
    public int x;
    public int y;
}
internal class Standard.RefRECT : object {
    public int Width { get; }
    public int Height { get; }
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public RefRECT(int left, int top, int right, int bottom);
    public int get_Width();
    public int get_Height();
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public void Offset(int dx, int dy);
}
internal class Standard.RGBQUAD : ValueType {
    public byte rgbBlue;
    public byte rgbGreen;
    public byte rgbRed;
    public byte rgbReserved;
}
internal enum Standard.RGN : Enum {
    public int value__;
    public static RGN AND;
    public static RGN OR;
    public static RGN XOR;
    public static RGN DIFF;
    public static RGN COPY;
}
[SecurityCriticalAttribute]
internal class Standard.SafeConnectionPointCookie : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
public SafeConnectionPointCookie(IConnectionPointContainer target, object sink, Guid eventId);
    [SecurityCriticalAttribute]
public void Disconnect();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Standard.SafeDC : SafeHandleZeroOrMinusOneIsInvalid {
    unknown IntPtr Hwnd {public set; }
    [SecurityCriticalAttribute]
public void set_Hwnd(IntPtr value);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public static SafeDC CreateDC(string deviceName);
    [SecurityCriticalAttribute]
public static SafeDC CreateCompatibleDC(SafeDC hdc);
    [SecurityCriticalAttribute]
public static SafeDC GetDC(IntPtr hwnd);
    [SecurityCriticalAttribute]
public static SafeDC GetDesktop();
    [SecurityCriticalAttribute]
public static SafeDC WrapDC(IntPtr hdc);
}
internal class Standard.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Standard.SafeGdiplusStartupToken : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public static SafeGdiplusStartupToken Startup();
}
[SecurityCriticalAttribute]
internal class Standard.SafeHBITMAP : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
internal enum Standard.SC : Enum {
    public int value__;
    public static SC SIZE;
    public static SC MOVE;
    public static SC MINIMIZE;
    public static SC MAXIMIZE;
    public static SC NEXTWINDOW;
    public static SC PREVWINDOW;
    public static SC CLOSE;
    public static SC VSCROLL;
    public static SC HSCROLL;
    public static SC MOUSEMENU;
    public static SC KEYMENU;
    public static SC ARRANGE;
    public static SC RESTORE;
    public static SC TASKLIST;
    public static SC SCREENSAVE;
    public static SC HOTKEY;
    public static SC DEFAULT;
    public static SC MONITORPOWER;
    public static SC CONTEXTHELP;
    public static SC SEPARATOR;
    public static SC F_ISSECURE;
    public static SC ICON;
    public static SC ZOOM;
}
[FlagsAttribute]
internal enum Standard.SFGAO : Enum {
    public UInt32 value__;
    public static SFGAO CANCOPY;
    public static SFGAO CANMOVE;
    public static SFGAO CANLINK;
    public static SFGAO STORAGE;
    public static SFGAO CANRENAME;
    public static SFGAO CANDELETE;
    public static SFGAO HASPROPSHEET;
    public static SFGAO DROPTARGET;
    public static SFGAO CAPABILITYMASK;
    public static SFGAO ENCRYPTED;
    public static SFGAO ISSLOW;
    public static SFGAO GHOSTED;
    public static SFGAO LINK;
    public static SFGAO SHARE;
    public static SFGAO READONLY;
    public static SFGAO HIDDEN;
    public static SFGAO DISPLAYATTRMASK;
    public static SFGAO FILESYSANCESTOR;
    public static SFGAO FOLDER;
    public static SFGAO FILESYSTEM;
    public static SFGAO HASSUBFOLDER;
    public static SFGAO CONTENTSMASK;
    public static SFGAO VALIDATE;
    public static SFGAO REMOVABLE;
    public static SFGAO COMPRESSED;
    public static SFGAO BROWSABLE;
    public static SFGAO NONENUMERATED;
    public static SFGAO NEWCONTENT;
    public static SFGAO CANMONIKER;
    public static SFGAO HASSTORAGE;
    public static SFGAO STREAM;
    public static SFGAO STORAGEANCESTOR;
    public static SFGAO STORAGECAPMASK;
    public static SFGAO PKEYSFGAOMASK;
}
internal enum Standard.SHARD : Enum {
    public int value__;
    public static SHARD PIDL;
    public static SHARD PATHA;
    public static SHARD PATHW;
    public static SHARD APPIDINFO;
    public static SHARD APPIDINFOIDLIST;
    public static SHARD LINK;
    public static SHARD APPIDINFOLINK;
}
internal class Standard.SHARDAPPIDINFO : object {
}
internal class Standard.SHARDAPPIDINFOIDLIST : object {
}
internal class Standard.SHARDAPPIDINFOLINK : object {
}
internal enum Standard.SHCONTF : Enum {
    public int value__;
    public static SHCONTF CHECKING_FOR_CHILDREN;
    public static SHCONTF FOLDERS;
    public static SHCONTF NONFOLDERS;
    public static SHCONTF INCLUDEHIDDEN;
    public static SHCONTF INIT_ON_FIRST_NEXT;
    public static SHCONTF NETPRINTERSRCH;
    public static SHCONTF SHAREABLE;
    public static SHCONTF STORAGE;
    public static SHCONTF NAVIGATION_ENUM;
    public static SHCONTF FASTITEMS;
    public static SHCONTF FLATLIST;
    public static SHCONTF ENABLE_ASYNC;
}
internal class Standard.SHFILEOPSTRUCT : ValueType {
    public IntPtr hwnd;
    public FO wFunc;
    public string pFrom;
    public string pTo;
    public FOF fFlags;
    public int fAnyOperationsAborted;
    public IntPtr hNameMappings;
    public string lpszProgressTitle;
}
[FlagsAttribute]
internal enum Standard.SHGDN : Enum {
    public int value__;
    public static SHGDN SHGDN_NORMAL;
    public static SHGDN SHGDN_INFOLDER;
    public static SHGDN SHGDN_FOREDITING;
    public static SHGDN SHGDN_FORADDRESSBAR;
    public static SHGDN SHGDN_FORPARSING;
}
internal enum Standard.SIATTRIBFLAGS : Enum {
    public int value__;
    public static SIATTRIBFLAGS AND;
    public static SIATTRIBFLAGS OR;
    public static SIATTRIBFLAGS APPCOMPAT;
}
internal enum Standard.SICHINT : Enum {
    public UInt32 value__;
    public static SICHINT DISPLAY;
    public static SICHINT ALLFIELDS;
    public static SICHINT CANONICAL;
    public static SICHINT TEST_FILESYSPATH_IF_NOT_EQUAL;
}
internal enum Standard.SIGDN : Enum {
    public UInt32 value__;
    public static SIGDN NORMALDISPLAY;
    public static SIGDN PARENTRELATIVEPARSING;
    public static SIGDN DESKTOPABSOLUTEPARSING;
    public static SIGDN PARENTRELATIVEEDITING;
    public static SIGDN DESKTOPABSOLUTEEDITING;
    public static SIGDN FILESYSPATH;
    public static SIGDN URL;
    public static SIGDN PARENTRELATIVEFORADDRESSBAR;
    public static SIGDN PARENTRELATIVE;
}
internal class Standard.SIZE : ValueType {
    public int cx;
    public int cy;
}
[FlagsAttribute]
internal enum Standard.SLGP : Enum {
    public int value__;
    public static SLGP SHORTPATH;
    public static SLGP UNCPRIORITY;
    public static SLGP RAWPATH;
}
internal enum Standard.SM : Enum {
    public int value__;
    public static SM CXSCREEN;
    public static SM CYSCREEN;
    public static SM CXVSCROLL;
    public static SM CYHSCROLL;
    public static SM CYCAPTION;
    public static SM CXBORDER;
    public static SM CYBORDER;
    public static SM CXFIXEDFRAME;
    public static SM CYFIXEDFRAME;
    public static SM CYVTHUMB;
    public static SM CXHTHUMB;
    public static SM CXICON;
    public static SM CYICON;
    public static SM CXCURSOR;
    public static SM CYCURSOR;
    public static SM CYMENU;
    public static SM CXFULLSCREEN;
    public static SM CYFULLSCREEN;
    public static SM CYKANJIWINDOW;
    public static SM MOUSEPRESENT;
    public static SM CYVSCROLL;
    public static SM CXHSCROLL;
    public static SM DEBUG;
    public static SM SWAPBUTTON;
    public static SM CXMIN;
    public static SM CYMIN;
    public static SM CXSIZE;
    public static SM CYSIZE;
    public static SM CXFRAME;
    public static SM CXSIZEFRAME;
    public static SM CYFRAME;
    public static SM CYSIZEFRAME;
    public static SM CXMINTRACK;
    public static SM CYMINTRACK;
    public static SM CXDOUBLECLK;
    public static SM CYDOUBLECLK;
    public static SM CXICONSPACING;
    public static SM CYICONSPACING;
    public static SM MENUDROPALIGNMENT;
    public static SM PENWINDOWS;
    public static SM DBCSENABLED;
    public static SM CMOUSEBUTTONS;
    public static SM SECURE;
    public static SM CXEDGE;
    public static SM CYEDGE;
    public static SM CXMINSPACING;
    public static SM CYMINSPACING;
    public static SM CXSMICON;
    public static SM CYSMICON;
    public static SM CYSMCAPTION;
    public static SM CXSMSIZE;
    public static SM CYSMSIZE;
    public static SM CXMENUSIZE;
    public static SM CYMENUSIZE;
    public static SM ARRANGE;
    public static SM CXMINIMIZED;
    public static SM CYMINIMIZED;
    public static SM CXMAXTRACK;
    public static SM CYMAXTRACK;
    public static SM CXMAXIMIZED;
    public static SM CYMAXIMIZED;
    public static SM NETWORK;
    public static SM CLEANBOOT;
    public static SM CXDRAG;
    public static SM CYDRAG;
    public static SM SHOWSOUNDS;
    public static SM CXMENUCHECK;
    public static SM CYMENUCHECK;
    public static SM SLOWMACHINE;
    public static SM MIDEASTENABLED;
    public static SM MOUSEWHEELPRESENT;
    public static SM XVIRTUALSCREEN;
    public static SM YVIRTUALSCREEN;
    public static SM CXVIRTUALSCREEN;
    public static SM CYVIRTUALSCREEN;
    public static SM CMONITORS;
    public static SM SAMEDISPLAYFORMAT;
    public static SM IMMENABLED;
    public static SM CXFOCUSBORDER;
    public static SM CYFOCUSBORDER;
    public static SM TABLETPC;
    public static SM MEDIACENTER;
    public static SM REMOTESESSION;
    public static SM REMOTECONTROL;
}
internal enum Standard.SPI : Enum {
    public int value__;
    public static SPI GETBEEP;
    public static SPI SETBEEP;
    public static SPI GETMOUSE;
    public static SPI SETMOUSE;
    public static SPI GETBORDER;
    public static SPI SETBORDER;
    public static SPI GETKEYBOARDSPEED;
    public static SPI SETKEYBOARDSPEED;
    public static SPI LANGDRIVER;
    public static SPI ICONHORIZONTALSPACING;
    public static SPI GETSCREENSAVETIMEOUT;
    public static SPI SETSCREENSAVETIMEOUT;
    public static SPI GETSCREENSAVEACTIVE;
    public static SPI SETSCREENSAVEACTIVE;
    public static SPI GETGRIDGRANULARITY;
    public static SPI SETGRIDGRANULARITY;
    public static SPI SETDESKWALLPAPER;
    public static SPI SETDESKPATTERN;
    public static SPI GETKEYBOARDDELAY;
    public static SPI SETKEYBOARDDELAY;
    public static SPI ICONVERTICALSPACING;
    public static SPI GETICONTITLEWRAP;
    public static SPI SETICONTITLEWRAP;
    public static SPI GETMENUDROPALIGNMENT;
    public static SPI SETMENUDROPALIGNMENT;
    public static SPI SETDOUBLECLKWIDTH;
    public static SPI SETDOUBLECLKHEIGHT;
    public static SPI GETICONTITLELOGFONT;
    public static SPI SETDOUBLECLICKTIME;
    public static SPI SETMOUSEBUTTONSWAP;
    public static SPI SETICONTITLELOGFONT;
    public static SPI GETFASTTASKSWITCH;
    public static SPI SETFASTTASKSWITCH;
    public static SPI SETDRAGFULLWINDOWS;
    public static SPI GETDRAGFULLWINDOWS;
    public static SPI GETNONCLIENTMETRICS;
    public static SPI SETNONCLIENTMETRICS;
    public static SPI GETMINIMIZEDMETRICS;
    public static SPI SETMINIMIZEDMETRICS;
    public static SPI GETICONMETRICS;
    public static SPI SETICONMETRICS;
    public static SPI SETWORKAREA;
    public static SPI GETWORKAREA;
    public static SPI SETPENWINDOWS;
    public static SPI GETHIGHCONTRAST;
    public static SPI SETHIGHCONTRAST;
    public static SPI GETKEYBOARDPREF;
    public static SPI SETKEYBOARDPREF;
    public static SPI GETSCREENREADER;
    public static SPI SETSCREENREADER;
    public static SPI GETANIMATION;
    public static SPI SETANIMATION;
    public static SPI GETFONTSMOOTHING;
    public static SPI SETFONTSMOOTHING;
    public static SPI SETDRAGWIDTH;
    public static SPI SETDRAGHEIGHT;
    public static SPI SETHANDHELD;
    public static SPI GETLOWPOWERTIMEOUT;
    public static SPI GETPOWEROFFTIMEOUT;
    public static SPI SETLOWPOWERTIMEOUT;
    public static SPI SETPOWEROFFTIMEOUT;
    public static SPI GETLOWPOWERACTIVE;
    public static SPI GETPOWEROFFACTIVE;
    public static SPI SETLOWPOWERACTIVE;
    public static SPI SETPOWEROFFACTIVE;
    public static SPI SETCURSORS;
    public static SPI SETICONS;
    public static SPI GETDEFAULTINPUTLANG;
    public static SPI SETDEFAULTINPUTLANG;
    public static SPI SETLANGTOGGLE;
    public static SPI GETWINDOWSEXTENSION;
    public static SPI SETMOUSETRAILS;
    public static SPI GETMOUSETRAILS;
    public static SPI SETSCREENSAVERRUNNING;
    public static SPI SCREENSAVERRUNNING;
    public static SPI GETFILTERKEYS;
    public static SPI SETFILTERKEYS;
    public static SPI GETTOGGLEKEYS;
    public static SPI SETTOGGLEKEYS;
    public static SPI GETMOUSEKEYS;
    public static SPI SETMOUSEKEYS;
    public static SPI GETSHOWSOUNDS;
    public static SPI SETSHOWSOUNDS;
    public static SPI GETSTICKYKEYS;
    public static SPI SETSTICKYKEYS;
    public static SPI GETACCESSTIMEOUT;
    public static SPI SETACCESSTIMEOUT;
    public static SPI GETSERIALKEYS;
    public static SPI SETSERIALKEYS;
    public static SPI GETSOUNDSENTRY;
    public static SPI SETSOUNDSENTRY;
    public static SPI GETSNAPTODEFBUTTON;
    public static SPI SETSNAPTODEFBUTTON;
    public static SPI GETMOUSEHOVERWIDTH;
    public static SPI SETMOUSEHOVERWIDTH;
    public static SPI GETMOUSEHOVERHEIGHT;
    public static SPI SETMOUSEHOVERHEIGHT;
    public static SPI GETMOUSEHOVERTIME;
    public static SPI SETMOUSEHOVERTIME;
    public static SPI GETWHEELSCROLLLINES;
    public static SPI SETWHEELSCROLLLINES;
    public static SPI GETMENUSHOWDELAY;
    public static SPI SETMENUSHOWDELAY;
    public static SPI GETWHEELSCROLLCHARS;
    public static SPI SETWHEELSCROLLCHARS;
    public static SPI GETSHOWIMEUI;
    public static SPI SETSHOWIMEUI;
    public static SPI GETMOUSESPEED;
    public static SPI SETMOUSESPEED;
    public static SPI GETSCREENSAVERRUNNING;
    public static SPI GETDESKWALLPAPER;
    public static SPI GETAUDIODESCRIPTION;
    public static SPI SETAUDIODESCRIPTION;
    public static SPI GETSCREENSAVESECURE;
    public static SPI SETSCREENSAVESECURE;
    public static SPI GETHUNGAPPTIMEOUT;
    public static SPI SETHUNGAPPTIMEOUT;
    public static SPI GETWAITTOKILLTIMEOUT;
    public static SPI SETWAITTOKILLTIMEOUT;
    public static SPI GETWAITTOKILLSERVICETIMEOUT;
    public static SPI SETWAITTOKILLSERVICETIMEOUT;
    public static SPI GETMOUSEDOCKTHRESHOLD;
    public static SPI SETMOUSEDOCKTHRESHOLD;
    public static SPI GETPENDOCKTHRESHOLD;
    public static SPI SETPENDOCKTHRESHOLD;
    public static SPI GETWINARRANGING;
    public static SPI SETWINARRANGING;
    public static SPI GETMOUSEDRAGOUTTHRESHOLD;
    public static SPI SETMOUSEDRAGOUTTHRESHOLD;
    public static SPI GETPENDRAGOUTTHRESHOLD;
    public static SPI SETPENDRAGOUTTHRESHOLD;
    public static SPI GETMOUSESIDEMOVETHRESHOLD;
    public static SPI SETMOUSESIDEMOVETHRESHOLD;
    public static SPI GETPENSIDEMOVETHRESHOLD;
    public static SPI SETPENSIDEMOVETHRESHOLD;
    public static SPI GETDRAGFROMMAXIMIZE;
    public static SPI SETDRAGFROMMAXIMIZE;
    public static SPI GETSNAPSIZING;
    public static SPI SETSNAPSIZING;
    public static SPI GETDOCKMOVING;
    public static SPI SETDOCKMOVING;
    public static SPI GETACTIVEWINDOWTRACKING;
    public static SPI SETACTIVEWINDOWTRACKING;
    public static SPI GETMENUANIMATION;
    public static SPI SETMENUANIMATION;
    public static SPI GETCOMBOBOXANIMATION;
    public static SPI SETCOMBOBOXANIMATION;
    public static SPI GETLISTBOXSMOOTHSCROLLING;
    public static SPI SETLISTBOXSMOOTHSCROLLING;
    public static SPI GETGRADIENTCAPTIONS;
    public static SPI SETGRADIENTCAPTIONS;
    public static SPI GETKEYBOARDCUES;
    public static SPI SETKEYBOARDCUES;
    public static SPI GETMENUUNDERLINES;
    public static SPI SETMENUUNDERLINES;
    public static SPI GETACTIVEWNDTRKZORDER;
    public static SPI SETACTIVEWNDTRKZORDER;
    public static SPI GETHOTTRACKING;
    public static SPI SETHOTTRACKING;
    public static SPI GETMENUFADE;
    public static SPI SETMENUFADE;
    public static SPI GETSELECTIONFADE;
    public static SPI SETSELECTIONFADE;
    public static SPI GETTOOLTIPANIMATION;
    public static SPI SETTOOLTIPANIMATION;
    public static SPI GETTOOLTIPFADE;
    public static SPI SETTOOLTIPFADE;
    public static SPI GETCURSORSHADOW;
    public static SPI SETCURSORSHADOW;
    public static SPI GETMOUSESONAR;
    public static SPI SETMOUSESONAR;
    public static SPI GETMOUSECLICKLOCK;
    public static SPI SETMOUSECLICKLOCK;
    public static SPI GETMOUSEVANISH;
    public static SPI SETMOUSEVANISH;
    public static SPI GETFLATMENU;
    public static SPI SETFLATMENU;
    public static SPI GETDROPSHADOW;
    public static SPI SETDROPSHADOW;
    public static SPI GETBLOCKSENDINPUTRESETS;
    public static SPI SETBLOCKSENDINPUTRESETS;
    public static SPI GETUIEFFECTS;
    public static SPI SETUIEFFECTS;
    public static SPI GETDISABLEOVERLAPPEDCONTENT;
    public static SPI SETDISABLEOVERLAPPEDCONTENT;
    public static SPI GETCLIENTAREAANIMATION;
    public static SPI SETCLIENTAREAANIMATION;
    public static SPI GETCLEARTYPE;
    public static SPI SETCLEARTYPE;
    public static SPI GETSPEECHRECOGNITION;
    public static SPI SETSPEECHRECOGNITION;
    public static SPI GETFOREGROUNDLOCKTIMEOUT;
    public static SPI SETFOREGROUNDLOCKTIMEOUT;
    public static SPI GETACTIVEWNDTRKTIMEOUT;
    public static SPI SETACTIVEWNDTRKTIMEOUT;
    public static SPI GETFOREGROUNDFLASHCOUNT;
    public static SPI SETFOREGROUNDFLASHCOUNT;
    public static SPI GETCARETWIDTH;
    public static SPI SETCARETWIDTH;
    public static SPI GETMOUSECLICKLOCKTIME;
    public static SPI SETMOUSECLICKLOCKTIME;
    public static SPI GETFONTSMOOTHINGTYPE;
    public static SPI SETFONTSMOOTHINGTYPE;
    public static SPI GETFONTSMOOTHINGCONTRAST;
    public static SPI SETFONTSMOOTHINGCONTRAST;
    public static SPI GETFOCUSBORDERWIDTH;
    public static SPI SETFOCUSBORDERWIDTH;
    public static SPI GETFOCUSBORDERHEIGHT;
    public static SPI SETFOCUSBORDERHEIGHT;
    public static SPI GETFONTSMOOTHINGORIENTATION;
    public static SPI SETFONTSMOOTHINGORIENTATION;
    public static SPI GETMINIMUMHITRADIUS;
    public static SPI SETMINIMUMHITRADIUS;
    public static SPI GETMESSAGEDURATION;
    public static SPI SETMESSAGEDURATION;
}
[FlagsAttribute]
internal enum Standard.SPIF : Enum {
    public int value__;
    public static SPIF None;
    public static SPIF UPDATEINIFILE;
    public static SPIF SENDCHANGE;
    public static SPIF SENDWININICHANGE;
}
internal class Standard.StartupInput : object {
    public int GdiplusVersion;
    public IntPtr DebugEventCallback;
    public bool SuppressBackgroundThread;
    public bool SuppressExternalCodecs;
}
internal class Standard.StartupOutput : ValueType {
    public IntPtr hook;
    public IntPtr unhook;
}
[FlagsAttribute]
internal enum Standard.STATE_SYSTEM : Enum {
    public int value__;
    public static STATE_SYSTEM UNAVAILABLE;
    public static STATE_SYSTEM SELECTED;
    public static STATE_SYSTEM FOCUSED;
    public static STATE_SYSTEM PRESSED;
    public static STATE_SYSTEM CHECKED;
    public static STATE_SYSTEM MIXED;
    public static STATE_SYSTEM INDETERMINATE;
    public static STATE_SYSTEM READONLY;
    public static STATE_SYSTEM HOTTRACKED;
    public static STATE_SYSTEM DEFAULT;
    public static STATE_SYSTEM EXPANDED;
    public static STATE_SYSTEM COLLAPSED;
    public static STATE_SYSTEM BUSY;
    public static STATE_SYSTEM FLOATING;
    public static STATE_SYSTEM MARQUEED;
    public static STATE_SYSTEM ANIMATED;
    public static STATE_SYSTEM INVISIBLE;
    public static STATE_SYSTEM OFFSCREEN;
    public static STATE_SYSTEM SIZEABLE;
    public static STATE_SYSTEM MOVEABLE;
    public static STATE_SYSTEM SELFVOICING;
    public static STATE_SYSTEM FOCUSABLE;
    public static STATE_SYSTEM SELECTABLE;
    public static STATE_SYSTEM LINKED;
    public static STATE_SYSTEM TRAVERSED;
    public static STATE_SYSTEM MULTISELECTABLE;
    public static STATE_SYSTEM EXTSELECTABLE;
    public static STATE_SYSTEM ALERT_LOW;
    public static STATE_SYSTEM ALERT_MEDIUM;
    public static STATE_SYSTEM ALERT_HIGH;
    public static STATE_SYSTEM PROTECTED;
    public static STATE_SYSTEM VALID;
}
internal enum Standard.Status : Enum {
    public int value__;
    public static Status Ok;
    public static Status GenericError;
    public static Status InvalidParameter;
    public static Status OutOfMemory;
    public static Status ObjectBusy;
    public static Status InsufficientBuffer;
    public static Status NotImplemented;
    public static Status Win32Error;
    public static Status WrongState;
    public static Status Aborted;
    public static Status FileNotFound;
    public static Status ValueOverflow;
    public static Status AccessDenied;
    public static Status UnknownImageFormat;
    public static Status FontFamilyNotFound;
    public static Status FontStyleNotFound;
    public static Status NotTrueTypeFont;
    public static Status UnsupportedGdiplusVersion;
    public static Status GdiplusNotInitialized;
    public static Status PropertyNotFound;
    public static Status PropertyNotSupported;
    public static Status ProfileNotFound;
}
internal enum Standard.StockObject : Enum {
    public int value__;
    public static StockObject WHITE_BRUSH;
    public static StockObject LTGRAY_BRUSH;
    public static StockObject GRAY_BRUSH;
    public static StockObject DKGRAY_BRUSH;
    public static StockObject BLACK_BRUSH;
    public static StockObject NULL_BRUSH;
    public static StockObject HOLLOW_BRUSH;
    public static StockObject WHITE_PEN;
    public static StockObject BLACK_PEN;
    public static StockObject NULL_PEN;
    public static StockObject SYSTEM_FONT;
    public static StockObject DEFAULT_PALETTE;
}
[FlagsAttribute]
internal enum Standard.STPF : Enum {
    public int value__;
    public static STPF NONE;
    public static STPF USEAPPTHUMBNAILALWAYS;
    public static STPF USEAPPTHUMBNAILWHENACTIVE;
    public static STPF USEAPPPEEKALWAYS;
    public static STPF USEAPPPEEKWHENACTIVE;
}
internal static class Standard.STR_GPS : object {
    public static string HANDLERPROPERTIESONLY;
    public static string FASTPROPERTIESONLY;
    public static string OPENSLOWITEM;
    public static string DELAYCREATION;
    public static string BESTEFFORT;
    public static string NO_OPLOCK;
}
internal enum Standard.SW : Enum {
    public int value__;
    public static SW HIDE;
    public static SW SHOWNORMAL;
    public static SW NORMAL;
    public static SW SHOWMINIMIZED;
    public static SW SHOWMAXIMIZED;
    public static SW MAXIMIZE;
    public static SW SHOWNOACTIVATE;
    public static SW SHOW;
    public static SW MINIMIZE;
    public static SW SHOWMINNOACTIVE;
    public static SW SHOWNA;
    public static SW RESTORE;
    public static SW SHOWDEFAULT;
    public static SW FORCEMINIMIZE;
}
[FlagsAttribute]
internal enum Standard.SWP : Enum {
    public int value__;
    public static SWP ASYNCWINDOWPOS;
    public static SWP DEFERERASE;
    public static SWP DRAWFRAME;
    public static SWP FRAMECHANGED;
    public static SWP HIDEWINDOW;
    public static SWP NOACTIVATE;
    public static SWP NOCOPYBITS;
    public static SWP NOMOVE;
    public static SWP NOOWNERZORDER;
    public static SWP NOREDRAW;
    public static SWP NOREPOSITION;
    public static SWP NOSENDCHANGING;
    public static SWP NOSIZE;
    public static SWP NOZORDER;
    public static SWP SHOWWINDOW;
}
internal enum Standard.TBPF : Enum {
    public int value__;
    public static TBPF NOPROGRESS;
    public static TBPF INDETERMINATE;
    public static TBPF NORMAL;
    public static TBPF ERROR;
    public static TBPF PAUSED;
}
[FlagsAttribute]
internal enum Standard.THB : Enum {
    public UInt32 value__;
    public static THB BITMAP;
    public static THB ICON;
    public static THB TOOLTIP;
    public static THB FLAGS;
}
[FlagsAttribute]
internal enum Standard.THBF : Enum {
    public UInt32 value__;
    public static THBF ENABLED;
    public static THBF DISABLED;
    public static THBF DISMISSONCLICK;
    public static THBF NOBACKGROUND;
    public static THBF HIDDEN;
    public static THBF NONINTERACTIVE;
}
internal class Standard.THUMBBUTTON : ValueType {
    public static int THBN_CLICKED;
    public THB dwMask;
    public UInt32 iId;
    public UInt32 iBitmap;
    public IntPtr hIcon;
    public string szTip;
    public THBF dwFlags;
}
internal class Standard.TITLEBARINFO : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
}
internal class Standard.TITLEBARINFOEX : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
    public RECT rgrect_TitleBar;
    public RECT rgrect_Reserved;
    public RECT rgrect_MinimizeButton;
    public RECT rgrect_MaximizeButton;
    public RECT rgrect_HelpButton;
    public RECT rgrect_CloseButton;
}
internal enum Standard.ULW : Enum {
    public int value__;
    public static ULW ALPHA;
    public static ULW COLORKEY;
    public static ULW OPAQUE;
}
internal class Standard.UNSIGNED_RATIO : ValueType {
    public UInt32 uiNumerator;
    public UInt32 uiDenominator;
}
internal static class Standard.Utility : object {
    public static bool IsOSVistaOrNewer { get; }
    public static bool IsOSWindows7OrNewer { get; }
    public static bool IsPresentationFrameworkVersionLessThan4 { get; }
    private static Utility();
    public static Color ColorFromArgbDword(UInt32 color);
    public static int GET_X_LPARAM(IntPtr lParam);
    public static int GET_Y_LPARAM(IntPtr lParam);
    public static int HIWORD(int i);
    public static int LOWORD(int i);
    public static bool IsFlagSet(int value, int mask);
    public static bool IsFlagSet(UInt32 value, UInt32 mask);
    public static bool IsFlagSet(long value, long mask);
    public static bool IsFlagSet(ulong value, ulong mask);
    public static bool get_IsOSVistaOrNewer();
    public static bool get_IsOSWindows7OrNewer();
    public static bool get_IsPresentationFrameworkVersionLessThan4();
    public static BitmapFrame GetBestMatch(IList`1<BitmapFrame> frames, int width, int height);
    [SecurityCriticalAttribute]
public static void SafeDeleteObject(IntPtr& gdiObject);
    [SecurityCriticalAttribute]
public static void SafeDestroyWindow(IntPtr& hwnd);
    [SecurityCriticalAttribute]
public static void SafeRelease(T& comObject);
    public static void AddDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static void RemoveDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static bool IsThicknessNonNegative(Thickness thickness);
    public static bool IsCornerRadiusValid(CornerRadius cornerRadius);
    public static bool IsDoubleFiniteAndNonNegative(double d);
}
internal static class Standard.Verify : object {
    [DebuggerStepThroughAttribute]
public static void IsApartmentState(ApartmentState requiredState, string message);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorEmpty(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorWhitespace(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotDefault(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name, string message);
    [DebuggerStepThroughAttribute]
public static void AreEqual(T expected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void AreNotEqual(T notExpected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void UriIsAbsolute(Uri uri, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive, string message, string parameter);
    [DebuggerStepThroughAttribute]
public static void TypeSupportsInterface(Type type, Type interfaceType, string parameterName);
    [DebuggerStepThroughAttribute]
public static void FileExists(string filePath, string parameterName);
    [DebuggerStepThroughAttribute]
internal static void ImplementsInterface(object parameter, Type interfaceType, string parameterName);
}
[BestFitMappingAttribute("False")]
internal class Standard.WIN32_FIND_DATAW : object {
    public FileAttributes dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public int nFileSizeHigh;
    public int nFileSizeLow;
    public int dwReserved0;
    public int dwReserved1;
    public string cFileName;
    public string cAlternateFileName;
}
internal class Standard.Win32Error : ValueType {
    private int _value;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INVALID_FUNCTION;
    public static Win32Error ERROR_FILE_NOT_FOUND;
    public static Win32Error ERROR_PATH_NOT_FOUND;
    public static Win32Error ERROR_TOO_MANY_OPEN_FILES;
    public static Win32Error ERROR_ACCESS_DENIED;
    public static Win32Error ERROR_INVALID_HANDLE;
    public static Win32Error ERROR_OUTOFMEMORY;
    public static Win32Error ERROR_NO_MORE_FILES;
    public static Win32Error ERROR_SHARING_VIOLATION;
    public static Win32Error ERROR_INVALID_PARAMETER;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NESTING_NOT_ALLOWED;
    public static Win32Error ERROR_KEY_DELETED;
    public static Win32Error ERROR_NOT_FOUND;
    public static Win32Error ERROR_NO_MATCH;
    public static Win32Error ERROR_BAD_DEVICE;
    public static Win32Error ERROR_CANCELLED;
    public static Win32Error ERROR_CLASS_ALREADY_EXISTS;
    public static Win32Error ERROR_INVALID_DATATYPE;
    public Win32Error(int i);
    private static Win32Error();
    public static HRESULT op_Explicit(Win32Error error);
    public HRESULT ToHRESULT();
    [SecurityCriticalAttribute]
public static Win32Error GetLastError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Win32Error errLeft, Win32Error errRight);
    public static bool op_Inequality(Win32Error errLeft, Win32Error errRight);
}
internal static class Standard.Win32Value : object {
    public static UInt32 MAX_PATH;
    public static UInt32 INFOTIPSIZE;
    public static UInt32 TRUE;
    public static UInt32 FALSE;
    public static UInt32 sizeof_WCHAR;
    public static UInt32 sizeof_CHAR;
    public static UInt32 sizeof_BOOL;
}
internal class Standard.WINDOWPLACEMENT : object {
    public int length;
    public int flags;
    public SW showCmd;
    public POINT ptMinPosition;
    public POINT ptMaxPosition;
    public RECT rcNormalPosition;
}
internal class Standard.WINDOWPOS : ValueType {
    public IntPtr hwnd;
    public IntPtr hwndInsertAfter;
    public int x;
    public int y;
    public int cx;
    public int cy;
    public int flags;
}
internal enum Standard.WINDOWTHEMEATTRIBUTETYPE : Enum {
    public UInt32 value__;
    public static WINDOWTHEMEATTRIBUTETYPE WTA_NONCLIENT;
}
internal enum Standard.WM : Enum {
    public int value__;
    public static WM NULL;
    public static WM CREATE;
    public static WM DESTROY;
    public static WM MOVE;
    public static WM SIZE;
    public static WM ACTIVATE;
    public static WM SETFOCUS;
    public static WM KILLFOCUS;
    public static WM ENABLE;
    public static WM SETREDRAW;
    public static WM SETTEXT;
    public static WM GETTEXT;
    public static WM GETTEXTLENGTH;
    public static WM PAINT;
    public static WM CLOSE;
    public static WM QUERYENDSESSION;
    public static WM QUIT;
    public static WM QUERYOPEN;
    public static WM ERASEBKGND;
    public static WM SYSCOLORCHANGE;
    public static WM SHOWWINDOW;
    public static WM CTLCOLOR;
    public static WM WININICHANGE;
    public static WM SETTINGCHANGE;
    public static WM ACTIVATEAPP;
    public static WM SETCURSOR;
    public static WM MOUSEACTIVATE;
    public static WM CHILDACTIVATE;
    public static WM QUEUESYNC;
    public static WM GETMINMAXINFO;
    public static WM WINDOWPOSCHANGING;
    public static WM WINDOWPOSCHANGED;
    public static WM CONTEXTMENU;
    public static WM STYLECHANGING;
    public static WM STYLECHANGED;
    public static WM DISPLAYCHANGE;
    public static WM GETICON;
    public static WM SETICON;
    public static WM NCCREATE;
    public static WM NCDESTROY;
    public static WM NCCALCSIZE;
    public static WM NCHITTEST;
    public static WM NCPAINT;
    public static WM NCACTIVATE;
    public static WM GETDLGCODE;
    public static WM SYNCPAINT;
    public static WM NCMOUSEMOVE;
    public static WM NCLBUTTONDOWN;
    public static WM NCLBUTTONUP;
    public static WM NCLBUTTONDBLCLK;
    public static WM NCRBUTTONDOWN;
    public static WM NCRBUTTONUP;
    public static WM NCRBUTTONDBLCLK;
    public static WM NCMBUTTONDOWN;
    public static WM NCMBUTTONUP;
    public static WM NCMBUTTONDBLCLK;
    public static WM SYSKEYDOWN;
    public static WM SYSKEYUP;
    public static WM SYSCHAR;
    public static WM SYSDEADCHAR;
    public static WM COMMAND;
    public static WM SYSCOMMAND;
    public static WM MOUSEMOVE;
    public static WM LBUTTONDOWN;
    public static WM LBUTTONUP;
    public static WM LBUTTONDBLCLK;
    public static WM RBUTTONDOWN;
    public static WM RBUTTONUP;
    public static WM RBUTTONDBLCLK;
    public static WM MBUTTONDOWN;
    public static WM MBUTTONUP;
    public static WM MBUTTONDBLCLK;
    public static WM MOUSEWHEEL;
    public static WM XBUTTONDOWN;
    public static WM XBUTTONUP;
    public static WM XBUTTONDBLCLK;
    public static WM MOUSEHWHEEL;
    public static WM PARENTNOTIFY;
    public static WM CAPTURECHANGED;
    public static WM POWERBROADCAST;
    public static WM DEVICECHANGE;
    public static WM ENTERSIZEMOVE;
    public static WM EXITSIZEMOVE;
    public static WM IME_SETCONTEXT;
    public static WM IME_NOTIFY;
    public static WM IME_CONTROL;
    public static WM IME_COMPOSITIONFULL;
    public static WM IME_SELECT;
    public static WM IME_CHAR;
    public static WM IME_REQUEST;
    public static WM IME_KEYDOWN;
    public static WM IME_KEYUP;
    public static WM NCMOUSELEAVE;
    public static WM TABLET_DEFBASE;
    public static WM TABLET_ADDED;
    public static WM TABLET_DELETED;
    public static WM TABLET_FLICK;
    public static WM TABLET_QUERYSYSTEMGESTURESTATUS;
    public static WM CUT;
    public static WM COPY;
    public static WM PASTE;
    public static WM CLEAR;
    public static WM UNDO;
    public static WM RENDERFORMAT;
    public static WM RENDERALLFORMATS;
    public static WM DESTROYCLIPBOARD;
    public static WM DRAWCLIPBOARD;
    public static WM PAINTCLIPBOARD;
    public static WM VSCROLLCLIPBOARD;
    public static WM SIZECLIPBOARD;
    public static WM ASKCBFORMATNAME;
    public static WM CHANGECBCHAIN;
    public static WM HSCROLLCLIPBOARD;
    public static WM QUERYNEWPALETTE;
    public static WM PALETTEISCHANGING;
    public static WM PALETTECHANGED;
    public static WM HOTKEY;
    public static WM PRINT;
    public static WM PRINTCLIENT;
    public static WM APPCOMMAND;
    public static WM THEMECHANGED;
    public static WM DWMCOMPOSITIONCHANGED;
    public static WM DWMNCRENDERINGCHANGED;
    public static WM DWMCOLORIZATIONCOLORCHANGED;
    public static WM DWMWINDOWMAXIMIZEDCHANGE;
    public static WM GETTITLEBARINFOEX;
    public static WM DWMSENDICONICTHUMBNAIL;
    public static WM DWMSENDICONICLIVEPREVIEWBITMAP;
    public static WM USER;
    public static WM TRAYMOUSEMESSAGE;
    public static WM APP;
}
internal class Standard.WNDCLASSEX : ValueType {
    public int cbSize;
    public CS style;
    public WndProc lpfnWndProc;
    public int cbClsExtra;
    public int cbWndExtra;
    public IntPtr hInstance;
    public IntPtr hIcon;
    public IntPtr hCursor;
    public IntPtr hbrBackground;
    public string lpszMenuName;
    public string lpszClassName;
    public IntPtr hIconSm;
}
internal class Standard.WndProc : MulticastDelegate {
    public WndProc(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
internal class Standard.WndProcHook : MulticastDelegate {
    public WndProcHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
[FlagsAttribute]
internal enum Standard.WS : Enum {
    public UInt32 value__;
    public static WS OVERLAPPED;
    public static WS POPUP;
    public static WS CHILD;
    public static WS MINIMIZE;
    public static WS VISIBLE;
    public static WS DISABLED;
    public static WS CLIPSIBLINGS;
    public static WS CLIPCHILDREN;
    public static WS MAXIMIZE;
    public static WS BORDER;
    public static WS DLGFRAME;
    public static WS VSCROLL;
    public static WS HSCROLL;
    public static WS SYSMENU;
    public static WS THICKFRAME;
    public static WS GROUP;
    public static WS TABSTOP;
    public static WS MINIMIZEBOX;
    public static WS MAXIMIZEBOX;
    public static WS CAPTION;
    public static WS TILED;
    public static WS ICONIC;
    public static WS SIZEBOX;
    public static WS TILEDWINDOW;
    public static WS OVERLAPPEDWINDOW;
    public static WS POPUPWINDOW;
    public static WS CHILDWINDOW;
}
[FlagsAttribute]
internal enum Standard.WS_EX : Enum {
    public UInt32 value__;
    public static WS_EX None;
    public static WS_EX DLGMODALFRAME;
    public static WS_EX NOPARENTNOTIFY;
    public static WS_EX TOPMOST;
    public static WS_EX ACCEPTFILES;
    public static WS_EX TRANSPARENT;
    public static WS_EX MDICHILD;
    public static WS_EX TOOLWINDOW;
    public static WS_EX WINDOWEDGE;
    public static WS_EX CLIENTEDGE;
    public static WS_EX CONTEXTHELP;
    public static WS_EX RIGHT;
    public static WS_EX LEFT;
    public static WS_EX RTLREADING;
    public static WS_EX LTRREADING;
    public static WS_EX LEFTSCROLLBAR;
    public static WS_EX RIGHTSCROLLBAR;
    public static WS_EX CONTROLPARENT;
    public static WS_EX STATICEDGE;
    public static WS_EX APPWINDOW;
    public static WS_EX LAYERED;
    public static WS_EX NOINHERITLAYOUT;
    public static WS_EX LAYOUTRTL;
    public static WS_EX COMPOSITED;
    public static WS_EX NOACTIVATE;
    public static WS_EX OVERLAPPEDWINDOW;
    public static WS_EX PALETTEWINDOW;
}
internal class Standard.WTA_OPTIONS : ValueType {
    public static UInt32 Size;
    public WTNCA dwFlags;
    public WTNCA dwMask;
}
[FlagsAttribute]
internal enum Standard.WTNCA : Enum {
    public UInt32 value__;
    public static WTNCA NODRAWCAPTION;
    public static WTNCA NODRAWICON;
    public static WTNCA NOSYSMENU;
    public static WTNCA NOMIRRORHELP;
    public static WTNCA VALIDBITS;
}
internal enum Standard.WVR : Enum {
    public int value__;
    public static WVR ALIGNTOP;
    public static WVR ALIGNLEFT;
    public static WVR ALIGNBOTTOM;
    public static WVR ALIGNRIGHT;
    public static WVR HREDRAW;
    public static WVR VREDRAW;
    public static WVR VALIDRECTS;
    public static WVR REDRAW;
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
}
public static class System.ComponentModel.DesignerProperties : object {
    public static DependencyProperty IsInDesignModeProperty;
    private static DesignerProperties();
    [DesignerSerializationVisibilityAttribute("0")]
public static bool GetIsInDesignMode(DependencyObject element);
    public static void SetIsInDesignMode(DependencyObject element, bool value);
}
internal static class System.LocalAppContext : object {
    private static LocalAppContext();
    public static bool IsSwitchEnabled(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
[XmlRootAttribute]
public class System.Windows.Annotations.Annotation : object {
    public Guid Id { get; }
    public XmlQualifiedName AnnotationType { get; }
    public DateTime CreationTime { get; }
    public DateTime LastModificationTime { get; }
    public Collection`1<string> Authors { get; }
    public Collection`1<AnnotationResource> Anchors { get; }
    public Collection`1<AnnotationResource> Cargos { get; }
    public Annotation(XmlQualifiedName annotationType);
    public Annotation(XmlQualifiedName annotationType, Guid id, DateTime creationTime, DateTime lastModificationTime);
    private static Annotation();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    [CompilerGeneratedAttribute]
public void add_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CargoChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CargoChanged(AnnotationResourceChangedEventHandler value);
    public Guid get_Id();
    public XmlQualifiedName get_AnnotationType();
    public DateTime get_CreationTime();
    public DateTime get_LastModificationTime();
    public Collection`1<string> get_Authors();
    public Collection`1<AnnotationResource> get_Anchors();
    public Collection`1<AnnotationResource> get_Cargos();
    internal static bool IsNamespaceDeclaration(XmlReader reader);
    internal static void CheckForNonNamespaceAttribute(XmlReader reader, string elementName);
}
public enum System.Windows.Annotations.AnnotationAction : Enum {
    public int value__;
    public static AnnotationAction Added;
    public static AnnotationAction Removed;
    public static AnnotationAction Modified;
}
public class System.Windows.Annotations.AnnotationAuthorChangedEventArgs : EventArgs {
    public Annotation Annotation { get; }
    public object Author { get; }
    public AnnotationAction Action { get; }
    public AnnotationAuthorChangedEventArgs(Annotation annotation, AnnotationAction action, object author);
    public Annotation get_Annotation();
    public object get_Author();
    public AnnotationAction get_Action();
}
public class System.Windows.Annotations.AnnotationAuthorChangedEventHandler : MulticastDelegate {
    public AnnotationAuthorChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AnnotationAuthorChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AnnotationAuthorChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Annotations.AnnotationComponentChooser : object {
    public IAnnotationComponent ChooseAnnotationComponent(IAttachedAnnotation attachedAnnotation);
}
public class System.Windows.Annotations.AnnotationDocumentPaginator : DocumentPaginator {
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, Stream annotationStore);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, Stream annotationStore, FlowDirection flowDirection);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, AnnotationStore annotationStore);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, AnnotationStore annotationStore, FlowDirection flowDirection);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync(object userState);
    public virtual void CancelAsync(object userState);
}
public static class System.Windows.Annotations.AnnotationHelper : object {
    public static Annotation CreateHighlightForSelection(AnnotationService service, string author, Brush highlightBrush);
    public static Annotation CreateTextStickyNoteForSelection(AnnotationService service, string author);
    public static Annotation CreateInkStickyNoteForSelection(AnnotationService service, string author);
    public static void ClearHighlightsForSelection(AnnotationService service);
    public static void DeleteTextStickyNotesForSelection(AnnotationService service);
    public static void DeleteInkStickyNotesForSelection(AnnotationService service);
    public static IAnchorInfo GetAnchorInfo(AnnotationService service, Annotation annotation);
    internal static void OnCreateHighlightCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnCreateTextStickyNoteCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnCreateInkStickyNoteCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnClearHighlightsCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnDeleteStickyNotesCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnDeleteAnnotationsCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnQueryCreateHighlightCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryCreateTextStickyNoteCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryCreateInkStickyNoteCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryClearHighlightsCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryDeleteStickyNotesCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryDeleteAnnotationsCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static DocumentPageView FindView(DocumentViewerBase viewer, int pageNb);
    internal static object GetFdrHost(FlowDocumentReader fdr);
}
[XmlRootAttribute]
public class System.Windows.Annotations.AnnotationResource : object {
    public Guid Id { get; }
    public string Name { get; public set; }
    public Collection`1<ContentLocatorBase> ContentLocators { get; }
    public Collection`1<XmlElement> Contents { get; }
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    internal static Serializer ListSerializer { get; }
    public AnnotationResource(string name);
    public AnnotationResource(Guid id);
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public Guid get_Id();
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<ContentLocatorBase> get_ContentLocators();
    public Collection`1<XmlElement> get_Contents();
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
    internal static Serializer get_ListSerializer();
}
public class System.Windows.Annotations.AnnotationResourceChangedEventArgs : EventArgs {
    public Annotation Annotation { get; }
    public AnnotationResource Resource { get; }
    public AnnotationAction Action { get; }
    public AnnotationResourceChangedEventArgs(Annotation annotation, AnnotationAction action, AnnotationResource resource);
    public Annotation get_Annotation();
    public AnnotationResource get_Resource();
    public AnnotationAction get_Action();
}
public class System.Windows.Annotations.AnnotationResourceChangedEventHandler : MulticastDelegate {
    public AnnotationResourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AnnotationResourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AnnotationResourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Annotations.AnnotationService : DispatcherObject {
    public static RoutedUICommand CreateHighlightCommand;
    public static RoutedUICommand CreateTextStickyNoteCommand;
    public static RoutedUICommand CreateInkStickyNoteCommand;
    public static RoutedUICommand ClearHighlightsCommand;
    public static RoutedUICommand DeleteStickyNotesCommand;
    public static RoutedUICommand DeleteAnnotationsCommand;
    internal static DependencyProperty ChooserProperty;
    internal static DependencyProperty SubTreeProcessorIdProperty;
    internal static DependencyProperty DataIdProperty;
    internal static DependencyProperty ServiceProperty;
    public bool IsEnabled { get; }
    public AnnotationStore Store { get; }
    internal LocatorManager LocatorManager { get; }
    internal DependencyObject Root { get; }
    private static AnnotationService();
    public AnnotationService(DocumentViewerBase viewer);
    public AnnotationService(FlowDocumentScrollViewer viewer);
    public AnnotationService(FlowDocumentReader viewer);
    internal AnnotationService(DependencyObject root);
    public void Enable(AnnotationStore annotationStore);
    public void Disable();
    public static AnnotationService GetService(DocumentViewerBase viewer);
    public static AnnotationService GetService(FlowDocumentReader reader);
    public static AnnotationService GetService(FlowDocumentScrollViewer viewer);
    internal void LoadAnnotations(DependencyObject element);
    internal void UnloadAnnotations(DependencyObject element);
    internal IList`1<IAttachedAnnotation> GetAttachedAnnotations();
    public bool get_IsEnabled();
    public AnnotationStore get_Store();
    internal static AnnotationService GetService(DependencyObject d);
    internal static AnnotationComponentChooser GetChooser(DependencyObject d);
    internal static void SetSubTreeProcessorId(DependencyObject d, string id);
    internal static string GetSubTreeProcessorId(DependencyObject d);
    internal static void SetDataId(DependencyObject d, string id);
    internal static string GetDataId(DependencyObject d);
    [CompilerGeneratedAttribute]
internal void add_AttachedAnnotationChanged(AttachedAnnotationChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AttachedAnnotationChanged(AttachedAnnotationChangedEventHandler value);
    internal LocatorManager get_LocatorManager();
    internal DependencyObject get_Root();
}
[XmlRootAttribute]
public class System.Windows.Annotations.ContentLocator : ContentLocatorBase {
    public Collection`1<ContentLocatorPart> Parts { get; }
    public bool StartsWith(ContentLocator locator);
    public virtual object Clone();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public Collection`1<ContentLocatorPart> get_Parts();
    internal IList`1<ContentLocatorBase> DotProduct(IList`1<ContentLocatorPart> additionalLocatorParts);
    internal virtual ContentLocatorBase Merge(ContentLocatorBase other);
    internal void Append(ContentLocator other);
}
public abstract class System.Windows.Annotations.ContentLocatorBase : object {
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    public abstract virtual object Clone();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    internal void FireLocatorChanged(string name);
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
    internal abstract virtual ContentLocatorBase Merge(ContentLocatorBase other);
}
[XmlRootAttribute]
public class System.Windows.Annotations.ContentLocatorGroup : ContentLocatorBase {
    public Collection`1<ContentLocator> Locators { get; }
    public virtual object Clone();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public Collection`1<ContentLocator> get_Locators();
    internal virtual ContentLocatorBase Merge(ContentLocatorBase other);
}
public class System.Windows.Annotations.ContentLocatorPart : object {
    public IDictionary`2<string, string> NameValuePairs { get; }
    public XmlQualifiedName PartType { get; }
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    public ContentLocatorPart(XmlQualifiedName partType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object Clone();
    public IDictionary`2<string, string> get_NameValuePairs();
    public XmlQualifiedName get_PartType();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    internal bool Matches(ContentLocatorPart part);
    internal string GetQueryFragment(XmlNamespaceManager namespaceManager);
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
}
public interface System.Windows.Annotations.IAnchorInfo {
    public Annotation Annotation { get; }
    public AnnotationResource Anchor { get; }
    public object ResolvedAnchor { get; }
    public abstract virtual Annotation get_Annotation();
    public abstract virtual AnnotationResource get_Anchor();
    public abstract virtual object get_ResolvedAnchor();
}
public abstract class System.Windows.Annotations.Storage.AnnotationStore : object {
    public bool AutoFlush { get; public set; }
    protected object SyncRoot { get; }
    protected bool IsDisposed { get; }
    protected virtual override void Finalize();
    public abstract virtual void AddAnnotation(Annotation newAnnotation);
    public abstract virtual Annotation DeleteAnnotation(Guid annotationId);
    public abstract virtual IList`1<Annotation> GetAnnotations(ContentLocator anchorLocator);
    public abstract virtual IList`1<Annotation> GetAnnotations();
    public abstract virtual Annotation GetAnnotation(Guid annotationId);
    public abstract virtual void Flush();
    public sealed virtual void Dispose();
    public abstract virtual bool get_AutoFlush();
    public abstract virtual void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public void add_StoreContentChanged(StoreContentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StoreContentChanged(StoreContentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CargoChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CargoChanged(AnnotationResourceChangedEventHandler value);
    protected virtual void Dispose(bool disposing);
    protected virtual void OnAuthorChanged(AnnotationAuthorChangedEventArgs args);
    protected virtual void OnAnchorChanged(AnnotationResourceChangedEventArgs args);
    protected virtual void OnCargoChanged(AnnotationResourceChangedEventArgs args);
    protected virtual void OnStoreContentChanged(StoreContentChangedEventArgs e);
    protected object get_SyncRoot();
    protected bool get_IsDisposed();
}
public enum System.Windows.Annotations.Storage.StoreContentAction : Enum {
    public int value__;
    public static StoreContentAction Added;
    public static StoreContentAction Deleted;
}
public class System.Windows.Annotations.Storage.StoreContentChangedEventArgs : EventArgs {
    public Annotation Annotation { get; }
    public StoreContentAction Action { get; }
    public StoreContentChangedEventArgs(StoreContentAction action, Annotation annotation);
    public Annotation get_Annotation();
    public StoreContentAction get_Action();
}
public class System.Windows.Annotations.Storage.StoreContentChangedEventHandler : MulticastDelegate {
    public StoreContentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StoreContentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StoreContentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Annotations.Storage.XmlStreamStore : AnnotationStore {
    public bool AutoFlush { get; public set; }
    public IList`1<Uri> IgnoredNamespaces { get; }
    public static IList`1<Uri> WellKnownNamespaces { get; }
    private static XmlStreamStore();
    public XmlStreamStore(Stream stream);
    public XmlStreamStore(Stream stream, IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
    public virtual void AddAnnotation(Annotation newAnnotation);
    public virtual Annotation DeleteAnnotation(Guid annotationId);
    public virtual IList`1<Annotation> GetAnnotations(ContentLocator anchorLocator);
    public virtual IList`1<Annotation> GetAnnotations();
    public virtual Annotation GetAnnotation(Guid annotationId);
    public virtual void Flush();
    public static IList`1<Uri> GetWellKnownCompatibleNamespaces(Uri name);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public IList`1<Uri> get_IgnoredNamespaces();
    public static IList`1<Uri> get_WellKnownNamespaces();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnStoreContentChanged(StoreContentChangedEventArgs e);
}
public class System.Windows.Annotations.TextAnchor : object {
    public ContentPosition BoundingStart { get; }
    public ContentPosition BoundingEnd { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal bool IsEmpty { get; }
    internal string Text { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal TextAnchor(TextAnchor anchor);
    internal bool Contains(ITextPointer textPointer);
    internal void AddTextSegment(ITextPointer start, ITextPointer end);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal bool IsOverlapping(ICollection`1<TextSegment> textSegments);
    internal static TextAnchor ExclusiveUnion(TextAnchor anchor, TextAnchor otherAnchor);
    internal static TextAnchor TrimToRelativeComplement(TextAnchor anchor, ICollection`1<TextSegment> textSegments);
    internal static TextAnchor TrimToIntersectionWith(TextAnchor anchor, ICollection`1<TextSegment> textSegments);
    public ContentPosition get_BoundingStart();
    public ContentPosition get_BoundingEnd();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal bool get_IsEmpty();
    internal string get_Text();
    internal ReadOnlyCollection`1<TextSegment> get_TextSegments();
}
public class System.Windows.Application : DispatcherObject {
    public static Application Current { get; }
    public WindowCollection Windows { get; }
    public Window MainWindow { get; public set; }
    public ShutdownMode ShutdownMode { get; public set; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    internal bool HasImplicitStylesInResources { get; internal set; }
    public Uri StartupUri { get; public set; }
    public IDictionary Properties { get; }
    public static Assembly ResourceAssembly { get; public set; }
    internal WindowCollection WindowsInternal { get; private set; }
    internal WindowCollection NonAppWindowsInternal { get; private set; }
    internal MimeType MimeType { get; internal set; }
    private IServiceProvider ServiceProvider { get; internal set; }
    internal IBrowserCallbackServices BrowserCallbackServices { get; }
    internal NavigationService NavService { get; internal set; }
    internal static bool IsShuttingDown { get; internal set; }
    internal static bool IsApplicationObjectShuttingDown { get; }
    internal IntPtr ParkingHwnd { get; }
    internal Uri ApplicationMarkupBaseUri { get; internal set; }
    private static Application();
    public int Run();
    [SecurityCriticalAttribute]
public int Run(Window window);
    internal static bool InBrowserHostedApp();
    internal object GetService(Type serviceType);
    public void Shutdown();
    [SecurityCriticalAttribute]
public void Shutdown(int exitCode);
    [SecurityCriticalAttribute]
internal void CriticalShutdown(int exitCode);
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    internal object FindResourceInternal(object resourceKey);
    internal object FindResourceInternal(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    [SecurityCriticalAttribute]
public static void LoadComponent(object component, Uri resourceLocator);
    public static object LoadComponent(Uri resourceLocator);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static object LoadComponent(Uri resourceLocator, bool bSkipJournaledProperties);
    internal static object LoadBamlStreamWithSyncInfo(Stream stream, ParserContext pc);
    [SecurityCriticalAttribute]
public static StreamResourceInfo GetResourceStream(Uri uriResource);
    [SecurityCriticalAttribute]
public static StreamResourceInfo GetContentStream(Uri uriContent);
    [SecurityCriticalAttribute]
public static StreamResourceInfo GetRemoteStream(Uri uriRemote);
    public static string GetCookie(Uri uri);
    public static void SetCookie(Uri uri, string value);
    public static Application get_Current();
    public WindowCollection get_Windows();
    public Window get_MainWindow();
    public void set_MainWindow(Window value);
    public ShutdownMode get_ShutdownMode();
    public void set_ShutdownMode(ShutdownMode value);
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    internal bool get_HasImplicitStylesInResources();
    internal void set_HasImplicitStylesInResources(bool value);
    public Uri get_StartupUri();
    public void set_StartupUri(Uri value);
    public IDictionary get_Properties();
    public static Assembly get_ResourceAssembly();
    public static void set_ResourceAssembly(Assembly value);
    public void add_Startup(StartupEventHandler value);
    public void remove_Startup(StartupEventHandler value);
    public void add_Exit(ExitEventHandler value);
    public void remove_Exit(ExitEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler value);
    public void add_SessionEnding(SessionEndingCancelEventHandler value);
    public void remove_SessionEnding(SessionEndingCancelEventHandler value);
    public void add_DispatcherUnhandledException(DispatcherUnhandledExceptionEventHandler value);
    public void remove_DispatcherUnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FragmentNavigation(FragmentNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    protected virtual void OnStartup(StartupEventArgs e);
    protected virtual void OnExit(ExitEventArgs e);
    protected virtual void OnActivated(EventArgs e);
    protected virtual void OnDeactivated(EventArgs e);
    protected virtual void OnSessionEnding(SessionEndingCancelEventArgs e);
    protected virtual void OnNavigating(NavigatingCancelEventArgs e);
    protected virtual void OnNavigated(NavigationEventArgs e);
    protected virtual void OnNavigationProgress(NavigationProgressEventArgs e);
    protected virtual void OnNavigationFailed(NavigationFailedEventArgs e);
    protected virtual void OnLoadCompleted(NavigationEventArgs e);
    protected virtual void OnNavigationStopped(NavigationEventArgs e);
    protected virtual void OnFragmentNavigation(FragmentNavigationEventArgs e);
    internal virtual void PerformNavigationStateChangeTasks(bool isNavigationInitiator, bool playNavigatingSound, NavigationStateChange state);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void UpdateBrowserCommands();
    internal void DoStartup();
    [SecurityCriticalAttribute]
internal virtual void DoShutdown();
    [SecurityCriticalAttribute]
internal int RunInternal(Window window);
    internal void InvalidateResourceReferences(ResourcesChangeInfo info);
    [SecurityCriticalAttribute]
internal NavigationWindow GetAppWindow();
    internal void FireNavigating(NavigatingCancelEventArgs e, bool isInitialNavigation);
    internal void FireNavigated(NavigationEventArgs e);
    internal void FireNavigationProgress(NavigationProgressEventArgs e);
    internal void FireNavigationFailed(NavigationFailedEventArgs e);
    internal void FireLoadCompleted(NavigationEventArgs e);
    internal void FireNavigationStopped(NavigationEventArgs e);
    internal void FireFragmentNavigation(FragmentNavigationEventArgs e);
    internal WindowCollection get_WindowsInternal();
    private void set_WindowsInternal(WindowCollection value);
    internal WindowCollection get_NonAppWindowsInternal();
    private void set_NonAppWindowsInternal(WindowCollection value);
    internal MimeType get_MimeType();
    [SecurityCriticalAttribute]
internal void set_MimeType(MimeType value);
    private IServiceProvider get_ServiceProvider();
    internal void set_ServiceProvider(IServiceProvider value);
    internal IBrowserCallbackServices get_BrowserCallbackServices();
    internal NavigationService get_NavService();
    internal void set_NavService(NavigationService value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool get_IsShuttingDown();
    internal static void set_IsShuttingDown(bool value);
    internal static bool get_IsApplicationObjectShuttingDown();
    [SecurityCriticalAttribute]
internal IntPtr get_ParkingHwnd();
    internal Uri get_ApplicationMarkupBaseUri();
    internal void set_ApplicationMarkupBaseUri(Uri value);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForChildrenAttribute : AttachedPropertyBrowsableAttribute {
    public bool IncludeDescendants { get; public set; }
    public bool get_IncludeDescendants();
    public void set_IncludeDescendants(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
public class System.Windows.Automation.Peers.ButtonAutomationPeer : ButtonBaseAutomationPeer {
    public ButtonAutomationPeer(Button owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
}
public abstract class System.Windows.Automation.Peers.ButtonBaseAutomationPeer : FrameworkElementAutomationPeer {
    protected ButtonBaseAutomationPeer(ButtonBase owner);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.CalendarAutomationPeer : FrameworkElementAutomationPeer {
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private int System.Windows.Automation.Provider.IMultipleViewProvider.CurrentView { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    public CalendarAutomationPeer(Calendar owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual void SetFocusCore();
    internal void AddProxyToWeakRefStorage(WeakReference wr, DateTimeAutomationPeer dateTimePeer);
    internal void RaiseSelectionEvents(SelectionChangedEventArgs e);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override int System.Windows.Automation.Provider.IMultipleViewProvider.get_CurrentView();
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IMultipleViewProvider.GetSupportedViews();
    private sealed virtual override string System.Windows.Automation.Provider.IMultipleViewProvider.GetViewName(int viewId);
    private sealed virtual override void System.Windows.Automation.Provider.IMultipleViewProvider.SetCurrentView(int viewId);
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfterProvider, int propertyId, object value);
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
}
public class System.Windows.Automation.Peers.CalendarButtonAutomationPeer : FrameworkElementAutomationPeer {
    public CalendarButtonAutomationPeer(Button owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetLocalizedControlTypeCore();
}
public class System.Windows.Automation.Peers.CheckBoxAutomationPeer : ToggleButtonAutomationPeer {
    public CheckBoxAutomationPeer(CheckBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ComboBoxAutomationPeer : SelectorAutomationPeer {
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    public ComboBoxAutomationPeer(ComboBox owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface pattern);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual void SetFocusCore();
    internal void ScrollItemIntoView(object item);
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string val);
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
}
public abstract class System.Windows.Automation.Peers.ContentTextAutomationPeer : FrameworkContentElementAutomationPeer {
    protected ContentTextAutomationPeer(FrameworkContentElement owner);
    internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider);
    internal abstract virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.ContextMenuAutomationPeer : FrameworkElementAutomationPeer {
    public ContextMenuAutomationPeer(ContextMenu owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DataGridAutomationPeer : ItemsControlAutomationPeer {
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    public DataGridAutomationPeer(DataGrid owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
    internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e);
    internal void RaiseAutomationRowInvokeEvents(DataGridRow row);
    internal void RaiseAutomationCellInvokeEvents(DataGridColumn column, DataGridRow row);
    internal void RaiseAutomationSelectionEvents(SelectionChangedEventArgs e);
}
public class System.Windows.Automation.Peers.DataGridCellAutomationPeer : FrameworkElementAutomationPeer {
    public DataGridCellAutomationPeer(DataGridCell owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.DataGridCellItemAutomationPeer : AutomationPeer {
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    internal DataGridCellAutomationPeer OwningCellPeer { get; }
    private IRawElementProviderSimple ContainingGrid { get; }
    internal DataGridColumn Column { get; }
    internal object Item { get; }
    internal bool AncestorsInvalid { get; internal set; }
    public DataGridCellItemAutomationPeer(object item, DataGridColumn dataGridColumn);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal DataGridCellAutomationPeer get_OwningCellPeer();
    private IRawElementProviderSimple get_ContainingGrid();
    internal DataGridColumn get_Column();
    internal object get_Item();
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
}
public class System.Windows.Automation.Peers.DataGridColumnHeaderAutomationPeer : ButtonBaseAutomationPeer {
    public DataGridColumnHeaderAutomationPeer(DataGridColumnHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DataGridColumnHeaderItemAutomationPeer : ItemAutomationPeer {
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    internal bool AncestorsInvalid { get; internal set; }
    internal DataGridColumnHeader OwningHeader { get; }
    internal DataGrid OwningDataGrid { get; }
    internal DataGridColumn Column { get; }
    internal DataGridColumnHeaderAutomationPeer OwningColumnHeaderPeer { get; }
    public DataGridColumnHeaderItemAutomationPeer(object item, DataGridColumn column, DataGridColumnHeadersPresenterAutomationPeer peer);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsContentElementCore();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    internal DataGridColumnHeader get_OwningHeader();
    internal DataGrid get_OwningDataGrid();
    internal DataGridColumn get_Column();
    internal DataGridColumnHeaderAutomationPeer get_OwningColumnHeaderPeer();
}
public class System.Windows.Automation.Peers.DataGridColumnHeadersPresenterAutomationPeer : ItemsControlAutomationPeer {
    public DataGridColumnHeadersPresenterAutomationPeer(DataGridColumnHeadersPresenter owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    protected virtual bool IsContentElementCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object column);
}
public class System.Windows.Automation.Peers.DataGridDetailsPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public DataGridDetailsPresenterAutomationPeer(DataGridDetailsPresenter owner);
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.DataGridItemAutomationPeer : ItemAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    internal AutomationPeer RowHeaderAutomationPeer { get; }
    public DataGridItemAutomationPeer(object item, DataGridAutomationPeer dataGridPeer);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    internal List`1<AutomationPeer> GetCellItemPeers();
    internal DataGridCellItemAutomationPeer GetOrCreateCellItemPeer(DataGridColumn column);
    internal void AddProxyToWeakRefStorage(WeakReference wr, DataGridCellItemAutomationPeer cellItemPeer);
    internal AutomationPeer get_RowHeaderAutomationPeer();
}
public class System.Windows.Automation.Peers.DataGridRowAutomationPeer : FrameworkElementAutomationPeer {
    internal AutomationPeer RowHeaderAutomationPeer { get; }
    public DataGridRowAutomationPeer(DataGridRow owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal AutomationPeer get_RowHeaderAutomationPeer();
}
public class System.Windows.Automation.Peers.DataGridRowHeaderAutomationPeer : ButtonBaseAutomationPeer {
    public DataGridRowHeaderAutomationPeer(DataGridRowHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DatePickerAutomationPeer : FrameworkElementAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public DatePickerAutomationPeer(DatePicker owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual void SetFocusCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetLocalizedControlTypeCore();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
}
public class System.Windows.Automation.Peers.DateTimeAutomationPeer : AutomationPeer {
    internal bool AncestorsInvalid { get; internal set; }
    internal DateTime Date { get; private set; }
    internal CalendarMode ButtonMode { get; private set; }
    internal bool IsDayButton { get; }
    internal Button OwningButton { get; }
    internal FrameworkElementAutomationPeer WrapperPeer { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    internal DateTimeAutomationPeer(DateTime date, Calendar owningCalendar, CalendarMode buttonMode);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    [CompilerGeneratedAttribute]
internal DateTime get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
internal CalendarMode get_ButtonMode();
    [CompilerGeneratedAttribute]
private void set_ButtonMode(CalendarMode value);
    internal bool get_IsDayButton();
    internal Button get_OwningButton();
    internal FrameworkElementAutomationPeer get_WrapperPeer();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
}
internal class System.Windows.Automation.Peers.DateTimeCalendarModePair : ValueType {
    private CalendarMode ButtonMode;
    private DateTime Date;
    internal DateTimeCalendarModePair(DateTime date, CalendarMode mode);
}
public class System.Windows.Automation.Peers.DocumentAutomationPeer : ContentTextAutomationPeer {
    public DocumentAutomationPeer(FrameworkContentElement owner);
    internal void OnDisconnected();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Point GetClickablePointCore();
    protected virtual bool IsOffscreenCore();
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.DocumentPageViewAutomationPeer : FrameworkElementAutomationPeer {
    public DocumentPageViewAutomationPeer(DocumentPageView owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetAutomationIdCore();
}
public class System.Windows.Automation.Peers.DocumentViewerAutomationPeer : DocumentViewerBaseAutomationPeer {
    public DocumentViewerAutomationPeer(DocumentViewer owner);
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
}
public class System.Windows.Automation.Peers.DocumentViewerBaseAutomationPeer : FrameworkElementAutomationPeer {
    public DocumentViewerBaseAutomationPeer(DocumentViewerBase owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.ExpanderAutomationPeer : FrameworkElementAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    public ExpanderAutomationPeer(Expander owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual bool HasKeyboardFocusCore();
    public virtual object GetPattern(PatternInterface pattern);
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
}
public class System.Windows.Automation.Peers.FixedPageAutomationPeer : FrameworkElementAutomationPeer {
    public FixedPageAutomationPeer(FixedPage owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.FlowDocumentPageViewerAutomationPeer : DocumentViewerBaseAutomationPeer {
    public FlowDocumentPageViewerAutomationPeer(FlowDocumentPageViewer owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.FlowDocumentReaderAutomationPeer : FrameworkElementAutomationPeer {
    private int System.Windows.Automation.Provider.IMultipleViewProvider.CurrentView { get; }
    public FlowDocumentReaderAutomationPeer(FlowDocumentReader owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    internal void RaiseCurrentViewChangedEvent(FlowDocumentReaderViewingMode newMode, FlowDocumentReaderViewingMode oldMode);
    internal void RaiseSupportedViewsChangedEvent(DependencyPropertyChangedEventArgs e);
    private sealed virtual override string System.Windows.Automation.Provider.IMultipleViewProvider.GetViewName(int viewId);
    private sealed virtual override void System.Windows.Automation.Provider.IMultipleViewProvider.SetCurrentView(int viewId);
    private sealed virtual override int System.Windows.Automation.Provider.IMultipleViewProvider.get_CurrentView();
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IMultipleViewProvider.GetSupportedViews();
}
public class System.Windows.Automation.Peers.FlowDocumentScrollViewerAutomationPeer : FrameworkElementAutomationPeer {
    public FlowDocumentScrollViewerAutomationPeer(FlowDocumentScrollViewer owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.FrameAutomationPeer : FrameworkElementAutomationPeer {
    public FrameAutomationPeer(Frame owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.FrameworkContentElementAutomationPeer : ContentElementAutomationPeer {
    public FrameworkContentElementAutomationPeer(FrameworkContentElement owner);
    protected virtual string GetAutomationIdCore();
    protected virtual string GetHelpTextCore();
    protected virtual AutomationPeer GetLabeledByCore();
}
public class System.Windows.Automation.Peers.FrameworkElementAutomationPeer : UIElementAutomationPeer {
    public FrameworkElementAutomationPeer(FrameworkElement owner);
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    internal virtual bool IgnoreUpdatePeer();
}
public class System.Windows.Automation.Peers.GridSplitterAutomationPeer : ThumbAutomationPeer {
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    public GridSplitterAutomationPeer(GridSplitter owner);
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
}
public class System.Windows.Automation.Peers.GridViewAutomationPeer : object {
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    public GridViewAutomationPeer(GridView owner, ListView listview);
    private sealed virtual override AutomationControlType System.Windows.Automation.Peers.IViewAutomationPeer.GetAutomationControlType();
    private sealed virtual override object System.Windows.Automation.Peers.IViewAutomationPeer.GetPattern(PatternInterface patternInterface);
    private sealed virtual override List`1<AutomationPeer> System.Windows.Automation.Peers.IViewAutomationPeer.GetChildren(List`1<AutomationPeer> children);
    private sealed virtual override ItemAutomationPeer System.Windows.Automation.Peers.IViewAutomationPeer.CreateItemAutomationPeer(object item);
    private sealed virtual override void System.Windows.Automation.Peers.IViewAutomationPeer.ItemsChanged(NotifyCollectionChangedEventArgs e);
    private sealed virtual override void System.Windows.Automation.Peers.IViewAutomationPeer.ViewDetached();
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    internal static Visual FindVisualByType(Visual parent, Type type);
}
public class System.Windows.Automation.Peers.GridViewCellAutomationPeer : FrameworkElementAutomationPeer {
    internal int Column { get; internal set; }
    internal int Row { get; internal set; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    internal GridViewCellAutomationPeer(ContentPresenter owner, ListViewAutomationPeer parent);
    internal GridViewCellAutomationPeer(TextBlock owner, ListViewAutomationPeer parent);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsControlElementCore();
    internal int get_Column();
    internal void set_Column(int value);
    internal int get_Row();
    internal void set_Row(int value);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
}
public class System.Windows.Automation.Peers.GridViewColumnHeaderAutomationPeer : FrameworkElementAutomationPeer {
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    public GridViewColumnHeaderAutomationPeer(GridViewColumnHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
}
public class System.Windows.Automation.Peers.GridViewHeaderRowPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public GridViewHeaderRowPresenterAutomationPeer(GridViewHeaderRowPresenter owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
}
public class System.Windows.Automation.Peers.GridViewItemAutomationPeer : ListBoxItemAutomationPeer {
    public GridViewItemAutomationPeer(object owner, ListViewAutomationPeer listviewAP);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
}
public class System.Windows.Automation.Peers.GroupBoxAutomationPeer : FrameworkElementAutomationPeer {
    public GroupBoxAutomationPeer(GroupBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.GroupItemAutomationPeer : FrameworkElementAutomationPeer {
    public GroupItemAutomationPeer(GroupItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal void InvalidateGroupItemPeersContainingRecentlyRealizedPeers(List`1<ItemAutomationPeer> recentlyRealizedPeers);
}
internal class System.Windows.Automation.Peers.HwndHostAutomationPeer : FrameworkElementAutomationPeer {
    public HwndHostAutomationPeer(HwndHost owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual InteropAutomationProvider GetInteropChild();
}
public class System.Windows.Automation.Peers.HyperlinkAutomationPeer : TextElementAutomationPeer {
    public HyperlinkAutomationPeer(Hyperlink owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
}
public class System.Windows.Automation.Peers.ImageAutomationPeer : FrameworkElementAutomationPeer {
    public ImageAutomationPeer(Image owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.InkCanvasAutomationPeer : FrameworkElementAutomationPeer {
    public InkCanvasAutomationPeer(InkCanvas owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.InkPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public InkPresenterAutomationPeer(InkPresenter owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public abstract class System.Windows.Automation.Peers.ItemAutomationPeer : AutomationPeer {
    internal bool AncestorsInvalid { get; internal set; }
    public object Item { get; }
    public ItemsControlAutomationPeer ItemsControlAutomationPeer { get; internal set; }
    protected ItemAutomationPeer(object item, ItemsControlAutomationPeer itemsControlAutomationPeer);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal UIElement GetWrapper();
    internal virtual AutomationPeer GetWrapperPeer();
    internal void ThrowElementNotAvailableException();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual string GetItemTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual ItemsControlAutomationPeer GetItemsControlAutomationPeer();
    public object get_Item();
    public ItemsControlAutomationPeer get_ItemsControlAutomationPeer();
    internal void set_ItemsControlAutomationPeer(ItemsControlAutomationPeer value);
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual void RealizeCore();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Automation.Peers.ItemPeersStorage`1 : object {
    public T Item { get; public set; }
    public int Count { get; }
    public void Clear();
    public T get_Item(object item);
    public void set_Item(object item, T value);
    public void Remove(object item);
    public void PurgeWeakRefCollection();
    public int get_Count();
}
public abstract class System.Windows.Automation.Peers.ItemsControlAutomationPeer : FrameworkElementAutomationPeer {
    protected bool IsVirtualized { get; }
    internal ItemPeersStorage`1<ItemAutomationPeer> ItemPeers { get; internal set; }
    internal ItemPeersStorage`1<WeakReference> WeakRefElementProxyStorage { get; internal set; }
    internal List`1<ItemAutomationPeer> RecentlyRealizedPeers { get; }
    protected ItemsControlAutomationPeer(ItemsControl owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal void AddProxyToWeakRefStorage(WeakReference wr, ItemAutomationPeer itemPeer);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal static bool IsPropertySupportedByControlForFindItemInternal(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    internal static object GetSupportedPropertyValueInternal(AutomationPeer itemPeer, int propertyId);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected internal virtual ItemAutomationPeer FindOrCreateItemAutomationPeer(object item);
    internal ItemAutomationPeer CreateItemAutomationPeerInternal(object item);
    protected abstract virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal RecyclableWrapper GetRecyclableWrapperPeer(object item);
    internal virtual void UpdateChildren();
    internal ItemAutomationPeer GetPeerFromWeakRefStorage(object item);
    internal AutomationPeer GetExistingPeerByItem(object item, bool checkInWeakRefStorage);
    protected virtual bool get_IsVirtualized();
    internal ItemPeersStorage`1<ItemAutomationPeer> get_ItemPeers();
    internal void set_ItemPeers(ItemPeersStorage`1<ItemAutomationPeer> value);
    internal ItemPeersStorage`1<WeakReference> get_WeakRefElementProxyStorage();
    internal void set_WeakRefElementProxyStorage(ItemPeersStorage`1<WeakReference> value);
    internal List`1<ItemAutomationPeer> get_RecentlyRealizedPeers();
}
public interface System.Windows.Automation.Peers.IViewAutomationPeer {
    public abstract virtual AutomationControlType GetAutomationControlType();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public abstract virtual List`1<AutomationPeer> GetChildren(List`1<AutomationPeer> children);
    public abstract virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    public abstract virtual void ItemsChanged(NotifyCollectionChangedEventArgs e);
    public abstract virtual void ViewDetached();
}
public class System.Windows.Automation.Peers.LabelAutomationPeer : FrameworkElementAutomationPeer {
    public LabelAutomationPeer(Label owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.ListBoxAutomationPeer : SelectorAutomationPeer {
    public ListBoxAutomationPeer(ListBox owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.ListBoxItemAutomationPeer : SelectorItemAutomationPeer {
    public ListBoxItemAutomationPeer(object owner, SelectorAutomationPeer selectorAutomationPeer);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual void RealizeCore();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
}
public class System.Windows.Automation.Peers.ListBoxItemWrapperAutomationPeer : FrameworkElementAutomationPeer {
    public ListBoxItemWrapperAutomationPeer(ListBoxItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ListViewAutomationPeer : ListBoxAutomationPeer {
    protected internal IViewAutomationPeer ViewAutomationPeer { get; protected internal set; }
    public ListViewAutomationPeer(ListView owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected internal IViewAutomationPeer get_ViewAutomationPeer();
    protected internal void set_ViewAutomationPeer(IViewAutomationPeer value);
}
public class System.Windows.Automation.Peers.MediaElementAutomationPeer : FrameworkElementAutomationPeer {
    public MediaElementAutomationPeer(MediaElement owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.MenuAutomationPeer : FrameworkElementAutomationPeer {
    public MenuAutomationPeer(Menu owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.MenuItemAutomationPeer : FrameworkElementAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private ToggleState System.Windows.Automation.Provider.IToggleProvider.ToggleState { get; }
    public MenuItemAutomationPeer(MenuItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual string GetAccessKeyCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IToggleProvider.Toggle();
    private sealed virtual override ToggleState System.Windows.Automation.Provider.IToggleProvider.get_ToggleState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.NavigationWindowAutomationPeer : WindowAutomationPeer {
    public NavigationWindowAutomationPeer(NavigationWindow owner);
    protected virtual string GetClassNameCore();
    internal static void RaiseAsyncContentLoadedEvent(AutomationPeer peer, long bytesRead, long maxBytes);
}
public class System.Windows.Automation.Peers.PasswordBoxAutomationPeer : TextAutomationPeer {
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public PasswordBoxAutomationPeer(PasswordBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsPasswordCore();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    internal void RaiseIsReadOnlyPropertyChangedEvent(bool oldValue, bool newValue);
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
internal class System.Windows.Automation.Peers.PopupRootAutomationPeer : FrameworkElementAutomationPeer {
    public PopupRootAutomationPeer(PopupRoot owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ProgressBarAutomationPeer : RangeBaseAutomationPeer {
    private bool System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.LargeChange { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.SmallChange { get; }
    public ProgressBarAutomationPeer(ProgressBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IRangeValueProvider.SetValue(double val);
    private sealed virtual override bool System.Windows.Automation.Provider.IRangeValueProvider.get_IsReadOnly();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_LargeChange();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_SmallChange();
}
public class System.Windows.Automation.Peers.RadioButtonAutomationPeer : ToggleButtonAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    public RadioButtonAutomationPeer(RadioButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    internal virtual void RaiseToggleStatePropertyChangedEvent(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
}
public class System.Windows.Automation.Peers.RangeBaseAutomationPeer : FrameworkElementAutomationPeer {
    private double System.Windows.Automation.Provider.IRangeValueProvider.Value { get; }
    private bool System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.Maximum { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.Minimum { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.LargeChange { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.SmallChange { get; }
    public RangeBaseAutomationPeer(RangeBase owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal void RaiseMinimumPropertyChangedEvent(double oldValue, double newValue);
    internal void RaiseMaximumPropertyChangedEvent(double oldValue, double newValue);
    internal void RaiseValuePropertyChangedEvent(double oldValue, double newValue);
    internal virtual void SetValueCore(double val);
    private sealed virtual override void System.Windows.Automation.Provider.IRangeValueProvider.SetValue(double val);
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Value();
    private sealed virtual override bool System.Windows.Automation.Provider.IRangeValueProvider.get_IsReadOnly();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Maximum();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Minimum();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_LargeChange();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_SmallChange();
}
internal class System.Windows.Automation.Peers.RecyclableWrapper : object {
    public AutomationPeer Peer { get; }
    public RecyclableWrapper(ItemsControl itemsControl, object item);
    public void LinkItem(object item);
    private sealed virtual override void System.IDisposable.Dispose();
    public AutomationPeer get_Peer();
}
public class System.Windows.Automation.Peers.RepeatButtonAutomationPeer : ButtonBaseAutomationPeer {
    public RepeatButtonAutomationPeer(RepeatButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
}
public class System.Windows.Automation.Peers.RichTextBoxAutomationPeer : TextAutomationPeer {
    public RichTextBoxAutomationPeer(RichTextBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
internal class System.Windows.Automation.Peers.RootBrowserWindowAutomationPeer : WindowAutomationPeer {
    public RootBrowserWindowAutomationPeer(RootBrowserWindow owner);
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.ScrollBarAutomationPeer : RangeBaseAutomationPeer {
    public ScrollBarAutomationPeer(ScrollBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual Point GetClickablePointCore();
    protected virtual AutomationOrientation GetOrientationCore();
    internal virtual void SetValueCore(double val);
}
public class System.Windows.Automation.Peers.ScrollViewerAutomationPeer : FrameworkElementAutomationPeer {
    private double System.Windows.Automation.Provider.IScrollProvider.HorizontalScrollPercent { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.VerticalScrollPercent { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.HorizontalViewSize { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.VerticalViewSize { get; }
    private bool System.Windows.Automation.Provider.IScrollProvider.HorizontallyScrollable { get; }
    private bool System.Windows.Automation.Provider.IScrollProvider.VerticallyScrollable { get; }
    private bool HorizontallyScrollable { get; }
    private bool VerticallyScrollable { get; }
    public ScrollViewerAutomationPeer(ScrollViewer owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsControlElementCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IScrollProvider.Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    private sealed virtual override void System.Windows.Automation.Provider.IScrollProvider.SetScrollPercent(double horizontalPercent, double verticalPercent);
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_HorizontalScrollPercent();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_VerticalScrollPercent();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_HorizontalViewSize();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_VerticalViewSize();
    private sealed virtual override bool System.Windows.Automation.Provider.IScrollProvider.get_HorizontallyScrollable();
    private sealed virtual override bool System.Windows.Automation.Provider.IScrollProvider.get_VerticallyScrollable();
    private bool get_HorizontallyScrollable();
    private bool get_VerticallyScrollable();
    internal void RaiseAutomationEvents(double extentX, double extentY, double viewportX, double viewportY, double offsetX, double offsetY);
}
public abstract class System.Windows.Automation.Peers.SelectorAutomationPeer : ItemsControlAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    protected SelectorAutomationPeer(Selector owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal static bool IsPropertySupportedByControlForFindItemInternal(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    internal static object GetSupportedPropertyValueInternal(AutomationPeer itemPeer, int propertyId);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    internal void RaiseSelectionEvents(SelectionChangedEventArgs e);
}
public abstract class System.Windows.Automation.Peers.SelectorItemAutomationPeer : ItemAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    protected SelectorItemAutomationPeer(object owner, SelectorAutomationPeer selectorAutomationPeer);
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
}
public class System.Windows.Automation.Peers.SeparatorAutomationPeer : FrameworkElementAutomationPeer {
    public SeparatorAutomationPeer(Separator owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.SliderAutomationPeer : RangeBaseAutomationPeer {
    public SliderAutomationPeer(Slider owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual Point GetClickablePointCore();
}
public class System.Windows.Automation.Peers.StatusBarAutomationPeer : FrameworkElementAutomationPeer {
    public StatusBarAutomationPeer(StatusBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
}
public class System.Windows.Automation.Peers.StatusBarItemAutomationPeer : FrameworkElementAutomationPeer {
    public StatusBarItemAutomationPeer(StatusBarItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.TabControlAutomationPeer : SelectorAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    public TabControlAutomationPeer(TabControl owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
}
public class System.Windows.Automation.Peers.TabItemAutomationPeer : SelectorItemAutomationPeer {
    public TabItemAutomationPeer(object owner, TabControlAutomationPeer tabControlAutomationPeer);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    internal virtual void RealizeCore();
}
public class System.Windows.Automation.Peers.TabItemWrapperAutomationPeer : FrameworkElementAutomationPeer {
    public TabItemWrapperAutomationPeer(TabItem owner);
}
public class System.Windows.Automation.Peers.TableAutomationPeer : TextElementAutomationPeer {
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    public TableAutomationPeer(Table owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    internal void OnStructureInvalidated();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
}
public class System.Windows.Automation.Peers.TableCellAutomationPeer : TextElementAutomationPeer {
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    public TableCellAutomationPeer(TableCell owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    internal void OnColumnSpanChanged(int oldValue, int newValue);
    internal void OnRowSpanChanged(int oldValue, int newValue);
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
}
public abstract class System.Windows.Automation.Peers.TextAutomationPeer : FrameworkElementAutomationPeer {
    protected TextAutomationPeer(FrameworkElement owner);
    protected virtual string GetNameCore();
    internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider);
    internal abstract virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.TextBlockAutomationPeer : FrameworkElementAutomationPeer {
    public TextBlockAutomationPeer(TextBlock owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
}
public class System.Windows.Automation.Peers.TextBoxAutomationPeer : TextAutomationPeer {
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public TextBoxAutomationPeer(TextBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    internal void RaiseIsReadOnlyPropertyChangedEvent(bool oldValue, bool newValue);
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.TextElementAutomationPeer : ContentTextAutomationPeer {
    public TextElementAutomationPeer(TextElement owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Point GetClickablePointCore();
    protected virtual bool IsOffscreenCore();
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.ThumbAutomationPeer : FrameworkElementAutomationPeer {
    public ThumbAutomationPeer(Thumb owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.ToggleButtonAutomationPeer : ButtonBaseAutomationPeer {
    private ToggleState System.Windows.Automation.Provider.IToggleProvider.ToggleState { get; }
    public ToggleButtonAutomationPeer(ToggleButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IToggleProvider.Toggle();
    private sealed virtual override ToggleState System.Windows.Automation.Provider.IToggleProvider.get_ToggleState();
    internal virtual void RaiseToggleStatePropertyChangedEvent(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
}
public class System.Windows.Automation.Peers.ToolBarAutomationPeer : FrameworkElementAutomationPeer {
    public ToolBarAutomationPeer(ToolBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ToolTipAutomationPeer : FrameworkElementAutomationPeer {
    public ToolTipAutomationPeer(ToolTip owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.TreeViewAutomationPeer : ItemsControlAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    public TreeViewAutomationPeer(TreeView owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
}
public class System.Windows.Automation.Peers.TreeViewDataItemAutomationPeer : ItemAutomationPeer {
    public TreeViewDataItemAutomationPeer ParentDataItemAutomationPeer { get; }
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    internal ItemPeersStorage`1<WeakReference> WeakRefElementProxyStorageCache { get; internal set; }
    public TreeViewDataItemAutomationPeer(object item, ItemsControlAutomationPeer itemsControlAutomationPeer, TreeViewDataItemAutomationPeer parentDataItemAutomationPeer);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual AutomationPeer GetWrapperPeer();
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public TreeViewDataItemAutomationPeer get_ParentDataItemAutomationPeer();
    internal virtual ItemsControlAutomationPeer GetItemsControlAutomationPeer();
    internal virtual void RealizeCore();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
    internal ItemPeersStorage`1<WeakReference> get_WeakRefElementProxyStorageCache();
    internal void set_WeakRefElementProxyStorageCache(ItemPeersStorage`1<WeakReference> value);
}
public class System.Windows.Automation.Peers.TreeViewItemAutomationPeer : ItemsControlAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    public TreeViewItemAutomationPeer(TreeViewItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected internal virtual ItemAutomationPeer FindOrCreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual void UpdateChildren();
    internal void AddDataPeerInfo(TreeViewDataItemAutomationPeer dataPeer);
    internal void UpdateWeakRefStorageFromDataPeer();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
    internal void RaiseAutomationSelectionEvent(AutomationEvents eventId);
}
public class System.Windows.Automation.Peers.UserControlAutomationPeer : FrameworkElementAutomationPeer {
    public UserControlAutomationPeer(UserControl owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.Viewport3DAutomationPeer : FrameworkElementAutomationPeer {
    public Viewport3DAutomationPeer(Viewport3D owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.WindowAutomationPeer : FrameworkElementAutomationPeer {
    public WindowAutomationPeer(Window owner);
    protected virtual string GetClassNameCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual string GetNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Rect GetBoundingRectangleCore();
}
public class System.Windows.Baml2006.Baml2006Reader : XamlReader {
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlSchemaContext SchemaContext { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    private bool System.Xaml.IXamlLineInfo.HasLineInfo { get; }
    private int System.Xaml.IXamlLineInfo.LineNumber { get; }
    private int System.Xaml.IXamlLineInfo.LinePosition { get; }
    internal bool FreezeFreezables { get; internal set; }
    private bool System.Windows.Media.IFreezeFreezables.FreezeFreezables { get; }
    public Baml2006Reader(string fileName);
    public Baml2006Reader(Stream stream);
    public Baml2006Reader(Stream stream, XamlReaderSettings xamlReaderSettings);
    internal Baml2006Reader(Stream stream, Baml2006SchemaContext schemaContext, Baml2006ReaderSettings settings);
    internal Baml2006Reader(Stream stream, Baml2006SchemaContext baml2006SchemaContext, Baml2006ReaderSettings baml2006ReaderSettings, object root);
    public virtual bool Read();
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override bool System.Xaml.IXamlLineInfo.get_HasLineInfo();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LinePosition();
    internal List`1<KeyRecord> ReadKeys();
    internal XamlReader ReadObject(KeyRecord record);
    internal Type GetTypeOfFirstStartObject(KeyRecord record);
    internal virtual object CreateTypeConverterMarkupExtension(XamlMember property, TypeConverter converter, object propertyValue, Baml2006ReaderSettings settings);
    internal virtual string GetAssemblyNameForNamespace(Assembly assembly);
    internal bool get_FreezeFreezables();
    internal void set_FreezeFreezables(bool value);
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.get_FreezeFreezables();
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.TryFreeze(string value, Freezable freezable);
    private sealed virtual override Freezable System.Windows.Media.IFreezeFreezables.TryGetFreezable(string value);
}
internal class System.Windows.Baml2006.Baml2006ReaderContext : object {
    public Baml2006SchemaContext SchemaContext { get; }
    public Baml2006ReaderFrame CurrentFrame { get; }
    public Baml2006ReaderFrame PreviousFrame { get; }
    public List`1<KeyRecord> KeyList { get; public set; }
    public int CurrentKey { get; public set; }
    public KeyRecord LastKey { get; }
    public bool InsideKeyRecord { get; public set; }
    public bool InsideStaticResource { get; public set; }
    public int TemplateStartDepth { get; public set; }
    public int LineNumber { get; public set; }
    public int LineOffset { get; public set; }
    public Baml2006ReaderContext(Baml2006SchemaContext schemaContext);
    public Baml2006SchemaContext get_SchemaContext();
    public void PushScope();
    public void PopScope();
    public Baml2006ReaderFrame get_CurrentFrame();
    public Baml2006ReaderFrame get_PreviousFrame();
    [CompilerGeneratedAttribute]
public List`1<KeyRecord> get_KeyList();
    [CompilerGeneratedAttribute]
public void set_KeyList(List`1<KeyRecord> value);
    [CompilerGeneratedAttribute]
public int get_CurrentKey();
    [CompilerGeneratedAttribute]
public void set_CurrentKey(int value);
    public KeyRecord get_LastKey();
    [CompilerGeneratedAttribute]
public bool get_InsideKeyRecord();
    [CompilerGeneratedAttribute]
public void set_InsideKeyRecord(bool value);
    [CompilerGeneratedAttribute]
public bool get_InsideStaticResource();
    [CompilerGeneratedAttribute]
public void set_InsideStaticResource(bool value);
    [CompilerGeneratedAttribute]
public int get_TemplateStartDepth();
    [CompilerGeneratedAttribute]
public void set_TemplateStartDepth(int value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LineOffset();
    [CompilerGeneratedAttribute]
public void set_LineOffset(int value);
}
internal class System.Windows.Baml2006.Baml2006ReaderFrame : XamlFrame {
    protected Dictionary`2<string, string> _namespaces;
    public XamlType XamlType { get; public set; }
    public XamlMember Member { get; public set; }
    public KeyRecord Key { get; public set; }
    public int DelayedConnectionId { get; public set; }
    public XamlMember ContentProperty { get; public set; }
    public bool FreezeFreezables { get; public set; }
    public Baml2006ReaderFrameFlags Flags { get; public set; }
    public bool IsDeferredContent { get; public set; }
    public Baml2006ReaderFrame(Baml2006ReaderFrame source);
    public virtual XamlFrame Clone();
    [CompilerGeneratedAttribute]
public XamlType get_XamlType();
    [CompilerGeneratedAttribute]
public void set_XamlType(XamlType value);
    [CompilerGeneratedAttribute]
public XamlMember get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(XamlMember value);
    [CompilerGeneratedAttribute]
public KeyRecord get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(KeyRecord value);
    [CompilerGeneratedAttribute]
public int get_DelayedConnectionId();
    [CompilerGeneratedAttribute]
public void set_DelayedConnectionId(int value);
    [CompilerGeneratedAttribute]
public XamlMember get_ContentProperty();
    [CompilerGeneratedAttribute]
public void set_ContentProperty(XamlMember value);
    [CompilerGeneratedAttribute]
public bool get_FreezeFreezables();
    [CompilerGeneratedAttribute]
public void set_FreezeFreezables(bool value);
    public void AddNamespace(string prefix, string xamlNs);
    public void SetNamespaces(Dictionary`2<string, string> namespaces);
    public bool TryGetNamespaceByPrefix(string prefix, String& xamlNs);
    public bool TryGetPrefixByNamespace(string xamlNs, String& prefix);
    public virtual void Reset();
    [CompilerGeneratedAttribute]
public Baml2006ReaderFrameFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(Baml2006ReaderFrameFlags value);
    [CompilerGeneratedAttribute]
public bool get_IsDeferredContent();
    [CompilerGeneratedAttribute]
public void set_IsDeferredContent(bool value);
}
internal enum System.Windows.Baml2006.Baml2006ReaderFrameFlags : Enum {
    public byte value__;
    public static Baml2006ReaderFrameFlags None;
    public static Baml2006ReaderFrameFlags IsImplict;
    public static Baml2006ReaderFrameFlags HasImplicitProperty;
}
internal class System.Windows.Baml2006.Baml2006ReaderInternal : Baml2006Reader {
    internal Baml2006ReaderInternal(Stream stream, Baml2006SchemaContext schemaContext, Baml2006ReaderSettings settings);
    internal Baml2006ReaderInternal(Stream stream, Baml2006SchemaContext baml2006SchemaContext, Baml2006ReaderSettings baml2006ReaderSettings, object root);
    internal virtual string GetAssemblyNameForNamespace(Assembly asm);
    internal virtual object CreateTypeConverterMarkupExtension(XamlMember property, TypeConverter converter, object propertyValue, Baml2006ReaderSettings settings);
}
internal class System.Windows.Baml2006.Baml2006ReaderSettings : XamlReaderSettings {
    internal bool OwnsStream { get; internal set; }
    internal bool IsBamlFragment { get; internal set; }
    public Baml2006ReaderSettings(Baml2006ReaderSettings settings);
    public Baml2006ReaderSettings(XamlReaderSettings settings);
    [CompilerGeneratedAttribute]
internal bool get_OwnsStream();
    [CompilerGeneratedAttribute]
internal void set_OwnsStream(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsBamlFragment();
    [CompilerGeneratedAttribute]
internal void set_IsBamlFragment(bool value);
}
internal enum System.Windows.Baml2006.Baml2006RecordType : Enum {
    public byte value__;
    public static Baml2006RecordType Unknown;
    public static Baml2006RecordType DocumentStart;
    public static Baml2006RecordType DocumentEnd;
    public static Baml2006RecordType ElementStart;
    public static Baml2006RecordType ElementEnd;
    public static Baml2006RecordType Property;
    public static Baml2006RecordType PropertyCustom;
    public static Baml2006RecordType PropertyComplexStart;
    public static Baml2006RecordType PropertyComplexEnd;
    public static Baml2006RecordType PropertyArrayStart;
    public static Baml2006RecordType PropertyArrayEnd;
    public static Baml2006RecordType PropertyIListStart;
    public static Baml2006RecordType PropertyIListEnd;
    public static Baml2006RecordType PropertyIDictionaryStart;
    public static Baml2006RecordType PropertyIDictionaryEnd;
    public static Baml2006RecordType LiteralContent;
    public static Baml2006RecordType Text;
    public static Baml2006RecordType TextWithConverter;
    public static Baml2006RecordType RoutedEvent;
    public static Baml2006RecordType ClrEvent;
    public static Baml2006RecordType XmlnsProperty;
    public static Baml2006RecordType XmlAttribute;
    public static Baml2006RecordType ProcessingInstruction;
    public static Baml2006RecordType Comment;
    public static Baml2006RecordType DefTag;
    public static Baml2006RecordType DefAttribute;
    public static Baml2006RecordType EndAttributes;
    public static Baml2006RecordType PIMapping;
    public static Baml2006RecordType AssemblyInfo;
    public static Baml2006RecordType TypeInfo;
    public static Baml2006RecordType TypeSerializerInfo;
    public static Baml2006RecordType AttributeInfo;
    public static Baml2006RecordType StringInfo;
    public static Baml2006RecordType PropertyStringReference;
    public static Baml2006RecordType PropertyTypeReference;
    public static Baml2006RecordType PropertyWithExtension;
    public static Baml2006RecordType PropertyWithConverter;
    public static Baml2006RecordType DeferableContentStart;
    public static Baml2006RecordType DefAttributeKeyString;
    public static Baml2006RecordType DefAttributeKeyType;
    public static Baml2006RecordType KeyElementStart;
    public static Baml2006RecordType KeyElementEnd;
    public static Baml2006RecordType ConstructorParametersStart;
    public static Baml2006RecordType ConstructorParametersEnd;
    public static Baml2006RecordType ConstructorParameterType;
    public static Baml2006RecordType ConnectionId;
    public static Baml2006RecordType ContentProperty;
    public static Baml2006RecordType NamedElementStart;
    public static Baml2006RecordType StaticResourceStart;
    public static Baml2006RecordType StaticResourceEnd;
    public static Baml2006RecordType StaticResourceId;
    public static Baml2006RecordType TextWithId;
    public static Baml2006RecordType PresentationOptionsAttribute;
    public static Baml2006RecordType LineNumberAndPosition;
    public static Baml2006RecordType LinePosition;
    public static Baml2006RecordType OptimizedStaticResource;
    public static Baml2006RecordType PropertyWithStaticResourceId;
    public static Baml2006RecordType LastRecordType;
}
internal class System.Windows.Baml2006.Baml2006SchemaContext : XamlSchemaContext {
    internal static short StaticExtensionTypeId;
    internal static short StaticResourceTypeId;
    internal static short DynamicResourceTypeId;
    internal static short TemplateBindingTypeId;
    internal static short TypeExtensionTypeId;
    internal static string WpfNamespace;
    internal XamlMember StaticExtensionMemberTypeProperty { get; }
    internal XamlMember TypeExtensionTypeProperty { get; }
    internal XamlMember ResourceDictionaryDeferredContentProperty { get; }
    internal XamlType ResourceDictionaryType { get; }
    internal XamlType EventSetterType { get; }
    internal XamlMember EventSetterEventProperty { get; }
    internal XamlMember EventSetterHandlerProperty { get; }
    internal XamlMember FrameworkTemplateTemplateProperty { get; }
    internal XamlType StaticResourceExtensionType { get; }
    internal Assembly LocalAssembly { get; }
    internal Baml2006ReaderSettings Settings { get; internal set; }
    public Baml2006SchemaContext(Assembly localAssembly);
    internal Baml2006SchemaContext(Assembly localAssembly, XamlSchemaContext parentSchemaContext);
    private static Baml2006SchemaContext();
    public virtual bool TryGetCompatibleXamlNamespace(string xamlNamespace, String& compatibleNamespace);
    public virtual XamlDirective GetXamlDirective(string xamlNamespace, string name);
    public virtual IEnumerable`1<string> GetAllXamlNamespaces();
    public virtual ICollection`1<XamlType> GetAllXamlTypes(string xamlNamespace);
    public virtual string GetPreferredPrefix(string xmlns);
    public virtual XamlType GetXamlType(Type type);
    protected virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    internal XamlMember get_StaticExtensionMemberTypeProperty();
    internal XamlMember get_TypeExtensionTypeProperty();
    internal XamlMember get_ResourceDictionaryDeferredContentProperty();
    internal XamlType get_ResourceDictionaryType();
    internal XamlType get_EventSetterType();
    internal XamlMember get_EventSetterEventProperty();
    internal XamlMember get_EventSetterHandlerProperty();
    internal XamlMember get_FrameworkTemplateTemplateProperty();
    internal XamlType get_StaticResourceExtensionType();
    internal Assembly get_LocalAssembly();
    [CompilerGeneratedAttribute]
internal Baml2006ReaderSettings get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(Baml2006ReaderSettings value);
    internal void Reset();
    internal Assembly GetAssembly(short assemblyId);
    internal string GetAssemblyName(short assemblyId);
    internal Type GetClrType(short typeId);
    internal XamlType GetXamlType(short typeId);
    internal DependencyProperty GetDependencyProperty(short propertyId);
    internal XamlMember GetProperty(short propertyId, XamlType parentType);
    internal XamlMember GetProperty(short propertyId, bool isAttached);
    internal XamlType GetPropertyDeclaringType(short propertyId);
    internal string GetPropertyName(short propertyId, bool fullName);
    internal string GetString(short stringId);
    internal void AddAssembly(short assemblyId, string assemblyName);
    internal void AddXamlType(short typeId, short assemblyId, string typeName, TypeInfoFlags flags);
    internal void AddProperty(short propertyId, short declaringTypeId, string propertyName);
    internal void AddString(short stringId, string value);
    internal void AddXmlnsMapping(string xmlns, Int16[] assemblies);
}
internal class System.Windows.Baml2006.Baml6Assembly : object {
    public string Name;
    public Assembly Assembly { get; }
    public Baml6Assembly(string name);
    public Baml6Assembly(Assembly assembly);
    public Assembly get_Assembly();
}
internal class System.Windows.Baml2006.Baml6ConstructorInfo : ValueType {
    private List`1<Type> _types;
    private Func`2<Object[], object> _constructor;
    public List`1<Type> Types { get; }
    public Func`2<Object[], object> Constructor { get; }
    public Baml6ConstructorInfo(List`1<Type> types, Func`2<Object[], object> ctor);
    public List`1<Type> get_Types();
    public Func`2<Object[], object> get_Constructor();
}
internal static class System.Windows.Baml2006.Baml6KnownTypes : object {
    public static short BooleanConverter;
    public static short DependencyPropertyConverter;
    public static short EnumConverter;
    public static short XamlBrushSerializer;
    public static short XamlInt32CollectionSerializer;
    public static short XamlPathDataSerializer;
    public static short XamlPoint3DCollectionSerializer;
    public static short XamlPointCollectionSerializer;
    public static short XamlVector3DCollectionSerializer;
}
internal class System.Windows.Baml2006.BamlBinaryReader : BinaryReader {
    public BamlBinaryReader(Stream stream);
    public int Read7BitEncodedInt();
}
internal class System.Windows.Baml2006.DeferredBinaryDeserializerExtension : MarkupExtension {
    public DeferredBinaryDeserializerExtension(IFreezeFreezables freezer, BinaryReader reader, int converterId, int dataByteSize);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[DebuggerDisplayAttribute("{DebuggerString}")]
internal class System.Windows.Baml2006.KeyRecord : object {
    public bool Shared { get; }
    public bool SharedSet { get; }
    public long ValuePosition { get; public set; }
    public int ValueSize { get; public set; }
    public byte Flags { get; public set; }
    public List`1<object> StaticResources { get; }
    public bool HasStaticResources { get; }
    public StaticResource LastStaticResource { get; }
    public string KeyString { get; }
    public Type KeyType { get; }
    public XamlNodeList KeyNodeList { get; }
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, Type keyType);
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, string keyString);
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, XamlSchemaContext context);
    public bool get_Shared();
    public bool get_SharedSet();
    [CompilerGeneratedAttribute]
public long get_ValuePosition();
    [CompilerGeneratedAttribute]
public void set_ValuePosition(long value);
    [CompilerGeneratedAttribute]
public int get_ValueSize();
    [CompilerGeneratedAttribute]
public void set_ValueSize(int value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    public List`1<object> get_StaticResources();
    public bool get_HasStaticResources();
    public StaticResource get_LastStaticResource();
    public string get_KeyString();
    public Type get_KeyType();
    public XamlNodeList get_KeyNodeList();
}
internal class System.Windows.Baml2006.OptimizedStaticResource : object {
    public short KeyId { get; public set; }
    public object KeyValue { get; public set; }
    public bool IsKeyStaticExtension { get; }
    public bool IsKeyTypeExtension { get; }
    public OptimizedStaticResource(byte flags, short keyId);
    private static OptimizedStaticResource();
    [CompilerGeneratedAttribute]
public short get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(short value);
    [CompilerGeneratedAttribute]
public object get_KeyValue();
    [CompilerGeneratedAttribute]
public void set_KeyValue(object value);
    public bool get_IsKeyStaticExtension();
    public bool get_IsKeyTypeExtension();
}
internal class System.Windows.Baml2006.SharedStream : Stream {
    public int SharedCount { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsDisposed { get; }
    public Stream BaseStream { get; }
    public SharedStream(Stream baseStream);
    public SharedStream(Stream baseStream, long offset, long length);
    public virtual int get_SharedCount();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_IsDisposed();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public Stream get_BaseStream();
}
internal class System.Windows.Baml2006.SourceUriTypeConverterMarkupExtension : TypeConverterMarkupExtension {
    public SourceUriTypeConverterMarkupExtension(TypeConverter converter, object value, Assembly assemblyInfo);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class System.Windows.Baml2006.StaticResource : object {
    public XamlNodeList ResourceNodeList { get; private set; }
    public StaticResource(XamlType type, XamlSchemaContext schemaContext);
    [CompilerGeneratedAttribute]
public XamlNodeList get_ResourceNodeList();
    [CompilerGeneratedAttribute]
private void set_ResourceNodeList(XamlNodeList value);
}
internal abstract class System.Windows.Baml2006.ThemeKnownTypeHelper : object {
    public abstract virtual XamlType GetKnownXamlType(string name);
}
internal class System.Windows.Baml2006.TypeConverterMarkupExtension : MarkupExtension {
    public TypeConverterMarkupExtension(TypeConverter converter, object value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class System.Windows.Baml2006.WpfKnownMember : WpfXamlMember {
    public bool HasSpecialTypeConverter { get; public set; }
    public bool Ambient { get; public set; }
    public bool IsReadPrivate { get; public set; }
    public bool IsWritePrivate { get; public set; }
    public Action`2<object, object> SetDelegate { get; public set; }
    public Func`2<object, object> GetDelegate { get; public set; }
    public Type TypeConverterType { get; public set; }
    public Type DeferringLoaderType { get; public set; }
    public WpfKnownMember(XamlSchemaContext schema, XamlType declaringType, string name, DependencyProperty dProperty, bool isReadOnly, bool isAttachable);
    public WpfKnownMember(XamlSchemaContext schema, XamlType declaringType, string name, Type type, bool isReadOnly, bool isAttachable);
    public bool get_HasSpecialTypeConverter();
    public void set_HasSpecialTypeConverter(bool value);
    public bool get_Ambient();
    public void set_Ambient(bool value);
    public bool get_IsReadPrivate();
    public void set_IsReadPrivate(bool value);
    public bool get_IsWritePrivate();
    public void set_IsWritePrivate(bool value);
    protected virtual bool LookupIsUnknown();
    public void Freeze();
    protected virtual XamlMemberInvoker LookupInvoker();
    public Action`2<object, object> get_SetDelegate();
    public void set_SetDelegate(Action`2<object, object> value);
    public Func`2<object, object> get_GetDelegate();
    public void set_GetDelegate(Func`2<object, object> value);
    public Type get_TypeConverterType();
    public void set_TypeConverterType(Type value);
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    public Type get_DeferringLoaderType();
    public void set_DeferringLoaderType(Type value);
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual bool LookupIsReadOnly();
    protected virtual XamlType LookupType();
    protected virtual MemberInfo LookupUnderlyingMember();
    protected virtual bool LookupIsAmbient();
    protected virtual bool LookupIsWritePublic();
    protected virtual bool LookupIsReadPublic();
    protected virtual WpfXamlMember GetAsContentProperty();
}
internal class System.Windows.Baml2006.WpfKnownMemberInvoker : XamlMemberInvoker {
    public WpfKnownMemberInvoker(WpfKnownMember member);
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
    public virtual ShouldSerializeResult ShouldSerializeValue(object instance);
}
internal class System.Windows.Baml2006.WpfKnownType : WpfXamlType {
    public bool WhitespaceSignificantCollection { get; public set; }
    public bool IsUsableDuringInit { get; public set; }
    public bool HasSpecialValueConverter { get; public set; }
    public short BamlNumber { get; }
    public string ContentPropertyName { get; public set; }
    public string RuntimeNamePropertyName { get; public set; }
    public string XmlLangPropertyName { get; public set; }
    public string UidPropertyName { get; public set; }
    public string DictionaryKeyPropertyName { get; public set; }
    public XamlCollectionKind CollectionKind { get; public set; }
    public Func`1<object> DefaultConstructor { get; public set; }
    public Type TypeConverterType { get; public set; }
    public Type DeferringLoaderType { get; public set; }
    public Dictionary`2<int, Baml6ConstructorInfo> Constructors { get; }
    public WpfKnownType(XamlSchemaContext schema, int bamlNumber, string name, Type underlyingType);
    public WpfKnownType(XamlSchemaContext schema, int bamlNumber, string name, Type underlyingType, bool isBamlType, bool useV3Rules);
    public bool get_WhitespaceSignificantCollection();
    public void set_WhitespaceSignificantCollection(bool value);
    public bool get_IsUsableDuringInit();
    public void set_IsUsableDuringInit(bool value);
    public bool get_HasSpecialValueConverter();
    public void set_HasSpecialValueConverter(bool value);
    public void Freeze();
    public short get_BamlNumber();
    protected virtual XamlMember LookupContentProperty();
    public string get_ContentPropertyName();
    public void set_ContentPropertyName(string value);
    protected virtual XamlMember LookupAliasedProperty(XamlDirective directive);
    public string get_RuntimeNamePropertyName();
    public void set_RuntimeNamePropertyName(string value);
    public string get_XmlLangPropertyName();
    public void set_XmlLangPropertyName(string value);
    public string get_UidPropertyName();
    public void set_UidPropertyName(string value);
    public string get_DictionaryKeyPropertyName();
    public void set_DictionaryKeyPropertyName(string value);
    protected virtual XamlCollectionKind LookupCollectionKind();
    public XamlCollectionKind get_CollectionKind();
    public void set_CollectionKind(XamlCollectionKind value);
    protected virtual bool LookupIsWhitespaceSignificantCollection();
    public Func`1<object> get_DefaultConstructor();
    public void set_DefaultConstructor(Func`1<object> value);
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    public Type get_TypeConverterType();
    public void set_TypeConverterType(Type value);
    public Type get_DeferringLoaderType();
    public void set_DeferringLoaderType(Type value);
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual EventHandler`1<XamlSetMarkupExtensionEventArgs> LookupSetMarkupExtensionHandler();
    protected virtual EventHandler`1<XamlSetTypeConverterEventArgs> LookupSetTypeConverterHandler();
    protected virtual bool LookupUsableDuringInitialization();
    protected virtual XamlTypeInvoker LookupInvoker();
    public Dictionary`2<int, Baml6ConstructorInfo> get_Constructors();
    protected virtual IList`1<XamlType> LookupPositionalParameters(int paramCount);
    protected virtual ICustomAttributeProvider LookupCustomAttributeProvider();
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
    private sealed virtual override bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
}
internal class System.Windows.Baml2006.WpfKnownTypeInvoker : XamlTypeInvoker {
    public WpfKnownTypeInvoker(WpfKnownType type);
    public virtual object CreateInstance(Object[] arguments);
}
internal class System.Windows.Baml2006.WpfMemberInvoker : XamlMemberInvoker {
    public WpfMemberInvoker(WpfXamlMember member);
    public virtual void SetValue(object instance, object value);
    public virtual object GetValue(object instance);
    public virtual ShouldSerializeResult ShouldSerializeValue(object instance);
}
internal class System.Windows.Baml2006.WpfSharedBamlSchemaContext : XamlSchemaContext {
    internal XamlMember StaticExtensionMemberTypeProperty { get; }
    internal XamlMember TypeExtensionTypeProperty { get; }
    internal XamlMember ResourceDictionaryDeferredContentProperty { get; }
    internal XamlType ResourceDictionaryType { get; }
    internal XamlType EventSetterType { get; }
    internal XamlMember EventSetterEventProperty { get; }
    internal XamlMember EventSetterHandlerProperty { get; }
    internal XamlMember FrameworkTemplateTemplateProperty { get; }
    internal XamlType StaticResourceExtensionType { get; }
    internal Baml2006ReaderSettings Settings { get; internal set; }
    internal List`1<ThemeKnownTypeHelper> ThemeKnownTypeHelpers { get; }
    public WpfSharedBamlSchemaContext(XamlSchemaContextSettings settings);
    private static WpfSharedBamlSchemaContext();
    internal WpfKnownMember CreateKnownMember(string type, string property);
    internal WpfKnownMember CreateKnownAttachableMember(string type, string property);
    protected WpfKnownType CreateKnownBamlType(string typeName, bool isBamlType, bool useV3Rules);
    internal string GetKnownBamlString(short stringId);
    internal Baml6Assembly GetKnownBamlAssembly(short assemblyId);
    internal Baml6Assembly CreateKnownBamlAssembly(short assemblyId);
    internal WpfKnownType GetKnownBamlType(short typeId);
    internal WpfKnownMember GetKnownBamlMember(short memberId);
    public virtual XamlType GetXamlType(Type type);
    internal XamlType GetKnownXamlType(Type type);
    internal XamlValueConverter`1<XamlDeferringLoader> GetDeferringLoader(Type loaderType);
    internal XamlValueConverter`1<TypeConverter> GetTypeConverter(Type converterType);
    protected virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    public XamlType GetXamlTypeExposed(string xamlNamespace, string name, XamlType[] typeArguments);
    internal Type ResolvePrefixedNameWithAdditionalWpfSemantics(string prefixedName, DependencyObject element);
    internal XamlMember get_StaticExtensionMemberTypeProperty();
    internal XamlMember get_TypeExtensionTypeProperty();
    internal XamlMember get_ResourceDictionaryDeferredContentProperty();
    internal XamlType get_ResourceDictionaryType();
    internal XamlType get_EventSetterType();
    internal XamlMember get_EventSetterEventProperty();
    internal XamlMember get_EventSetterHandlerProperty();
    internal XamlMember get_FrameworkTemplateTemplateProperty();
    internal XamlType get_StaticResourceExtensionType();
    [CompilerGeneratedAttribute]
internal Baml2006ReaderSettings get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(Baml2006ReaderSettings value);
    internal List`1<ThemeKnownTypeHelper> get_ThemeKnownTypeHelpers();
}
internal class System.Windows.Baml2006.WpfSharedXamlSchemaContext : WpfSharedBamlSchemaContext {
    public WpfSharedXamlSchemaContext(XamlSchemaContextSettings settings, bool useV3Rules);
    public virtual XamlType GetXamlType(Type type);
    internal static void RequireRuntimeType(Type type);
    internal XamlType GetXamlTypeInternal(string xamlNamespace, string name, XamlType[] typeArguments);
}
internal class System.Windows.Baml2006.WpfXamlMember : XamlMember {
    public DependencyProperty DependencyProperty { get; public set; }
    public RoutedEvent RoutedEvent { get; public set; }
    internal bool ApplyGetterFallback { get; private set; }
    internal WpfXamlMember AsContentProperty { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetObject { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetProperty { get; }
    public WpfXamlMember(DependencyProperty dp, bool isAttachable);
    public WpfXamlMember(RoutedEvent re, bool isAttachable);
    public WpfXamlMember(DependencyProperty dp, MethodInfo getter, MethodInfo setter, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(DependencyProperty dp, PropertyInfo property, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(RoutedEvent re, MethodInfo setter, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(RoutedEvent re, EventInfo eventInfo, XamlSchemaContext schemaContext, bool useV3Rules);
    protected WpfXamlMember(string name, XamlType declaringType, bool isAttachable);
    [CompilerGeneratedAttribute]
public DependencyProperty get_DependencyProperty();
    [CompilerGeneratedAttribute]
public void set_DependencyProperty(DependencyProperty value);
    [CompilerGeneratedAttribute]
public RoutedEvent get_RoutedEvent();
    [CompilerGeneratedAttribute]
public void set_RoutedEvent(RoutedEvent value);
    internal bool get_ApplyGetterFallback();
    private void set_ApplyGetterFallback(bool value);
    internal WpfXamlMember get_AsContentProperty();
    protected virtual WpfXamlMember GetAsContentProperty();
    protected virtual XamlType LookupType();
    protected virtual MemberInfo LookupUnderlyingMember();
    protected virtual MethodInfo LookupUnderlyingSetter();
    protected virtual MethodInfo LookupUnderlyingGetter();
    protected virtual bool LookupIsReadOnly();
    protected virtual bool LookupIsEvent();
    protected virtual XamlMemberInvoker LookupInvoker();
    protected virtual bool LookupIsUnknown();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetObject();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetProperty();
}
internal class System.Windows.Baml2006.WpfXamlType : XamlType {
    protected byte _bitField;
    protected ConcurrentDictionary`2<string, XamlMember> Members { get; }
    protected ConcurrentDictionary`2<string, XamlMember> AttachableMembers { get; }
    public WpfXamlType(Type type, XamlSchemaContext schema, bool isBamlScenario, bool useV3Rules);
    protected ConcurrentDictionary`2<string, XamlMember> get_Members();
    protected ConcurrentDictionary`2<string, XamlMember> get_AttachableMembers();
    protected virtual XamlMember LookupContentProperty();
    protected virtual bool LookupIsNameScope();
    protected virtual XamlMember LookupMember(string name, bool skipReadOnlyCheck);
    protected virtual XamlMember LookupAttachableMember(string name);
    protected virtual IEnumerable`1<XamlMember> LookupAllMembers();
    protected virtual XamlCollectionKind LookupCollectionKind();
    internal XamlMember FindBaseXamlMember(string name, bool isAttachable);
    internal static bool GetFlag(Byte& bitField, byte typeBit);
    internal static void SetFlag(Byte& bitField, byte typeBit, bool value);
}
public enum System.Windows.BaseValueSource : Enum {
    public int value__;
    public static BaseValueSource Unknown;
    public static BaseValueSource Default;
    public static BaseValueSource Inherited;
    public static BaseValueSource DefaultStyle;
    public static BaseValueSource DefaultStyleTrigger;
    public static BaseValueSource Style;
    public static BaseValueSource TemplateTrigger;
    public static BaseValueSource StyleTrigger;
    public static BaseValueSource ImplicitStyleReference;
    public static BaseValueSource ParentTemplate;
    public static BaseValueSource ParentTemplateTrigger;
    public static BaseValueSource Local;
}
internal class System.Windows.BindingValueCache : object {
    internal Type BindingValueType;
    internal object ValueAsBindingValueType;
    internal BindingValueCache(Type bindingValueType, object valueAsBindingValueType);
}
internal static class System.Windows.BroadcastEventHelper : object {
    private static BroadcastEventHelper();
    internal static void AddLoadedCallback(DependencyObject d, DependencyObject logicalParent);
    internal static void RemoveLoadedCallback(DependencyObject d, Object[] loadedPending);
    internal static void AddUnloadedCallback(DependencyObject d, DependencyObject logicalParent);
    internal static void RemoveUnloadedCallback(DependencyObject d, Object[] unloadedPending);
    internal static void BroadcastLoadedOrUnloadedEvent(DependencyObject d, DependencyObject oldParent, DependencyObject newParent);
    internal static object BroadcastLoadedEvent(object root);
    internal static void BroadcastLoadedSynchronously(DependencyObject rootDO, bool isLoaded);
    internal static object BroadcastUnloadedEvent(object root);
    internal static void BroadcastUnloadedSynchronously(DependencyObject rootDO, bool isLoaded);
    internal static bool IsParentLoaded(DependencyObject d);
    internal static FrameworkElementFactory GetFEFTreeRoot(DependencyObject templatedParent);
    internal static void AddOrRemoveHasLoadedChangeHandlerFlag(DependencyObject d, DependencyObject oldParent, DependencyObject newParent);
    internal static void AddHasLoadedChangeHandlerFlagInAncestry(DependencyObject d);
    internal static void RemoveHasLoadedChangeHandlerFlagInAncestry(DependencyObject d);
}
internal class System.Windows.ChildEventDependent : ValueType {
    internal int ChildIndex;
    internal EventHandlersStore EventHandlersStore;
}
internal class System.Windows.ChildPropertyDependent : ValueType {
    public int ChildIndex;
    public DependencyProperty Property;
    public object Name;
}
internal class System.Windows.ChildRecord : ValueType {
    public ItemStructMap`1<ItemStructList`1<ChildValueLookup>> ValueLookupListFromProperty;
}
internal class System.Windows.ChildValueLookup : ValueType {
    internal ValueLookupType LookupType;
    internal TriggerCondition[] Conditions;
    internal DependencyProperty Property;
    internal object Value;
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static bool op_Equality(ChildValueLookup value1, ChildValueLookup value2);
    public static bool op_Inequality(ChildValueLookup value1, ChildValueLookup value2);
}
[MarkupExtensionReturnTypeAttribute("System.Windows.Media.Imaging.ColorConvertedBitmap")]
public class System.Windows.ColorConvertedBitmapExtension : MarkupExtension {
    public ColorConvertedBitmapExtension(object image);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public enum System.Windows.ColumnSpaceDistribution : Enum {
    public int value__;
    public static ColumnSpaceDistribution Left;
    public static ColumnSpaceDistribution Right;
    public static ColumnSpaceDistribution Between;
}
[TypeConverterAttribute("System.Windows.Markup.ComponentResourceKeyConverter")]
public class System.Windows.ComponentResourceKey : ResourceKey {
    public Type TypeInTargetAssembly { get; public set; }
    public Assembly Assembly { get; }
    public object ResourceId { get; public set; }
    public ComponentResourceKey(Type typeInTargetAssembly, object resourceId);
    public Type get_TypeInTargetAssembly();
    public void set_TypeInTargetAssembly(Type value);
    public virtual Assembly get_Assembly();
    public object get_ResourceId();
    public void set_ResourceId(object value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
public class System.Windows.Condition : object {
    [AmbientAttribute]
[DefaultValueAttribute("")]
public DependencyProperty Property { get; public set; }
    [DefaultValueAttribute("")]
public BindingBase Binding { get; public set; }
    [TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    [DefaultValueAttribute("")]
public string SourceName { get; public set; }
    public Condition(DependencyProperty conditionProperty, object conditionValue);
    public Condition(DependencyProperty conditionProperty, object conditionValue, string sourceName);
    public Condition(BindingBase binding, object conditionValue);
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public BindingBase get_Binding();
    public void set_Binding(BindingBase value);
    public object get_Value();
    public void set_Value(object value);
    public string get_SourceName();
    public void set_SourceName(string value);
    internal void Seal(ValueLookupType type);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
}
public class System.Windows.ConditionCollection : Collection`1<Condition> {
    public bool IsSealed { get; }
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, Condition item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, Condition item);
    public bool get_IsSealed();
    internal void Seal(ValueLookupType type);
}
internal class System.Windows.ContainerDependent : ValueType {
    internal DependencyProperty Property;
    internal bool FromVisualTrigger;
}
[ContentPropertyAttribute("Text")]
public class System.Windows.Controls.AccessText : FrameworkElement {
    public static DependencyProperty TextProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty TextTrimmingProperty;
    public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty BaselineOffsetProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public char AccessKey { get; }
    [DefaultValueAttribute("")]
public string Text { get; public set; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public TextTrimming TextTrimming { get; public set; }
    public TextWrapping TextWrapping { get; public set; }
    public double BaselineOffset { get; public set; }
    internal TextBlock TextBlock { get; }
    internal static char AccessKeyMarker { get; }
    protected int VisualChildrenCount { get; }
    private static AccessText();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    public char get_AccessKey();
    public string get_Text();
    public void set_Text(string value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public TextTrimming get_TextTrimming();
    public void set_TextTrimming(TextTrimming value);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public double get_BaselineOffset();
    public void set_BaselineOffset(double value);
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    internal static bool HasCustomSerialization(object o);
    internal TextBlock get_TextBlock();
    internal static char get_AccessKeyMarker();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal static void SerializeCustom(XmlWriter xmlWriter, object o);
    internal static string RemoveAccessKeyMarker(string text);
}
public class System.Windows.Controls.AddingNewItemEventArgs : EventArgs {
    public object NewItem { get; public set; }
    public object get_NewItem();
    public void set_NewItem(object value);
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.AdornedElementPlaceholder : FrameworkElement {
    public UIElement AdornedElement { get; }
    [DefaultValueAttribute("")]
public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public UIElement get_AdornedElement();
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
}
[ContentPropertyAttribute("Values")]
public class System.Windows.Controls.AlternationConverter : object {
    public IList Values { get; }
    public IList get_Values();
    public sealed virtual object Convert(object o, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type targetType, object parameter, CultureInfo culture);
}
internal class System.Windows.Controls.AVElementHelper : object {
    internal MediaPlayer Player { get; }
    internal Uri BaseUri { get; internal set; }
    internal TimeSpan Position { get; }
    internal MediaClock Clock { get; }
    internal double SpeedRatio { get; }
    internal AVElementHelper(MediaElement element);
    internal static AVElementHelper GetHelper(DependencyObject d);
    internal MediaPlayer get_Player();
    internal Uri get_BaseUri();
    internal void set_BaseUri(Uri value);
    internal void SetUnloadedBehavior(MediaState unloadedBehavior);
    internal void SetLoadedBehavior(MediaState loadedBehavior);
    internal TimeSpan get_Position();
    internal void SetPosition(TimeSpan position);
    internal MediaClock get_Clock();
    internal void SetClock(MediaClock clock);
    internal double get_SpeedRatio();
    internal void SetSpeedRatio(double speedRatio);
    internal void SetState(MediaState mediaState);
    internal void SetVolume(double volume);
    internal void SetBalance(double balance);
    internal void SetIsMuted(bool isMuted);
    internal void SetScrubbingEnabled(bool isScrubbingEnabled);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[LocalizabilityAttribute("17")]
internal class System.Windows.Controls.BooleanToSelectiveScrollingOrientationConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.BooleanToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class System.Windows.Controls.Border : Decorator {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty CornerRadiusProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderBrushProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    public Thickness BorderThickness { get; public set; }
    public Thickness Padding { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public Brush BorderBrush { get; public set; }
    public Brush Background { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Border();
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext dc);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Controls.BorderGapMaskConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class System.Windows.Controls.Button : ButtonBase {
    public static DependencyProperty IsDefaultProperty;
    public static DependencyProperty IsCancelProperty;
    public static DependencyProperty IsDefaultedProperty;
    public bool IsDefault { get; public set; }
    public bool IsCancel { get; public set; }
    public bool IsDefaulted { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Button();
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    public bool get_IsCancel();
    public void set_IsCancel(bool value);
    public bool get_IsDefaulted();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Calendar : Control {
    public static RoutedEvent SelectedDatesChangedEvent;
    public static DependencyProperty CalendarButtonStyleProperty;
    public static DependencyProperty CalendarDayButtonStyleProperty;
    public static DependencyProperty CalendarItemStyleProperty;
    public static DependencyProperty DisplayDateProperty;
    public static DependencyProperty DisplayDateEndProperty;
    public static DependencyProperty DisplayDateStartProperty;
    public static DependencyProperty DisplayModeProperty;
    public static DependencyProperty FirstDayOfWeekProperty;
    public static DependencyProperty IsTodayHighlightedProperty;
    public static DependencyProperty SelectedDateProperty;
    public static DependencyProperty SelectionModeProperty;
    public CalendarBlackoutDatesCollection BlackoutDates { get; }
    public Style CalendarButtonStyle { get; public set; }
    public Style CalendarDayButtonStyle { get; public set; }
    public Style CalendarItemStyle { get; public set; }
    public DateTime DisplayDate { get; public set; }
    public Nullable`1<DateTime> DisplayDateEnd { get; public set; }
    public Nullable`1<DateTime> DisplayDateStart { get; public set; }
    public CalendarMode DisplayMode { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public bool IsTodayHighlighted { get; public set; }
    public Nullable`1<DateTime> SelectedDate { get; public set; }
    public SelectedDatesCollection SelectedDates { get; }
    public CalendarSelectionMode SelectionMode { get; public set; }
    internal bool DatePickerDisplayDateFlag { get; internal set; }
    internal DateTime DisplayDateInternal { get; private set; }
    internal DateTime DisplayDateEndInternal { get; }
    internal DateTime DisplayDateStartInternal { get; }
    internal DateTime CurrentDate { get; internal set; }
    internal Nullable`1<DateTime> HoverStart { get; internal set; }
    internal Nullable`1<DateTime> HoverEnd { get; internal set; }
    internal CalendarItem MonthControl { get; }
    internal DateTime DisplayMonth { get; }
    internal DateTime DisplayYear { get; }
    private static Calendar();
    public void add_SelectedDatesChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public void remove_SelectedDatesChanged(EventHandler`1<SelectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DisplayDateChanged(EventHandler`1<CalendarDateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DisplayDateChanged(EventHandler`1<CalendarDateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DisplayModeChanged(EventHandler`1<CalendarModeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DisplayModeChanged(EventHandler`1<CalendarModeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SelectionModeChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SelectionModeChanged(EventHandler`1<EventArgs> value);
    public CalendarBlackoutDatesCollection get_BlackoutDates();
    public Style get_CalendarButtonStyle();
    public void set_CalendarButtonStyle(Style value);
    public Style get_CalendarDayButtonStyle();
    public void set_CalendarDayButtonStyle(Style value);
    public Style get_CalendarItemStyle();
    public void set_CalendarItemStyle(Style value);
    public DateTime get_DisplayDate();
    public void set_DisplayDate(DateTime value);
    public Nullable`1<DateTime> get_DisplayDateEnd();
    public void set_DisplayDateEnd(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_DisplayDateStart();
    public void set_DisplayDateStart(Nullable`1<DateTime> value);
    public CalendarMode get_DisplayMode();
    public void set_DisplayMode(CalendarMode value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public bool get_IsTodayHighlighted();
    public void set_IsTodayHighlighted(bool value);
    public Nullable`1<DateTime> get_SelectedDate();
    public void set_SelectedDate(Nullable`1<DateTime> value);
    public SelectedDatesCollection get_SelectedDates();
    public CalendarSelectionMode get_SelectionMode();
    public void set_SelectionMode(CalendarSelectionMode value);
    [CompilerGeneratedAttribute]
internal void add_DayButtonMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DayButtonMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_DayOrMonthPreviewKeyDown(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DayOrMonthPreviewKeyDown(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
internal bool get_DatePickerDisplayDateFlag();
    [CompilerGeneratedAttribute]
internal void set_DatePickerDisplayDateFlag(bool value);
    [CompilerGeneratedAttribute]
internal DateTime get_DisplayDateInternal();
    [CompilerGeneratedAttribute]
private void set_DisplayDateInternal(DateTime value);
    internal DateTime get_DisplayDateEndInternal();
    internal DateTime get_DisplayDateStartInternal();
    internal DateTime get_CurrentDate();
    internal void set_CurrentDate(DateTime value);
    internal Nullable`1<DateTime> get_HoverStart();
    internal void set_HoverStart(Nullable`1<DateTime> value);
    internal Nullable`1<DateTime> get_HoverEnd();
    internal void set_HoverEnd(Nullable`1<DateTime> value);
    internal CalendarItem get_MonthControl();
    internal DateTime get_DisplayMonth();
    internal DateTime get_DisplayYear();
    public virtual void OnApplyTemplate();
    public virtual string ToString();
    protected virtual void OnSelectedDatesChanged(SelectionChangedEventArgs e);
    protected virtual void OnDisplayDateChanged(CalendarDateChangedEventArgs e);
    protected virtual void OnDisplayModeChanged(CalendarModeChangedEventArgs e);
    protected virtual void OnSelectionModeChanged(EventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    internal CalendarDayButton FindDayButtonFromDay(DateTime day);
    internal static bool IsValidDateSelection(Calendar cal, object value);
    internal void OnDayButtonMouseUp(MouseButtonEventArgs e);
    internal void OnDayOrMonthPreviewKeyDown(RoutedEventArgs e);
    internal void OnDayClick(DateTime selectedDate);
    internal void OnCalendarButtonPressed(CalendarButton b, bool switchDisplayMode);
    internal void OnNextClick();
    internal void OnPreviousClick();
    internal void OnSelectedDatesCollectionChanged(SelectionChangedEventArgs e);
    internal void UpdateCellItems();
    internal static bool IsValidFirstDayOfWeek(object value);
    internal void FocusDate(DateTime date);
}
public class System.Windows.Controls.CalendarBlackoutDatesCollection : ObservableCollection`1<CalendarDateRange> {
    public CalendarBlackoutDatesCollection(Calendar owner);
    public void AddDatesInPast();
    public bool Contains(DateTime date);
    public bool Contains(DateTime start, DateTime end);
    public bool ContainsAny(CalendarDateRange range);
    internal Nullable`1<DateTime> GetNonBlackoutDate(Nullable`1<DateTime> requestedDate, int dayInterval);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, CalendarDateRange item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, CalendarDateRange item);
}
public class System.Windows.Controls.CalendarDateChangedEventArgs : RoutedEventArgs {
    public Nullable`1<DateTime> AddedDate { get; private set; }
    public Nullable`1<DateTime> RemovedDate { get; private set; }
    internal CalendarDateChangedEventArgs(Nullable`1<DateTime> removedDate, Nullable`1<DateTime> addedDate);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_AddedDate();
    [CompilerGeneratedAttribute]
private void set_AddedDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_RemovedDate();
    [CompilerGeneratedAttribute]
private void set_RemovedDate(Nullable`1<DateTime> value);
}
public class System.Windows.Controls.CalendarDateRange : object {
    public DateTime End { get; public set; }
    public DateTime Start { get; public set; }
    public CalendarDateRange(DateTime day);
    public CalendarDateRange(DateTime start, DateTime end);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public DateTime get_End();
    public void set_End(DateTime value);
    public DateTime get_Start();
    public void set_Start(DateTime value);
    [CompilerGeneratedAttribute]
internal void add_Changing(EventHandler`1<CalendarDateRangeChangingEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_Changing(EventHandler`1<CalendarDateRangeChangingEventArgs> value);
    internal bool ContainsAny(CalendarDateRange range);
}
internal class System.Windows.Controls.CalendarDateRangeChangingEventArgs : EventArgs {
    public DateTime Start { get; }
    public DateTime End { get; }
    public CalendarDateRangeChangingEventArgs(DateTime start, DateTime end);
    public DateTime get_Start();
    public DateTime get_End();
}
internal static class System.Windows.Controls.CalendarKeyboardHelper : object {
    public static void GetMetaKeyState(Boolean& ctrl, Boolean& shift);
}
public enum System.Windows.Controls.CalendarMode : Enum {
    public int value__;
    public static CalendarMode Month;
    public static CalendarMode Year;
    public static CalendarMode Decade;
}
public class System.Windows.Controls.CalendarModeChangedEventArgs : RoutedEventArgs {
    public CalendarMode NewMode { get; private set; }
    public CalendarMode OldMode { get; private set; }
    public CalendarModeChangedEventArgs(CalendarMode oldMode, CalendarMode newMode);
    [CompilerGeneratedAttribute]
public CalendarMode get_NewMode();
    [CompilerGeneratedAttribute]
private void set_NewMode(CalendarMode value);
    [CompilerGeneratedAttribute]
public CalendarMode get_OldMode();
    [CompilerGeneratedAttribute]
private void set_OldMode(CalendarMode value);
}
internal class System.Windows.Controls.CalendarSelectionChangedEventArgs : SelectionChangedEventArgs {
    public CalendarSelectionChangedEventArgs(RoutedEvent eventId, IList removedItems, IList addedItems);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public enum System.Windows.Controls.CalendarSelectionMode : Enum {
    public int value__;
    public static CalendarSelectionMode SingleDate;
    public static CalendarSelectionMode SingleRange;
    public static CalendarSelectionMode MultipleRange;
    public static CalendarSelectionMode None;
}
public class System.Windows.Controls.Canvas : Panel {
    public static DependencyProperty LeftProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty BottomProperty;
    internal int EffectiveValuesInitialSize { get; }
    private static Canvas();
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Controls.CharacterCasing : Enum {
    public int value__;
    public static CharacterCasing Normal;
    public static CharacterCasing Lower;
    public static CharacterCasing Upper;
}
[DefaultEventAttribute("CheckStateChanged")]
[LocalizabilityAttribute("5")]
public class System.Windows.Controls.CheckBox : ToggleButton {
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static CheckBox();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.CleanUpVirtualizedItemEventArgs : RoutedEventArgs {
    public object Value { get; }
    public UIElement UIElement { get; }
    public bool Cancel { get; public set; }
    public CleanUpVirtualizedItemEventArgs(object value, UIElement element);
    public object get_Value();
    public UIElement get_UIElement();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.Windows.Controls.CleanUpVirtualizedItemEventHandler : MulticastDelegate {
    public CleanUpVirtualizedItemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CleanUpVirtualizedItemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CleanUpVirtualizedItemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.ClickMode : Enum {
    public int value__;
    public static ClickMode Release;
    public static ClickMode Press;
    public static ClickMode Hover;
}
public class System.Windows.Controls.ColumnDefinition : DefinitionBase {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty WidthProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MinWidthProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MaxWidthProperty;
    public GridLength Width { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxWidth { get; public set; }
    public double ActualWidth { get; }
    public double Offset { get; }
    private static ColumnDefinition();
    public GridLength get_Width();
    public void set_Width(GridLength value);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public double get_ActualWidth();
    public double get_Offset();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.ColumnDefinitionCollection : object {
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ColumnDefinition Item { get; public set; }
    internal int InternalCount { get; }
    internal DefinitionBase[] InternalItems { get; }
    internal ColumnDefinitionCollection(Grid owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(ColumnDefinition[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Add(ColumnDefinition value);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual bool Contains(ColumnDefinition value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual int IndexOf(ColumnDefinition value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual void Insert(int index, ColumnDefinition value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual bool Remove(ColumnDefinition value);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<ColumnDefinition> System.Collections.Generic.IEnumerable<System.Windows.Controls.ColumnDefinition>.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual ColumnDefinition get_Item(int index);
    public sealed virtual void set_Item(int index, ColumnDefinition value);
    internal void InternalTrimToSize();
    internal int get_InternalCount();
    internal DefinitionBase[] get_InternalItems();
}
internal enum System.Windows.Controls.ColumnMeasureState : Enum {
    public int value__;
    public static ColumnMeasureState Init;
    public static ColumnMeasureState Headered;
    public static ColumnMeasureState Data;
    public static ColumnMeasureState SpecificWidth;
}
[LocalizabilityAttribute("6")]
[TemplatePartAttribute]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ComboBox : Selector {
    public static DependencyProperty MaxDropDownHeightProperty;
    public static DependencyProperty IsDropDownOpenProperty;
    public static DependencyProperty ShouldPreserveUserEnteredPrefixProperty;
    public static DependencyProperty IsEditableProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty SelectionBoxItemProperty;
    public static DependencyProperty SelectionBoxItemTemplateProperty;
    public static DependencyProperty SelectionBoxItemStringFormatProperty;
    public static DependencyProperty StaysOpenOnEditProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxDropDownHeight { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsDropDownOpen { get; public set; }
    public bool ShouldPreserveUserEnteredPrefix { get; public set; }
    public bool IsEditable { get; public set; }
    public string Text { get; public set; }
    public bool IsReadOnly { get; public set; }
    public object SelectionBoxItem { get; private set; }
    public DataTemplate SelectionBoxItemTemplate { get; private set; }
    public string SelectionBoxItemStringFormat { get; private set; }
    public bool StaysOpenOnEdit { get; public set; }
    public bool IsSelectionBoxHighlighted { get; }
    protected internal bool HandlesScrolling { get; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    internal TextBox EditableTextBoxSite { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ComboBox();
    public double get_MaxDropDownHeight();
    public void set_MaxDropDownHeight(double value);
    public bool get_IsDropDownOpen();
    public void set_IsDropDownOpen(bool value);
    public bool get_ShouldPreserveUserEnteredPrefix();
    public void set_ShouldPreserveUserEnteredPrefix(bool value);
    protected virtual void OnDropDownOpened(EventArgs e);
    protected virtual void OnDropDownClosed(EventArgs e);
    public bool get_IsEditable();
    public void set_IsEditable(bool value);
    public string get_Text();
    public void set_Text(string value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public object get_SelectionBoxItem();
    private void set_SelectionBoxItem(object value);
    public DataTemplate get_SelectionBoxItemTemplate();
    private void set_SelectionBoxItemTemplate(DataTemplate value);
    public string get_SelectionBoxItemStringFormat();
    private void set_SelectionBoxItemStringFormat(string value);
    public bool get_StaysOpenOnEdit();
    public void set_StaysOpenOnEdit(bool value);
    public bool get_IsSelectionBoxHighlighted();
    public void add_DropDownOpened(EventHandler value);
    public void remove_DropDownOpened(EventHandler value);
    public void add_DropDownClosed(EventHandler value);
    public void remove_DropDownClosed(EventHandler value);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    internal void SelectedItemUpdated();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    internal void NotifyComboBoxItemMouseDown(ComboBoxItem comboBoxItem);
    internal void NotifyComboBoxItemMouseUp(ComboBoxItem comboBoxItem);
    internal void NotifyComboBoxItemEnter(ComboBoxItem item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    public virtual void OnApplyTemplate();
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal TextBox get_EditableTextBoxSite();
    internal void set_EditableTextBoxSite(TextBox value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("6")]
public class System.Windows.Controls.ComboBoxItem : ListBoxItem {
    public static DependencyProperty IsHighlightedProperty;
    public bool IsHighlighted { get; protected set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ComboBoxItem();
    public bool get_IsHighlighted();
    protected void set_IsHighlighted(bool value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void SetIsHighlighted(bool isHighlighted);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.ContainerTracking`1 : object {
    internal T Container { get; }
    internal ContainerTracking`1<T> Next { get; }
    internal ContainerTracking`1<T> Previous { get; }
    internal ContainerTracking`1(T container);
    internal T get_Container();
    internal ContainerTracking`1<T> get_Next();
    internal ContainerTracking`1<T> get_Previous();
    internal void StartTracking(ContainerTracking`1& root);
    internal void StopTracking(ContainerTracking`1& root);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertIsInList(ContainerTracking`1<T> root);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertNotInList(ContainerTracking`1<T> root);
}
[DefaultPropertyAttribute("Content")]
[ContentPropertyAttribute("Content")]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ContentControl : Control {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasContentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentStringFormatProperty;
    protected internal IEnumerator LogicalChildren { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public object Content { get; public set; }
    [BrowsableAttribute("False")]
[ReadOnlyAttribute("True")]
public bool HasContent { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate ContentTemplate { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ContentTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ContentStringFormat { get; public set; }
    internal bool ContentIsNotLogical { get; internal set; }
    internal bool ContentIsItem { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ContentControl();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual string GetPlainText();
    internal static string ContentObjectToString(object content);
    internal void PrepareContentControl(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string itemStringFormat);
    internal void ClearContentControl(object item);
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public sealed virtual object get_Content();
    public sealed virtual void set_Content(object value);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    public bool get_HasContent();
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat);
    internal bool get_ContentIsNotLogical();
    internal void set_ContentIsNotLogical(bool value);
    internal bool get_ContentIsItem();
    internal void set_ContentIsItem(bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ContentPresenter : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RecognizesAccessKeyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentStringFormatProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentSourceProperty;
    internal static DependencyProperty TemplateProperty;
    public bool RecognizesAccessKey { get; public set; }
    public object Content { get; public set; }
    public DataTemplate ContentTemplate { get; public set; }
    public DataTemplateSelector ContentTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ContentStringFormat { get; public set; }
    public string ContentSource { get; public set; }
    internal static DataTemplate AccessTextContentTemplate { get; }
    internal static DataTemplate StringContentTemplate { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    internal bool TemplateIsCurrent { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ContentPresenter();
    public bool get_RecognizesAccessKey();
    public void set_RecognizesAccessKey(bool value);
    public object get_Content();
    public void set_Content(object value);
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeContentTemplateSelector();
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat);
    public string get_ContentSource();
    public void set_ContentSource(string value);
    internal virtual void OnPreApplyTemplate();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual DataTemplate ChooseTemplate();
    internal static DataTemplate get_AccessTextContentTemplate();
    internal static DataTemplate get_StringContentTemplate();
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal bool get_TemplateIsCurrent();
    internal void PrepareContentPresenter(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string stringFormat);
    internal void ClearContentPresenter(object item);
    internal static object DataTypeForItem(object item, DependencyObject target, Type& type);
    internal void ReevaluateTemplate();
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnTemplateChanged(DataTemplate oldTemplate, DataTemplate newTemplate);
    internal static FrameworkElementFactory CreateAccessTextFactory();
    internal static FrameworkElementFactory CreateTextBlockFactory();
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultEventAttribute("Opened")]
public class System.Windows.Controls.ContextMenu : MenuBase {
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double VerticalOffset { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[DesignerSerializationVisibilityAttribute("0")]
public UIElement PlacementTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Rect PlacementRectangle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    public bool HasDropShadow { get; public set; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpen { get; public set; }
    protected internal bool HandlesScrolling { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ContextMenu();
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    public bool get_HasDropShadow();
    public void set_HasDropShadow(bool value);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    protected virtual void OnOpened(RoutedEventArgs e);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    protected virtual void OnClosed(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal virtual void OnAncestorChanged();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ContextMenuEventArgs : RoutedEventArgs {
    public double CursorLeft { get; }
    public double CursorTop { get; }
    internal DependencyObject TargetElement { get; internal set; }
    internal ContextMenuEventArgs(object source, bool opening);
    internal ContextMenuEventArgs(object source, bool opening, double left, double top);
    public double get_CursorLeft();
    public double get_CursorTop();
    internal DependencyObject get_TargetElement();
    internal void set_TargetElement(DependencyObject value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ContextMenuEventHandler : MulticastDelegate {
    public ContextMenuEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ContextMenuEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ContextMenuEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.ContextMenuService : object {
    public static DependencyProperty ContextMenuProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ShowOnDisabledProperty;
    public static DependencyProperty IsEnabledProperty;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    private static ContextMenuService();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ContextMenu GetContextMenu(DependencyObject element);
    public static void SetContextMenu(DependencyObject element, ContextMenu value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetHorizontalOffset(DependencyObject element);
    public static void SetHorizontalOffset(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetVerticalOffset(DependencyObject element);
    public static void SetVerticalOffset(DependencyObject element, double value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHasDropShadow(DependencyObject element);
    public static void SetHasDropShadow(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static UIElement GetPlacementTarget(DependencyObject element);
    public static void SetPlacementTarget(DependencyObject element, UIElement value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static Rect GetPlacementRectangle(DependencyObject element);
    public static void SetPlacementRectangle(DependencyObject element, Rect value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static PlacementMode GetPlacement(DependencyObject element);
    public static void SetPlacement(DependencyObject element, PlacementMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetShowOnDisabled(DependencyObject element);
    public static void SetShowOnDisabled(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsEnabled(DependencyObject element);
    public static void SetIsEnabled(DependencyObject element, bool value);
    public static void AddContextMenuOpeningHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void RemoveContextMenuOpeningHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void AddContextMenuClosingHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void RemoveContextMenuClosingHandler(DependencyObject element, ContextMenuEventHandler handler);
    internal static bool ContextMenuIsEnabled(DependencyObject o);
}
public class System.Windows.Controls.Control : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderBrushProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderThicknessProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalContentAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalContentAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TabIndexProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsTabStopProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PaddingProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TemplateProperty;
    public static RoutedEvent PreviewMouseDoubleClickEvent;
    public static RoutedEvent MouseDoubleClickEvent;
    internal ControlBoolFlags _controlBoolField;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush BorderBrush { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Thickness BorderThickness { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush Background { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush Foreground { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public FontStretch FontStretch { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public FontStyle FontStyle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public FontWeight FontWeight { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public HorizontalAlignment HorizontalContentAlignment { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public VerticalAlignment VerticalContentAlignment { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int TabIndex { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsTabStop { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Thickness Padding { get; public set; }
    public ControlTemplate Template { get; public set; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    protected internal bool HandlesScrolling { get; }
    internal bool VisualStateChangeSuspended { get; internal set; }
    private static Control();
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public HorizontalAlignment get_HorizontalContentAlignment();
    public void set_HorizontalContentAlignment(HorizontalAlignment value);
    public VerticalAlignment get_VerticalContentAlignment();
    public void set_VerticalContentAlignment(VerticalAlignment value);
    public int get_TabIndex();
    public void set_TabIndex(int value);
    public bool get_IsTabStop();
    public void set_IsTabStop(bool value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public ControlTemplate get_Template();
    public void set_Template(ControlTemplate value);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected internal virtual bool get_HandlesScrolling();
    internal bool get_VisualStateChangeSuspended();
    internal void set_VisualStateChangeSuspended(bool value);
    public virtual string ToString();
    public void add_PreviewMouseDoubleClick(MouseButtonEventHandler value);
    public void remove_PreviewMouseDoubleClick(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseDoubleClick(MouseButtonEventArgs e);
    public void add_MouseDoubleClick(MouseButtonEventHandler value);
    public void remove_MouseDoubleClick(MouseButtonEventHandler value);
    protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnPostApplyTemplate();
    internal void UpdateVisualState();
    internal void UpdateVisualState(bool useTransitions);
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void ChangeValidationVisualState(bool useTransitions);
    internal static void OnVisualStatePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    internal bool ReadControlFlag(ControlBoolFlags reqFlag);
    internal void WriteControlFlag(ControlBoolFlags reqFlag, bool set);
}
[LocalizabilityAttribute("0")]
[DictionaryKeyPropertyAttribute("TargetType")]
public class System.Windows.Controls.ControlTemplate : FrameworkTemplate {
    internal static Type DefaultTargetType;
    [AmbientAttribute]
[DefaultValueAttribute("")]
public Type TargetType { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[DependsOnAttribute("VisualTree")]
[DependsOnAttribute("Template")]
public TriggerCollection Triggers { get; }
    internal Type TargetTypeInternal { get; }
    internal TriggerCollection TriggersInternal { get; }
    public ControlTemplate(Type targetType);
    private static ControlTemplate();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
    public Type get_TargetType();
    public void set_TargetType(Type value);
    public TriggerCollection get_Triggers();
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal virtual TriggerCollection get_TriggersInternal();
}
internal class System.Windows.Controls.ConversionValidationRule : ValidationRule {
    internal static ConversionValidationRule Instance;
    private static ConversionValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
internal class System.Windows.Controls.CustomDictionarySources : object {
    private Uri System.Collections.Generic.IList<System.Uri>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Uri>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Uri>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal CustomDictionarySources(TextBoxBase owner);
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<System.Uri>.IndexOf(Uri item);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.Insert(int index, Uri item);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.RemoveAt(int index);
    private sealed virtual override Uri System.Collections.Generic.IList<System.Uri>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.set_Item(int index, Uri value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.Add(Uri item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.Contains(Uri item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.CopyTo(Uri[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Uri>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.Remove(Uri item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public class System.Windows.Controls.DataErrorValidationRule : ValidationRule {
    internal static DataErrorValidationRule Instance;
    private static DataErrorValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
public class System.Windows.Controls.DataGrid : MultiSelector {
    public static DependencyProperty CanUserResizeColumnsProperty;
    public static DependencyProperty ColumnWidthProperty;
    public static DependencyProperty MinColumnWidthProperty;
    public static DependencyProperty MaxColumnWidthProperty;
    public static DependencyProperty GridLinesVisibilityProperty;
    public static DependencyProperty HorizontalGridLinesBrushProperty;
    public static DependencyProperty VerticalGridLinesBrushProperty;
    public static DependencyProperty RowStyleProperty;
    public static DependencyProperty RowValidationErrorTemplateProperty;
    public static DependencyProperty RowStyleSelectorProperty;
    public static DependencyProperty RowBackgroundProperty;
    public static DependencyProperty AlternatingRowBackgroundProperty;
    public static DependencyProperty RowHeightProperty;
    public static DependencyProperty MinRowHeightProperty;
    public static DependencyProperty RowHeaderWidthProperty;
    public static DependencyProperty RowHeaderActualWidthProperty;
    public static DependencyProperty ColumnHeaderHeightProperty;
    public static DependencyProperty HeadersVisibilityProperty;
    public static DependencyProperty CellStyleProperty;
    public static DependencyProperty ColumnHeaderStyleProperty;
    public static DependencyProperty RowHeaderStyleProperty;
    public static DependencyProperty RowHeaderTemplateProperty;
    public static DependencyProperty RowHeaderTemplateSelectorProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    internal static DependencyProperty HorizontalScrollOffsetProperty;
    public static RoutedCommand BeginEditCommand;
    public static RoutedCommand CommitEditCommand;
    public static RoutedCommand CancelEditCommand;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty CurrentItemProperty;
    public static DependencyProperty CurrentColumnProperty;
    public static DependencyProperty CurrentCellProperty;
    public static DependencyProperty CanUserAddRowsProperty;
    public static DependencyProperty CanUserDeleteRowsProperty;
    public static DependencyProperty RowDetailsVisibilityModeProperty;
    public static DependencyProperty AreRowDetailsFrozenProperty;
    public static DependencyProperty RowDetailsTemplateProperty;
    public static DependencyProperty RowDetailsTemplateSelectorProperty;
    public static DependencyProperty CanUserResizeRowsProperty;
    public static DependencyProperty NewItemMarginProperty;
    public static DependencyProperty SelectionModeProperty;
    public static DependencyProperty SelectionUnitProperty;
    public static DependencyProperty CanUserSortColumnsProperty;
    public static DependencyProperty AutoGenerateColumnsProperty;
    public static DependencyProperty FrozenColumnCountProperty;
    public static DependencyProperty NonFrozenColumnsViewportHorizontalOffsetProperty;
    public static DependencyProperty EnableRowVirtualizationProperty;
    public static DependencyProperty EnableColumnVirtualizationProperty;
    public static DependencyProperty CanUserReorderColumnsProperty;
    public static DependencyProperty DragIndicatorStyleProperty;
    public static DependencyProperty DropLocationIndicatorStyleProperty;
    public static DependencyProperty ClipboardCopyModeProperty;
    internal static DependencyProperty CellsPanelActualWidthProperty;
    public static DependencyProperty CellsPanelHorizontalOffsetProperty;
    public ObservableCollection`1<DataGridColumn> Columns { get; }
    internal DataGridColumnCollection InternalColumns { get; }
    public bool CanUserResizeColumns { get; public set; }
    public DataGridLength ColumnWidth { get; public set; }
    public double MinColumnWidth { get; public set; }
    public double MaxColumnWidth { get; public set; }
    internal List`1<int> DisplayIndexMap { get; }
    internal DataGridColumnHeadersPresenter ColumnHeadersPresenter { get; internal set; }
    public DataGridGridLinesVisibility GridLinesVisibility { get; public set; }
    public Brush HorizontalGridLinesBrush { get; public set; }
    public Brush VerticalGridLinesBrush { get; public set; }
    internal double HorizontalGridLineThickness { get; }
    internal double VerticalGridLineThickness { get; }
    public Style RowStyle { get; public set; }
    public ControlTemplate RowValidationErrorTemplate { get; public set; }
    public ObservableCollection`1<ValidationRule> RowValidationRules { get; }
    public StyleSelector RowStyleSelector { get; public set; }
    public Brush RowBackground { get; public set; }
    public Brush AlternatingRowBackground { get; public set; }
    public double RowHeight { get; public set; }
    public double MinRowHeight { get; public set; }
    internal Visibility PlaceholderVisibility { get; }
    public double RowHeaderWidth { get; public set; }
    public double RowHeaderActualWidth { get; internal set; }
    public double ColumnHeaderHeight { get; public set; }
    public DataGridHeadersVisibility HeadersVisibility { get; public set; }
    internal DataGridItemAttachedStorage ItemAttachedStorage { get; }
    public Style CellStyle { get; public set; }
    public Style ColumnHeaderStyle { get; public set; }
    public Style RowHeaderStyle { get; public set; }
    public DataTemplate RowHeaderTemplate { get; public set; }
    public DataTemplateSelector RowHeaderTemplateSelector { get; public set; }
    public static ComponentResourceKey FocusBorderBrushKey { get; }
    public static IValueConverter HeadersVisibilityConverter { get; }
    public static IValueConverter RowDetailsScrollingConverter { get; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    protected internal bool HandlesScrolling { get; }
    internal Panel InternalItemsHost { get; internal set; }
    internal ScrollViewer InternalScrollHost { get; }
    internal ScrollContentPresenter InternalScrollContentPresenter { get; }
    internal double HorizontalScrollOffset { get; }
    public static RoutedUICommand DeleteCommand { get; }
    public bool IsReadOnly { get; public set; }
    public object CurrentItem { get; public set; }
    public DataGridColumn CurrentColumn { get; public set; }
    public DataGridCellInfo CurrentCell { get; public set; }
    internal DataGridCell CurrentCellContainer { get; internal set; }
    internal ItemInfo CurrentInfo { get; }
    internal DataGridCell FocusedCell { get; internal set; }
    public bool CanUserAddRows { get; public set; }
    public bool CanUserDeleteRows { get; public set; }
    public DataGridRowDetailsVisibilityMode RowDetailsVisibilityMode { get; public set; }
    public bool AreRowDetailsFrozen { get; public set; }
    public DataTemplate RowDetailsTemplate { get; public set; }
    public DataTemplateSelector RowDetailsTemplateSelector { get; public set; }
    public bool CanUserResizeRows { get; public set; }
    public Thickness NewItemMargin { get; private set; }
    internal SelectedItemCollection SelectedItemCollection { get; }
    public IList`1<DataGridCellInfo> SelectedCells { get; }
    internal SelectedCellsCollection SelectedCellsInternal { get; }
    public static RoutedUICommand SelectAllCommand { get; }
    public DataGridSelectionMode SelectionMode { get; public set; }
    public DataGridSelectionUnit SelectionUnit { get; public set; }
    public bool CanUserSortColumns { get; public set; }
    public bool AutoGenerateColumns { get; public set; }
    public int FrozenColumnCount { get; public set; }
    public double NonFrozenColumnsViewportHorizontalOffset { get; internal set; }
    public bool EnableRowVirtualization { get; public set; }
    public bool EnableColumnVirtualization { get; public set; }
    public bool CanUserReorderColumns { get; public set; }
    public Style DragIndicatorStyle { get; public set; }
    public Style DropLocationIndicatorStyle { get; public set; }
    public DataGridClipboardCopyMode ClipboardCopyMode { get; public set; }
    internal double CellsPanelActualWidth { get; internal set; }
    public double CellsPanelHorizontalOffset { get; private set; }
    internal static object NewItemPlaceholder { get; }
    private static DataGrid();
    public ObservableCollection`1<DataGridColumn> get_Columns();
    internal DataGridColumnCollection get_InternalColumns();
    public bool get_CanUserResizeColumns();
    public void set_CanUserResizeColumns(bool value);
    public DataGridLength get_ColumnWidth();
    public void set_ColumnWidth(DataGridLength value);
    public double get_MinColumnWidth();
    public void set_MinColumnWidth(double value);
    public double get_MaxColumnWidth();
    public void set_MaxColumnWidth(double value);
    internal void UpdateDataGridReference(IList list, bool clear);
    internal bool RetryBringColumnIntoView(bool retryRequested);
    public DataGridColumn ColumnFromDisplayIndex(int displayIndex);
    [CompilerGeneratedAttribute]
public void add_ColumnDisplayIndexChanged(EventHandler`1<DataGridColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnDisplayIndexChanged(EventHandler`1<DataGridColumnEventArgs> value);
    protected internal virtual void OnColumnDisplayIndexChanged(DataGridColumnEventArgs e);
    internal List`1<int> get_DisplayIndexMap();
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex);
    internal int ColumnIndexFromDisplayIndex(int displayIndex);
    internal DataGridColumnHeader ColumnHeaderFromDisplayIndex(int displayIndex);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction action, int oldDisplayIndex, DataGridColumn oldColumn, int newDisplayIndex);
    internal DataGridColumnHeadersPresenter get_ColumnHeadersPresenter();
    internal void set_ColumnHeadersPresenter(DataGridColumnHeadersPresenter value);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    public DataGridGridLinesVisibility get_GridLinesVisibility();
    public void set_GridLinesVisibility(DataGridGridLinesVisibility value);
    public Brush get_HorizontalGridLinesBrush();
    public void set_HorizontalGridLinesBrush(Brush value);
    public Brush get_VerticalGridLinesBrush();
    public void set_VerticalGridLinesBrush(Brush value);
    internal double get_HorizontalGridLineThickness();
    internal double get_VerticalGridLineThickness();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    public Style get_RowStyle();
    public void set_RowStyle(Style value);
    public ControlTemplate get_RowValidationErrorTemplate();
    public void set_RowValidationErrorTemplate(ControlTemplate value);
    public ObservableCollection`1<ValidationRule> get_RowValidationRules();
    public StyleSelector get_RowStyleSelector();
    public void set_RowStyleSelector(StyleSelector value);
    public Brush get_RowBackground();
    public void set_RowBackground(Brush value);
    public Brush get_AlternatingRowBackground();
    public void set_AlternatingRowBackground(Brush value);
    public double get_RowHeight();
    public void set_RowHeight(double value);
    public double get_MinRowHeight();
    public void set_MinRowHeight(double value);
    internal Visibility get_PlaceholderVisibility();
    [CompilerGeneratedAttribute]
public void add_LoadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LoadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_UnloadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnloadingRow(EventHandler`1<DataGridRowEventArgs> value);
    protected virtual void OnLoadingRow(DataGridRowEventArgs e);
    internal static object DelayedOnLoadingRowDetails(object arg);
    protected virtual void OnUnloadingRow(DataGridRowEventArgs e);
    public double get_RowHeaderWidth();
    public void set_RowHeaderWidth(double value);
    public double get_RowHeaderActualWidth();
    internal void set_RowHeaderActualWidth(double value);
    public double get_ColumnHeaderHeight();
    public void set_ColumnHeaderHeight(double value);
    public DataGridHeadersVisibility get_HeadersVisibility();
    public void set_HeadersVisibility(DataGridHeadersVisibility value);
    public void SetDetailsVisibilityForItem(object item, Visibility detailsVisibility);
    public Visibility GetDetailsVisibilityForItem(object item);
    public void ClearDetailsVisibilityForItem(object item);
    internal DataGridItemAttachedStorage get_ItemAttachedStorage();
    public Style get_CellStyle();
    public void set_CellStyle(Style value);
    public Style get_ColumnHeaderStyle();
    public void set_ColumnHeaderStyle(Style value);
    public Style get_RowHeaderStyle();
    public void set_RowHeaderStyle(Style value);
    public DataTemplate get_RowHeaderTemplate();
    public void set_RowHeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_RowHeaderTemplateSelector();
    public void set_RowHeaderTemplateSelector(DataTemplateSelector value);
    public static ComponentResourceKey get_FocusBorderBrushKey();
    public static IValueConverter get_HeadersVisibilityConverter();
    public static IValueConverter get_RowDetailsScrollingConverter();
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public void ScrollIntoView(object item);
    internal void ScrollIntoView(ItemInfo info);
    public void ScrollIntoView(object item, DataGridColumn column);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool get_HandlesScrolling();
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    internal ScrollViewer get_InternalScrollHost();
    internal ScrollContentPresenter get_InternalScrollContentPresenter();
    internal void OnViewportSizeChanged(Size oldSize, Size newSize);
    internal void OnHasVisibleStarColumnsChanged();
    internal double get_HorizontalScrollOffset();
    public static RoutedUICommand get_DeleteCommand();
    protected virtual void OnCanExecuteBeginEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedBeginEdit(ExecutedRoutedEventArgs e);
    protected virtual void OnCanExecuteCommitEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedCommitEdit(ExecutedRoutedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_RowEditEnding(EventHandler`1<DataGridRowEditEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RowEditEnding(EventHandler`1<DataGridRowEditEndingEventArgs> value);
    protected virtual void OnRowEditEnding(DataGridRowEditEndingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_CellEditEnding(EventHandler`1<DataGridCellEditEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CellEditEnding(EventHandler`1<DataGridCellEditEndingEventArgs> value);
    protected virtual void OnCellEditEnding(DataGridCellEditEndingEventArgs e);
    protected virtual void OnCanExecuteCancelEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e);
    protected virtual void OnCanExecuteDelete(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedDelete(ExecutedRoutedEventArgs e);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public object get_CurrentItem();
    public void set_CurrentItem(object value);
    public DataGridColumn get_CurrentColumn();
    public void set_CurrentColumn(DataGridColumn value);
    public DataGridCellInfo get_CurrentCell();
    public void set_CurrentCell(DataGridCellInfo value);
    [CompilerGeneratedAttribute]
public void add_CurrentCellChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentCellChanged(EventHandler`1<EventArgs> value);
    protected virtual void OnCurrentCellChanged(EventArgs e);
    internal DataGridCell get_CurrentCellContainer();
    internal void set_CurrentCellContainer(DataGridCell value);
    internal ItemInfo get_CurrentInfo();
    internal bool IsCurrent(DataGridRow row, DataGridColumn column);
    [CompilerGeneratedAttribute]
public void add_BeginningEdit(EventHandler`1<DataGridBeginningEditEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeginningEdit(EventHandler`1<DataGridBeginningEditEventArgs> value);
    protected virtual void OnBeginningEdit(DataGridBeginningEditEventArgs e);
    [CompilerGeneratedAttribute]
public void add_PreparingCellForEdit(EventHandler`1<DataGridPreparingCellForEditEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreparingCellForEdit(EventHandler`1<DataGridPreparingCellForEditEventArgs> value);
    protected internal virtual void OnPreparingCellForEdit(DataGridPreparingCellForEditEventArgs e);
    public bool BeginEdit();
    public bool BeginEdit(RoutedEventArgs editingEventArgs);
    public bool CancelEdit();
    internal bool CancelEdit(DataGridCell cell);
    public bool CancelEdit(DataGridEditingUnit editingUnit);
    public bool CommitEdit();
    public bool CommitEdit(DataGridEditingUnit editingUnit, bool exitEditingMode);
    internal DataGridCell get_FocusedCell();
    internal void set_FocusedCell(DataGridCell value);
    public bool get_CanUserAddRows();
    public void set_CanUserAddRows(bool value);
    public bool get_CanUserDeleteRows();
    public void set_CanUserDeleteRows(bool value);
    [CompilerGeneratedAttribute]
public void add_AddingNewItem(EventHandler`1<AddingNewItemEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AddingNewItem(EventHandler`1<AddingNewItemEventArgs> value);
    protected virtual void OnAddingNewItem(AddingNewItemEventArgs e);
    [CompilerGeneratedAttribute]
public void add_InitializingNewItem(InitializingNewItemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InitializingNewItem(InitializingNewItemEventHandler value);
    protected virtual void OnInitializingNewItem(InitializingNewItemEventArgs e);
    public DataGridRowDetailsVisibilityMode get_RowDetailsVisibilityMode();
    public void set_RowDetailsVisibilityMode(DataGridRowDetailsVisibilityMode value);
    public bool get_AreRowDetailsFrozen();
    public void set_AreRowDetailsFrozen(bool value);
    public DataTemplate get_RowDetailsTemplate();
    public void set_RowDetailsTemplate(DataTemplate value);
    public DataTemplateSelector get_RowDetailsTemplateSelector();
    public void set_RowDetailsTemplateSelector(DataTemplateSelector value);
    [CompilerGeneratedAttribute]
public void add_LoadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LoadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_UnloadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnloadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RowDetailsVisibilityChanged(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RowDetailsVisibilityChanged(EventHandler`1<DataGridRowDetailsEventArgs> value);
    internal void OnLoadingRowDetailsWrapper(DataGridRow row);
    internal void OnUnloadingRowDetailsWrapper(DataGridRow row);
    protected virtual void OnLoadingRowDetails(DataGridRowDetailsEventArgs e);
    protected virtual void OnUnloadingRowDetails(DataGridRowDetailsEventArgs e);
    protected internal virtual void OnRowDetailsVisibilityChanged(DataGridRowDetailsEventArgs e);
    public bool get_CanUserResizeRows();
    public void set_CanUserResizeRows(bool value);
    public Thickness get_NewItemMargin();
    private void set_NewItemMargin(Thickness value);
    internal virtual void OnIsGroupingChanged(DependencyPropertyChangedEventArgs e);
    internal SelectedItemCollection get_SelectedItemCollection();
    public IList`1<DataGridCellInfo> get_SelectedCells();
    internal SelectedCellsCollection get_SelectedCellsInternal();
    [CompilerGeneratedAttribute]
public void add_SelectedCellsChanged(SelectedCellsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectedCellsChanged(SelectedCellsChangedEventHandler value);
    internal void OnSelectedCellsChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
    protected virtual void OnSelectedCellsChanged(SelectedCellsChangedEventArgs e);
    public static RoutedUICommand get_SelectAllCommand();
    internal virtual void SelectAllImpl();
    internal void SelectOnlyThisCell(DataGridCellInfo currentCellInfo);
    public void SelectAllCells();
    public void UnselectAllCells();
    public DataGridSelectionMode get_SelectionMode();
    public void set_SelectionMode(DataGridSelectionMode value);
    public DataGridSelectionUnit get_SelectionUnit();
    public void set_SelectionUnit(DataGridSelectionUnit value);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    internal void CellIsSelectedChanged(DataGridCell cell, bool isSelected);
    internal void HandleSelectionForCellInput(DataGridCell cell, bool startDragging, bool allowsExtendSelect, bool allowsMinimalSelect);
    internal void HandleSelectionForRowHeaderAndDetailsInput(DataGridRow row, bool startDragging);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal string GetCellAutomationValue(object item, DataGridColumn column);
    internal object GetCellClipboardValue(object item, DataGridColumn column);
    internal void SetCellAutomationValue(object item, DataGridColumn column, string value);
    internal void SetCellClipboardValue(object item, DataGridColumn column, object value);
    internal DataGridCell TryFindCell(DataGridCellInfo info);
    internal DataGridCell TryFindCell(ItemInfo info, DataGridColumn column);
    internal DataGridCell TryFindCell(object item, DataGridColumn column);
    public bool get_CanUserSortColumns();
    public void set_CanUserSortColumns(bool value);
    [CompilerGeneratedAttribute]
public void add_Sorting(DataGridSortingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Sorting(DataGridSortingEventHandler value);
    protected virtual void OnSorting(DataGridSortingEventArgs eventArgs);
    internal void PerformSort(DataGridColumn sortColumn);
    [CompilerGeneratedAttribute]
public void add_AutoGeneratedColumns(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AutoGeneratedColumns(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_AutoGeneratingColumn(EventHandler`1<DataGridAutoGeneratingColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AutoGeneratingColumn(EventHandler`1<DataGridAutoGeneratingColumnEventArgs> value);
    public bool get_AutoGenerateColumns();
    public void set_AutoGenerateColumns(bool value);
    protected virtual void OnAutoGeneratedColumns(EventArgs e);
    protected virtual void OnAutoGeneratingColumn(DataGridAutoGeneratingColumnEventArgs e);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    public static Collection`1<DataGridColumn> GenerateColumns(IItemProperties itemProperties);
    public int get_FrozenColumnCount();
    public void set_FrozenColumnCount(int value);
    public double get_NonFrozenColumnsViewportHorizontalOffset();
    internal void set_NonFrozenColumnsViewportHorizontalOffset(double value);
    public virtual void OnApplyTemplate();
    public bool get_EnableRowVirtualization();
    public void set_EnableRowVirtualization(bool value);
    public bool get_EnableColumnVirtualization();
    public void set_EnableColumnVirtualization(bool value);
    public bool get_CanUserReorderColumns();
    public void set_CanUserReorderColumns(bool value);
    public Style get_DragIndicatorStyle();
    public void set_DragIndicatorStyle(Style value);
    public Style get_DropLocationIndicatorStyle();
    public void set_DropLocationIndicatorStyle(Style value);
    [CompilerGeneratedAttribute]
public void add_ColumnReordering(EventHandler`1<DataGridColumnReorderingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnReordering(EventHandler`1<DataGridColumnReorderingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragStarted(EventHandler`1<DragStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragStarted(EventHandler`1<DragStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragDelta(EventHandler`1<DragDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragDelta(EventHandler`1<DragDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragCompleted(EventHandler`1<DragCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragCompleted(EventHandler`1<DragCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnReordered(EventHandler`1<DataGridColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnReordered(EventHandler`1<DataGridColumnEventArgs> value);
    protected internal virtual void OnColumnHeaderDragStarted(DragStartedEventArgs e);
    protected internal virtual void OnColumnReordering(DataGridColumnReorderingEventArgs e);
    protected internal virtual void OnColumnHeaderDragDelta(DragDeltaEventArgs e);
    protected internal virtual void OnColumnHeaderDragCompleted(DragCompletedEventArgs e);
    protected internal virtual void OnColumnReordered(DataGridColumnEventArgs e);
    public DataGridClipboardCopyMode get_ClipboardCopyMode();
    public void set_ClipboardCopyMode(DataGridClipboardCopyMode value);
    protected virtual void OnCanExecuteCopy(CanExecuteRoutedEventArgs args);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnExecutedCopy(ExecutedRoutedEventArgs args);
    protected virtual void OnCopyingRowClipboardContent(DataGridRowClipboardEventArgs args);
    [CompilerGeneratedAttribute]
public void add_CopyingRowClipboardContent(EventHandler`1<DataGridRowClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CopyingRowClipboardContent(EventHandler`1<DataGridRowClipboardEventArgs> value);
    internal double get_CellsPanelActualWidth();
    internal void set_CellsPanelActualWidth(double value);
    public double get_CellsPanelHorizontalOffset();
    private void set_CellsPanelHorizontalOffset(double value);
    internal void QueueInvalidateCellsPanelHorizontalOffset();
    internal IProvideDataGridColumn GetAnyCellOrColumnHeader();
    internal double GetViewportWidthForColumns();
    internal virtual void ChangeVisualState(bool useTransitions);
    internal static object get_NewItemPlaceholder();
}
public class System.Windows.Controls.DataGridAutoGeneratingColumnEventArgs : EventArgs {
    public DataGridColumn Column { get; public set; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    public object PropertyDescriptor { get; private set; }
    public bool Cancel { get; public set; }
    public DataGridAutoGeneratingColumnEventArgs(string propertyName, Type propertyType, DataGridColumn column);
    internal DataGridAutoGeneratingColumnEventArgs(DataGridColumn column, ItemPropertyInfo itemPropertyInfo);
    internal DataGridAutoGeneratingColumnEventArgs(DataGridColumn column, string propertyName, Type propertyType, object propertyDescriptor);
    public DataGridColumn get_Column();
    public void set_Column(DataGridColumn value);
    public string get_PropertyName();
    public Type get_PropertyType();
    public object get_PropertyDescriptor();
    private void set_PropertyDescriptor(object value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.Windows.Controls.DataGridBeginningEditEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public RoutedEventArgs EditingEventArgs { get; }
    public DataGridBeginningEditEventArgs(DataGridColumn column, DataGridRow row, RoutedEventArgs editingEventArgs);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public RoutedEventArgs get_EditingEventArgs();
}
public abstract class System.Windows.Controls.DataGridBoundColumn : DataGridColumn {
    public static DependencyProperty ElementStyleProperty;
    public static DependencyProperty EditingElementStyleProperty;
    public BindingBase Binding { get; public set; }
    public Style ElementStyle { get; public set; }
    public Style EditingElementStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    private static DataGridBoundColumn();
    public virtual BindingBase get_Binding();
    public virtual void set_Binding(BindingBase value);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    protected virtual void OnBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    internal void ApplyBinding(DependencyObject target, DependencyProperty property);
    public Style get_ElementStyle();
    public void set_ElementStyle(Style value);
    public Style get_EditingElementStyle();
    public void set_EditingElementStyle(Style value);
    internal void ApplyStyle(bool isEditing, bool defaultToElementStyle, FrameworkElement element);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
}
public class System.Windows.Controls.DataGridCell : ContentControl {
    public static DependencyProperty ColumnProperty;
    public static DependencyProperty IsEditingProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    internal ContainerTracking`1<DataGridCell> Tracker { get; }
    public DataGridColumn Column { get; internal set; }
    public bool IsEditing { get; public set; }
    public bool IsReadOnly { get; }
    internal FrameworkElement EditingElement { get; }
    public bool IsSelected { get; public set; }
    internal DataGrid DataGridOwner { get; }
    internal DataGridRow RowOwner { get; }
    internal object RowDataItem { get; }
    private static DataGridCell();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void PrepareCell(object item, ItemsControl cellsPresenter, DataGridRow ownerRow);
    internal void PrepareCell(object item, DataGridRow ownerRow, int index);
    internal void ClearCell(DataGridRow ownerRow);
    internal ContainerTracking`1<DataGridCell> get_Tracker();
    public sealed virtual DataGridColumn get_Column();
    internal void set_Column(DataGridColumn value);
    protected virtual void OnColumnChanged(DataGridColumn oldColumn, DataGridColumn newColumn);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void BuildVisualTree();
    public bool get_IsEditing();
    public void set_IsEditing(bool value);
    protected virtual void OnIsEditingChanged(bool isEditing);
    internal void NotifyCurrentCellContainerChanged();
    public bool get_IsReadOnly();
    internal void BeginEdit(RoutedEventArgs e);
    internal void CancelEdit();
    internal bool CommitEdit();
    internal FrameworkElement get_EditingElement();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    internal void SyncIsSelected(bool isSelected);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal DataGrid get_DataGridOwner();
    internal DataGridRow get_RowOwner();
    internal object get_RowDataItem();
}
public class System.Windows.Controls.DataGridCellClipboardEventArgs : EventArgs {
    public object Content { get; public set; }
    public object Item { get; }
    public DataGridColumn Column { get; }
    public DataGridCellClipboardEventArgs(object item, DataGridColumn column, object content);
    public object get_Content();
    public void set_Content(object value);
    public object get_Item();
    public DataGridColumn get_Column();
}
public class System.Windows.Controls.DataGridCellEditEndingEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public FrameworkElement EditingElement { get; }
    public DataGridEditAction EditAction { get; }
    public DataGridCellEditEndingEventArgs(DataGridColumn column, DataGridRow row, FrameworkElement editingElement, DataGridEditAction editAction);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public FrameworkElement get_EditingElement();
    public DataGridEditAction get_EditAction();
}
public class System.Windows.Controls.DataGridCellInfo : ValueType {
    private ItemInfo _info;
    private DataGridColumn _column;
    private WeakReference _owner;
    public object Item { get; }
    public DataGridColumn Column { get; }
    public bool IsValid { get; }
    internal bool IsSet { get; }
    internal ItemInfo ItemInfo { get; }
    internal static DataGridCellInfo Unset { get; }
    public DataGridCellInfo(object item, DataGridColumn column);
    public DataGridCellInfo(DataGridCell cell);
    internal DataGridCellInfo(object item, DataGridColumn column, DataGrid owner);
    internal DataGridCellInfo(ItemInfo info, DataGridColumn column, DataGrid owner);
    internal DataGridCellInfo(object item);
    internal DataGridCellInfo(DataGridCellInfo info);
    internal static DataGridCellInfo CreatePossiblyPartialCellInfo(object item, DataGridColumn column, DataGrid owner);
    public object get_Item();
    public DataGridColumn get_Column();
    public virtual bool Equals(object obj);
    public static bool op_Equality(DataGridCellInfo cell1, DataGridCellInfo cell2);
    public static bool op_Inequality(DataGridCellInfo cell1, DataGridCellInfo cell2);
    internal bool EqualsImpl(DataGridCellInfo cell);
    public virtual int GetHashCode();
    public bool get_IsValid();
    internal bool get_IsSet();
    internal ItemInfo get_ItemInfo();
    internal bool IsValidForDataGrid(DataGrid dataGrid);
    internal static DataGridCellInfo get_Unset();
}
public class System.Windows.Controls.DataGridCellsPanel : VirtualizingPanel {
    internal bool HasCorrectRealizedColumns { get; }
    private static DataGridCellsPanel();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal bool get_HasCorrectRealizedColumns();
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    internal double ComputeCellsPanelHorizontalOffset();
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    protected virtual void OnClearChildren();
    internal void InternalBringIndexIntoView(int index);
    protected internal virtual void BringIndexIntoView(int index);
    internal Geometry GetFrozenClipForChild(UIElement child);
}
public class System.Windows.Controls.DataGridCheckBoxColumn : DataGridBoundColumn {
    public static DependencyProperty IsThreeStateProperty;
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public bool IsThreeState { get; public set; }
    private static DataGridCheckBoxColumn();
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    public bool get_IsThreeState();
    public void set_IsThreeState(bool value);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    internal virtual void OnInput(InputEventArgs e);
}
public class System.Windows.Controls.DataGridClipboardCellContent : ValueType {
    private object _item;
    private DataGridColumn _column;
    private object _content;
    public object Item { get; }
    public DataGridColumn Column { get; }
    public object Content { get; }
    public DataGridClipboardCellContent(object item, DataGridColumn column, object content);
    public object get_Item();
    public DataGridColumn get_Column();
    public object get_Content();
    public virtual bool Equals(object data);
    public virtual int GetHashCode();
    public static bool op_Equality(DataGridClipboardCellContent clipboardCellContent1, DataGridClipboardCellContent clipboardCellContent2);
    public static bool op_Inequality(DataGridClipboardCellContent clipboardCellContent1, DataGridClipboardCellContent clipboardCellContent2);
}
public enum System.Windows.Controls.DataGridClipboardCopyMode : Enum {
    public int value__;
    public static DataGridClipboardCopyMode None;
    public static DataGridClipboardCopyMode ExcludeHeader;
    public static DataGridClipboardCopyMode IncludeHeader;
}
internal static class System.Windows.Controls.DataGridClipboardHelper : object {
    internal static void FormatCell(object cellValue, bool firstCell, bool lastCell, StringBuilder sb, string format);
    internal static void GetClipboardContentForHtml(StringBuilder content);
}
public abstract class System.Windows.Controls.DataGridColumn : DependencyObject {
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderStyleProperty;
    public static DependencyProperty HeaderStringFormatProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty CellStyleProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty WidthProperty;
    public static DependencyProperty MinWidthProperty;
    public static DependencyProperty MaxWidthProperty;
    public static DependencyProperty ActualWidthProperty;
    public static DependencyProperty DisplayIndexProperty;
    public static DependencyProperty SortMemberPathProperty;
    public static DependencyProperty CanUserSortProperty;
    public static DependencyProperty SortDirectionProperty;
    public static DependencyProperty IsAutoGeneratedProperty;
    public static DependencyProperty IsFrozenProperty;
    public static DependencyProperty CanUserReorderProperty;
    public static DependencyProperty DragIndicatorStyleProperty;
    public static DependencyProperty CanUserResizeProperty;
    public static DependencyProperty VisibilityProperty;
    public object Header { get; public set; }
    public Style HeaderStyle { get; public set; }
    public string HeaderStringFormat { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public Style CellStyle { get; public set; }
    public bool IsReadOnly { get; public set; }
    public DataGridLength Width { get; public set; }
    public double MinWidth { get; public set; }
    public double MaxWidth { get; public set; }
    public double ActualWidth { get; private set; }
    protected internal DataGrid DataGridOwner { get; internal set; }
    public int DisplayIndex { get; public set; }
    public string SortMemberPath { get; public set; }
    public bool CanUserSort { get; public set; }
    public Nullable`1<ListSortDirection> SortDirection { get; public set; }
    public bool IsAutoGenerated { get; internal set; }
    public bool IsFrozen { get; internal set; }
    public bool CanUserReorder { get; public set; }
    public Style DragIndicatorStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    public bool CanUserResize { get; public set; }
    public Visibility Visibility { get; public set; }
    internal bool IsVisible { get; }
    private static DataGridColumn();
    public object get_Header();
    public void set_Header(object value);
    public Style get_HeaderStyle();
    public void set_HeaderStyle(Style value);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public Style get_CellStyle();
    public void set_CellStyle(Style value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    public DataGridLength get_Width();
    public void set_Width(DataGridLength value);
    internal void SetWidthInternal(DataGridLength width);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public double get_ActualWidth();
    private void set_ActualWidth(double value);
    internal double GetConstraintWidth(bool isHeader);
    internal void UpdateDesiredWidthForAutoColumn(bool isHeader, double pixelWidth);
    internal void UpdateWidthForStarColumn(double displayWidth, double desiredWidth, double starValue);
    public FrameworkElement GetCellContent(object dataItem);
    public FrameworkElement GetCellContent(DataGridRow dataGridRow);
    internal FrameworkElement BuildVisualTree(bool isEditing, object dataItem, DataGridCell cell);
    protected abstract virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected abstract virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal void BeginEdit(FrameworkElement editingElement, RoutedEventArgs e);
    internal void CancelEdit(FrameworkElement editingElement);
    internal bool CommitEdit(FrameworkElement editingElement);
    internal static void OnNotifyCellPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    protected void NotifyPropertyChanged(string propertyName);
    internal static void NotifyPropertyChangeForRefreshContent(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    internal void SyncProperties();
    protected internal DataGrid get_DataGridOwner();
    internal void set_DataGridOwner(DataGrid value);
    public int get_DisplayIndex();
    public void set_DisplayIndex(int value);
    public string get_SortMemberPath();
    public void set_SortMemberPath(string value);
    public bool get_CanUserSort();
    public void set_CanUserSort(bool value);
    internal static object OnCoerceCanUserSort(DependencyObject d, object baseValue);
    public Nullable`1<ListSortDirection> get_SortDirection();
    public void set_SortDirection(Nullable`1<ListSortDirection> value);
    public bool get_IsAutoGenerated();
    internal void set_IsAutoGenerated(bool value);
    internal static DataGridColumn CreateDefaultColumn(ItemPropertyInfo itemProperty);
    public bool get_IsFrozen();
    internal void set_IsFrozen(bool value);
    public bool get_CanUserReorder();
    public void set_CanUserReorder(bool value);
    public Style get_DragIndicatorStyle();
    public void set_DragIndicatorStyle(Style value);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    public virtual object OnCopyingCellClipboardContent(object item);
    public virtual void OnPastingCellClipboardContent(object item, object cellContent);
    [CompilerGeneratedAttribute]
public void add_CopyingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CopyingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PastingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PastingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    internal virtual void OnInput(InputEventArgs e);
    internal void BeginEdit(InputEventArgs e, bool handled);
    public bool get_CanUserResize();
    public void set_CanUserResize(bool value);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    internal bool get_IsVisible();
}
internal class System.Windows.Controls.DataGridColumnCollection : ObservableCollection`1<DataGridColumn> {
    internal List`1<int> DisplayIndexMap { get; private set; }
    internal bool DisplayIndexMapInitialized { get; }
    internal bool HasVisibleStarColumns { get; private set; }
    internal double AverageColumnWidth { get; }
    internal bool ColumnWidthsComputationPending { get; }
    internal bool RebuildRealizedColumnsBlockListForNonVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsBlockListForNonVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows { get; internal set; }
    internal bool RebuildRealizedColumnsBlockListForVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsBlockListForVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsDisplayIndexBlockListForVirtualizedRows { get; internal set; }
    internal int FirstVisibleDisplayIndex { get; }
    internal int LastVisibleDisplayIndex { get; }
    internal bool RefreshAutoWidthColumns { get; internal set; }
    internal DataGridColumnCollection(DataGrid dataGridOwner);
    protected virtual void InsertItem(int index, DataGridColumn item);
    protected virtual void SetItem(int index, DataGridColumn item);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void ClearItems();
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal DataGridColumn ColumnFromDisplayIndex(int displayIndex);
    internal List`1<int> get_DisplayIndexMap();
    private void set_DisplayIndexMap(List`1<int> value);
    internal void InitializeDisplayIndexMap();
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex);
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex, bool isAdding);
    internal bool get_DisplayIndexMapInitialized();
    internal bool get_HasVisibleStarColumns();
    private void set_HasVisibleStarColumns(bool value);
    internal void InvalidateHasVisibleStarColumns();
    internal void InvalidateAverageColumnWidth();
    internal double get_AverageColumnWidth();
    internal bool get_ColumnWidthsComputationPending();
    internal void InvalidateColumnWidthsComputation();
    internal void RedistributeColumnWidthsOnMinWidthChangeOfColumn(DataGridColumn changedColumn, double oldMinWidth);
    internal void RedistributeColumnWidthsOnMaxWidthChangeOfColumn(DataGridColumn changedColumn, double oldMaxWidth);
    internal void RedistributeColumnWidthsOnWidthChangeOfColumn(DataGridColumn changedColumn, DataGridLength oldWidth);
    internal void RedistributeColumnWidthsOnAvailableSpaceChange(double availableSpaceChange, double newTotalAvailableSpace);
    internal void OnColumnResizeStarted();
    internal void OnColumnResizeCompleted(bool cancel);
    internal void RecomputeColumnWidthsOnColumnResize(DataGridColumn resizingColumn, double horizontalChange, bool retainAuto);
    [CompilerGeneratedAttribute]
internal bool get_RebuildRealizedColumnsBlockListForNonVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RebuildRealizedColumnsBlockListForNonVirtualizedRows(bool value);
    internal List`1<RealizedColumnsBlock> get_RealizedColumnsBlockListForNonVirtualizedRows();
    internal void set_RealizedColumnsBlockListForNonVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal List`1<RealizedColumnsBlock> get_RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal bool get_RebuildRealizedColumnsBlockListForVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RebuildRealizedColumnsBlockListForVirtualizedRows(bool value);
    internal List`1<RealizedColumnsBlock> get_RealizedColumnsBlockListForVirtualizedRows();
    internal void set_RealizedColumnsBlockListForVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal List`1<RealizedColumnsBlock> get_RealizedColumnsDisplayIndexBlockListForVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RealizedColumnsDisplayIndexBlockListForVirtualizedRows(List`1<RealizedColumnsBlock> value);
    internal void InvalidateColumnRealization(bool invalidateForNonVirtualizedRows);
    internal int get_FirstVisibleDisplayIndex();
    internal int get_LastVisibleDisplayIndex();
    [CompilerGeneratedAttribute]
internal bool get_RefreshAutoWidthColumns();
    [CompilerGeneratedAttribute]
internal void set_RefreshAutoWidthColumns(bool value);
}
internal class System.Windows.Controls.DataGridColumnDropSeparator : Separator {
    internal DataGridColumnHeader ReferenceHeader { get; internal set; }
    private static DataGridColumnDropSeparator();
    internal DataGridColumnHeader get_ReferenceHeader();
    internal void set_ReferenceHeader(DataGridColumnHeader value);
}
public class System.Windows.Controls.DataGridColumnEventArgs : EventArgs {
    public DataGridColumn Column { get; }
    public DataGridColumnEventArgs(DataGridColumn column);
    public DataGridColumn get_Column();
}
[TemplatePartAttribute]
internal class System.Windows.Controls.DataGridColumnFloatingHeader : Control {
    internal DataGridColumnHeader ReferenceHeader { get; internal set; }
    private static DataGridColumnFloatingHeader();
    public virtual void OnApplyTemplate();
    internal DataGridColumnHeader get_ReferenceHeader();
    internal void set_ReferenceHeader(DataGridColumnHeader value);
    internal void ClearHeader();
}
internal class System.Windows.Controls.DataGridColumnHeaderCollection : object {
    public DataGridColumnHeaderCollection(ObservableCollection`1<DataGridColumn> columns);
    public DataGridColumn ColumnFromIndex(int index);
    internal void NotifyHeaderPropertyChanged(DataGridColumn column, DependencyPropertyChangedEventArgs e);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
public class System.Windows.Controls.DataGridColumnReorderingEventArgs : DataGridColumnEventArgs {
    public bool Cancel { get; public set; }
    public Control DropLocationIndicator { get; public set; }
    public Control DragIndicator { get; public set; }
    public DataGridColumnReorderingEventArgs(DataGridColumn dataGridColumn);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Control get_DropLocationIndicator();
    public void set_DropLocationIndicator(Control value);
    public Control get_DragIndicator();
    public void set_DragIndicator(Control value);
}
public class System.Windows.Controls.DataGridComboBoxColumn : DataGridColumn {
    public static DependencyProperty ElementStyleProperty;
    public static DependencyProperty EditingElementStyleProperty;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty DisplayMemberPathProperty;
    public static DependencyProperty SelectedValuePathProperty;
    public static ComponentResourceKey TextBlockComboBoxStyleKey { get; }
    public BindingBase SelectedValueBinding { get; public set; }
    public BindingBase SelectedItemBinding { get; public set; }
    public BindingBase TextBinding { get; public set; }
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public Style ElementStyle { get; public set; }
    public Style EditingElementStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    public IEnumerable ItemsSource { get; public set; }
    public string DisplayMemberPath { get; public set; }
    public string SelectedValuePath { get; public set; }
    private static DataGridComboBoxColumn();
    public static ComponentResourceKey get_TextBlockComboBoxStyleKey();
    public virtual BindingBase get_SelectedValueBinding();
    public virtual void set_SelectedValueBinding(BindingBase value);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    public virtual BindingBase get_SelectedItemBinding();
    public virtual void set_SelectedItemBinding(BindingBase value);
    public virtual BindingBase get_TextBinding();
    public virtual void set_TextBinding(BindingBase value);
    protected virtual void OnSelectedValueBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    protected virtual void OnSelectedItemBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    protected virtual void OnTextBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    public Style get_ElementStyle();
    public void set_ElementStyle(Style value);
    public Style get_EditingElementStyle();
    public void set_EditingElementStyle(Style value);
    internal void ApplyStyle(bool isEditing, bool defaultToElementStyle, FrameworkContentElement element);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public string get_DisplayMemberPath();
    public void set_DisplayMemberPath(string value);
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal virtual void OnInput(InputEventArgs e);
}
public enum System.Windows.Controls.DataGridEditAction : Enum {
    public int value__;
    public static DataGridEditAction Cancel;
    public static DataGridEditAction Commit;
}
public enum System.Windows.Controls.DataGridEditingUnit : Enum {
    public int value__;
    public static DataGridEditingUnit Cell;
    public static DataGridEditingUnit Row;
}
public enum System.Windows.Controls.DataGridGridLinesVisibility : Enum {
    public int value__;
    public static DataGridGridLinesVisibility All;
    public static DataGridGridLinesVisibility Horizontal;
    public static DataGridGridLinesVisibility None;
    public static DataGridGridLinesVisibility Vertical;
}
[FlagsAttribute]
public enum System.Windows.Controls.DataGridHeadersVisibility : Enum {
    public int value__;
    public static DataGridHeadersVisibility All;
    public static DataGridHeadersVisibility Column;
    public static DataGridHeadersVisibility Row;
    public static DataGridHeadersVisibility None;
}
[LocalizabilityAttribute("17")]
internal class System.Windows.Controls.DataGridHeadersVisibilityToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
internal static class System.Windows.Controls.DataGridHelper : object {
    private static DataGridHelper();
    public static Size SubtractFromSize(Size size, double thickness, bool height);
    public static bool IsGridLineVisible(DataGrid dataGrid, bool isHorizontal);
    public static bool ShouldNotifyCells(DataGridNotificationTarget target);
    public static bool ShouldNotifyCellsPresenter(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumns(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnHeaders(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnHeadersPresenter(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnCollection(DataGridNotificationTarget target);
    public static bool ShouldNotifyDataGrid(DataGridNotificationTarget target);
    public static bool ShouldNotifyDetailsPresenter(DataGridNotificationTarget target);
    public static bool ShouldRefreshCellContent(DataGridNotificationTarget target);
    public static bool ShouldNotifyRowHeaders(DataGridNotificationTarget target);
    public static bool ShouldNotifyRows(DataGridNotificationTarget target);
    public static bool ShouldNotifyRowSubtree(DataGridNotificationTarget target);
    public static T FindParent(FrameworkElement element);
    public static T FindVisualParent(UIElement element);
    public static bool TreeHasFocusAndTabStop(DependencyObject element);
    public static void OnColumnWidthChanged(IProvideDataGridColumn cell, DependencyPropertyChangedEventArgs e);
    public static Geometry GetFrozenClipForCell(IProvideDataGridColumn cell);
    public static DataGridCellsPanel GetParentPanelForCell(IProvideDataGridColumn cell);
    public static double GetParentCellsPanelHorizontalOffset(IProvideDataGridColumn cell);
    public static bool IsDefaultValue(DependencyObject d, DependencyProperty dp);
    public static object GetCoercedTransferPropertyValue(DependencyObject baseObject, object baseValue, DependencyProperty baseProperty, DependencyObject parentObject, DependencyProperty parentProperty);
    public static object GetCoercedTransferPropertyValue(DependencyObject baseObject, object baseValue, DependencyProperty baseProperty, DependencyObject parentObject, DependencyProperty parentProperty, DependencyObject grandParentObject, DependencyProperty grandParentProperty);
    public static void TransferProperty(DependencyObject d, DependencyProperty p);
    internal static bool IsPropertyTransferEnabled(DependencyObject d, DependencyProperty p);
    internal static bool IsOneWay(BindingBase bindingBase);
    internal static BindingExpression GetBindingExpression(FrameworkElement element, DependencyProperty dp);
    internal static bool ValidateWithoutUpdate(FrameworkElement element);
    internal static bool BindingExpressionBelongsToElement(BindingExpressionBase beb, T element);
    internal static void CacheFlowDirection(FrameworkElement element, DataGridCell cell);
    internal static void RestoreFlowDirection(FrameworkElement element, DataGridCell cell);
    internal static void UpdateTarget(FrameworkElement element);
    internal static void SyncColumnProperty(DependencyObject column, DependencyObject content, DependencyProperty contentProperty, DependencyProperty columnProperty);
    internal static string GetPathFromBinding(Binding binding);
    public static bool AreRowHeadersVisible(DataGridHeadersVisibility headersVisibility);
    public static double CoerceToMinMax(double value, double minValue, double maxValue);
    public static bool HasNonEscapeCharacters(TextCompositionEventArgs textArgs);
    public static bool IsImeProcessed(KeyEventArgs keyArgs);
}
public class System.Windows.Controls.DataGridHyperlinkColumn : DataGridBoundColumn {
    public static DependencyProperty TargetNameProperty;
    public string TargetName { get; public set; }
    public BindingBase ContentBinding { get; public set; }
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    private static DataGridHyperlinkColumn();
    public string get_TargetName();
    public void set_TargetName(string value);
    public BindingBase get_ContentBinding();
    public void set_ContentBinding(BindingBase value);
    protected virtual void OnContentBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal virtual void OnInput(InputEventArgs e);
}
internal class System.Windows.Controls.DataGridItemAttachedStorage : object {
    public void SetValue(object item, DependencyProperty property, object value);
    public bool TryGetValue(object item, DependencyProperty property, Object& value);
    public void ClearValue(object item, DependencyProperty property);
    public void ClearItem(object item);
    public void Clear();
}
[TypeConverterAttribute("System.Windows.Controls.DataGridLengthConverter")]
public class System.Windows.Controls.DataGridLength : ValueType {
    private double _unitValue;
    private DataGridLengthUnitType _unitType;
    private double _desiredValue;
    private double _displayValue;
    private static double AutoValue;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsStar { get; }
    public bool IsSizeToCells { get; }
    public bool IsSizeToHeader { get; }
    public double Value { get; }
    public DataGridLengthUnitType UnitType { get; }
    public double DesiredValue { get; }
    public double DisplayValue { get; }
    public static DataGridLength Auto { get; }
    public static DataGridLength SizeToCells { get; }
    public static DataGridLength SizeToHeader { get; }
    public DataGridLength(double pixels);
    public DataGridLength(double value, DataGridLengthUnitType type);
    public DataGridLength(double value, DataGridLengthUnitType type, double desiredValue, double displayValue);
    private static DataGridLength();
    public static bool op_Equality(DataGridLength gl1, DataGridLength gl2);
    public static bool op_Inequality(DataGridLength gl1, DataGridLength gl2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DataGridLength other);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsStar();
    public bool get_IsSizeToCells();
    public bool get_IsSizeToHeader();
    public double get_Value();
    public DataGridLengthUnitType get_UnitType();
    public double get_DesiredValue();
    public double get_DisplayValue();
    public virtual string ToString();
    public static DataGridLength get_Auto();
    public static DataGridLength get_SizeToCells();
    public static DataGridLength get_SizeToHeader();
    public static DataGridLength op_Implicit(double value);
}
public class System.Windows.Controls.DataGridLengthConverter : TypeConverter {
    private static DataGridLengthConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static string ConvertToString(DataGridLength length, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.DataGridLengthUnitType : Enum {
    public int value__;
    public static DataGridLengthUnitType Auto;
    public static DataGridLengthUnitType Pixel;
    public static DataGridLengthUnitType SizeToCells;
    public static DataGridLengthUnitType SizeToHeader;
    public static DataGridLengthUnitType Star;
}
[FlagsAttribute]
internal enum System.Windows.Controls.DataGridNotificationTarget : Enum {
    public int value__;
    public static DataGridNotificationTarget None;
    public static DataGridNotificationTarget Cells;
    public static DataGridNotificationTarget CellsPresenter;
    public static DataGridNotificationTarget Columns;
    public static DataGridNotificationTarget ColumnCollection;
    public static DataGridNotificationTarget ColumnHeaders;
    public static DataGridNotificationTarget ColumnHeadersPresenter;
    public static DataGridNotificationTarget DataGrid;
    public static DataGridNotificationTarget DetailsPresenter;
    public static DataGridNotificationTarget RefreshCellContent;
    public static DataGridNotificationTarget RowHeaders;
    public static DataGridNotificationTarget Rows;
    public static DataGridNotificationTarget All;
}
public class System.Windows.Controls.DataGridPreparingCellForEditEventArgs : EventArgs {
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public RoutedEventArgs EditingEventArgs { get; }
    public FrameworkElement EditingElement { get; }
    public DataGridPreparingCellForEditEventArgs(DataGridColumn column, DataGridRow row, RoutedEventArgs editingEventArgs, FrameworkElement editingElement);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public RoutedEventArgs get_EditingEventArgs();
    public FrameworkElement get_EditingElement();
}
public class System.Windows.Controls.DataGridRow : Control {
    public static DependencyProperty ItemProperty;
    public static DependencyProperty ItemsPanelProperty;
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderStyleProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty ValidationErrorTemplateProperty;
    public static DependencyProperty DetailsTemplateProperty;
    public static DependencyProperty DetailsTemplateSelectorProperty;
    public static DependencyProperty DetailsVisibilityProperty;
    public static DependencyProperty AlternationIndexProperty;
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    public static DependencyProperty IsEditingProperty;
    internal static DependencyPropertyKey IsNewItemPropertyKey;
    public static DependencyProperty IsNewItemProperty;
    internal bool _detailsLoaded;
    public object Item { get; public set; }
    public ItemsPanelTemplate ItemsPanel { get; public set; }
    public object Header { get; public set; }
    public Style HeaderStyle { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public ControlTemplate ValidationErrorTemplate { get; public set; }
    public DataTemplate DetailsTemplate { get; public set; }
    public DataTemplateSelector DetailsTemplateSelector { get; public set; }
    public Visibility DetailsVisibility { get; public set; }
    internal bool DetailsLoaded { get; internal set; }
    internal ContainerTracking`1<DataGridRow> Tracker { get; }
    internal DataGridCellsPresenter CellsPresenter { get; internal set; }
    internal DataGridDetailsPresenter DetailsPresenter { get; internal set; }
    internal DataGridRowHeader RowHeader { get; internal set; }
    public int AlternationIndex { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    public bool IsEditing { get; internal set; }
    public bool IsNewItem { get; internal set; }
    internal DataGrid DataGridOwner { get; }
    internal bool DetailsPresenterDrawsGridLines { get; }
    private static DataGridRow();
    public object get_Item();
    public void set_Item(object value);
    protected virtual void OnItemChanged(object oldItem, object newItem);
    public ItemsPanelTemplate get_ItemsPanel();
    public void set_ItemsPanel(ItemsPanelTemplate value);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    internal virtual void ChangeVisualState(bool useTransitions);
    public object get_Header();
    public void set_Header(object value);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public Style get_HeaderStyle();
    public void set_HeaderStyle(Style value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public ControlTemplate get_ValidationErrorTemplate();
    public void set_ValidationErrorTemplate(ControlTemplate value);
    public DataTemplate get_DetailsTemplate();
    public void set_DetailsTemplate(DataTemplate value);
    public DataTemplateSelector get_DetailsTemplateSelector();
    public void set_DetailsTemplateSelector(DataTemplateSelector value);
    public Visibility get_DetailsVisibility();
    public void set_DetailsVisibility(Visibility value);
    internal bool get_DetailsLoaded();
    internal void set_DetailsLoaded(bool value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal void PrepareRow(object item, DataGrid owningDataGrid);
    internal void ClearRow(DataGrid owningDataGrid);
    internal ContainerTracking`1<DataGridRow> get_Tracker();
    internal void OnRowResizeStarted();
    internal void OnRowResize(double changeAmount);
    internal void OnRowResizeCompleted(bool canceled);
    internal void OnRowResizeReset();
    protected internal virtual void OnColumnsChanged(ObservableCollection`1<DataGridColumn> columns, NotifyCollectionChangedEventArgs e);
    internal DataGridCellsPresenter get_CellsPresenter();
    internal void set_CellsPresenter(DataGridCellsPresenter value);
    internal DataGridDetailsPresenter get_DetailsPresenter();
    internal void set_DetailsPresenter(DataGridDetailsPresenter value);
    internal DataGridRowHeader get_RowHeader();
    internal void set_RowHeader(DataGridRowHeader value);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    public int get_AlternationIndex();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    public bool get_IsEditing();
    internal void set_IsEditing(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void ScrollCellIntoView(int index);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    public bool get_IsNewItem();
    internal void set_IsNewItem(bool value);
    public int GetIndex();
    public static DataGridRow GetRowContainingElement(FrameworkElement element);
    internal DataGrid get_DataGridOwner();
    internal bool get_DetailsPresenterDrawsGridLines();
    internal DataGridCell TryGetCell(int index);
}
public class System.Windows.Controls.DataGridRowClipboardEventArgs : EventArgs {
    public object Item { get; }
    public List`1<DataGridClipboardCellContent> ClipboardRowContent { get; }
    public int StartColumnDisplayIndex { get; }
    public int EndColumnDisplayIndex { get; }
    public bool IsColumnHeadersRow { get; }
    internal int RowIndexHint { get; }
    public DataGridRowClipboardEventArgs(object item, int startColumnDisplayIndex, int endColumnDisplayIndex, bool isColumnHeadersRow);
    internal DataGridRowClipboardEventArgs(object item, int startColumnDisplayIndex, int endColumnDisplayIndex, bool isColumnHeadersRow, int rowIndexHint);
    public object get_Item();
    public List`1<DataGridClipboardCellContent> get_ClipboardRowContent();
    public string FormatClipboardCellValues(string format);
    public int get_StartColumnDisplayIndex();
    public int get_EndColumnDisplayIndex();
    public bool get_IsColumnHeadersRow();
    internal int get_RowIndexHint();
}
public class System.Windows.Controls.DataGridRowDetailsEventArgs : EventArgs {
    public FrameworkElement DetailsElement { get; private set; }
    public DataGridRow Row { get; private set; }
    public DataGridRowDetailsEventArgs(DataGridRow row, FrameworkElement detailsElement);
    [CompilerGeneratedAttribute]
public FrameworkElement get_DetailsElement();
    [CompilerGeneratedAttribute]
private void set_DetailsElement(FrameworkElement value);
    [CompilerGeneratedAttribute]
public DataGridRow get_Row();
    [CompilerGeneratedAttribute]
private void set_Row(DataGridRow value);
}
public enum System.Windows.Controls.DataGridRowDetailsVisibilityMode : Enum {
    public int value__;
    public static DataGridRowDetailsVisibilityMode Collapsed;
    public static DataGridRowDetailsVisibilityMode Visible;
    public static DataGridRowDetailsVisibilityMode VisibleWhenSelected;
}
public class System.Windows.Controls.DataGridRowEditEndingEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public DataGridRow Row { get; }
    public DataGridEditAction EditAction { get; }
    public DataGridRowEditEndingEventArgs(DataGridRow row, DataGridEditAction editAction);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridRow get_Row();
    public DataGridEditAction get_EditAction();
}
public class System.Windows.Controls.DataGridRowEventArgs : EventArgs {
    public DataGridRow Row { get; private set; }
    public DataGridRowEventArgs(DataGridRow row);
    [CompilerGeneratedAttribute]
public DataGridRow get_Row();
    [CompilerGeneratedAttribute]
private void set_Row(DataGridRow value);
}
public enum System.Windows.Controls.DataGridSelectionMode : Enum {
    public int value__;
    public static DataGridSelectionMode Single;
    public static DataGridSelectionMode Extended;
}
public enum System.Windows.Controls.DataGridSelectionUnit : Enum {
    public int value__;
    public static DataGridSelectionUnit Cell;
    public static DataGridSelectionUnit FullRow;
    public static DataGridSelectionUnit CellOrRowHeader;
}
public class System.Windows.Controls.DataGridSortingEventArgs : DataGridColumnEventArgs {
    public bool Handled { get; public set; }
    public DataGridSortingEventArgs(DataGridColumn column);
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Controls.DataGridSortingEventHandler : MulticastDelegate {
    public DataGridSortingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataGridSortingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataGridSortingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.DataGridTemplateColumn : DataGridColumn {
    public static DependencyProperty CellTemplateProperty;
    public static DependencyProperty CellTemplateSelectorProperty;
    public static DependencyProperty CellEditingTemplateProperty;
    public static DependencyProperty CellEditingTemplateSelectorProperty;
    public DataTemplate CellTemplate { get; public set; }
    public DataTemplateSelector CellTemplateSelector { get; public set; }
    public DataTemplate CellEditingTemplate { get; public set; }
    public DataTemplateSelector CellEditingTemplateSelector { get; public set; }
    private static DataGridTemplateColumn();
    public DataTemplate get_CellTemplate();
    public void set_CellTemplate(DataTemplate value);
    public DataTemplateSelector get_CellTemplateSelector();
    public void set_CellTemplateSelector(DataTemplateSelector value);
    public DataTemplate get_CellEditingTemplate();
    public void set_CellEditingTemplate(DataTemplate value);
    public DataTemplateSelector get_CellEditingTemplateSelector();
    public void set_CellEditingTemplateSelector(DataTemplateSelector value);
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
}
public class System.Windows.Controls.DataGridTextColumn : DataGridBoundColumn {
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty ForegroundProperty;
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public Brush Foreground { get; public set; }
    private static DataGridTextColumn();
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal virtual void OnInput(InputEventArgs e);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
}
public class System.Windows.Controls.DataTemplateSelector : object {
    public virtual DataTemplate SelectTemplate(object item, DependencyObject container);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.DatePicker : Control {
    public static RoutedEvent SelectedDateChangedEvent;
    public static DependencyProperty CalendarStyleProperty;
    public static DependencyProperty DisplayDateProperty;
    public static DependencyProperty DisplayDateEndProperty;
    public static DependencyProperty DisplayDateStartProperty;
    public static DependencyProperty FirstDayOfWeekProperty;
    public static DependencyProperty IsDropDownOpenProperty;
    public static DependencyProperty IsTodayHighlightedProperty;
    public static DependencyProperty SelectedDateProperty;
    public static DependencyProperty SelectedDateFormatProperty;
    public static DependencyProperty TextProperty;
    public CalendarBlackoutDatesCollection BlackoutDates { get; }
    public Style CalendarStyle { get; public set; }
    public DateTime DisplayDate { get; public set; }
    public Nullable`1<DateTime> DisplayDateEnd { get; public set; }
    public Nullable`1<DateTime> DisplayDateStart { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public bool IsDropDownOpen { get; public set; }
    public bool IsTodayHighlighted { get; public set; }
    public Nullable`1<DateTime> SelectedDate { get; public set; }
    public DatePickerFormat SelectedDateFormat { get; public set; }
    public string Text { get; public set; }
    internal Calendar Calendar { get; }
    internal TextBox TextBox { get; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    private static DatePicker();
    [CompilerGeneratedAttribute]
public void add_CalendarClosed(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CalendarClosed(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CalendarOpened(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CalendarOpened(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DateValidationError(EventHandler`1<DatePickerDateValidationErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DateValidationError(EventHandler`1<DatePickerDateValidationErrorEventArgs> value);
    public void add_SelectedDateChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public void remove_SelectedDateChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public CalendarBlackoutDatesCollection get_BlackoutDates();
    public Style get_CalendarStyle();
    public void set_CalendarStyle(Style value);
    public DateTime get_DisplayDate();
    public void set_DisplayDate(DateTime value);
    public Nullable`1<DateTime> get_DisplayDateEnd();
    public void set_DisplayDateEnd(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_DisplayDateStart();
    public void set_DisplayDateStart(Nullable`1<DateTime> value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public bool get_IsDropDownOpen();
    public void set_IsDropDownOpen(bool value);
    public bool get_IsTodayHighlighted();
    public void set_IsTodayHighlighted(bool value);
    public Nullable`1<DateTime> get_SelectedDate();
    public void set_SelectedDate(Nullable`1<DateTime> value);
    public DatePickerFormat get_SelectedDateFormat();
    public void set_SelectedDateFormat(DatePickerFormat value);
    public string get_Text();
    public void set_Text(string value);
    internal Calendar get_Calendar();
    internal TextBox get_TextBox();
    public virtual void OnApplyTemplate();
    public virtual string ToString();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnCalendarClosed(RoutedEventArgs e);
    protected virtual void OnCalendarOpened(RoutedEventArgs e);
    protected virtual void OnSelectedDateChanged(SelectionChangedEventArgs e);
    protected virtual void OnDateValidationError(DatePickerDateValidationErrorEventArgs e);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
}
public class System.Windows.Controls.DatePickerDateValidationErrorEventArgs : EventArgs {
    public Exception Exception { get; private set; }
    public string Text { get; private set; }
    public bool ThrowException { get; public set; }
    public DatePickerDateValidationErrorEventArgs(Exception exception, string text);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    public bool get_ThrowException();
    public void set_ThrowException(bool value);
}
public enum System.Windows.Controls.DatePickerFormat : Enum {
    public int value__;
    public static DatePickerFormat Long;
    public static DatePickerFormat Short;
}
internal static class System.Windows.Controls.DateTimeHelper : object {
    private static DateTimeHelper();
    public static Nullable`1<DateTime> AddDays(DateTime time, int days);
    public static Nullable`1<DateTime> AddMonths(DateTime time, int months);
    public static Nullable`1<DateTime> AddYears(DateTime time, int years);
    public static Nullable`1<DateTime> SetYear(DateTime date, int year);
    public static Nullable`1<DateTime> SetYearMonth(DateTime date, DateTime yearMonth);
    public static int CompareDays(DateTime dt1, DateTime dt2);
    public static int CompareYearMonth(DateTime dt1, DateTime dt2);
    public static int DecadeOfDate(DateTime date);
    public static DateTime DiscardDayTime(DateTime d);
    public static Nullable`1<DateTime> DiscardTime(Nullable`1<DateTime> d);
    public static int EndOfDecade(DateTime date);
    public static DateTimeFormatInfo GetCurrentDateFormat();
    internal static CultureInfo GetCulture(FrameworkElement element);
    internal static DateTimeFormatInfo GetDateFormat(CultureInfo culture);
    public static bool InRange(DateTime date, CalendarDateRange range);
    public static bool InRange(DateTime date, DateTime start, DateTime end);
    public static string ToDayString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToDecadeRangeString(int decade, FrameworkElement fe);
    public static string ToYearMonthPatternString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToYearString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToAbbreviatedMonthString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToLongDateString(Nullable`1<DateTime> date, CultureInfo culture);
}
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.Decorator : FrameworkElement {
    [DefaultValueAttribute("")]
public UIElement Child { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal UIElement IntChild { get; internal set; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal UIElement get_IntChild();
    internal void set_IntChild(UIElement value);
}
internal class System.Windows.Controls.DefaultItemContainerTemplateSelector : ItemContainerTemplateSelector {
    public virtual DataTemplate SelectTemplate(object item, ItemsControl parentItemsControl);
}
internal class System.Windows.Controls.DeferredRunTextReference : DeferredReference {
    internal DeferredRunTextReference(Run run);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.Controls.DeferredSelectedIndexReference : DeferredReference {
    internal DeferredSelectedIndexReference(Selector selector);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.Controls.DeferredTextReference : DeferredReference {
    internal DeferredTextReference(ITextContainer textContainer);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
[LocalizabilityAttribute("16")]
public abstract class System.Windows.Controls.DefinitionBase : FrameworkContentElement {
    internal static bool ThisIsColumnDefinition;
    internal static bool ThisIsRowDefinition;
    internal static DependencyProperty PrivateSharedSizeScopeProperty;
    public static DependencyProperty SharedSizeGroupProperty;
    public string SharedSizeGroup { get; public set; }
    internal bool IsShared { get; }
    internal GridLength UserSize { get; }
    internal double UserMinSize { get; }
    internal double UserMaxSize { get; }
    internal int Index { get; internal set; }
    internal LayoutTimeSizeType SizeType { get; internal set; }
    internal double MeasureSize { get; internal set; }
    internal double PreferredSize { get; }
    internal double SizeCache { get; internal set; }
    internal double MinSize { get; }
    internal double MinSizeForArrange { get; }
    internal double FinalOffset { get; internal set; }
    internal GridLength UserSizeValueCache { get; }
    internal double UserMinSizeValueCache { get; }
    internal double UserMaxSizeValueCache { get; }
    internal bool InParentLogicalTree { get; }
    internal DefinitionBase(bool isColumnDefinition);
    private static DefinitionBase();
    public string get_SharedSizeGroup();
    public void set_SharedSizeGroup(string value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnBeforeLayout(Grid grid);
    internal void UpdateMinSize(double minSize);
    internal void SetMinSize(double minSize);
    internal static void OnUserSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserSizePropertyValueValid(object value);
    internal static void OnUserMinSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserMinSizePropertyValueValid(object value);
    internal static void OnUserMaxSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserMaxSizePropertyValueValid(object value);
    internal static void OnIsSharedSizeScopePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal bool get_IsShared();
    internal GridLength get_UserSize();
    internal double get_UserMinSize();
    internal double get_UserMaxSize();
    internal int get_Index();
    internal void set_Index(int value);
    internal LayoutTimeSizeType get_SizeType();
    internal void set_SizeType(LayoutTimeSizeType value);
    internal double get_MeasureSize();
    internal void set_MeasureSize(double value);
    internal double get_PreferredSize();
    internal double get_SizeCache();
    internal void set_SizeCache(double value);
    internal double get_MinSize();
    internal double get_MinSizeForArrange();
    internal double get_FinalOffset();
    internal void set_FinalOffset(double value);
    internal GridLength get_UserSizeValueCache();
    internal double get_UserMinSizeValueCache();
    internal double get_UserMaxSizeValueCache();
    internal bool get_InParentLogicalTree();
}
public enum System.Windows.Controls.Dock : Enum {
    public int value__;
    public static Dock Left;
    public static Dock Top;
    public static Dock Right;
    public static Dock Bottom;
}
public class System.Windows.Controls.DockPanel : Panel {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty LastChildFillProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty DockProperty;
    public bool LastChildFill { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static DockPanel();
    [AttachedPropertyBrowsableForChildrenAttribute]
public static Dock GetDock(UIElement element);
    public static void SetDock(UIElement element, Dock dock);
    public bool get_LastChildFill();
    public void set_LastChildFill(bool value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static bool IsValidDock(object o);
    internal virtual int get_EffectiveValuesInitialSize();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.DocumentViewer : DocumentViewerBase {
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty ExtentWidthProperty;
    public static DependencyProperty ExtentHeightProperty;
    public static DependencyProperty ViewportWidthProperty;
    public static DependencyProperty ViewportHeightProperty;
    public static DependencyProperty ShowPageBordersProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxPagesAcrossProperty;
    public static DependencyProperty VerticalPageSpacingProperty;
    public static DependencyProperty HorizontalPageSpacingProperty;
    public static DependencyProperty CanMoveUpProperty;
    public static DependencyProperty CanMoveDownProperty;
    public static DependencyProperty CanMoveLeftProperty;
    public static DependencyProperty CanMoveRightProperty;
    public static DependencyProperty CanIncreaseZoomProperty;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static RoutedUICommand ViewThumbnailsCommand { get; }
    public static RoutedUICommand FitToWidthCommand { get; }
    public static RoutedUICommand FitToHeightCommand { get; }
    public static RoutedUICommand FitToMaxPagesAcrossCommand { get; }
    public double HorizontalOffset { get; public set; }
    public double VerticalOffset { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public bool ShowPageBorders { get; public set; }
    public double Zoom { get; public set; }
    public int MaxPagesAcross { get; public set; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool CanMoveUp { get; }
    public bool CanMoveDown { get; }
    public bool CanMoveLeft { get; }
    public bool CanMoveRight { get; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    internal ITextSelection TextSelection { get; }
    internal IDocumentScrollInfo DocumentScrollInfo { get; }
    internal ScrollViewer ScrollViewer { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static DocumentViewer();
    public void ViewThumbnails();
    public void FitToWidth();
    public void FitToHeight();
    public void FitToMaxPagesAcross();
    public void FitToMaxPagesAcross(int pagesAcross);
    public void Find();
    public void ScrollPageUp();
    public void ScrollPageDown();
    public void ScrollPageLeft();
    public void ScrollPageRight();
    public void MoveUp();
    public void MoveDown();
    public void MoveLeft();
    public void MoveRight();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public virtual void OnApplyTemplate();
    public static RoutedUICommand get_ViewThumbnailsCommand();
    public static RoutedUICommand get_FitToWidthCommand();
    public static RoutedUICommand get_FitToHeightCommand();
    public static RoutedUICommand get_FitToMaxPagesAcrossCommand();
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public bool get_ShowPageBorders();
    public void set_ShowPageBorders(bool value);
    public double get_Zoom();
    public void set_Zoom(double value);
    public int get_MaxPagesAcross();
    public void set_MaxPagesAcross(int value);
    public double get_VerticalPageSpacing();
    public void set_VerticalPageSpacing(double value);
    public double get_HorizontalPageSpacing();
    public void set_HorizontalPageSpacing(double value);
    public bool get_CanMoveUp();
    public bool get_CanMoveDown();
    public bool get_CanMoveLeft();
    public bool get_CanMoveRight();
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnDocumentChanged();
    protected virtual void OnBringIntoView(DependencyObject element, Rect rect, int pageNumber);
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnViewThumbnailsCommand();
    protected virtual void OnFitToWidthCommand();
    protected virtual void OnFitToHeightCommand();
    protected virtual void OnFitToMaxPagesAcrossCommand();
    protected virtual void OnFitToMaxPagesAcrossCommand(int pagesAcross);
    protected virtual void OnFindCommand();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnScrollPageUpCommand();
    protected virtual void OnScrollPageDownCommand();
    protected virtual void OnScrollPageLeftCommand();
    protected virtual void OnScrollPageRightCommand();
    protected virtual void OnMoveUpCommand();
    protected virtual void OnMoveDownCommand();
    protected virtual void OnMoveLeftCommand();
    protected virtual void OnMoveRightCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    protected virtual ReadOnlyCollection`1<DocumentPageView> GetPageViewsCollection(Boolean& changed);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    internal void InvalidateDocumentScrollInfo();
    internal void InvalidatePageViewsInternal();
    internal bool BringPointIntoView(Point point);
    internal ITextSelection get_TextSelection();
    internal IDocumentScrollInfo get_DocumentScrollInfo();
    internal ScrollViewer get_ScrollViewer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal static class System.Windows.Controls.EditingModeHelper : object {
    internal static bool IsDefined(InkCanvasEditingMode InkCanvasEditingMode);
}
internal enum System.Windows.Controls.ElementViewportPosition : Enum {
    public int value__;
    public static ElementViewportPosition None;
    public static ElementViewportPosition BeforeViewport;
    public static ElementViewportPosition PartiallyInViewport;
    public static ElementViewportPosition CompletelyInViewport;
    public static ElementViewportPosition AfterViewport;
}
public class System.Windows.Controls.ExceptionValidationRule : ValidationRule {
    internal static ExceptionValidationRule Instance;
    private static ExceptionValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.ExpandDirection : Enum {
    public int value__;
    public static ExpandDirection Down;
    public static ExpandDirection Up;
    public static ExpandDirection Left;
    public static ExpandDirection Right;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Expander : HeaderedContentControl {
    public static DependencyProperty ExpandDirectionProperty;
    public static DependencyProperty IsExpandedProperty;
    public static RoutedEvent ExpandedEvent;
    public static RoutedEvent CollapsedEvent;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public ExpandDirection ExpandDirection { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsExpanded { get; public set; }
    internal bool IsExpanderToggleButtonFocused { get; }
    internal ToggleButton ExpanderToggleButton { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Expander();
    public ExpandDirection get_ExpandDirection();
    public void set_ExpandDirection(ExpandDirection value);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public void add_Expanded(RoutedEventHandler value);
    public void remove_Expanded(RoutedEventHandler value);
    public void add_Collapsed(RoutedEventHandler value);
    public void remove_Collapsed(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnExpanded();
    protected virtual void OnCollapsed();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    internal bool get_IsExpanderToggleButtonFocused();
    internal ToggleButton get_ExpanderToggleButton();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.FindToolTipEventArgs : RoutedEventArgs {
    internal DependencyObject TargetElement { get; internal set; }
    internal bool KeepCurrentActive { get; internal set; }
    internal DependencyObject get_TargetElement();
    internal void set_TargetElement(DependencyObject value);
    internal bool get_KeepCurrentActive();
    internal void set_KeepCurrentActive(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
internal class System.Windows.Controls.FindToolTipEventHandler : MulticastDelegate {
    public FindToolTipEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FindToolTipEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FindToolTipEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TemplatePartAttribute]
public class System.Windows.Controls.FlowDocumentPageViewer : DocumentViewerBase {
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    protected static DependencyPropertyKey CanIncreaseZoomPropertyKey;
    public static DependencyProperty CanIncreaseZoomProperty;
    protected static DependencyPropertyKey CanDecreaseZoomPropertyKey;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public TextSelection Selection { get; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal ContentPosition ContentPosition { get; }
    internal bool CanShowFindToolBar { get; }
    internal bool IsPrinting { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static FlowDocumentPageViewer();
    public virtual void OnApplyTemplate();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public void Find();
    public TextSelection get_Selection();
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public virtual bool get_CanIncreaseZoom();
    public virtual bool get_CanDecreaseZoom();
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnPageViewsChanged();
    protected virtual void OnDocumentChanged();
    protected virtual void OnPrintCompleted();
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal bool BringPointIntoView(Point point);
    internal object BringContentPositionIntoView(object arg);
    internal ContentPosition get_ContentPosition();
    internal bool get_CanShowFindToolBar();
    internal bool get_IsPrinting();
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[ContentPropertyAttribute("Document")]
public class System.Windows.Controls.FlowDocumentReader : Control {
    public static DependencyProperty ViewingModeProperty;
    public static DependencyProperty IsPageViewEnabledProperty;
    public static DependencyProperty IsTwoPageViewEnabledProperty;
    public static DependencyProperty IsScrollViewEnabledProperty;
    public static DependencyProperty PageCountProperty;
    public static DependencyProperty PageNumberProperty;
    public static DependencyProperty CanGoToPreviousPageProperty;
    public static DependencyProperty CanGoToNextPageProperty;
    public static DependencyProperty IsFindEnabledProperty;
    public static DependencyProperty IsPrintEnabledProperty;
    public static DependencyProperty DocumentProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    public static DependencyProperty CanIncreaseZoomProperty;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedUICommand SwitchViewingModeCommand;
    public FlowDocumentReaderViewingMode ViewingMode { get; public set; }
    public TextSelection Selection { get; }
    public bool IsPageViewEnabled { get; public set; }
    public bool IsTwoPageViewEnabled { get; public set; }
    public bool IsScrollViewEnabled { get; public set; }
    public int PageCount { get; }
    public int PageNumber { get; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    public bool IsFindEnabled { get; public set; }
    public bool IsPrintEnabled { get; public set; }
    public FlowDocument Document { get; public set; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static FlowDocumentReader();
    public virtual void OnApplyTemplate();
    public bool CanGoToPage(int pageNumber);
    public void Find();
    public void Print();
    public void CancelPrint();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public void SwitchViewingMode(FlowDocumentReaderViewingMode viewingMode);
    public FlowDocumentReaderViewingMode get_ViewingMode();
    public void set_ViewingMode(FlowDocumentReaderViewingMode value);
    public TextSelection get_Selection();
    public bool get_IsPageViewEnabled();
    public void set_IsPageViewEnabled(bool value);
    public bool get_IsTwoPageViewEnabled();
    public void set_IsTwoPageViewEnabled(bool value);
    public bool get_IsScrollViewEnabled();
    public void set_IsScrollViewEnabled(bool value);
    public int get_PageCount();
    public int get_PageNumber();
    public bool get_CanGoToPreviousPage();
    public bool get_CanGoToNextPage();
    public bool get_IsFindEnabled();
    public void set_IsFindEnabled(bool value);
    public bool get_IsPrintEnabled();
    public void set_IsPrintEnabled(bool value);
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual void OnPrintCompleted();
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    protected virtual void OnSwitchViewingModeCommand(FlowDocumentReaderViewingMode viewingMode);
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    protected virtual void SwitchViewingModeCore(FlowDocumentReaderViewingMode viewingMode);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public enum System.Windows.Controls.FlowDocumentReaderViewingMode : Enum {
    public int value__;
    public static FlowDocumentReaderViewingMode Page;
    public static FlowDocumentReaderViewingMode TwoPage;
    public static FlowDocumentReaderViewingMode Scroll;
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[ContentPropertyAttribute("Document")]
public class System.Windows.Controls.FlowDocumentScrollViewer : Control {
    public static DependencyProperty DocumentProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    public static DependencyProperty CanIncreaseZoomProperty;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty IsSelectionEnabledProperty;
    public static DependencyProperty IsToolBarVisibleProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public FlowDocument Document { get; public set; }
    public TextSelection Selection { get; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public bool IsSelectionEnabled { get; public set; }
    public bool IsToolBarVisible { get; public set; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    internal ScrollViewer ScrollViewer { get; }
    internal bool CanShowFindToolBar { get; }
    internal bool IsPrinting { get; }
    internal TextPointer ContentPosition { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static FlowDocumentScrollViewer();
    public virtual void OnApplyTemplate();
    public void Find();
    public void Print();
    public void CancelPrint();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    public TextSelection get_Selection();
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    public bool get_IsSelectionEnabled();
    public void set_IsSelectionEnabled(bool value);
    public bool get_IsToolBarVisible();
    public void set_IsToolBarVisible(bool value);
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual void OnPrintCompleted();
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal object BringContentPositionIntoView(object arg);
    internal ScrollViewer get_ScrollViewer();
    internal bool get_CanShowFindToolBar();
    internal bool get_IsPrinting();
    internal TextPointer get_ContentPosition();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultPropertyAttribute("Source")]
[DefaultEventAttribute("Navigated")]
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Frame : ContentControl {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty CanGoBackProperty;
    public static DependencyProperty CanGoForwardProperty;
    public static DependencyProperty BackStackProperty;
    public static DependencyProperty ForwardStackProperty;
    public static DependencyProperty NavigationUIVisibilityProperty;
    public static DependencyProperty SandboxExternalContentProperty;
    public static DependencyProperty JournalOwnershipProperty;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    private NavigationService MS.Internal.AppModel.IDownloader.Downloader { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Navigation")]
public Uri Source { get; public set; }
    public NavigationUIVisibility NavigationUIVisibility { get; public set; }
    public bool SandboxExternalContent { get; public set; }
    public JournalOwnership JournalOwnership { get; public set; }
    public NavigationService NavigationService { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public Uri CurrentSource { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Frame();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    private sealed virtual override NavigationService MS.Internal.AppModel.IDownloader.get_Downloader();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ContentRendered(EventHandler value);
    protected virtual void OnContentRendered(EventArgs args);
    private sealed virtual override void MS.Internal.AppModel.INavigatorImpl.OnSourceUpdatedFromNavService(bool journalOrCancel);
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public NavigationUIVisibility get_NavigationUIVisibility();
    public void set_NavigationUIVisibility(NavigationUIVisibility value);
    public bool get_SandboxExternalContent();
    public void set_SandboxExternalContent(bool value);
    public JournalOwnership get_JournalOwnership();
    public void set_JournalOwnership(JournalOwnership value);
    public sealed virtual NavigationService get_NavigationService();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void AddChild(object value);
    protected virtual void AddText(string text);
    internal virtual object AdjustEventSource(RoutedEventArgs e);
    internal virtual string GetPlainText();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    public virtual void OnApplyTemplate();
    private sealed virtual override Visual MS.Internal.AppModel.INavigatorImpl.FindRootViewer();
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    public sealed virtual void GoForward();
    public sealed virtual void GoBack();
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.VerifyContextAndObjectState();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.OnJournalAvailable();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoBackOverride();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoForwardOverride();
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal cjs);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnThemeChanged();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Grid : Panel {
    public static DependencyProperty ShowGridLinesProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ColumnProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RowProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ColumnSpanProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RowSpanProperty;
    public static DependencyProperty IsSharedSizeScopeProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public bool ShowGridLines { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public ColumnDefinitionCollection ColumnDefinitions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public RowDefinitionCollection RowDefinitions { get; }
    protected int VisualChildrenCount { get; }
    internal bool MeasureOverrideInProgress { get; internal set; }
    internal bool ArrangeOverrideInProgress { get; internal set; }
    internal bool ColumnDefinitionCollectionDirty { get; internal set; }
    internal bool RowDefinitionCollectionDirty { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Grid();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    public static void SetColumn(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetColumn(UIElement element);
    public static void SetRow(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetRow(UIElement element);
    public static void SetColumnSpan(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetColumnSpan(UIElement element);
    public static void SetRowSpan(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetRowSpan(UIElement element);
    public static void SetIsSharedSizeScope(UIElement element, bool value);
    public static bool GetIsSharedSizeScope(UIElement element);
    public bool get_ShowGridLines();
    public void set_ShowGridLines(bool value);
    public ColumnDefinitionCollection get_ColumnDefinitions();
    public RowDefinitionCollection get_RowDefinitions();
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal void Invalidate();
    internal double GetFinalColumnDefinitionWidth(int columnIndex);
    internal double GetFinalRowDefinitionHeight(int rowIndex);
    internal bool get_MeasureOverrideInProgress();
    internal void set_MeasureOverrideInProgress(bool value);
    internal bool get_ArrangeOverrideInProgress();
    internal void set_ArrangeOverrideInProgress(bool value);
    internal bool get_ColumnDefinitionCollectionDirty();
    internal void set_ColumnDefinitionCollectionDirty(bool value);
    internal bool get_RowDefinitionCollectionDirty();
    internal void set_RowDefinitionCollectionDirty(bool value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeColumnDefinitions();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeRowDefinitions();
    internal virtual int get_EffectiveValuesInitialSize();
    [ConditionalAttribute("GRIDPARANOIA")]
internal void EnterCounterScope(Counters scopeCounter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void ExitCounterScope(Counters scopeCounter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void EnterCounter(Counters counter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void ExitCounter(Counters counter);
}
public enum System.Windows.Controls.GridResizeBehavior : Enum {
    public int value__;
    public static GridResizeBehavior BasedOnAlignment;
    public static GridResizeBehavior CurrentAndNext;
    public static GridResizeBehavior PreviousAndCurrent;
    public static GridResizeBehavior PreviousAndNext;
}
public enum System.Windows.Controls.GridResizeDirection : Enum {
    public int value__;
    public static GridResizeDirection Auto;
    public static GridResizeDirection Columns;
    public static GridResizeDirection Rows;
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.GridSplitter : Thumb {
    public static DependencyProperty ResizeDirectionProperty;
    public static DependencyProperty ResizeBehaviorProperty;
    public static DependencyProperty ShowsPreviewProperty;
    public static DependencyProperty PreviewStyleProperty;
    public static DependencyProperty KeyboardIncrementProperty;
    public static DependencyProperty DragIncrementProperty;
    public GridResizeDirection ResizeDirection { get; public set; }
    public GridResizeBehavior ResizeBehavior { get; public set; }
    public bool ShowsPreview { get; public set; }
    public Style PreviewStyle { get; public set; }
    public double KeyboardIncrement { get; public set; }
    public double DragIncrement { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static GridSplitter();
    public GridResizeDirection get_ResizeDirection();
    public void set_ResizeDirection(GridResizeDirection value);
    public GridResizeBehavior get_ResizeBehavior();
    public void set_ResizeBehavior(GridResizeBehavior value);
    public bool get_ShowsPreview();
    public void set_ShowsPreview(bool value);
    public Style get_PreviewStyle();
    public void set_PreviewStyle(Style value);
    public double get_KeyboardIncrement();
    public void set_KeyboardIncrement(double value);
    public double get_DragIncrement();
    public void set_DragIncrement(double value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal bool KeyboardMoveSplitter(double horizontalChange, double verticalChange);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[StyleTypedPropertyAttribute]
[ContentPropertyAttribute("Columns")]
public class System.Windows.Controls.GridView : ViewBase {
    public static DependencyProperty ColumnCollectionProperty;
    public static DependencyProperty ColumnHeaderContainerStyleProperty;
    public static DependencyProperty ColumnHeaderTemplateProperty;
    public static DependencyProperty ColumnHeaderTemplateSelectorProperty;
    public static DependencyProperty ColumnHeaderStringFormatProperty;
    public static DependencyProperty AllowsColumnReorderProperty;
    public static DependencyProperty ColumnHeaderContextMenuProperty;
    public static DependencyProperty ColumnHeaderToolTipProperty;
    public static ResourceKey GridViewScrollViewerStyleKey { get; }
    public static ResourceKey GridViewStyleKey { get; }
    public static ResourceKey GridViewItemContainerStyleKey { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public GridViewColumnCollection Columns { get; }
    public Style ColumnHeaderContainerStyle { get; public set; }
    public DataTemplate ColumnHeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ColumnHeaderTemplateSelector { get; public set; }
    public string ColumnHeaderStringFormat { get; public set; }
    public bool AllowsColumnReorder { get; public set; }
    public ContextMenu ColumnHeaderContextMenu { get; public set; }
    public object ColumnHeaderToolTip { get; public set; }
    protected internal object DefaultStyleKey { get; }
    protected internal object ItemContainerDefaultStyleKey { get; }
    internal GridViewHeaderRowPresenter HeaderRowPresenter { get; internal set; }
    private static GridView();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object column);
    protected virtual void AddChild(object column);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public virtual string ToString();
    protected internal virtual IViewAutomationPeer GetAutomationPeer(ListView parent);
    public static ResourceKey get_GridViewScrollViewerStyleKey();
    public static ResourceKey get_GridViewStyleKey();
    public static ResourceKey get_GridViewItemContainerStyleKey();
    public static GridViewColumnCollection GetColumnCollection(DependencyObject element);
    public static void SetColumnCollection(DependencyObject element, GridViewColumnCollection collection);
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeColumnCollection(DependencyObject obj);
    public GridViewColumnCollection get_Columns();
    public Style get_ColumnHeaderContainerStyle();
    public void set_ColumnHeaderContainerStyle(Style value);
    public DataTemplate get_ColumnHeaderTemplate();
    public void set_ColumnHeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_ColumnHeaderTemplateSelector();
    public void set_ColumnHeaderTemplateSelector(DataTemplateSelector value);
    public string get_ColumnHeaderStringFormat();
    public void set_ColumnHeaderStringFormat(string value);
    public bool get_AllowsColumnReorder();
    public void set_AllowsColumnReorder(bool value);
    public ContextMenu get_ColumnHeaderContextMenu();
    public void set_ColumnHeaderContextMenu(ContextMenu value);
    public object get_ColumnHeaderToolTip();
    public void set_ColumnHeaderToolTip(object value);
    protected internal virtual void PrepareItem(ListViewItem item);
    protected internal virtual void ClearItem(ListViewItem item);
    protected internal virtual object get_DefaultStyleKey();
    protected internal virtual object get_ItemContainerDefaultStyleKey();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal virtual void OnThemeChanged();
    internal GridViewHeaderRowPresenter get_HeaderRowPresenter();
    internal void set_HeaderRowPresenter(GridViewHeaderRowPresenter value);
}
[ContentPropertyAttribute("Header")]
[StyleTypedPropertyAttribute]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GridViewColumn : DependencyObject {
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderContainerStyleProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty HeaderStringFormatProperty;
    internal static string c_DisplayMemberBindingName;
    public static DependencyProperty CellTemplateProperty;
    public static DependencyProperty CellTemplateSelectorProperty;
    public static DependencyProperty WidthProperty;
    internal static string c_ActualWidthName;
    public object Header { get; public set; }
    public Style HeaderContainerStyle { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public string HeaderStringFormat { get; public set; }
    public BindingBase DisplayMemberBinding { get; public set; }
    public DataTemplate CellTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector CellTemplateSelector { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Width { get; public set; }
    public double ActualWidth { get; private set; }
    internal ColumnMeasureState State { get; internal set; }
    internal int ActualIndex { get; internal set; }
    internal double DesiredWidth { get; private set; }
    internal DependencyObject InheritanceContext { get; }
    private static GridViewColumn();
    public virtual string ToString();
    public object get_Header();
    public void set_Header(object value);
    public Style get_HeaderContainerStyle();
    public void set_HeaderContainerStyle(Style value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    public BindingBase get_DisplayMemberBinding();
    public void set_DisplayMemberBinding(BindingBase value);
    public DataTemplate get_CellTemplate();
    public void set_CellTemplate(DataTemplate value);
    public DataTemplateSelector get_CellTemplateSelector();
    public void set_CellTemplateSelector(DataTemplateSelector value);
    public double get_Width();
    public void set_Width(double value);
    public double get_ActualWidth();
    private void set_ActualWidth(double value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal void OnThemeChanged();
    internal double EnsureWidth(double width);
    internal void ResetPrivateData();
    internal ColumnMeasureState get_State();
    internal void set_State(ColumnMeasureState value);
    internal int get_ActualIndex();
    internal void set_ActualIndex(int value);
    internal double get_DesiredWidth();
    private void set_DesiredWidth(double value);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
}
public class System.Windows.Controls.GridViewColumnCollection : ObservableCollection`1<GridViewColumn> {
    internal List`1<GridViewColumn> ColumnCollection { get; }
    internal List`1<int> IndexList { get; }
    internal DependencyObject Owner { get; internal set; }
    internal bool InViewMode { get; internal set; }
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, GridViewColumn column);
    protected virtual void SetItem(int index, GridViewColumn column);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    internal void add_InternalCollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void remove_InternalCollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void BlockWrite();
    internal void UnblockWrite();
    internal List`1<GridViewColumn> get_ColumnCollection();
    internal List`1<int> get_IndexList();
    internal DependencyObject get_Owner();
    internal void set_Owner(DependencyObject value);
    internal bool get_InViewMode();
    internal void set_InViewMode(bool value);
}
internal class System.Windows.Controls.GridViewColumnCollectionChangedEventArgs : NotifyCollectionChangedEventArgs {
    internal int ActualIndex { get; }
    internal ReadOnlyCollection`1<GridViewColumn> ClearedColumns { get; }
    internal GridViewColumn Column { get; }
    internal string PropertyName { get; }
    internal GridViewColumnCollectionChangedEventArgs(GridViewColumn column, string propertyName);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn[] clearedColumns);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn changedItem, int index, int actualIndex);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn newItem, GridViewColumn oldItem, int index, int actualIndex);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn changedItem, int index, int oldIndex, int actualIndex);
    internal int get_ActualIndex();
    internal ReadOnlyCollection`1<GridViewColumn> get_ClearedColumns();
    internal GridViewColumn get_Column();
    internal string get_PropertyName();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.GridViewColumnHeader : ButtonBase {
    internal static DependencyPropertyKey ColumnPropertyKey;
    public static DependencyProperty ColumnProperty;
    internal static DependencyPropertyKey RolePropertyKey;
    public static DependencyProperty RoleProperty;
    public GridViewColumn Column { get; }
    [CategoryAttribute("Behavior")]
public GridViewColumnHeaderRole Role { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal GridViewColumnHeader PreviousVisualHeader { get; internal set; }
    internal bool SuppressClickEvent { get; internal set; }
    internal GridViewColumnHeader FloatSourceHeader { get; internal set; }
    internal bool IsInternalGenerated { get; internal set; }
    private static GridViewColumnHeader();
    public virtual void OnApplyTemplate();
    public GridViewColumn get_Column();
    public GridViewColumnHeaderRole get_Role();
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    protected virtual void OnClick();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void AutomationClick();
    internal void OnColumnHeaderKeyDown(object sender, KeyEventArgs e);
    internal void CheckWidthForPreviousHeaderGripper();
    internal void ResetFloatingHeaderCanvasBackground();
    internal void UpdateProperty(DependencyProperty dp, object value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal GridViewColumnHeader get_PreviousVisualHeader();
    internal void set_PreviousVisualHeader(GridViewColumnHeader value);
    internal bool get_SuppressClickEvent();
    internal void set_SuppressClickEvent(bool value);
    internal GridViewColumnHeader get_FloatSourceHeader();
    internal void set_FloatSourceHeader(GridViewColumnHeader value);
    internal bool get_IsInternalGenerated();
    internal void set_IsInternalGenerated(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public enum System.Windows.Controls.GridViewColumnHeaderRole : Enum {
    public int value__;
    public static GridViewColumnHeaderRole Normal;
    public static GridViewColumnHeaderRole Floating;
    public static GridViewColumnHeaderRole Padding;
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.GridViewHeaderRowPresenter : GridViewRowPresenterBase {
    public static DependencyProperty ColumnHeaderContainerStyleProperty;
    public static DependencyProperty ColumnHeaderTemplateProperty;
    public static DependencyProperty ColumnHeaderTemplateSelectorProperty;
    public static DependencyProperty ColumnHeaderStringFormatProperty;
    public static DependencyProperty AllowsColumnReorderProperty;
    public static DependencyProperty ColumnHeaderContextMenuProperty;
    public static DependencyProperty ColumnHeaderToolTipProperty;
    public Style ColumnHeaderContainerStyle { get; public set; }
    public DataTemplate ColumnHeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ColumnHeaderTemplateSelector { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public string ColumnHeaderStringFormat { get; public set; }
    public bool AllowsColumnReorder { get; public set; }
    public ContextMenu ColumnHeaderContextMenu { get; public set; }
    public object ColumnHeaderToolTip { get; public set; }
    internal List`1<GridViewColumnHeader> ActualColumnHeaders { get; }
    private static GridViewHeaderRowPresenter();
    public Style get_ColumnHeaderContainerStyle();
    public void set_ColumnHeaderContainerStyle(Style value);
    public DataTemplate get_ColumnHeaderTemplate();
    public void set_ColumnHeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_ColumnHeaderTemplateSelector();
    public void set_ColumnHeaderTemplateSelector(DataTemplateSelector value);
    public string get_ColumnHeaderStringFormat();
    public void set_ColumnHeaderStringFormat(string value);
    public bool get_AllowsColumnReorder();
    public void set_AllowsColumnReorder(bool value);
    public ContextMenu get_ColumnHeaderContextMenu();
    public void set_ColumnHeaderContextMenu(ContextMenu value);
    public object get_ColumnHeaderToolTip();
    public void set_ColumnHeaderToolTip(object value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal void MakeParentItemsControlGotFocus();
    internal void UpdateHeaderProperty(GridViewColumnHeader header, DependencyProperty property);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal List`1<GridViewColumnHeader> get_ActualColumnHeaders();
}
public class System.Windows.Controls.GridViewRowPresenter : GridViewRowPresenterBase {
    public static DependencyProperty ContentProperty;
    public object Content { get; public set; }
    internal List`1<UIElement> ActualCells { get; }
    private static GridViewRowPresenter();
    public virtual string ToString();
    public object get_Content();
    public void set_Content(object value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal List`1<UIElement> get_ActualCells();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GroupBox : HeaderedContentControl {
    private static GroupBox();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
}
public class System.Windows.Controls.GroupItem : ContentControl {
    internal static UncommonField`1<bool> MustDisableVirtualizationField;
    internal static UncommonField`1<bool> InBackgroundLayoutField;
    internal static UncommonField`1<Thickness> DesiredPixelItemsSizeCorrectionFactorField;
    internal static UncommonField`1<HierarchicalVirtualizationConstraints> HierarchicalVirtualizationConstraintsField;
    internal static UncommonField`1<HierarchicalVirtualizationHeaderDesiredSizes> HierarchicalVirtualizationHeaderDesiredSizesField;
    internal static UncommonField`1<HierarchicalVirtualizationItemDesiredSizes> HierarchicalVirtualizationItemDesiredSizesField;
    internal ItemContainerGenerator Generator { get; internal set; }
    private HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.Constraints { get; private set; }
    private HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.HeaderDesiredSizes { get; }
    private HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemDesiredSizes { get; private set; }
    private Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemsHost { get; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.MustDisableVirtualization { get; private set; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.InBackgroundLayout { get; private set; }
    internal IContainItemStorage ParentItemStorageProvider { get; }
    internal Panel ItemsHost { get; internal set; }
    internal Expander Expander { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static GroupItem();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual string GetPlainText();
    internal ItemContainerGenerator get_Generator();
    internal void set_Generator(ItemContainerGenerator value);
    internal void PrepareItemContainer(object item, ItemsControl parentItemsControl);
    internal void ClearItemContainer(object item, ItemsControl parentItemsControl);
    private sealed virtual override HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_Constraints();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_Constraints(HierarchicalVirtualizationConstraints value);
    private sealed virtual override HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_HeaderDesiredSizes();
    private sealed virtual override HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemDesiredSizes();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    private sealed virtual override Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemsHost();
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_MustDisableVirtualization();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_MustDisableVirtualization(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_InBackgroundLayout();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_InBackgroundLayout(bool value);
    private sealed virtual override object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, DependencyProperty dp, object value);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.Clear();
    internal IContainItemStorage get_ParentItemStorageProvider();
    internal Panel get_ItemsHost();
    internal void set_ItemsHost(Panel value);
    internal Expander get_Expander();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GroupStyle : object {
    public static ItemsPanelTemplate DefaultGroupPanel;
    internal static ItemsPanelTemplate DefaultStackPanel;
    internal static ItemsPanelTemplate DefaultVirtualizingStackPanel;
    public ItemsPanelTemplate Panel { get; public set; }
    [DefaultValueAttribute("")]
public Style ContainerStyle { get; public set; }
    [DefaultValueAttribute("")]
public StyleSelector ContainerStyleSelector { get; public set; }
    [DefaultValueAttribute("")]
public DataTemplate HeaderTemplate { get; public set; }
    [DefaultValueAttribute("")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [DefaultValueAttribute("")]
public string HeaderStringFormat { get; public set; }
    [DefaultValueAttribute("False")]
public bool HidesIfEmpty { get; public set; }
    [DefaultValueAttribute("0")]
public int AlternationCount { get; public set; }
    public static GroupStyle Default { get; }
    internal bool IsAlternationCountSet { get; }
    private static GroupStyle();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public ItemsPanelTemplate get_Panel();
    public void set_Panel(ItemsPanelTemplate value);
    public Style get_ContainerStyle();
    public void set_ContainerStyle(Style value);
    public StyleSelector get_ContainerStyleSelector();
    public void set_ContainerStyleSelector(StyleSelector value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    public bool get_HidesIfEmpty();
    public void set_HidesIfEmpty(bool value);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    public static GroupStyle get_Default();
    internal bool get_IsAlternationCountSet();
}
public class System.Windows.Controls.GroupStyleSelector : MulticastDelegate {
    public GroupStyleSelector(object object, IntPtr method);
    public virtual GroupStyle Invoke(CollectionViewGroup group, int level);
    public virtual IAsyncResult BeginInvoke(CollectionViewGroup group, int level, AsyncCallback callback, object object);
    public virtual GroupStyle EndInvoke(IAsyncResult result);
}
[LocalizabilityAttribute("1")]
public class System.Windows.Controls.HeaderedContentControl : ContentControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderProperty;
    internal static DependencyPropertyKey HasHeaderPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasHeaderProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderStringFormatProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
[LocalizabilityAttribute("3")]
public object Header { get; public set; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
public bool HasHeader { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
public DataTemplate HeaderTemplate { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string HeaderStringFormat { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool HeaderIsNotLogical { get; internal set; }
    internal bool HeaderIsItem { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static HeaderedContentControl();
    public object get_Header();
    public void set_Header(object value);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public bool get_HasHeader();
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual string GetPlainText();
    internal bool get_HeaderIsNotLogical();
    internal void set_HeaderIsNotLogical(bool value);
    internal bool get_HeaderIsItem();
    internal void set_HeaderIsItem(bool value);
    internal void PrepareHeaderedContentControl(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string stringFormat);
    internal void ClearHeaderedContentControl(object item);
    public virtual string ToString();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultPropertyAttribute("Header")]
[LocalizabilityAttribute("8")]
public class System.Windows.Controls.HeaderedItemsControl : ItemsControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasHeaderProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderStringFormatProperty;
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public object Header { get; public set; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
public bool HasHeader { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate HeaderTemplate { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string HeaderStringFormat { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    private static HeaderedItemsControl();
    public object get_Header();
    public void set_Header(object value);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public bool get_HasHeader();
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    internal void PrepareHeaderedItemsControl(object item, ItemsControl parentItemsControl);
    internal void ClearHeaderedItemsControl(object item);
    internal virtual string GetPlainText();
    public virtual string ToString();
    protected internal virtual IEnumerator get_LogicalChildren();
}
public class System.Windows.Controls.HierarchicalVirtualizationConstraints : ValueType {
    private VirtualizationCacheLength _cacheLength;
    private VirtualizationCacheLengthUnit _cacheLengthUnit;
    private Rect _viewport;
    public VirtualizationCacheLength CacheLength { get; }
    public VirtualizationCacheLengthUnit CacheLengthUnit { get; }
    public Rect Viewport { get; }
    public HierarchicalVirtualizationConstraints(VirtualizationCacheLength cacheLength, VirtualizationCacheLengthUnit cacheLengthUnit, Rect viewport);
    public VirtualizationCacheLength get_CacheLength();
    public VirtualizationCacheLengthUnit get_CacheLengthUnit();
    public Rect get_Viewport();
    public static bool op_Equality(HierarchicalVirtualizationConstraints constraints1, HierarchicalVirtualizationConstraints constraints2);
    public static bool op_Inequality(HierarchicalVirtualizationConstraints constraints1, HierarchicalVirtualizationConstraints constraints2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationConstraints comparisonConstraints);
    public virtual int GetHashCode();
}
public class System.Windows.Controls.HierarchicalVirtualizationHeaderDesiredSizes : ValueType {
    private Size _logicalSize;
    private Size _pixelSize;
    public Size LogicalSize { get; }
    public Size PixelSize { get; }
    public HierarchicalVirtualizationHeaderDesiredSizes(Size logicalSize, Size pixelSize);
    public Size get_LogicalSize();
    public Size get_PixelSize();
    public static bool op_Equality(HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes1, HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes2);
    public static bool op_Inequality(HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes1, HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationHeaderDesiredSizes comparisonHeaderSizes);
    public virtual int GetHashCode();
}
public class System.Windows.Controls.HierarchicalVirtualizationItemDesiredSizes : ValueType {
    private Size _logicalSize;
    private Size _logicalSizeInViewport;
    private Size _logicalSizeBeforeViewport;
    private Size _logicalSizeAfterViewport;
    private Size _pixelSize;
    private Size _pixelSizeInViewport;
    private Size _pixelSizeBeforeViewport;
    private Size _pixelSizeAfterViewport;
    public Size LogicalSize { get; }
    public Size LogicalSizeInViewport { get; }
    public Size LogicalSizeBeforeViewport { get; }
    public Size LogicalSizeAfterViewport { get; }
    public Size PixelSize { get; }
    public Size PixelSizeInViewport { get; }
    public Size PixelSizeBeforeViewport { get; }
    public Size PixelSizeAfterViewport { get; }
    public HierarchicalVirtualizationItemDesiredSizes(Size logicalSize, Size logicalSizeInViewport, Size logicalSizeBeforeViewport, Size logicalSizeAfterViewport, Size pixelSize, Size pixelSizeInViewport, Size pixelSizeBeforeViewport, Size pixelSizeAfterViewport);
    public Size get_LogicalSize();
    public Size get_LogicalSizeInViewport();
    public Size get_LogicalSizeBeforeViewport();
    public Size get_LogicalSizeAfterViewport();
    public Size get_PixelSize();
    public Size get_PixelSizeInViewport();
    public Size get_PixelSizeBeforeViewport();
    public Size get_PixelSizeAfterViewport();
    public static bool op_Equality(HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes1, HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes2);
    public static bool op_Inequality(HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes1, HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationItemDesiredSizes comparisonItemSizes);
    public virtual int GetHashCode();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Image : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty SourceProperty;
    public static RoutedEvent DpiChangedEvent;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public static RoutedEvent ImageFailedEvent;
    public ImageSource Source { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Image();
    public ImageSource get_Source();
    public void set_Source(ImageSource value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    public void add_ImageFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void remove_ImageFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    internal virtual int get_EffectiveValuesInitialSize();
    private sealed virtual override bool System.Windows.Markup.IProvidePropertyFallback.CanProvidePropertyFallback(string property);
    private sealed virtual override object System.Windows.Markup.IProvidePropertyFallback.ProvidePropertyFallback(string property, Exception cause);
}
public class System.Windows.Controls.InitializingNewItemEventArgs : EventArgs {
    public object NewItem { get; }
    public InitializingNewItemEventArgs(object newItem);
    public object get_NewItem();
}
public class System.Windows.Controls.InitializingNewItemEventHandler : MulticastDelegate {
    public InitializingNewItemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InitializingNewItemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InitializingNewItemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Controls.InkCanvas : FrameworkElement {
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty BottomProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty StrokesProperty;
    public static DependencyProperty DefaultDrawingAttributesProperty;
    internal static DependencyPropertyKey ActiveEditingModePropertyKey;
    public static DependencyProperty ActiveEditingModeProperty;
    public static DependencyProperty EditingModeProperty;
    public static DependencyProperty EditingModeInvertedProperty;
    public static RoutedEvent StrokeCollectedEvent;
    public static RoutedEvent GestureEvent;
    public static RoutedEvent ActiveEditingModeChangedEvent;
    public static RoutedEvent EditingModeChangedEvent;
    public static RoutedEvent EditingModeInvertedChangedEvent;
    public static RoutedEvent StrokeErasedEvent;
    internal static RoutedCommand DeselectCommand;
    protected int VisualChildrenCount { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush Background { get; public set; }
    public StrokeCollection Strokes { get; public set; }
    internal InkCanvasSelectionAdorner SelectionAdorner { get; }
    internal InkCanvasFeedbackAdorner FeedbackAdorner { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsGestureRecognizerAvailable { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    public DrawingAttributes DefaultDrawingAttributes { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StylusShape EraserShape { get; public set; }
    public InkCanvasEditingMode ActiveEditingMode { get; }
    public InkCanvasEditingMode EditingMode { get; public set; }
    public InkCanvasEditingMode EditingModeInverted { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool UseCustomCursor { get; public set; }
    public bool MoveEnabled { get; public set; }
    public bool ResizeEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StylusPointDescription DefaultStylusPointDescription { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IEnumerable`1<InkCanvasClipboardFormat> PreferredPasteFormats { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected DynamicRenderer DynamicRenderer { get; protected set; }
    protected InkPresenter InkPresenter { get; }
    internal EditingCoordinator EditingCoordinator { get; }
    internal DynamicRenderer InternalDynamicRenderer { get; }
    internal InkCanvasInnerCanvas InnerCanvas { get; }
    internal InkCanvasSelection InkCanvasSelection { get; }
    private static InkCanvas();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParams);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal virtual void OnPreApplyTemplate();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Brush get_Background();
    public void set_Background(Brush value);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    public StrokeCollection get_Strokes();
    public void set_Strokes(StrokeCollection value);
    internal InkCanvasSelectionAdorner get_SelectionAdorner();
    internal InkCanvasFeedbackAdorner get_FeedbackAdorner();
    public bool get_IsGestureRecognizerAvailable();
    public UIElementCollection get_Children();
    public DrawingAttributes get_DefaultDrawingAttributes();
    public void set_DefaultDrawingAttributes(DrawingAttributes value);
    public StylusShape get_EraserShape();
    public void set_EraserShape(StylusShape value);
    public InkCanvasEditingMode get_ActiveEditingMode();
    public InkCanvasEditingMode get_EditingMode();
    public void set_EditingMode(InkCanvasEditingMode value);
    public InkCanvasEditingMode get_EditingModeInverted();
    public void set_EditingModeInverted(InkCanvasEditingMode value);
    public bool get_UseCustomCursor();
    public void set_UseCustomCursor(bool value);
    public bool get_MoveEnabled();
    public void set_MoveEnabled(bool value);
    public bool get_ResizeEnabled();
    public void set_ResizeEnabled(bool value);
    public StylusPointDescription get_DefaultStylusPointDescription();
    public void set_DefaultStylusPointDescription(StylusPointDescription value);
    public IEnumerable`1<InkCanvasClipboardFormat> get_PreferredPasteFormats();
    public void set_PreferredPasteFormats(IEnumerable`1<InkCanvasClipboardFormat> value);
    public void add_StrokeCollected(InkCanvasStrokeCollectedEventHandler value);
    public void remove_StrokeCollected(InkCanvasStrokeCollectedEventHandler value);
    protected virtual void OnStrokeCollected(InkCanvasStrokeCollectedEventArgs e);
    [SecurityCriticalAttribute]
internal void RaiseGestureOrStrokeCollected(InkCanvasStrokeCollectedEventArgs e, bool userInitiated);
    public void add_Gesture(InkCanvasGestureEventHandler value);
    public void remove_Gesture(InkCanvasGestureEventHandler value);
    protected virtual void OnGesture(InkCanvasGestureEventArgs e);
    [CompilerGeneratedAttribute]
public void add_StrokesReplaced(InkCanvasStrokesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokesReplaced(InkCanvasStrokesReplacedEventHandler value);
    protected virtual void OnStrokesReplaced(InkCanvasStrokesReplacedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_DefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    protected virtual void OnDefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    public void add_ActiveEditingModeChanged(RoutedEventHandler value);
    public void remove_ActiveEditingModeChanged(RoutedEventHandler value);
    protected virtual void OnActiveEditingModeChanged(RoutedEventArgs e);
    internal void RaiseActiveEditingModeChanged(RoutedEventArgs e);
    public void add_EditingModeChanged(RoutedEventHandler value);
    public void remove_EditingModeChanged(RoutedEventHandler value);
    protected virtual void OnEditingModeChanged(RoutedEventArgs e);
    public void add_EditingModeInvertedChanged(RoutedEventHandler value);
    public void remove_EditingModeInvertedChanged(RoutedEventHandler value);
    protected virtual void OnEditingModeInvertedChanged(RoutedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionMoving(InkCanvasSelectionEditingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionMoving(InkCanvasSelectionEditingEventHandler value);
    protected virtual void OnSelectionMoving(InkCanvasSelectionEditingEventArgs e);
    internal void RaiseSelectionMoving(InkCanvasSelectionEditingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionMoved(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionMoved(EventHandler value);
    protected virtual void OnSelectionMoved(EventArgs e);
    internal void RaiseSelectionMoved(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_StrokeErasing(InkCanvasStrokeErasingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokeErasing(InkCanvasStrokeErasingEventHandler value);
    protected virtual void OnStrokeErasing(InkCanvasStrokeErasingEventArgs e);
    internal void RaiseStrokeErasing(InkCanvasStrokeErasingEventArgs e);
    public void add_StrokeErased(RoutedEventHandler value);
    public void remove_StrokeErased(RoutedEventHandler value);
    protected virtual void OnStrokeErased(RoutedEventArgs e);
    internal void RaiseInkErased();
    [CompilerGeneratedAttribute]
public void add_SelectionResizing(InkCanvasSelectionEditingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionResizing(InkCanvasSelectionEditingEventHandler value);
    protected virtual void OnSelectionResizing(InkCanvasSelectionEditingEventArgs e);
    internal void RaiseSelectionResizing(InkCanvasSelectionEditingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionResized(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionResized(EventHandler value);
    protected virtual void OnSelectionResized(EventArgs e);
    internal void RaiseSelectionResized(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionChanging(InkCanvasSelectionChangingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanging(InkCanvasSelectionChangingEventHandler value);
    protected virtual void OnSelectionChanging(InkCanvasSelectionChangingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(EventHandler value);
    protected virtual void OnSelectionChanged(EventArgs e);
    internal void RaiseSelectionChanged(EventArgs e);
    internal void RaiseOnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    public Rect GetSelectionBounds();
    public ReadOnlyCollection`1<UIElement> GetSelectedElements();
    public StrokeCollection GetSelectedStrokes();
    public void Select(StrokeCollection selectedStrokes);
    public void Select(IEnumerable`1<UIElement> selectedElements);
    public void Select(StrokeCollection selectedStrokes, IEnumerable`1<UIElement> selectedElements);
    public InkCanvasSelectionHitResult HitTestSelection(Point point);
    public void CopySelection();
    public void CutSelection();
    public void Paste();
    public void Paste(Point point);
    public bool CanPaste();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string textData);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected DynamicRenderer get_DynamicRenderer();
    protected void set_DynamicRenderer(DynamicRenderer value);
    protected InkPresenter get_InkPresenter();
    internal void PasteFromDataObject(IDataObject dataObj, Point point);
    internal EditingCoordinator get_EditingCoordinator();
    internal DynamicRenderer get_InternalDynamicRenderer();
    internal InkCanvasInnerCanvas get_InnerCanvas();
    internal InkCanvasSelection get_InkCanvasSelection();
    internal void BeginDynamicSelection(Visual visual);
    internal void UpdateDynamicSelection(StrokeCollection strokesToDynamicallySelect, StrokeCollection strokesToDynamicallyUnselect);
    internal StrokeCollection EndDynamicSelection(Visual visual);
    internal bool ClearSelectionRaiseSelectionChanging();
    internal void ClearSelection(bool raiseSelectionChangedEvent);
    internal void ChangeInkCanvasSelection(StrokeCollection strokes, UIElement[] elements);
    internal static StrokeCollection GetValidStrokes(StrokeCollection subset, StrokeCollection superset);
    internal void UpdateDynamicRenderer();
    internal void UpdateCursor();
}
public enum System.Windows.Controls.InkCanvasClipboardFormat : Enum {
    public int value__;
    public static InkCanvasClipboardFormat InkSerializedFormat;
    public static InkCanvasClipboardFormat Text;
    public static InkCanvasClipboardFormat Xaml;
}
public enum System.Windows.Controls.InkCanvasEditingMode : Enum {
    public int value__;
    public static InkCanvasEditingMode None;
    public static InkCanvasEditingMode Ink;
    public static InkCanvasEditingMode GestureOnly;
    public static InkCanvasEditingMode InkAndGesture;
    public static InkCanvasEditingMode Select;
    public static InkCanvasEditingMode EraseByPoint;
    public static InkCanvasEditingMode EraseByStroke;
}
public class System.Windows.Controls.InkCanvasGestureEventArgs : RoutedEventArgs {
    public StrokeCollection Strokes { get; }
    public bool Cancel { get; public set; }
    public InkCanvasGestureEventArgs(StrokeCollection strokes, IEnumerable`1<GestureRecognitionResult> gestureRecognitionResults);
    public StrokeCollection get_Strokes();
    public ReadOnlyCollection`1<GestureRecognitionResult> GetGestureRecognitionResults();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.InkCanvasGestureEventHandler : MulticastDelegate {
    public InkCanvasGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasSelectionChangingEventArgs : CancelEventArgs {
    internal bool StrokesChanged { get; }
    internal bool ElementsChanged { get; }
    internal InkCanvasSelectionChangingEventArgs(StrokeCollection selectedStrokes, IEnumerable`1<UIElement> selectedElements);
    internal bool get_StrokesChanged();
    internal bool get_ElementsChanged();
    public void SetSelectedElements(IEnumerable`1<UIElement> selectedElements);
    public ReadOnlyCollection`1<UIElement> GetSelectedElements();
    public void SetSelectedStrokes(StrokeCollection selectedStrokes);
    public StrokeCollection GetSelectedStrokes();
}
public class System.Windows.Controls.InkCanvasSelectionChangingEventHandler : MulticastDelegate {
    public InkCanvasSelectionChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasSelectionChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasSelectionChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasSelectionEditingEventArgs : CancelEventArgs {
    public Rect OldRectangle { get; }
    public Rect NewRectangle { get; public set; }
    internal InkCanvasSelectionEditingEventArgs(Rect oldRectangle, Rect newRectangle);
    public Rect get_OldRectangle();
    public Rect get_NewRectangle();
    public void set_NewRectangle(Rect value);
}
public class System.Windows.Controls.InkCanvasSelectionEditingEventHandler : MulticastDelegate {
    public InkCanvasSelectionEditingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasSelectionEditingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasSelectionEditingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.InkCanvasSelectionHitResult : Enum {
    public int value__;
    public static InkCanvasSelectionHitResult None;
    public static InkCanvasSelectionHitResult TopLeft;
    public static InkCanvasSelectionHitResult Top;
    public static InkCanvasSelectionHitResult TopRight;
    public static InkCanvasSelectionHitResult Right;
    public static InkCanvasSelectionHitResult BottomRight;
    public static InkCanvasSelectionHitResult Bottom;
    public static InkCanvasSelectionHitResult BottomLeft;
    public static InkCanvasSelectionHitResult Left;
    public static InkCanvasSelectionHitResult Selection;
}
public class System.Windows.Controls.InkCanvasStrokeCollectedEventArgs : RoutedEventArgs {
    public Stroke Stroke { get; }
    public InkCanvasStrokeCollectedEventArgs(Stroke stroke);
    public Stroke get_Stroke();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.InkCanvasStrokeCollectedEventHandler : MulticastDelegate {
    public InkCanvasStrokeCollectedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokeCollectedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokeCollectedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasStrokeErasingEventArgs : CancelEventArgs {
    public Stroke Stroke { get; }
    internal InkCanvasStrokeErasingEventArgs(Stroke stroke);
    public Stroke get_Stroke();
}
public class System.Windows.Controls.InkCanvasStrokeErasingEventHandler : MulticastDelegate {
    public InkCanvasStrokeErasingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokeErasingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokeErasingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasStrokesReplacedEventArgs : EventArgs {
    public StrokeCollection NewStrokes { get; }
    public StrokeCollection PreviousStrokes { get; }
    internal InkCanvasStrokesReplacedEventArgs(StrokeCollection newStrokes, StrokeCollection previousStrokes);
    public StrokeCollection get_NewStrokes();
    public StrokeCollection get_PreviousStrokes();
}
public class System.Windows.Controls.InkCanvasStrokesReplacedEventHandler : MulticastDelegate {
    public InkCanvasStrokesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkPresenter : Decorator {
    public static DependencyProperty StrokesProperty;
    public StrokeCollection Strokes { get; public set; }
    protected int VisualChildrenCount { get; }
    private static InkPresenter();
    public void AttachVisuals(Visual visual, DrawingAttributes drawingAttributes);
    public void DetachVisuals(Visual visual);
    public StrokeCollection get_Strokes();
    public void set_Strokes(StrokeCollection value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal bool ContainsAttachedVisual(Visual visual);
    internal bool AttachedVisualIsPositionedCorrectly(Visual visual, DrawingAttributes drawingAttributes);
}
internal interface System.Windows.Controls.IProvideDataGridColumn {
    public DataGridColumn Column { get; }
    public abstract virtual DataGridColumn get_Column();
}
internal interface System.Windows.Controls.IStackMeasure {
    public bool IsScrolling { get; }
    public UIElementCollection InternalChildren { get; }
    public Orientation Orientation { get; }
    public bool CanVerticallyScroll { get; }
    public bool CanHorizontallyScroll { get; }
    public abstract virtual bool get_IsScrolling();
    public abstract virtual UIElementCollection get_InternalChildren();
    public abstract virtual Orientation get_Orientation();
    public abstract virtual bool get_CanVerticallyScroll();
    public abstract virtual bool get_CanHorizontallyScroll();
    public abstract virtual void OnScrollChange();
}
internal interface System.Windows.Controls.IStackMeasureScrollData {
    public Vector Offset { get; public set; }
    public Size Viewport { get; public set; }
    public Size Extent { get; public set; }
    public Vector ComputedOffset { get; public set; }
    public abstract virtual Vector get_Offset();
    public abstract virtual void set_Offset(Vector value);
    public abstract virtual Size get_Viewport();
    public abstract virtual void set_Viewport(Size value);
    public abstract virtual Size get_Extent();
    public abstract virtual void set_Extent(Size value);
    public abstract virtual Vector get_ComputedOffset();
    public abstract virtual void set_ComputedOffset(Vector value);
    public abstract virtual void SetPhysicalViewport(double value);
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
public class System.Windows.Controls.ItemCollection : CollectionView {
    public int Count { get; }
    public bool IsEmpty { get; }
    public object Item { get; public set; }
    public IEnumerable SourceCollection { get; }
    public bool NeedsRefresh { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public int CurrentPosition { get; }
    public object CurrentItem { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    private NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition { get; private set; }
    private bool System.ComponentModel.IEditableCollectionView.CanAddNew { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsAddingNew { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentAddItem { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanRemove { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanCancelEdit { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsEditingItem { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentEditItem { get; }
    private bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    private ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.ItemProperties { get; }
    internal DependencyObject ModelParent { get; }
    internal FrameworkElement ModelParentFE { get; }
    internal IEnumerable ItemsSource { get; }
    internal bool IsUsingItemsSource { get; }
    internal CollectionView CollectionView { get; }
    internal IEnumerator LogicalChildren { get; }
    internal ItemCollection(DependencyObject modelParent);
    internal ItemCollection(FrameworkElement modelParent, int capacity);
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual IEnumerator GetEnumerator();
    public sealed virtual int Add(object newItem);
    public sealed virtual void Clear();
    public virtual bool Contains(object containItem);
    public sealed virtual void CopyTo(Array array, int index);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public sealed virtual void Insert(int insertIndex, object insertItem);
    public sealed virtual void Remove(object removeItem);
    public sealed virtual void RemoveAt(int removeIndex);
    public virtual bool PassesFilter(object item);
    protected virtual void RefreshOverride();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public virtual IEnumerable get_SourceCollection();
    public virtual bool get_NeedsRefresh();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual IDisposable DeferRefresh();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    public virtual int get_CurrentPosition();
    public virtual object get_CurrentItem();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    private sealed virtual override NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.get_NewItemPlaceholderPosition();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanAddNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.AddNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelNew();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsAddingNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentAddItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanRemove();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.Remove(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.EditItem(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitEdit();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanCancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsEditingItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentEditItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionViewAddNewItem.get_CanAddNewItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(object newItem);
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    private sealed virtual override ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.get_ItemProperties();
    internal DependencyObject get_ModelParent();
    internal FrameworkElement get_ModelParentFE();
    internal void SetItemsSource(IEnumerable value, Func`2<object, object> GetSourceItem);
    internal void ClearItemsSource();
    internal IEnumerable get_ItemsSource();
    internal bool get_IsUsingItemsSource();
    internal CollectionView get_CollectionView();
    internal void BeginInit();
    internal void EndInit();
    internal IEnumerator get_LogicalChildren();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.Controls.ItemContainerGenerator : object {
    internal static DependencyProperty ItemForItemContainerProperty;
    public GeneratorStatus Status { get; }
    public ReadOnlyCollection`1<object> Items { get; }
    internal IEnumerable RecyclableContainers { get; }
    internal ItemContainerGenerator Parent { get; }
    internal int Level { get; }
    internal GroupStyle GroupStyle { get; internal set; }
    internal IList ItemsInternal { get; internal set; }
    internal ItemContainerGenerator(IGeneratorHost host);
    private static ItemContainerGenerator();
    public GeneratorStatus get_Status();
    public ReadOnlyCollection`1<object> get_Items();
    private sealed virtual override ItemContainerGenerator System.Windows.Controls.Primitives.IItemContainerGenerator.GetItemContainerGeneratorForPanel(Panel panel);
    private sealed virtual override IDisposable System.Windows.Controls.Primitives.IItemContainerGenerator.StartAt(GeneratorPosition position, GeneratorDirection direction);
    private sealed virtual override IDisposable System.Windows.Controls.Primitives.IItemContainerGenerator.StartAt(GeneratorPosition position, GeneratorDirection direction, bool allowStartAtRealizedItem);
    public IDisposable GenerateBatches();
    private sealed virtual override DependencyObject System.Windows.Controls.Primitives.IItemContainerGenerator.GenerateNext();
    private sealed virtual override DependencyObject System.Windows.Controls.Primitives.IItemContainerGenerator.GenerateNext(Boolean& isNewlyRealized);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.PrepareItemContainer(DependencyObject container);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.Remove(GeneratorPosition position, int count);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.RemoveAll();
    internal void RemoveAllInternal(bool saveRecycleQueue);
    private sealed virtual override void System.Windows.Controls.Primitives.IRecyclingItemContainerGenerator.Recycle(GeneratorPosition position, int count);
    private sealed virtual override GeneratorPosition System.Windows.Controls.Primitives.IItemContainerGenerator.GeneratorPositionFromIndex(int itemIndex);
    private sealed virtual override int System.Windows.Controls.Primitives.IItemContainerGenerator.IndexFromGeneratorPosition(GeneratorPosition position);
    public object ItemFromContainer(DependencyObject container);
    public DependencyObject ContainerFromItem(object item);
    public int IndexFromContainer(DependencyObject container);
    public int IndexFromContainer(DependencyObject container, bool returnLocalIndex);
    internal bool FindItem(Func`3<object, DependencyObject, bool> match, DependencyObject& container, Int32& itemIndex);
    public DependencyObject ContainerFromIndex(int index);
    [CompilerGeneratedAttribute]
public void add_ItemsChanged(ItemsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ItemsChanged(ItemsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StatusChanged(EventHandler value);
    internal IEnumerable get_RecyclableContainers();
    internal void Refresh();
    internal void Release();
    internal void Verify();
    internal void ChangeAlternationCount();
    internal ItemContainerGenerator get_Parent();
    internal int get_Level();
    internal GroupStyle get_GroupStyle();
    internal void set_GroupStyle(GroupStyle value);
    internal IList get_ItemsInternal();
    internal void set_ItemsInternal(IList value);
    [CompilerGeneratedAttribute]
internal void add_PanelChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PanelChanged(EventHandler value);
    internal void OnPanelChanged();
    internal static void LinkContainerToItem(DependencyObject container, object item);
    internal static void UnlinkContainerFromItem(DependencyObject container, object item, IGeneratorHost host);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
[DictionaryKeyPropertyAttribute("ItemContainerTemplateKey")]
public class System.Windows.Controls.ItemContainerTemplate : DataTemplate {
    public object ItemContainerTemplateKey { get; }
    public object get_ItemContainerTemplateKey();
}
public class System.Windows.Controls.ItemContainerTemplateKey : TemplateKey {
    public ItemContainerTemplateKey(object dataType);
}
public abstract class System.Windows.Controls.ItemContainerTemplateSelector : object {
    public virtual DataTemplate SelectTemplate(object item, ItemsControl parentItemsControl);
}
[DefaultEventAttribute("OnItemsChanged")]
[DefaultPropertyAttribute("Items")]
[ContentPropertyAttribute("Items")]
[StyleTypedPropertyAttribute]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ItemsControl : Control {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemsSourceProperty;
    internal static DependencyPropertyKey HasItemsPropertyKey;
    public static DependencyProperty HasItemsProperty;
    public static DependencyProperty DisplayMemberPathProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemStringFormatProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemBindingGroupProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemContainerStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemContainerStyleSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemsPanelProperty;
    public static DependencyProperty IsGroupingProperty;
    public static DependencyProperty GroupStyleSelectorProperty;
    public static DependencyProperty AlternationCountProperty;
    public static DependencyProperty AlternationIndexProperty;
    public static DependencyProperty IsTextSearchEnabledProperty;
    public static DependencyProperty IsTextSearchCaseSensitiveProperty;
    [DesignerSerializationVisibilityAttribute("2")]
[BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public ItemCollection Items { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public IEnumerable ItemsSource { get; public set; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("2")]
public ItemContainerGenerator ItemContainerGenerator { get; }
    protected internal IEnumerator LogicalChildren { get; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
public bool HasItems { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string DisplayMemberPath { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate ItemTemplate { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ItemTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ItemStringFormat { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public BindingGroup ItemBindingGroup { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
public Style ItemContainerStyle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public StyleSelector ItemContainerStyleSelector { get; public set; }
    [BindableAttribute("False")]
public ItemsPanelTemplate ItemsPanel { get; public set; }
    [BindableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsGrouping { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public ObservableCollection`1<GroupStyle> GroupStyle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public GroupStyleSelector GroupStyleSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public int AlternationCount { get; public set; }
    public bool IsTextSearchEnabled { get; public set; }
    public bool IsTextSearchCaseSensitive { get; public set; }
    private ItemCollection MS.Internal.Controls.IGeneratorHost.View { get; }
    private int MS.Internal.Controls.IGeneratorHost.AlternationCount { get; }
    internal Panel ItemsHost { get; internal set; }
    internal ItemInfo FocusedInfo { get; }
    internal bool IsLogicalVertical { get; }
    internal bool IsLogicalHorizontal { get; }
    internal ScrollViewer ScrollHost { get; }
    internal static TimeSpan AutoScrollTimeout { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ItemsControl();
    public ItemCollection get_Items();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeItems();
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public ItemContainerGenerator get_ItemContainerGenerator();
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    public bool get_HasItems();
    public string get_DisplayMemberPath();
    public void set_DisplayMemberPath(string value);
    protected virtual void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath);
    public DataTemplate get_ItemTemplate();
    public void set_ItemTemplate(DataTemplate value);
    protected virtual void OnItemTemplateChanged(DataTemplate oldItemTemplate, DataTemplate newItemTemplate);
    public DataTemplateSelector get_ItemTemplateSelector();
    public void set_ItemTemplateSelector(DataTemplateSelector value);
    protected virtual void OnItemTemplateSelectorChanged(DataTemplateSelector oldItemTemplateSelector, DataTemplateSelector newItemTemplateSelector);
    public string get_ItemStringFormat();
    public void set_ItemStringFormat(string value);
    protected virtual void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat);
    public BindingGroup get_ItemBindingGroup();
    public void set_ItemBindingGroup(BindingGroup value);
    protected virtual void OnItemBindingGroupChanged(BindingGroup oldItemBindingGroup, BindingGroup newItemBindingGroup);
    public Style get_ItemContainerStyle();
    public void set_ItemContainerStyle(Style value);
    protected virtual void OnItemContainerStyleChanged(Style oldItemContainerStyle, Style newItemContainerStyle);
    public StyleSelector get_ItemContainerStyleSelector();
    public void set_ItemContainerStyleSelector(StyleSelector value);
    protected virtual void OnItemContainerStyleSelectorChanged(StyleSelector oldItemContainerStyleSelector, StyleSelector newItemContainerStyleSelector);
    public static ItemsControl GetItemsOwner(DependencyObject element);
    internal static DependencyObject GetItemsOwnerInternal(DependencyObject element);
    internal static DependencyObject GetItemsOwnerInternal(DependencyObject element, ItemsControl& itemsControl);
    public ItemsPanelTemplate get_ItemsPanel();
    public void set_ItemsPanel(ItemsPanelTemplate value);
    protected virtual void OnItemsPanelChanged(ItemsPanelTemplate oldItemsPanel, ItemsPanelTemplate newItemsPanel);
    public bool get_IsGrouping();
    internal virtual void OnIsGroupingChanged(DependencyPropertyChangedEventArgs e);
    public ObservableCollection`1<GroupStyle> get_GroupStyle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupStyle();
    public GroupStyleSelector get_GroupStyleSelector();
    public void set_GroupStyleSelector(GroupStyleSelector value);
    protected virtual void OnGroupStyleSelectorChanged(GroupStyleSelector oldGroupStyleSelector, GroupStyleSelector newGroupStyleSelector);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    protected virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);
    public static int GetAlternationIndex(DependencyObject element);
    internal static void SetAlternationIndex(DependencyObject d, int value);
    internal static void ClearAlternationIndex(DependencyObject d);
    public bool get_IsTextSearchEnabled();
    public void set_IsTextSearchEnabled(bool value);
    public bool get_IsTextSearchCaseSensitive();
    public void set_IsTextSearchCaseSensitive(bool value);
    public static ItemsControl ItemsControlFromItemContainer(DependencyObject container);
    public static DependencyObject ContainerFromElement(ItemsControl itemsControl, DependencyObject element);
    public DependencyObject ContainerFromElement(DependencyObject element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    private sealed virtual override ItemCollection MS.Internal.Controls.IGeneratorHost.get_View();
    private sealed virtual override bool MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(object item);
    private sealed virtual override DependencyObject MS.Internal.Controls.IGeneratorHost.GetContainerForItem(object item);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.PrepareItemContainer(DependencyObject container, object item);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.ClearContainerForItem(DependencyObject container, object item);
    private sealed virtual override bool MS.Internal.Controls.IGeneratorHost.IsHostForItemContainer(DependencyObject container);
    private sealed virtual override GroupStyle MS.Internal.Controls.IGeneratorHost.GetGroupStyle(CollectionViewGroup group, int level);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.SetIsGrouping(bool isGrouping);
    private sealed virtual override int MS.Internal.Controls.IGeneratorHost.get_AlternationCount();
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool IsItemItsOwnContainer(object item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    internal void PrepareItemsControl(object item, ItemsControl parentItemsControl);
    internal void ClearItemsControl(object item);
    internal object OnBringItemIntoView(object arg);
    internal object OnBringItemIntoView(ItemInfo info);
    internal Panel get_ItemsHost();
    internal void set_ItemsHost(Panel value);
    internal bool NavigateByLine(FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal void PrepareNavigateByLine(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs, FrameworkElement& container);
    internal bool NavigateByLine(ItemInfo startingInfo, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByLine(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal void PrepareToNavigateByPage(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs, FrameworkElement& container);
    internal bool NavigateByPage(FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByPage(ItemInfo startingInfo, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByPage(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal void NavigateToStart(ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateToStartInternal(ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    internal void NavigateToEnd(ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateToEndInternal(ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    internal void NavigateToItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs, bool alwaysAtTopOfViewport);
    internal void NavigateToItem(object item, ItemNavigateArgs itemNavigateArgs);
    internal void NavigateToItem(object item, int itemIndex, ItemNavigateArgs itemNavigateArgs);
    internal void NavigateToItem(object item, ItemNavigateArgs itemNavigateArgs, bool alwaysAtTopOfViewport);
    internal void MakeVisible(FrameworkElement container, FocusNavigationDirection direction, bool alwaysAtTopOfViewport);
    internal FrameworkElement GetViewportElement();
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible, Rect& elementRect);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible, bool ignorePerpendicularAxis, Rect& elementRect);
    internal ItemInfo get_FocusedInfo();
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    internal bool get_IsLogicalVertical();
    internal bool get_IsLogicalHorizontal();
    internal ScrollViewer get_ScrollHost();
    internal static TimeSpan get_AutoScrollTimeout();
    internal void DoAutoScroll();
    internal void DoAutoScroll(ItemInfo startingInfo);
    internal static DependencyObject TryGetTreeViewItemHeader(DependencyObject element);
    internal object GetItemOrContainerFromContainer(DependencyObject container);
    internal static bool EqualsEx(object o1, object o2);
    internal ItemInfo NewItemInfo(object item, DependencyObject container, int index);
    internal ItemInfo ItemInfoFromContainer(DependencyObject container);
    internal ItemInfo ItemInfoFromIndex(int index);
    internal ItemInfo NewUnresolvedItemInfo(object item);
    internal DependencyObject ContainerFromItemInfo(ItemInfo info);
    internal void AdjustItemInfoAfterGeneratorChange(ItemInfo info);
    internal void AdjustItemInfosAfterGeneratorChange(IEnumerable`1<ItemInfo> list, bool claimUniqueContainer);
    internal void AdjustItemInfo(NotifyCollectionChangedEventArgs e, ItemInfo info);
    internal void AdjustItemInfos(NotifyCollectionChangedEventArgs e, IEnumerable`1<ItemInfo> list);
    internal ItemInfo LeaseItemInfo(ItemInfo info, bool ensureIndex);
    internal void RefreshItemInfo(ItemInfo info);
    private sealed virtual override object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, DependencyProperty dp, object value);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.Clear();
    public virtual string ToString();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ItemsPanelTemplate : FrameworkTemplate {
    internal Type TargetTypeInternal { get; }
    internal static Type DefaultTargetType { get; }
    public ItemsPanelTemplate(FrameworkElementFactory root);
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal static Type get_DefaultTargetType();
    internal virtual void ProcessTemplateBeforeSeal();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.ItemsPresenter : FrameworkElement {
    internal static DependencyProperty TemplateProperty;
    internal ItemsControl Owner { get; }
    internal ItemContainerGenerator Generator { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    private static ItemsPresenter();
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal ItemsControl get_Owner();
    internal ItemContainerGenerator get_Generator();
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnTemplateChanged(ItemsPanelTemplate oldTemplate, ItemsPanelTemplate newTemplate);
    internal static ItemsPresenter FromPanel(Panel panel);
    internal static ItemsPresenter FromGroupItem(GroupItem groupItem);
    internal virtual void OnAncestorChanged();
}
internal interface System.Windows.Controls.ITextBoxViewHost {
    public ITextContainer TextContainer { get; }
    public bool IsTypographyDefaultValue { get; }
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_IsTypographyDefaultValue();
}
[LocalizabilityAttribute("3")]
public class System.Windows.Controls.Label : ContentControl {
    public static DependencyProperty TargetProperty;
    [TypeConverterAttribute("System.Windows.Markup.NameReferenceConverter")]
public UIElement Target { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Label();
    public UIElement get_Target();
    public void set_Target(UIElement value);
    internal static Label GetLabeledBy(DependencyObject o);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("7")]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ListBox : Selector {
    public static DependencyProperty SelectionModeProperty;
    public static DependencyProperty SelectedItemsProperty;
    public SelectionMode SelectionMode { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public IList SelectedItems { get; }
    protected internal bool HandlesScrolling { get; }
    protected object AnchorItem { get; protected set; }
    internal ItemInfo AnchorItemInternal { get; internal set; }
    internal ListBoxItem LastActionItem { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ListBox();
    public void SelectAll();
    public void UnselectAll();
    public void ScrollIntoView(object item);
    public SelectionMode get_SelectionMode();
    public void set_SelectionMode(SelectionMode value);
    public IList get_SelectedItems();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected bool SetSelectedItems(IEnumerable selectedItems);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected internal virtual bool get_HandlesScrolling();
    internal void NotifyListItemClicked(ListBoxItem item, MouseButton mouseButton);
    internal void NotifyListItemMouseDragged(ListBoxItem listItem);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected object get_AnchorItem();
    protected void set_AnchorItem(object value);
    internal ItemInfo get_AnchorItemInternal();
    internal void set_AnchorItemInternal(ItemInfo value);
    internal ListBoxItem get_LastActionItem();
    internal void set_LastActionItem(ListBoxItem value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Selected")]
public class System.Windows.Controls.ListBoxItem : ContentControl {
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    internal Selector ParentSelector { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ListBoxItem();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    protected virtual void OnSelected(RoutedEventArgs e);
    protected virtual void OnUnselected(RoutedEventArgs e);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal Selector get_ParentSelector();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ListView : ListBox {
    public static DependencyProperty ViewProperty;
    public ViewBase View { get; public set; }
    private static ListView();
    public ViewBase get_View();
    public void set_View(ViewBase value);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual void OnThemeChanged();
}
public class System.Windows.Controls.ListViewItem : ListBoxItem {
    internal void SetDefaultStyleKey(object key);
    internal void ClearDefaultStyleKey();
}
internal class System.Windows.Controls.MatchedTextInfo : object {
    internal static MatchedTextInfo NoMatch { get; }
    internal string MatchedText { get; }
    internal int MatchedItemIndex { get; }
    internal int MatchedPrefixLength { get; }
    internal int TextExcludingPrefixLength { get; }
    private static MatchedTextInfo();
    internal MatchedTextInfo(int matchedItemIndex, string matchedText, int matchedPrefixLength, int textExcludingPrefixLength);
    internal static MatchedTextInfo get_NoMatch();
    internal string get_MatchedText();
    internal int get_MatchedItemIndex();
    internal int get_MatchedPrefixLength();
    internal int get_TextExcludingPrefixLength();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.MediaElement : FrameworkElement {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty VolumeProperty;
    public static DependencyProperty BalanceProperty;
    public static DependencyProperty IsMutedProperty;
    public static DependencyProperty ScrubbingEnabledProperty;
    public static DependencyProperty UnloadedBehaviorProperty;
    public static DependencyProperty LoadedBehaviorProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public static RoutedEvent MediaFailedEvent;
    public static RoutedEvent MediaOpenedEvent;
    public static RoutedEvent BufferingStartedEvent;
    public static RoutedEvent BufferingEndedEvent;
    public static RoutedEvent ScriptCommandEvent;
    public static RoutedEvent MediaEndedEvent;
    public Uri Source { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public MediaClock Clock { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    public double Volume { get; public set; }
    public double Balance { get; public set; }
    public bool IsMuted { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public MediaState UnloadedBehavior { get; public set; }
    public MediaState LoadedBehavior { get; public set; }
    public bool CanPause { get; }
    public bool IsBuffering { get; }
    public double DownloadProgress { get; }
    public double BufferingProgress { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public Duration NaturalDuration { get; }
    public TimeSpan Position { get; public set; }
    public double SpeedRatio { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal AVElementHelper Helper { get; }
    private static MediaElement();
    public Uri get_Source();
    public void set_Source(Uri value);
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    public void Play();
    public void Pause();
    public void Stop();
    public void Close();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    public double get_Volume();
    public void set_Volume(double value);
    public double get_Balance();
    public void set_Balance(double value);
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public MediaState get_UnloadedBehavior();
    public void set_UnloadedBehavior(MediaState value);
    public MediaState get_LoadedBehavior();
    public void set_LoadedBehavior(MediaState value);
    public bool get_CanPause();
    public bool get_IsBuffering();
    public double get_DownloadProgress();
    public double get_BufferingProgress();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public Duration get_NaturalDuration();
    public TimeSpan get_Position();
    public void set_Position(TimeSpan value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void add_MediaFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void remove_MediaFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void add_MediaOpened(RoutedEventHandler value);
    public void remove_MediaOpened(RoutedEventHandler value);
    public void add_BufferingStarted(RoutedEventHandler value);
    public void remove_BufferingStarted(RoutedEventHandler value);
    public void add_BufferingEnded(RoutedEventHandler value);
    public void remove_BufferingEnded(RoutedEventHandler value);
    public void add_ScriptCommand(EventHandler`1<MediaScriptCommandRoutedEventArgs> value);
    public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandRoutedEventArgs> value);
    public void add_MediaEnded(RoutedEventHandler value);
    public void remove_MediaEnded(RoutedEventHandler value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal AVElementHelper get_Helper();
    internal void OnMediaFailed(object sender, ExceptionEventArgs args);
    internal void OnMediaOpened(object sender, EventArgs args);
    internal void OnBufferingStarted(object sender, EventArgs args);
    internal void OnBufferingEnded(object sender, EventArgs args);
    internal void OnMediaEnded(object sender, EventArgs args);
    internal void OnScriptCommand(object sender, MediaScriptCommandEventArgs args);
}
public enum System.Windows.Controls.MediaState : Enum {
    public int value__;
    public static MediaState Manual;
    public static MediaState Play;
    public static MediaState Close;
    public static MediaState Pause;
    public static MediaState Stop;
}
public class System.Windows.Controls.Menu : MenuBase {
    public static DependencyProperty IsMainMenuProperty;
    public bool IsMainMenu { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Menu();
    public bool get_IsMainMenu();
    public void set_IsMainMenu(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnKeyDown(KeyEventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void HandleMouseButton(MouseButtonEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Click")]
[LocalizabilityAttribute("8")]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.MenuItem : HeaderedItemsControl {
    public static RoutedEvent ClickEvent;
    internal static RoutedEvent PreviewClickEvent;
    public static RoutedEvent CheckedEvent;
    public static RoutedEvent UncheckedEvent;
    public static RoutedEvent SubmenuOpenedEvent;
    public static RoutedEvent SubmenuClosedEvent;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    public static DependencyProperty IsSubmenuOpenProperty;
    public static DependencyProperty RoleProperty;
    public static DependencyProperty IsCheckableProperty;
    public static DependencyProperty IsPressedProperty;
    public static DependencyProperty IsHighlightedProperty;
    public static DependencyProperty IsCheckedProperty;
    public static DependencyProperty StaysOpenOnClickProperty;
    internal static DependencyProperty IsSelectedProperty;
    public static DependencyProperty InputGestureTextProperty;
    public static DependencyProperty IconProperty;
    public static DependencyProperty IsSuspendingPopupAnimationProperty;
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    internal static DependencyProperty InsideContextMenuProperty;
    public static ResourceKey TopLevelItemTemplateKey { get; }
    public static ResourceKey TopLevelHeaderTemplateKey { get; }
    public static ResourceKey SubmenuItemTemplateKey { get; }
    public static ResourceKey SubmenuHeaderTemplateKey { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    protected bool IsEnabledCore { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public object CommandParameter { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
public IInputElement CommandTarget { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsSubmenuOpen { get; public set; }
    [CategoryAttribute("Behavior")]
public MenuItemRole Role { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsCheckable { get; public set; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsPressed { get; protected set; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsHighlighted { get; protected set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsChecked { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpenOnClick { get; public set; }
    internal bool IsSelected { get; internal set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string InputGestureText { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public object Icon { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsSuspendingPopupAnimation { get; internal set; }
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    protected internal bool HandlesScrolling { get; }
    internal object LogicalParent { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    private static MenuItem();
    public static ResourceKey get_TopLevelItemTemplateKey();
    public static ResourceKey get_TopLevelHeaderTemplateKey();
    public static ResourceKey get_SubmenuItemTemplateKey();
    public static ResourceKey get_SubmenuHeaderTemplateKey();
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    public void add_Checked(RoutedEventHandler value);
    public void remove_Checked(RoutedEventHandler value);
    public void add_Unchecked(RoutedEventHandler value);
    public void remove_Unchecked(RoutedEventHandler value);
    public void add_SubmenuOpened(RoutedEventHandler value);
    public void remove_SubmenuOpened(RoutedEventHandler value);
    public void add_SubmenuClosed(RoutedEventHandler value);
    public void remove_SubmenuClosed(RoutedEventHandler value);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public bool get_IsSubmenuOpen();
    public void set_IsSubmenuOpen(bool value);
    protected virtual void OnSubmenuOpened(RoutedEventArgs e);
    protected virtual void OnSubmenuClosed(RoutedEventArgs e);
    public MenuItemRole get_Role();
    public bool get_IsCheckable();
    public void set_IsCheckable(bool value);
    public bool get_IsPressed();
    protected void set_IsPressed(bool value);
    public bool get_IsHighlighted();
    protected void set_IsHighlighted(bool value);
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    protected virtual void OnChecked(RoutedEventArgs e);
    protected virtual void OnUnchecked(RoutedEventArgs e);
    public bool get_StaysOpenOnClick();
    public void set_StaysOpenOnClick(bool value);
    internal bool get_IsSelected();
    internal void set_IsSelected(bool value);
    public string get_InputGestureText();
    public void set_InputGestureText(string value);
    public object get_Icon();
    public void set_Icon(object value);
    public bool get_IsSuspendingPopupAnimation();
    internal void set_IsSuspendingPopupAnimation(bool value);
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal static void PrepareMenuItem(DependencyObject element, object item);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnClick();
    [SecurityCriticalAttribute]
internal virtual void OnClickCore(bool userInitiated);
    [SecurityCriticalAttribute]
internal void OnClickImpl(bool userInitiated);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool get_HandlesScrolling();
    [SecurityCriticalAttribute]
protected virtual void OnKeyDown(KeyEventArgs e);
    [SecurityCriticalAttribute]
protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    public virtual void OnApplyTemplate();
    internal static void SetInsideContextMenuProperty(UIElement element, bool value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ClickItem();
    internal void ClickHeader();
    internal bool OpenMenu();
    internal void OpenSubmenuWithKeyboard();
    internal object get_LogicalParent();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
}
public enum System.Windows.Controls.MenuItemRole : Enum {
    public int value__;
    public static MenuItemRole TopLevelItem;
    public static MenuItemRole TopLevelHeader;
    public static MenuItemRole SubmenuItem;
    public static MenuItemRole SubmenuHeader;
}
public class System.Windows.Controls.MenuScrollingVisibilityConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Controls.MultipleCopiesCollection : object {
    internal object CopiedItem { get; internal set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal MultipleCopiesCollection(object item, int count);
    internal void MirrorCollectionChange(NotifyCollectionChangedEventArgs e);
    internal void SyncToCount(int newCount);
    internal object get_CopiedItem();
    internal void set_CopiedItem(object value);
    private void RemoveAt(int index);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public class System.Windows.Controls.NotifyDataErrorValidationRule : ValidationRule {
    internal static NotifyDataErrorValidationRule Instance;
    private static NotifyDataErrorValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.Controls.Orientation : Enum {
    public int value__;
    public static Orientation Horizontal;
    public static Orientation Vertical;
}
public enum System.Windows.Controls.OverflowMode : Enum {
    public int value__;
    public static OverflowMode AsNeeded;
    public static OverflowMode Always;
    public static OverflowMode Never;
}
[ContentPropertyAttribute("Content")]
public class System.Windows.Controls.Page : FrameworkElement {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TitleProperty;
    public static DependencyProperty KeepAliveProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty TemplateProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public object Content { get; public set; }
    private string System.Windows.IWindowService.Title { get; private set; }
    [LocalizabilityAttribute("2")]
public string WindowTitle { get; public set; }
    private double System.Windows.IWindowService.Height { get; private set; }
    public double WindowHeight { get; public set; }
    private double System.Windows.IWindowService.Width { get; private set; }
    public double WindowWidth { get; public set; }
    [CategoryAttribute("Appearance")]
public Brush Background { get; public set; }
    public string Title { get; public set; }
    public bool ShowsNavigationUI { get; public set; }
    public bool KeepAlive { get; public set; }
    public NavigationService NavigationService { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush Foreground { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public ControlTemplate Template { get; public set; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    private bool System.Windows.IWindowService.UserResized { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Page();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object obj);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string str);
    protected internal virtual IEnumerator get_LogicalChildren();
    public object get_Content();
    public void set_Content(object value);
    private sealed virtual override string System.Windows.IWindowService.get_Title();
    private sealed virtual override void System.Windows.IWindowService.set_Title(string value);
    public string get_WindowTitle();
    public void set_WindowTitle(string value);
    internal bool ShouldJournalWindowTitle();
    private sealed virtual override double System.Windows.IWindowService.get_Height();
    private sealed virtual override void System.Windows.IWindowService.set_Height(double value);
    public double get_WindowHeight();
    public void set_WindowHeight(double value);
    private sealed virtual override double System.Windows.IWindowService.get_Width();
    private sealed virtual override void System.Windows.IWindowService.set_Width(double value);
    public double get_WindowWidth();
    public void set_WindowWidth(double value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public string get_Title();
    public void set_Title(string value);
    public bool get_ShowsNavigationUI();
    public void set_ShowsNavigationUI(bool value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public NavigationService get_NavigationService();
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public ControlTemplate get_Template();
    public void set_Template(ControlTemplate value);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected internal sealed virtual void OnVisualParentChanged(DependencyObject oldParent);
    private sealed virtual override bool System.Windows.IWindowService.get_UserResized();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowTitle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowHeight();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowWidth();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTitle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeShowsNavigationUI();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.PageHelperObject : object {
    internal string _text;
    internal string _windowTitle;
    internal double _windowHeight;
    internal double _windowWidth;
    internal bool _showsNavigationUI;
}
public class System.Windows.Controls.PageRange : ValueType {
    private int _pageFrom;
    private int _pageTo;
    public int PageFrom { get; public set; }
    public int PageTo { get; public set; }
    public PageRange(int page);
    public PageRange(int pageFrom, int pageTo);
    public int get_PageFrom();
    public void set_PageFrom(int value);
    public int get_PageTo();
    public void set_PageTo(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(PageRange pageRange);
    public virtual int GetHashCode();
    public static bool op_Equality(PageRange pr1, PageRange pr2);
    public static bool op_Inequality(PageRange pr1, PageRange pr2);
}
public enum System.Windows.Controls.PageRangeSelection : Enum {
    public int value__;
    public static PageRangeSelection AllPages;
    public static PageRangeSelection UserPages;
    public static PageRangeSelection CurrentPage;
    public static PageRangeSelection SelectedPages;
}
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Controls.Panel : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    public static DependencyProperty IsItemsHostProperty;
    public static DependencyProperty ZIndexProperty;
    public Brush Background { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    [BindableAttribute("False")]
[CategoryAttribute("Behavior")]
public bool IsItemsHost { get; public set; }
    public Orientation LogicalOrientationPublic { get; }
    protected internal Orientation LogicalOrientation { get; }
    public bool HasLogicalOrientationPublic { get; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal UIElementCollection InternalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal IItemContainerGenerator Generator { get; }
    internal bool VSP_IsVirtualizing { get; internal set; }
    internal bool VSP_HasMeasured { get; internal set; }
    internal bool VSP_MustDisableVirtualization { get; internal set; }
    internal bool VSP_IsPixelBased { get; internal set; }
    internal bool VSP_InRecyclingMode { get; internal set; }
    internal bool VSP_MeasureCaches { get; internal set; }
    internal bool IsDataBound { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Panel();
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Brush get_Background();
    public void set_Background(Brush value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public UIElementCollection get_Children();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeChildren();
    public bool get_IsItemsHost();
    public void set_IsItemsHost(bool value);
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    public Orientation get_LogicalOrientationPublic();
    protected internal virtual Orientation get_LogicalOrientation();
    public bool get_HasLogicalOrientationPublic();
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal UIElementCollection get_InternalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    internal IItemContainerGenerator get_Generator();
    internal bool get_VSP_IsVirtualizing();
    internal void set_VSP_IsVirtualizing(bool value);
    internal bool get_VSP_HasMeasured();
    internal void set_VSP_HasMeasured(bool value);
    internal bool get_VSP_MustDisableVirtualization();
    internal void set_VSP_MustDisableVirtualization(bool value);
    internal bool get_VSP_IsPixelBased();
    internal void set_VSP_IsPixelBased(bool value);
    internal bool get_VSP_InRecyclingMode();
    internal void set_VSP_InRecyclingMode(bool value);
    internal bool get_VSP_MeasureCaches();
    internal void set_VSP_MeasureCaches(bool value);
    internal bool get_IsDataBound();
    internal static bool IsAboutToGenerateContent(Panel panel);
    internal void EnsureGenerator();
    internal virtual void OnClearChildrenInternal();
    internal virtual void GenerateChildren();
    private void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    internal virtual int get_EffectiveValuesInitialSize();
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    public static void SetZIndex(UIElement element, int value);
    public static int GetZIndex(UIElement element);
    internal void InvalidateZState();
}
public enum System.Windows.Controls.PanningMode : Enum {
    public int value__;
    public static PanningMode None;
    public static PanningMode HorizontalOnly;
    public static PanningMode VerticalOnly;
    public static PanningMode Both;
    public static PanningMode HorizontalFirst;
    public static PanningMode VerticalFirst;
}
[TemplatePartAttribute]
public class System.Windows.Controls.PasswordBox : Control {
    public static DependencyProperty PasswordCharProperty;
    public static DependencyProperty MaxLengthProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty CaretBrushProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedEvent PasswordChangedEvent;
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
public string Password { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public SecureString SecurePassword { get; }
    public char PasswordChar { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxLength { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public Brush CaretBrush { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal PasswordTextContainer TextContainer { get; }
    internal FrameworkElement RenderScope { get; }
    internal ScrollViewer ScrollViewer { get; }
    private ITextContainer System.Windows.Controls.ITextBoxViewHost.TextContainer { get; }
    private bool System.Windows.Controls.ITextBoxViewHost.IsTypographyDefaultValue { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static PasswordBox();
    public void Paste();
    public void SelectAll();
    public void Clear();
    [SecurityCriticalAttribute]
public string get_Password();
    [SecurityCriticalAttribute]
public void set_Password(string value);
    public SecureString get_SecurePassword();
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public Brush get_CaretBrush();
    public void set_CaretBrush(Brush value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    public void add_PasswordChanged(RoutedEventHandler value);
    public void remove_PasswordChanged(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    internal PasswordTextContainer get_TextContainer();
    internal FrameworkElement get_RenderScope();
    internal ScrollViewer get_ScrollViewer();
    private sealed virtual override ITextContainer System.Windows.Controls.ITextBoxViewHost.get_TextContainer();
    private sealed virtual override bool System.Windows.Controls.ITextBoxViewHost.get_IsTypographyDefaultValue();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.PasswordTextContainer : object {
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    internal ITextView TextView { get; internal set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal int SymbolCount { get; }
    internal char PasswordChar { get; }
    internal PasswordBox PasswordBox { get; }
    internal PasswordTextContainer(PasswordBox passwordBox);
    internal void InsertText(ITextPointer position, string textData);
    internal void DeleteContent(ITextPointer startPosition, ITextPointer endPosition);
    internal void BeginChange();
    internal void EndChange();
    internal void EndChange(bool skipEvents);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    internal void AddPosition(PasswordTextPointer position);
    internal void RemovePosition(PasswordTextPointer searchPosition);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal SecureString GetPasswordCopy();
    internal void SetPassword(SecureString value);
    internal int get_SymbolCount();
    internal char get_PasswordChar();
    internal PasswordBox get_PasswordBox();
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changed(TextContainerChangedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changed(TextContainerChangedEventHandler value);
}
internal class System.Windows.Controls.PasswordTextPointer : object {
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal PasswordTextContainer Container { get; }
    internal LogicalDirection LogicalDirection { get; }
    internal int Offset { get; internal set; }
    internal PasswordTextPointer(PasswordTextContainer container, LogicalDirection gravity, int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty formattingProperty);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty formattingProperty);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int distance);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal PasswordTextContainer get_Container();
    internal LogicalDirection get_LogicalDirection();
    internal int get_Offset();
    internal void set_Offset(int value);
}
internal class System.Windows.Controls.PopupControlService : object {
    internal static RoutedEvent ContextMenuOpenedEvent;
    internal static RoutedEvent ContextMenuClosedEvent;
    internal static DependencyProperty ServiceOwnedProperty;
    internal static DependencyProperty OwnerProperty;
    internal static PopupControlService Current { get; }
    internal ToolTip CurrentToolTip { get; }
    private static PopupControlService();
    internal bool StopLookingForToolTip(DependencyObject o);
    internal void OnRaiseToolTipOpeningEvent(object sender, EventArgs e);
    internal void OnRaiseToolTipClosingEvent(object sender, EventArgs e);
    internal static DependencyObject FindParent(DependencyObject o);
    internal static DependencyObject FindContentElementParent(ContentElement ce);
    internal static bool IsElementEnabled(DependencyObject o);
    internal static PopupControlService get_Current();
    internal ToolTip get_CurrentToolTip();
    internal static object CoerceProperty(DependencyObject o, object value, DependencyProperty dp);
}
public enum System.Windows.Controls.Primitives.AutoToolTipPlacement : Enum {
    public int value__;
    public static AutoToolTipPlacement None;
    public static AutoToolTipPlacement TopLeft;
    public static AutoToolTipPlacement BottomRight;
}
public class System.Windows.Controls.Primitives.BulletDecorator : Decorator {
    public static DependencyProperty BackgroundProperty;
    public Brush Background { get; public set; }
    public UIElement Bullet { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    private static BulletDecorator();
    public Brush get_Background();
    public void set_Background(Brush value);
    public UIElement get_Bullet();
    public void set_Bullet(UIElement value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnRender(DrawingContext dc);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
}
[DefaultEventAttribute("Click")]
[LocalizabilityAttribute("4")]
public abstract class System.Windows.Controls.Primitives.ButtonBase : ContentControl {
    public static RoutedEvent ClickEvent;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandParameterProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandTargetProperty;
    internal static DependencyPropertyKey IsPressedPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsPressedProperty;
    public static DependencyProperty ClickModeProperty;
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
public bool IsPressed { get; protected set; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    protected bool IsEnabledCore { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public object CommandParameter { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
public IInputElement CommandTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public ClickMode ClickMode { get; public set; }
    private static ButtonBase();
    protected virtual void OnClick();
    protected virtual void OnIsPressedChanged(DependencyPropertyChangedEventArgs e);
    internal void AutomationButtonBaseClick();
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    public bool get_IsPressed();
    protected void set_IsPressed(bool value);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public ClickMode get_ClickMode();
    public void set_ClickMode(ClickMode value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
}
public class System.Windows.Controls.Primitives.CalendarButton : Button {
    internal static DependencyPropertyKey HasSelectedDaysPropertyKey;
    public static DependencyProperty HasSelectedDaysProperty;
    internal static DependencyPropertyKey IsInactivePropertyKey;
    public static DependencyProperty IsInactiveProperty;
    public bool HasSelectedDays { get; internal set; }
    public bool IsInactive { get; internal set; }
    internal Calendar Owner { get; internal set; }
    private static CalendarButton();
    public bool get_HasSelectedDays();
    internal void set_HasSelectedDays(bool value);
    public bool get_IsInactive();
    internal void set_IsInactive(bool value);
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void SetContentInternal(string value);
}
public class System.Windows.Controls.Primitives.CalendarDayButton : Button {
    internal static DependencyPropertyKey IsTodayPropertyKey;
    public static DependencyProperty IsTodayProperty;
    internal static DependencyPropertyKey IsSelectedPropertyKey;
    public static DependencyProperty IsSelectedProperty;
    internal static DependencyPropertyKey IsInactivePropertyKey;
    public static DependencyProperty IsInactiveProperty;
    internal static DependencyPropertyKey IsBlackedOutPropertyKey;
    public static DependencyProperty IsBlackedOutProperty;
    internal static DependencyPropertyKey IsHighlightedPropertyKey;
    public static DependencyProperty IsHighlightedProperty;
    public bool IsToday { get; }
    public bool IsSelected { get; }
    public bool IsInactive { get; }
    public bool IsBlackedOut { get; }
    public bool IsHighlighted { get; }
    internal Calendar Owner { get; internal set; }
    private static CalendarDayButton();
    public bool get_IsToday();
    public bool get_IsSelected();
    public bool get_IsInactive();
    public bool get_IsBlackedOut();
    public bool get_IsHighlighted();
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void NotifyNeedsVisualStateUpdate();
    internal void SetContentInternal(string value);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.CalendarItem : Control {
    internal Grid MonthView { get; }
    internal Calendar Owner { get; internal set; }
    internal Grid YearView { get; }
    internal Button HeaderButton { get; }
    internal Button NextButton { get; }
    internal Button PreviousButton { get; }
    public static ComponentResourceKey DayTitleTemplateResourceKey { get; }
    private static CalendarItem();
    internal Grid get_MonthView();
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    internal Grid get_YearView();
    internal Button get_HeaderButton();
    internal Button get_NextButton();
    internal Button get_PreviousButton();
    public virtual void OnApplyTemplate();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal void UpdateDecadeMode();
    internal void UpdateMonthMode();
    internal void UpdateYearMode();
    [IteratorStateMachineAttribute("System.Windows.Controls.Primitives.CalendarItem/<GetCalendarDayButtons>d__51")]
internal IEnumerable`1<CalendarDayButton> GetCalendarDayButtons();
    internal CalendarDayButton GetFocusedCalendarDayButton();
    internal CalendarDayButton GetCalendarDayButton(DateTime date);
    internal CalendarButton GetCalendarButton(DateTime date, CalendarMode mode);
    internal CalendarButton GetFocusedCalendarButton();
    internal void FocusDate(DateTime date);
    public static ComponentResourceKey get_DayTitleTemplateResourceKey();
}
public class System.Windows.Controls.Primitives.CustomPopupPlacement : ValueType {
    private Point _point;
    private PopupPrimaryAxis _primaryAxis;
    public Point Point { get; public set; }
    public PopupPrimaryAxis PrimaryAxis { get; public set; }
    public CustomPopupPlacement(Point point, PopupPrimaryAxis primaryAxis);
    public Point get_Point();
    public void set_Point(Point value);
    public PopupPrimaryAxis get_PrimaryAxis();
    public void set_PrimaryAxis(PopupPrimaryAxis value);
    public static bool op_Equality(CustomPopupPlacement placement1, CustomPopupPlacement placement2);
    public static bool op_Inequality(CustomPopupPlacement placement1, CustomPopupPlacement placement2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class System.Windows.Controls.Primitives.CustomPopupPlacementCallback : MulticastDelegate {
    public CustomPopupPlacementCallback(object object, IntPtr method);
    public virtual CustomPopupPlacement[] Invoke(Size popupSize, Size targetSize, Point offset);
    public virtual IAsyncResult BeginInvoke(Size popupSize, Size targetSize, Point offset, AsyncCallback callback, object object);
    public virtual CustomPopupPlacement[] EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DataGridCellsPresenter : ItemsControl {
    public object Item { get; internal set; }
    internal Panel InternalItemsHost { get; internal set; }
    internal DataGrid DataGridOwner { get; }
    internal DataGridRow DataGridRowOwner { get; }
    internal ContainerTracking`1<DataGridCell> CellTrackingRoot { get; }
    private static DataGridCellsPresenter();
    public virtual void OnApplyTemplate();
    internal void SyncProperties(bool forcePrepareCells);
    public object get_Item();
    internal void set_Item(object value);
    protected virtual void OnItemChanged(object oldItem, object newItem);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    internal bool IsItemItsOwnContainerInternal(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected internal virtual void OnColumnsChanged(ObservableCollection`1<DataGridColumn> columns, NotifyCollectionChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void InvalidateDataGridCellsPanelMeasureAndArrange();
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    internal void ScrollCellIntoView(int index);
    internal DataGrid get_DataGridOwner();
    internal DataGridRow get_DataGridRowOwner();
    internal ContainerTracking`1<DataGridCell> get_CellTrackingRoot();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridColumnHeader : ButtonBase {
    public static DependencyProperty SeparatorBrushProperty;
    public static DependencyProperty SeparatorVisibilityProperty;
    public static DependencyProperty DisplayIndexProperty;
    public static DependencyProperty CanUserSortProperty;
    public static DependencyProperty SortDirectionProperty;
    public static DependencyProperty IsFrozenProperty;
    public DataGridColumn Column { get; }
    public Brush SeparatorBrush { get; public set; }
    public Visibility SeparatorVisibility { get; public set; }
    internal ContainerTracking`1<DataGridColumnHeader> Tracker { get; }
    public int DisplayIndex { get; }
    public bool CanUserSort { get; }
    public Nullable`1<ListSortDirection> SortDirection { get; }
    public bool IsFrozen { get; }
    internal DataGridColumnHeadersPresenter ParentPresenter { get; }
    internal bool SuppressClickEvent { get; internal set; }
    public static ComponentResourceKey ColumnHeaderDropSeparatorStyleKey { get; }
    public static ComponentResourceKey ColumnFloatingHeaderStyleKey { get; }
    private DataGridColumn System.Windows.Controls.IProvideDataGridColumn.Column { get; }
    private static DataGridColumnHeader();
    public DataGridColumn get_Column();
    public Brush get_SeparatorBrush();
    public void set_SeparatorBrush(Brush value);
    public Visibility get_SeparatorVisibility();
    public void set_SeparatorVisibility(Visibility value);
    internal void PrepareColumnHeader(object item, DataGridColumn column);
    internal void ClearHeader();
    internal ContainerTracking`1<DataGridColumnHeader> get_Tracker();
    public int get_DisplayIndex();
    public virtual void OnApplyTemplate();
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_CanUserSort();
    public Nullable`1<ListSortDirection> get_SortDirection();
    protected virtual void OnClick();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void Invoke();
    public bool get_IsFrozen();
    internal DataGridColumnHeadersPresenter get_ParentPresenter();
    internal bool get_SuppressClickEvent();
    internal void set_SuppressClickEvent(bool value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    public static ComponentResourceKey get_ColumnHeaderDropSeparatorStyleKey();
    public static ComponentResourceKey get_ColumnFloatingHeaderStyleKey();
    internal virtual void ChangeVisualState(bool useTransitions);
    private sealed virtual override DataGridColumn System.Windows.Controls.IProvideDataGridColumn.get_Column();
}
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridColumnHeadersPresenter : ItemsControl {
    internal Panel InternalItemsHost { get; internal set; }
    protected int VisualChildrenCount { get; }
    internal DataGrid ParentDataGrid { get; }
    internal ContainerTracking`1<DataGridColumnHeader> HeaderTrackingRoot { get; }
    private static DataGridColumnHeadersPresenter();
    public virtual void OnApplyTemplate();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    internal bool IsItemItsOwnContainerInternal(object item);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal void OnHeaderMouseLeftButtonDown(MouseButtonEventArgs e);
    internal void OnHeaderMouseMove(MouseEventArgs e);
    internal void OnHeaderMouseLeftButtonUp(MouseButtonEventArgs e);
    internal void OnHeaderLostMouseCapture(MouseEventArgs e);
    internal DataGrid get_ParentDataGrid();
    internal ContainerTracking`1<DataGridColumnHeader> get_HeaderTrackingRoot();
}
public class System.Windows.Controls.Primitives.DataGridDetailsPresenter : ContentPresenter {
    internal FrameworkElement DetailsElement { get; }
    internal DataGridRow DataGridRowOwner { get; }
    private static DataGridDetailsPresenter();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal FrameworkElement get_DetailsElement();
    internal void SyncProperties();
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal DataGridRow get_DataGridRowOwner();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridRowHeader : ButtonBase {
    public static DependencyProperty SeparatorBrushProperty;
    public static DependencyProperty SeparatorVisibilityProperty;
    public static DependencyProperty IsRowSelectedProperty;
    public Brush SeparatorBrush { get; public set; }
    public Visibility SeparatorVisibility { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsRowSelected { get; }
    internal DataGridRow ParentRow { get; }
    private static DataGridRowHeader();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Brush get_SeparatorBrush();
    public void set_SeparatorBrush(Brush value);
    public Visibility get_SeparatorVisibility();
    public void set_SeparatorVisibility(Visibility value);
    protected virtual Size MeasureOverride(Size availableSize);
    public virtual void OnApplyTemplate();
    internal void SyncProperties();
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    public bool get_IsRowSelected();
    protected virtual void OnClick();
    internal DataGridRow get_ParentRow();
}
public class System.Windows.Controls.Primitives.DataGridRowsPresenter : VirtualizingStackPanel {
    internal Size AvailableSize { get; }
    internal DataGrid Owner { get; }
    internal void InternalBringIndexIntoView(int index);
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize);
    protected virtual Size MeasureOverride(Size constraint);
    internal Size get_AvailableSize();
    protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e);
    internal DataGrid get_Owner();
}
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DatePickerTextBox : TextBox {
    internal static DependencyProperty WatermarkProperty;
    internal object Watermark { get; internal set; }
    private static DatePickerTextBox();
    internal object get_Watermark();
    internal void set_Watermark(object value);
    public virtual void OnApplyTemplate();
    protected virtual void OnGotFocus(RoutedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
}
public class System.Windows.Controls.Primitives.DocumentPageView : FrameworkElement {
    public static DependencyProperty PageNumberProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public DocumentPaginator DocumentPaginator { get; public set; }
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    protected bool IsDisposed { get; }
    protected int VisualChildrenCount { get; }
    internal bool UseAsynchronousGetPage { get; internal set; }
    internal DocumentPage DocumentPageInternal { get; }
    private static DocumentPageView();
    public DocumentPaginator get_DocumentPaginator();
    public void set_DocumentPaginator(DocumentPaginator value);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    [CompilerGeneratedAttribute]
public void add_PageConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PageDisconnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageDisconnected(EventHandler value);
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected sealed virtual Size MeasureOverride(Size availableSize);
    protected sealed virtual Size ArrangeOverride(Size finalSize);
    protected virtual Visual GetVisualChild(int index);
    protected void Dispose();
    protected object GetService(Type serviceType);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected bool get_IsDisposed();
    protected virtual int get_VisualChildrenCount();
    internal void SetPageZoom(double pageZoom);
    internal void SuspendLayout();
    internal void ResumeLayout();
    internal void DuplicateVisual();
    internal void RemoveDuplicateVisual();
    internal bool get_UseAsynchronousGetPage();
    internal void set_UseAsynchronousGetPage(bool value);
    internal DocumentPage get_DocumentPageInternal();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.IDisposable.Dispose();
}
[ContentPropertyAttribute("Document")]
public abstract class System.Windows.Controls.Primitives.DocumentViewerBase : Control {
    public static DependencyProperty DocumentProperty;
    protected static DependencyPropertyKey PageCountPropertyKey;
    public static DependencyProperty PageCountProperty;
    protected static DependencyPropertyKey MasterPageNumberPropertyKey;
    public static DependencyProperty MasterPageNumberProperty;
    protected static DependencyPropertyKey CanGoToPreviousPagePropertyKey;
    public static DependencyProperty CanGoToPreviousPageProperty;
    protected static DependencyPropertyKey CanGoToNextPagePropertyKey;
    public static DependencyProperty CanGoToNextPageProperty;
    public static DependencyProperty IsMasterPageProperty;
    public IDocumentPaginatorSource Document { get; public set; }
    public int PageCount { get; }
    public int MasterPageNumber { get; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    [CLSCompliantAttribute("False")]
public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool IsSelectionEnabled { get; internal set; }
    internal TextEditor TextEditor { get; }
    internal FrameworkElement TextEditorRenderScope { get; internal set; }
    private static DocumentViewerBase();
    public virtual void OnApplyTemplate();
    public void PreviousPage();
    public void NextPage();
    public void FirstPage();
    public void LastPage();
    public void GoToPage(int pageNumber);
    public void Print();
    public void CancelPrint();
    public virtual bool CanGoToPage(int pageNumber);
    public IDocumentPaginatorSource get_Document();
    public void set_Document(IDocumentPaginatorSource value);
    public int get_PageCount();
    public virtual int get_MasterPageNumber();
    public virtual bool get_CanGoToPreviousPage();
    public virtual bool get_CanGoToNextPage();
    public ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public static bool GetIsMasterPage(DependencyObject element);
    public static void SetIsMasterPage(DependencyObject element, bool value);
    [CompilerGeneratedAttribute]
public void add_PageViewsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageViewsChanged(EventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected void InvalidatePageViews();
    protected DocumentPageView GetMasterPageView();
    protected virtual ReadOnlyCollection`1<DocumentPageView> GetPageViewsCollection(Boolean& changed);
    protected virtual void OnPageViewsChanged();
    protected virtual void OnMasterPageNumberChanged();
    protected virtual void OnBringIntoView(DependencyObject element, Rect rect, int pageNumber);
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnDocumentChanged();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal bool IsMasterPageView(DocumentPageView pageView);
    internal ITextRange Find(FindToolBar findToolBar);
    internal bool get_IsSelectionEnabled();
    internal void set_IsSelectionEnabled(bool value);
    internal TextEditor get_TextEditor();
    internal FrameworkElement get_TextEditorRenderScope();
    internal void set_TextEditorRenderScope(FrameworkElement value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
public class System.Windows.Controls.Primitives.DragCompletedEventArgs : RoutedEventArgs {
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public bool Canceled { get; }
    public DragCompletedEventArgs(double horizontalChange, double verticalChange, bool canceled);
    public double get_HorizontalChange();
    public double get_VerticalChange();
    public bool get_Canceled();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragCompletedEventHandler : MulticastDelegate {
    public DragCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DragDeltaEventArgs : RoutedEventArgs {
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public DragDeltaEventArgs(double horizontalChange, double verticalChange);
    public double get_HorizontalChange();
    public double get_VerticalChange();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragDeltaEventHandler : MulticastDelegate {
    public DragDeltaEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragDeltaEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragDeltaEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DragStartedEventArgs : RoutedEventArgs {
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public DragStartedEventArgs(double horizontalOffset, double verticalOffset);
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragStartedEventHandler : MulticastDelegate {
    public DragStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.Primitives.GeneratorDirection : Enum {
    public int value__;
    public static GeneratorDirection Forward;
    public static GeneratorDirection Backward;
}
public class System.Windows.Controls.Primitives.GeneratorPosition : ValueType {
    private int _index;
    private int _offset;
    public int Index { get; public set; }
    public int Offset { get; public set; }
    public GeneratorPosition(int index, int offset);
    public int get_Index();
    public void set_Index(int value);
    public int get_Offset();
    public void set_Offset(int value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public static bool op_Equality(GeneratorPosition gp1, GeneratorPosition gp2);
    public static bool op_Inequality(GeneratorPosition gp1, GeneratorPosition gp2);
}
public enum System.Windows.Controls.Primitives.GeneratorStatus : Enum {
    public int value__;
    public static GeneratorStatus NotStarted;
    public static GeneratorStatus GeneratingContainers;
    public static GeneratorStatus ContainersGenerated;
    public static GeneratorStatus Error;
}
public abstract class System.Windows.Controls.Primitives.GridViewRowPresenterBase : FrameworkElement {
    public static DependencyProperty ColumnsProperty;
    internal static double c_PaddingHeaderMinWidth;
    public GridViewColumnCollection Columns { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal List`1<double> DesiredWidthList { get; private set; }
    internal bool NeedUpdateVisualTree { get; internal set; }
    internal UIElementCollection InternalChildren { get; }
    private static GridViewRowPresenterBase();
    public virtual string ToString();
    public GridViewColumnCollection get_Columns();
    public void set_Columns(GridViewColumnCollection value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal abstract virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal void EnsureDesiredWidthList();
    internal List`1<double> get_DesiredWidthList();
    private void set_DesiredWidthList(List`1<double> value);
    internal bool get_NeedUpdateVisualTree();
    internal void set_NeedUpdateVisualTree(bool value);
    internal UIElementCollection get_InternalChildren();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
}
public interface System.Windows.Controls.Primitives.IContainItemStorage {
    public abstract virtual void StoreItemValue(object item, DependencyProperty dp, object value);
    public abstract virtual object ReadItemValue(object item, DependencyProperty dp);
    public abstract virtual void ClearItemValue(object item, DependencyProperty dp);
    public abstract virtual void ClearValue(DependencyProperty dp);
    public abstract virtual void Clear();
}
public interface System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo {
    public HierarchicalVirtualizationConstraints Constraints { get; public set; }
    public HierarchicalVirtualizationHeaderDesiredSizes HeaderDesiredSizes { get; }
    public HierarchicalVirtualizationItemDesiredSizes ItemDesiredSizes { get; public set; }
    public Panel ItemsHost { get; }
    public bool MustDisableVirtualization { get; public set; }
    public bool InBackgroundLayout { get; public set; }
    public abstract virtual HierarchicalVirtualizationConstraints get_Constraints();
    public abstract virtual void set_Constraints(HierarchicalVirtualizationConstraints value);
    public abstract virtual HierarchicalVirtualizationHeaderDesiredSizes get_HeaderDesiredSizes();
    public abstract virtual HierarchicalVirtualizationItemDesiredSizes get_ItemDesiredSizes();
    public abstract virtual void set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    public abstract virtual Panel get_ItemsHost();
    public abstract virtual bool get_MustDisableVirtualization();
    public abstract virtual void set_MustDisableVirtualization(bool value);
    public abstract virtual bool get_InBackgroundLayout();
    public abstract virtual void set_InBackgroundLayout(bool value);
}
public interface System.Windows.Controls.Primitives.IItemContainerGenerator {
    public abstract virtual ItemContainerGenerator GetItemContainerGeneratorForPanel(Panel panel);
    public abstract virtual IDisposable StartAt(GeneratorPosition position, GeneratorDirection direction);
    public abstract virtual IDisposable StartAt(GeneratorPosition position, GeneratorDirection direction, bool allowStartAtRealizedItem);
    public abstract virtual DependencyObject GenerateNext();
    public abstract virtual DependencyObject GenerateNext(Boolean& isNewlyRealized);
    public abstract virtual void PrepareItemContainer(DependencyObject container);
    public abstract virtual void RemoveAll();
    public abstract virtual void Remove(GeneratorPosition position, int count);
    public abstract virtual GeneratorPosition GeneratorPositionFromIndex(int itemIndex);
    public abstract virtual int IndexFromGeneratorPosition(GeneratorPosition position);
}
internal class System.Windows.Controls.Primitives.InternalCollectionChangedEventManager : WeakEventManager {
    public static void AddListener(GridViewColumnCollection source, IWeakEventListener listener);
    public static void RemoveListener(GridViewColumnCollection source, IWeakEventListener listener);
    public static void AddHandler(GridViewColumnCollection source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void RemoveHandler(GridViewColumnCollection source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public interface System.Windows.Controls.Primitives.IRecyclingItemContainerGenerator {
    public abstract virtual void Recycle(GeneratorPosition position, int count);
}
public interface System.Windows.Controls.Primitives.IScrollInfo {
    public bool CanVerticallyScroll { get; public set; }
    public bool CanHorizontallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public abstract virtual void LineUp();
    public abstract virtual void LineDown();
    public abstract virtual void LineLeft();
    public abstract virtual void LineRight();
    public abstract virtual void PageUp();
    public abstract virtual void PageDown();
    public abstract virtual void PageLeft();
    public abstract virtual void PageRight();
    public abstract virtual void MouseWheelUp();
    public abstract virtual void MouseWheelDown();
    public abstract virtual void MouseWheelLeft();
    public abstract virtual void MouseWheelRight();
    public abstract virtual void SetHorizontalOffset(double offset);
    public abstract virtual void SetVerticalOffset(double offset);
    public abstract virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public abstract virtual bool get_CanVerticallyScroll();
    public abstract virtual void set_CanVerticallyScroll(bool value);
    public abstract virtual bool get_CanHorizontallyScroll();
    public abstract virtual void set_CanHorizontallyScroll(bool value);
    public abstract virtual double get_ExtentWidth();
    public abstract virtual double get_ExtentHeight();
    public abstract virtual double get_ViewportWidth();
    public abstract virtual double get_ViewportHeight();
    public abstract virtual double get_HorizontalOffset();
    public abstract virtual double get_VerticalOffset();
    public abstract virtual ScrollViewer get_ScrollOwner();
    public abstract virtual void set_ScrollOwner(ScrollViewer value);
}
public class System.Windows.Controls.Primitives.ItemsChangedEventArgs : EventArgs {
    public NotifyCollectionChangedAction Action { get; }
    public GeneratorPosition Position { get; }
    public GeneratorPosition OldPosition { get; }
    public int ItemCount { get; }
    public int ItemUICount { get; }
    internal ItemsChangedEventArgs(NotifyCollectionChangedAction action, GeneratorPosition position, GeneratorPosition oldPosition, int itemCount, int itemUICount);
    internal ItemsChangedEventArgs(NotifyCollectionChangedAction action, GeneratorPosition position, int itemCount, int itemUICount);
    public NotifyCollectionChangedAction get_Action();
    public GeneratorPosition get_Position();
    public GeneratorPosition get_OldPosition();
    public int get_ItemCount();
    public int get_ItemUICount();
}
public class System.Windows.Controls.Primitives.ItemsChangedEventHandler : MulticastDelegate {
    public ItemsChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ItemsChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ItemsChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.Primitives.LayoutInformation : object {
    public static Rect GetLayoutSlot(FrameworkElement element);
    public static Geometry GetLayoutClip(FrameworkElement element);
    public static UIElement GetLayoutExceptionElement(Dispatcher dispatcher);
}
[LocalizabilityAttribute("8")]
[StyleTypedPropertyAttribute]
public abstract class System.Windows.Controls.Primitives.MenuBase : ItemsControl {
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    internal static RoutedEvent IsSelectedChangedEvent;
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    internal MenuItem CurrentSelection { get; internal set; }
    internal bool HasCapture { get; }
    internal bool IgnoreNextLeftRelease { get; internal set; }
    internal bool IgnoreNextRightRelease { get; internal set; }
    internal bool IsMenuMode { get; internal set; }
    internal bool OpenOnMouseEnter { get; internal set; }
    private static MenuBase();
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    protected virtual void HandleMouseButton(MouseButtonEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal static bool IsDescendant(DependencyObject reference, DependencyObject node);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    internal void add_InternalMenuModeChanged(EventHandler value);
    internal void remove_InternalMenuModeChanged(EventHandler value);
    internal static void SetSuspendingPopupAnimation(ItemsControl menu, MenuItem ignore, bool suspend);
    internal void KeyboardLeaveMenuMode();
    internal MenuItem get_CurrentSelection();
    internal void set_CurrentSelection(MenuItem value);
    internal bool get_HasCapture();
    internal bool get_IgnoreNextLeftRelease();
    internal void set_IgnoreNextLeftRelease(bool value);
    internal bool get_IgnoreNextRightRelease();
    internal void set_IgnoreNextRightRelease(bool value);
    internal bool get_IsMenuMode();
    internal void set_IsMenuMode(bool value);
    internal bool get_OpenOnMouseEnter();
    internal void set_OpenOnMouseEnter(bool value);
}
public abstract class System.Windows.Controls.Primitives.MultiSelector : Selector {
    protected bool CanSelectMultipleItems { get; protected set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public IList SelectedItems { get; }
    protected bool IsUpdatingSelectedItems { get; }
    protected bool get_CanSelectMultipleItems();
    protected void set_CanSelectMultipleItems(bool value);
    public IList get_SelectedItems();
    protected void BeginUpdateSelectedItems();
    protected void EndUpdateSelectedItems();
    protected bool get_IsUpdatingSelectedItems();
    public void SelectAll();
    public void UnselectAll();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.Controls.Primitives.PlacementMode : Enum {
    public int value__;
    public static PlacementMode Absolute;
    public static PlacementMode Relative;
    public static PlacementMode Bottom;
    public static PlacementMode Center;
    public static PlacementMode Right;
    public static PlacementMode AbsolutePoint;
    public static PlacementMode RelativePoint;
    public static PlacementMode Mouse;
    public static PlacementMode MousePoint;
    public static PlacementMode Left;
    public static PlacementMode Top;
    public static PlacementMode Custom;
}
[DefaultEventAttribute("Opened")]
[DefaultPropertyAttribute("Child")]
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.Primitives.Popup : FrameworkElement {
    public static DependencyProperty ChildProperty;
    internal static UncommonField`1<List`1<Popup>> RegisteredPopupsField;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsOpenProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PlacementProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PopupAnimationProperty;
    public static DependencyProperty AllowsTransparencyProperty;
    public static DependencyProperty HasDropShadowProperty;
    internal static double Tolerance;
    internal static TimeSpan AnimationDelayTime;
    internal static RoutedEventHandler CloseOnUnloadedHandler;
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public UIElement Child { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double HorizontalOffset { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double VerticalOffset { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[DesignerSerializationVisibilityAttribute("0")]
public UIElement PlacementTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Rect PlacementRectangle { get; public set; }
    internal bool DropOpposite { get; internal set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public PopupAnimation PopupAnimation { get; public set; }
    public bool AllowsTransparency { get; public set; }
    public bool HasDropShadow { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal Exception SavedException { get; internal set; }
    internal bool HitTestable { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Popup();
    public UIElement get_Child();
    public void set_Child(UIElement value);
    internal virtual void pushTextRenderingMode();
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    protected virtual void OnOpened(EventArgs e);
    protected virtual void OnClosed(EventArgs e);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    internal bool get_DropOpposite();
    internal void set_DropOpposite(bool value);
    public PopupAnimation get_PopupAnimation();
    public void set_PopupAnimation(PopupAnimation value);
    public bool get_AllowsTransparency();
    public void set_AllowsTransparency(bool value);
    public bool get_HasDropShadow();
    public static void CreateRootPopup(Popup popup, UIElement child);
    internal static bool IsRootedInPopup(Popup parentPopup, UIElement element);
    public void add_Opened(EventHandler value);
    public void remove_Opened(EventHandler value);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_PopupCouldClose(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PopupCouldClose(EventHandler value);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void OnThemeChanged();
    internal virtual bool BlockReverseInheritance();
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal void ForceClose();
    internal Exception get_SavedException();
    internal void set_SavedException(Exception value);
    internal void Reposition();
    internal Size RestrictSize(Size desiredSize);
    internal bool get_HitTestable();
    internal void set_HitTestable(bool value);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Controls.Primitives.PopupAnimation : Enum {
    public int value__;
    public static PopupAnimation None;
    public static PopupAnimation Fade;
    public static PopupAnimation Slide;
    public static PopupAnimation Scroll;
}
public enum System.Windows.Controls.Primitives.PopupPrimaryAxis : Enum {
    public int value__;
    public static PopupPrimaryAxis None;
    public static PopupPrimaryAxis Horizontal;
    public static PopupPrimaryAxis Vertical;
}
internal class System.Windows.Controls.Primitives.PopupRoot : FrameworkElement {
    protected int VisualChildrenCount { get; }
    internal UIElement Child { get; internal set; }
    internal Vector AnimationOffset { get; }
    unknown Transform Transform {internal set; }
    private static PopupRoot();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal UIElement get_Child();
    internal void set_Child(UIElement value);
    internal Vector get_AnimationOffset();
    internal void set_Transform(Transform value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal void SetupLayoutBindings(Popup popup);
    internal void SetupFadeAnimation(Duration duration, bool visible);
    internal void SetupTranslateAnimations(PopupAnimation animationType, Duration duration, bool animateFromRight, bool animateFromBottom);
    internal void StopAnimations();
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
}
[DefaultEventAttribute("ValueChanged")]
[DefaultPropertyAttribute("Value")]
public abstract class System.Windows.Controls.Primitives.RangeBase : Control {
    public static RoutedEvent ValueChangedEvent;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty LargeChangeProperty;
    public static DependencyProperty SmallChangeProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Minimum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Maximum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Value { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double LargeChange { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double SmallChange { get; public set; }
    private static RangeBase();
    public void add_ValueChanged(RoutedPropertyChangedEventHandler`1<double> value);
    public void remove_ValueChanged(RoutedPropertyChangedEventHandler`1<double> value);
    public double get_Minimum();
    public void set_Minimum(double value);
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    public double get_Maximum();
    public void set_Maximum(double value);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    internal static object ConstrainToRange(DependencyObject d, object value);
    public double get_Value();
    public void set_Value(double value);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    public double get_LargeChange();
    public void set_LargeChange(double value);
    public double get_SmallChange();
    public void set_SmallChange(double value);
    internal virtual void ChangeVisualState(bool useTransitions);
    public virtual string ToString();
}
internal enum System.Windows.Controls.Primitives.RelativeHeaderPosition : Enum {
    public int value__;
    public static RelativeHeaderPosition Top;
    public static RelativeHeaderPosition Bottom;
    public static RelativeHeaderPosition Left;
    public static RelativeHeaderPosition Right;
}
public class System.Windows.Controls.Primitives.RepeatButton : ButtonBase {
    public static DependencyProperty DelayProperty;
    public static DependencyProperty IntervalProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Delay { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Interval { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RepeatButton();
    public int get_Delay();
    public void set_Delay(int value);
    public int get_Interval();
    public void set_Interval(int value);
    internal static int GetKeyboardDelay();
    internal static int GetKeyboardSpeed();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.ResizeGrip : Control {
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ResizeGrip();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("17")]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.ScrollBar : RangeBase {
    public static RoutedEvent ScrollEvent;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty ViewportSizeProperty;
    public static RoutedCommand LineUpCommand;
    public static RoutedCommand LineDownCommand;
    public static RoutedCommand LineLeftCommand;
    public static RoutedCommand LineRightCommand;
    public static RoutedCommand PageUpCommand;
    public static RoutedCommand PageDownCommand;
    public static RoutedCommand PageLeftCommand;
    public static RoutedCommand PageRightCommand;
    public static RoutedCommand ScrollToEndCommand;
    public static RoutedCommand ScrollToHomeCommand;
    public static RoutedCommand ScrollToRightEndCommand;
    public static RoutedCommand ScrollToLeftEndCommand;
    public static RoutedCommand ScrollToTopCommand;
    public static RoutedCommand ScrollToBottomCommand;
    public static RoutedCommand ScrollToHorizontalOffsetCommand;
    public static RoutedCommand ScrollToVerticalOffsetCommand;
    public static RoutedCommand DeferScrollToHorizontalOffsetCommand;
    public static RoutedCommand DeferScrollToVerticalOffsetCommand;
    public static RoutedCommand ScrollHereCommand;
    public Orientation Orientation { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public double ViewportSize { get; public set; }
    public Track Track { get; }
    protected bool IsEnabledCore { get; }
    internal bool IsStandalone { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ScrollBar();
    public void add_Scroll(ScrollEventHandler value);
    public void remove_Scroll(ScrollEventHandler value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public double get_ViewportSize();
    public void set_ViewportSize(double value);
    public Track get_Track();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual bool get_IsEnabledCore();
    public virtual void OnApplyTemplate();
    internal void ScrollToLastMousePoint();
    internal void RaiseScrollEvent(ScrollEventType scrollEventType);
    internal static bool IsValidOrientation(object o);
    internal bool get_IsStandalone();
    internal void set_IsStandalone(bool value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Controls.Primitives.ScrollEventArgs : RoutedEventArgs {
    public ScrollEventType ScrollEventType { get; }
    public double NewValue { get; }
    public ScrollEventArgs(ScrollEventType scrollEventType, double newValue);
    public ScrollEventType get_ScrollEventType();
    public double get_NewValue();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.ScrollEventHandler : MulticastDelegate {
    public ScrollEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScrollEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScrollEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.Primitives.ScrollEventType : Enum {
    public int value__;
    public static ScrollEventType EndScroll;
    public static ScrollEventType First;
    public static ScrollEventType LargeDecrement;
    public static ScrollEventType LargeIncrement;
    public static ScrollEventType Last;
    public static ScrollEventType SmallDecrement;
    public static ScrollEventType SmallIncrement;
    public static ScrollEventType ThumbPosition;
    public static ScrollEventType ThumbTrack;
}
public class System.Windows.Controls.Primitives.SelectiveScrollingGrid : Grid {
    public static DependencyProperty SelectiveScrollingOrientationProperty;
    private static SelectiveScrollingGrid();
    public static SelectiveScrollingOrientation GetSelectiveScrollingOrientation(DependencyObject obj);
    public static void SetSelectiveScrollingOrientation(DependencyObject obj, SelectiveScrollingOrientation value);
}
[DefaultEventAttribute("SelectionChanged")]
[DefaultPropertyAttribute("SelectedIndex")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Controls.Primitives.Selector : ItemsControl {
    public static RoutedEvent SelectionChangedEvent;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    internal static DependencyPropertyKey IsSelectionActivePropertyKey;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty IsSynchronizedWithCurrentItemProperty;
    public static DependencyProperty SelectedIndexProperty;
    public static DependencyProperty SelectedItemProperty;
    public static DependencyProperty SelectedValueProperty;
    public static DependencyProperty SelectedValuePathProperty;
    internal static DependencyProperty SelectedItemsImplProperty;
    internal InternalSelectedItemsStorage _selectedItems;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
[TypeConverterAttribute("System.Windows.NullableBoolConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[LocalizabilityAttribute("17")]
public Nullable`1<bool> IsSynchronizedWithCurrentItem { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public int SelectedIndex { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedItem { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public object SelectedValue { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("17")]
public string SelectedValuePath { get; public set; }
    internal IList SelectedItemsImpl { get; }
    internal bool CanSelectMultiple { get; internal set; }
    internal SelectionChanger SelectionChange { get; }
    internal object InternalSelectedItem { get; }
    internal ItemInfo InternalSelectedInfo { get; }
    internal int InternalSelectedIndex { get; }
    private static Selector();
    public void add_SelectionChanged(SelectionChangedEventHandler value);
    public void remove_SelectionChanged(SelectionChangedEventHandler value);
    public static void AddSelectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveSelectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddUnselectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveUnselectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static bool GetIsSelectionActive(DependencyObject element);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static bool GetIsSelected(DependencyObject element);
    public static void SetIsSelected(DependencyObject element, bool isSelected);
    public Nullable`1<bool> get_IsSynchronizedWithCurrentItem();
    public void set_IsSynchronizedWithCurrentItem(Nullable`1<bool> value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public object get_SelectedItem();
    public void set_SelectedItem(object value);
    public object get_SelectedValue();
    public void set_SelectedValue(object value);
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    internal IList get_SelectedItemsImpl();
    internal bool SetSelectedItemsImpl(IEnumerable selectedItems);
    internal bool get_CanSelectMultiple();
    internal void set_CanSelectMultiple(bool value);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    internal void RaiseIsSelectedChangedAutomationEvent(DependencyObject container, bool isSelected);
    internal void SetInitialMousePosition();
    internal bool DidMouseMove();
    internal void ResetLastMousePosition();
    internal virtual void SelectAllImpl();
    internal virtual void UnselectAllImpl();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnInitialized(EventArgs e);
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    internal void FinishSelectedItemsChange();
    internal void UpdatePublicSelectionProperties();
    internal static bool ItemGetIsSelectable(object item);
    internal static bool UiGetIsSelectable(DependencyObject o);
    internal void NotifyIsSelectedChanged(FrameworkElement container, bool selected, RoutedEventArgs e);
    internal SelectionChanger get_SelectionChange();
    internal void LocateSelectedItems(List`1<Tuple`2<int, int>> ranges, bool deselectMissingItems);
    internal object get_InternalSelectedItem();
    internal ItemInfo get_InternalSelectedInfo();
    internal int get_InternalSelectedIndex();
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.Primitives.StatusBar : ItemsControl {
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    private static StatusBar();
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
}
[LocalizabilityAttribute("15")]
public class System.Windows.Controls.Primitives.StatusBarItem : ContentControl {
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static StatusBarItem();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.TabPanel : Panel {
    private static TabPanel();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
}
[LocalizabilityAttribute("1")]
[TemplatePartAttribute]
public abstract class System.Windows.Controls.Primitives.TextBoxBase : Control {
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsReadOnlyCaretVisibleProperty;
    public static DependencyProperty AcceptsReturnProperty;
    public static DependencyProperty AcceptsTabProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public static DependencyProperty IsUndoEnabledProperty;
    public static DependencyProperty UndoLimitProperty;
    public static DependencyProperty AutoWordSelectionProperty;
    public static DependencyProperty SelectionBrushProperty;
    internal static double AdornerSelectionOpacityDefaultValue;
    internal static double NonAdornerSelectionOpacityDefaultValue;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty CaretBrushProperty;
    internal static DependencyPropertyKey IsSelectionActivePropertyKey;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedEvent TextChangedEvent;
    public static RoutedEvent SelectionChangedEvent;
    internal static string ContentHostTemplateName;
    public bool IsReadOnly { get; public set; }
    public bool IsReadOnlyCaretVisible { get; public set; }
    public bool AcceptsReturn { get; public set; }
    public bool AcceptsTab { get; public set; }
    public SpellCheck SpellCheck { get; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public bool CanUndo { get; }
    public bool CanRedo { get; }
    public bool IsUndoEnabled { get; public set; }
    public int UndoLimit { get; public set; }
    public bool AutoWordSelection { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public Brush CaretBrush { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal ScrollViewer ScrollViewer { get; }
    internal TextSelection TextSelectionInternal { get; }
    internal TextContainer TextContainer { get; }
    internal FrameworkElement RenderScope { get; }
    internal UndoAction PendingUndoAction { get; internal set; }
    internal TextEditor TextEditor { get; }
    internal bool IsContentHostAvailable { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TextBoxBase();
    public void AppendText(string textData);
    public virtual void OnApplyTemplate();
    [SecurityCriticalAttribute]
public void Copy();
    [SecurityCriticalAttribute]
public void Cut();
    public void Paste();
    public void SelectAll();
    public void LineLeft();
    public void LineRight();
    public void PageLeft();
    public void PageRight();
    public void LineUp();
    public void LineDown();
    public void PageUp();
    public void PageDown();
    public void ScrollToHome();
    public void ScrollToEnd();
    public void ScrollToHorizontalOffset(double offset);
    public void ScrollToVerticalOffset(double offset);
    public bool Undo();
    public bool Redo();
    public void LockCurrentUndoUnit();
    public void BeginChange();
    public void EndChange();
    public IDisposable DeclareChangeBlock();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public bool get_IsReadOnlyCaretVisible();
    public void set_IsReadOnlyCaretVisible(bool value);
    public bool get_AcceptsReturn();
    public void set_AcceptsReturn(bool value);
    public bool get_AcceptsTab();
    public void set_AcceptsTab(bool value);
    public SpellCheck get_SpellCheck();
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    public bool get_CanUndo();
    public bool get_CanRedo();
    public bool get_IsUndoEnabled();
    public void set_IsUndoEnabled(bool value);
    public int get_UndoLimit();
    public void set_UndoLimit(int value);
    public bool get_AutoWordSelection();
    public void set_AutoWordSelection(bool value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public Brush get_CaretBrush();
    public void set_CaretBrush(Brush value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    public void add_TextChanged(TextChangedEventHandler value);
    public void remove_TextChanged(TextChangedEventHandler value);
    public void add_SelectionChanged(RoutedEventHandler value);
    public void remove_SelectionChanged(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    protected virtual void OnSelectionChanged(RoutedEventArgs e);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    internal abstract virtual FrameworkElement CreateRenderScope();
    internal virtual void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    internal void InitializeTextContainer(TextContainer textContainer);
    internal TextPointer GetTextPositionFromPointInternal(Point point, bool snapToText);
    internal bool GetRectangleFromTextPosition(TextPointer position, Rect& rect);
    internal virtual void AttachToVisualTree();
    internal virtual void DoLineUp();
    internal virtual void DoLineDown();
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    internal void ChangeUndoEnabled(bool value);
    internal void ChangeUndoLimit(object value);
    internal ScrollViewer get_ScrollViewer();
    internal TextSelection get_TextSelectionInternal();
    internal TextContainer get_TextContainer();
    internal FrameworkElement get_RenderScope();
    internal UndoAction get_PendingUndoAction();
    internal void set_PendingUndoAction(UndoAction value);
    internal TextEditor get_TextEditor();
    internal bool get_IsContentHostAvailable();
    internal virtual void OnScrollChanged(object sender, ScrollChangedEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnScrollViewerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[DefaultEventAttribute("DragDelta")]
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.Primitives.Thumb : Control {
    public static RoutedEvent DragStartedEvent;
    public static RoutedEvent DragDeltaEvent;
    public static RoutedEvent DragCompletedEvent;
    public static DependencyProperty IsDraggingProperty;
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsDragging { get; protected set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Thumb();
    public void add_DragStarted(DragStartedEventHandler value);
    public void remove_DragStarted(DragStartedEventHandler value);
    public void add_DragDelta(DragDeltaEventHandler value);
    public void remove_DragDelta(DragDeltaEventHandler value);
    public void add_DragCompleted(DragCompletedEventHandler value);
    public void remove_DragCompleted(DragCompletedEventHandler value);
    public bool get_IsDragging();
    protected void set_IsDragging(bool value);
    public void CancelDrag();
    protected virtual void OnDraggingChanged(DependencyPropertyChangedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Primitives.TickBar : FrameworkElement {
    public static DependencyProperty FillProperty;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty SelectionStartProperty;
    public static DependencyProperty SelectionEndProperty;
    public static DependencyProperty IsSelectionRangeEnabledProperty;
    public static DependencyProperty TickFrequencyProperty;
    public static DependencyProperty TicksProperty;
    public static DependencyProperty IsDirectionReversedProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ReservedSpaceProperty;
    public Brush Fill { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double Minimum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double Maximum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionStart { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionEnd { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelectionRangeEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double TickFrequency { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public DoubleCollection Ticks { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsDirectionReversed { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public TickBarPlacement Placement { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double ReservedSpace { get; public set; }
    private static TickBar();
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public double get_Minimum();
    public void set_Minimum(double value);
    public double get_Maximum();
    public void set_Maximum(double value);
    public double get_SelectionStart();
    public void set_SelectionStart(double value);
    public double get_SelectionEnd();
    public void set_SelectionEnd(double value);
    public bool get_IsSelectionRangeEnabled();
    public void set_IsSelectionRangeEnabled(bool value);
    public double get_TickFrequency();
    public void set_TickFrequency(double value);
    public DoubleCollection get_Ticks();
    public void set_Ticks(DoubleCollection value);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    public TickBarPlacement get_Placement();
    public void set_Placement(TickBarPlacement value);
    public double get_ReservedSpace();
    public void set_ReservedSpace(double value);
    protected virtual void OnRender(DrawingContext dc);
    internal virtual void OnPreApplyTemplate();
}
public enum System.Windows.Controls.Primitives.TickBarPlacement : Enum {
    public int value__;
    public static TickBarPlacement Left;
    public static TickBarPlacement Top;
    public static TickBarPlacement Right;
    public static TickBarPlacement Bottom;
}
public enum System.Windows.Controls.Primitives.TickPlacement : Enum {
    public int value__;
    public static TickPlacement None;
    public static TickPlacement TopLeft;
    public static TickPlacement BottomRight;
    public static TickPlacement Both;
}
[DefaultEventAttribute("Checked")]
public class System.Windows.Controls.Primitives.ToggleButton : ButtonBase {
    public static RoutedEvent CheckedEvent;
    public static RoutedEvent UncheckedEvent;
    public static RoutedEvent IndeterminateEvent;
    public static DependencyProperty IsCheckedProperty;
    public static DependencyProperty IsThreeStateProperty;
    [CategoryAttribute("Appearance")]
[TypeConverterAttribute("System.Windows.NullableBoolConverter")]
[LocalizabilityAttribute("0")]
public Nullable`1<bool> IsChecked { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsThreeState { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToggleButton();
    public void add_Checked(RoutedEventHandler value);
    public void remove_Checked(RoutedEventHandler value);
    public void add_Unchecked(RoutedEventHandler value);
    public void remove_Unchecked(RoutedEventHandler value);
    public void add_Indeterminate(RoutedEventHandler value);
    public void remove_Indeterminate(RoutedEventHandler value);
    public Nullable`1<bool> get_IsChecked();
    public void set_IsChecked(Nullable`1<bool> value);
    protected virtual void OnChecked(RoutedEventArgs e);
    protected virtual void OnUnchecked(RoutedEventArgs e);
    protected virtual void OnIndeterminate(RoutedEventArgs e);
    public bool get_IsThreeState();
    public void set_IsThreeState(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    internal virtual void ChangeVisualState(bool useTransitions);
    public virtual string ToString();
    protected internal virtual void OnToggle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.ToolBarOverflowPanel : Panel {
    public static DependencyProperty WrapWidthProperty;
    public double WrapWidth { get; public set; }
    private static ToolBarOverflowPanel();
    public double get_WrapWidth();
    public void set_WrapWidth(double value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
}
public class System.Windows.Controls.Primitives.ToolBarPanel : StackPanel {
    internal double MinLength { get; private set; }
    internal double MaxLength { get; private set; }
    internal List`1<UIElement> GeneratedItemsCollection { get; }
    private static ToolBarPanel();
    [CompilerGeneratedAttribute]
internal double get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(double value);
    [CompilerGeneratedAttribute]
internal double get_MaxLength();
    [CompilerGeneratedAttribute]
private void set_MaxLength(double value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    internal virtual void GenerateChildren();
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    internal List`1<UIElement> get_GeneratedItemsCollection();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Primitives.Track : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty OrientationProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinimumProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaximumProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ValueProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ViewportSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsDirectionReversedProperty;
    public RepeatButton DecreaseRepeatButton { get; public set; }
    public Thumb Thumb { get; public set; }
    public RepeatButton IncreaseRepeatButton { get; public set; }
    public Orientation Orientation { get; public set; }
    public double Minimum { get; public set; }
    public double Maximum { get; public set; }
    public double Value { get; public set; }
    public double ViewportSize { get; public set; }
    public bool IsDirectionReversed { get; public set; }
    protected int VisualChildrenCount { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Track();
    public virtual double ValueFromPoint(Point pt);
    public virtual double ValueFromDistance(double horizontal, double vertical);
    public RepeatButton get_DecreaseRepeatButton();
    public void set_DecreaseRepeatButton(RepeatButton value);
    public Thumb get_Thumb();
    public void set_Thumb(Thumb value);
    public RepeatButton get_IncreaseRepeatButton();
    public void set_IncreaseRepeatButton(RepeatButton value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public double get_Minimum();
    public void set_Minimum(double value);
    public double get_Maximum();
    public void set_Maximum(double value);
    public double get_Value();
    public void set_Value(double value);
    public double get_ViewportSize();
    public void set_ViewportSize(double value);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Controls.Primitives.UniformGrid : Panel {
    public static DependencyProperty FirstColumnProperty;
    public static DependencyProperty ColumnsProperty;
    public static DependencyProperty RowsProperty;
    public int FirstColumn { get; public set; }
    public int Columns { get; public set; }
    public int Rows { get; public set; }
    private static UniformGrid();
    public int get_FirstColumn();
    public void set_FirstColumn(int value);
    public int get_Columns();
    public void set_Columns(int value);
    public int get_Rows();
    public void set_Rows(int value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
}
public class System.Windows.Controls.PrintDialog : object {
    public PageRangeSelection PageRangeSelection { get; public set; }
    public PageRange PageRange { get; public set; }
    public bool UserPageRangeEnabled { get; public set; }
    public bool SelectedPagesEnabled { get; public set; }
    public bool CurrentPageEnabled { get; public set; }
    public UInt32 MinPage { get; public set; }
    public UInt32 MaxPage { get; public set; }
    public PrintQueue PrintQueue { get; public set; }
    public PrintTicket PrintTicket { get; public set; }
    public double PrintableAreaWidth { get; }
    public double PrintableAreaHeight { get; }
    public PageRangeSelection get_PageRangeSelection();
    public void set_PageRangeSelection(PageRangeSelection value);
    public PageRange get_PageRange();
    public void set_PageRange(PageRange value);
    public bool get_UserPageRangeEnabled();
    public void set_UserPageRangeEnabled(bool value);
    public bool get_SelectedPagesEnabled();
    public void set_SelectedPagesEnabled(bool value);
    public bool get_CurrentPageEnabled();
    public void set_CurrentPageEnabled(bool value);
    public UInt32 get_MinPage();
    public void set_MinPage(UInt32 value);
    public UInt32 get_MaxPage();
    public void set_MaxPage(UInt32 value);
    [SecurityCriticalAttribute]
public PrintQueue get_PrintQueue();
    [SecurityCriticalAttribute]
public void set_PrintQueue(PrintQueue value);
    [SecurityCriticalAttribute]
public PrintTicket get_PrintTicket();
    [SecurityCriticalAttribute]
public void set_PrintTicket(PrintTicket value);
    public double get_PrintableAreaWidth();
    public double get_PrintableAreaHeight();
    [SecurityCriticalAttribute]
public Nullable`1<bool> ShowDialog();
    [SecurityCriticalAttribute]
public void PrintVisual(Visual visual, string description);
    [SecurityCriticalAttribute]
public void PrintDocument(DocumentPaginator documentPaginator, string description);
}
public class System.Windows.Controls.PrintDialogException : Exception {
    public PrintDialogException(string message);
    public PrintDialogException(string message, Exception innerException);
    protected PrintDialogException(SerializationInfo info, StreamingContext context);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ProgressBar : RangeBase {
    public static DependencyProperty IsIndeterminateProperty;
    public static DependencyProperty OrientationProperty;
    public bool IsIndeterminate { get; public set; }
    public Orientation Orientation { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ProgressBar();
    public bool get_IsIndeterminate();
    public void set_IsIndeterminate(bool value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    internal static bool IsValidOrientation(object o);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    public virtual void OnApplyTemplate();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("9")]
public class System.Windows.Controls.RadioButton : ToggleButton {
    public static DependencyProperty GroupNameProperty;
    [DefaultValueAttribute("")]
[LocalizabilityAttribute("17")]
public string GroupName { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RadioButton();
    public string get_GroupName();
    public void set_GroupName(string value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnChecked(RoutedEventArgs e);
    protected internal virtual void OnToggle();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.RealizedColumnsBlock : ValueType {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndexOffset>k__BackingField;
    public int StartIndex { get; private set; }
    public int EndIndex { get; private set; }
    public int StartIndexOffset { get; private set; }
    public RealizedColumnsBlock(int startIndex, int endIndex, int startIndexOffset);
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
private void set_StartIndex(int value);
    [CompilerGeneratedAttribute]
public int get_EndIndex();
    [CompilerGeneratedAttribute]
private void set_EndIndex(int value);
    [CompilerGeneratedAttribute]
public int get_StartIndexOffset();
    [CompilerGeneratedAttribute]
private void set_StartIndexOffset(int value);
}
[LocalizabilityAttribute("15")]
[ContentPropertyAttribute("Document")]
public class System.Windows.Controls.RichTextBox : TextBoxBase {
    public static DependencyProperty IsDocumentEnabledProperty;
    public FlowDocument Document { get; public set; }
    public bool IsDocumentEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    public TextSelection Selection { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public TextPointer CaretPosition { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RichTextBox();
    public RichTextBox(FlowDocument document);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public TextPointer GetPositionFromPoint(Point point, bool snapToText);
    public SpellingError GetSpellingError(TextPointer position);
    public TextRange GetSpellingErrorRange(TextPointer position);
    public TextPointer GetNextSpellingErrorPosition(TextPointer position, LogicalDirection direction);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected virtual Size MeasureOverride(Size constraint);
    internal virtual FrameworkElement CreateRenderScope();
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeDocument();
    public bool get_IsDocumentEnabled();
    public void set_IsDocumentEnabled(bool value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public TextSelection get_Selection();
    public TextPointer get_CaretPosition();
    public void set_CaretPosition(TextPointer value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.RowDefinition : DefinitionBase {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeightProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MinHeightProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MaxHeightProperty;
    public GridLength Height { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxHeight { get; public set; }
    public double ActualHeight { get; }
    public double Offset { get; }
    private static RowDefinition();
    public GridLength get_Height();
    public void set_Height(GridLength value);
    public double get_MinHeight();
    public void set_MinHeight(double value);
    public double get_MaxHeight();
    public void set_MaxHeight(double value);
    public double get_ActualHeight();
    public double get_Offset();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.RowDefinitionCollection : object {
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public RowDefinition Item { get; public set; }
    internal int InternalCount { get; }
    internal DefinitionBase[] InternalItems { get; }
    internal RowDefinitionCollection(Grid owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(RowDefinition[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Add(RowDefinition value);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual bool Contains(RowDefinition value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual int IndexOf(RowDefinition value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual void Insert(int index, RowDefinition value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual bool Remove(RowDefinition value);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<RowDefinition> System.Collections.Generic.IEnumerable<System.Windows.Controls.RowDefinition>.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual RowDefinition get_Item(int index);
    public sealed virtual void set_Item(int index, RowDefinition value);
    internal void InternalTrimToSize();
    internal int get_InternalCount();
    internal DefinitionBase[] get_InternalItems();
}
public enum System.Windows.Controls.ScrollBarVisibility : Enum {
    public int value__;
    public static ScrollBarVisibility Disabled;
    public static ScrollBarVisibility Auto;
    public static ScrollBarVisibility Hidden;
    public static ScrollBarVisibility Visible;
}
public class System.Windows.Controls.ScrollChangedEventArgs : RoutedEventArgs {
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double ViewportWidthChange { get; }
    public double ViewportHeightChange { get; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ExtentWidthChange { get; }
    public double ExtentHeightChange { get; }
    internal ScrollChangedEventArgs(Vector offset, Vector offsetChange, Size extent, Vector extentChange, Size viewport, Vector viewportChange);
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    public double get_HorizontalChange();
    public double get_VerticalChange();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public double get_ViewportWidthChange();
    public double get_ViewportHeightChange();
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ExtentWidthChange();
    public double get_ExtentHeightChange();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ScrollChangedEventHandler : MulticastDelegate {
    public ScrollChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScrollChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScrollChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.ScrollContentPresenter : ContentPresenter {
    public static DependencyProperty CanContentScrollProperty;
    public AdornerLayer AdornerLayer { get; }
    public bool CanContentScroll { get; public set; }
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    protected int VisualChildrenCount { get; }
    internal UIElement TemplateChild { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    private static ScrollContentPresenter();
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public AdornerLayer get_AdornerLayer();
    public bool get_CanContentScroll();
    public void set_CanContentScroll(bool value);
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual UIElement get_TemplateChild();
    internal virtual void set_TemplateChild(UIElement value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    public virtual void OnApplyTemplate();
    internal Rect MakeVisible(Visual visual, Rect rectangle, bool throwOnError);
    internal static double ComputeScrollOffsetWithMinimalScroll(double topView, double bottomView, double topChild, double bottomChild);
    internal static double ComputeScrollOffsetWithMinimalScroll(double topView, double bottomView, double topChild, double bottomChild, Boolean& alignTop, Boolean& alignBottom);
    internal static double ValidateInputOffset(double offset, string parameterName);
    internal void HookupScrollingComponents();
    internal static double CoerceOffset(double offset, double extent, double viewport);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Controls.ScrollUnit : Enum {
    public int value__;
    public static ScrollUnit Pixel;
    public static ScrollUnit Item;
}
[DefaultEventAttribute("ScrollChangedEvent")]
[LocalizabilityAttribute("16")]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ScrollViewer : ContentControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CanContentScrollProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public static DependencyProperty ComputedHorizontalScrollBarVisibilityProperty;
    public static DependencyProperty ComputedVerticalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty ContentVerticalOffsetProperty;
    public static DependencyProperty ContentHorizontalOffsetProperty;
    public static DependencyProperty ExtentWidthProperty;
    public static DependencyProperty ExtentHeightProperty;
    public static DependencyProperty ScrollableWidthProperty;
    public static DependencyProperty ScrollableHeightProperty;
    public static DependencyProperty ViewportWidthProperty;
    internal static DependencyPropertyKey ViewportHeightPropertyKey;
    public static DependencyProperty ViewportHeightProperty;
    public static DependencyProperty IsDeferredScrollingEnabledProperty;
    public static RoutedEvent ScrollChangedEvent;
    public static DependencyProperty PanningModeProperty;
    public static DependencyProperty PanningDecelerationProperty;
    public static DependencyProperty PanningRatioProperty;
    internal static double _scrollLineDelta;
    internal static double _mouseWheelDelta;
    internal static string ScrollContentPresenterTemplateName;
    public bool CanContentScroll { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public Visibility ComputedHorizontalScrollBarVisibility { get; }
    public Visibility ComputedVerticalScrollBarVisibility { get; }
    public double HorizontalOffset { get; private set; }
    public double VerticalOffset { get; private set; }
    [CategoryAttribute("Layout")]
public double ExtentWidth { get; }
    [CategoryAttribute("Layout")]
public double ExtentHeight { get; }
    public double ScrollableWidth { get; }
    public double ScrollableHeight { get; }
    [CategoryAttribute("Layout")]
public double ViewportWidth { get; }
    [CategoryAttribute("Layout")]
public double ViewportHeight { get; }
    public double ContentVerticalOffset { get; private set; }
    public double ContentHorizontalOffset { get; private set; }
    public bool IsDeferredScrollingEnabled { get; public set; }
    protected internal bool HandlesScrolling { get; }
    protected internal IScrollInfo ScrollInfo { get; protected internal set; }
    public PanningMode PanningMode { get; public set; }
    public double PanningDeceleration { get; public set; }
    public double PanningRatio { get; public set; }
    internal bool HandlesMouseWheelScrolling { get; internal set; }
    internal bool InChildInvalidateMeasure { get; internal set; }
    internal bool InChildMeasurePass1 { get; internal set; }
    internal bool InChildMeasurePass2 { get; internal set; }
    internal bool InChildMeasurePass3 { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ScrollViewer();
    public void LineUp();
    public void LineDown();
    public void LineLeft();
    public void LineRight();
    public void PageUp();
    public void PageDown();
    public void PageLeft();
    public void PageRight();
    public void ScrollToLeftEnd();
    public void ScrollToRightEnd();
    public void ScrollToHome();
    public void ScrollToEnd();
    public void ScrollToTop();
    public void ScrollToBottom();
    public void ScrollToHorizontalOffset(double offset);
    public void ScrollToVerticalOffset(double offset);
    internal void MakeVisible(Visual child, Rect rect);
    public void InvalidateScrollInfo();
    public bool get_CanContentScroll();
    public void set_CanContentScroll(bool value);
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public Visibility get_ComputedHorizontalScrollBarVisibility();
    public Visibility get_ComputedVerticalScrollBarVisibility();
    public double get_HorizontalOffset();
    private void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    private void set_VerticalOffset(double value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ScrollableWidth();
    public double get_ScrollableHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public static void SetCanContentScroll(DependencyObject element, bool canContentScroll);
    public static bool GetCanContentScroll(DependencyObject element);
    public static void SetHorizontalScrollBarVisibility(DependencyObject element, ScrollBarVisibility horizontalScrollBarVisibility);
    public static ScrollBarVisibility GetHorizontalScrollBarVisibility(DependencyObject element);
    public static void SetVerticalScrollBarVisibility(DependencyObject element, ScrollBarVisibility verticalScrollBarVisibility);
    public static ScrollBarVisibility GetVerticalScrollBarVisibility(DependencyObject element);
    public double get_ContentVerticalOffset();
    private void set_ContentVerticalOffset(double value);
    public double get_ContentHorizontalOffset();
    private void set_ContentHorizontalOffset(double value);
    public static bool GetIsDeferredScrollingEnabled(DependencyObject element);
    public static void SetIsDeferredScrollingEnabled(DependencyObject element, bool value);
    public bool get_IsDeferredScrollingEnabled();
    public void set_IsDeferredScrollingEnabled(bool value);
    public void add_ScrollChanged(ScrollChangedEventHandler value);
    public void remove_ScrollChanged(ScrollChangedEventHandler value);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnScrollChanged(ScrollChangedEventArgs e);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal void ScrollInDirection(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    protected internal IScrollInfo get_ScrollInfo();
    protected internal void set_ScrollInfo(IScrollInfo value);
    public PanningMode get_PanningMode();
    public void set_PanningMode(PanningMode value);
    public static void SetPanningMode(DependencyObject element, PanningMode panningMode);
    public static PanningMode GetPanningMode(DependencyObject element);
    public double get_PanningDeceleration();
    public void set_PanningDeceleration(double value);
    public static void SetPanningDeceleration(DependencyObject element, double value);
    public static double GetPanningDeceleration(DependencyObject element);
    public double get_PanningRatio();
    public void set_PanningRatio(double value);
    public static void SetPanningRatio(DependencyObject element, double value);
    public static double GetPanningRatio(DependencyObject element);
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    internal bool get_HandlesMouseWheelScrolling();
    internal void set_HandlesMouseWheelScrolling(bool value);
    internal bool get_InChildInvalidateMeasure();
    internal void set_InChildInvalidateMeasure(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal bool get_InChildMeasurePass1();
    internal void set_InChildMeasurePass1(bool value);
    internal bool get_InChildMeasurePass2();
    internal void set_InChildMeasurePass2(bool value);
    internal bool get_InChildMeasurePass3();
    internal void set_InChildMeasurePass3(bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.SelectedCellsChangedEventArgs : EventArgs {
    public IList`1<DataGridCellInfo> AddedCells { get; }
    public IList`1<DataGridCellInfo> RemovedCells { get; }
    public SelectedCellsChangedEventArgs(List`1<DataGridCellInfo> addedCells, List`1<DataGridCellInfo> removedCells);
    public SelectedCellsChangedEventArgs(ReadOnlyCollection`1<DataGridCellInfo> addedCells, ReadOnlyCollection`1<DataGridCellInfo> removedCells);
    internal SelectedCellsChangedEventArgs(DataGrid owner, VirtualizedCellInfoCollection addedCells, VirtualizedCellInfoCollection removedCells);
    public IList`1<DataGridCellInfo> get_AddedCells();
    public IList`1<DataGridCellInfo> get_RemovedCells();
}
public class System.Windows.Controls.SelectedCellsChangedEventHandler : MulticastDelegate {
    public SelectedCellsChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SelectedCellsChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SelectedCellsChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Controls.SelectedCellsCollection : VirtualizedCellInfoCollection {
    internal SelectedCellsCollection(DataGrid owner);
    internal bool GetSelectionRange(Int32& minColumnDisplayIndex, Int32& maxColumnDisplayIndex, Int32& minRowIndex, Int32& maxRowIndex);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
}
public class System.Windows.Controls.SelectedDatesCollection : ObservableCollection`1<DateTime> {
    internal Nullable`1<DateTime> MinimumDate { get; }
    internal Nullable`1<DateTime> MaximumDate { get; }
    public SelectedDatesCollection(Calendar owner);
    internal Nullable`1<DateTime> get_MinimumDate();
    internal Nullable`1<DateTime> get_MaximumDate();
    public void AddRange(DateTime start, DateTime end);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, DateTime item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, DateTime item);
    internal void AddRangeInternal(DateTime start, DateTime end);
    internal void ClearInternal();
    internal void ClearInternal(bool fireChangeNotification);
    internal void Toggle(DateTime date);
}
internal class System.Windows.Controls.SelectedItemCollection : ObservableCollection`1<object> {
    internal bool IsChanging { get; }
    internal bool IsUpdatingSelectedItems { get; }
    public SelectedItemCollection(Selector selector);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, object item);
    protected virtual void SetItem(int index, object item);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    internal bool get_IsChanging();
    internal void BeginUpdateSelectedItems();
    internal void EndUpdateSelectedItems();
    internal bool get_IsUpdatingSelectedItems();
    internal void Add(ItemInfo info);
    internal void Remove(ItemInfo info);
}
public class System.Windows.Controls.SelectionChangedEventArgs : RoutedEventArgs {
    public IList RemovedItems { get; }
    public IList AddedItems { get; }
    internal List`1<ItemInfo> RemovedInfos { get; }
    internal List`1<ItemInfo> AddedInfos { get; }
    public SelectionChangedEventArgs(RoutedEvent id, IList removedItems, IList addedItems);
    internal SelectionChangedEventArgs(List`1<ItemInfo> unselectedInfos, List`1<ItemInfo> selectedInfos);
    public IList get_RemovedItems();
    public IList get_AddedItems();
    internal List`1<ItemInfo> get_RemovedInfos();
    internal List`1<ItemInfo> get_AddedInfos();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.SelectionChangedEventHandler : MulticastDelegate {
    public SelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.SelectionMode : Enum {
    public int value__;
    public static SelectionMode Single;
    public static SelectionMode Multiple;
    public static SelectionMode Extended;
}
public enum System.Windows.Controls.SelectiveScrollingOrientation : Enum {
    public int value__;
    public static SelectiveScrollingOrientation None;
    public static SelectiveScrollingOrientation Horizontal;
    public static SelectiveScrollingOrientation Vertical;
    public static SelectiveScrollingOrientation Both;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Separator : Control {
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Separator();
    internal static void PrepareContainer(Control container);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[FlagsAttribute]
internal enum System.Windows.Controls.SetPropertyFlags : Enum {
    public byte value__;
    public static SetPropertyFlags WindowTitle;
    public static SetPropertyFlags WindowHeight;
    public static SetPropertyFlags WindowWidth;
    public static SetPropertyFlags Title;
    public static SetPropertyFlags ShowsNavigationUI;
    public static SetPropertyFlags None;
}
internal class System.Windows.Controls.SettableState`1 : ValueType {
    internal T _value;
    internal bool _isSet;
    internal bool _wasSet;
    internal SettableState`1(T value);
}
[LocalizabilityAttribute("16")]
[DefaultEventAttribute("ValueChanged")]
[DefaultPropertyAttribute("Value")]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Slider : RangeBase {
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty IsDirectionReversedProperty;
    public static DependencyProperty DelayProperty;
    public static DependencyProperty IntervalProperty;
    public static DependencyProperty AutoToolTipPlacementProperty;
    public static DependencyProperty AutoToolTipPrecisionProperty;
    public static DependencyProperty IsSnapToTickEnabledProperty;
    public static DependencyProperty TickPlacementProperty;
    public static DependencyProperty TickFrequencyProperty;
    public static DependencyProperty TicksProperty;
    public static DependencyProperty IsSelectionRangeEnabledProperty;
    public static DependencyProperty SelectionStartProperty;
    public static DependencyProperty SelectionEndProperty;
    public static DependencyProperty IsMoveToPointEnabledProperty;
    public static RoutedCommand IncreaseLarge { get; }
    public static RoutedCommand DecreaseLarge { get; }
    public static RoutedCommand IncreaseSmall { get; }
    public static RoutedCommand DecreaseSmall { get; }
    public static RoutedCommand MinimizeValue { get; }
    public static RoutedCommand MaximizeValue { get; }
    public Orientation Orientation { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsDirectionReversed { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Delay { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Interval { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public AutoToolTipPlacement AutoToolTipPlacement { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public int AutoToolTipPrecision { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsSnapToTickEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public TickPlacement TickPlacement { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double TickFrequency { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public DoubleCollection Ticks { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelectionRangeEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionStart { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionEnd { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsMoveToPointEnabled { get; public set; }
    internal Track Track { get; internal set; }
    internal FrameworkElement SelectionRangeElement { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Slider();
    public static RoutedCommand get_IncreaseLarge();
    public static RoutedCommand get_DecreaseLarge();
    public static RoutedCommand get_IncreaseSmall();
    public static RoutedCommand get_DecreaseSmall();
    public static RoutedCommand get_MinimizeValue();
    public static RoutedCommand get_MaximizeValue();
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    public int get_Delay();
    public void set_Delay(int value);
    public int get_Interval();
    public void set_Interval(int value);
    public AutoToolTipPlacement get_AutoToolTipPlacement();
    public void set_AutoToolTipPlacement(AutoToolTipPlacement value);
    public int get_AutoToolTipPrecision();
    public void set_AutoToolTipPrecision(int value);
    public bool get_IsSnapToTickEnabled();
    public void set_IsSnapToTickEnabled(bool value);
    public TickPlacement get_TickPlacement();
    public void set_TickPlacement(TickPlacement value);
    public double get_TickFrequency();
    public void set_TickFrequency(double value);
    public DoubleCollection get_Ticks();
    public void set_Ticks(DoubleCollection value);
    public bool get_IsSelectionRangeEnabled();
    public void set_IsSelectionRangeEnabled(bool value);
    public double get_SelectionStart();
    public void set_SelectionStart(double value);
    public double get_SelectionEnd();
    public void set_SelectionEnd(double value);
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    public bool get_IsMoveToPointEnabled();
    public void set_IsMoveToPointEnabled(bool value);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnThumbDragStarted(DragStartedEventArgs e);
    protected virtual void OnThumbDragDelta(DragDeltaEventArgs e);
    protected virtual void OnThumbDragCompleted(DragCompletedEventArgs e);
    internal Track get_Track();
    internal void set_Track(Track value);
    internal FrameworkElement get_SelectionRangeElement();
    internal void set_SelectionRangeElement(FrameworkElement value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnIncreaseLarge();
    protected virtual void OnDecreaseLarge();
    protected virtual void OnIncreaseSmall();
    protected virtual void OnDecreaseSmall();
    protected virtual void OnMaximizeValue();
    protected virtual void OnMinimizeValue();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.SoundPlayerAction : TriggerAction {
    public static DependencyProperty SourceProperty;
    public Uri Source { get; public set; }
    private static SoundPlayerAction();
    public sealed virtual void Dispose();
    public Uri get_Source();
    public void set_Source(Uri value);
    internal sealed virtual void Invoke(FrameworkElement el, FrameworkContentElement ctntEl, Style targetStyle, FrameworkTemplate targetTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement el);
}
public class System.Windows.Controls.SpellCheck : object {
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty SpellingReformProperty;
    public static DependencyProperty CustomDictionariesProperty;
    public bool IsEnabled { get; public set; }
    public SpellingReform SpellingReform { get; public set; }
    public IList CustomDictionaries { get; }
    internal SpellCheck(TextBoxBase owner);
    private static SpellCheck();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public static void SetIsEnabled(TextBoxBase textBoxBase, bool value);
    public static bool GetIsEnabled(TextBoxBase textBoxBase);
    public SpellingReform get_SpellingReform();
    public void set_SpellingReform(SpellingReform value);
    public static void SetSpellingReform(TextBoxBase textBoxBase, SpellingReform value);
    public IList get_CustomDictionaries();
    public static IList GetCustomDictionaries(TextBoxBase textBoxBase);
}
public class System.Windows.Controls.SpellingError : object {
    public IEnumerable`1<string> Suggestions { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal SpellingError(Speller speller, ITextPointer start, ITextPointer end);
    public void Correct(string correctedText);
    public void IgnoreAll();
    [IteratorStateMachineAttribute("System.Windows.Controls.SpellingError/<get_Suggestions>d__4")]
public IEnumerable`1<string> get_Suggestions();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
}
public enum System.Windows.Controls.SpellingReform : Enum {
    public int value__;
    public static SpellingReform PreAndPostreform;
    public static SpellingReform Prereform;
    public static SpellingReform Postreform;
}
public class System.Windows.Controls.StackPanel : Panel {
    public static DependencyProperty OrientationProperty;
    public Orientation Orientation { get; public set; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal Orientation LogicalOrientation { get; }
    [DefaultValueAttribute("False")]
public bool CanHorizontallyScroll { get; public set; }
    [DefaultValueAttribute("False")]
public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private bool System.Windows.Controls.IStackMeasure.IsScrolling { get; }
    private UIElementCollection System.Windows.Controls.IStackMeasure.InternalChildren { get; }
    private static StackPanel();
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public sealed virtual Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal virtual Orientation get_LogicalOrientation();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    protected virtual Size MeasureOverride(Size constraint);
    internal static Size StackMeasureHelper(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static Size StackArrangeHelper(IStackMeasure arrangeElement, IStackMeasureScrollData scrollData, Size arrangeSize);
    internal virtual int get_EffectiveValuesInitialSize();
    private sealed virtual override bool System.Windows.Controls.IStackMeasure.get_IsScrolling();
    private sealed virtual override UIElementCollection System.Windows.Controls.IStackMeasure.get_InternalChildren();
    private sealed virtual override void System.Windows.Controls.IStackMeasure.OnScrollChange();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.StickyNoteControl : Control {
    public static XmlQualifiedName TextSchemaName;
    public static XmlQualifiedName InkSchemaName;
    internal static DependencyPropertyKey AuthorPropertyKey;
    public static DependencyProperty AuthorProperty;
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty IsActiveProperty;
    internal static DependencyPropertyKey IsMouseOverAnchorPropertyKey;
    public static DependencyProperty IsMouseOverAnchorProperty;
    public static DependencyProperty CaptionFontFamilyProperty;
    public static DependencyProperty CaptionFontSizeProperty;
    public static DependencyProperty CaptionFontStretchProperty;
    public static DependencyProperty CaptionFontStyleProperty;
    public static DependencyProperty CaptionFontWeightProperty;
    public static DependencyProperty PenWidthProperty;
    public static DependencyProperty StickyNoteTypeProperty;
    public static RoutedCommand DeleteNoteCommand;
    public static RoutedCommand InkCommand;
    private IList MS.Internal.Annotations.Component.IAnnotationComponent.AttachedAnnotations { get; }
    private UIElement MS.Internal.Annotations.Component.IAnnotationComponent.AnnotatedElement { get; }
    private PresentationContext MS.Internal.Annotations.Component.IAnnotationComponent.PresentationContext { get; private set; }
    private int MS.Internal.Annotations.Component.IAnnotationComponent.ZOrder { get; private set; }
    private bool MS.Internal.Annotations.Component.IAnnotationComponent.IsDirty { get; private set; }
    internal TranslateTransform PositionTransform { get; internal set; }
    internal double XOffset { get; internal set; }
    internal double YOffset { get; internal set; }
    internal bool FlipBothOrigins { get; }
    public string Author { get; }
    public bool IsExpanded { get; public set; }
    public bool IsActive { get; }
    public bool IsMouseOverAnchor { get; }
    public FontFamily CaptionFontFamily { get; public set; }
    public double CaptionFontSize { get; public set; }
    public FontStretch CaptionFontStretch { get; public set; }
    public FontStyle CaptionFontStyle { get; public set; }
    public FontWeight CaptionFontWeight { get; public set; }
    public double PenWidth { get; public set; }
    public StickyNoteType StickyNoteType { get; }
    public IAnchorInfo AnchorInfo { get; }
    internal StickyNoteContentControl Content { get; }
    private static StickyNoteControl();
    internal StickyNoteControl(StickyNoteType type);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    private sealed virtual override IList MS.Internal.Annotations.Component.IAnnotationComponent.get_AttachedAnnotations();
    private sealed virtual override GeneralTransform MS.Internal.Annotations.Component.IAnnotationComponent.GetDesiredTransform(GeneralTransform transform);
    private sealed virtual override UIElement MS.Internal.Annotations.Component.IAnnotationComponent.get_AnnotatedElement();
    private sealed virtual override PresentationContext MS.Internal.Annotations.Component.IAnnotationComponent.get_PresentationContext();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_PresentationContext(PresentationContext value);
    private sealed virtual override int MS.Internal.Annotations.Component.IAnnotationComponent.get_ZOrder();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_ZOrder(int value);
    private sealed virtual override bool MS.Internal.Annotations.Component.IAnnotationComponent.get_IsDirty();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_IsDirty(bool value);
    internal TranslateTransform get_PositionTransform();
    internal void set_PositionTransform(TranslateTransform value);
    internal double get_XOffset();
    internal void set_XOffset(double value);
    internal double get_YOffset();
    internal void set_YOffset(double value);
    internal bool get_FlipBothOrigins();
    public virtual void OnApplyTemplate();
    public string get_Author();
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public bool get_IsActive();
    public bool get_IsMouseOverAnchor();
    public FontFamily get_CaptionFontFamily();
    public void set_CaptionFontFamily(FontFamily value);
    public double get_CaptionFontSize();
    public void set_CaptionFontSize(double value);
    public FontStretch get_CaptionFontStretch();
    public void set_CaptionFontStretch(FontStretch value);
    public FontStyle get_CaptionFontStyle();
    public void set_CaptionFontStyle(FontStyle value);
    public FontWeight get_CaptionFontWeight();
    public void set_CaptionFontWeight(FontWeight value);
    public double get_PenWidth();
    public void set_PenWidth(double value);
    public StickyNoteType get_StickyNoteType();
    public IAnchorInfo get_AnchorInfo();
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs args);
    internal StickyNoteContentControl get_Content();
}
public enum System.Windows.Controls.StickyNoteType : Enum {
    public int value__;
    public static StickyNoteType Text;
    public static StickyNoteType Ink;
}
public enum System.Windows.Controls.StretchDirection : Enum {
    public int value__;
    public static StretchDirection UpOnly;
    public static StretchDirection DownOnly;
    public static StretchDirection Both;
}
public class System.Windows.Controls.StyleSelector : object {
    public virtual Style SelectStyle(object item, DependencyObject container);
}
[StyleTypedPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.TabControl : Selector {
    public static DependencyProperty TabStripPlacementProperty;
    public static DependencyProperty SelectedContentProperty;
    public static DependencyProperty SelectedContentTemplateProperty;
    public static DependencyProperty SelectedContentTemplateSelectorProperty;
    public static DependencyProperty SelectedContentStringFormatProperty;
    public static DependencyProperty ContentTemplateProperty;
    public static DependencyProperty ContentTemplateSelectorProperty;
    public static DependencyProperty ContentStringFormatProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public Dock TabStripPlacement { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public object SelectedContent { get; internal set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplate SelectedContentTemplate { get; internal set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector SelectedContentTemplateSelector { get; internal set; }
    public string SelectedContentStringFormat { get; internal set; }
    public DataTemplate ContentTemplate { get; public set; }
    public DataTemplateSelector ContentTemplateSelector { get; public set; }
    public string ContentStringFormat { get; public set; }
    internal ContentPresenter SelectedContentPresenter { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TabControl();
    public Dock get_TabStripPlacement();
    public void set_TabStripPlacement(Dock value);
    public object get_SelectedContent();
    internal void set_SelectedContent(object value);
    public DataTemplate get_SelectedContentTemplate();
    internal void set_SelectedContentTemplate(DataTemplate value);
    public DataTemplateSelector get_SelectedContentTemplateSelector();
    internal void set_SelectedContentTemplateSelector(DataTemplateSelector value);
    public string get_SelectedContentStringFormat();
    internal void set_SelectedContentStringFormat(string value);
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    public virtual void OnApplyTemplate();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    internal ContentPresenter get_SelectedContentPresenter();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("IsSelectedChanged")]
public class System.Windows.Controls.TabItem : HeaderedContentControl {
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty TabStripPlacementProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    public Dock TabStripPlacement { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TabItem();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    protected virtual void OnSelected(RoutedEventArgs e);
    protected virtual void OnUnselected(RoutedEventArgs e);
    public Dock get_TabStripPlacement();
    internal virtual void OnAncestorChanged();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    internal bool SetFocus();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[ContentPropertyAttribute("Inlines")]
[LocalizabilityAttribute("1")]
public class System.Windows.Controls.TextBlock : FrameworkElement {
    public static DependencyProperty BaselineOffsetProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty TextAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextTrimmingProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty IsHyphenationEnabledProperty;
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public TextPointer ContentStart { get; }
    public TextPointer ContentEnd { get; }
    internal TextRange TextRange { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public Typography Typography { get; }
    public double BaselineOffset { get; public set; }
    [LocalizabilityAttribute("1")]
public string Text { get; public set; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public Thickness Padding { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public TextTrimming TextTrimming { get; public set; }
    public TextWrapping TextWrapping { get; public set; }
    public bool IsHyphenationEnabled { get; public set; }
    protected int VisualChildrenCount { get; }
    protected IEnumerator`1<IInputElement> HostedElementsCore { get; }
    internal TextFormatter TextFormatter { get; }
    internal ITextContainer TextContainer { get; }
    internal ITextView TextView { get; }
    internal Highlights Highlights { get; }
    internal LineProperties ParagraphProperties { get; }
    internal bool IsLayoutDataValid { get; }
    internal bool HasComplexContent { get; }
    internal bool IsTypographyDefaultValue { get; }
    internal bool IsContentPresenterContainer { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    private static TextBlock();
    public TextBlock(Inline inline);
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public TextPointer GetPositionFromPoint(Point point, bool snapToText);
    public InlineCollection get_Inlines();
    public TextPointer get_ContentStart();
    public TextPointer get_ContentEnd();
    internal TextRange get_TextRange();
    public LineBreakCondition get_BreakBefore();
    public LineBreakCondition get_BreakAfter();
    public Typography get_Typography();
    public double get_BaselineOffset();
    public void set_BaselineOffset(double value);
    public static void SetBaselineOffset(DependencyObject element, double value);
    public static double GetBaselineOffset(DependencyObject element);
    public string get_Text();
    public void set_Text(string value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public static void SetFontFamily(DependencyObject element, FontFamily value);
    public static FontFamily GetFontFamily(DependencyObject element);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public static void SetFontStyle(DependencyObject element, FontStyle value);
    public static FontStyle GetFontStyle(DependencyObject element);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public static void SetFontWeight(DependencyObject element, FontWeight value);
    public static FontWeight GetFontWeight(DependencyObject element);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public static void SetFontStretch(DependencyObject element, FontStretch value);
    public static FontStretch GetFontStretch(DependencyObject element);
    public double get_FontSize();
    public void set_FontSize(double value);
    public static void SetFontSize(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
public static double GetFontSize(DependencyObject element);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public static void SetForeground(DependencyObject element, Brush value);
    public static Brush GetForeground(DependencyObject element);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public static void SetLineHeight(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public static double GetLineHeight(DependencyObject element);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value);
    public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public static void SetTextAlignment(DependencyObject element, TextAlignment value);
    public static TextAlignment GetTextAlignment(DependencyObject element);
    public TextTrimming get_TextTrimming();
    public void set_TextTrimming(TextTrimming value);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    protected sealed virtual void OnRender(DrawingContext ctx);
    protected sealed virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected sealed virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual IInputElement InputHitTestCore(Point point);
    protected virtual ReadOnlyCollection`1<Rect> GetRectanglesCore(ContentElement child);
    protected virtual IEnumerator`1<IInputElement> get_HostedElementsCore();
    protected virtual void OnChildDesiredSizeChangedCore(UIElement child);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void RemoveChild(Visual child);
    internal void SetTextContainer(ITextContainer textContainer);
    internal Size MeasureChild(InlineObject inlineObject);
    internal virtual string GetPlainText();
    internal ReadOnlyCollection`1<LineResult> GetLineResults();
    internal void GetLineDetails(int dcp, int index, double lineVOffset, Int32& cchContent, Int32& cchEllipses);
    internal ITextPointer GetTextPositionFromDistance(int dcp, double distance, double lineVOffset, int index);
    internal Rect GetRectangleFromTextPosition(ITextPointer orientedPosition);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal bool IsAtCaretUnitBoundary(ITextPointer position, int dcp, int lineIndex);
    internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction, int dcp, int lineIndex);
    internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position, int dcp, int lineIndex);
    internal TextFormatter get_TextFormatter();
    internal ITextContainer get_TextContainer();
    internal ITextView get_TextView();
    internal Highlights get_Highlights();
    internal LineProperties get_ParagraphProperties();
    internal bool get_IsLayoutDataValid();
    internal bool get_HasComplexContent();
    internal bool get_IsTypographyDefaultValue();
    internal bool get_IsContentPresenterContainer();
    internal void set_IsContentPresenterContainer(bool value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
    internal void OnChildBaselineOffsetChanged(DependencyObject source);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBaselineOffset();
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Controls.TextBlockCache : object {
    public LineProperties _lineProperties;
    public TextRunCache _textRunCache;
}
[LocalizabilityAttribute("1")]
[ContentPropertyAttribute("Text")]
public class System.Windows.Controls.TextBox : TextBoxBase {
    public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty MinLinesProperty;
    public static DependencyProperty MaxLinesProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty CharacterCasingProperty;
    public static DependencyProperty MaxLengthProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty TextDecorationsProperty;
    public TextWrapping TextWrapping { get; public set; }
    [DefaultValueAttribute("1")]
public int MinLines { get; public set; }
    [DefaultValueAttribute("2147483647")]
public int MaxLines { get; public set; }
    [DefaultValueAttribute("")]
[LocalizabilityAttribute("1")]
public string Text { get; public set; }
    public CharacterCasing CharacterCasing { get; public set; }
    [DefaultValueAttribute("0")]
[LocalizabilityAttribute("0")]
public int MaxLength { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public string SelectedText { get; public set; }
    [DefaultValueAttribute("0")]
[DesignerSerializationVisibilityAttribute("0")]
public int SelectionLength { get; public set; }
    [DefaultValueAttribute("0")]
[DesignerSerializationVisibilityAttribute("0")]
public int SelectionStart { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int CaretIndex { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int LineCount { get; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public Typography Typography { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal TextSelection Selection { get; }
    internal TextPointer StartPosition { get; }
    internal TextPointer EndPosition { get; }
    internal bool IsTypographyDefaultValue { get; }
    private ITextContainer System.Windows.Controls.ITextBoxViewHost.TextContainer { get; }
    private bool System.Windows.Controls.ITextBoxViewHost.IsTypographyDefaultValue { get; }
    private static TextBox();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public void Select(int start, int length);
    public void Clear();
    public int GetCharacterIndexFromPoint(Point point, bool snapToText);
    public int GetCharacterIndexFromLineIndex(int lineIndex);
    public int GetLineIndexFromCharacterIndex(int charIndex);
    public int GetLineLength(int lineIndex);
    public int GetFirstVisibleLineIndex();
    public int GetLastVisibleLineIndex();
    public void ScrollToLine(int lineIndex);
    public string GetLineText(int lineIndex);
    public Rect GetRectFromCharacterIndex(int charIndex);
    public Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge);
    public SpellingError GetSpellingError(int charIndex);
    public int GetSpellingErrorStart(int charIndex);
    public int GetSpellingErrorLength(int charIndex);
    public int GetNextSpellingErrorCharacterIndex(int charIndex, LogicalDirection direction);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public int get_MinLines();
    public void set_MinLines(int value);
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public string get_Text();
    public void set_Text(string value);
    public CharacterCasing get_CharacterCasing();
    public void set_CharacterCasing(CharacterCasing value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public string get_SelectedText();
    public void set_SelectedText(string value);
    public int get_SelectionLength();
    public void set_SelectionLength(int value);
    public int get_SelectionStart();
    public void set_SelectionStart(int value);
    public int get_CaretIndex();
    public void set_CaretIndex(int value);
    public int get_LineCount();
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public Typography get_Typography();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Size MeasureOverride(Size constraint);
    internal void OnTextWrappingChanged();
    internal virtual FrameworkElement CreateRenderScope();
    internal virtual void AttachToVisualTree();
    internal virtual string GetPlainText();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual void DoLineUp();
    internal virtual void DoLineDown();
    internal virtual void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    internal void OnDeferredTextReferenceResolved(DeferredTextReference dtr, string s);
    internal virtual void OnScrollChanged(object sender, ScrollChangedEventArgs e);
    internal void RaiseCourtesyTextChangedEvent();
    internal virtual int get_EffectiveValuesInitialSize();
    internal TextSelection get_Selection();
    internal TextPointer get_StartPosition();
    internal TextPointer get_EndPosition();
    internal bool get_IsTypographyDefaultValue();
    private sealed virtual override ITextContainer System.Windows.Controls.ITextBoxViewHost.get_TextContainer();
    private sealed virtual override bool System.Windows.Controls.ITextBoxViewHost.get_IsTypographyDefaultValue();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText(XamlDesignerSerializationManager manager);
}
internal class System.Windows.Controls.TextBoxLine : TextSource {
    internal double Width { get; }
    internal double Height { get; }
    internal bool EndOfParagraph { get; }
    internal int Length { get; }
    internal int ContentLength { get; }
    internal bool HasLineBreak { get; }
    internal TextBoxLine(TextBoxView owner);
    public sealed virtual void Dispose();
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    internal void Format(int dcp, double formatWidth, double paragraphWidth, LineProperties lineProperties, TextRunCache textRunCache, TextFormatter formatter);
    internal TextBoxLineDrawingVisual CreateVisual(Geometry selectionGeometry);
    internal Rect GetBoundsFromTextPosition(int characterIndex, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal CharacterHit GetTextPositionFromDistance(double distance);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal double get_Width();
    internal double get_Height();
    internal bool get_EndOfParagraph();
    internal int get_Length();
    internal int get_ContentLength();
    internal bool get_HasLineBreak();
}
internal class System.Windows.Controls.TextBoxLineDrawingVisual : DrawingVisual {
    internal bool DiscardOnArrange { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_DiscardOnArrange();
    [CompilerGeneratedAttribute]
internal void set_DiscardOnArrange(bool value);
}
internal class System.Windows.Controls.TextBoxView : FrameworkElement {
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.VerticalOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    protected int VisualChildrenCount { get; }
    internal ITextBoxViewHost Host { get; }
    private UIElement System.Windows.Documents.ITextView.RenderScope { get; }
    private ITextContainer System.Windows.Documents.ITextView.TextContainer { get; }
    private bool System.Windows.Documents.ITextView.IsValid { get; }
    private bool System.Windows.Documents.ITextView.RendersOwnSelection { get; }
    private ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.TextSegments { get; }
    private static TextBoxView();
    internal TextBoxView(ITextBoxViewHost host);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_HorizontalOffset();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_VerticalOffset();
    private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext context);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetTextPositionFromPoint(Point point, bool snapToText);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRectangleFromTextPosition(ITextPointer position);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    private sealed virtual override Geometry System.Windows.Documents.ITextView.GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    private sealed virtual override bool System.Windows.Documents.ITextView.IsAtCaretUnitBoundary(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetBackspaceCaretUnitPosition(ITextPointer position);
    private sealed virtual override TextSegment System.Windows.Documents.ITextView.GetLineRange(ITextPointer position);
    private sealed virtual override ReadOnlyCollection`1<GlyphRun> System.Windows.Documents.ITextView.GetGlyphRuns(ITextPointer start, ITextPointer end);
    private sealed virtual override bool System.Windows.Documents.ITextView.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPositionIntoViewAsync(ITextPointer position, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPointIntoViewAsync(Point point, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.CancelAsync(object userState);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate();
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(Point point);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.ThrottleBackgroundTasksForUserInput();
    internal void Remeasure();
    internal void Rerender();
    internal int GetLineIndexFromOffset(int offset);
    internal void RemoveTextContainerListeners();
    internal ITextBoxViewHost get_Host();
    private sealed virtual override UIElement System.Windows.Documents.ITextView.get_RenderScope();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextView.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_IsValid();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_RendersOwnSelection();
    private sealed virtual override ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.get_TextSegments();
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_Updated(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_Updated(EventHandler value);
}
public class System.Windows.Controls.TextChange : object {
    public int Offset { get; internal set; }
    public int AddedLength { get; internal set; }
    public int RemovedLength { get; internal set; }
    public int get_Offset();
    internal void set_Offset(int value);
    public int get_AddedLength();
    internal void set_AddedLength(int value);
    public int get_RemovedLength();
    internal void set_RemovedLength(int value);
}
public class System.Windows.Controls.TextChangedEventArgs : RoutedEventArgs {
    public UndoAction UndoAction { get; }
    public ICollection`1<TextChange> Changes { get; }
    public TextChangedEventArgs(RoutedEvent id, UndoAction action, ICollection`1<TextChange> changes);
    public TextChangedEventArgs(RoutedEvent id, UndoAction action);
    public UndoAction get_UndoAction();
    public ICollection`1<TextChange> get_Changes();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.TextChangedEventHandler : MulticastDelegate {
    public TextChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.TextSearch : DependencyObject {
    public static DependencyProperty TextPathProperty;
    public static DependencyProperty TextProperty;
    private static TextSearch();
    internal static TextSearch EnsureInstance(ItemsControl itemsControl);
    public static void SetTextPath(DependencyObject element, string path);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetTextPath(DependencyObject element);
    public static void SetText(DependencyObject element, string text);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetText(DependencyObject element);
    internal bool DoSearch(string nextChar);
    internal bool DeleteLastCharacter();
    internal static MatchedTextInfo FindMatchingPrefix(ItemsControl itemsControl, string prefix);
    internal static string GetPrimaryTextFromItem(ItemsControl itemsControl, object item);
    internal string GetCurrentPrefix();
    internal static string GetPrimaryText(FrameworkElement element);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ToolBar : HeaderedItemsControl {
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty BandProperty;
    public static DependencyProperty BandIndexProperty;
    public static DependencyProperty IsOverflowOpenProperty;
    internal static DependencyPropertyKey HasOverflowItemsPropertyKey;
    public static DependencyProperty HasOverflowItemsProperty;
    internal static DependencyPropertyKey IsOverflowItemPropertyKey;
    public static DependencyProperty IsOverflowItemProperty;
    public static DependencyProperty OverflowModeProperty;
    public Orientation Orientation { get; }
    public int Band { get; public set; }
    public int BandIndex { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOverflowOpen { get; public set; }
    public bool HasOverflowItems { get; }
    internal ToolBarPanel ToolBarPanel { get; }
    internal ToolBarOverflowPanel ToolBarOverflowPanel { get; }
    internal double MinLength { get; }
    internal double MaxLength { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey ButtonStyleKey { get; }
    public static ResourceKey ToggleButtonStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    public static ResourceKey CheckBoxStyleKey { get; }
    public static ResourceKey RadioButtonStyleKey { get; }
    public static ResourceKey ComboBoxStyleKey { get; }
    public static ResourceKey TextBoxStyleKey { get; }
    public static ResourceKey MenuStyleKey { get; }
    private static ToolBar();
    public Orientation get_Orientation();
    public int get_Band();
    public void set_Band(int value);
    public int get_BandIndex();
    public void set_BandIndex(int value);
    public bool get_IsOverflowOpen();
    public void set_IsOverflowOpen(bool value);
    public bool get_HasOverflowItems();
    internal static void SetIsOverflowItem(DependencyObject element, object value);
    public static bool GetIsOverflowItem(DependencyObject element);
    public static void SetOverflowMode(DependencyObject element, OverflowMode mode);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static OverflowMode GetOverflowMode(DependencyObject element);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal ToolBarPanel get_ToolBarPanel();
    internal ToolBarOverflowPanel get_ToolBarOverflowPanel();
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal virtual void OnAncestorChanged();
    internal double get_MinLength();
    internal double get_MaxLength();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_ButtonStyleKey();
    public static ResourceKey get_ToggleButtonStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
    public static ResourceKey get_CheckBoxStyleKey();
    public static ResourceKey get_RadioButtonStyleKey();
    public static ResourceKey get_ComboBoxStyleKey();
    public static ResourceKey get_TextBoxStyleKey();
    public static ResourceKey get_MenuStyleKey();
}
[ContentPropertyAttribute("ToolBars")]
public class System.Windows.Controls.ToolBarTray : FrameworkElement {
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty IsLockedProperty;
    public Brush Background { get; public set; }
    public Orientation Orientation { get; public set; }
    public bool IsLocked { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<ToolBar> ToolBars { get; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToolBarTray();
    public Brush get_Background();
    public void set_Background(Brush value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public bool get_IsLocked();
    public void set_IsLocked(bool value);
    public static void SetIsLocked(DependencyObject element, bool value);
    public static bool GetIsLocked(DependencyObject element);
    public Collection`1<ToolBar> get_ToolBars();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnRender(DrawingContext dc);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Opened")]
[LocalizabilityAttribute("10")]
public class System.Windows.Controls.ToolTip : ContentControl {
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double VerticalOffset { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOpen { get; public set; }
    public bool HasDropShadow { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[DesignerSerializationVisibilityAttribute("0")]
public UIElement PlacementTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Rect PlacementRectangle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpen { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToolTip();
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    public bool get_HasDropShadow();
    public void set_HasDropShadow(bool value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    protected virtual void OnOpened(RoutedEventArgs e);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    protected virtual void OnClosed(RoutedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal virtual void OnAncestorChanged();
    protected virtual void OnContentChanged(object oldContent, object newContent);
    internal void ForceClose();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ToolTipEventArgs : RoutedEventArgs {
    internal ToolTipEventArgs(bool opening);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ToolTipEventHandler : MulticastDelegate {
    public ToolTipEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolTipEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolTipEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.ToolTipService : object {
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ShowOnDisabledProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty ShowDurationProperty;
    public static DependencyProperty InitialShowDelayProperty;
    public static DependencyProperty BetweenShowDelayProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    internal static RoutedEvent FindToolTipEvent;
    private static ToolTipService();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static object GetToolTip(DependencyObject element);
    public static void SetToolTip(DependencyObject element, object value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetHorizontalOffset(DependencyObject element);
    public static void SetHorizontalOffset(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetVerticalOffset(DependencyObject element);
    public static void SetVerticalOffset(DependencyObject element, double value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHasDropShadow(DependencyObject element);
    public static void SetHasDropShadow(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static UIElement GetPlacementTarget(DependencyObject element);
    public static void SetPlacementTarget(DependencyObject element, UIElement value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static Rect GetPlacementRectangle(DependencyObject element);
    public static void SetPlacementRectangle(DependencyObject element, Rect value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static PlacementMode GetPlacement(DependencyObject element);
    public static void SetPlacement(DependencyObject element, PlacementMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetShowOnDisabled(DependencyObject element);
    public static void SetShowOnDisabled(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsOpen(DependencyObject element);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsEnabled(DependencyObject element);
    public static void SetIsEnabled(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetShowDuration(DependencyObject element);
    public static void SetShowDuration(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetInitialShowDelay(DependencyObject element);
    public static void SetInitialShowDelay(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetBetweenShowDelay(DependencyObject element);
    public static void SetBetweenShowDelay(DependencyObject element, int value);
    public static void AddToolTipOpeningHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void RemoveToolTipOpeningHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void AddToolTipClosingHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void RemoveToolTipClosingHandler(DependencyObject element, ToolTipEventHandler handler);
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.TreeView : ItemsControl {
    public static DependencyProperty SelectedItemProperty;
    public static DependencyProperty SelectedValueProperty;
    public static DependencyProperty SelectedValuePathProperty;
    public static RoutedEvent SelectedItemChangedEvent;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedItem { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedValue { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public string SelectedValuePath { get; public set; }
    internal bool IsSelectionChangeActive { get; internal set; }
    internal bool IsSelectedContainerHookedUp { get; }
    internal TreeViewItem SelectedContainer { get; }
    protected internal bool HandlesScrolling { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TreeView();
    public object get_SelectedItem();
    public object get_SelectedValue();
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    public void add_SelectedItemChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_SelectedItemChanged(RoutedPropertyChangedEventHandler`1<object> value);
    protected virtual void OnSelectedItemChanged(RoutedPropertyChangedEventArgs`1<object> e);
    internal void ChangeSelection(object data, TreeViewItem container, bool selected);
    internal bool get_IsSelectionChangeActive();
    internal void set_IsSelectionChangeActive(bool value);
    internal void HandleSelectionAndCollapsed(TreeViewItem collapsed);
    internal void HandleMouseButtonDown();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal bool get_IsSelectedContainerHookedUp();
    internal TreeViewItem get_SelectedContainer();
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual bool ExpandSubtree(TreeViewItem container);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.TreeViewItem : HeaderedItemsControl {
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static RoutedEvent ExpandedEvent;
    public static RoutedEvent CollapsedEvent;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    public bool IsExpanded { get; public set; }
    public bool IsSelected { get; public set; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
public bool IsSelectionActive { get; }
    private HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.Constraints { get; private set; }
    private HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.HeaderDesiredSizes { get; }
    private HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemDesiredSizes { get; private set; }
    private Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemsHost { get; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.MustDisableVirtualization { get; private set; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.InBackgroundLayout { get; private set; }
    internal TreeView ParentTreeView { get; }
    internal TreeViewItem ParentTreeViewItem { get; }
    internal ItemsControl ParentItemsControl { get; }
    internal FrameworkElement HeaderElement { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TreeViewItem();
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    public bool get_IsSelectionActive();
    public void add_Expanded(RoutedEventHandler value);
    public void remove_Expanded(RoutedEventHandler value);
    protected virtual void OnExpanded(RoutedEventArgs e);
    public void add_Collapsed(RoutedEventHandler value);
    public void remove_Collapsed(RoutedEventHandler value);
    protected virtual void OnCollapsed(RoutedEventArgs e);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    public void ExpandSubtree();
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private sealed virtual override HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_Constraints();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_Constraints(HierarchicalVirtualizationConstraints value);
    private sealed virtual override HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_HeaderDesiredSizes();
    private sealed virtual override HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemDesiredSizes();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    private sealed virtual override Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemsHost();
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_MustDisableVirtualization();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_MustDisableVirtualization(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_InBackgroundLayout();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_InBackgroundLayout(bool value);
    internal TreeView get_ParentTreeView();
    internal TreeViewItem get_ParentTreeViewItem();
    internal ItemsControl get_ParentItemsControl();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal void UpdateContainsSelection(bool selected);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal bool HandleUpKey(KeyEventArgs e);
    internal bool HandleDownKey(KeyEventArgs e);
    internal FrameworkElement get_HeaderElement();
    internal FrameworkElement TryGetHeaderElement();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    internal void PrepareItemContainer(object item, ItemsControl parentItemsControl);
    internal void ClearItemContainer(object item, ItemsControl parentItemsControl);
    internal static void IsVirtualizingPropagationHelper(DependencyObject parent, DependencyObject element);
    internal static void SynchronizeValue(DependencyProperty dp, DependencyObject parent, DependencyObject child);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual void ChangeVisualState(bool useTransitions);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.UIElementCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public UIElement Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal UIElement VisualParent { get; }
    internal FrameworkElement LogicalParent { get; }
    public UIElementCollection(UIElement visualParent, FrameworkElement logicalParent);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void CopyTo(Array array, int index);
    public virtual void CopyTo(UIElement[] array, int index);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual UIElement get_Item(int index);
    public virtual void set_Item(int index, UIElement value);
    internal void SetInternal(int index, UIElement item);
    public virtual int Add(UIElement element);
    internal int AddInternal(UIElement element);
    public virtual int IndexOf(UIElement element);
    public virtual void Remove(UIElement element);
    internal void RemoveInternal(UIElement element);
    internal virtual void RemoveNoVerify(UIElement element);
    public virtual bool Contains(UIElement element);
    public virtual void Clear();
    internal void ClearInternal();
    public virtual void Insert(int index, UIElement element);
    internal void InsertInternal(int index, UIElement element);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    internal void RemoveRangeInternal(int index, int count);
    internal void MoveVisualChild(Visual visual, Visual destination);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public virtual IEnumerator GetEnumerator();
    protected void SetLogicalParent(UIElement element);
    protected void ClearLogicalParent(UIElement element);
    internal UIElement get_VisualParent();
    internal FrameworkElement get_LogicalParent();
}
public enum System.Windows.Controls.UndoAction : Enum {
    public int value__;
    public static UndoAction None;
    public static UndoAction Merge;
    public static UndoAction Undo;
    public static UndoAction Redo;
    public static UndoAction Clear;
    public static UndoAction Create;
}
public class System.Windows.Controls.UserControl : ContentControl {
    internal FrameworkElement StateGroupsRoot { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static UserControl();
    internal virtual void AdjustBranchSource(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual FrameworkElement get_StateGroupsRoot();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public static class System.Windows.Controls.Validation : object {
    public static RoutedEvent ErrorEvent;
    internal static DependencyPropertyKey ErrorsPropertyKey;
    public static DependencyProperty ErrorsProperty;
    internal static DependencyProperty ValidationErrorsInternalProperty;
    internal static DependencyPropertyKey HasErrorPropertyKey;
    public static DependencyProperty HasErrorProperty;
    public static DependencyProperty ErrorTemplateProperty;
    public static DependencyProperty ValidationAdornerSiteProperty;
    public static DependencyProperty ValidationAdornerSiteForProperty;
    private static Validation();
    public static void AddErrorHandler(DependencyObject element, EventHandler`1<ValidationErrorEventArgs> handler);
    public static void RemoveErrorHandler(DependencyObject element, EventHandler`1<ValidationErrorEventArgs> handler);
    public static ReadOnlyObservableCollection`1<ValidationError> GetErrors(DependencyObject element);
    internal static ValidationErrorCollection GetErrorsInternal(DependencyObject target);
    public static bool GetHasError(DependencyObject element);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ControlTemplate GetErrorTemplate(DependencyObject element);
    public static void SetErrorTemplate(DependencyObject element, ControlTemplate value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static DependencyObject GetValidationAdornerSite(DependencyObject element);
    public static void SetValidationAdornerSite(DependencyObject element, DependencyObject value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static DependencyObject GetValidationAdornerSiteFor(DependencyObject element);
    public static void SetValidationAdornerSiteFor(DependencyObject element, DependencyObject value);
    internal static void ShowValidationAdorner(DependencyObject targetElement, bool show);
    public static void MarkInvalid(BindingExpressionBase bindingExpression, ValidationError validationError);
    public static void ClearInvalid(BindingExpressionBase bindingExpression);
    internal static void AddValidationError(ValidationError validationError, DependencyObject targetElement, bool shouldRaiseEvent);
    internal static void RemoveValidationError(ValidationError validationError, DependencyObject targetElement, bool shouldRaiseEvent);
}
public class System.Windows.Controls.ValidationError : object {
    public ValidationRule RuleInError { get; public set; }
    public object ErrorContent { get; public set; }
    public Exception Exception { get; public set; }
    public object BindingInError { get; }
    public ValidationError(ValidationRule ruleInError, object bindingInError, object errorContent, Exception exception);
    public ValidationError(ValidationRule ruleInError, object bindingInError);
    public ValidationRule get_RuleInError();
    public void set_RuleInError(ValidationRule value);
    public object get_ErrorContent();
    public void set_ErrorContent(object value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public object get_BindingInError();
}
public enum System.Windows.Controls.ValidationErrorEventAction : Enum {
    public int value__;
    public static ValidationErrorEventAction Added;
    public static ValidationErrorEventAction Removed;
}
public class System.Windows.Controls.ValidationErrorEventArgs : RoutedEventArgs {
    public ValidationError Error { get; }
    public ValidationErrorEventAction Action { get; }
    internal ValidationErrorEventArgs(ValidationError validationError, ValidationErrorEventAction action);
    public ValidationError get_Error();
    public ValidationErrorEventAction get_Action();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ValidationResult : object {
    public bool IsValid { get; }
    public object ErrorContent { get; }
    public static ValidationResult ValidResult { get; }
    public ValidationResult(bool isValid, object errorContent);
    private static ValidationResult();
    public bool get_IsValid();
    public object get_ErrorContent();
    public static ValidationResult get_ValidResult();
    public static bool op_Equality(ValidationResult left, ValidationResult right);
    public static bool op_Inequality(ValidationResult left, ValidationResult right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.Windows.Controls.ValidationRule : object {
    public ValidationStep ValidationStep { get; public set; }
    public bool ValidatesOnTargetUpdated { get; public set; }
    protected ValidationRule(ValidationStep validationStep, bool validatesOnTargetUpdated);
    public abstract virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo, BindingExpressionBase owner);
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo, BindingGroup owner);
    public ValidationStep get_ValidationStep();
    public void set_ValidationStep(ValidationStep value);
    public bool get_ValidatesOnTargetUpdated();
    public void set_ValidatesOnTargetUpdated(bool value);
}
public enum System.Windows.Controls.ValidationStep : Enum {
    public int value__;
    public static ValidationStep RawProposedValue;
    public static ValidationStep ConvertedProposedValue;
    public static ValidationStep UpdatedValue;
    public static ValidationStep CommittedValue;
}
public abstract class System.Windows.Controls.ViewBase : DependencyObject {
    protected internal object DefaultStyleKey { get; }
    protected internal object ItemContainerDefaultStyleKey { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsUsed { get; internal set; }
    protected internal virtual void PrepareItem(ListViewItem item);
    protected internal virtual void ClearItem(ListViewItem item);
    protected internal virtual object get_DefaultStyleKey();
    protected internal virtual object get_ItemContainerDefaultStyleKey();
    internal virtual void OnThemeChanged();
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    protected internal virtual IViewAutomationPeer GetAutomationPeer(ListView parent);
    internal bool get_IsUsed();
    internal void set_IsUsed(bool value);
}
public class System.Windows.Controls.Viewbox : Decorator {
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    private static Viewbox();
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static Size ComputeScaleFactor(Size availableSize, Size contentSize, Stretch stretch, StretchDirection stretchDirection);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.Viewport3D : FrameworkElement {
    public static DependencyProperty CameraProperty;
    public static DependencyProperty ChildrenProperty;
    public Camera Camera { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected int VisualChildrenCount { get; }
    private static Viewport3D();
    public Camera get_Camera();
    public void set_Camera(Camera value);
    public Visual3DCollection get_Children();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
}
[TypeConverterAttribute("System.Windows.Controls.VirtualizationCacheLengthConverter")]
public class System.Windows.Controls.VirtualizationCacheLength : ValueType {
    private double _cacheBeforeViewport;
    private double _cacheAfterViewport;
    public double CacheBeforeViewport { get; }
    public double CacheAfterViewport { get; }
    public VirtualizationCacheLength(double cacheBeforeAndAfterViewport);
    public VirtualizationCacheLength(double cacheBeforeViewport, double cacheAfterViewport);
    public static bool op_Equality(VirtualizationCacheLength cl1, VirtualizationCacheLength cl2);
    public static bool op_Inequality(VirtualizationCacheLength cl1, VirtualizationCacheLength cl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(VirtualizationCacheLength cacheLength);
    public virtual int GetHashCode();
    public double get_CacheBeforeViewport();
    public double get_CacheAfterViewport();
    public virtual string ToString();
}
public class System.Windows.Controls.VirtualizationCacheLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(VirtualizationCacheLength cacheLength, CultureInfo cultureInfo);
    internal static VirtualizationCacheLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.VirtualizationCacheLengthUnit : Enum {
    public int value__;
    public static VirtualizationCacheLengthUnit Pixel;
    public static VirtualizationCacheLengthUnit Item;
    public static VirtualizationCacheLengthUnit Page;
}
public enum System.Windows.Controls.VirtualizationMode : Enum {
    public int value__;
    public static VirtualizationMode Standard;
    public static VirtualizationMode Recycling;
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Controls.VirtualizedCellInfoCollection : object {
    public DataGridCellInfo Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; private set; }
    protected bool IsEmpty { get; }
    protected DataGrid Owner { get; }
    internal VirtualizedCellInfoCollection(DataGrid owner);
    internal static VirtualizedCellInfoCollection MakeEmptyCollection(DataGrid owner);
    public sealed virtual void Add(DataGridCellInfo cell);
    internal void AddValidatedCell(DataGridCellInfo cell);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(DataGridCellInfo cell);
    internal bool Contains(DataGridCell cell);
    internal bool Contains(int rowIndex, int columnIndex);
    public sealed virtual void CopyTo(DataGridCellInfo[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<DataGridCellInfo> GetEnumerator();
    public sealed virtual int IndexOf(DataGridCellInfo cell);
    public sealed virtual void Insert(int index, DataGridCellInfo cell);
    public sealed virtual bool Remove(DataGridCellInfo cell);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual DataGridCellInfo get_Item(int index);
    public sealed virtual void set_Item(int index, DataGridCellInfo value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private void set_IsReadOnly(bool value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
    protected bool get_IsEmpty();
    protected void GetBoundingRegion(Int32& left, Int32& top, Int32& right, Int32& bottom);
    internal void AddRegion(int rowIndex, int columnIndex, int rowCount, int columnCount);
    internal void RemoveRegion(int rowIndex, int columnIndex, int rowCount, int columnCount);
    internal void OnItemsCollectionChanged(NotifyCollectionChangedEventArgs e, List`1<Tuple`2<int, int>> ranges);
    internal void OnColumnsChanged(NotifyCollectionChangedAction action, int oldDisplayIndex, DataGridColumn oldColumn, int newDisplayIndex, IList selectedRows);
    internal void Union(VirtualizedCellInfoCollection collection);
    internal static void Xor(VirtualizedCellInfoCollection c1, VirtualizedCellInfoCollection c2);
    internal void ClearFullRows(IList rows);
    internal void RestoreOnlyFullRows(List`1<Tuple`2<int, int>> ranges);
    internal void RemoveAllButOne(DataGridCellInfo cellInfo);
    internal void RemoveAllButOne();
    internal void RemoveAllButOneRow(int rowIndex);
    internal bool Intersects(int rowIndex);
    internal bool Intersects(int rowIndex, List`1& columnIndexRanges);
    protected DataGrid get_Owner();
    protected virtual DataGridCellInfo CreateCellInfo(ItemInfo rowInfo, DataGridColumn column, DataGrid owner);
}
public abstract class System.Windows.Controls.VirtualizingPanel : Panel {
    public static DependencyProperty IsVirtualizingProperty;
    public static DependencyProperty VirtualizationModeProperty;
    public static DependencyProperty IsVirtualizingWhenGroupingProperty;
    public static DependencyProperty ScrollUnitProperty;
    public static DependencyProperty CacheLengthProperty;
    public static DependencyProperty CacheLengthUnitProperty;
    public static DependencyProperty IsContainerVirtualizableProperty;
    internal static DependencyProperty ShouldCacheContainerSizeProperty;
    public bool CanHierarchicallyScrollAndVirtualize { get; }
    protected bool CanHierarchicallyScrollAndVirtualizeCore { get; }
    public IItemContainerGenerator ItemContainerGenerator { get; }
    private static VirtualizingPanel();
    public bool get_CanHierarchicallyScrollAndVirtualize();
    protected virtual bool get_CanHierarchicallyScrollAndVirtualizeCore();
    public double GetItemOffset(UIElement child);
    protected virtual double GetItemOffsetCore(UIElement child);
    public static bool GetIsVirtualizing(DependencyObject element);
    public static void SetIsVirtualizing(DependencyObject element, bool value);
    public static VirtualizationMode GetVirtualizationMode(DependencyObject element);
    public static void SetVirtualizationMode(DependencyObject element, VirtualizationMode value);
    public static bool GetIsVirtualizingWhenGrouping(DependencyObject element);
    public static void SetIsVirtualizingWhenGrouping(DependencyObject element, bool value);
    public static ScrollUnit GetScrollUnit(DependencyObject element);
    public static void SetScrollUnit(DependencyObject element, ScrollUnit value);
    public static VirtualizationCacheLength GetCacheLength(DependencyObject element);
    public static void SetCacheLength(DependencyObject element, VirtualizationCacheLength value);
    public static VirtualizationCacheLengthUnit GetCacheLengthUnit(DependencyObject element);
    public static void SetCacheLengthUnit(DependencyObject element, VirtualizationCacheLengthUnit value);
    public static bool GetIsContainerVirtualizable(DependencyObject element);
    public static void SetIsContainerVirtualizable(DependencyObject element, bool value);
    internal static bool GetShouldCacheContainerSize(DependencyObject element);
    internal static void OnVirtualizationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public IItemContainerGenerator get_ItemContainerGenerator();
    internal virtual void GenerateChildren();
    protected void AddInternalChild(UIElement child);
    protected void InsertInternalChild(int index, UIElement child);
    protected void RemoveInternalChildRange(int index, int range);
    internal static void AddInternalChild(UIElementCollection children, UIElement child);
    internal static void InsertInternalChild(UIElementCollection children, int index, UIElement child);
    internal static void RemoveInternalChildRange(UIElementCollection children, int index, int range);
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    public bool ShouldItemsChangeAffectLayout(bool areItemChangesLocal, ItemsChangedEventArgs args);
    protected virtual bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args);
    protected virtual void OnClearChildren();
    public void BringIndexIntoViewPublic(int index);
    protected internal virtual void BringIndexIntoView(int index);
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    internal virtual void OnClearChildrenInternal();
}
public class System.Windows.Controls.VirtualizingStackPanel : VirtualizingPanel {
    internal static DependencyProperty ItemsHostInsetProperty;
    public static DependencyProperty IsVirtualizingProperty;
    public static DependencyProperty VirtualizationModeProperty;
    public static DependencyProperty OrientationProperty;
    public static RoutedEvent CleanUpVirtualizedItemEvent;
    public Orientation Orientation { get; public set; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal Orientation LogicalOrientation { get; }
    [DefaultValueAttribute("False")]
public bool CanHorizontallyScroll { get; public set; }
    [DefaultValueAttribute("False")]
public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    protected bool CanHierarchicallyScrollAndVirtualizeCore { get; }
    internal bool IsScrolling { get; }
    internal bool IsPixelBased { get; internal set; }
    internal bool MustDisableVirtualization { get; internal set; }
    internal bool MeasureCaches { get; internal set; }
    internal bool IgnoreMaxDesiredSize { get; internal set; }
    internal static bool IsVSP45Compat { get; }
    private bool System.Windows.Controls.IStackMeasure.IsScrolling { get; }
    private UIElementCollection System.Windows.Controls.IStackMeasure.InternalChildren { get; }
    private static VirtualizingStackPanel();
    public virtual void LineUp();
    public virtual void LineDown();
    public virtual void LineLeft();
    public virtual void LineRight();
    public virtual void PageUp();
    public virtual void PageDown();
    public virtual void PageLeft();
    public virtual void PageRight();
    public virtual void MouseWheelUp();
    public virtual void MouseWheelDown();
    public virtual void MouseWheelLeft();
    public virtual void MouseWheelRight();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    internal void AnchoredInvalidateMeasure();
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    protected internal virtual void BringIndexIntoView(int index);
    public sealed virtual Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal virtual Orientation get_LogicalOrientation();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public static void AddCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler);
    public static void RemoveCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler);
    protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e);
    protected virtual bool get_CanHierarchicallyScrollAndVirtualizeCore();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    internal void ResetMaximumDesiredSize();
    protected virtual bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args);
    protected virtual void OnClearChildren();
    internal void ClearAllContainers();
    protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize);
    protected virtual void OnViewportOffsetChanged(Vector oldViewportOffset, Vector newViewportOffset);
    protected virtual double GetItemOffsetCore(UIElement child);
    internal bool get_IsScrolling();
    internal bool get_IsPixelBased();
    internal void set_IsPixelBased(bool value);
    internal bool get_MustDisableVirtualization();
    internal void set_MustDisableVirtualization(bool value);
    internal bool get_MeasureCaches();
    internal void set_MeasureCaches(bool value);
    internal bool get_IgnoreMaxDesiredSize();
    internal void set_IgnoreMaxDesiredSize(bool value);
    internal static bool get_IsVSP45Compat();
    private sealed virtual override bool System.Windows.Controls.IStackMeasure.get_IsScrolling();
    private sealed virtual override UIElementCollection System.Windows.Controls.IStackMeasure.get_InternalChildren();
    private sealed virtual override void System.Windows.Controls.IStackMeasure.OnScrollChange();
}
internal static class System.Windows.Controls.VisualStates : object {
    internal static string StateToday;
    internal static string StateRegularDay;
    internal static string GroupDay;
    internal static string StateBlackoutDay;
    internal static string StateNormalDay;
    internal static string GroupBlackout;
    public static string StateCalendarButtonUnfocused;
    public static string StateCalendarButtonFocused;
    public static string GroupCalendarButtonFocus;
    public static string StateNormal;
    public static string StateMouseOver;
    public static string StatePressed;
    public static string StateDisabled;
    public static string StateReadOnly;
    internal static string StateDeterminate;
    public static string GroupCommon;
    public static string StateUnfocused;
    public static string StateFocused;
    public static string StateFocusedDropDown;
    public static string GroupFocus;
    public static string StateExpanded;
    public static string StateCollapsed;
    public static string GroupExpansion;
    public static string StateOpen;
    public static string StateClosed;
    public static string GroupOpen;
    public static string StateHasItems;
    public static string StateNoItems;
    public static string GroupHasItems;
    public static string StateExpandDown;
    public static string StateExpandUp;
    public static string StateExpandLeft;
    public static string StateExpandRight;
    public static string GroupExpandDirection;
    public static string StateSelected;
    public static string StateSelectedUnfocused;
    public static string StateSelectedInactive;
    public static string StateUnselected;
    public static string GroupSelection;
    public static string StateEditable;
    public static string StateUneditable;
    public static string GroupEdit;
    public static string StateActive;
    public static string StateInactive;
    public static string GroupActive;
    public static string StateValid;
    public static string StateInvalidFocused;
    public static string StateInvalidUnfocused;
    public static string GroupValidation;
    public static string StateUnwatermarked;
    public static string StateWatermarked;
    public static string GroupWatermark;
    public static string StateChecked;
    public static string StateUnchecked;
    public static string StateIndeterminate;
    public static string GroupCheck;
    public static string StateRegular;
    public static string StateCurrent;
    public static string GroupCurrent;
    public static string StateDisplay;
    public static string StateEditing;
    public static string GroupInteraction;
    public static string StateUnsorted;
    public static string StateSortAscending;
    public static string StateSortDescending;
    public static string GroupSort;
    public static string DATAGRIDROW_stateAlternate;
    public static string DATAGRIDROW_stateMouseOver;
    public static string DATAGRIDROW_stateMouseOverEditing;
    public static string DATAGRIDROW_stateMouseOverEditingFocused;
    public static string DATAGRIDROW_stateMouseOverSelected;
    public static string DATAGRIDROW_stateMouseOverSelectedFocused;
    public static string DATAGRIDROW_stateNormal;
    public static string DATAGRIDROW_stateNormalEditing;
    public static string DATAGRIDROW_stateNormalEditingFocused;
    public static string DATAGRIDROW_stateSelected;
    public static string DATAGRIDROW_stateSelectedFocused;
    public static string DATAGRIDROWHEADER_stateMouseOver;
    public static string DATAGRIDROWHEADER_stateMouseOverCurrentRow;
    public static string DATAGRIDROWHEADER_stateMouseOverEditingRow;
    public static string DATAGRIDROWHEADER_stateMouseOverEditingRowFocused;
    public static string DATAGRIDROWHEADER_stateMouseOverSelected;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRow;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRowFocused;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedFocused;
    public static string DATAGRIDROWHEADER_stateNormal;
    public static string DATAGRIDROWHEADER_stateNormalCurrentRow;
    public static string DATAGRIDROWHEADER_stateNormalEditingRow;
    public static string DATAGRIDROWHEADER_stateNormalEditingRowFocused;
    public static string DATAGRIDROWHEADER_stateSelected;
    public static string DATAGRIDROWHEADER_stateSelectedCurrentRow;
    public static string DATAGRIDROWHEADER_stateSelectedCurrentRowFocused;
    public static string DATAGRIDROWHEADER_stateSelectedFocused;
    public static void GoToState(Control control, bool useTransitions, String[] stateNames);
}
public class System.Windows.Controls.WebBrowser : ActiveXHost {
    internal bool _canGoBack;
    internal bool _canGoForward;
    internal static string AboutBlankUriString;
    public Uri Source { get; public set; }
    public bool CanGoBack { get; }
    public bool CanGoForward { get; }
    public object ObjectForScripting { get; public set; }
    public object Document { get; }
    internal IHTMLDocument2 NativeHTMLDocument { get; }
    [DebuggerBrowsableAttribute("0")]
internal IWebBrowser2 AxIWebBrowser2 { get; }
    internal WebOCHostingAdaptor HostingAdaptor { get; }
    internal Stream DocumentStream { get; internal set; }
    internal bool NavigatingToAboutBlank { get; internal set; }
    internal Guid LastNavigation { get; internal set; }
    internal static bool IsWebOCHostedInBrowserProcess { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static WebBrowser();
    public void Navigate(Uri source);
    public void Navigate(string source);
    public void Navigate(Uri source, string targetFrameName, Byte[] postData, string additionalHeaders);
    public void Navigate(string source, string targetFrameName, Byte[] postData, string additionalHeaders);
    public void NavigateToStream(Stream stream);
    public void NavigateToString(string text);
    [SecurityCriticalAttribute]
public void GoBack();
    [SecurityCriticalAttribute]
public void GoForward();
    [SecurityCriticalAttribute]
public void Refresh();
    [SecurityCriticalAttribute]
public void Refresh(bool noCache);
    public object InvokeScript(string scriptName);
    [SecurityCriticalAttribute]
public object InvokeScript(string scriptName, Object[] args);
    public void set_Source(Uri value);
    [SecurityCriticalAttribute]
public Uri get_Source();
    public bool get_CanGoBack();
    public bool get_CanGoForward();
    public object get_ObjectForScripting();
    [SecurityCriticalAttribute]
public void set_ObjectForScripting(object value);
    [SecurityCriticalAttribute]
public object get_Document();
    [CompilerGeneratedAttribute]
public void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(LoadCompletedEventHandler value);
    internal void OnNavigating(NavigatingCancelEventArgs e);
    internal void OnNavigated(NavigationEventArgs e);
    internal void OnLoadCompleted(NavigationEventArgs e);
    [SecurityCriticalAttribute]
internal virtual object CreateActiveXObject(Guid clsid);
    [SecurityCriticalAttribute]
internal virtual void AttachInterfaces(object nativeActiveXObject);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void DetachInterfaces();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void CreateSink();
    [SecurityCriticalAttribute]
internal virtual void DetachSink();
    [SecurityCriticalAttribute]
internal virtual ActiveXSite CreateActiveXSite();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual DrawingGroup GetDrawing();
    [SecurityCriticalAttribute]
internal void CleanInternalState();
    [SecurityCriticalAttribute]
internal IHTMLDocument2 get_NativeHTMLDocument();
    [SecurityCriticalAttribute]
internal IWebBrowser2 get_AxIWebBrowser2();
    internal WebOCHostingAdaptor get_HostingAdaptor();
    internal Stream get_DocumentStream();
    internal void set_DocumentStream(Stream value);
    internal bool get_NavigatingToAboutBlank();
    [SecurityCriticalAttribute]
internal void set_NavigatingToAboutBlank(bool value);
    internal Guid get_LastNavigation();
    [SecurityCriticalAttribute]
internal void set_LastNavigation(Guid value);
    internal static bool get_IsWebOCHostedInBrowserProcess();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
protected virtual bool TabIntoCore(TraversalRequest request);
}
public class System.Windows.Controls.WrapPanel : Panel {
    public static DependencyProperty ItemWidthProperty;
    public static DependencyProperty ItemHeightProperty;
    public static DependencyProperty OrientationProperty;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemHeight { get; public set; }
    public Orientation Orientation { get; public set; }
    private static WrapPanel();
    public double get_ItemWidth();
    public void set_ItemWidth(double value);
    public double get_ItemHeight();
    public void set_ItemHeight(double value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
}
[TypeConverterAttribute("System.Windows.CornerRadiusConverter")]
public class System.Windows.CornerRadius : ValueType {
    private double _topLeft;
    private double _topRight;
    private double _bottomLeft;
    private double _bottomRight;
    public double TopLeft { get; public set; }
    public double TopRight { get; public set; }
    public double BottomRight { get; public set; }
    public double BottomLeft { get; public set; }
    internal bool IsZero { get; }
    public CornerRadius(double uniformRadius);
    public CornerRadius(double topLeft, double topRight, double bottomRight, double bottomLeft);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CornerRadius cornerRadius);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(CornerRadius cr1, CornerRadius cr2);
    public static bool op_Inequality(CornerRadius cr1, CornerRadius cr2);
    public double get_TopLeft();
    public void set_TopLeft(double value);
    public double get_TopRight();
    public void set_TopRight(double value);
    public double get_BottomRight();
    public void set_BottomRight(double value);
    public double get_BottomLeft();
    public void set_BottomLeft(double value);
    internal bool IsValid(bool allowNegative, bool allowNaN, bool allowPositiveInfinity, bool allowNegativeInfinity);
    internal bool get_IsZero();
}
public class System.Windows.CornerRadiusConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(CornerRadius cr, CultureInfo cultureInfo);
    internal static CornerRadius FromString(string s, CultureInfo cultureInfo);
}
internal class System.Windows.CustomCategoryAttribute : CategoryAttribute {
    internal CustomCategoryAttribute(string name);
    protected virtual string GetLocalizedString(string value);
}
public class System.Windows.Data.Binding : BindingBase {
    public static RoutedEvent SourceUpdatedEvent;
    public static RoutedEvent TargetUpdatedEvent;
    public static DependencyProperty XmlNamespaceManagerProperty;
    public static object DoNothing;
    public static string IndexerName;
    public Collection`1<ValidationRule> ValidationRules { get; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnExceptions { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnDataErrors { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidatesOnNotifyDataErrors { get; public set; }
    public PropertyPath Path { get; public set; }
    [DefaultValueAttribute("")]
public string XPath { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public BindingMode Mode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnSourceUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnTargetUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnValidationError { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo ConverterCulture { get; public set; }
    public object Source { get; public set; }
    [DefaultValueAttribute("")]
public RelativeSource RelativeSource { get; public set; }
    [DefaultValueAttribute("")]
public string ElementName { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsAsync { get; public set; }
    [DefaultValueAttribute("")]
public object AsyncState { get; public set; }
    [DefaultValueAttribute("False")]
public bool BindsDirectlyToSource { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; public set; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal ObjectRef SourceReference { get; internal set; }
    internal bool TreeContextIsRequired { get; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal bool TransfersDefaultValue { get; internal set; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    public Binding(string path);
    private static Binding();
    public static void AddSourceUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void RemoveSourceUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void AddTargetUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void RemoveTargetUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static XmlNamespaceManager GetXmlNamespaceManager(DependencyObject target);
    public static void SetXmlNamespaceManager(DependencyObject target, XmlNamespaceManager value);
    public Collection`1<ValidationRule> get_ValidationRules();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeValidationRules();
    public bool get_ValidatesOnExceptions();
    public void set_ValidatesOnExceptions(bool value);
    public bool get_ValidatesOnDataErrors();
    public void set_ValidatesOnDataErrors(bool value);
    public bool get_ValidatesOnNotifyDataErrors();
    public void set_ValidatesOnNotifyDataErrors(bool value);
    public PropertyPath get_Path();
    public void set_Path(PropertyPath value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializePath();
    public string get_XPath();
    public void set_XPath(string value);
    public BindingMode get_Mode();
    public void set_Mode(BindingMode value);
    public UpdateSourceTrigger get_UpdateSourceTrigger();
    public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_NotifyOnSourceUpdated();
    public void set_NotifyOnSourceUpdated(bool value);
    public bool get_NotifyOnTargetUpdated();
    public void set_NotifyOnTargetUpdated(bool value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
    public CultureInfo get_ConverterCulture();
    public void set_ConverterCulture(CultureInfo value);
    public object get_Source();
    public void set_Source(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSource();
    public RelativeSource get_RelativeSource();
    public void set_RelativeSource(RelativeSource value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public object get_AsyncState();
    public void set_AsyncState(object value);
    public bool get_BindsDirectlyToSource();
    public void set_BindsDirectlyToSource(bool value);
    public UpdateSourceExceptionFilterCallback get_UpdateSourceExceptionFilter();
    public void set_UpdateSourceExceptionFilter(UpdateSourceExceptionFilterCallback value);
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal object DoFilterException(object bindExpr, Exception exception);
    internal void UsePath(PropertyPath path);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal ObjectRef get_SourceReference();
    internal void set_SourceReference(ObjectRef value);
    internal bool get_TreeContextIsRequired();
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal bool get_TransfersDefaultValue();
    internal void set_TransfersDefaultValue(bool value);
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
}
[MarkupExtensionReturnTypeAttribute("System.Object")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Data.BindingBase : MarkupExtension {
    public object FallbackValue { get; public set; }
    [DefaultValueAttribute("")]
public string StringFormat { get; public set; }
    public object TargetNullValue { get; public set; }
    [DefaultValueAttribute("")]
public string BindingGroupName { get; public set; }
    [DefaultValueAttribute("0")]
public int Delay { get; public set; }
    internal BindingFlags Flags { get; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    private static BindingBase();
    public object get_FallbackValue();
    public void set_FallbackValue(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeFallbackValue();
    public string get_StringFormat();
    public void set_StringFormat(string value);
    public object get_TargetNullValue();
    public void set_TargetNullValue(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTargetNullValue();
    public string get_BindingGroupName();
    public void set_BindingGroupName(string value);
    public int get_Delay();
    public void set_Delay(int value);
    public sealed virtual object ProvideValue(IServiceProvider serviceProvider);
    internal abstract virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject targetObject, DependencyProperty targetProperty, BindingExpressionBase owner);
    internal bool TestFlag(BindingFlags flag);
    internal void SetFlag(BindingFlags flag);
    internal void ClearFlag(BindingFlags flag);
    internal void ChangeFlag(BindingFlags flag, bool value);
    internal BindingFlags GetFlagsWithinMask(BindingFlags mask);
    internal void ChangeFlagsWithinMask(BindingFlags mask, BindingFlags flags);
    internal static BindingFlags FlagsFrom(BindingMode bindingMode);
    internal static BindingFlags FlagsFrom(UpdateSourceTrigger updateSourceTrigger);
    internal BindingFlags get_Flags();
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
    internal BindingExpressionBase CreateBindingExpression(DependencyObject targetObject, DependencyProperty targetProperty);
    internal BindingExpressionBase CreateBindingExpression(DependencyObject targetObject, DependencyProperty targetProperty, BindingExpressionBase owner);
    internal void CheckSealed();
    internal ValidationRule GetValidationRule(Type type);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal static ValidationRule LookupValidationRule(Type type, Collection`1<ValidationRule> collection);
    internal BindingBase Clone(BindingMode mode);
    internal virtual void InitializeClone(BindingBase clone, BindingMode mode);
    internal abstract virtual BindingBase CreateClone();
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
    internal void CopyValue(Feature id, BindingBase clone);
}
public class System.Windows.Data.BindingExpression : BindingExpressionBase {
    internal static object NullDataItem;
    internal static object IgnoreDefaultValue;
    internal static object StaticSource;
    private DependencyObject MS.Internal.Data.IDataBindEngineClient.TargetElement { get; }
    public Binding ParentBinding { get; }
    public object DataItem { get; }
    public object ResolvedSource { get; }
    public string ResolvedSourcePropertyName { get; }
    internal object DataSource { get; }
    internal DependencyObject ContextElement { get; }
    internal CollectionViewSource CollectionViewSource { get; internal set; }
    internal bool IgnoreSourcePropertyChange { get; }
    internal PropertyPath Path { get; }
    internal IValueConverter Converter { get; internal set; }
    internal Type ConverterSourceType { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal object SourceValue { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    internal bool IsDisconnected { get; }
    private static BindingExpression();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.TransferValue();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.UpdateValue();
    private sealed virtual override bool MS.Internal.Data.IDataBindEngineClient.AttachToContext(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.VerifySourceReference(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.OnTargetUpdated();
    private sealed virtual override DependencyObject MS.Internal.Data.IDataBindEngineClient.get_TargetElement();
    public Binding get_ParentBinding();
    public object get_DataItem();
    public object get_ResolvedSource();
    public string get_ResolvedSourcePropertyName();
    internal object get_DataSource();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal DependencyObject get_ContextElement();
    internal CollectionViewSource get_CollectionViewSource();
    internal void set_CollectionViewSource(CollectionViewSource value);
    internal bool get_IgnoreSourcePropertyChange();
    internal PropertyPath get_Path();
    internal IValueConverter get_Converter();
    internal void set_Converter(IValueConverter value);
    internal Type get_ConverterSourceType();
    internal object get_SourceItem();
    internal string get_SourcePropertyName();
    internal object get_SourceValue();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal virtual bool get_IsDisconnected();
    internal static BindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, Binding binding, BindingExpressionBase parent);
    internal void SetupDefaultValueConverter(Type type);
    internal static bool HasLocalDataContext(DependencyObject d);
    internal virtual bool AttachOverride(DependencyObject target, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal virtual void Activate();
    internal void Activate(object item);
    internal virtual void Deactivate();
    internal virtual void Disconnect();
    internal virtual object GetSourceItem(object newValue);
    internal void ChangeWorkerSources(WeakDependencySource[] newWorkerSources, int n);
    internal void TransferValue(object newValue, bool isASubPropertyChange);
    internal void ScheduleTransfer(bool isASubPropertyChange);
    internal virtual bool UpdateOverride();
    internal virtual object ConvertProposedValue(object value);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object value);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal void UpdateNotifyDataErrors(INotifyDataErrorInfo indei, string propertyName, object value);
    internal static List`1<object> GetDataErrors(INotifyDataErrorInfo indei, string propertyName);
    internal void OnCurrentChanged(object sender, EventArgs e);
    internal void OnCurrentChanging(object sender, CurrentChangingEventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal IDisposable ChangingValue();
    internal void CancelPendingTasks();
    internal static void OnTargetUpdated(DependencyObject d, DependencyProperty dp);
    internal static void OnSourceUpdated(DependencyObject d, DependencyProperty dp);
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
}
public abstract class System.Windows.Data.BindingExpressionBase : Expression {
    internal static DependencyProperty NoTargetProperty;
    internal static object DefaultValueObject;
    internal static object DisconnectedItem;
    public DependencyObject Target { get; }
    public DependencyProperty TargetProperty { get; }
    public BindingBase ParentBindingBase { get; }
    public BindingGroup BindingGroup { get; }
    public BindingStatus Status { get; }
    internal BindingStatusInternal StatusInternal { get; }
    public ValidationError ValidationError { get; }
    internal ValidationError BaseValidationError { get; }
    internal List`1<ValidationError> NotifyDataErrors { get; }
    public bool HasError { get; }
    public bool HasValidationError { get; }
    public bool IsDirty { get; }
    public ReadOnlyCollection`1<ValidationError> ValidationErrors { get; }
    internal bool IsAttaching { get; internal set; }
    internal bool IsDetaching { get; internal set; }
    internal bool IsDetached { get; }
    internal bool IsDynamic { get; }
    internal bool IsReflective { get; internal set; }
    internal bool UseDefaultValueConverter { get; internal set; }
    internal bool IsOneWayToSource { get; }
    internal bool IsUpdateOnPropertyChanged { get; }
    internal bool IsUpdateOnLostFocus { get; }
    internal bool IsTransferPending { get; internal set; }
    internal bool TransferIsDeferred { get; internal set; }
    internal bool IsInTransfer { get; internal set; }
    internal bool IsInUpdate { get; internal set; }
    internal bool UsingFallbackValue { get; internal set; }
    internal bool UsingMentor { get; internal set; }
    internal bool ResolveNamesInTemplate { get; internal set; }
    internal bool NeedsDataTransfer { get; internal set; }
    internal bool NeedsUpdate { get; internal set; }
    internal bool NeedsValidation { get; internal set; }
    internal bool NotifyOnTargetUpdated { get; internal set; }
    internal bool NotifyOnSourceUpdated { get; internal set; }
    internal bool NotifyOnValidationError { get; internal set; }
    internal bool IsInPriorityBindingExpression { get; }
    internal bool IsInMultiBindingExpression { get; }
    internal bool IsInBindingExpressionCollection { get; }
    internal bool ValidatesOnExceptions { get; }
    internal bool ValidatesOnDataErrors { get; }
    internal bool TargetWantsCrossThreadNotifications { get; internal set; }
    internal bool IsDataErrorsChangedPending { get; internal set; }
    internal bool IsUpdateDeferredForComposition { get; internal set; }
    internal bool ValidatesOnNotifyDataErrors { get; }
    internal MultiBindingExpression ParentMultiBindingExpression { get; }
    internal PriorityBindingExpression ParentPriorityBindingExpression { get; }
    internal BindingExpressionBase ParentBindingExpressionBase { get; }
    internal object FallbackValue { get; }
    internal object DefaultValue { get; }
    internal string EffectiveStringFormat { get; }
    internal object EffectiveTargetNullValue { get; }
    internal BindingExpressionBase RootBindingExpression { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    internal bool UsesLanguage { get; }
    internal bool IsEligibleForCommit { get; }
    internal DependencyObject TargetElement { get; }
    internal WeakReference TargetElementReference { get; }
    internal DataBindEngine Engine { get; }
    internal Dispatcher Dispatcher { get; }
    internal object Value { get; internal set; }
    internal WeakDependencySource[] WeakSources { get; }
    internal bool IsDisconnected { get; }
    internal TraceEventType TraceLevel { get; }
    private static BindingExpressionBase();
    internal BindingExpressionBase(BindingBase binding, BindingExpressionBase parent);
    public DependencyObject get_Target();
    public DependencyProperty get_TargetProperty();
    public BindingBase get_ParentBindingBase();
    public BindingGroup get_BindingGroup();
    public BindingStatus get_Status();
    internal BindingStatusInternal get_StatusInternal();
    public virtual ValidationError get_ValidationError();
    internal ValidationError get_BaseValidationError();
    internal List`1<ValidationError> get_NotifyDataErrors();
    public virtual bool get_HasError();
    public virtual bool get_HasValidationError();
    public bool get_IsDirty();
    public virtual ReadOnlyCollection`1<ValidationError> get_ValidationErrors();
    public virtual void UpdateTarget();
    public virtual void UpdateSource();
    public bool ValidateWithoutUpdate();
    internal sealed virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal sealed virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual DependencySource[] GetSources();
    internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal static BindingExpressionBase CreateUntargetedBindingExpression(DependencyObject d, BindingBase binding);
    internal void Attach(DependencyObject d);
    [CompilerGeneratedAttribute]
internal void add_ValueChanged(EventHandler`1<BindingValueChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ValueChanged(EventHandler`1<BindingValueChangedEventArgs> value);
    internal bool get_IsAttaching();
    internal void set_IsAttaching(bool value);
    internal bool get_IsDetaching();
    internal void set_IsDetaching(bool value);
    internal bool get_IsDetached();
    internal bool get_IsDynamic();
    internal bool get_IsReflective();
    internal void set_IsReflective(bool value);
    internal bool get_UseDefaultValueConverter();
    internal void set_UseDefaultValueConverter(bool value);
    internal bool get_IsOneWayToSource();
    internal bool get_IsUpdateOnPropertyChanged();
    internal bool get_IsUpdateOnLostFocus();
    internal bool get_IsTransferPending();
    internal void set_IsTransferPending(bool value);
    internal bool get_TransferIsDeferred();
    internal void set_TransferIsDeferred(bool value);
    internal bool get_IsInTransfer();
    internal void set_IsInTransfer(bool value);
    internal bool get_IsInUpdate();
    internal void set_IsInUpdate(bool value);
    internal bool get_UsingFallbackValue();
    internal void set_UsingFallbackValue(bool value);
    internal bool get_UsingMentor();
    internal void set_UsingMentor(bool value);
    internal bool get_ResolveNamesInTemplate();
    internal void set_ResolveNamesInTemplate(bool value);
    internal bool get_NeedsDataTransfer();
    internal void set_NeedsDataTransfer(bool value);
    internal bool get_NeedsUpdate();
    internal void set_NeedsUpdate(bool value);
    internal bool get_NeedsValidation();
    internal void set_NeedsValidation(bool value);
    internal bool get_NotifyOnTargetUpdated();
    internal void set_NotifyOnTargetUpdated(bool value);
    internal bool get_NotifyOnSourceUpdated();
    internal void set_NotifyOnSourceUpdated(bool value);
    internal bool get_NotifyOnValidationError();
    internal void set_NotifyOnValidationError(bool value);
    internal bool get_IsInPriorityBindingExpression();
    internal bool get_IsInMultiBindingExpression();
    internal bool get_IsInBindingExpressionCollection();
    internal bool get_ValidatesOnExceptions();
    internal bool get_ValidatesOnDataErrors();
    internal bool get_TargetWantsCrossThreadNotifications();
    internal void set_TargetWantsCrossThreadNotifications(bool value);
    internal bool get_IsDataErrorsChangedPending();
    internal void set_IsDataErrorsChangedPending(bool value);
    internal bool get_IsUpdateDeferredForComposition();
    internal void set_IsUpdateDeferredForComposition(bool value);
    internal bool get_ValidatesOnNotifyDataErrors();
    internal MultiBindingExpression get_ParentMultiBindingExpression();
    internal PriorityBindingExpression get_ParentPriorityBindingExpression();
    internal BindingExpressionBase get_ParentBindingExpressionBase();
    internal object get_FallbackValue();
    internal object get_DefaultValue();
    internal string get_EffectiveStringFormat();
    internal object get_EffectiveTargetNullValue();
    internal BindingExpressionBase get_RootBindingExpression();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal bool get_UsesLanguage();
    internal bool get_IsEligibleForCommit();
    internal virtual bool AttachOverride(DependencyObject target, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal abstract virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal abstract virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal abstract virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal abstract virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal void OnBindingGroupChanged(bool joining);
    internal abstract virtual void UpdateBindingGroup(BindingGroup bg);
    internal bool UpdateValue();
    internal virtual object GetRawProposedValue();
    internal abstract virtual object ConvertProposedValue(object rawValue);
    internal abstract virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal abstract virtual object UpdateSource(object convertedValue);
    internal abstract virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual object CommitSource(object value);
    internal abstract virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal abstract virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal abstract virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal CultureInfo GetCulture();
    internal void InvalidateCulture();
    internal void BeginSourceUpdate();
    internal void EndSourceUpdate();
    internal bool ShouldUpdateWithCurrentValue(DependencyObject target, Object& currentValue);
    internal void ChangeValue(object newValue, bool notify);
    internal void Clean();
    internal void Dirty();
    internal void Invalidate(bool isASubPropertyChange);
    internal object UseFallbackValue();
    internal static bool IsNullValue(object value);
    internal object NullValueForType(Type type);
    internal ValidationRule LookupValidationRule(Type type);
    internal void JoinBindingGroup(bool isReflective, DependencyObject contextElement);
    internal void LeaveBindingGroup();
    internal void RejoinBindingGroup(bool isReflective, DependencyObject contextElement);
    internal BindingGroup FindBindingGroup(bool isReflective, DependencyObject contextElement);
    internal void JoinBindingGroup(BindingGroup bg, bool explicitJoin);
    internal void NotifyCommitManager();
    internal virtual void UpdateCommitState();
    internal void AdoptProperties(BindingExpressionBase bb);
    internal virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    internal abstract virtual object GetSourceItem(object newValue);
    internal DependencyObject get_TargetElement();
    internal WeakReference get_TargetElementReference();
    internal DataBindEngine get_Engine();
    internal Dispatcher get_Dispatcher();
    internal object get_Value();
    internal void set_Value(object value);
    internal WeakDependencySource[] get_WeakSources();
    internal virtual bool get_IsDisconnected();
    internal void Attach(DependencyObject target, DependencyProperty dp);
    internal void Detach();
    internal virtual void Disconnect();
    internal void SetStatus(BindingStatusInternal status);
    internal static object ConvertFallbackValue(object value, DependencyProperty dp, object sender);
    internal static object ConvertTargetNullValue(object value, DependencyProperty dp, object sender);
    internal TraceEventType get_TraceLevel();
    internal virtual void Activate();
    internal virtual void Deactivate();
    internal bool Update();
    internal virtual bool UpdateOverride();
    internal void UpdateValidationError(ValidationError validationError, bool skipBindingGroup);
    internal void UpdateNotifyDataErrorValidationErrors(List`1<object> errors);
    internal static void GetValidationDelta(List`1<ValidationError> previousErrors, List`1<object> errors, List`1& toAdd, List`1& toRemove);
    internal void AddValidationError(ValidationError validationError, bool skipBindingGroup);
    internal void RemoveValidationError(ValidationError validationError, bool skipBindingGroup);
    internal ValidationError GetValidationErrors(ValidationStep validationStep);
    internal void ChangeSources(WeakDependencySource[] newSources);
    internal static WeakDependencySource[] CombineSources(int index, Collection`1<BindingExpressionBase> bindingExpressions, int count, WeakDependencySource[] newSources, WeakDependencySource[] commonSources);
    internal void ResolvePropertyDefaultSettings(BindingMode mode, UpdateSourceTrigger updateTrigger, FrameworkPropertyMetadata fwMetaData);
    internal UpdateSourceTrigger GetDefaultUpdateSourceTrigger(FrameworkPropertyMetadata fwMetaData);
    internal void SetUpdateSourceTrigger(UpdateSourceTrigger ust);
    internal Type GetEffectiveTargetType();
    internal void DetermineEffectiveStringFormat();
    internal void DetermineEffectiveTargetNullValue();
    internal void DetermineEffectiveValidatesOnNotifyDataErrors();
    internal static object CreateReference(object item);
    internal static object CreateReference(WeakReference item);
    internal static object ReplaceReference(object oldReference, object item);
    internal static object GetReference(object reference);
    internal static void InitializeTracing(BindingExpressionBase expr, DependencyObject d, DependencyProperty dp);
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
}
public class System.Windows.Data.BindingGroup : DependencyObject {
    internal static object DeferredTargetValue;
    internal static object DeferredSourceValue;
    public DependencyObject Owner { get; }
    public Collection`1<ValidationRule> ValidationRules { get; }
    public Collection`1<BindingExpressionBase> BindingExpressions { get; }
    public string Name { get; public set; }
    public bool NotifyOnValidationError { get; public set; }
    public bool ValidatesOnNotifyDataError { get; public set; }
    public bool SharesProposedValues { get; public set; }
    public bool CanRestoreValues { get; }
    public IList Items { get; }
    public bool IsDirty { get; }
    public bool HasValidationError { get; }
    public ReadOnlyCollection`1<ValidationError> ValidationErrors { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal BindingGroup(BindingGroup master);
    private static BindingGroup();
    public DependencyObject get_Owner();
    public Collection`1<ValidationRule> get_ValidationRules();
    public Collection`1<BindingExpressionBase> get_BindingExpressions();
    public string get_Name();
    public void set_Name(string value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public bool get_ValidatesOnNotifyDataError();
    public void set_ValidatesOnNotifyDataError(bool value);
    public bool get_SharesProposedValues();
    public void set_SharesProposedValues(bool value);
    public bool get_CanRestoreValues();
    public IList get_Items();
    public bool get_IsDirty();
    public bool get_HasValidationError();
    public ReadOnlyCollection`1<ValidationError> get_ValidationErrors();
    public void BeginEdit();
    public bool CommitEdit();
    public void CancelEdit();
    public bool ValidateWithoutUpdate();
    public bool UpdateSources();
    public object GetValue(object item, string propertyName);
    public bool TryGetValue(object item, string propertyName, Object& value);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal void UpdateTable(BindingExpression bindingExpression);
    internal void AddToValueTable(BindingExpressionBase bindingExpressionBase);
    internal object GetValue(BindingExpressionBase bindingExpressionBase);
    internal void SetValue(BindingExpressionBase bindingExpressionBase, object value);
    internal void UseSourceValue(BindingExpressionBase bindingExpressionBase);
    internal ProposedValueEntry GetProposedValueEntry(object item, string propertyName);
    internal void RemoveProposedValueEntry(ProposedValueEntry entry);
    internal void AddBindingForProposedValue(BindingExpressionBase dependent, object item, string propertyName);
    internal void AddValidationError(ValidationError validationError);
    internal void RemoveValidationError(ValidationError validationError);
}
public class System.Windows.Data.BindingListCollectionView : CollectionView {
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanFilter { get; }
    public string CustomFilter { get; public set; }
    public bool CanCustomFilter { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    [DefaultValueAttribute("")]
public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDataInGroupOrder { get; public set; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    internal bool IsLiveShapingDirty { get; internal set; }
    public BindingListCollectionView(IBindingList list);
    public virtual bool PassesFilter(object item);
    public virtual bool Contains(object item);
    public virtual bool MoveCurrentToPosition(int position);
    private sealed virtual override int System.Collections.IComparer.Compare(object o1, object o2);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    protected virtual IEnumerator GetEnumerator();
    public virtual void DetachFromSourceCollection();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanFilter();
    public string get_CustomFilter();
    public void set_CustomFilter(string value);
    public bool get_CanCustomFilter();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public GroupDescriptionSelectorCallback get_GroupBySelector();
    public void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public bool get_IsDataInGroupOrder();
    public void set_IsDataInGroupOrder(bool value);
    public sealed virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public sealed virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public sealed virtual bool get_CanAddNew();
    public sealed virtual object AddNew();
    public sealed virtual void CommitNew();
    public sealed virtual void CancelNew();
    public sealed virtual bool get_IsAddingNew();
    public sealed virtual object get_CurrentAddItem();
    public sealed virtual bool get_CanRemove();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object item);
    public sealed virtual void EditItem(object item);
    public sealed virtual void CommitEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual bool get_CanCancelEdit();
    public sealed virtual bool get_IsEditingItem();
    public sealed virtual object get_CurrentEditItem();
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    protected virtual void RefreshOverride();
    protected virtual void OnAllowsCrossThreadChangesChanged();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    internal void RestoreLiveShaping();
    internal bool get_IsLiveShapingDirty();
    internal void set_IsLiveShapingDirty(bool value);
}
public enum System.Windows.Data.BindingMode : Enum {
    public int value__;
    public static BindingMode TwoWay;
    public static BindingMode OneWay;
    public static BindingMode OneTime;
    public static BindingMode OneWayToSource;
    public static BindingMode Default;
}
public static class System.Windows.Data.BindingOperations : object {
    public static object DisconnectedSource { get; }
    internal static bool IsCleanupEnabled { get; internal set; }
    internal static bool TraceAccessorTableSize { get; internal set; }
    public static object get_DisconnectedSource();
    public static BindingExpressionBase SetBinding(DependencyObject target, DependencyProperty dp, BindingBase binding);
    public static BindingBase GetBindingBase(DependencyObject target, DependencyProperty dp);
    public static Binding GetBinding(DependencyObject target, DependencyProperty dp);
    public static PriorityBinding GetPriorityBinding(DependencyObject target, DependencyProperty dp);
    public static MultiBinding GetMultiBinding(DependencyObject target, DependencyProperty dp);
    public static BindingExpressionBase GetBindingExpressionBase(DependencyObject target, DependencyProperty dp);
    public static BindingExpression GetBindingExpression(DependencyObject target, DependencyProperty dp);
    public static MultiBindingExpression GetMultiBindingExpression(DependencyObject target, DependencyProperty dp);
    public static PriorityBindingExpression GetPriorityBindingExpression(DependencyObject target, DependencyProperty dp);
    public static void ClearBinding(DependencyObject target, DependencyProperty dp);
    public static void ClearAllBindings(DependencyObject target);
    public static bool IsDataBound(DependencyObject target, DependencyProperty dp);
    public static void EnableCollectionSynchronization(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    public static void EnableCollectionSynchronization(IEnumerable collection, object lockObject);
    public static void DisableCollectionSynchronization(IEnumerable collection);
    public static void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    public static ReadOnlyCollection`1<BindingExpressionBase> GetSourceUpdatingBindings(DependencyObject root);
    public static ReadOnlyCollection`1<BindingGroup> GetSourceUpdatingBindingGroups(DependencyObject root);
    [CompilerGeneratedAttribute]
public static void add_CollectionRegistering(EventHandler`1<CollectionRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_CollectionRegistering(EventHandler`1<CollectionRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_CollectionViewRegistering(EventHandler`1<CollectionViewRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_CollectionViewRegistering(EventHandler`1<CollectionViewRegisteringEventArgs> value);
    internal static bool IsValidUpdateSourceTrigger(UpdateSourceTrigger value);
    internal static bool get_IsCleanupEnabled();
    internal static void set_IsCleanupEnabled(bool value);
    internal static bool Cleanup();
    internal static void PrintStats();
    internal static bool get_TraceAccessorTableSize();
    internal static void set_TraceAccessorTableSize(bool value);
    internal static void OnCollectionRegistering(IEnumerable collection, object parent);
    internal static void OnCollectionViewRegistering(CollectionView view);
}
public enum System.Windows.Data.BindingStatus : Enum {
    public int value__;
    public static BindingStatus Unattached;
    public static BindingStatus Inactive;
    public static BindingStatus Active;
    public static BindingStatus Detached;
    public static BindingStatus AsyncRequestPending;
    public static BindingStatus PathError;
    public static BindingStatus UpdateTargetError;
    public static BindingStatus UpdateSourceError;
}
internal enum System.Windows.Data.BindingStatusInternal : Enum {
    public byte value__;
    public static BindingStatusInternal Unattached;
    public static BindingStatusInternal Inactive;
    public static BindingStatusInternal Active;
    public static BindingStatusInternal Detached;
    public static BindingStatusInternal AsyncRequestPending;
    public static BindingStatusInternal PathError;
    public static BindingStatusInternal UpdateTargetError;
    public static BindingStatusInternal UpdateSourceError;
}
public class System.Windows.Data.CollectionContainer : DependencyObject {
    public static DependencyProperty CollectionProperty;
    public IEnumerable Collection { get; public set; }
    internal ICollectionView View { get; }
    internal int ViewCount { get; }
    internal bool ViewIsEmpty { get; }
    private static CollectionContainer();
    public IEnumerable get_Collection();
    public void set_Collection(IEnumerable value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCollection();
    internal ICollectionView get_View();
    internal int get_ViewCount();
    internal bool get_ViewIsEmpty();
    internal object ViewItem(int index);
    internal int ViewIndexOf(object item);
    internal void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnContainedCollectionChanged(NotifyCollectionChangedEventArgs args);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public class System.Windows.Data.CollectionRegisteringEventArgs : EventArgs {
    public IEnumerable Collection { get; }
    public object Parent { get; }
    internal CollectionRegisteringEventArgs(IEnumerable collection, object parent);
    public IEnumerable get_Collection();
    public object get_Parent();
}
public class System.Windows.Data.CollectionSynchronizationCallback : MulticastDelegate {
    public CollectionSynchronizationCallback(object object, IntPtr method);
    public virtual void Invoke(IEnumerable collection, object context, Action accessMethod, bool writeAccess);
    public virtual IAsyncResult BeginInvoke(IEnumerable collection, object context, Action accessMethod, bool writeAccess, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Data.CollectionView : DispatcherObject {
    internal static object NoNewItem;
    internal static string CountPropertyName;
    internal static string IsEmptyPropertyName;
    internal static string CulturePropertyName;
    internal static string CurrentPositionPropertyName;
    internal static string CurrentItemPropertyName;
    internal static string IsCurrentBeforeFirstPropertyName;
    internal static string IsCurrentAfterLastPropertyName;
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public IComparer Comparer { get; }
    public bool NeedsRefresh { get; }
    public bool IsInUse { get; }
    public static object NewItemPlaceholder { get; }
    protected bool IsDynamic { get; }
    protected bool AllowsCrossThreadChanges { get; }
    protected bool UpdatedOutsideDispatcher { get; }
    protected bool IsRefreshDeferred { get; }
    protected bool IsCurrentInSync { get; }
    internal object SyncRoot { get; }
    internal int Timestamp { get; }
    public CollectionView(IEnumerable collection);
    internal CollectionView(IEnumerable collection, int moveToFirst);
    internal CollectionView(IEnumerable collection, bool shouldProcessCollectionChanged);
    private static CollectionView();
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual IEnumerable get_SourceCollection();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual void Refresh();
    internal void RefreshInternal();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    [CompilerGeneratedAttribute]
public virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CurrentChanged(EventHandler value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool PassesFilter(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual void DetachFromSourceCollection();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual IComparer get_Comparer();
    public virtual bool get_NeedsRefresh();
    public virtual bool get_IsInUse();
    public static object get_NewItemPlaceholder();
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected void SetCurrent(object newItem, int newPosition);
    protected void SetCurrent(object newItem, int newPosition, int count);
    protected bool OKToChangeCurrent();
    protected void OnCurrentChanging();
    protected virtual void OnCurrentChanging(CurrentChangingEventArgs args);
    protected virtual void OnCurrentChanged();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    protected virtual void OnAllowsCrossThreadChangesChanged();
    protected void ClearPendingChanges();
    protected void ProcessPendingChanges();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    [ObsoleteAttribute("Replaced by ClearPendingChanges")]
protected void ClearChangeLog();
    protected void RefreshOrDefer();
    protected bool get_IsDynamic();
    protected bool get_AllowsCrossThreadChanges();
    internal void SetAllowsCrossThreadChanges(bool value);
    protected bool get_UpdatedOutsideDispatcher();
    protected bool get_IsRefreshDeferred();
    protected bool get_IsCurrentInSync();
    internal void SetViewManagerData(object value);
    internal virtual bool HasReliableHashCodes();
    internal void VerifyRefreshNotDeferred();
    internal void InvalidateEnumerableWrapper();
    internal ReadOnlyCollection`1<ItemPropertyInfo> GetItemProperties();
    internal Type GetItemType(bool useRepresentativeItem);
    internal object GetRepresentativeItem();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    internal object get_SyncRoot();
    internal int get_Timestamp();
}
public abstract class System.Windows.Data.CollectionViewGroup : object {
    public object Name { get; }
    public ReadOnlyObservableCollection`1<object> Items { get; }
    public int ItemCount { get; }
    public bool IsBottomLevel { get; }
    protected ObservableCollection`1<object> ProtectedItems { get; }
    protected int ProtectedItemCount { get; protected set; }
    protected CollectionViewGroup(object name);
    public object get_Name();
    public ReadOnlyObservableCollection`1<object> get_Items();
    public int get_ItemCount();
    public abstract virtual bool get_IsBottomLevel();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected ObservableCollection`1<object> get_ProtectedItems();
    protected int get_ProtectedItemCount();
    protected void set_ProtectedItemCount(int value);
}
public class System.Windows.Data.CollectionViewRegisteringEventArgs : EventArgs {
    public CollectionView CollectionView { get; }
    internal CollectionViewRegisteringEventArgs(CollectionView view);
    public CollectionView get_CollectionView();
}
public class System.Windows.Data.CollectionViewSource : DependencyObject {
    public static DependencyProperty ViewProperty;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty CollectionViewTypeProperty;
    public static DependencyProperty CanChangeLiveSortingProperty;
    public static DependencyProperty IsLiveSortingRequestedProperty;
    public static DependencyProperty IsLiveSortingProperty;
    public static DependencyProperty CanChangeLiveFilteringProperty;
    public static DependencyProperty IsLiveFilteringRequestedProperty;
    public static DependencyProperty IsLiveFilteringProperty;
    public static DependencyProperty CanChangeLiveGroupingProperty;
    public static DependencyProperty IsLiveGroupingRequestedProperty;
    public static DependencyProperty IsLiveGroupingProperty;
    internal static CollectionViewSource DefaultSource;
    [ReadOnlyAttribute("True")]
public ICollectionView View { get; }
    public object Source { get; public set; }
    public Type CollectionViewType { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo Culture { get; public set; }
    public SortDescriptionCollection SortDescriptions { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveSorting { get; private set; }
    public bool IsLiveSortingRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveSorting { get; private set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveFiltering { get; private set; }
    public bool IsLiveFilteringRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveFiltering { get; private set; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveGrouping { get; private set; }
    public bool IsLiveGroupingRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveGrouping { get; private set; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    internal CollectionView CollectionView { get; }
    internal DependencyProperty PropertyForInheritanceContext { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static CollectionViewSource();
    public ICollectionView get_View();
    public object get_Source();
    public void set_Source(object value);
    protected virtual void OnSourceChanged(object oldSource, object newSource);
    public Type get_CollectionViewType();
    public void set_CollectionViewType(Type value);
    protected virtual void OnCollectionViewTypeChanged(Type oldCollectionViewType, Type newCollectionViewType);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public SortDescriptionCollection get_SortDescriptions();
    public ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public bool get_CanChangeLiveSorting();
    private void set_CanChangeLiveSorting(bool value);
    public bool get_IsLiveSortingRequested();
    public void set_IsLiveSortingRequested(bool value);
    public Nullable`1<bool> get_IsLiveSorting();
    private void set_IsLiveSorting(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveSortingProperties();
    public bool get_CanChangeLiveFiltering();
    private void set_CanChangeLiveFiltering(bool value);
    public bool get_IsLiveFilteringRequested();
    public void set_IsLiveFilteringRequested(bool value);
    public Nullable`1<bool> get_IsLiveFiltering();
    private void set_IsLiveFiltering(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveFilteringProperties();
    public bool get_CanChangeLiveGrouping();
    private void set_CanChangeLiveGrouping(bool value);
    public bool get_IsLiveGroupingRequested();
    public void set_IsLiveGroupingRequested(bool value);
    public Nullable`1<bool> get_IsLiveGrouping();
    private void set_IsLiveGrouping(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveGroupingProperties();
    public void add_Filter(FilterEventHandler value);
    public void remove_Filter(FilterEventHandler value);
    public static ICollectionView GetDefaultView(object source);
    public static bool IsDefaultView(ICollectionView view);
    public IDisposable DeferRefresh();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal CollectionView get_CollectionView();
    internal DependencyProperty get_PropertyForInheritanceContext();
    internal static CollectionView GetDefaultCollectionView(object source, bool createView, Func`2<object, object> GetSourceItem);
    internal static CollectionView GetDefaultCollectionView(object source, DependencyObject d, Func`2<object, object> GetSourceItem);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool IsShareableInTemplate();
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
public class System.Windows.Data.CompositeCollection : object {
    public int Count { get; }
    public object Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public CompositeCollection(int capacity);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int Add(object newItem);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object containItem);
    public sealed virtual int IndexOf(object indexItem);
    public sealed virtual void Insert(int insertIndex, object insertItem);
    public sealed virtual void Remove(object removeItem);
    public sealed virtual void RemoveAt(int removeIndex);
    private sealed virtual override ICollectionView System.ComponentModel.ICollectionViewFactory.CreateView();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int itemIndex);
    public sealed virtual void set_Item(int itemIndex, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    [CompilerGeneratedAttribute]
internal void add_ContainedCollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ContainedCollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
}
public class System.Windows.Data.DataChangedEventManager : WeakEventManager {
    public static void AddListener(DataSourceProvider source, IWeakEventListener listener);
    public static void RemoveListener(DataSourceProvider source, IWeakEventListener listener);
    public static void AddHandler(DataSourceProvider source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(DataSourceProvider source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
public class System.Windows.Data.DataTransferEventArgs : RoutedEventArgs {
    public DependencyObject TargetObject { get; }
    public DependencyProperty Property { get; }
    internal DataTransferEventArgs(DependencyObject targetObject, DependencyProperty dp);
    public DependencyObject get_TargetObject();
    public DependencyProperty get_Property();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Data.FilterEventArgs : EventArgs {
    public object Item { get; }
    public bool Accepted { get; public set; }
    internal FilterEventArgs(object item);
    public object get_Item();
    public bool get_Accepted();
    public void set_Accepted(bool value);
}
public class System.Windows.Data.FilterEventHandler : MulticastDelegate {
    public FilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Data.GroupDescriptionSelectorCallback : MulticastDelegate {
    public GroupDescriptionSelectorCallback(object object, IntPtr method);
    public virtual GroupDescription Invoke(CollectionViewGroup group, int level);
    public virtual IAsyncResult BeginInvoke(CollectionViewGroup group, int level, AsyncCallback callback, object object);
    public virtual GroupDescription EndInvoke(IAsyncResult result);
}
public interface System.Windows.Data.IMultiValueConverter {
    public abstract virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public interface System.Windows.Data.IValueConverter {
    public abstract virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class System.Windows.Data.ListCollectionView : CollectionView {
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanFilter { get; }
    public Predicate`1<object> Filter { get; public set; }
    public IComparer CustomSort { get; public set; }
    [DefaultValueAttribute("")]
public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDataInGroupOrder { get; public set; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool CanAddNewItem { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    protected bool UsesLocalArray { get; }
    protected IList InternalList { get; }
    protected IComparer ActiveComparer { get; protected set; }
    protected Predicate`1<object> ActiveFilter { get; protected set; }
    protected bool IsGrouping { get; }
    protected int InternalCount { get; }
    internal ArrayList ShadowCollection { get; internal set; }
    internal bool HasSortDescriptions { get; }
    internal bool IsLiveShapingDirty { get; internal set; }
    public ListCollectionView(IList list);
    protected virtual void RefreshOverride();
    public virtual bool Contains(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual bool PassesFilter(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    private sealed virtual override int System.Collections.IComparer.Compare(object o1, object o2);
    protected virtual int Compare(object o1, object o2);
    protected virtual IEnumerator GetEnumerator();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanFilter();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public IComparer get_CustomSort();
    public void set_CustomSort(IComparer value);
    public virtual GroupDescriptionSelectorCallback get_GroupBySelector();
    public virtual void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public bool get_IsDataInGroupOrder();
    public void set_IsDataInGroupOrder(bool value);
    public sealed virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public sealed virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public sealed virtual bool get_CanAddNew();
    public sealed virtual bool get_CanAddNewItem();
    public sealed virtual object AddNew();
    public sealed virtual object AddNewItem(object newItem);
    public sealed virtual void CommitNew();
    public sealed virtual void CancelNew();
    public sealed virtual bool get_IsAddingNew();
    public sealed virtual object get_CurrentAddItem();
    public sealed virtual bool get_CanRemove();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object item);
    public sealed virtual void EditItem(object item);
    public sealed virtual void CommitEdit();
    public sealed virtual void CancelEdit();
    public sealed virtual bool get_CanCancelEdit();
    public sealed virtual bool get_IsEditingItem();
    public sealed virtual object get_CurrentEditItem();
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    protected virtual void OnAllowsCrossThreadChangesChanged();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected int InternalIndexOf(object item);
    protected object InternalItemAt(int index);
    protected bool InternalContains(object item);
    protected IEnumerator InternalGetEnumerator();
    protected bool get_UsesLocalArray();
    protected IList get_InternalList();
    protected IComparer get_ActiveComparer();
    protected void set_ActiveComparer(IComparer value);
    protected Predicate`1<object> get_ActiveFilter();
    protected void set_ActiveFilter(Predicate`1<object> value);
    protected bool get_IsGrouping();
    protected int get_InternalCount();
    internal ArrayList get_ShadowCollection();
    internal void set_ShadowCollection(ArrayList value);
    internal void AdjustShadowCopy(NotifyCollectionChangedEventArgs e);
    internal bool get_HasSortDescriptions();
    internal static IComparer PrepareComparer(IComparer customSort, SortDescriptionCollection sort, Func`1<CollectionView> lazyGetCollectionView);
    internal void RestoreLiveShaping();
    internal bool get_IsLiveShapingDirty();
    internal void set_IsLiveShapingDirty(bool value);
}
[ContentPropertyAttribute("Bindings")]
public class System.Windows.Data.MultiBinding : BindingBase {
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<BindingBase> Bindings { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public BindingMode Mode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnSourceUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnTargetUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnValidationError { get; public set; }
    [DefaultValueAttribute("")]
public IMultiValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo ConverterCulture { get; public set; }
    public Collection`1<ValidationRule> ValidationRules { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnExceptions { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnDataErrors { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidatesOnNotifyDataErrors { get; public set; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Collection`1<BindingBase> get_Bindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBindings();
    public BindingMode get_Mode();
    public void set_Mode(BindingMode value);
    public UpdateSourceTrigger get_UpdateSourceTrigger();
    public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_NotifyOnSourceUpdated();
    public void set_NotifyOnSourceUpdated(bool value);
    public bool get_NotifyOnTargetUpdated();
    public void set_NotifyOnTargetUpdated(bool value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public IMultiValueConverter get_Converter();
    public void set_Converter(IMultiValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
    public CultureInfo get_ConverterCulture();
    public void set_ConverterCulture(CultureInfo value);
    public Collection`1<ValidationRule> get_ValidationRules();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeValidationRules();
    public UpdateSourceExceptionFilterCallback get_UpdateSourceExceptionFilter();
    public void set_UpdateSourceExceptionFilter(UpdateSourceExceptionFilterCallback value);
    public bool get_ValidatesOnExceptions();
    public void set_ValidatesOnExceptions(bool value);
    public bool get_ValidatesOnDataErrors();
    public void set_ValidatesOnDataErrors(bool value);
    public bool get_ValidatesOnNotifyDataErrors();
    public void set_ValidatesOnNotifyDataErrors(bool value);
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal object DoFilterException(object bindExpr, Exception exception);
    internal static void CheckTrigger(BindingBase bb);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
}
public class System.Windows.Data.MultiBindingExpression : BindingExpressionBase {
    private DependencyObject MS.Internal.Data.IDataBindEngineClient.TargetElement { get; }
    public MultiBinding ParentMultiBinding { get; }
    public ReadOnlyCollection`1<BindingExpressionBase> BindingExpressions { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    public ValidationError ValidationError { get; }
    public bool HasError { get; }
    public bool HasValidationError { get; }
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.TransferValue();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.UpdateValue();
    private sealed virtual override bool MS.Internal.Data.IDataBindEngineClient.AttachToContext(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.VerifySourceReference(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.OnTargetUpdated();
    private sealed virtual override DependencyObject MS.Internal.Data.IDataBindEngineClient.get_TargetElement();
    public MultiBinding get_ParentMultiBinding();
    public ReadOnlyCollection`1<BindingExpressionBase> get_BindingExpressions();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal static MultiBindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, MultiBinding binding, BindingExpressionBase owner);
    public virtual ValidationError get_ValidationError();
    public virtual bool get_HasError();
    public virtual bool get_HasValidationError();
    internal virtual bool AttachOverride(DependencyObject d, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal virtual object ConvertProposedValue(object value);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object convertedValue);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal virtual object GetSourceItem(object newValue);
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    internal virtual bool UpdateOverride();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Data.ObjectDataProvider : DataSourceProvider {
    public Type ObjectType { get; public set; }
    public object ObjectInstance { get; public set; }
    [DefaultValueAttribute("")]
public string MethodName { get; public set; }
    public IList ConstructorParameters { get; }
    public IList MethodParameters { get; }
    [DefaultValueAttribute("False")]
public bool IsAsynchronous { get; public set; }
    public Type get_ObjectType();
    public void set_ObjectType(Type value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeObjectType();
    public object get_ObjectInstance();
    public void set_ObjectInstance(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeObjectInstance();
    public string get_MethodName();
    public void set_MethodName(string value);
    public IList get_ConstructorParameters();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeConstructorParameters();
    public IList get_MethodParameters();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMethodParameters();
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    protected virtual void BeginQuery();
}
[ContentPropertyAttribute("Bindings")]
public class System.Windows.Data.PriorityBinding : BindingBase {
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<BindingBase> Bindings { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Collection`1<BindingBase> get_Bindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBindings();
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
}
public class System.Windows.Data.PriorityBindingExpression : BindingExpressionBase {
    public PriorityBinding ParentPriorityBinding { get; }
    public ReadOnlyCollection`1<BindingExpressionBase> BindingExpressions { get; }
    public BindingExpressionBase ActiveBindingExpression { get; }
    public bool HasValidationError { get; }
    internal int AttentiveBindingExpressions { get; }
    public PriorityBinding get_ParentPriorityBinding();
    public ReadOnlyCollection`1<BindingExpressionBase> get_BindingExpressions();
    public BindingExpressionBase get_ActiveBindingExpression();
    public virtual bool get_HasValidationError();
    public virtual void UpdateTarget();
    public virtual void UpdateSource();
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal static PriorityBindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, PriorityBinding binding, BindingExpressionBase owner);
    internal int get_AttentiveBindingExpressions();
    internal virtual bool AttachOverride(DependencyObject d, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal virtual object GetRawProposedValue();
    internal virtual object ConvertProposedValue(object rawValue);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object convertedValue);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal virtual object GetSourceItem(object newValue);
    internal virtual void UpdateCommitState();
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
}
public class System.Windows.Data.PropertyGroupDescription : GroupDescription {
    [DefaultValueAttribute("")]
public string PropertyName { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public StringComparison StringComparison { get; public set; }
    public static IComparer CompareNameAscending { get; }
    public static IComparer CompareNameDescending { get; }
    public PropertyGroupDescription(string propertyName);
    public PropertyGroupDescription(string propertyName, IValueConverter converter);
    public PropertyGroupDescription(string propertyName, IValueConverter converter, StringComparison stringComparison);
    private static PropertyGroupDescription();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public StringComparison get_StringComparison();
    public void set_StringComparison(StringComparison value);
    public static IComparer get_CompareNameAscending();
    public static IComparer get_CompareNameDescending();
    public virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
    public virtual bool NamesMatch(object groupName, object itemName);
}
[MarkupExtensionReturnTypeAttribute("System.Windows.Data.RelativeSource")]
public class System.Windows.Data.RelativeSource : MarkupExtension {
    public static RelativeSource PreviousData { get; }
    public static RelativeSource TemplatedParent { get; }
    public static RelativeSource Self { get; }
    [ConstructorArgumentAttribute("mode")]
public RelativeSourceMode Mode { get; public set; }
    public Type AncestorType { get; public set; }
    public int AncestorLevel { get; public set; }
    public RelativeSource(RelativeSourceMode mode);
    public RelativeSource(RelativeSourceMode mode, Type ancestorType, int ancestorLevel);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static RelativeSource get_PreviousData();
    public static RelativeSource get_TemplatedParent();
    public static RelativeSource get_Self();
    public RelativeSourceMode get_Mode();
    public void set_Mode(RelativeSourceMode value);
    public Type get_AncestorType();
    public void set_AncestorType(Type value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAncestorType();
    public int get_AncestorLevel();
    public void set_AncestorLevel(int value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAncestorLevel();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public enum System.Windows.Data.RelativeSourceMode : Enum {
    public int value__;
    public static RelativeSourceMode PreviousData;
    public static RelativeSourceMode TemplatedParent;
    public static RelativeSourceMode Self;
    public static RelativeSourceMode FindAncestor;
}
public class System.Windows.Data.UpdateSourceExceptionFilterCallback : MulticastDelegate {
    public UpdateSourceExceptionFilterCallback(object object, IntPtr method);
    public virtual object Invoke(object bindExpression, Exception exception);
    public virtual IAsyncResult BeginInvoke(object bindExpression, Exception exception, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Data.UpdateSourceTrigger : Enum {
    public int value__;
    public static UpdateSourceTrigger Default;
    public static UpdateSourceTrigger PropertyChanged;
    public static UpdateSourceTrigger LostFocus;
    public static UpdateSourceTrigger Explicit;
}
[AttributeUsageAttribute("4")]
public class System.Windows.Data.ValueConversionAttribute : Attribute {
    public Type SourceType { get; }
    public Type TargetType { get; }
    public Type ParameterType { get; public set; }
    public object TypeId { get; }
    public ValueConversionAttribute(Type sourceType, Type targetType);
    public Type get_SourceType();
    public Type get_TargetType();
    public Type get_ParameterType();
    public void set_ParameterType(Type value);
    public virtual object get_TypeId();
    public virtual int GetHashCode();
}
public class System.Windows.Data.ValueUnavailableException : SystemException {
    public ValueUnavailableException(string message);
    public ValueUnavailableException(string message, Exception innerException);
    protected ValueUnavailableException(SerializationInfo info, StreamingContext context);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("XmlSerializer")]
public class System.Windows.Data.XmlDataProvider : DataSourceProvider {
    public Uri Source { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public XmlDocument Document { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string XPath { get; public set; }
    [DefaultValueAttribute("")]
public XmlNamespaceManager XmlNamespaceManager { get; public set; }
    [DefaultValueAttribute("True")]
public bool IsAsynchronous { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[EditorBrowsableAttribute("1")]
public IXmlSerializable XmlSerializer { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    public Uri get_Source();
    public void set_Source(Uri value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSource();
    public XmlDocument get_Document();
    public void set_Document(XmlDocument value);
    public string get_XPath();
    public void set_XPath(string value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeXPath();
    public XmlNamespaceManager get_XmlNamespaceManager();
    public void set_XmlNamespaceManager(XmlNamespaceManager value);
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    public IXmlSerializable get_XmlSerializer();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeXmlSerializer();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    protected virtual void BeginQuery();
    protected virtual void EndInit();
}
public class System.Windows.Data.XmlNamespaceMapping : object {
    public string Prefix { get; public set; }
    public Uri Uri { get; public set; }
    public XmlNamespaceMapping(string prefix, Uri uri);
    public string get_Prefix();
    public void set_Prefix(string value);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(XmlNamespaceMapping mappingA, XmlNamespaceMapping mappingB);
    public static bool op_Inequality(XmlNamespaceMapping mappingA, XmlNamespaceMapping mappingB);
    public virtual int GetHashCode();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Data.XmlNamespaceMappingCollection : XmlNamespaceManager {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public sealed virtual void Add(XmlNamespaceMapping mapping);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(XmlNamespaceMapping mapping);
    public sealed virtual void CopyTo(XmlNamespaceMapping[] array, int arrayIndex);
    public sealed virtual bool Remove(XmlNamespaceMapping mapping);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<XmlNamespaceMapping> System.Collections.Generic.IEnumerable<System.Windows.Data.XmlNamespaceMapping>.GetEnumerator();
    [IteratorStateMachineAttribute("System.Windows.Data.XmlNamespaceMappingCollection/<ProtectedGetEnumerator>d__16")]
protected IEnumerator`1<XmlNamespaceMapping> ProtectedGetEnumerator();
}
[DictionaryKeyPropertyAttribute("DataTemplateKey")]
public class System.Windows.DataTemplate : FrameworkTemplate {
    [DefaultValueAttribute("")]
[AmbientAttribute]
public object DataType { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[DependsOnAttribute("VisualTree")]
[DependsOnAttribute("Template")]
public TriggerCollection Triggers { get; }
    public object DataTemplateKey { get; }
    internal Type TargetTypeInternal { get; }
    internal object DataTypeInternal { get; }
    internal TriggerCollection TriggersInternal { get; }
    internal static Type DefaultTargetType { get; }
    public DataTemplate(object dataType);
    public object get_DataType();
    public void set_DataType(object value);
    public TriggerCollection get_Triggers();
    public object get_DataTemplateKey();
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal virtual object get_DataTypeInternal();
    internal virtual TriggerCollection get_TriggersInternal();
    internal static Type get_DefaultTargetType();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
}
public class System.Windows.DataTemplateKey : TemplateKey {
    public DataTemplateKey(object dataType);
}
[ContentPropertyAttribute("Setters")]
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
public class System.Windows.DataTrigger : TriggerBase {
    [LocalizabilityAttribute("0")]
public BindingBase Binding { get; public set; }
    [DependsOnAttribute("Binding")]
[LocalizabilityAttribute("0")]
public object Value { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public BindingBase get_Binding();
    public void set_Binding(BindingBase value);
    public object get_Value();
    public void set_Value(object value);
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal sealed virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
}
internal class System.Windows.DataTriggerRecord : object {
    public FrugalStructList`1<ChildPropertyDependent> Dependents;
}
[TypeConverterAttribute("System.Windows.DeferrableContentConverter")]
public class System.Windows.DeferrableContent : object {
    internal XamlLoadPermission LoadPermission { get; private set; }
    internal Stream Stream { get; private set; }
    internal Baml2006SchemaContext SchemaContext { get; private set; }
    internal IXamlObjectWriterFactory ObjectWriterFactory { get; private set; }
    internal XamlObjectWriterSettings ObjectWriterParentSettings { get; private set; }
    internal object RootObject { get; private set; }
    internal IServiceProvider ServiceProvider { get; private set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal DeferrableContent(Stream stream, Baml2006SchemaContext schemaContext, IXamlObjectWriterFactory objectWriterFactory, IServiceProvider serviceProvider, object rootObject);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal XamlLoadPermission get_LoadPermission();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
private void set_LoadPermission(XamlLoadPermission value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Stream get_Stream();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
internal Baml2006SchemaContext get_SchemaContext();
    [CompilerGeneratedAttribute]
private void set_SchemaContext(Baml2006SchemaContext value);
    [CompilerGeneratedAttribute]
internal IXamlObjectWriterFactory get_ObjectWriterFactory();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterFactory(IXamlObjectWriterFactory value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriterSettings get_ObjectWriterParentSettings();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterParentSettings(XamlObjectWriterSettings value);
    [CompilerGeneratedAttribute]
internal object get_RootObject();
    [CompilerGeneratedAttribute]
private void set_RootObject(object value);
    [CompilerGeneratedAttribute]
internal IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void set_ServiceProvider(IServiceProvider value);
}
public class System.Windows.DeferrableContentConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
internal class System.Windows.DeferredAction : ValueType {
    internal TriggerBase TriggerBase;
    internal TriggerActionCollection TriggerActionCollection;
}
internal class System.Windows.DeferredAppResourceReference : DeferredResourceReference {
    internal DeferredAppResourceReference(ResourceDictionary dictionary, object resourceKey);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.DeferredResourceReference : DeferredReference {
    protected object _keyOrValue;
    internal object Key { get; }
    internal ResourceDictionary Dictionary { get; internal set; }
    internal object Value { get; internal set; }
    internal bool IsUnset { get; }
    internal bool IsInflated { get; }
    internal DeferredResourceReference(ResourceDictionary dictionary, object key);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal virtual void RemoveFromDictionary();
    internal virtual void AddInflatedListener(ResourceReferenceExpression listener);
    internal virtual void RemoveInflatedListener(ResourceReferenceExpression listener);
    internal virtual object get_Key();
    internal ResourceDictionary get_Dictionary();
    internal void set_Dictionary(ResourceDictionary value);
    internal virtual object get_Value();
    internal virtual void set_Value(object value);
    internal virtual bool get_IsUnset();
    internal bool get_IsInflated();
}
internal class System.Windows.DeferredResourceReferenceHolder : DeferredResourceReference {
    internal object Key { get; }
    internal object Value { get; internal set; }
    internal bool IsUnset { get; }
    internal DeferredResourceReferenceHolder(object resourceKey, object value);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal virtual object get_Key();
    internal virtual object get_Value();
    internal virtual void set_Value(object value);
    internal virtual bool get_IsUnset();
}
internal class System.Windows.DeferredThemeResourceReference : DeferredResourceReference {
    internal DeferredThemeResourceReference(ResourceDictionary dictionary, object resourceKey, bool canCacheAsThemeResource);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal virtual void RemoveFromDictionary();
}
public static class System.Windows.DependencyPropertyHelper : object {
    public static ValueSource GetValueSource(DependencyObject dependencyObject, DependencyProperty dependencyProperty);
    public static bool IsTemplatedValueDynamic(DependencyObject elementInTemplate, DependencyProperty dependencyProperty);
}
internal class System.Windows.DescendentsWalker`1 : DescendentsWalkerBase {
    protected T Data { get; }
    public DescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> callback);
    public DescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> callback, T data);
    public void StartWalk(DependencyObject startNode);
    public virtual void StartWalk(DependencyObject startNode, bool skipStartNode);
    protected virtual void _VisitNode(DependencyObject d, bool visitedViaVisualTree);
    protected T get_Data();
}
internal class System.Windows.DescendentsWalkerBase : object {
    internal DependencyObject _startNode;
    internal TreeWalkPriority _priority;
    internal FrugalStructList`1<DependencyObject> _nodes;
    internal int _recursionDepth;
    protected DescendentsWalkerBase(TreeWalkPriority priority);
    internal bool WasVisited(DependencyObject d);
}
public static class System.Windows.Diagnostics.ResourceDictionaryDiagnostics : object {
    public static IEnumerable`1<ResourceDictionaryInfo> ThemedResourceDictionaries { get; }
    public static IEnumerable`1<ResourceDictionaryInfo> GenericResourceDictionaries { get; }
    internal static bool HasStaticResourceResolvedListeners { get; }
    internal static bool IsEnabled { get; private set; }
    [SecuritySafeCriticalAttribute]
private static ResourceDictionaryDiagnostics();
    public static IEnumerable`1<ResourceDictionaryInfo> get_ThemedResourceDictionaries();
    public static IEnumerable`1<ResourceDictionaryInfo> get_GenericResourceDictionaries();
    public static void add_ThemedResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void remove_ThemedResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void add_ThemedResourceDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    public static void remove_ThemedResourceDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    public static void add_GenericResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void remove_GenericResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static IEnumerable`1<ResourceDictionary> GetResourceDictionariesForSource(Uri uri);
    internal static void AddResourceDictionaryForUri(Uri uri, ResourceDictionary rd);
    internal static void RemoveResourceDictionaryForUri(Uri uri, ResourceDictionary rd);
    public static IEnumerable`1<FrameworkElement> GetFrameworkElementOwners(ResourceDictionary dictionary);
    public static IEnumerable`1<FrameworkContentElement> GetFrameworkContentElementOwners(ResourceDictionary dictionary);
    public static IEnumerable`1<Application> GetApplicationOwners(ResourceDictionary dictionary);
    [CompilerGeneratedAttribute]
public static void add_StaticResourceResolved(EventHandler`1<StaticResourceResolvedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_StaticResourceResolved(EventHandler`1<StaticResourceResolvedEventArgs> value);
    internal static bool get_HasStaticResourceResolvedListeners();
    internal static bool ShouldIgnoreProperty(object targetProperty);
    internal static LookupResult RequestLookupResult(StaticResourceExtension requester);
    internal static void RecordLookupResult(object key, ResourceDictionary rd);
    internal static void RevertRequest(StaticResourceExtension requester, bool success);
    internal static void OnStaticResourceResolved(object targetObject, object targetProperty, LookupResult result);
    [CompilerGeneratedAttribute]
internal static bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private static void set_IsEnabled(bool value);
}
[DebuggerDisplayAttribute("Assembly = {Assembly?.GetName()?.Name}, ResourceDictionary SourceUri = {SourceUri?.AbsoluteUri}")]
public class System.Windows.Diagnostics.ResourceDictionaryInfo : object {
    public Assembly Assembly { get; private set; }
    public Assembly ResourceDictionaryAssembly { get; private set; }
    public ResourceDictionary ResourceDictionary { get; private set; }
    public Uri SourceUri { get; private set; }
    internal ResourceDictionaryInfo(Assembly assembly, Assembly resourceDictionaryAssembly, ResourceDictionary resourceDictionary, Uri sourceUri);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public Assembly get_ResourceDictionaryAssembly();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public ResourceDictionary get_ResourceDictionary();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionary(ResourceDictionary value);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
}
public class System.Windows.Diagnostics.ResourceDictionaryLoadedEventArgs : EventArgs {
    public ResourceDictionaryInfo ResourceDictionaryInfo { get; private set; }
    internal ResourceDictionaryLoadedEventArgs(ResourceDictionaryInfo resourceDictionaryInfo);
    [CompilerGeneratedAttribute]
public ResourceDictionaryInfo get_ResourceDictionaryInfo();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryInfo(ResourceDictionaryInfo value);
}
public class System.Windows.Diagnostics.ResourceDictionaryUnloadedEventArgs : EventArgs {
    public ResourceDictionaryInfo ResourceDictionaryInfo { get; private set; }
    internal ResourceDictionaryUnloadedEventArgs(ResourceDictionaryInfo resourceDictionaryInfo);
    [CompilerGeneratedAttribute]
public ResourceDictionaryInfo get_ResourceDictionaryInfo();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryInfo(ResourceDictionaryInfo value);
}
public class System.Windows.Diagnostics.StaticResourceResolvedEventArgs : EventArgs {
    public object TargetObject { get; private set; }
    public object TargetProperty { get; private set; }
    public ResourceDictionary ResourceDictionary { get; private set; }
    public object ResourceKey { get; private set; }
    internal StaticResourceResolvedEventArgs(object targetObject, object targetProperty, ResourceDictionary rd, object key);
    [CompilerGeneratedAttribute]
public object get_TargetObject();
    [CompilerGeneratedAttribute]
private void set_TargetObject(object value);
    [CompilerGeneratedAttribute]
public object get_TargetProperty();
    [CompilerGeneratedAttribute]
private void set_TargetProperty(object value);
    [CompilerGeneratedAttribute]
public ResourceDictionary get_ResourceDictionary();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionary(ResourceDictionary value);
    [CompilerGeneratedAttribute]
public object get_ResourceKey();
    [CompilerGeneratedAttribute]
private void set_ResourceKey(object value);
}
public class System.Windows.DialogResultConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public abstract class System.Windows.Documents.Adorner : FrameworkElement {
    internal Geometry AdornerClip { get; internal set; }
    internal Transform AdornerTransform { get; internal set; }
    public UIElement AdornedElement { get; }
    public bool IsClipEnabled { get; public set; }
    protected Adorner(UIElement adornedElement);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    internal Geometry get_AdornerClip();
    internal void set_AdornerClip(Geometry value);
    internal Transform get_AdornerTransform();
    internal void set_AdornerTransform(Transform value);
    public UIElement get_AdornedElement();
    public bool get_IsClipEnabled();
    public void set_IsClipEnabled(bool value);
    internal virtual bool NeedsUpdate(Size oldSize);
}
public class System.Windows.Documents.AdornerDecorator : Decorator {
    public AdornerLayer AdornerLayer { get; }
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    internal int EffectiveValuesInitialSize { get; }
    public AdornerLayer get_AdornerLayer();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Documents.AdornerLayer : FrameworkElement {
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal HybridDictionary ElementMap { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal AdornerLayer(Dispatcher context);
    public void Add(Adorner adorner);
    public void Remove(Adorner adorner);
    public void Update();
    public void Update(UIElement element);
    public Adorner[] GetAdorners(UIElement element);
    public AdornerHitTestResult AdornerHitTest(Point point);
    public static AdornerLayer GetAdornerLayer(Visual visual);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal void Add(Adorner adorner, int zOrder);
    internal void InvalidateAdorner(AdornerInfo adornerInfo);
    internal void OnLayoutUpdated(object sender, EventArgs args);
    internal void SetAdornerZOrder(Adorner adorner, int zOrder);
    internal int GetAdornerZOrder(Adorner adorner);
    internal HybridDictionary get_ElementMap();
    internal virtual int get_EffectiveValuesInitialSize();
}
[ContentPropertyAttribute("Blocks")]
public abstract class System.Windows.Documents.AnchoredBlock : Inline {
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    protected AnchoredBlock(Block block, TextPointer insertionPosition);
    private static AnchoredBlock();
    public BlockCollection get_Blocks();
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
    internal virtual bool get_IsIMEStructuralElement();
}
public abstract class System.Windows.Documents.Block : TextElement {
    public static DependencyProperty IsHyphenationEnabledProperty;
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty BreakPageBeforeProperty;
    public static DependencyProperty BreakColumnBeforeProperty;
    public static DependencyProperty ClearFloatersProperty;
    public BlockCollection SiblingBlocks { get; }
    public Block NextBlock { get; }
    public Block PreviousBlock { get; }
    public bool IsHyphenationEnabled { get; public set; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public bool BreakPageBefore { get; public set; }
    public bool BreakColumnBefore { get; public set; }
    public WrapDirection ClearFloaters { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    private static Block();
    public BlockCollection get_SiblingBlocks();
    public Block get_NextBlock();
    public Block get_PreviousBlock();
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    public static void SetIsHyphenationEnabled(DependencyObject element, bool value);
    public static bool GetIsHyphenationEnabled(DependencyObject element);
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public static void SetTextAlignment(DependencyObject element, TextAlignment value);
    public static TextAlignment GetTextAlignment(DependencyObject element);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public static void SetLineHeight(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public static double GetLineHeight(DependencyObject element);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value);
    public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element);
    public bool get_BreakPageBefore();
    public void set_BreakPageBefore(bool value);
    public bool get_BreakColumnBefore();
    public void set_BreakColumnBefore(bool value);
    public WrapDirection get_ClearFloaters();
    public void set_ClearFloaters(WrapDirection value);
    internal static bool IsValidMargin(object o);
    internal static bool IsValidPadding(object o);
    internal static bool IsValidBorderThickness(object o);
    internal virtual bool get_IsIMEStructuralElement();
    internal static bool IsValidThickness(Thickness t, bool allowNaN);
}
public class System.Windows.Documents.BlockCollection : TextElementCollection`1<Block> {
    public Block FirstBlock { get; }
    public Block LastBlock { get; }
    internal BlockCollection(DependencyObject owner, bool isOwnerParent);
    public Block get_FirstBlock();
    public Block get_LastBlock();
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Documents.BlockUIContainer : Block {
    public UIElement Child { get; public set; }
    public BlockUIContainer(UIElement uiElement);
    public UIElement get_Child();
    public void set_Child(UIElement value);
}
public class System.Windows.Documents.Bold : Span {
    private static Bold();
    public Bold(Inline childInline);
    public Bold(Inline childInline, TextPointer insertionPosition);
    public Bold(TextPointer start, TextPointer end);
}
internal class System.Windows.Documents.BorderFormat : object {
    internal long CF { get; internal set; }
    internal long Width { get; internal set; }
    internal long EffectiveWidth { get; }
    internal BorderType Type { get; internal set; }
    internal bool IsNone { get; }
    internal string RTFEncoding { get; }
    internal static BorderFormat EmptyBorderFormat { get; }
    internal BorderFormat(BorderFormat cb);
    private static BorderFormat();
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_Width();
    internal void set_Width(long value);
    internal long get_EffectiveWidth();
    internal BorderType get_Type();
    internal void set_Type(BorderType value);
    internal bool get_IsNone();
    internal string get_RTFEncoding();
    internal static BorderFormat get_EmptyBorderFormat();
    internal void SetDefaults();
}
internal enum System.Windows.Documents.BorderType : Enum {
    public int value__;
    public static BorderType BorderNone;
    public static BorderType BorderSingle;
    public static BorderType BorderDouble;
}
internal class System.Windows.Documents.BringLineIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    public ITextPointer Position { get; }
    public int Count { get; }
    public ITextPointer NewPosition { get; }
    public double NewSuggestedX { get; }
    public BringLineIntoViewCompletedEventArgs(ITextPointer position, double suggestedX, int count, ITextPointer newPosition, double newSuggestedX, int linesMoved, bool succeeded, Exception error, bool cancelled, object userState);
    public ITextPointer get_Position();
    public int get_Count();
    public ITextPointer get_NewPosition();
    public double get_NewSuggestedX();
}
internal class System.Windows.Documents.BringLineIntoViewCompletedEventHandler : MulticastDelegate {
    public BringLineIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringLineIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringLineIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPageIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    public ITextPointer Position { get; }
    public int Count { get; }
    public ITextPointer NewPosition { get; }
    public Point NewSuggestedOffset { get; }
    public BringPageIntoViewCompletedEventArgs(ITextPointer position, Point suggestedOffset, int count, ITextPointer newPosition, Point newSuggestedOffset, int pagesMoved, bool succeeded, Exception error, bool cancelled, object userState);
    public ITextPointer get_Position();
    public int get_Count();
    public ITextPointer get_NewPosition();
    public Point get_NewSuggestedOffset();
}
internal class System.Windows.Documents.BringPageIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPageIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPageIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPageIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPointIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    public Point Point { get; }
    public ITextPointer Position { get; }
    public BringPointIntoViewCompletedEventArgs(Point point, ITextPointer position, bool succeeded, Exception error, bool cancelled, object userState);
    public Point get_Point();
    public ITextPointer get_Position();
}
internal class System.Windows.Documents.BringPointIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPointIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPointIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPointIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPositionIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    public BringPositionIntoViewCompletedEventArgs(ITextPointer position, bool succeeded, Exception error, bool cancelled, object userState);
}
internal class System.Windows.Documents.BringPositionIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPositionIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPositionIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPositionIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.CaretElement : Adorner {
    internal static double BidiCaretIndicatorWidth;
    internal static double CaretPaddingWidth;
    internal static double c_geometryCombineTolerance;
    internal static double c_endOfParaMagicMultiplier;
    internal static int ZOrderValue;
    protected int VisualChildrenCount { get; }
    internal Geometry SelectionGeometry { get; }
    internal bool IsSelectionActive { get; internal set; }
    internal CaretElement(TextEditor textEditor, bool isBlinkEnabled);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size availableSize);
    internal void Update(bool visible, Rect caretRectangle, Brush caretBrush, double opacity, bool italic, CaretScrollMethod scrollMethod, double scrollToOriginPosition);
    internal void UpdateSelection();
    internal static void AddGeometry(Geometry& geometry, Geometry addedGeometry);
    internal static void ClipGeometryByViewport(Geometry& geometry, Rect viewport);
    internal static void AddTransformToGeometry(Geometry targetGeometry, Transform transformToAdd);
    internal void Hide();
    internal void RefreshCaret(bool italic);
    internal void DetachFromView();
    internal void SetBlinking(bool isBlinkEnabled);
    internal void UpdateCaretBrush(Brush caretBrush);
    internal void OnRenderCaretSubElement(DrawingContext context);
    internal void OnTextViewUpdated();
    internal Geometry get_SelectionGeometry();
    internal bool get_IsSelectionActive();
    internal void set_IsSelectionActive(bool value);
    internal static FrameworkElement GetOwnerElement(FrameworkElement uiScope);
}
internal enum System.Windows.Documents.CaretScrollMethod : Enum {
    public int value__;
    public static CaretScrollMethod Unset;
    public static CaretScrollMethod Simple;
    public static CaretScrollMethod Navigation;
    public static CaretScrollMethod None;
}
internal class System.Windows.Documents.CellFormat : object {
    internal long CB { get; internal set; }
    internal long CF { get; internal set; }
    internal long Shading { get; internal set; }
    internal long PaddingLeft { get; internal set; }
    internal long PaddingRight { get; internal set; }
    internal long PaddingTop { get; internal set; }
    internal long PaddingBottom { get; internal set; }
    internal BorderFormat BorderTop { get; internal set; }
    internal BorderFormat BorderBottom { get; internal set; }
    internal BorderFormat BorderLeft { get; internal set; }
    internal BorderFormat BorderRight { get; internal set; }
    internal CellWidth Width { get; internal set; }
    internal long CellX { get; internal set; }
    internal bool IsCellXSet { get; internal set; }
    unknown VAlign VAlign {internal set; }
    internal long SpacingTop { get; internal set; }
    internal long SpacingLeft { get; internal set; }
    internal long SpacingBottom { get; internal set; }
    internal long SpacingRight { get; internal set; }
    internal bool IsPending { get; internal set; }
    internal bool IsHMerge { get; internal set; }
    internal bool IsHMergeFirst { get; internal set; }
    internal bool IsVMerge { get; internal set; }
    internal bool IsVMergeFirst { get; internal set; }
    internal bool HasBorder { get; }
    internal string RTFEncodingForWidth { get; }
    internal CellFormat(CellFormat cf);
    internal long get_CB();
    internal void set_CB(long value);
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_Shading();
    internal void set_Shading(long value);
    internal long get_PaddingLeft();
    internal void set_PaddingLeft(long value);
    internal long get_PaddingRight();
    internal void set_PaddingRight(long value);
    internal long get_PaddingTop();
    internal void set_PaddingTop(long value);
    internal long get_PaddingBottom();
    internal void set_PaddingBottom(long value);
    internal BorderFormat get_BorderTop();
    internal void set_BorderTop(BorderFormat value);
    internal BorderFormat get_BorderBottom();
    internal void set_BorderBottom(BorderFormat value);
    internal BorderFormat get_BorderLeft();
    internal void set_BorderLeft(BorderFormat value);
    internal BorderFormat get_BorderRight();
    internal void set_BorderRight(BorderFormat value);
    internal CellWidth get_Width();
    internal void set_Width(CellWidth value);
    internal long get_CellX();
    internal void set_CellX(long value);
    internal bool get_IsCellXSet();
    internal void set_IsCellXSet(bool value);
    internal void set_VAlign(VAlign value);
    internal long get_SpacingTop();
    internal void set_SpacingTop(long value);
    internal long get_SpacingLeft();
    internal void set_SpacingLeft(long value);
    internal long get_SpacingBottom();
    internal void set_SpacingBottom(long value);
    internal long get_SpacingRight();
    internal void set_SpacingRight(long value);
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_IsHMerge();
    internal void set_IsHMerge(bool value);
    internal bool get_IsHMergeFirst();
    internal void set_IsHMergeFirst(bool value);
    internal bool get_IsVMerge();
    internal void set_IsVMerge(bool value);
    internal bool get_IsVMergeFirst();
    internal void set_IsVMergeFirst(bool value);
    internal bool get_HasBorder();
    internal string get_RTFEncodingForWidth();
    internal void SetDefaults();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal string GetPaddingAttributeString();
}
internal class System.Windows.Documents.CellWidth : object {
    internal WidthType Type { get; internal set; }
    internal long Value { get; internal set; }
    internal CellWidth(CellWidth cw);
    internal WidthType get_Type();
    internal void set_Type(WidthType value);
    internal long get_Value();
    internal void set_Value(long value);
    internal void SetDefaults();
}
internal class System.Windows.Documents.ChangeBlockUndoRecord : object {
    internal ChangeBlockUndoRecord(ITextContainer textContainer, string actionDescription);
    internal void OnEndChange();
}
internal class System.Windows.Documents.ChildDocumentBlock : object {
    internal DocumentSequenceTextContainer AggregatedContainer { get; }
    internal ITextContainer ChildContainer { get; }
    internal DocumentSequenceHighlightLayer ChildHighlightLayer { get; }
    internal DocumentReference DocRef { get; }
    internal ITextPointer End { get; }
    internal bool IsHead { get; }
    internal bool IsTail { get; }
    internal ChildDocumentBlock PreviousBlock { get; }
    internal ChildDocumentBlock NextBlock { get; }
    internal ChildDocumentBlock(DocumentSequenceTextContainer aggregatedContainer, ITextContainer childContainer);
    internal ChildDocumentBlock(DocumentSequenceTextContainer aggregatedContainer, DocumentReference docRef);
    internal ChildDocumentBlock InsertNextBlock(ChildDocumentBlock newBlock);
    internal DocumentSequenceTextContainer get_AggregatedContainer();
    internal ITextContainer get_ChildContainer();
    internal DocumentSequenceHighlightLayer get_ChildHighlightLayer();
    internal DocumentReference get_DocRef();
    internal ITextPointer get_End();
    internal bool get_IsHead();
    internal bool get_IsTail();
    internal ChildDocumentBlock get_PreviousBlock();
    internal ChildDocumentBlock get_NextBlock();
}
internal class System.Windows.Documents.ColorTable : ArrayList {
    unknown byte NewRed {internal set; }
    unknown byte NewGreen {internal set; }
    unknown byte NewBlue {internal set; }
    internal Color ColorAt(int index);
    internal void FinishColor();
    internal int AddColor(Color color);
    internal ColorTableEntry EntryAt(int index);
    internal void set_NewRed(byte value);
    internal void set_NewGreen(byte value);
    internal void set_NewBlue(byte value);
}
internal class System.Windows.Documents.ColorTableEntry : object {
    internal Color Color { get; internal set; }
    internal bool IsAuto { get; internal set; }
    unknown byte Red {internal set; }
    unknown byte Green {internal set; }
    unknown byte Blue {internal set; }
    internal Color get_Color();
    internal void set_Color(Color value);
    internal bool get_IsAuto();
    internal void set_IsAuto(bool value);
    internal void set_Red(byte value);
    internal void set_Green(byte value);
    internal void set_Blue(byte value);
}
internal class System.Windows.Documents.ColumnResizeUndoUnit : ParentUndoUnit {
    internal ColumnResizeUndoUnit(TextPointer textPointerTable, int columnIndex, Double[] columnWidths, double resizeAmount);
    public virtual void Do();
}
internal class System.Windows.Documents.ColumnState : object {
    internal long CellX { get; internal set; }
    internal DocumentNode Row { get; internal set; }
    internal bool IsFilled { get; internal set; }
    internal long get_CellX();
    internal void set_CellX(long value);
    internal DocumentNode get_Row();
    internal void set_Row(DocumentNode value);
    internal bool get_IsFilled();
    internal void set_IsFilled(bool value);
}
internal class System.Windows.Documents.ColumnStateArray : ArrayList {
    internal ColumnState EntryAt(int i);
    internal int GetMinUnfilledRowIndex();
}
internal class System.Windows.Documents.CompositionAdorner : Adorner {
    private static CompositionAdorner();
    internal CompositionAdorner(ITextView textView);
    internal CompositionAdorner(ITextView textView, ArrayList attributeRanges);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void AddAttributeRange(ITextPointer start, ITextPointer end, TextServicesDisplayAttribute textServiceDisplayAttribute);
    internal void InvalidateAdorner();
    internal void Initialize(ITextView textView);
    internal void Uninitialize();
}
internal static class System.Windows.Documents.Converters : object {
    internal static double HalfPointToPositivePx(double halfPoint);
    internal static double TwipToPx(double twip);
    internal static double TwipToPositivePx(double twip);
    internal static double TwipToPositiveVisiblePx(double twip);
    internal static string TwipToPxString(double twip);
    internal static string TwipToPositivePxString(double twip);
    internal static string TwipToPositiveVisiblePxString(double twip);
    internal static double PxToPt(double px);
    internal static long PxToTwipRounded(double px);
    internal static long PxToHalfPointRounded(double px);
    internal static bool StringToDouble(string s, Double& d);
    internal static bool StringToInt(string s, Int32& i);
    internal static string StringToXMLAttribute(string s);
    internal static bool HexStringToInt(string s, Int32& i);
    internal static string MarkerStyleToString(MarkerStyle ms);
    internal static string MarkerStyleToOldRTFString(MarkerStyle ms);
    internal static bool ColorToUse(ConverterState converterState, long cb, long cf, long shade, Color& c);
    internal static string AlignmentToString(HAlign a, DirState ds);
    internal static string MarkerCountToString(MarkerStyle ms, long nCount);
    internal static void ByteToHex(byte byteData, Byte& firstHexByte, Byte& secondHexByte);
}
internal class System.Windows.Documents.ConverterState : object {
    internal RtfFormatStack RtfFormatStack { get; }
    internal FontTable FontTable { get; }
    internal ColorTable ColorTable { get; }
    internal ListTable ListTable { get; }
    internal ListOverrideTable ListOverrideTable { get; }
    internal DocumentNodeArray DocumentNodeArray { get; }
    internal FormatState TopFormatState { get; }
    internal int CodePage { get; internal set; }
    internal long DefaultFont { get; internal set; }
    internal long DefaultLang { get; internal set; }
    internal long DefaultLangFE { get; internal set; }
    internal bool IsMarkerWhiteSpace { get; internal set; }
    internal bool IsMarkerPresent { get; internal set; }
    internal BorderFormat CurrentBorder { get; internal set; }
    internal FormatState PreviousTopFormatState(int fromTop);
    internal RtfFormatStack get_RtfFormatStack();
    internal FontTable get_FontTable();
    internal ColorTable get_ColorTable();
    internal ListTable get_ListTable();
    internal ListOverrideTable get_ListOverrideTable();
    internal DocumentNodeArray get_DocumentNodeArray();
    internal FormatState get_TopFormatState();
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal long get_DefaultFont();
    internal void set_DefaultFont(long value);
    internal long get_DefaultLang();
    internal void set_DefaultLang(long value);
    internal long get_DefaultLangFE();
    internal void set_DefaultLangFE(long value);
    internal bool get_IsMarkerWhiteSpace();
    internal void set_IsMarkerWhiteSpace(bool value);
    internal bool get_IsMarkerPresent();
    internal void set_IsMarkerPresent(bool value);
    internal BorderFormat get_CurrentBorder();
    internal void set_CurrentBorder(BorderFormat value);
}
internal enum System.Windows.Documents.DirState : Enum {
    public int value__;
    public static DirState DirDefault;
    public static DirState DirLTR;
    public static DirState DirRTL;
}
internal class System.Windows.Documents.DocumentNode : object {
    internal static String[] HtmlNames;
    internal static Int32[] HtmlLengths;
    internal static String[] XamlNames;
    internal bool IsInline { get; }
    internal bool IsBlock { get; }
    internal bool IsEmptyNode { get; }
    internal bool IsHidden { get; }
    internal bool IsWhiteSpace { get; }
    internal bool IsPending { get; internal set; }
    internal bool IsTerminated { get; internal set; }
    internal bool IsMatched { get; internal set; }
    internal bool IsTrackedAsOpen { get; }
    internal bool HasMarkerContent { get; internal set; }
    internal bool IsNonEmpty { get; }
    internal string ListLabel { get; internal set; }
    internal long VirtualListLevel { get; internal set; }
    internal string NavigateUri { get; internal set; }
    internal DocumentNodeType Type { get; }
    internal FormatState FormatState { get; internal set; }
    internal FormatState ParentFormatStateForFont { get; }
    internal int ChildCount { get; internal set; }
    internal int Index { get; internal set; }
    internal DocumentNodeArray DNA { get; internal set; }
    internal int LastChildIndex { get; }
    internal DocumentNode ClosedParent { get; }
    internal DocumentNode Parent { get; internal set; }
    internal string Xaml { get; internal set; }
    internal StringBuilder Content { get; }
    internal int RowSpan { get; internal set; }
    internal int ColSpan { get; internal set; }
    internal ColumnStateArray ColumnStateArray { get; internal set; }
    internal DirState XamlDir { get; }
    internal DirState ParentXamlDir { get; }
    internal bool RequiresXamlDir { get; }
    internal long NearMargin { get; internal set; }
    internal long FarMargin { get; }
    internal DocumentNode(DocumentNodeType documentNodeType);
    private static DocumentNode();
    internal void InheritFormatState(FormatState formatState);
    internal string GetTagName();
    internal DocumentNode GetParentOfType(DocumentNodeType parentType);
    internal int GetTableDepth();
    internal int GetListDepth();
    internal void Terminate(ConverterState converterState);
    internal void ConstrainFontPropagation(FormatState fsOrig);
    internal bool RequiresXamlFontProperties();
    internal void AppendXamlFontProperties(ConverterState converterState, StringBuilder sb);
    internal string StripInvalidChars(string text);
    internal void AppendXamlEncoded(string text);
    internal void AppendXamlPrefix(ConverterState converterState);
    internal void AppendXamlPostfix(ConverterState converterState);
    internal void AppendInlineXamlPrefix(ConverterState converterState);
    internal void AppendInlineXamlPostfix(ConverterState converterState);
    internal void AppendImageXamlPrefix();
    internal void AppendImageXamlPostfix();
    internal bool IsAncestorOf(DocumentNode documentNode);
    internal bool IsLastParagraphInCell();
    internal DocumentNodeArray GetTableRows();
    internal DocumentNodeArray GetRowsCells();
    internal int GetCellColumn();
    internal ColumnStateArray ComputeColumns();
    internal bool get_IsInline();
    internal bool get_IsBlock();
    internal bool get_IsEmptyNode();
    internal bool get_IsHidden();
    internal bool get_IsWhiteSpace();
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_IsTerminated();
    internal void set_IsTerminated(bool value);
    internal bool get_IsMatched();
    internal void set_IsMatched(bool value);
    internal bool get_IsTrackedAsOpen();
    internal bool get_HasMarkerContent();
    internal void set_HasMarkerContent(bool value);
    internal bool get_IsNonEmpty();
    internal string get_ListLabel();
    internal void set_ListLabel(string value);
    internal long get_VirtualListLevel();
    internal void set_VirtualListLevel(long value);
    internal string get_NavigateUri();
    internal void set_NavigateUri(string value);
    internal DocumentNodeType get_Type();
    internal FormatState get_FormatState();
    internal void set_FormatState(FormatState value);
    internal FormatState get_ParentFormatStateForFont();
    internal int get_ChildCount();
    internal void set_ChildCount(int value);
    internal int get_Index();
    internal void set_Index(int value);
    internal DocumentNodeArray get_DNA();
    internal void set_DNA(DocumentNodeArray value);
    internal int get_LastChildIndex();
    internal DocumentNode get_ClosedParent();
    internal DocumentNode get_Parent();
    internal void set_Parent(DocumentNode value);
    internal string get_Xaml();
    internal void set_Xaml(string value);
    internal StringBuilder get_Content();
    internal int get_RowSpan();
    internal void set_RowSpan(int value);
    internal int get_ColSpan();
    internal void set_ColSpan(int value);
    internal ColumnStateArray get_ColumnStateArray();
    internal void set_ColumnStateArray(ColumnStateArray value);
    internal DirState get_XamlDir();
    internal DirState get_ParentXamlDir();
    internal bool get_RequiresXamlDir();
    internal long get_NearMargin();
    internal void set_NearMargin(long value);
    internal long get_FarMargin();
}
internal class System.Windows.Documents.DocumentNodeArray : ArrayList {
    internal DocumentNode Top { get; }
    unknown bool IsMain {internal set; }
    internal DocumentNode EntryAt(int nAt);
    internal void Push(DocumentNode documentNode);
    internal DocumentNode Pop();
    internal DocumentNode TopPending();
    internal bool TestTop(DocumentNodeType documentNodeType);
    internal void PreCoalesceChildren(ConverterState converterState, int nStart, bool bChild);
    internal void CoalesceChildren(ConverterState converterState, int nStart);
    internal void CoalesceOnlyChildren(ConverterState converterState, int nStart);
    internal void CoalesceAll(ConverterState converterState);
    internal void CloseAtHelper(int index, int nChildCount);
    internal void CloseAt(int index);
    internal void AssertTreeInvariants();
    internal void AssertTreeSemanticInvariants();
    internal void CloseAll();
    internal int CountOpenNodes(DocumentNodeType documentNodeType);
    internal int CountOpenCells();
    internal DocumentNode GetOpenParentWhileParsing(DocumentNode dn);
    internal DocumentNodeType GetTableScope();
    internal MarkerList GetOpenMarkerStyles();
    internal MarkerList GetLastMarkerStyles(MarkerList mlHave, MarkerList mlWant);
    internal void OpenLastList();
    internal void OpenLastCell();
    internal int FindPendingFrom(DocumentNodeType documentNodeType, int nStart, int nLow);
    internal int FindPending(DocumentNodeType documentNodeType, int nLow);
    internal int FindPending(DocumentNodeType documentNodeType);
    internal int FindUnmatched(DocumentNodeType dnType);
    internal void EstablishTreeRelationships();
    internal void CullOpen();
    internal void InsertOpenNode(DocumentNode dn);
    internal void InsertNode(int nAt, DocumentNode dn);
    internal void InsertChildAt(DocumentNode dnParent, DocumentNode dnNew, int nInsertAt, int nChild);
    internal void Excise(int nAt, int nExcise);
    internal DocumentNode get_Top();
    internal void set_IsMain(bool value);
}
internal enum System.Windows.Documents.DocumentNodeType : Enum {
    public int value__;
    public static DocumentNodeType dnUnknown;
    public static DocumentNodeType dnText;
    public static DocumentNodeType dnInline;
    public static DocumentNodeType dnLineBreak;
    public static DocumentNodeType dnHyperlink;
    public static DocumentNodeType dnParagraph;
    public static DocumentNodeType dnInlineUIContainer;
    public static DocumentNodeType dnBlockUIContainer;
    public static DocumentNodeType dnImage;
    public static DocumentNodeType dnList;
    public static DocumentNodeType dnListItem;
    public static DocumentNodeType dnTable;
    public static DocumentNodeType dnTableBody;
    public static DocumentNodeType dnRow;
    public static DocumentNodeType dnCell;
    public static DocumentNodeType dnSection;
    public static DocumentNodeType dnFigure;
    public static DocumentNodeType dnFloater;
    public static DocumentNodeType dnFieldBegin;
    public static DocumentNodeType dnFieldEnd;
    public static DocumentNodeType dnShape;
    public static DocumentNodeType dnListText;
}
[UsableDuringInitializationAttribute("False")]
public class System.Windows.Documents.DocumentReference : FrameworkElement {
    public static DependencyProperty SourceProperty;
    public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal FixedDocument CurrentlyLoadedDoc { get; }
    private static DocumentReference();
    public FixedDocument GetDocument(bool forceReload);
    public void SetDocument(FixedDocument doc);
    public Uri get_Source();
    public void set_Source(Uri value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    internal FixedDocument get_CurrentlyLoadedDoc();
}
[DefaultMemberAttribute("Item")]
[CLSCompliantAttribute("False")]
public class System.Windows.Documents.DocumentReferenceCollection : object {
    public int Count { get; }
    public DocumentReference Item { get; }
    public sealed virtual IEnumerator`1<DocumentReference> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(DocumentReference item);
    public void CopyTo(DocumentReference[] array, int arrayIndex);
    public int get_Count();
    public DocumentReference get_Item(int index);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.Documents.DocumentSequenceHighlightLayer : HighlightLayer {
    internal Type OwnerType { get; }
    internal DocumentSequenceHighlightLayer(DocumentSequenceTextContainer docSeqContainer);
    internal virtual object GetHighlightValue(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal void RaiseHighlightChangedEvent(IList ranges);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.DocumentSequenceTextContainer : object {
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal Highlights Highlights { get; }
    internal ITextSelection TextSelection { get; }
    internal DocumentSequenceTextContainer(DependencyObject parent);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
    internal DocumentSequenceTextPointer VerifyPosition(ITextPointer position);
    internal DocumentSequenceTextPointer MapChildPositionToParent(ITextPointer tp);
    internal ChildDocumentBlock FindChildBlock(DocumentReference docRef);
    internal int GetChildBlockDistance(ChildDocumentBlock block1, ChildDocumentBlock block2);
    internal Highlights get_Highlights();
    internal ITextSelection get_TextSelection();
}
internal class System.Windows.Documents.DocumentSequenceTextPointer : ContentPosition {
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal DocumentSequenceTextContainer AggregatedContainer { get; }
    internal ChildDocumentBlock ChildBlock { get; internal set; }
    internal ITextPointer ChildPointer { get; internal set; }
    internal DocumentSequenceTextPointer(ChildDocumentBlock childBlock, ITextPointer childPosition);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    internal DocumentSequenceTextContainer get_AggregatedContainer();
    internal ChildDocumentBlock get_ChildBlock();
    internal void set_ChildBlock(ChildDocumentBlock value);
    internal ITextPointer get_ChildPointer();
    internal void set_ChildPointer(ITextPointer value);
    public static int CompareTo(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static int GetOffsetToPosition(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static TextPointerContext GetPointerContext(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static int GetTextRunLength(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static int GetTextInRun(DocumentSequenceTextPointer thisTp, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public static object GetAdjacentElement(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static Type GetElementType(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static Type GetElementType(DocumentSequenceTextPointer thisTp);
    public static bool HasEqualScope(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static object GetValue(DocumentSequenceTextPointer thisTp, DependencyProperty property);
    public static object ReadLocalValue(DocumentSequenceTextPointer thisTp, DependencyProperty property);
    public static LocalValueEnumerator GetLocalValueEnumerator(DocumentSequenceTextPointer thisTp);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, int distance);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, LogicalDirection gravity);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, int distance, LogicalDirection gravity);
    internal static bool iScan(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    internal static bool iScan(DocumentSequenceTextPointer thisTp, int distance);
}
internal class System.Windows.Documents.DocumentSequenceTextView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal DocumentSequenceTextView(FixedDocumentSequenceDocumentPage docPage);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual bool Validate(Point point);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
}
public class System.Windows.Documents.DocumentStructures.BlockElement : object {
    internal ElementType _elementType;
    internal ElementType ElementType { get; }
    internal ElementType get_ElementType();
}
public class System.Windows.Documents.DocumentStructures.FigureStructure : SemanticBasicElement {
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public void Add(NamedElement element);
    private sealed virtual override IEnumerator`1<NamedElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.NamedElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.ListItemStructure : SemanticBasicElement {
    public string Marker { get; public set; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string get_Marker();
    public void set_Marker(string value);
}
public class System.Windows.Documents.DocumentStructures.ListStructure : SemanticBasicElement {
    public void Add(ListItemStructure listItem);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<ListItemStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.ListItemStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.NamedElement : BlockElement {
    public string NameReference { get; public set; }
    public string get_NameReference();
    public void set_NameReference(string value);
}
public class System.Windows.Documents.DocumentStructures.ParagraphStructure : SemanticBasicElement {
    public void Add(NamedElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<NamedElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.NamedElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.SectionStructure : SemanticBasicElement {
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.SemanticBasicElement : BlockElement {
    internal List`1<BlockElement> _elementList;
    internal List`1<BlockElement> BlockElementList { get; }
    internal List`1<BlockElement> get_BlockElementList();
}
public class System.Windows.Documents.DocumentStructures.StoryBreak : BlockElement {
}
[ContentPropertyAttribute("BlockElementList")]
public class System.Windows.Documents.DocumentStructures.StoryFragment : object {
    public string StoryName { get; public set; }
    public string FragmentName { get; public set; }
    public string FragmentType { get; public set; }
    internal List`1<BlockElement> BlockElementList { get; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string get_StoryName();
    public void set_StoryName(string value);
    public string get_FragmentName();
    public void set_FragmentName(string value);
    public string get_FragmentType();
    public void set_FragmentType(string value);
    internal List`1<BlockElement> get_BlockElementList();
}
[ContentPropertyAttribute("StoryFragmentList")]
public class System.Windows.Documents.DocumentStructures.StoryFragments : object {
    internal List`1<StoryFragment> StoryFragmentList { get; }
    public void Add(StoryFragment storyFragment);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<StoryFragment> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.StoryFragment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal List`1<StoryFragment> get_StoryFragmentList();
}
public class System.Windows.Documents.DocumentStructures.TableCellStructure : SemanticBasicElement {
    public int RowSpan { get; public set; }
    public int ColumnSpan { get; public set; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_RowSpan();
    public void set_RowSpan(int value);
    public int get_ColumnSpan();
    public void set_ColumnSpan(int value);
}
public class System.Windows.Documents.DocumentStructures.TableRowGroupStructure : SemanticBasicElement {
    public void Add(TableRowStructure tableRow);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableRowStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableRowStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.TableRowStructure : SemanticBasicElement {
    public void Add(TableCellStructure tableCell);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableCellStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableCellStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.TableStructure : SemanticBasicElement {
    public void Add(TableRowGroupStructure tableRowGroup);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableRowGroupStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableRowGroupStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Windows.Documents.DPTypeDescriptorContext : object {
    private IContainer System.ComponentModel.ITypeDescriptorContext.Container { get; }
    private object System.ComponentModel.ITypeDescriptorContext.Instance { get; }
    private PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.PropertyDescriptor { get; }
    internal static string GetStringValue(DependencyProperty property, object propertyValue);
    private sealed virtual override IContainer System.ComponentModel.ITypeDescriptorContext.get_Container();
    private sealed virtual override object System.ComponentModel.ITypeDescriptorContext.get_Instance();
    private sealed virtual override void System.ComponentModel.ITypeDescriptorContext.OnComponentChanged();
    private sealed virtual override bool System.ComponentModel.ITypeDescriptorContext.OnComponentChanging();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.get_PropertyDescriptor();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
public static class System.Windows.Documents.EditingCommands : object {
    public static RoutedUICommand ToggleInsert { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Backspace { get; }
    public static RoutedUICommand DeleteNextWord { get; }
    public static RoutedUICommand DeletePreviousWord { get; }
    public static RoutedUICommand EnterParagraphBreak { get; }
    public static RoutedUICommand EnterLineBreak { get; }
    public static RoutedUICommand TabForward { get; }
    public static RoutedUICommand TabBackward { get; }
    public static RoutedUICommand MoveRightByCharacter { get; }
    public static RoutedUICommand MoveLeftByCharacter { get; }
    public static RoutedUICommand MoveRightByWord { get; }
    public static RoutedUICommand MoveLeftByWord { get; }
    public static RoutedUICommand MoveDownByLine { get; }
    public static RoutedUICommand MoveUpByLine { get; }
    public static RoutedUICommand MoveDownByParagraph { get; }
    public static RoutedUICommand MoveUpByParagraph { get; }
    public static RoutedUICommand MoveDownByPage { get; }
    public static RoutedUICommand MoveUpByPage { get; }
    public static RoutedUICommand MoveToLineStart { get; }
    public static RoutedUICommand MoveToLineEnd { get; }
    public static RoutedUICommand MoveToDocumentStart { get; }
    public static RoutedUICommand MoveToDocumentEnd { get; }
    public static RoutedUICommand SelectRightByCharacter { get; }
    public static RoutedUICommand SelectLeftByCharacter { get; }
    public static RoutedUICommand SelectRightByWord { get; }
    public static RoutedUICommand SelectLeftByWord { get; }
    public static RoutedUICommand SelectDownByLine { get; }
    public static RoutedUICommand SelectUpByLine { get; }
    public static RoutedUICommand SelectDownByParagraph { get; }
    public static RoutedUICommand SelectUpByParagraph { get; }
    public static RoutedUICommand SelectDownByPage { get; }
    public static RoutedUICommand SelectUpByPage { get; }
    public static RoutedUICommand SelectToLineStart { get; }
    public static RoutedUICommand SelectToLineEnd { get; }
    public static RoutedUICommand SelectToDocumentStart { get; }
    public static RoutedUICommand SelectToDocumentEnd { get; }
    public static RoutedUICommand ToggleBold { get; }
    public static RoutedUICommand ToggleItalic { get; }
    public static RoutedUICommand ToggleUnderline { get; }
    public static RoutedUICommand ToggleSubscript { get; }
    public static RoutedUICommand ToggleSuperscript { get; }
    public static RoutedUICommand IncreaseFontSize { get; }
    public static RoutedUICommand DecreaseFontSize { get; }
    public static RoutedUICommand AlignLeft { get; }
    public static RoutedUICommand AlignCenter { get; }
    public static RoutedUICommand AlignRight { get; }
    public static RoutedUICommand AlignJustify { get; }
    public static RoutedUICommand ToggleBullets { get; }
    public static RoutedUICommand ToggleNumbering { get; }
    public static RoutedUICommand IncreaseIndentation { get; }
    public static RoutedUICommand DecreaseIndentation { get; }
    public static RoutedUICommand CorrectSpellingError { get; }
    public static RoutedUICommand IgnoreSpellingError { get; }
    internal static RoutedUICommand Space { get; }
    internal static RoutedUICommand ShiftSpace { get; }
    internal static RoutedUICommand MoveToColumnStart { get; }
    internal static RoutedUICommand MoveToColumnEnd { get; }
    internal static RoutedUICommand MoveToWindowTop { get; }
    internal static RoutedUICommand MoveToWindowBottom { get; }
    internal static RoutedUICommand SelectToColumnStart { get; }
    internal static RoutedUICommand SelectToColumnEnd { get; }
    internal static RoutedUICommand SelectToWindowTop { get; }
    internal static RoutedUICommand SelectToWindowBottom { get; }
    internal static RoutedUICommand ResetFormat { get; }
    internal static RoutedUICommand ToggleSpellCheck { get; }
    internal static RoutedUICommand ApplyFontSize { get; }
    internal static RoutedUICommand ApplyFontFamily { get; }
    internal static RoutedUICommand ApplyForeground { get; }
    internal static RoutedUICommand ApplyBackground { get; }
    internal static RoutedUICommand ApplyInlineFlowDirectionRTL { get; }
    internal static RoutedUICommand ApplyInlineFlowDirectionLTR { get; }
    internal static RoutedUICommand ApplySingleSpace { get; }
    internal static RoutedUICommand ApplyOneAndAHalfSpace { get; }
    internal static RoutedUICommand ApplyDoubleSpace { get; }
    internal static RoutedUICommand ApplyParagraphFlowDirectionRTL { get; }
    internal static RoutedUICommand ApplyParagraphFlowDirectionLTR { get; }
    internal static RoutedUICommand CopyFormat { get; }
    internal static RoutedUICommand PasteFormat { get; }
    internal static RoutedUICommand RemoveListMarkers { get; }
    internal static RoutedUICommand InsertTable { get; }
    internal static RoutedUICommand InsertRows { get; }
    internal static RoutedUICommand InsertColumns { get; }
    internal static RoutedUICommand DeleteRows { get; }
    internal static RoutedUICommand DeleteColumns { get; }
    internal static RoutedUICommand MergeCells { get; }
    internal static RoutedUICommand SplitCell { get; }
    private static EditingCommands();
    public static RoutedUICommand get_ToggleInsert();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Backspace();
    public static RoutedUICommand get_DeleteNextWord();
    public static RoutedUICommand get_DeletePreviousWord();
    public static RoutedUICommand get_EnterParagraphBreak();
    public static RoutedUICommand get_EnterLineBreak();
    public static RoutedUICommand get_TabForward();
    public static RoutedUICommand get_TabBackward();
    public static RoutedUICommand get_MoveRightByCharacter();
    public static RoutedUICommand get_MoveLeftByCharacter();
    public static RoutedUICommand get_MoveRightByWord();
    public static RoutedUICommand get_MoveLeftByWord();
    public static RoutedUICommand get_MoveDownByLine();
    public static RoutedUICommand get_MoveUpByLine();
    public static RoutedUICommand get_MoveDownByParagraph();
    public static RoutedUICommand get_MoveUpByParagraph();
    public static RoutedUICommand get_MoveDownByPage();
    public static RoutedUICommand get_MoveUpByPage();
    public static RoutedUICommand get_MoveToLineStart();
    public static RoutedUICommand get_MoveToLineEnd();
    public static RoutedUICommand get_MoveToDocumentStart();
    public static RoutedUICommand get_MoveToDocumentEnd();
    public static RoutedUICommand get_SelectRightByCharacter();
    public static RoutedUICommand get_SelectLeftByCharacter();
    public static RoutedUICommand get_SelectRightByWord();
    public static RoutedUICommand get_SelectLeftByWord();
    public static RoutedUICommand get_SelectDownByLine();
    public static RoutedUICommand get_SelectUpByLine();
    public static RoutedUICommand get_SelectDownByParagraph();
    public static RoutedUICommand get_SelectUpByParagraph();
    public static RoutedUICommand get_SelectDownByPage();
    public static RoutedUICommand get_SelectUpByPage();
    public static RoutedUICommand get_SelectToLineStart();
    public static RoutedUICommand get_SelectToLineEnd();
    public static RoutedUICommand get_SelectToDocumentStart();
    public static RoutedUICommand get_SelectToDocumentEnd();
    public static RoutedUICommand get_ToggleBold();
    public static RoutedUICommand get_ToggleItalic();
    public static RoutedUICommand get_ToggleUnderline();
    public static RoutedUICommand get_ToggleSubscript();
    public static RoutedUICommand get_ToggleSuperscript();
    public static RoutedUICommand get_IncreaseFontSize();
    public static RoutedUICommand get_DecreaseFontSize();
    public static RoutedUICommand get_AlignLeft();
    public static RoutedUICommand get_AlignCenter();
    public static RoutedUICommand get_AlignRight();
    public static RoutedUICommand get_AlignJustify();
    public static RoutedUICommand get_ToggleBullets();
    public static RoutedUICommand get_ToggleNumbering();
    public static RoutedUICommand get_IncreaseIndentation();
    public static RoutedUICommand get_DecreaseIndentation();
    public static RoutedUICommand get_CorrectSpellingError();
    public static RoutedUICommand get_IgnoreSpellingError();
    internal static RoutedUICommand get_Space();
    internal static RoutedUICommand get_ShiftSpace();
    internal static RoutedUICommand get_MoveToColumnStart();
    internal static RoutedUICommand get_MoveToColumnEnd();
    internal static RoutedUICommand get_MoveToWindowTop();
    internal static RoutedUICommand get_MoveToWindowBottom();
    internal static RoutedUICommand get_SelectToColumnStart();
    internal static RoutedUICommand get_SelectToColumnEnd();
    internal static RoutedUICommand get_SelectToWindowTop();
    internal static RoutedUICommand get_SelectToWindowBottom();
    internal static RoutedUICommand get_ResetFormat();
    internal static RoutedUICommand get_ToggleSpellCheck();
    internal static RoutedUICommand get_ApplyFontSize();
    internal static RoutedUICommand get_ApplyFontFamily();
    internal static RoutedUICommand get_ApplyForeground();
    internal static RoutedUICommand get_ApplyBackground();
    internal static RoutedUICommand get_ApplyInlineFlowDirectionRTL();
    internal static RoutedUICommand get_ApplyInlineFlowDirectionLTR();
    internal static RoutedUICommand get_ApplySingleSpace();
    internal static RoutedUICommand get_ApplyOneAndAHalfSpace();
    internal static RoutedUICommand get_ApplyDoubleSpace();
    internal static RoutedUICommand get_ApplyParagraphFlowDirectionRTL();
    internal static RoutedUICommand get_ApplyParagraphFlowDirectionLTR();
    internal static RoutedUICommand get_CopyFormat();
    internal static RoutedUICommand get_PasteFormat();
    internal static RoutedUICommand get_RemoveListMarkers();
    internal static RoutedUICommand get_InsertTable();
    internal static RoutedUICommand get_InsertRows();
    internal static RoutedUICommand get_InsertColumns();
    internal static RoutedUICommand get_DeleteRows();
    internal static RoutedUICommand get_DeleteColumns();
    internal static RoutedUICommand get_MergeCells();
    internal static RoutedUICommand get_SplitCell();
}
[FlagsAttribute]
internal enum System.Windows.Documents.ElementEdge : Enum {
    public byte value__;
    public static ElementEdge BeforeStart;
    public static ElementEdge AfterStart;
    public static ElementEdge BeforeEnd;
    public static ElementEdge AfterEnd;
}
public class System.Windows.Documents.Figure : AnchoredBlock {
    public static DependencyProperty HorizontalAnchorProperty;
    public static DependencyProperty VerticalAnchorProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty CanDelayPlacementProperty;
    public static DependencyProperty WrapDirectionProperty;
    public static DependencyProperty WidthProperty;
    public static DependencyProperty HeightProperty;
    public FigureHorizontalAnchor HorizontalAnchor { get; public set; }
    public FigureVerticalAnchor VerticalAnchor { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double VerticalOffset { get; public set; }
    public bool CanDelayPlacement { get; public set; }
    public WrapDirection WrapDirection { get; public set; }
    public FigureLength Width { get; public set; }
    public FigureLength Height { get; public set; }
    public Figure(Block childBlock);
    public Figure(Block childBlock, TextPointer insertionPosition);
    private static Figure();
    public FigureHorizontalAnchor get_HorizontalAnchor();
    public void set_HorizontalAnchor(FigureHorizontalAnchor value);
    public FigureVerticalAnchor get_VerticalAnchor();
    public void set_VerticalAnchor(FigureVerticalAnchor value);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public bool get_CanDelayPlacement();
    public void set_CanDelayPlacement(bool value);
    public WrapDirection get_WrapDirection();
    public void set_WrapDirection(WrapDirection value);
    public FigureLength get_Width();
    public void set_Width(FigureLength value);
    public FigureLength get_Height();
    public void set_Height(FigureLength value);
}
[FlagsAttribute]
internal enum System.Windows.Documents.FindFlags : Enum {
    public int value__;
    public static FindFlags None;
    public static FindFlags MatchCase;
    public static FindFlags FindInReverse;
    public static FindFlags FindWholeWordsOnly;
    public static FindFlags MatchDiacritics;
    public static FindFlags MatchKashida;
    public static FindFlags MatchAlefHamza;
}
[ContentPropertyAttribute("Pages")]
public class System.Windows.Documents.FixedDocument : FrameworkContentElement {
    public static DependencyProperty PrintTicketProperty;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal NavigationService NavigationService { get; internal set; }
    protected internal IEnumerator LogicalChildren { get; }
    public DocumentPaginator DocumentPaginator { get; }
    internal bool IsPageCountValid { get; }
    internal int PageCount { get; }
    internal Size PageSize { get; internal set; }
    internal bool HasExplicitStructure { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public PageContentCollection Pages { get; }
    public object PrintTicket { get; public set; }
    internal FixedTextContainer FixedContainer { get; }
    internal Dictionary`2<FixedPage, ArrayList> Highlights { get; }
    internal DocumentReference DocumentReference { get; internal set; }
    private static FixedDocument();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    internal NavigationService get_NavigationService();
    internal void set_NavigationService(NavigationService value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public sealed virtual DocumentPaginator get_DocumentPaginator();
    internal DocumentPage GetPage(int pageNumber);
    internal void GetPageAsync(int pageNumber, object userState);
    internal int GetPageNumber(ContentPosition contentPosition);
    internal void CancelAsync(object userState);
    internal ContentPosition GetObjectPosition(object o);
    internal ContentPosition GetPagePosition(DocumentPage page);
    internal bool get_IsPageCountValid();
    internal int get_PageCount();
    internal Size get_PageSize();
    internal void set_PageSize(Size value);
    internal bool get_HasExplicitStructure();
    public PageContentCollection get_Pages();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal int GetIndexOfPage(FixedPage p);
    internal bool IsValidPageIndex(int index);
    internal FixedPage SyncGetPageWithCheck(int index);
    internal FixedPage SyncGetPage(int index, bool forceReload);
    internal void OnPageContentAppended(int index);
    internal void EnsurePageSize(FixedPage fp);
    internal bool GetPageSize(Size& pageSize, int pageNumber);
    internal Size ComputePageSize(FixedPage fp);
    internal FixedTextContainer get_FixedContainer();
    internal Dictionary`2<FixedPage, ArrayList> get_Highlights();
    internal DocumentReference get_DocumentReference();
    internal void set_DocumentReference(DocumentReference value);
    internal void ValidateDocStructure();
    internal static StoryFragments GetStoryFragments(FixedPage fixedPage);
    internal FixedPage GetFixedPage(int pageNumber);
}
internal class System.Windows.Documents.FixedDocumentPage : DocumentPage {
    public Visual Visual { get; }
    internal ContentPosition ContentPosition { get; }
    internal FixedPage FixedPage { get; }
    internal int PageIndex { get; }
    internal FixedTextView TextView { get; }
    internal FixedDocument Owner { get; }
    internal FixedTextContainer TextContainer { get; }
    internal FixedDocumentPage(FixedDocument panel, FixedPage page, Size fixedSize, int index);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public virtual Visual get_Visual();
    internal ContentPosition get_ContentPosition();
    internal FixedPage get_FixedPage();
    internal int get_PageIndex();
    internal FixedTextView get_TextView();
    internal FixedDocument get_Owner();
    internal FixedTextContainer get_TextContainer();
}
[ContentPropertyAttribute("References")]
public class System.Windows.Documents.FixedDocumentSequence : FrameworkContentElement {
    public static DependencyProperty PrintTicketProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public DocumentPaginator DocumentPaginator { get; }
    internal bool IsPageCountValid { get; }
    internal int PageCount { get; }
    internal Size PageSize { get; internal set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    [DesignerSerializationVisibilityAttribute("2")]
[CLSCompliantAttribute("False")]
public DocumentReferenceCollection References { get; }
    public object PrintTicket { get; public set; }
    internal DocumentSequenceTextContainer TextContainer { get; }
    private static FixedDocumentSequence();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    protected internal virtual IEnumerator get_LogicalChildren();
    public sealed virtual DocumentPaginator get_DocumentPaginator();
    internal DocumentPage GetPage(int pageNumber);
    internal DocumentPage GetPage(FixedDocument document, int fixedDocPageNumber);
    internal void GetPageAsync(int pageNumber, object userState);
    internal int GetPageNumber(ContentPosition contentPosition);
    internal void CancelAsync(object userState);
    internal ContentPosition GetObjectPosition(object o);
    internal ContentPosition GetPagePosition(DocumentPage page);
    internal bool get_IsPageCountValid();
    internal int get_PageCount();
    internal Size get_PageSize();
    internal void set_PageSize(Size value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public DocumentReferenceCollection get_References();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal DynamicDocumentPaginator GetPaginator(DocumentReference docRef);
    internal bool TranslatePageNumber(int pageNumber, DynamicDocumentPaginator& childPaginator, Int32& childPageNumber);
    internal DocumentSequenceTextContainer get_TextContainer();
}
internal class System.Windows.Documents.FixedDocumentSequenceDocumentPage : DocumentPage {
    public Visual Visual { get; }
    internal ContentPosition ContentPosition { get; }
    internal DocumentReference ChildDocumentReference { get; }
    internal DocumentPage ChildDocumentPage { get; }
    internal FixedDocumentSequence FixedDocumentSequence { get; }
    internal FixedDocumentSequenceDocumentPage(FixedDocumentSequence documentSequence, DynamicDocumentPaginator documentPaginator, DocumentPage documentPage);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public virtual Visual get_Visual();
    internal ContentPosition get_ContentPosition();
    internal DocumentReference get_ChildDocumentReference();
    internal DocumentPage get_ChildDocumentPage();
    internal FixedDocumentSequence get_FixedDocumentSequence();
}
internal class System.Windows.Documents.FixedDSBuilder : object {
    public StoryFragments StoryFragments { get; }
    public FixedDSBuilder(FixedPage fp, StoryFragments sf);
    public void BuildNameHashTable(string Name, UIElement e, int indexToFixedNodes);
    public StoryFragments get_StoryFragments();
    public void ConstructFlowNodes(FlowModelBuilder flowBuilder, List`1<FixedNode> fixedNodes);
}
internal class System.Windows.Documents.FixedElement : DependencyObject {
    public static DependencyProperty LanguageProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty CellSpacingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty ColumnSpanProperty;
    public static DependencyProperty NavigateUriProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty HelpTextProperty;
    internal bool IsTextElement { get; }
    internal Type Type { get; }
    internal FixedTextPointer Start { get; }
    internal FixedTextPointer End { get; }
    internal int PageIndex { get; }
    unknown object Object {internal set; }
    internal FixedElement(ElementType type, FixedTextPointer start, FixedTextPointer end, int pageIndex);
    private static FixedElement();
    internal void Append(FixedElement e);
    internal object GetObject();
    internal object BuildObjectTree();
    internal bool get_IsTextElement();
    internal Type get_Type();
    internal FixedTextPointer get_Start();
    internal FixedTextPointer get_End();
    internal int get_PageIndex();
    internal void set_Object(object value);
}
internal class System.Windows.Documents.FixedFindEngine : object {
    private static FixedFindEngine();
    internal static TextRange Find(ITextPointer start, ITextPointer end, string findPattern, CultureInfo cultureInfo, bool matchCase, bool matchWholeWord, bool matchLast, bool matchDiacritics, bool matchKashida, bool matchAlefHamza);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Documents.FixedFlowMap : object {
    internal static int FixedOrderStartPage;
    internal static int FixedOrderEndPage;
    internal static int FixedOrderStartVisual;
    internal static int FixedOrderEndVisual;
    internal static int FlowOrderBoundaryScopeId;
    internal static int FlowOrderVirtualScopeId;
    internal static int FlowOrderScopeIdStart;
    internal FlowNode Item { get; }
    internal FixedNode FixedStartEdge { get; }
    internal FlowNode FlowStartEdge { get; }
    internal FlowNode FlowEndEdge { get; }
    internal int FlowCount { get; }
    private static FixedFlowMap();
    internal FlowNode get_Item(int fp);
    internal void MappingReplace(FlowNode flowOld, List`1<FlowNode> flowNew);
    internal FixedSOMElement MappingGetFixedSOMElement(FixedNode fixedp, int offset);
    internal FlowNode FlowOrderInsertBefore(FlowNode nextFlow, FlowNode newFlow);
    internal void AddFixedElement(FixedSOMElement element);
    internal FixedNode get_FixedStartEdge();
    internal FlowNode get_FlowStartEdge();
    internal FlowNode get_FlowEndEdge();
    internal int get_FlowCount();
    internal void _FlowOrderInsertBefore(FlowNode nextFlow, FlowNode newFlow);
}
internal class System.Windows.Documents.FixedHighlight : object {
    internal FixedHighlightType HighlightType { get; }
    internal Glyphs Glyphs { get; }
    internal UIElement Element { get; }
    internal Brush ForegroundBrush { get; }
    internal Brush BackgroundBrush { get; }
    internal FixedHighlight(UIElement element, int beginOffset, int endOffset, FixedHighlightType t, Brush foreground, Brush background);
    public virtual bool Equals(object oCompare);
    public virtual int GetHashCode();
    internal Rect ComputeDesignRect();
    internal FixedHighlightType get_HighlightType();
    internal Glyphs get_Glyphs();
    internal UIElement get_Element();
    internal Brush get_ForegroundBrush();
    internal Brush get_BackgroundBrush();
}
internal enum System.Windows.Documents.FixedHighlightType : Enum {
    public int value__;
    public static FixedHighlightType None;
    public static FixedHighlightType TextSelection;
    public static FixedHighlightType AnnotationHighlight;
}
internal static class System.Windows.Documents.FixedHyperLink : object {
    public static void OnNavigationServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static void FragmentHandler(object sender, FragmentNavigationEventArgs e);
    internal static void NavigateToElement(object ElementHost, string elementID);
}
internal class System.Windows.Documents.FixedLineResult : object {
    internal FixedNode Start { get; }
    internal FixedNode End { get; }
    internal FixedNode[] Nodes { get; }
    internal double BaseLine { get; }
    internal Rect LayoutBox { get; }
    internal FixedLineResult(FixedNode[] nodes, Rect layoutBox);
    public sealed virtual int CompareTo(object o);
    internal FixedNode get_Start();
    internal FixedNode get_End();
    internal FixedNode[] get_Nodes();
    internal double get_BaseLine();
    internal Rect get_LayoutBox();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Documents.FixedNode : ValueType {
    private Int32[] _path;
    internal int Page { get; }
    internal int Item { get; }
    internal int ChildLevels { get; }
    internal static FixedNode Create(int pageIndex, int childLevels, int level1Index, int level2Index, Int32[] childPath);
    internal static FixedNode Create(int pageIndex, Int32[] childPath);
    public sealed virtual int CompareTo(object o);
    public int CompareTo(FixedNode fixedNode);
    internal int ComparetoIndex(Int32[] childPath);
    public static bool op_LessThan(FixedNode fp1, FixedNode fp2);
    public static bool op_LessThanOrEqual(FixedNode fp1, FixedNode fp2);
    public static bool op_GreaterThan(FixedNode fp1, FixedNode fp2);
    public static bool op_GreaterThanOrEqual(FixedNode fp1, FixedNode fp2);
    public virtual bool Equals(object o);
    public bool Equals(FixedNode fixedp);
    public static bool op_Equality(FixedNode fp1, FixedNode fp2);
    public static bool op_Inequality(FixedNode fp1, FixedNode fp2);
    public virtual int GetHashCode();
    internal int get_Page();
    internal int get_Item(int level);
    internal int get_ChildLevels();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Documents.FixedPage : FrameworkElement {
    public static DependencyProperty PrintTicketProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty BottomProperty;
    public static DependencyProperty ContentBoxProperty;
    public static DependencyProperty BleedBoxProperty;
    public static DependencyProperty NavigateUriProperty;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    public object PrintTicket { get; public set; }
    public Brush Background { get; public set; }
    public Rect ContentBox { get; public set; }
    public Rect BleedBox { get; public set; }
    protected int VisualChildrenCount { get; }
    internal string StartPartUriString { get; internal set; }
    private static FixedPage();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static Uri GetNavigateUri(UIElement element);
    public static void SetNavigateUri(UIElement element, Uri uri);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public UIElementCollection get_Children();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public Rect get_ContentBox();
    public void set_ContentBox(Rect value);
    public Rect get_BleedBox();
    public void set_BleedBox(Rect value);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal static bool CanNavigateToUri(Uri uri);
    internal static Uri GetLinkUri(IInputElement element, Uri inputUri);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    internal FixedNode CreateFixedNode(int pageIndex, UIElement e);
    internal Glyphs GetGlyphsElement(FixedNode node);
    internal DependencyObject GetElement(FixedNode node);
    internal string get_StartPartUriString();
    internal void set_StartPartUriString(string value);
    internal StoryFragments GetPageStructure();
    internal Int32[] _CreateChildIndex(DependencyObject e);
}
internal class System.Windows.Documents.FixedPageStructure : object {
    internal FixedNode[] LastLine { get; }
    internal FixedNode[] FirstLine { get; }
    internal int PageIndex { get; }
    internal bool Loaded { get; }
    internal FlowNode FlowStart { get; }
    internal FlowNode FlowEnd { get; }
    internal FixedSOMPage FixedSOMPage { get; internal set; }
    internal FixedDSBuilder FixedDSBuilder { get; internal set; }
    internal FixedSOMPageConstructor PageConstructor { get; internal set; }
    internal FixedPageStructure(int pageIndex);
    internal void SetupLineResults(FixedLineResult[] lineResults);
    internal FixedNode[] GetNextLine(int line, bool forward, Int32& count);
    internal FixedNode[] FindSnapToLine(Point pt);
    internal void SetFlowBoundary(FlowNode flowStart, FlowNode flowEnd);
    public void ConstructFixedSOMPage(List`1<FixedNode> fixedNodes);
    internal FixedNode[] get_LastLine();
    internal FixedNode[] get_FirstLine();
    internal int get_PageIndex();
    internal bool get_Loaded();
    internal FlowNode get_FlowStart();
    internal FlowNode get_FlowEnd();
    internal FixedSOMPage get_FixedSOMPage();
    internal void set_FixedSOMPage(FixedSOMPage value);
    internal FixedDSBuilder get_FixedDSBuilder();
    internal void set_FixedDSBuilder(FixedDSBuilder value);
    internal FixedSOMPageConstructor get_PageConstructor();
    internal void set_PageConstructor(FixedSOMPageConstructor value);
}
internal class System.Windows.Documents.FixedPosition : ValueType {
    private FixedNode _fixedNode;
    private int _offset;
    internal int Page { get; }
    internal FixedNode Node { get; }
    internal int Offset { get; }
    internal FixedPosition(FixedNode fixedNode, int offset);
    internal int get_Page();
    internal FixedNode get_Node();
    internal int get_Offset();
}
internal abstract class System.Windows.Documents.FixedSOMContainer : FixedSOMSemanticBox {
    protected List`1<FixedSOMSemanticBox> _semanticBoxes;
    protected List`1<FixedNode> _fixedNodes;
    internal ElementType[] ElementTypes { get; }
    public List`1<FixedSOMSemanticBox> SemanticBoxes { get; public set; }
    public List`1<FixedNode> FixedNodes { get; }
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    protected void AddSorted(FixedSOMSemanticBox box);
    protected void Add(FixedSOMSemanticBox box);
    internal virtual ElementType[] get_ElementTypes();
    public List`1<FixedSOMSemanticBox> get_SemanticBoxes();
    public void set_SemanticBoxes(List`1<FixedSOMSemanticBox> value);
    public List`1<FixedNode> get_FixedNodes();
}
internal abstract class System.Windows.Documents.FixedSOMElement : FixedSOMSemanticBox {
    protected FixedNode _fixedNode;
    protected int _startIndex;
    protected int _endIndex;
    protected Matrix _mat;
    public FixedNode FixedNode { get; }
    public int StartIndex { get; }
    public int EndIndex { get; }
    internal FlowNode FlowNode { get; internal set; }
    internal int OffsetInFlowNode { get; internal set; }
    internal Matrix Matrix { get; }
    protected FixedSOMElement(FixedNode fixedNode, int startIndex, int endIndex, GeneralTransform transform);
    protected FixedSOMElement(FixedNode fixedNode, GeneralTransform transform);
    public static FixedSOMElement CreateFixedSOMElement(FixedPage page, UIElement uiElement, FixedNode fixedNode, int startIndex, int endIndex);
    public FixedNode get_FixedNode();
    public int get_StartIndex();
    public int get_EndIndex();
    internal FlowNode get_FlowNode();
    internal void set_FlowNode(FlowNode value);
    internal int get_OffsetInFlowNode();
    internal void set_OffsetInFlowNode(int value);
    internal Matrix get_Matrix();
}
internal class System.Windows.Documents.FixedSOMFixedBlock : FixedSOMPageElement {
    public double LineHeight { get; }
    public bool IsFloatingImage { get; }
    internal ElementType[] ElementTypes { get; }
    public bool IsWhiteSpace { get; }
    public bool IsRTL { get; }
    public Matrix Matrix { get; }
    public FixedSOMFixedBlock(FixedSOMPage page);
    public double get_LineHeight();
    public bool get_IsFloatingImage();
    internal virtual ElementType[] get_ElementTypes();
    public bool get_IsWhiteSpace();
    public virtual bool get_IsRTL();
    public Matrix get_Matrix();
    public void CombineWith(FixedSOMFixedBlock block);
    public void AddTextRun(FixedSOMTextRun textRun);
    public void AddImage(FixedSOMImage image);
    public virtual void SetRTFProperties(FixedElement element);
}
internal class System.Windows.Documents.FixedSOMGroup : FixedSOMPageElement {
    public bool IsRTL { get; }
    public FixedSOMGroup(FixedSOMPage page);
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    public void AddContainer(FixedSOMPageElement pageElement);
    public virtual bool get_IsRTL();
}
internal class System.Windows.Documents.FixedSOMImage : FixedSOMElement {
    internal Uri Source { get; }
    internal string Name { get; }
    internal string HelpText { get; }
    public static FixedSOMImage Create(FixedPage page, Image image, FixedNode fixedNode);
    public static FixedSOMImage Create(FixedPage page, Path path, FixedNode fixedNode);
    internal Uri get_Source();
    internal string get_Name();
    internal string get_HelpText();
}
internal class System.Windows.Documents.FixedSOMLineCollection : object {
    public List`1<FixedSOMLineRanges> HorizontalLines { get; }
    public List`1<FixedSOMLineRanges> VerticalLines { get; }
    public bool IsVerticallySeparated(double left, double top, double right, double bottom);
    public bool IsHorizontallySeparated(double left, double top, double right, double bottom);
    public void AddVertical(Point point1, Point point2);
    public void AddHorizontal(Point point1, Point point2);
    public List`1<FixedSOMLineRanges> get_HorizontalLines();
    public List`1<FixedSOMLineRanges> get_VerticalLines();
}
internal class System.Windows.Documents.FixedSOMLineRanges : object {
    public double Line { get; public set; }
    public List`1<double> Start { get; }
    public List`1<double> End { get; }
    public int Count { get; }
    public static double MinLineSeparation { get; }
    public void AddRange(double start, double end);
    public int GetLineAt(double line);
    public void set_Line(double value);
    public double get_Line();
    public List`1<double> get_Start();
    public List`1<double> get_End();
    public int get_Count();
    public static double get_MinLineSeparation();
}
internal class System.Windows.Documents.FixedSOMPage : FixedSOMContainer {
    internal ElementType[] ElementTypes { get; }
    internal List`1<FixedNode> MarkupOrder { get; internal set; }
    unknown CultureInfo CultureInfo {internal set; }
    public void AddFixedBlock(FixedSOMFixedBlock fixedBlock);
    public void AddTable(FixedSOMTable table);
    public virtual void SetRTFProperties(FixedElement element);
    internal virtual ElementType[] get_ElementTypes();
    internal List`1<FixedNode> get_MarkupOrder();
    internal void set_MarkupOrder(List`1<FixedNode> value);
    internal void set_CultureInfo(CultureInfo value);
}
internal class System.Windows.Documents.FixedSOMPageConstructor : object {
    public FixedSOMPage FixedSOMPage { get; }
    public FixedSOMPageConstructor(FixedPage fixedPage, int pageIndex);
    public FixedSOMPage ConstructPageStructure(List`1<FixedNode> fixedNodes);
    public void ProcessPath(Path path, Matrix transform);
    public FixedSOMPage get_FixedSOMPage();
    public void _AddLine(Point startP, Point endP, Matrix transform);
    internal bool _ProcessFilledRect(Matrix transform, Rect bounds);
}
internal abstract class System.Windows.Documents.FixedSOMPageElement : FixedSOMContainer {
    protected FixedSOMPage _page;
    public FixedSOMPage FixedSOMPage { get; }
    public bool IsRTL { get; }
    public FixedSOMPageElement(FixedSOMPage page);
    public FixedSOMPage get_FixedSOMPage();
    public abstract virtual bool get_IsRTL();
}
internal abstract class System.Windows.Documents.FixedSOMSemanticBox : object {
    protected Rect _boundingRect;
    public Rect BoundingRect { get; public set; }
    public FixedSOMSemanticBox(Rect boundingRect);
    public Rect get_BoundingRect();
    public void set_BoundingRect(Rect value);
    public virtual void SetRTFProperties(FixedElement element);
    public int CompareTo(object o);
    private sealed virtual override int System.IComparable.CompareTo(object o);
    protected SpatialComparison _CompareHorizontal(FixedSOMSemanticBox otherBox, bool RTL);
    protected SpatialComparison _CompareVertical(FixedSOMSemanticBox otherBox);
    protected int _SpatialToAbsoluteComparison(SpatialComparison comparison);
    protected SpatialComparison _InvertSpatialComparison(SpatialComparison comparison);
}
internal class System.Windows.Documents.FixedSOMTable : FixedSOMPageElement {
    public bool IsRTL { get; }
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    internal bool IsSingleCelled { get; }
    public FixedSOMTable(FixedSOMPage page);
    public void AddRow(FixedSOMTableRow row);
    public bool AddContainer(FixedSOMContainer container);
    public virtual void SetRTFProperties(FixedElement element);
    public virtual bool get_IsRTL();
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
    internal bool get_IsSingleCelled();
    internal void DeleteEmptyRows();
    internal void DeleteEmptyColumns();
}
internal class System.Windows.Documents.FixedSOMTableCell : FixedSOMContainer {
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    internal int ColumnSpan { get; internal set; }
    public FixedSOMTableCell(double left, double top, double right, double bottom);
    public void AddContainer(FixedSOMContainer container);
    public virtual void SetRTFProperties(FixedElement element);
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
    internal int get_ColumnSpan();
    internal void set_ColumnSpan(int value);
}
internal class System.Windows.Documents.FixedSOMTableRow : FixedSOMContainer {
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    public void AddCell(FixedSOMTableCell cell);
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
}
internal class System.Windows.Documents.FixedSOMTextRun : FixedSOMElement {
    public double DefaultCharWidth { get; }
    public bool IsSideways { get; }
    public bool IsWhiteSpace { get; }
    public CultureInfo CultureInfo { get; }
    public bool IsLTR { get; }
    public bool IsRTL { get; }
    public string Text { get; public set; }
    public FixedSOMFixedBlock FixedBlock { get; public set; }
    public string FontFamily { get; }
    public FontStyle FontStyle { get; }
    public FontWeight FontWeight { get; }
    public FontStretch FontStretch { get; }
    public double FontRenderingEmSize { get; }
    public Brush Foreground { get; }
    public bool IsReversed { get; }
    internal int LineIndex { get; internal set; }
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    public static FixedSOMTextRun Create(Rect boundingRect, GeneralTransform transform, Glyphs glyphs, FixedNode fixedNode, int startIndex, int endIndex, bool allowReverseGlyphs);
    public bool HasSameRichProperties(FixedSOMTextRun run);
    public virtual void SetRTFProperties(FixedElement element);
    public double get_DefaultCharWidth();
    public bool get_IsSideways();
    public bool get_IsWhiteSpace();
    public CultureInfo get_CultureInfo();
    public bool get_IsLTR();
    public bool get_IsRTL();
    public string get_Text();
    public void set_Text(string value);
    public FixedSOMFixedBlock get_FixedBlock();
    public void set_FixedBlock(FixedSOMFixedBlock value);
    public string get_FontFamily();
    public FontStyle get_FontStyle();
    public FontWeight get_FontWeight();
    public FontStretch get_FontStretch();
    public double get_FontRenderingEmSize();
    public Brush get_Foreground();
    public bool get_IsReversed();
    internal int get_LineIndex();
    internal void set_LineIndex(int value);
}
internal class System.Windows.Documents.FixedTextBuilder : object {
    internal static char FLOWORDER_SEPARATOR;
    internal static CultureInfo[] AdjacentLanguage;
    internal static Char[] HyphenSet;
    internal FixedFlowMap FixedFlowMap { get; }
    internal FixedTextBuilder(FixedTextContainer container);
    private static FixedTextBuilder();
    internal static bool AlwaysAdjacent(CultureInfo ci);
    internal static bool IsHyphen(char target);
    internal static bool IsSpace(char target);
    internal void AddVirtualPage();
    internal bool EnsureTextOMForPage(int pageIndex);
    internal FixedPage GetFixedPage(FixedNode node);
    internal Glyphs GetGlyphsElement(FixedNode node);
    internal FixedNode[] GetNextLine(FixedNode currentNode, bool forward, Int32& count);
    internal FixedNode[] GetLine(int pageIndex, Point pt);
    internal FixedNode[] GetFirstLine(int pageIndex);
    internal FlowPosition CreateFlowPosition(FixedPosition fixedPosition);
    internal FlowPosition GetPageStartFlowPosition(int pageIndex);
    internal FlowPosition GetPageEndFlowPosition(int pageIndex);
    internal bool GetFixedPosition(FlowPosition position, LogicalDirection textdir, FixedPosition& fixedp);
    internal bool GetFixedNodesForFlowRange(FlowPosition pStart, FlowPosition pEnd, FixedSOMElement[]& somElements, Int32& firstElementStart, Int32& lastElementEnd);
    internal string GetFlowText(FlowNode flowNode);
    internal static bool MostlyRTL(string s);
    internal static bool IsSameLine(double verticalDistance, double fontSize1, double fontSize2);
    internal static bool IsNonContiguous(CultureInfo ciPrev, CultureInfo ciCurrent, bool isSidewaysPrev, bool isSidewaysCurrent, string strPrev, string strCurrent, GlyphComparison comparison);
    internal FixedFlowMap get_FixedFlowMap();
}
internal class System.Windows.Documents.FixedTextContainer : object {
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal FixedDocument FixedDocument { get; }
    internal FixedTextBuilder FixedTextBuilder { get; }
    internal FixedElement ContainerElement { get; }
    internal Highlights Highlights { get; }
    internal ITextSelection TextSelection { get; }
    internal FixedTextContainer(DependencyObject parent);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    public sealed virtual void add_Changing(EventHandler value);
    public sealed virtual void remove_Changing(EventHandler value);
    public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
    internal FixedTextPointer VerifyPosition(ITextPointer position);
    internal int GetPageNumber(ITextPointer textPointer);
    internal void GetMultiHighlights(FixedTextPointer start, FixedTextPointer end, Dictionary`2<FixedPage, ArrayList> highlights, FixedHighlightType t, Brush foregroundBrush, Brush backgroundBrush);
    internal FixedDocument get_FixedDocument();
    internal FixedTextBuilder get_FixedTextBuilder();
    internal FixedElement get_ContainerElement();
    internal Highlights get_Highlights();
    internal ITextSelection get_TextSelection();
    internal void OnNewFlowElement(FixedElement parentElement, ElementType elementType, FlowPosition pStart, FlowPosition pEnd, object source, int pageIndex);
}
internal class System.Windows.Documents.FixedTextPointer : ContentPosition {
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal FlowPosition FlowPosition { get; }
    internal FixedTextContainer FixedTextContainer { get; }
    internal LogicalDirection LogicalDirection { get; internal set; }
    internal FixedTextPointer(bool mutable, LogicalDirection gravity, FlowPosition flow);
    internal int CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal FlowPosition get_FlowPosition();
    internal FixedTextContainer get_FixedTextContainer();
    internal LogicalDirection get_LogicalDirection();
    internal void set_LogicalDirection(LogicalDirection value);
}
internal class System.Windows.Documents.FixedTextView : TextViewBase {
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal FixedTextPointer Start { get; }
    internal FixedTextPointer End { get; }
    internal FixedTextView(FixedDocumentPage docPage);
    private static FixedTextView();
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal FixedTextPointer get_Start();
    internal FixedTextPointer get_End();
    internal static Rect _GetGlyphRunDesignRect(Glyphs g, int charStart, int charEnd);
}
public class System.Windows.Documents.Floater : AnchoredBlock {
    public static DependencyProperty HorizontalAlignmentProperty;
    public static DependencyProperty WidthProperty;
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Width { get; public set; }
    private static Floater();
    public Floater(Block childBlock);
    public Floater(Block childBlock, TextPointer insertionPosition);
    public HorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalAlignment value);
    public double get_Width();
    public void set_Width(double value);
}
[LocalizabilityAttribute("15")]
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.FlowDocument : FrameworkContentElement {
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty ColumnWidthProperty;
    public static DependencyProperty ColumnGapProperty;
    public static DependencyProperty IsColumnWidthFlexibleProperty;
    public static DependencyProperty ColumnRuleWidthProperty;
    public static DependencyProperty ColumnRuleBrushProperty;
    public static DependencyProperty IsOptimalParagraphEnabledProperty;
    public static DependencyProperty PageWidthProperty;
    public static DependencyProperty MinPageWidthProperty;
    public static DependencyProperty MaxPageWidthProperty;
    public static DependencyProperty PageHeightProperty;
    public static DependencyProperty MinPageHeightProperty;
    public static DependencyProperty MaxPageHeightProperty;
    public static DependencyProperty PagePaddingProperty;
    public static DependencyProperty IsHyphenationEnabledProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    internal TextRange TextRange { get; }
    public TextPointer ContentStart { get; }
    public TextPointer ContentEnd { get; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double ColumnWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double ColumnGap { get; public set; }
    public bool IsColumnWidthFlexible { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double ColumnRuleWidth { get; public set; }
    public Brush ColumnRuleBrush { get; public set; }
    public bool IsOptimalParagraphEnabled { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double PageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinPageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxPageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double PageHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinPageHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxPageHeight { get; public set; }
    public Thickness PagePadding { get; public set; }
    public Typography Typography { get; }
    public bool IsHyphenationEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected bool IsEnabledCore { get; }
    internal FlowDocumentFormatter BottomlessFormatter { get; }
    internal StructuralCache StructuralCache { get; }
    internal TypographyProperties TypographyPropertiesGroup { get; }
    internal TextWrapping TextWrapping { get; internal set; }
    internal IFlowDocumentFormatter Formatter { get; }
    internal bool IsLayoutDataValid { get; }
    internal TextContainer TextContainer { get; }
    internal double PixelsPerDip { get; internal set; }
    private DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator { get; }
    private static FlowDocument();
    public FlowDocument(Block block);
    internal FlowDocument(TextContainer textContainer);
    public BlockCollection get_Blocks();
    internal TextRange get_TextRange();
    public TextPointer get_ContentStart();
    public TextPointer get_ContentEnd();
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public double get_ColumnWidth();
    public void set_ColumnWidth(double value);
    public double get_ColumnGap();
    public void set_ColumnGap(double value);
    public bool get_IsColumnWidthFlexible();
    public void set_IsColumnWidthFlexible(bool value);
    public double get_ColumnRuleWidth();
    public void set_ColumnRuleWidth(double value);
    public Brush get_ColumnRuleBrush();
    public void set_ColumnRuleBrush(Brush value);
    public bool get_IsOptimalParagraphEnabled();
    public void set_IsOptimalParagraphEnabled(bool value);
    public double get_PageWidth();
    public void set_PageWidth(double value);
    public double get_MinPageWidth();
    public void set_MinPageWidth(double value);
    public double get_MaxPageWidth();
    public void set_MaxPageWidth(double value);
    public double get_PageHeight();
    public void set_PageHeight(double value);
    public double get_MinPageHeight();
    public void set_MinPageHeight(double value);
    public double get_MaxPageHeight();
    public void set_MaxPageHeight(double value);
    public Thickness get_PagePadding();
    public void set_PagePadding(Thickness value);
    public Typography get_Typography();
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    public void SetDpi(DpiScale dpiInfo);
    protected sealed virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual bool get_IsEnabledCore();
    internal ContentPosition GetObjectPosition(object element);
    internal void OnChildDesiredSizeChanged(UIElement child);
    internal void InitializeForFirstFormatting();
    internal void Uninitialize();
    internal Thickness ComputePageMargin();
    internal virtual void OnNewParent(DependencyObject newParent);
    internal FlowDocumentFormatter get_BottomlessFormatter();
    internal StructuralCache get_StructuralCache();
    internal TypographyProperties get_TypographyPropertiesGroup();
    internal TextWrapping get_TextWrapping();
    internal void set_TextWrapping(TextWrapping value);
    internal IFlowDocumentFormatter get_Formatter();
    internal bool get_IsLayoutDataValid();
    internal TextContainer get_TextContainer();
    internal double get_PixelsPerDip();
    internal void set_PixelsPerDip(double value);
    [CompilerGeneratedAttribute]
internal void add_PageSizeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PageSizeChanged(EventHandler value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.get_DocumentPaginator();
}
internal class System.Windows.Documents.FlowNode : object {
    internal int Fp { get; }
    internal int ScopeId { get; }
    internal FlowNodeType Type { get; }
    internal object Cookie { get; }
    internal FixedSOMElement[] FixedSOMElements { get; internal set; }
    internal FlowNode(int scopeId, FlowNodeType type, object cookie);
    public static bool IsNull(FlowNode flow);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual int CompareTo(object o);
    internal void SetFp(int fp);
    internal void IncreaseFp();
    internal void DecreaseFp();
    internal int get_Fp();
    internal int get_ScopeId();
    internal FlowNodeType get_Type();
    internal object get_Cookie();
    internal FixedSOMElement[] get_FixedSOMElements();
    internal void set_FixedSOMElements(FixedSOMElement[] value);
    internal void AttachElement(FixedElement fixedElement);
}
internal enum System.Windows.Documents.FlowNodeType : Enum {
    public byte value__;
    public static FlowNodeType Boundary;
    public static FlowNodeType Start;
    public static FlowNodeType Run;
    public static FlowNodeType End;
    public static FlowNodeType Object;
    public static FlowNodeType Virtual;
    public static FlowNodeType Noop;
}
internal class System.Windows.Documents.FlowPosition : object {
    internal FixedTextContainer TextContainer { get; }
    internal bool IsBoundary { get; }
    internal bool IsStart { get; }
    internal bool IsEnd { get; }
    internal bool IsSymbol { get; }
    internal bool IsRun { get; }
    internal bool IsObject { get; }
    internal FlowNode FlowNode { get; }
    internal FlowPosition(FixedTextContainer container, FlowNode node, int offset);
    public object Clone();
    public sealed virtual int CompareTo(object o);
    public virtual int GetHashCode();
    internal int GetDistance(FlowPosition flow);
    internal TextPointerContext GetPointerContext(LogicalDirection dir);
    internal int GetTextRunLength(LogicalDirection dir);
    internal int GetTextInRun(LogicalDirection dir, int maxLength, Char[] chars, int startIndex);
    internal object GetAdjacentElement(LogicalDirection dir);
    internal FixedElement GetElement(LogicalDirection dir);
    internal FixedElement GetScopingElement();
    internal bool Move(int distance);
    internal bool Move(LogicalDirection dir);
    internal void MoveTo(FlowPosition flow);
    internal void AttachElement(FixedElement e);
    internal void GetFlowNode(LogicalDirection direction, FlowNode& flowNode, Int32& offsetStart);
    internal void GetFlowNodes(FlowPosition pEnd, FlowNode[]& flowNodes, Int32& offsetStart, Int32& offsetEnd);
    internal FlowPosition GetClingPosition(LogicalDirection dir);
    internal bool IsVirtual(FlowNode flowNode);
    internal FixedTextContainer get_TextContainer();
    internal bool get_IsBoundary();
    internal bool get_IsStart();
    internal bool get_IsEnd();
    internal bool get_IsSymbol();
    internal bool get_IsRun();
    internal bool get_IsObject();
    internal FlowNode get_FlowNode();
}
internal enum System.Windows.Documents.FontSlot : Enum {
    public int value__;
    public static FontSlot LOCH;
    public static FontSlot DBCH;
    public static FontSlot HICH;
}
internal class System.Windows.Documents.FontTable : ArrayList {
    internal FontTableEntry CurrentEntry { get; }
    internal Hashtable FontMappings { get; }
    internal FontTableEntry DefineEntry(int index);
    internal FontTableEntry FindEntryByIndex(int index);
    internal FontTableEntry FindEntryByName(string name);
    internal FontTableEntry EntryAt(int index);
    internal int DefineEntryByName(string name);
    internal void MapFonts();
    internal FontTableEntry get_CurrentEntry();
    internal Hashtable get_FontMappings();
}
internal class System.Windows.Documents.FontTableEntry : object {
    internal int Index { get; internal set; }
    internal string Name { get; internal set; }
    internal bool IsNameSealed { get; internal set; }
    internal bool IsPending { get; internal set; }
    internal int CodePage { get; internal set; }
    unknown int CodePageFromCharSet {internal set; }
    internal int CharSet { get; internal set; }
    internal int get_Index();
    internal void set_Index(int value);
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_IsNameSealed();
    internal void set_IsNameSealed(bool value);
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal void set_CodePageFromCharSet(int value);
    internal int get_CharSet();
    internal void set_CharSet(int value);
    internal static int CharSetToCodePage(int cs);
    internal void ComputePreferredCodePage();
}
internal class System.Windows.Documents.FormatState : object {
    internal static FormatState EmptyFormatState { get; }
    internal RtfDestination RtfDestination { get; internal set; }
    internal bool IsHidden { get; internal set; }
    internal bool IsContentDestination { get; }
    internal bool Bold { get; internal set; }
    internal bool Italic { get; internal set; }
    internal bool Engrave { get; internal set; }
    internal bool Shadow { get; internal set; }
    internal bool SCaps { get; internal set; }
    internal bool Outline { get; internal set; }
    internal bool Sub { get; internal set; }
    internal bool Super { get; internal set; }
    internal long SuperOffset { get; internal set; }
    internal long FontSize { get; internal set; }
    internal long Font { get; internal set; }
    internal int CodePage { get; internal set; }
    internal long CF { get; internal set; }
    internal long CB { get; internal set; }
    internal DirState DirChar { get; internal set; }
    internal ULState UL { get; internal set; }
    internal StrikeState Strike { get; internal set; }
    internal long Expand { get; internal set; }
    internal long Lang { get; internal set; }
    internal long LangFE { get; internal set; }
    internal long LangCur { get; internal set; }
    internal FontSlot FontSlot { get; internal set; }
    internal long SB { get; internal set; }
    internal long SA { get; internal set; }
    internal long FI { get; internal set; }
    internal long RI { get; internal set; }
    internal long LI { get; internal set; }
    internal HAlign HAlign { get; internal set; }
    internal long ILVL { get; internal set; }
    internal long PNLVL { get; internal set; }
    internal long ITAP { get; internal set; }
    internal long ILS { get; internal set; }
    internal DirState DirPara { get; internal set; }
    internal long CFPara { get; internal set; }
    internal long CBPara { get; internal set; }
    internal long ParaShading { get; internal set; }
    internal MarkerStyle Marker { get; internal set; }
    internal bool IsContinue { get; internal set; }
    internal long StartIndex { get; internal set; }
    internal long StartIndexDefault { get; internal set; }
    internal long SL { get; internal set; }
    internal bool SLMult { get; internal set; }
    internal bool IsInTable { get; internal set; }
    internal long TableLevel { get; }
    internal long ListLevel { get; }
    internal int UnicodeSkip { get; internal set; }
    internal RowFormat RowFormat { get; internal set; }
    internal bool HasRowFormat { get; }
    internal ParaBorder ParaBorder { get; }
    internal bool HasParaBorder { get; }
    internal RtfImageFormat ImageFormat { get; internal set; }
    internal string ImageSource { get; internal set; }
    internal double ImageWidth { get; internal set; }
    internal double ImageHeight { get; internal set; }
    internal double ImageBaselineOffset { get; internal set; }
    internal bool IncludeImageBaselineOffset { get; internal set; }
    internal double ImageScaleWidth { get; internal set; }
    internal double ImageScaleHeight { get; internal set; }
    internal bool IsImageDataBinary { get; internal set; }
    internal string ImageStretch { get; internal set; }
    internal string ImageStretchDirection { get; internal set; }
    internal FormatState(FormatState formatState);
    private static FormatState();
    internal void SetCharDefaults();
    internal void SetParaDefaults();
    internal void SetRowDefaults();
    internal bool IsEqual(FormatState formatState);
    internal static FormatState get_EmptyFormatState();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal RtfDestination get_RtfDestination();
    internal void set_RtfDestination(RtfDestination value);
    internal bool get_IsHidden();
    internal void set_IsHidden(bool value);
    internal bool get_IsContentDestination();
    internal bool get_Bold();
    internal void set_Bold(bool value);
    internal bool get_Italic();
    internal void set_Italic(bool value);
    internal bool get_Engrave();
    internal void set_Engrave(bool value);
    internal bool get_Shadow();
    internal void set_Shadow(bool value);
    internal bool get_SCaps();
    internal void set_SCaps(bool value);
    internal bool get_Outline();
    internal void set_Outline(bool value);
    internal bool get_Sub();
    internal void set_Sub(bool value);
    internal bool get_Super();
    internal void set_Super(bool value);
    internal long get_SuperOffset();
    internal void set_SuperOffset(long value);
    internal long get_FontSize();
    internal void set_FontSize(long value);
    internal long get_Font();
    internal void set_Font(long value);
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_CB();
    internal void set_CB(long value);
    internal DirState get_DirChar();
    internal void set_DirChar(DirState value);
    internal ULState get_UL();
    internal void set_UL(ULState value);
    internal StrikeState get_Strike();
    internal void set_Strike(StrikeState value);
    internal long get_Expand();
    internal void set_Expand(long value);
    internal long get_Lang();
    internal void set_Lang(long value);
    internal long get_LangFE();
    internal void set_LangFE(long value);
    internal long get_LangCur();
    internal void set_LangCur(long value);
    internal FontSlot get_FontSlot();
    internal void set_FontSlot(FontSlot value);
    internal long get_SB();
    internal void set_SB(long value);
    internal long get_SA();
    internal void set_SA(long value);
    internal long get_FI();
    internal void set_FI(long value);
    internal long get_RI();
    internal void set_RI(long value);
    internal long get_LI();
    internal void set_LI(long value);
    internal HAlign get_HAlign();
    internal void set_HAlign(HAlign value);
    internal long get_ILVL();
    internal void set_ILVL(long value);
    internal long get_PNLVL();
    internal void set_PNLVL(long value);
    internal long get_ITAP();
    internal void set_ITAP(long value);
    internal long get_ILS();
    internal void set_ILS(long value);
    internal DirState get_DirPara();
    internal void set_DirPara(DirState value);
    internal long get_CFPara();
    internal void set_CFPara(long value);
    internal long get_CBPara();
    internal void set_CBPara(long value);
    internal long get_ParaShading();
    internal void set_ParaShading(long value);
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal bool get_IsContinue();
    internal void set_IsContinue(bool value);
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
    internal long get_StartIndexDefault();
    internal void set_StartIndexDefault(long value);
    internal long get_SL();
    internal void set_SL(long value);
    internal bool get_SLMult();
    internal void set_SLMult(bool value);
    internal bool get_IsInTable();
    internal void set_IsInTable(bool value);
    internal long get_TableLevel();
    internal long get_ListLevel();
    internal int get_UnicodeSkip();
    internal void set_UnicodeSkip(int value);
    internal RowFormat get_RowFormat();
    internal void set_RowFormat(RowFormat value);
    internal bool get_HasRowFormat();
    internal ParaBorder get_ParaBorder();
    internal bool get_HasParaBorder();
    internal RtfImageFormat get_ImageFormat();
    internal void set_ImageFormat(RtfImageFormat value);
    internal string get_ImageSource();
    internal void set_ImageSource(string value);
    internal double get_ImageWidth();
    internal void set_ImageWidth(double value);
    internal double get_ImageHeight();
    internal void set_ImageHeight(double value);
    internal double get_ImageBaselineOffset();
    internal void set_ImageBaselineOffset(double value);
    internal bool get_IncludeImageBaselineOffset();
    internal void set_IncludeImageBaselineOffset(bool value);
    internal double get_ImageScaleWidth();
    internal void set_ImageScaleWidth(double value);
    internal double get_ImageScaleHeight();
    internal void set_ImageScaleHeight(double value);
    internal bool get_IsImageDataBinary();
    internal void set_IsImageDataBinary(bool value);
    internal string get_ImageStretch();
    internal void set_ImageStretch(string value);
    internal string get_ImageStretchDirection();
    internal void set_ImageStretchDirection(string value);
}
public class System.Windows.Documents.FrameworkRichTextComposition : FrameworkTextComposition {
    public TextPointer ResultStart { get; }
    public TextPointer ResultEnd { get; }
    public TextPointer CompositionStart { get; }
    public TextPointer CompositionEnd { get; }
    internal FrameworkRichTextComposition(InputManager inputManager, IInputElement source, object owner);
    public TextPointer get_ResultStart();
    public TextPointer get_ResultEnd();
    public TextPointer get_CompositionStart();
    public TextPointer get_CompositionEnd();
}
public class System.Windows.Documents.FrameworkTextComposition : TextComposition {
    public int ResultOffset { get; }
    public int ResultLength { get; }
    public int CompositionOffset { get; }
    public int CompositionLength { get; }
    internal ITextPointer _ResultStart { get; }
    internal ITextPointer _ResultEnd { get; }
    internal ITextPointer _CompositionStart { get; }
    internal ITextPointer _CompositionEnd { get; }
    internal bool PendingComplete { get; }
    internal object Owner { get; }
    internal FrameworkTextComposition(InputManager inputManager, IInputElement source, object owner);
    [SecurityCriticalAttribute]
public virtual void Complete();
    public int get_ResultOffset();
    public int get_ResultLength();
    public int get_CompositionOffset();
    public int get_CompositionLength();
    [SecurityCriticalAttribute]
internal static void CompleteCurrentComposition(ITfDocumentMgr documentMgr);
    [SecurityCriticalAttribute]
internal static ITfCompositionView GetCurrentCompositionView(ITfDocumentMgr documentMgr);
    internal void SetResultPositions(ITextPointer start, ITextPointer end, string text);
    internal void SetCompositionPositions(ITextPointer start, ITextPointer end, string text);
    internal ITextPointer get__ResultStart();
    internal ITextPointer get__ResultEnd();
    internal ITextPointer get__CompositionStart();
    internal ITextPointer get__CompositionEnd();
    internal bool get_PendingComplete();
    internal object get_Owner();
}
internal class System.Windows.Documents.GeometryWalker : CapacityStreamGeometryContext {
    public GeometryWalker(FixedSOMPageConstructor pageConstructor);
    public void FindLines(StreamGeometry geometry, bool stroke, bool fill, Matrix trans);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal virtual void SetClosedState(bool closed);
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
}
public class System.Windows.Documents.GetPageRootCompletedEventArgs : AsyncCompletedEventArgs {
    public FixedPage Result { get; }
    internal GetPageRootCompletedEventArgs(FixedPage page, Exception error, bool cancelled, object userToken);
    public FixedPage get_Result();
}
public class System.Windows.Documents.GetPageRootCompletedEventHandler : MulticastDelegate {
    public GetPageRootCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageRootCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageRootCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Glyphs : FrameworkElement {
    public static DependencyProperty FillProperty;
    public static DependencyProperty IndicesProperty;
    public static DependencyProperty UnicodeStringProperty;
    public static DependencyProperty CaretStopsProperty;
    public static DependencyProperty FontRenderingEmSizeProperty;
    public static DependencyProperty OriginXProperty;
    public static DependencyProperty OriginYProperty;
    public static DependencyProperty FontUriProperty;
    public static DependencyProperty StyleSimulationsProperty;
    public static DependencyProperty IsSidewaysProperty;
    public static DependencyProperty BidiLevelProperty;
    public static DependencyProperty DeviceFontNameProperty;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public Brush Fill { get; public set; }
    public string Indices { get; public set; }
    public string UnicodeString { get; public set; }
    public string CaretStops { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double FontRenderingEmSize { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double OriginX { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double OriginY { get; public set; }
    public Uri FontUri { get; public set; }
    public StyleSimulations StyleSimulations { get; public set; }
    public bool IsSideways { get; public set; }
    public int BidiLevel { get; public set; }
    public string DeviceFontName { get; public set; }
    internal GlyphRun MeasurementGlyphRun { get; }
    private static Glyphs();
    public GlyphRun ToGlyphRun();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext context);
    protected virtual Size MeasureOverride(Size constraint);
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public string get_Indices();
    public void set_Indices(string value);
    public string get_UnicodeString();
    public void set_UnicodeString(string value);
    public string get_CaretStops();
    public void set_CaretStops(string value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public double get_OriginX();
    public void set_OriginX(double value);
    public double get_OriginY();
    public void set_OriginY(double value);
    public Uri get_FontUri();
    public void set_FontUri(Uri value);
    public StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    internal GlyphRun get_MeasurementGlyphRun();
}
internal enum System.Windows.Documents.HAlign : Enum {
    public int value__;
    public static HAlign AlignLeft;
    public static HAlign AlignRight;
    public static HAlign AlignCenter;
    public static HAlign AlignJustify;
    public static HAlign AlignDefault;
}
internal abstract class System.Windows.Documents.HighlightChangedEventArgs : object {
    internal IList Ranges { get; }
    internal Type OwnerType { get; }
    internal abstract virtual IList get_Ranges();
    internal abstract virtual Type get_OwnerType();
}
internal class System.Windows.Documents.HighlightChangedEventHandler : MulticastDelegate {
    public HighlightChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HighlightChangedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, HighlightChangedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Documents.HighlightLayer : object {
    internal Type OwnerType { get; }
    internal abstract virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.Highlights : object {
    protected ITextContainer TextContainer { get; }
    internal Highlights(ITextContainer textContainer);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction, Type highlightLayerOwnerType);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextHighlightChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextPropertyChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void AddLayer(HighlightLayer highlightLayer);
    internal void RemoveLayer(HighlightLayer highlightLayer);
    internal HighlightLayer GetLayer(Type highlightLayerType);
    protected ITextContainer get_TextContainer();
    [CompilerGeneratedAttribute]
internal void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.HighlightVisual : Adorner {
    internal HighlightVisual(FixedDocument panel, FixedPage page);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnRender(DrawingContext dc);
    internal void InvalidateHighlights();
    internal void UpdateRubberbandSelection(RubberbandSelector selector);
    internal static HighlightVisual GetHighlightVisual(FixedPage page);
}
internal class System.Windows.Documents.HostedElements : object {
    private object System.Collections.IEnumerator.Current { get; }
    public IInputElement Current { get; }
    internal HostedElements(ReadOnlyCollection`1<TextSegment> textSegments);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public sealed virtual IInputElement get_Current();
}
[TextElementEditingBehaviorAttribute]
public class System.Windows.Documents.Hyperlink : Span {
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty NavigateUriProperty;
    public static DependencyProperty TargetNameProperty;
    public static RoutedEvent RequestNavigateEvent;
    public static RoutedEvent ClickEvent;
    internal static RoutedEvent RequestSetStatusBarEvent;
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    protected bool IsEnabledCore { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public object CommandParameter { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
public IInputElement CommandTarget { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Navigation")]
[LocalizabilityAttribute("11")]
public Uri NavigateUri { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Navigation")]
[LocalizabilityAttribute("0")]
public string TargetName { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    [DesignerSerializationVisibilityAttribute("0")]
internal string Text { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Hyperlink();
    public Hyperlink(Inline childInline);
    public Hyperlink(Inline childInline, TextPointer insertionPosition);
    public Hyperlink(TextPointer start, TextPointer end);
    public void DoClick();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static object CoerceNavigateUri(DependencyObject d, object value);
    public Uri get_NavigateUri();
    public void set_NavigateUri(Uri value);
    public string get_TargetName();
    public void set_TargetName(string value);
    public void add_RequestNavigate(RequestNavigateEventHandler value);
    public void remove_RequestNavigate(RequestNavigateEventHandler value);
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    [SecurityCriticalAttribute]
protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnClick();
    [SecurityCriticalAttribute]
protected internal virtual void OnKeyDown(KeyEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    internal string get_Text();
    internal static void OnNavigateUriChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static void RaiseNavigate(IInputElement element, Uri targetUri, string targetWindow);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal interface System.Windows.Documents.IFixedNavigate {
    public abstract virtual UIElement FindElementByID(string elementID, FixedPage& rootFixedPage);
    public abstract virtual void NavigateAsync(string elementID);
}
internal class System.Windows.Documents.ImmComposition : object {
    internal bool IsComposition { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static ImmComposition();
    [SecurityCriticalAttribute]
internal ImmComposition(HwndSource source);
    [SecurityCriticalAttribute]
internal static ImmComposition GetImmComposition(FrameworkElement scope);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDetach(TextEditor editor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnGotFocus(TextEditor editor);
    internal void OnLostFocus();
    internal void OnLayoutUpdated();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CompleteComposition();
    internal void OnSelectionChange();
    internal void OnSelectionChanged();
    internal bool get_IsComposition();
    internal void UpdateCompositionText(FrameworkTextComposition composition);
    internal void UpdateCompositionText(FrameworkTextComposition composition, int resultLength, bool includeResultText, ITextPointer& start, ITextPointer& end);
}
[TextElementEditingBehaviorAttribute]
public abstract class System.Windows.Documents.Inline : TextElement {
    public static DependencyProperty BaselineAlignmentProperty;
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty FlowDirectionProperty;
    public InlineCollection SiblingInlines { get; }
    public Inline NextInline { get; }
    public Inline PreviousInline { get; }
    public BaselineAlignment BaselineAlignment { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    private static Inline();
    public InlineCollection get_SiblingInlines();
    public Inline get_NextInline();
    public Inline get_PreviousInline();
    public BaselineAlignment get_BaselineAlignment();
    public void set_BaselineAlignment(BaselineAlignment value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    internal static Run CreateImplicitRun(DependencyObject parent);
    internal static InlineUIContainer CreateImplicitInlineUIContainer(DependencyObject parent);
}
[ContentWrapperAttribute("System.Windows.Documents.Run")]
[ContentWrapperAttribute("System.Windows.Documents.InlineUIContainer")]
[WhitespaceSignificantCollectionAttribute]
public class System.Windows.Documents.InlineCollection : TextElementCollection`1<Inline> {
    public Inline FirstInline { get; }
    public Inline LastInline { get; }
    internal InlineCollection(DependencyObject owner, bool isOwnerParent);
    internal virtual int OnAdd(object value);
    public void Add(string text);
    public void Add(UIElement uiElement);
    public Inline get_FirstInline();
    public Inline get_LastInline();
    internal virtual void ValidateChild(Inline child);
}
[ContentPropertyAttribute("Child")]
[TextElementEditingBehaviorAttribute]
public class System.Windows.Documents.InlineUIContainer : Inline {
    public UIElement Child { get; public set; }
    internal UIElementIsland UIElementIsland { get; }
    public InlineUIContainer(UIElement childUIElement);
    public InlineUIContainer(UIElement childUIElement, TextPointer insertionPosition);
    public UIElement get_Child();
    public void set_Child(UIElement value);
    internal UIElementIsland get_UIElementIsland();
}
internal class System.Windows.Documents.InputScopeAttribute : object {
    internal InputScopeAttribute(InputScope inputscope);
    [SecurityCriticalAttribute]
public sealed virtual void GetInputScopes(IntPtr& ppinputscopes, Int32& count);
    [SecurityCriticalAttribute]
public sealed virtual int GetPhrase(IntPtr& ppbstrPhrases, Int32& count);
    public sealed virtual int GetRegularExpression(String& desc);
    public sealed virtual int GetSRGC(String& desc);
    public sealed virtual int GetXML(String& desc);
}
internal class System.Windows.Documents.Internal.ColumnResizeAdorner : Adorner {
    internal ColumnResizeAdorner(UIElement scope);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void Update(double newX);
    internal void Initialize(UIElement renderScope, double xPos, double yPos, double height);
    internal void Uninitialize();
}
public class System.Windows.Documents.Italic : Span {
    private static Italic();
    public Italic(Inline childInline);
    public Italic(Inline childInline, TextPointer insertionPosition);
    public Italic(TextPointer start, TextPointer end);
}
internal interface System.Windows.Documents.ITextContainer {
    public bool IsReadOnly { get; }
    public ITextPointer Start { get; }
    public ITextPointer End { get; }
    public DependencyObject Parent { get; }
    public Highlights Highlights { get; }
    public ITextSelection TextSelection { get; public set; }
    public UndoManager UndoManager { get; }
    public ITextView TextView { get; public set; }
    public int SymbolCount { get; }
    public int IMECharCount { get; }
    public UInt32 Generation { get; }
    public abstract virtual void BeginChange();
    public abstract virtual void BeginChangeNoUndo();
    public abstract virtual void EndChange();
    public abstract virtual void EndChange(bool skipEvents);
    public abstract virtual ITextPointer CreatePointerAtOffset(int offset, LogicalDirection direction);
    public abstract virtual ITextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    public abstract virtual ITextPointer CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual StaticTextPointer CreateStaticPointerAtOffset(int offset);
    public abstract virtual TextPointerContext GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    public abstract virtual int GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    public abstract virtual int GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public abstract virtual object GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual DependencyObject GetParent(StaticTextPointer position);
    public abstract virtual StaticTextPointer CreatePointer(StaticTextPointer position, int offset);
    public abstract virtual StaticTextPointer GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual int CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    public abstract virtual int CompareTo(StaticTextPointer position1, ITextPointer position2);
    public abstract virtual object GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual ITextPointer get_Start();
    public abstract virtual ITextPointer get_End();
    public abstract virtual DependencyObject get_Parent();
    public abstract virtual Highlights get_Highlights();
    public abstract virtual ITextSelection get_TextSelection();
    public abstract virtual void set_TextSelection(ITextSelection value);
    public abstract virtual UndoManager get_UndoManager();
    public abstract virtual ITextView get_TextView();
    public abstract virtual void set_TextView(ITextView value);
    public abstract virtual int get_SymbolCount();
    public abstract virtual int get_IMECharCount();
    public abstract virtual UInt32 get_Generation();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(TextContainerChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(TextContainerChangedEventHandler value);
}
internal interface System.Windows.Documents.ITextPointer {
    public ITextContainer TextContainer { get; }
    public bool HasValidLayout { get; }
    public bool IsAtCaretUnitBoundary { get; }
    public LogicalDirection LogicalDirection { get; }
    public Type ParentType { get; }
    public bool IsAtInsertionPosition { get; }
    public bool IsFrozen { get; }
    public int Offset { get; }
    public int CharOffset { get; }
    public abstract virtual ITextPointer CreatePointer();
    public abstract virtual StaticTextPointer CreateStaticPointer();
    public abstract virtual ITextPointer CreatePointer(int offset);
    public abstract virtual ITextPointer CreatePointer(LogicalDirection gravity);
    public abstract virtual ITextPointer CreatePointer(int offset, LogicalDirection gravity);
    public abstract virtual void SetLogicalDirection(LogicalDirection direction);
    public abstract virtual int CompareTo(ITextPointer position);
    public abstract virtual int CompareTo(StaticTextPointer position);
    public abstract virtual bool HasEqualScope(ITextPointer position);
    public abstract virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    public abstract virtual int GetOffsetToPosition(ITextPointer position);
    public abstract virtual int GetTextRunLength(LogicalDirection direction);
    public abstract virtual string GetTextInRun(LogicalDirection direction);
    public abstract virtual int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public abstract virtual object GetAdjacentElement(LogicalDirection direction);
    public abstract virtual void MoveToPosition(ITextPointer position);
    public abstract virtual int MoveByOffset(int offset);
    public abstract virtual bool MoveToNextContextPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetNextContextPosition(LogicalDirection direction);
    public abstract virtual bool MoveToInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetFormatNormalizedPosition(LogicalDirection direction);
    public abstract virtual bool MoveToNextInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetNextInsertionPosition(LogicalDirection direction);
    public abstract virtual void MoveToElementEdge(ElementEdge edge);
    public abstract virtual int MoveToLineBoundary(int count);
    public abstract virtual Rect GetCharacterRect(LogicalDirection direction);
    public abstract virtual void Freeze();
    public abstract virtual ITextPointer GetFrozenPointer(LogicalDirection logicalDirection);
    public abstract virtual void InsertTextInRun(string textData);
    public abstract virtual void DeleteContentToPosition(ITextPointer limit);
    public abstract virtual Type GetElementType(LogicalDirection direction);
    public abstract virtual object GetValue(DependencyProperty formattingProperty);
    public abstract virtual object ReadLocalValue(DependencyProperty formattingProperty);
    public abstract virtual LocalValueEnumerator GetLocalValueEnumerator();
    public abstract virtual bool ValidateLayout();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_HasValidLayout();
    public abstract virtual bool get_IsAtCaretUnitBoundary();
    public abstract virtual LogicalDirection get_LogicalDirection();
    public abstract virtual Type get_ParentType();
    public abstract virtual bool get_IsAtInsertionPosition();
    public abstract virtual bool get_IsFrozen();
    public abstract virtual int get_Offset();
    public abstract virtual int get_CharOffset();
}
internal interface System.Windows.Documents.ITextRange {
    public bool IgnoreTextUnitBoundaries { get; }
    public ITextPointer Start { get; }
    public ITextPointer End { get; }
    public bool IsEmpty { get; }
    public List`1<TextSegment> TextSegments { get; }
    public bool HasConcreteTextContainer { get; }
    public string Text { get; public set; }
    public string Xml { get; }
    public bool IsTableCellRange { get; }
    public int ChangeBlockLevel { get; }
    public UInt32 _ContentGeneration { get; public set; }
    public bool _IsTableCellRange { get; public set; }
    public List`1<TextSegment> _TextSegments { get; public set; }
    public int _ChangeBlockLevel { get; public set; }
    public ChangeBlockUndoRecord _ChangeBlockUndoRecord { get; public set; }
    public bool _IsChanged { get; public set; }
    public abstract virtual bool Contains(ITextPointer position);
    public abstract virtual void Select(ITextPointer position1, ITextPointer position2);
    public abstract virtual void SelectWord(ITextPointer position);
    public abstract virtual void SelectParagraph(ITextPointer position);
    public abstract virtual void ApplyTypingHeuristics(bool overType);
    public abstract virtual object GetPropertyValue(DependencyProperty formattingProperty);
    public abstract virtual UIElement GetUIElementSelected();
    public abstract virtual bool CanSave(string dataFormat);
    public abstract virtual void Save(Stream stream, string dataFormat);
    public abstract virtual void Save(Stream stream, string dataFormat, bool preserveTextElements);
    public abstract virtual void BeginChange();
    public abstract virtual void BeginChangeNoUndo();
    public abstract virtual void EndChange();
    public abstract virtual void EndChange(bool disableScroll, bool skipEvents);
    public abstract virtual IDisposable DeclareChangeBlock();
    public abstract virtual IDisposable DeclareChangeBlock(bool disableScroll);
    public abstract virtual void NotifyChanged(bool disableScroll, bool skipEvents);
    public abstract virtual bool get_IgnoreTextUnitBoundaries();
    public abstract virtual ITextPointer get_Start();
    public abstract virtual ITextPointer get_End();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual List`1<TextSegment> get_TextSegments();
    public abstract virtual bool get_HasConcreteTextContainer();
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual string get_Xml();
    public abstract virtual bool get_IsTableCellRange();
    public abstract virtual int get_ChangeBlockLevel();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
    public abstract virtual void FireChanged();
    public abstract virtual UInt32 get__ContentGeneration();
    public abstract virtual void set__ContentGeneration(UInt32 value);
    public abstract virtual bool get__IsTableCellRange();
    public abstract virtual void set__IsTableCellRange(bool value);
    public abstract virtual List`1<TextSegment> get__TextSegments();
    public abstract virtual void set__TextSegments(List`1<TextSegment> value);
    public abstract virtual int get__ChangeBlockLevel();
    public abstract virtual void set__ChangeBlockLevel(int value);
    public abstract virtual ChangeBlockUndoRecord get__ChangeBlockUndoRecord();
    public abstract virtual void set__ChangeBlockUndoRecord(ChangeBlockUndoRecord value);
    public abstract virtual bool get__IsChanged();
    public abstract virtual void set__IsChanged(bool value);
}
internal interface System.Windows.Documents.ITextSelection {
    public TextEditor TextEditor { get; }
    public ITextView TextView { get; }
    public bool IsInterimSelection { get; }
    public ITextPointer AnchorPosition { get; }
    public ITextPointer MovingPosition { get; }
    public CaretElement CaretElement { get; }
    public bool CoversEntireContent { get; }
    public abstract virtual void SetCaretToPosition(ITextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    public abstract virtual void ExtendToPosition(ITextPointer textPosition);
    public abstract virtual bool ExtendToNextInsertionPosition(LogicalDirection direction);
    public abstract virtual bool Contains(Point point);
    public abstract virtual void OnDetach();
    public abstract virtual void UpdateCaretAndHighlight();
    public abstract virtual void OnTextViewUpdated();
    public abstract virtual void DetachFromVisualTree();
    public abstract virtual void RefreshCaret();
    public abstract virtual void OnInterimSelectionChanged(bool interimSelection);
    public abstract virtual void SetSelectionByMouse(ITextPointer cursorPosition, Point cursorMousePoint);
    public abstract virtual void ExtendSelectionByMouse(ITextPointer cursorPosition, bool forceWordSelection, bool forceParagraphSelection);
    public abstract virtual bool ExtendToNextTableRow(LogicalDirection direction);
    public abstract virtual void OnCaretNavigation();
    public abstract virtual void ValidateLayout();
    public abstract virtual TextEditor get_TextEditor();
    public abstract virtual ITextView get_TextView();
    public abstract virtual bool get_IsInterimSelection();
    public abstract virtual ITextPointer get_AnchorPosition();
    public abstract virtual ITextPointer get_MovingPosition();
    public abstract virtual CaretElement get_CaretElement();
    public abstract virtual bool get_CoversEntireContent();
}
internal interface System.Windows.Documents.ITextView {
    public UIElement RenderScope { get; }
    public ITextContainer TextContainer { get; }
    public bool IsValid { get; }
    public bool RendersOwnSelection { get; }
    public ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    public abstract virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    public abstract virtual Rect GetRectangleFromTextPosition(ITextPointer position);
    public abstract virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    public abstract virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    public abstract virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    public abstract virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    public abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    public abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    public abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    public abstract virtual TextSegment GetLineRange(ITextPointer position);
    public abstract virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    public abstract virtual bool Contains(ITextPointer position);
    public abstract virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    public abstract virtual void BringPointIntoViewAsync(Point point, object userState);
    public abstract virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    public abstract virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    public abstract virtual void CancelAsync(object userState);
    public abstract virtual bool Validate();
    public abstract virtual bool Validate(Point point);
    public abstract virtual bool Validate(ITextPointer position);
    public abstract virtual void ThrottleBackgroundTasksForUserInput();
    public abstract virtual UIElement get_RenderScope();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_IsValid();
    public abstract virtual bool get_RendersOwnSelection();
    public abstract virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
}
internal interface System.Windows.Documents.IXamlAttributes {
    public abstract virtual XamlToRtfError GetLength(Int32& length);
    public abstract virtual XamlToRtfError GetUri(int index, String& uri);
    public abstract virtual XamlToRtfError GetLocalName(int index, String& localName);
    public abstract virtual XamlToRtfError GetQName(int index, String& qName);
    public abstract virtual XamlToRtfError GetName(int index, String& uri, String& localName, String& qName);
    public abstract virtual XamlToRtfError GetIndexFromName(string uri, string localName, Int32& index);
    public abstract virtual XamlToRtfError GetIndexFromQName(string qName, Int32& index);
    public abstract virtual XamlToRtfError GetType(int index, String& type);
    public abstract virtual XamlToRtfError GetTypeFromName(string uri, string localName, String& type);
    public abstract virtual XamlToRtfError GetTypeFromQName(string qName, String& type);
    public abstract virtual XamlToRtfError GetValue(int index, String& value);
    public abstract virtual XamlToRtfError GetValueFromName(string uri, string localName, String& value);
    public abstract virtual XamlToRtfError GetValueFromQName(string qName, String& value);
}
internal interface System.Windows.Documents.IXamlContentHandler {
    public abstract virtual XamlToRtfError StartDocument();
    public abstract virtual XamlToRtfError EndDocument();
    public abstract virtual XamlToRtfError StartPrefixMapping(string prefix, string uri);
    public abstract virtual XamlToRtfError StartElement(string nameSpaceUri, string localName, string qName, IXamlAttributes attributes);
    public abstract virtual XamlToRtfError EndElement(string nameSpaceUri, string localName, string qName);
    public abstract virtual XamlToRtfError Characters(string characters);
    public abstract virtual XamlToRtfError IgnorableWhitespace(string characters);
    public abstract virtual XamlToRtfError ProcessingInstruction(string target, string data);
    public abstract virtual XamlToRtfError SkippedEntity(string name);
}
internal interface System.Windows.Documents.IXamlErrorHandler {
    public abstract virtual void Error(string message, XamlToRtfError xamlToRtfError);
    public abstract virtual void FatalError(string message, XamlToRtfError xamlToRtfError);
    public abstract virtual void IgnorableWarning(string message, XamlToRtfError xamlToRtfError);
}
[TrimSurroundingWhitespaceAttribute]
public class System.Windows.Documents.LineBreak : Inline {
    public LineBreak(TextPointer insertionPosition);
}
public class System.Windows.Documents.LinkTarget : object {
    public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.LinkTargetCollection : CollectionBase {
    public LinkTarget Item { get; public set; }
    public LinkTarget get_Item(int index);
    public void set_Item(int index, LinkTarget value);
    public int Add(LinkTarget value);
    public void Remove(LinkTarget value);
    public bool Contains(LinkTarget value);
    public void CopyTo(LinkTarget[] array, int index);
    public int IndexOf(LinkTarget value);
    public void Insert(int index, LinkTarget value);
}
[ContentPropertyAttribute("ListItems")]
public class System.Windows.Documents.List : Block {
    public static DependencyProperty MarkerStyleProperty;
    public static DependencyProperty MarkerOffsetProperty;
    public static DependencyProperty StartIndexProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public ListItemCollection ListItems { get; }
    public TextMarkerStyle MarkerStyle { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MarkerOffset { get; public set; }
    public int StartIndex { get; public set; }
    private static List();
    public List(ListItem listItem);
    public ListItemCollection get_ListItems();
    public TextMarkerStyle get_MarkerStyle();
    public void set_MarkerStyle(TextMarkerStyle value);
    public double get_MarkerOffset();
    public void set_MarkerOffset(double value);
    public int get_StartIndex();
    public void set_StartIndex(int value);
    internal int GetListItemIndex(ListItem item);
    internal void Apply(Block firstBlock, Block lastBlock);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.ListItem : TextElement {
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public List List { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public ListItemCollection SiblingListItems { get; }
    public ListItem NextListItem { get; }
    public ListItem PreviousListItem { get; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    public ListItem(Paragraph paragraph);
    private static ListItem();
    public List get_List();
    public BlockCollection get_Blocks();
    public ListItemCollection get_SiblingListItems();
    public ListItem get_NextListItem();
    public ListItem get_PreviousListItem();
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
    internal virtual bool get_IsIMEStructuralElement();
}
public class System.Windows.Documents.ListItemCollection : TextElementCollection`1<ListItem> {
    public ListItem FirstListItem { get; }
    public ListItem LastListItem { get; }
    internal ListItemCollection(DependencyObject owner, bool isOwnerParent);
    public ListItem get_FirstListItem();
    public ListItem get_LastListItem();
}
internal class System.Windows.Documents.ListLevel : object {
    internal long StartIndex { get; internal set; }
    internal MarkerStyle Marker { get; internal set; }
    unknown FormatState FormatState {internal set; }
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal void set_FormatState(FormatState value);
}
internal class System.Windows.Documents.ListLevelTable : ArrayList {
    internal ListLevel CurrentEntry { get; }
    internal ListLevel EntryAt(int index);
    internal ListLevel AddEntry();
    internal ListLevel get_CurrentEntry();
}
internal class System.Windows.Documents.ListOverride : object {
    internal long ID { get; internal set; }
    internal long Index { get; internal set; }
    internal ListLevelTable Levels { get; internal set; }
    internal long StartIndex { get; internal set; }
    internal long get_ID();
    internal void set_ID(long value);
    internal long get_Index();
    internal void set_Index(long value);
    internal ListLevelTable get_Levels();
    internal void set_Levels(ListLevelTable value);
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
}
internal class System.Windows.Documents.ListOverrideTable : ArrayList {
    internal ListOverride CurrentEntry { get; }
    internal ListOverride EntryAt(int index);
    internal ListOverride FindEntry(int index);
    internal ListOverride AddEntry();
    internal ListOverride get_CurrentEntry();
}
internal class System.Windows.Documents.ListTable : ArrayList {
    internal ListTableEntry CurrentEntry { get; }
    internal ListTableEntry EntryAt(int index);
    internal ListTableEntry FindEntry(long id);
    internal ListTableEntry AddEntry();
    internal ListTableEntry get_CurrentEntry();
}
internal class System.Windows.Documents.ListTableEntry : object {
    internal long ID { get; internal set; }
    unknown long TemplateID {internal set; }
    unknown bool Simple {internal set; }
    internal ListLevelTable Levels { get; }
    internal long get_ID();
    internal void set_ID(long value);
    internal void set_TemplateID(long value);
    internal void set_Simple(bool value);
    internal ListLevelTable get_Levels();
}
public enum System.Windows.Documents.LogicalDirection : Enum {
    public int value__;
    public static LogicalDirection Backward;
    public static LogicalDirection Forward;
}
internal class System.Windows.Documents.MarkerList : ArrayList {
    internal MarkerListEntry EntryAt(int index);
    internal void AddEntry(MarkerStyle m, long nILS, long nStartIndexOverride, long nStartIndexDefault, long nLevel);
}
internal class System.Windows.Documents.MarkerListEntry : object {
    internal MarkerStyle Marker { get; internal set; }
    internal long StartIndexOverride { get; internal set; }
    internal long StartIndexDefault { get; internal set; }
    internal long VirtualListLevel { get; internal set; }
    internal long StartIndexToUse { get; }
    internal long ILS { get; internal set; }
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal long get_StartIndexOverride();
    internal void set_StartIndexOverride(long value);
    internal long get_StartIndexDefault();
    internal void set_StartIndexDefault(long value);
    internal long get_VirtualListLevel();
    internal void set_VirtualListLevel(long value);
    internal long get_StartIndexToUse();
    internal long get_ILS();
    internal void set_ILS(long value);
}
internal enum System.Windows.Documents.MarkerStyle : Enum {
    public int value__;
    public static MarkerStyle MarkerNone;
    public static MarkerStyle MarkerArabic;
    public static MarkerStyle MarkerUpperRoman;
    public static MarkerStyle MarkerLowerRoman;
    public static MarkerStyle MarkerUpperAlpha;
    public static MarkerStyle MarkerLowerAlpha;
    public static MarkerStyle MarkerOrdinal;
    public static MarkerStyle MarkerCardinal;
    public static MarkerStyle MarkerBullet;
    public static MarkerStyle MarkerHidden;
}
internal class System.Windows.Documents.MoveSizeWinEventHandler : WinEventHandler {
    internal int TextStoreCount { get; }
    internal void RegisterTextStore(TextStore textstore);
    internal void UnregisterTextStore(TextStore textstore);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void WinEventProc(int eventId, IntPtr hwnd);
    internal int get_TextStoreCount();
}
internal class System.Windows.Documents.MsSpellCheckLib.ChangeNotifyWrapper`1 : object {
    public T Value { get; public set; }
    private object System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.Value { get; private set; }
    internal ChangeNotifyWrapper`1(T value, bool shouldThrowInvalidCastException);
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    private sealed virtual override object System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.get_Value();
    private sealed virtual override void System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
internal static class System.Windows.Documents.MsSpellCheckLib.Extensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
internal static List`1<string> ToList(IEnumString enumString, bool shouldSuppressCOMExceptions, bool shouldReleaseCOMObject);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
internal static List`1<SpellingError> ToList(IEnumSpellingError spellingErrors, SpellChecker spellChecker, string text, bool shouldSuppressCOMExceptions, bool shouldReleaseCOMObject);
    [ExtensionAttribute]
internal static bool IsClean(List`1<SpellingError> errors);
}
internal interface System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal interface System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
internal class System.Windows.Documents.MsSpellCheckLib.RCW : object {
}
internal class System.Windows.Documents.MsSpellCheckLib.RetriesExhaustedException : Exception {
    internal RetriesExhaustedException(string message);
    internal RetriesExhaustedException(string message, Exception innerException);
}
internal static class System.Windows.Documents.MsSpellCheckLib.RetryHelper : object {
    internal static bool TryCallAction(Action action, RetryActionPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryCallAction(Action action, RetryPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryExecuteFunction(Func`1<TResult> func, TResult& result, RetryFunctionPreamble`1<TResult> preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryExecuteFunction(Func`1<TResult> func, TResult& result, RetryPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
}
internal class System.Windows.Documents.MsSpellCheckLib.SpellChecker : object {
    public SpellChecker(string languageTag);
    private static SpellChecker();
    public string GetLanguageTag();
    [SecuritySafeCriticalAttribute]
public List`1<string> SuggestImpl(string word);
    public List`1<string> SuggestImplWithRetries(string word, bool shouldSuppressCOMExceptions);
    public List`1<string> Suggest(string word, bool shouldSuppressCOMExceptions);
    public void Add(string word, bool shouldSuppressCOMExceptions);
    public void IgnoreImplWithRetries(string word, bool shouldSuppressCOMExceptions);
    public void Ignore(string word, bool shouldSuppressCOMExceptions);
    public void AutoCorrect(string from, string to, bool suppressCOMExceptions);
    public byte GetOptionValue(string optionId, bool suppressCOMExceptions);
    public List`1<string> GetOptionIds(bool suppressCOMExceptions);
    public string GetLocalizedName(bool suppressCOMExceptions);
    public OptionDescription GetOptionDescription(string optionId, bool suppressCOMExceptions);
    public List`1<SpellingError> Check(string text, bool suppressCOMExceptions);
    [SecuritySafeCriticalAttribute]
public List`1<SpellingError> ComprehensiveCheckImpl(string text);
    public List`1<SpellingError> ComprehensiveCheckImplWithRetries(string text, bool shouldSuppressCOMExceptions);
    public List`1<SpellingError> ComprehensiveCheck(string text, bool shouldSuppressCOMExceptions);
    internal virtual void OnChanged(SpellCheckerChangedEventArgs e);
    public void add_Changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
    public void remove_Changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class System.Windows.Documents.MsSpellCheckLib.SpellCheckerFactory : object {
    internal ISpellCheckerFactory ComFactory { get; private set; }
    internal static SpellCheckerFactory Singleton { get; private set; }
    private static SpellCheckerFactory();
    [CompilerGeneratedAttribute]
internal ISpellCheckerFactory get_ComFactory();
    [CompilerGeneratedAttribute]
private void set_ComFactory(ISpellCheckerFactory value);
    [CompilerGeneratedAttribute]
internal static SpellCheckerFactory get_Singleton();
    [CompilerGeneratedAttribute]
private static void set_Singleton(SpellCheckerFactory value);
    public static SpellCheckerFactory Create(bool shouldSuppressCOMExceptions);
    internal static List`1<string> GetSupportedLanguages(bool shouldSuppressCOMExceptions);
    internal static bool IsSupported(string languageTag, bool suppressCOMExceptons);
    [SecurityCriticalAttribute]
internal static ISpellChecker CreateSpellChecker(string languageTag, bool suppressCOMExceptions);
    internal static void RegisterUserDictionary(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    internal static void UnregisterUserDictionary(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
}
internal class System.Windows.Documents.NaturalLanguageHyphenator : TextLexicalService {
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual bool IsCultureSupported(CultureInfo culture);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual TextLexicalBreaks AnalyzeText(Char[] characterSource, int length, CultureInfo textCulture);
}
internal class System.Windows.Documents.NLGSpellerInterop : SpellerInteropBase {
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    private static NLGSpellerInterop();
    protected virtual override void Finalize();
    public virtual void Dispose();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
internal virtual void SetLocale(CultureInfo culture);
    [SecurityCriticalAttribute]
internal virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
    [SecurityCriticalAttribute]
internal virtual void UnloadDictionary(object dictionary);
    [SecurityCriticalAttribute]
internal virtual object LoadDictionary(string lexiconFilePath);
    [SecurityCriticalAttribute]
internal virtual object LoadDictionary(Uri item, string trustedFolder);
    [SecurityCriticalAttribute]
internal virtual void ReleaseAllLexicons();
    [SecurityCriticalAttribute]
internal virtual void set_Mode(SpellerMode value);
    [SecurityCriticalAttribute]
internal virtual void set_MultiWordMode(bool value);
    [SecurityCriticalAttribute]
internal virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal virtual bool CanSpellCheck(CultureInfo culture);
}
internal class System.Windows.Documents.NonLogicalAdornerDecorator : AdornerDecorator {
    public UIElement Child { get; public set; }
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
}
internal class System.Windows.Documents.NullTextContainer : object {
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    public sealed virtual void add_Changing(EventHandler value);
    public sealed virtual void remove_Changing(EventHandler value);
    public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
}
internal class System.Windows.Documents.NullTextPointer : object {
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal NullTextPointer(NullTextContainer container, LogicalDirection gravity);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int distance);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Documents.PageContent : FrameworkElement {
    public static DependencyProperty SourceProperty;
    public Uri Source { get; public set; }
    public LinkTargetCollection LinkTargets { get; }
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("2")]
public FixedPage Child { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal FixedPage PageStream { get; }
    protected internal IEnumerator LogicalChildren { get; }
    private static PageContent();
    public FixedPage GetPageRoot(bool forceReload);
    public void GetPageRootAsync(bool forceReload);
    public void GetPageRootAsyncCancel();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Uri get_Source();
    public void set_Source(Uri value);
    public LinkTargetCollection get_LinkTargets();
    public FixedPage get_Child();
    public void set_Child(FixedPage value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeChild(XamlDesignerSerializationManager manager);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public void add_GetPageRootCompleted(GetPageRootCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageRootCompleted(GetPageRootCompletedEventHandler value);
    internal bool IsOwnerOf(FixedPage pageVisual);
    internal Stream GetPageStream();
    internal FixedPage get_PageStream();
    internal bool ContainsID(string elementID);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal static void _LoadPageImpl(Uri baseUri, Uri uriToLoad, FixedPage& fixedPage, Stream& pageStream);
}
internal class System.Windows.Documents.PageContentAsyncResult : object {
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal Exception Exception { get; }
    internal bool IsCancelled { get; }
    unknown DispatcherOperation DispatcherOperation {internal set; }
    internal FixedPage Result { get; }
    internal PageContentAsyncResult(AsyncCallback callback, object state, Dispatcher dispatcher, Uri baseUri, Uri source, FixedPage child);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal object Dispatch(object arg);
    internal void Cancel();
    internal void Wait();
    internal Exception get_Exception();
    internal bool get_IsCancelled();
    internal void set_DispatcherOperation(DispatcherOperation value);
    internal FixedPage get_Result();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.PageContentCollection : object {
    public PageContent Item { get; }
    public int Count { get; }
    internal PageContentCollection(FixedDocument logicalParent);
    public int Add(PageContent newPageContent);
    public sealed virtual IEnumerator`1<PageContent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PageContent get_Item(int pageIndex);
    public int get_Count();
    internal int IndexOf(PageContent pc);
}
internal class System.Windows.Documents.ParaBorder : object {
    internal BorderFormat BorderLeft { get; internal set; }
    internal BorderFormat BorderTop { get; internal set; }
    internal BorderFormat BorderRight { get; internal set; }
    internal BorderFormat BorderBottom { get; internal set; }
    internal BorderFormat BorderAll { get; internal set; }
    internal long Spacing { get; internal set; }
    internal long CF { get; internal set; }
    internal bool IsNone { get; }
    internal string RTFEncoding { get; }
    internal ParaBorder(ParaBorder pb);
    internal BorderFormat get_BorderLeft();
    internal void set_BorderLeft(BorderFormat value);
    internal BorderFormat get_BorderTop();
    internal void set_BorderTop(BorderFormat value);
    internal BorderFormat get_BorderRight();
    internal void set_BorderRight(BorderFormat value);
    internal BorderFormat get_BorderBottom();
    internal void set_BorderBottom(BorderFormat value);
    internal BorderFormat get_BorderAll();
    internal void set_BorderAll(BorderFormat value);
    internal long get_Spacing();
    internal void set_Spacing(long value);
    internal long get_CF();
    internal void set_CF(long value);
    internal bool get_IsNone();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal string get_RTFEncoding();
}
[ContentPropertyAttribute("Inlines")]
public class System.Windows.Documents.Paragraph : Block {
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextIndentProperty;
    public static DependencyProperty MinOrphanLinesProperty;
    public static DependencyProperty MinWidowLinesProperty;
    public static DependencyProperty KeepWithNextProperty;
    public static DependencyProperty KeepTogetherProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public TextDecorationCollection TextDecorations { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double TextIndent { get; public set; }
    public int MinOrphanLines { get; public set; }
    public int MinWidowLines { get; public set; }
    public bool KeepWithNext { get; public set; }
    public bool KeepTogether { get; public set; }
    private static Paragraph();
    public Paragraph(Inline inline);
    public InlineCollection get_Inlines();
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public double get_TextIndent();
    public void set_TextIndent(double value);
    public int get_MinOrphanLines();
    public void set_MinOrphanLines(int value);
    public int get_MinWidowLines();
    public void set_MinWidowLines(int value);
    public bool get_KeepWithNext();
    public void set_KeepWithNext(bool value);
    public bool get_KeepTogether();
    public void set_KeepTogether(bool value);
    internal void GetDefaultMarginValue(Thickness& margin);
    internal static bool IsMarginAuto(Thickness margin);
    internal static bool IsLineHeightAuto(double lineHeight);
    internal static bool HasNoTextContent(Paragraph paragraph);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
}
internal enum System.Windows.Documents.PrecursorTextChangeType : Enum {
    public int value__;
    public static PrecursorTextChangeType ContentAdded;
    public static PrecursorTextChangeType ContentRemoved;
    public static PrecursorTextChangeType PropertyModified;
    public static PrecursorTextChangeType ElementAdded;
    public static PrecursorTextChangeType ElementExtracted;
}
internal class System.Windows.Documents.PropertyRecord : ValueType {
    private DependencyProperty _property;
    private object _value;
    internal DependencyProperty Property { get; internal set; }
    internal object Value { get; internal set; }
    internal DependencyProperty get_Property();
    internal void set_Property(DependencyProperty value);
    internal object get_Value();
    internal void set_Value(object value);
}
internal enum System.Windows.Documents.PropertyValueAction : Enum {
    public int value__;
    public static PropertyValueAction SetValue;
    public static PropertyValueAction IncreaseByAbsoluteValue;
    public static PropertyValueAction DecreaseByAbsoluteValue;
    public static PropertyValueAction IncreaseByPercentageValue;
    public static PropertyValueAction DecreaseByPercentageValue;
}
internal class System.Windows.Documents.RangeContentEnumerator : object {
    public object Current { get; }
    internal RangeContentEnumerator(TextPointer start, TextPointer end);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Windows.Documents.RowFormat : object {
    internal CellFormat RowCellFormat { get; }
    internal int CellCount { get; }
    internal CellFormat TopCellFormat { get; }
    internal CellWidth WidthA { get; }
    internal CellWidth WidthB { get; }
    internal CellWidth WidthRow { get; }
    internal long Trgaph { get; internal set; }
    internal long Trleft { get; internal set; }
    internal DirState Dir { get; internal set; }
    internal bool IsVMerge { get; }
    internal RowFormat(RowFormat ri);
    internal CellFormat get_RowCellFormat();
    internal int get_CellCount();
    internal CellFormat get_TopCellFormat();
    internal CellWidth get_WidthA();
    internal CellWidth get_WidthB();
    internal CellWidth get_WidthRow();
    internal long get_Trgaph();
    internal void set_Trgaph(long value);
    internal long get_Trleft();
    internal void set_Trleft(long value);
    internal DirState get_Dir();
    internal void set_Dir(DirState value);
    internal bool get_IsVMerge();
    internal CellFormat NthCellFormat(int n);
    internal CellFormat NextCellFormat();
    internal CellFormat CurrentCellFormat();
    internal void CanonicalizeWidthsFromRTF();
    internal void CanonicalizeWidthsFromXaml();
}
internal static class System.Windows.Documents.RtfControls : object {
    public static UInt32 RTK_TOGGLE;
    public static UInt32 RTK_FLAG;
    public static UInt32 RTK_VALUE;
    public static UInt32 RTK_DESTINATION;
    public static UInt32 RTK_SYMBOL;
    public static UInt32 RTK_PARAM;
    public static UInt32 RTK_TEXT;
    public static UInt32 RTK_ACHARPROPS;
    public static UInt32 RTK_CHARPROPS;
    public static UInt32 RTK_PARAPROPS;
    public static UInt32 RTK_OBJPROPS;
    public static UInt32 RTK_BOOKMARKPROPS;
    public static UInt32 RTK_SECTIONPROPS;
    public static UInt32 RTK_DOCPROPS;
    public static UInt32 RTK_FILEPROPS;
    public static UInt32 RTK_COMMENT;
    public static UInt32 RTK_STYLE;
    public static UInt32 RTK_FONTTABLE;
    public static UInt32 RTK_COLORTABLE;
    public static UInt32 RTK_BULLETS;
    public static UInt32 RTK_TABLEDEF;
    public static UInt32 RTK_SHAPES;
    public static UInt32 RTK_POSOBJ;
    public static UInt32 RTK_BORDER;
    public static UInt32 RTK_SHADING;
    public static UInt32 RTK_PICT;
    public static UInt32 RTK_FIELD;
    public static UInt32 RTK_FORMFIELD;
    public static UInt32 RTK_INDEX;
    public static UInt32 RTK_DRAWOBJ;
    public static UInt32 RTK_INFO;
    public static UInt32 RTK_LISTTABLE;
    public static UInt32 RTK_PICTPROPS;
    public static UInt32 RTK_CHARSET;
    public static UInt32 RTK_UNICODE;
    public static UInt32 RTK_TABS;
    public static UInt32 RTK_FOOTNOTES;
    public static UInt32 RTK_HIGHLIGHT;
    public static UInt32 RTK_FILETABLE;
    public static UInt32 RTK_HEADER;
    public static UInt32 RTK_OBJECTS;
    public static UInt32 RTK_PARATEXT;
    public static UInt32 RTK_SPECIAL;
    public static UInt32 RTK_SECTION;
    public static UInt32 RTK_TOC;
    internal static RtfControlWordInfo[] ControlTable;
    private static RtfControls();
}
internal enum System.Windows.Documents.RtfControlWord : Enum {
    public int value__;
    public static RtfControlWord Ctrl_Unknown;
    public static RtfControlWord Ctrl_AB;
    public static RtfControlWord Ctrl_ABSH;
    public static RtfControlWord Ctrl_ABSLOCK;
    public static RtfControlWord Ctrl_ABSNOOVRLP;
    public static RtfControlWord Ctrl_ABSW;
    public static RtfControlWord Ctrl_ACAPS;
    public static RtfControlWord Ctrl_ACCCOMMA;
    public static RtfControlWord Ctrl_ACCDOT;
    public static RtfControlWord Ctrl_ACCNONE;
    public static RtfControlWord Ctrl_ACF;
    public static RtfControlWord Ctrl_ADDITIVE;
    public static RtfControlWord Ctrl_ADJUSTRIGHT;
    public static RtfControlWord Ctrl_ADN;
    public static RtfControlWord Ctrl_AENDDOC;
    public static RtfControlWord Ctrl_AENDNOTES;
    public static RtfControlWord Ctrl_AEXPND;
    public static RtfControlWord Ctrl_AF;
    public static RtfControlWord Ctrl_AFFIXED;
    public static RtfControlWord Ctrl_AFS;
    public static RtfControlWord Ctrl_AFTNBJ;
    public static RtfControlWord Ctrl_AFTNCN;
    public static RtfControlWord Ctrl_AFTNNALC;
    public static RtfControlWord Ctrl_AFTNNAR;
    public static RtfControlWord Ctrl_AFTNNAUC;
    public static RtfControlWord Ctrl_AFTNNCHI;
    public static RtfControlWord Ctrl_AFTNNCHOSUNG;
    public static RtfControlWord Ctrl_AFTNNCNUM;
    public static RtfControlWord Ctrl_AFTNNDBAR;
    public static RtfControlWord Ctrl_AFTNNDBNUM;
    public static RtfControlWord Ctrl_AFTNNDBNUMD;
    public static RtfControlWord Ctrl_AFTNNDBNUMK;
    public static RtfControlWord Ctrl_AFTNNDBNUMT;
    public static RtfControlWord Ctrl_AFTNNGANADA;
    public static RtfControlWord Ctrl_AFTNNGBNUM;
    public static RtfControlWord Ctrl_AFTNNGBNUMD;
    public static RtfControlWord Ctrl_AFTNNGBNUMK;
    public static RtfControlWord Ctrl_AFTNNGBNUML;
    public static RtfControlWord Ctrl_AFTNNRLC;
    public static RtfControlWord Ctrl_AFTNNRUC;
    public static RtfControlWord Ctrl_AFTNNZODIAC;
    public static RtfControlWord Ctrl_AFTNNZODIACD;
    public static RtfControlWord Ctrl_AFTNNZODIACL;
    public static RtfControlWord Ctrl_AFTNRESTART;
    public static RtfControlWord Ctrl_AFTNRSTCONT;
    public static RtfControlWord Ctrl_AFTNSEP;
    public static RtfControlWord Ctrl_AFTNSEPC;
    public static RtfControlWord Ctrl_AFTNSTART;
    public static RtfControlWord Ctrl_AFTNTJ;
    public static RtfControlWord Ctrl_AI;
    public static RtfControlWord Ctrl_ALANG;
    public static RtfControlWord Ctrl_ALLPROT;
    public static RtfControlWord Ctrl_ALNTBLIND;
    public static RtfControlWord Ctrl_ALT;
    public static RtfControlWord Ctrl_ANIMTEXT;
    public static RtfControlWord Ctrl_ANNOTATION;
    public static RtfControlWord Ctrl_ANNOTPROT;
    public static RtfControlWord Ctrl_ANSI;
    public static RtfControlWord Ctrl_ANSICPG;
    public static RtfControlWord Ctrl_AOUTL;
    public static RtfControlWord Ctrl_ASCAPS;
    public static RtfControlWord Ctrl_ASHAD;
    public static RtfControlWord Ctrl_ASPALPHA;
    public static RtfControlWord Ctrl_ASPNUM;
    public static RtfControlWord Ctrl_ASTRIKE;
    public static RtfControlWord Ctrl_ATNAUTHOR;
    public static RtfControlWord Ctrl_ATNICN;
    public static RtfControlWord Ctrl_ATNID;
    public static RtfControlWord Ctrl_ATNREF;
    public static RtfControlWord Ctrl_ATNTIME;
    public static RtfControlWord Ctrl_ATRFEND;
    public static RtfControlWord Ctrl_ATRFSTART;
    public static RtfControlWord Ctrl_AUL;
    public static RtfControlWord Ctrl_AULD;
    public static RtfControlWord Ctrl_AULDB;
    public static RtfControlWord Ctrl_AULNONE;
    public static RtfControlWord Ctrl_AULW;
    public static RtfControlWord Ctrl_AUP;
    public static RtfControlWord Ctrl_AUTHOR;
    public static RtfControlWord Ctrl_B;
    public static RtfControlWord Ctrl_BACKGROUND;
    public static RtfControlWord Ctrl_BDBFHDR;
    public static RtfControlWord Ctrl_BDRRLSWSIX;
    public static RtfControlWord Ctrl_BGBDIAG;
    public static RtfControlWord Ctrl_BGCROSS;
    public static RtfControlWord Ctrl_BGDCROSS;
    public static RtfControlWord Ctrl_BGDKBDIAG;
    public static RtfControlWord Ctrl_BGDKCROSS;
    public static RtfControlWord Ctrl_BGDKDCROSS;
    public static RtfControlWord Ctrl_BGDKFDIAG;
    public static RtfControlWord Ctrl_BGDKHORIZ;
    public static RtfControlWord Ctrl_BGDKVERT;
    public static RtfControlWord Ctrl_BGFDIAG;
    public static RtfControlWord Ctrl_BGHORIZ;
    public static RtfControlWord Ctrl_BGVERT;
    public static RtfControlWord Ctrl_BIN;
    public static RtfControlWord Ctrl_BINFSXN;
    public static RtfControlWord Ctrl_BINSXN;
    public static RtfControlWord Ctrl_BKMKCOLF;
    public static RtfControlWord Ctrl_BKMKCOLL;
    public static RtfControlWord Ctrl_BKMKEND;
    public static RtfControlWord Ctrl_BKMKPUB;
    public static RtfControlWord Ctrl_BKMKSTART;
    public static RtfControlWord Ctrl_BLIPTAG;
    public static RtfControlWord Ctrl_BLIPUID;
    public static RtfControlWord Ctrl_BLIPUPI;
    public static RtfControlWord Ctrl_BLUE;
    public static RtfControlWord Ctrl_BOX;
    public static RtfControlWord Ctrl_BRDRART;
    public static RtfControlWord Ctrl_BRDRB;
    public static RtfControlWord Ctrl_BRDRBAR;
    public static RtfControlWord Ctrl_BRDRBTW;
    public static RtfControlWord Ctrl_BRDRCF;
    public static RtfControlWord Ctrl_BRDRDASH;
    public static RtfControlWord Ctrl_BRDRDASHD;
    public static RtfControlWord Ctrl_BRDRDASHDD;
    public static RtfControlWord Ctrl_BRDRDASHDOTSTR;
    public static RtfControlWord Ctrl_BRDRDASHSM;
    public static RtfControlWord Ctrl_BRDRDB;
    public static RtfControlWord Ctrl_BRDRDOT;
    public static RtfControlWord Ctrl_BRDREMBOSS;
    public static RtfControlWord Ctrl_BRDRENGRAVE;
    public static RtfControlWord Ctrl_BRDRFRAME;
    public static RtfControlWord Ctrl_BRDRHAIR;
    public static RtfControlWord Ctrl_BRDRINSET;
    public static RtfControlWord Ctrl_BRDRL;
    public static RtfControlWord Ctrl_BRDROUTSET;
    public static RtfControlWord Ctrl_BRDRNIL;
    public static RtfControlWord Ctrl_BRDRNONE;
    public static RtfControlWord Ctrl_BRDRTBL;
    public static RtfControlWord Ctrl_BRDRR;
    public static RtfControlWord Ctrl_BRDRS;
    public static RtfControlWord Ctrl_BRDRSH;
    public static RtfControlWord Ctrl_BRDRT;
    public static RtfControlWord Ctrl_BRDRTH;
    public static RtfControlWord Ctrl_BRDRTHTNLG;
    public static RtfControlWord Ctrl_BRDRTHTNMG;
    public static RtfControlWord Ctrl_BRDRTHTNSG;
    public static RtfControlWord Ctrl_BRDRTNTHLG;
    public static RtfControlWord Ctrl_BRDRTNTHMG;
    public static RtfControlWord Ctrl_BRDRTNTHSG;
    public static RtfControlWord Ctrl_BRDRTNTHTNLG;
    public static RtfControlWord Ctrl_BRDRTNTHTNMG;
    public static RtfControlWord Ctrl_BRDRTNTHTNSG;
    public static RtfControlWord Ctrl_BRDRTRIPLE;
    public static RtfControlWord Ctrl_BRDRW;
    public static RtfControlWord Ctrl_BRDRWAVY;
    public static RtfControlWord Ctrl_BRDRWAVYDB;
    public static RtfControlWord Ctrl_BRKFRM;
    public static RtfControlWord Ctrl_BRSP;
    public static RtfControlWord Ctrl_BULLET;
    public static RtfControlWord Ctrl_BUPTIM;
    public static RtfControlWord Ctrl_BXE;
    public static RtfControlWord Ctrl_CAPS;
    public static RtfControlWord Ctrl_CATEGORY;
    public static RtfControlWord Ctrl_CB;
    public static RtfControlWord Ctrl_CBPAT;
    public static RtfControlWord Ctrl_CCHS;
    public static RtfControlWord Ctrl_CELL;
    public static RtfControlWord Ctrl_CELLX;
    public static RtfControlWord Ctrl_CF;
    public static RtfControlWord Ctrl_CFPAT;
    public static RtfControlWord Ctrl_CGRID;
    public static RtfControlWord Ctrl_CHARSCALEX;
    public static RtfControlWord Ctrl_CHATN;
    public static RtfControlWord Ctrl_CHBGBDIAG;
    public static RtfControlWord Ctrl_CHBGCROSS;
    public static RtfControlWord Ctrl_CHBGDCROSS;
    public static RtfControlWord Ctrl_CHBGDKBDIAG;
    public static RtfControlWord Ctrl_CHBGDKCROSS;
    public static RtfControlWord Ctrl_CHBGDKDCROSS;
    public static RtfControlWord Ctrl_CHBGDKFDIAG;
    public static RtfControlWord Ctrl_CHBGDKHORIZ;
    public static RtfControlWord Ctrl_CHBGDKVERT;
    public static RtfControlWord Ctrl_CHBGFDIAG;
    public static RtfControlWord Ctrl_CHBGHORIZ;
    public static RtfControlWord Ctrl_CHBGVERT;
    public static RtfControlWord Ctrl_CHBRDR;
    public static RtfControlWord Ctrl_CHCBPAT;
    public static RtfControlWord Ctrl_CHCFPAT;
    public static RtfControlWord Ctrl_CHDATE;
    public static RtfControlWord Ctrl_CHDPA;
    public static RtfControlWord Ctrl_CHDPL;
    public static RtfControlWord Ctrl_CHFTN;
    public static RtfControlWord Ctrl_CHFTNSEP;
    public static RtfControlWord Ctrl_CHFTNSEPC;
    public static RtfControlWord Ctrl_CHPGN;
    public static RtfControlWord Ctrl_CHSHDNG;
    public static RtfControlWord Ctrl_CHTIME;
    public static RtfControlWord Ctrl_CLBGBDIAG;
    public static RtfControlWord Ctrl_CLBGCROSS;
    public static RtfControlWord Ctrl_CLBGDCROSS;
    public static RtfControlWord Ctrl_CLBGDKBDIAG;
    public static RtfControlWord Ctrl_CLBGDKCROSS;
    public static RtfControlWord Ctrl_CLBGDKDCROSS;
    public static RtfControlWord Ctrl_CLBGDKFDIAG;
    public static RtfControlWord Ctrl_CLBGDKHOR;
    public static RtfControlWord Ctrl_CLBGDKVERT;
    public static RtfControlWord Ctrl_CLBGFDIAG;
    public static RtfControlWord Ctrl_CLBGHORIZ;
    public static RtfControlWord Ctrl_CLBGVERT;
    public static RtfControlWord Ctrl_CLBRDRB;
    public static RtfControlWord Ctrl_CLBRDRL;
    public static RtfControlWord Ctrl_CLBRDRR;
    public static RtfControlWord Ctrl_CLBRDRT;
    public static RtfControlWord Ctrl_CLCBPAT;
    public static RtfControlWord Ctrl_CLCFPAT;
    public static RtfControlWord Ctrl_CLDGLL;
    public static RtfControlWord Ctrl_CLDGLU;
    public static RtfControlWord Ctrl_CLFITTEXT;
    public static RtfControlWord Ctrl_CLFTSWIDTH;
    public static RtfControlWord Ctrl_CLMGF;
    public static RtfControlWord Ctrl_CLMRG;
    public static RtfControlWord Ctrl_CLOWRAP;
    public static RtfControlWord Ctrl_CLPADB;
    public static RtfControlWord Ctrl_CLPADFB;
    public static RtfControlWord Ctrl_CLPADFL;
    public static RtfControlWord Ctrl_CLPADFR;
    public static RtfControlWord Ctrl_CLPADFT;
    public static RtfControlWord Ctrl_CLPADL;
    public static RtfControlWord Ctrl_CLPADR;
    public static RtfControlWord Ctrl_CLPADT;
    public static RtfControlWord Ctrl_CLSHDNG;
    public static RtfControlWord Ctrl_CLSHDRAWNIL;
    public static RtfControlWord Ctrl_CLTXBTLR;
    public static RtfControlWord Ctrl_CLTXLRTB;
    public static RtfControlWord Ctrl_CLTXLRTBV;
    public static RtfControlWord Ctrl_CLTXTBRL;
    public static RtfControlWord Ctrl_CLTXTBRLV;
    public static RtfControlWord Ctrl_CLVERTALB;
    public static RtfControlWord Ctrl_CLVERTALC;
    public static RtfControlWord Ctrl_CLVERTALT;
    public static RtfControlWord Ctrl_CLVMGF;
    public static RtfControlWord Ctrl_CLVMRG;
    public static RtfControlWord Ctrl_CLWWIDTH;
    public static RtfControlWord Ctrl_COLLAPSED;
    public static RtfControlWord Ctrl_COLNO;
    public static RtfControlWord Ctrl_COLORTBL;
    public static RtfControlWord Ctrl_COLS;
    public static RtfControlWord Ctrl_COLSR;
    public static RtfControlWord Ctrl_COLSX;
    public static RtfControlWord Ctrl_COLUMN;
    public static RtfControlWord Ctrl_COLW;
    public static RtfControlWord Ctrl_COMMENT;
    public static RtfControlWord Ctrl_COMPANY;
    public static RtfControlWord Ctrl_CPG;
    public static RtfControlWord Ctrl_CRAUTH;
    public static RtfControlWord Ctrl_CRDATE;
    public static RtfControlWord Ctrl_CREATIM;
    public static RtfControlWord Ctrl_CS;
    public static RtfControlWord Ctrl_CTRL;
    public static RtfControlWord Ctrl_CTS;
    public static RtfControlWord Ctrl_CUFI;
    public static RtfControlWord Ctrl_CULI;
    public static RtfControlWord Ctrl_CURI;
    public static RtfControlWord Ctrl_CVMME;
    public static RtfControlWord Ctrl_DATAFIELD;
    public static RtfControlWord Ctrl_DATE;
    public static RtfControlWord Ctrl_DBCH;
    public static RtfControlWord Ctrl_DEFF;
    public static RtfControlWord Ctrl_DEFFORMAT;
    public static RtfControlWord Ctrl_DEFLANG;
    public static RtfControlWord Ctrl_DEFLANGA;
    public static RtfControlWord Ctrl_DEFLANGFE;
    public static RtfControlWord Ctrl_DEFSHP;
    public static RtfControlWord Ctrl_DEFTAB;
    public static RtfControlWord Ctrl_DELETED;
    public static RtfControlWord Ctrl_DFRAUTH;
    public static RtfControlWord Ctrl_DFRDATE;
    public static RtfControlWord Ctrl_DFRMTXTX;
    public static RtfControlWord Ctrl_DFRMTXTY;
    public static RtfControlWord Ctrl_DFRSTART;
    public static RtfControlWord Ctrl_DFRSTOP;
    public static RtfControlWord Ctrl_DFRXST;
    public static RtfControlWord Ctrl_DGHORIGIN;
    public static RtfControlWord Ctrl_DGHSHOW;
    public static RtfControlWord Ctrl_DGHSPACE;
    public static RtfControlWord Ctrl_DGMARGIN;
    public static RtfControlWord Ctrl_DGSNAP;
    public static RtfControlWord Ctrl_DGVORIGIN;
    public static RtfControlWord Ctrl_DGVSHOW;
    public static RtfControlWord Ctrl_DGVSPACE;
    public static RtfControlWord Ctrl_DIBITMAP;
    public static RtfControlWord Ctrl_DN;
    public static RtfControlWord Ctrl_DNTBLNSBDB;
    public static RtfControlWord Ctrl_DO;
    public static RtfControlWord Ctrl_DOBXCOLUMN;
    public static RtfControlWord Ctrl_DOBXMARGIN;
    public static RtfControlWord Ctrl_DOBXPAGE;
    public static RtfControlWord Ctrl_DOBYMARGIN;
    public static RtfControlWord Ctrl_DOBYPAGE;
    public static RtfControlWord Ctrl_DOBYPARA;
    public static RtfControlWord Ctrl_DOCCOMM;
    public static RtfControlWord Ctrl_DOCTEMP;
    public static RtfControlWord Ctrl_DOCTYPE;
    public static RtfControlWord Ctrl_DOCVAR;
    public static RtfControlWord Ctrl_DODHGT;
    public static RtfControlWord Ctrl_DOLOCK;
    public static RtfControlWord Ctrl_DPAENDHOL;
    public static RtfControlWord Ctrl_DPAENDL;
    public static RtfControlWord Ctrl_DPAENDSOL;
    public static RtfControlWord Ctrl_DPAENDW;
    public static RtfControlWord Ctrl_DPARC;
    public static RtfControlWord Ctrl_DPARCFLIPX;
    public static RtfControlWord Ctrl_DPARCFLIPY;
    public static RtfControlWord Ctrl_DPASTARTHOL;
    public static RtfControlWord Ctrl_DPASTARTL;
    public static RtfControlWord Ctrl_DPASTARTSOL;
    public static RtfControlWord Ctrl_DPASTARTW;
    public static RtfControlWord Ctrl_DPCALLOUT;
    public static RtfControlWord Ctrl_DPCOA;
    public static RtfControlWord Ctrl_DPCOACCENT;
    public static RtfControlWord Ctrl_DPCOBESTFIT;
    public static RtfControlWord Ctrl_DPCOBORDER;
    public static RtfControlWord Ctrl_DPCODABS;
    public static RtfControlWord Ctrl_DPCODBOTTOM;
    public static RtfControlWord Ctrl_DPCODCENTER;
    public static RtfControlWord Ctrl_DPCODESCENT;
    public static RtfControlWord Ctrl_DPCODTOP;
    public static RtfControlWord Ctrl_DPCOLENGTH;
    public static RtfControlWord Ctrl_DPCOMINUSX;
    public static RtfControlWord Ctrl_DPCOMINUSY;
    public static RtfControlWord Ctrl_DPCOOFFSET;
    public static RtfControlWord Ctrl_DPCOSMARTA;
    public static RtfControlWord Ctrl_DPCOTDOUBLE;
    public static RtfControlWord Ctrl_DPCOTRIGHT;
    public static RtfControlWord Ctrl_DPCOTSINGLE;
    public static RtfControlWord Ctrl_DPCOTTRIPLE;
    public static RtfControlWord Ctrl_DPCOUNT;
    public static RtfControlWord Ctrl_DPELLIPSE;
    public static RtfControlWord Ctrl_DPENDGROUP;
    public static RtfControlWord Ctrl_DPFILLBGCB;
    public static RtfControlWord Ctrl_DPFILLBGCG;
    public static RtfControlWord Ctrl_DPFILLBGCR;
    public static RtfControlWord Ctrl_DPFILLBGGRAY;
    public static RtfControlWord Ctrl_DPFILLBGPAL;
    public static RtfControlWord Ctrl_DPFILLFGCB;
    public static RtfControlWord Ctrl_DPFILLFGCG;
    public static RtfControlWord Ctrl_DPFILLFGCR;
    public static RtfControlWord Ctrl_DPFILLFGGRAY;
    public static RtfControlWord Ctrl_DPFILLFGPAL;
    public static RtfControlWord Ctrl_DPFILLPAT;
    public static RtfControlWord Ctrl_DPGROUP;
    public static RtfControlWord Ctrl_DPLINE;
    public static RtfControlWord Ctrl_DPLINECOB;
    public static RtfControlWord Ctrl_DPLINECOG;
    public static RtfControlWord Ctrl_DPLINECOR;
    public static RtfControlWord Ctrl_DPLINEDADO;
    public static RtfControlWord Ctrl_DPLINEDADODO;
    public static RtfControlWord Ctrl_DPLINEDASH;
    public static RtfControlWord Ctrl_DPLINEDOT;
    public static RtfControlWord Ctrl_DPLINEGRAY;
    public static RtfControlWord Ctrl_DPLINEHOLLOW;
    public static RtfControlWord Ctrl_DPLINEPAL;
    public static RtfControlWord Ctrl_DPLINESOLID;
    public static RtfControlWord Ctrl_DPLINEW;
    public static RtfControlWord Ctrl_DPPOLYCOUNT;
    public static RtfControlWord Ctrl_DPPOLYGON;
    public static RtfControlWord Ctrl_DPPOLYLINE;
    public static RtfControlWord Ctrl_DPPTX;
    public static RtfControlWord Ctrl_DPPTY;
    public static RtfControlWord Ctrl_DPRECT;
    public static RtfControlWord Ctrl_DPROUNDR;
    public static RtfControlWord Ctrl_DPSHADOW;
    public static RtfControlWord Ctrl_DPSHADX;
    public static RtfControlWord Ctrl_DPSHADY;
    public static RtfControlWord Ctrl_DPTXBTLR;
    public static RtfControlWord Ctrl_DPTXBX;
    public static RtfControlWord Ctrl_DPTXBXMAR;
    public static RtfControlWord Ctrl_DPTXBXTEXT;
    public static RtfControlWord Ctrl_DPTXLRTB;
    public static RtfControlWord Ctrl_DPTXLRTBV;
    public static RtfControlWord Ctrl_DPTXTBRL;
    public static RtfControlWord Ctrl_DPTXTBRLV;
    public static RtfControlWord Ctrl_DPX;
    public static RtfControlWord Ctrl_DPXSIZE;
    public static RtfControlWord Ctrl_DPY;
    public static RtfControlWord Ctrl_DPYSIZE;
    public static RtfControlWord Ctrl_DROPCAPLI;
    public static RtfControlWord Ctrl_DROPCAPT;
    public static RtfControlWord Ctrl_DS;
    public static RtfControlWord Ctrl_DXFRTEXT;
    public static RtfControlWord Ctrl_DY;
    public static RtfControlWord Ctrl_EDMINS;
    public static RtfControlWord Ctrl_EMBO;
    public static RtfControlWord Ctrl_EMDASH;
    public static RtfControlWord Ctrl_EMFBLIP;
    public static RtfControlWord Ctrl_EMSPACE;
    public static RtfControlWord Ctrl_ENDASH;
    public static RtfControlWord Ctrl_ENDDOC;
    public static RtfControlWord Ctrl_ENDNHERE;
    public static RtfControlWord Ctrl_ENDNOTES;
    public static RtfControlWord Ctrl_ENSPACE;
    public static RtfControlWord Ctrl_EXPND;
    public static RtfControlWord Ctrl_EXPNDTW;
    public static RtfControlWord Ctrl_EXPSHRTN;
    public static RtfControlWord Ctrl_F;
    public static RtfControlWord Ctrl_FAAUTO;
    public static RtfControlWord Ctrl_FACENTER;
    public static RtfControlWord Ctrl_FACINGP;
    public static RtfControlWord Ctrl_FAHANG;
    public static RtfControlWord Ctrl_FALT;
    public static RtfControlWord Ctrl_FAROMAN;
    public static RtfControlWord Ctrl_FAVAR;
    public static RtfControlWord Ctrl_FBIAS;
    public static RtfControlWord Ctrl_FBIDI;
    public static RtfControlWord Ctrl_FCHARS;
    public static RtfControlWord Ctrl_FCHARSET;
    public static RtfControlWord Ctrl_FDECOR;
    public static RtfControlWord Ctrl_FET;
    public static RtfControlWord Ctrl_FETCH;
    public static RtfControlWord Ctrl_FFDEFRES;
    public static RtfControlWord Ctrl_FFDEFTEXT;
    public static RtfControlWord Ctrl_FFENTRYMCR;
    public static RtfControlWord Ctrl_FFEXITMCR;
    public static RtfControlWord Ctrl_FFFORMAT;
    public static RtfControlWord Ctrl_FFHASLISTBOX;
    public static RtfControlWord Ctrl_FFHELPTEXT;
    public static RtfControlWord Ctrl_FFHPS;
    public static RtfControlWord Ctrl_FFL;
    public static RtfControlWord Ctrl_FFMAXLEN;
    public static RtfControlWord Ctrl_FFNAME;
    public static RtfControlWord Ctrl_FFOWNHELP;
    public static RtfControlWord Ctrl_FFOWNSTAT;
    public static RtfControlWord Ctrl_FFPROT;
    public static RtfControlWord Ctrl_FFRECALC;
    public static RtfControlWord Ctrl_FFRES;
    public static RtfControlWord Ctrl_FFSIZE;
    public static RtfControlWord Ctrl_FFSTATTEXT;
    public static RtfControlWord Ctrl_FFTYPE;
    public static RtfControlWord Ctrl_FFTYPETXT;
    public static RtfControlWord Ctrl_FI;
    public static RtfControlWord Ctrl_FID;
    public static RtfControlWord Ctrl_FIELD;
    public static RtfControlWord Ctrl_FILE;
    public static RtfControlWord Ctrl_FILETBL;
    public static RtfControlWord Ctrl_FITTEXT;
    public static RtfControlWord Ctrl_FLDALT;
    public static RtfControlWord Ctrl_FLDDIRTY;
    public static RtfControlWord Ctrl_FLDEDIT;
    public static RtfControlWord Ctrl_FLDINST;
    public static RtfControlWord Ctrl_FLDLOCK;
    public static RtfControlWord Ctrl_FLDPRIV;
    public static RtfControlWord Ctrl_FLDRSLT;
    public static RtfControlWord Ctrl_FLDTYPE;
    public static RtfControlWord Ctrl_FMODERN;
    public static RtfControlWord Ctrl_FN;
    public static RtfControlWord Ctrl_FNAME;
    public static RtfControlWord Ctrl_FNETWORK;
    public static RtfControlWord Ctrl_FNIL;
    public static RtfControlWord Ctrl_FONTEMB;
    public static RtfControlWord Ctrl_FONTFILE;
    public static RtfControlWord Ctrl_FONTTBL;
    public static RtfControlWord Ctrl_FOOTER;
    public static RtfControlWord Ctrl_FOOTERF;
    public static RtfControlWord Ctrl_FOOTERL;
    public static RtfControlWord Ctrl_FOOTERR;
    public static RtfControlWord Ctrl_FOOTERY;
    public static RtfControlWord Ctrl_FOOTNOTE;
    public static RtfControlWord Ctrl_FORMDISP;
    public static RtfControlWord Ctrl_FORMFIELD;
    public static RtfControlWord Ctrl_FORMPROT;
    public static RtfControlWord Ctrl_FORMSHADE;
    public static RtfControlWord Ctrl_FOSNUM;
    public static RtfControlWord Ctrl_FPRQ;
    public static RtfControlWord Ctrl_FRACWIDTH;
    public static RtfControlWord Ctrl_FRELATIVE;
    public static RtfControlWord Ctrl_FRMTXBTLR;
    public static RtfControlWord Ctrl_FRMTXLRTB;
    public static RtfControlWord Ctrl_FRMTXLRTBV;
    public static RtfControlWord Ctrl_FRMTXTBRL;
    public static RtfControlWord Ctrl_FRMTXTBRLV;
    public static RtfControlWord Ctrl_FROMAN;
    public static RtfControlWord Ctrl_FROMHTML;
    public static RtfControlWord Ctrl_FROMTEXT;
    public static RtfControlWord Ctrl_FS;
    public static RtfControlWord Ctrl_FSCRIPT;
    public static RtfControlWord Ctrl_FSWISS;
    public static RtfControlWord Ctrl_FTNALT;
    public static RtfControlWord Ctrl_FTNBJ;
    public static RtfControlWord Ctrl_FTNCN;
    public static RtfControlWord Ctrl_FTNIL;
    public static RtfControlWord Ctrl_FTNLYTWNINE;
    public static RtfControlWord Ctrl_FTNNALC;
    public static RtfControlWord Ctrl_FTNNAR;
    public static RtfControlWord Ctrl_FTNNAUC;
    public static RtfControlWord Ctrl_FTNNCHI;
    public static RtfControlWord Ctrl_FTNNCHOSUNG;
    public static RtfControlWord Ctrl_FTNNCNUM;
    public static RtfControlWord Ctrl_FTNNDBAR;
    public static RtfControlWord Ctrl_FTNNDBNUM;
    public static RtfControlWord Ctrl_FTNNDBNUMD;
    public static RtfControlWord Ctrl_FTNNDBNUMK;
    public static RtfControlWord Ctrl_FTNNDBNUMT;
    public static RtfControlWord Ctrl_FTNNGANADA;
    public static RtfControlWord Ctrl_FTNNGBNUM;
    public static RtfControlWord Ctrl_FTNNGBNUMD;
    public static RtfControlWord Ctrl_FTNNGBNUMK;
    public static RtfControlWord Ctrl_FTNNGBNUML;
    public static RtfControlWord Ctrl_FTNNRLC;
    public static RtfControlWord Ctrl_FTNNRUC;
    public static RtfControlWord Ctrl_FTNNZODIAC;
    public static RtfControlWord Ctrl_FTNNZODIACD;
    public static RtfControlWord Ctrl_FTNNZODIACL;
    public static RtfControlWord Ctrl_FTNRESTART;
    public static RtfControlWord Ctrl_FTNRSTCONT;
    public static RtfControlWord Ctrl_FTNRSTPG;
    public static RtfControlWord Ctrl_FTNSEP;
    public static RtfControlWord Ctrl_FTNSEPC;
    public static RtfControlWord Ctrl_FTNSTART;
    public static RtfControlWord Ctrl_FTNTJ;
    public static RtfControlWord Ctrl_FTTRUETYPE;
    public static RtfControlWord Ctrl_FVALIDDOS;
    public static RtfControlWord Ctrl_FVALIDHPFS;
    public static RtfControlWord Ctrl_FVALIDMAC;
    public static RtfControlWord Ctrl_FVALIDNTFS;
    public static RtfControlWord Ctrl_G;
    public static RtfControlWord Ctrl_GCW;
    public static RtfControlWord Ctrl_GREEN;
    public static RtfControlWord Ctrl_GRIDTBL;
    public static RtfControlWord Ctrl_GUTTER;
    public static RtfControlWord Ctrl_GUTTERPRL;
    public static RtfControlWord Ctrl_GUTTERSXN;
    public static RtfControlWord Ctrl_HEADER;
    public static RtfControlWord Ctrl_HEADERF;
    public static RtfControlWord Ctrl_HEADERL;
    public static RtfControlWord Ctrl_HEADERR;
    public static RtfControlWord Ctrl_HEADERY;
    public static RtfControlWord Ctrl_HICH;
    public static RtfControlWord Ctrl_HIGHLIGHT;
    public static RtfControlWord Ctrl_HLFR;
    public static RtfControlWord Ctrl_HLINKBASE;
    public static RtfControlWord Ctrl_HLLOC;
    public static RtfControlWord Ctrl_HLSRC;
    public static RtfControlWord Ctrl_HORZDOC;
    public static RtfControlWord Ctrl_HORZSECT;
    public static RtfControlWord Ctrl_HR;
    public static RtfControlWord Ctrl_HTMAUTSP;
    public static RtfControlWord Ctrl_HTMLBASE;
    public static RtfControlWord Ctrl_HTMLRTF;
    public static RtfControlWord Ctrl_HTMLTAG;
    public static RtfControlWord Ctrl_HYPHAUTO;
    public static RtfControlWord Ctrl_HYPHCAPS;
    public static RtfControlWord Ctrl_HYPHCONSEC;
    public static RtfControlWord Ctrl_HYPHHOTZ;
    public static RtfControlWord Ctrl_HYPHPAR;
    public static RtfControlWord Ctrl_I;
    public static RtfControlWord Ctrl_ID;
    public static RtfControlWord Ctrl_ILVL;
    public static RtfControlWord Ctrl_IMPR;
    public static RtfControlWord Ctrl_INFO;
    public static RtfControlWord Ctrl_INTBL;
    public static RtfControlWord Ctrl_ITAP;
    public static RtfControlWord Ctrl_IXE;
    public static RtfControlWord Ctrl_JCOMPRESS;
    public static RtfControlWord Ctrl_JEXPAND;
    public static RtfControlWord Ctrl_JPEGBLIP;
    public static RtfControlWord Ctrl_JSKSU;
    public static RtfControlWord Ctrl_KEEP;
    public static RtfControlWord Ctrl_KEEPN;
    public static RtfControlWord Ctrl_KERNING;
    public static RtfControlWord Ctrl_KEYCODE;
    public static RtfControlWord Ctrl_KEYWORDS;
    public static RtfControlWord Ctrl_KSULANG;
    public static RtfControlWord Ctrl_LANDSCAPE;
    public static RtfControlWord Ctrl_LANG;
    public static RtfControlWord Ctrl_LANGFE;
    public static RtfControlWord Ctrl_LANGFENP;
    public static RtfControlWord Ctrl_LANGNP;
    public static RtfControlWord Ctrl_LBR;
    public static RtfControlWord Ctrl_LCHARS;
    public static RtfControlWord Ctrl_LDBLQUOTE;
    public static RtfControlWord Ctrl_LEVEL;
    public static RtfControlWord Ctrl_LEVELFOLLOW;
    public static RtfControlWord Ctrl_LEVELINDENT;
    public static RtfControlWord Ctrl_LEVELJC;
    public static RtfControlWord Ctrl_LEVELJCN;
    public static RtfControlWord Ctrl_LEVELLEGAL;
    public static RtfControlWord Ctrl_LEVELNFC;
    public static RtfControlWord Ctrl_LEVELNFCN;
    public static RtfControlWord Ctrl_LEVELNORESTART;
    public static RtfControlWord Ctrl_LEVELNUMBERS;
    public static RtfControlWord Ctrl_LEVELOLD;
    public static RtfControlWord Ctrl_LEVELPREV;
    public static RtfControlWord Ctrl_LEVELPREVSPACE;
    public static RtfControlWord Ctrl_LEVELSPACE;
    public static RtfControlWord Ctrl_LEVELSTARTAT;
    public static RtfControlWord Ctrl_LEVELTEMPLATEID;
    public static RtfControlWord Ctrl_LEVELTEXT;
    public static RtfControlWord Ctrl_LFOLEVEL;
    public static RtfControlWord Ctrl_LI;
    public static RtfControlWord Ctrl_LINE;
    public static RtfControlWord Ctrl_LINEBETCOL;
    public static RtfControlWord Ctrl_LINECONT;
    public static RtfControlWord Ctrl_LINEMOD;
    public static RtfControlWord Ctrl_LINEPPAGE;
    public static RtfControlWord Ctrl_LINERESTART;
    public static RtfControlWord Ctrl_LINESTART;
    public static RtfControlWord Ctrl_LINESTARTS;
    public static RtfControlWord Ctrl_LINEX;
    public static RtfControlWord Ctrl_LINKSELF;
    public static RtfControlWord Ctrl_LINKSTYLES;
    public static RtfControlWord Ctrl_LINKVAL;
    public static RtfControlWord Ctrl_LIN;
    public static RtfControlWord Ctrl_LISA;
    public static RtfControlWord Ctrl_LISB;
    public static RtfControlWord Ctrl_LIST;
    public static RtfControlWord Ctrl_LISTHYBRID;
    public static RtfControlWord Ctrl_LISTID;
    public static RtfControlWord Ctrl_LISTLEVEL;
    public static RtfControlWord Ctrl_LISTNAME;
    public static RtfControlWord Ctrl_LISTOVERRIDE;
    public static RtfControlWord Ctrl_LISTOVERRIDECOUNT;
    public static RtfControlWord Ctrl_LISTOVERRIDEFORMAT;
    public static RtfControlWord Ctrl_LISTOVERRIDESTART;
    public static RtfControlWord Ctrl_LISTPICTURE;
    public static RtfControlWord Ctrl_LISTRESTARTHDN;
    public static RtfControlWord Ctrl_LISTSIMPLE;
    public static RtfControlWord Ctrl_LISTTABLE;
    public static RtfControlWord Ctrl_LISTOVERRIDETABLE;
    public static RtfControlWord Ctrl_LISTTEMPLATEID;
    public static RtfControlWord Ctrl_LISTTEXT;
    public static RtfControlWord Ctrl_LNBRKRULE;
    public static RtfControlWord Ctrl_LNDSCPSXN;
    public static RtfControlWord Ctrl_LNONGRID;
    public static RtfControlWord Ctrl_LOCH;
    public static RtfControlWord Ctrl_LQUOTE;
    public static RtfControlWord Ctrl_LS;
    public static RtfControlWord Ctrl_LTRCH;
    public static RtfControlWord Ctrl_LTRDOC;
    public static RtfControlWord Ctrl_LTRMARK;
    public static RtfControlWord Ctrl_LTRPAR;
    public static RtfControlWord Ctrl_LTRROW;
    public static RtfControlWord Ctrl_LTRSECT;
    public static RtfControlWord Ctrl_LYTCALCTBLWD;
    public static RtfControlWord Ctrl_LYTEXCTTP;
    public static RtfControlWord Ctrl_LYTPRTMET;
    public static RtfControlWord Ctrl_LYTTBLRTGR;
    public static RtfControlWord Ctrl_MAC;
    public static RtfControlWord Ctrl_MACPICT;
    public static RtfControlWord Ctrl_MAKEBACKUP;
    public static RtfControlWord Ctrl_MANAGER;
    public static RtfControlWord Ctrl_MARGB;
    public static RtfControlWord Ctrl_MARGBSXN;
    public static RtfControlWord Ctrl_MARGL;
    public static RtfControlWord Ctrl_MARGLSXN;
    public static RtfControlWord Ctrl_MARGMIRROR;
    public static RtfControlWord Ctrl_MARGR;
    public static RtfControlWord Ctrl_MARGRSXN;
    public static RtfControlWord Ctrl_MARGT;
    public static RtfControlWord Ctrl_MARGTSXN;
    public static RtfControlWord Ctrl_MHTMLTAG;
    public static RtfControlWord Ctrl_MIN;
    public static RtfControlWord Ctrl_MO;
    public static RtfControlWord Ctrl_MSMCAP;
    public static RtfControlWord Ctrl_NESTCELL;
    public static RtfControlWord Ctrl_NESTROW;
    public static RtfControlWord Ctrl_NESTTABLEPROPS;
    public static RtfControlWord Ctrl_NEXTFILE;
    public static RtfControlWord Ctrl_NOCOLBAL;
    public static RtfControlWord Ctrl_NOCWRAP;
    public static RtfControlWord Ctrl_NOEXTRASPRL;
    public static RtfControlWord Ctrl_NOFCHARS;
    public static RtfControlWord Ctrl_NOFCHARSWS;
    public static RtfControlWord Ctrl_NOFPAGES;
    public static RtfControlWord Ctrl_NOFWORDS;
    public static RtfControlWord Ctrl_NOLEAD;
    public static RtfControlWord Ctrl_NOLINE;
    public static RtfControlWord Ctrl_NOLNHTADJTBL;
    public static RtfControlWord Ctrl_NONESTTABLES;
    public static RtfControlWord Ctrl_NONSHPPICT;
    public static RtfControlWord Ctrl_NOOVERFLOW;
    public static RtfControlWord Ctrl_NOPROOF;
    public static RtfControlWord Ctrl_NOSECTEXPAND;
    public static RtfControlWord Ctrl_NOSNAPLINEGRID;
    public static RtfControlWord Ctrl_NOSPACEFORUL;
    public static RtfControlWord Ctrl_NOSUPERSUB;
    public static RtfControlWord Ctrl_NOTABIND;
    public static RtfControlWord Ctrl_NOULTRLSPC;
    public static RtfControlWord Ctrl_NOWIDCTLPAR;
    public static RtfControlWord Ctrl_NOWRAP;
    public static RtfControlWord Ctrl_NOWWRAP;
    public static RtfControlWord Ctrl_NOXLATTOYEN;
    public static RtfControlWord Ctrl_OBJALIAS;
    public static RtfControlWord Ctrl_OBJALIGN;
    public static RtfControlWord Ctrl_OBJATTPH;
    public static RtfControlWord Ctrl_OBJAUTLINK;
    public static RtfControlWord Ctrl_OBJCLASS;
    public static RtfControlWord Ctrl_OBJCROPB;
    public static RtfControlWord Ctrl_OBJCROPL;
    public static RtfControlWord Ctrl_OBJCROPR;
    public static RtfControlWord Ctrl_OBJCROPT;
    public static RtfControlWord Ctrl_OBJDATA;
    public static RtfControlWord Ctrl_OBJECT;
    public static RtfControlWord Ctrl_OBJEMB;
    public static RtfControlWord Ctrl_OBJH;
    public static RtfControlWord Ctrl_OBJHTML;
    public static RtfControlWord Ctrl_OBJICEMB;
    public static RtfControlWord Ctrl_OBJLINK;
    public static RtfControlWord Ctrl_OBJLOCK;
    public static RtfControlWord Ctrl_OBJNAME;
    public static RtfControlWord Ctrl_OBJOCX;
    public static RtfControlWord Ctrl_OBJPUB;
    public static RtfControlWord Ctrl_OBJSCALEX;
    public static RtfControlWord Ctrl_OBJSCALEY;
    public static RtfControlWord Ctrl_OBJSECT;
    public static RtfControlWord Ctrl_OBJSETSIZE;
    public static RtfControlWord Ctrl_OBJSUB;
    public static RtfControlWord Ctrl_OBJTIME;
    public static RtfControlWord Ctrl_OBJTRANSY;
    public static RtfControlWord Ctrl_OBJUPDATE;
    public static RtfControlWord Ctrl_OBJW;
    public static RtfControlWord Ctrl_OLDAS;
    public static RtfControlWord Ctrl_OLDLINEWRAP;
    public static RtfControlWord Ctrl_OPERATOR;
    public static RtfControlWord Ctrl_OTBLRUL;
    public static RtfControlWord Ctrl_OUTL;
    public static RtfControlWord Ctrl_OUTLINELEVEL;
    public static RtfControlWord Ctrl_OVERLAY;
    public static RtfControlWord Ctrl_PAGE;
    public static RtfControlWord Ctrl_PAGEBB;
    public static RtfControlWord Ctrl_PANOSE;
    public static RtfControlWord Ctrl_PAPERH;
    public static RtfControlWord Ctrl_PAPERW;
    public static RtfControlWord Ctrl_PAR;
    public static RtfControlWord Ctrl_PARD;
    public static RtfControlWord Ctrl_PC;
    public static RtfControlWord Ctrl_PCA;
    public static RtfControlWord Ctrl_PGBRDRB;
    public static RtfControlWord Ctrl_PGBRDRFOOT;
    public static RtfControlWord Ctrl_PGBRDRHEAD;
    public static RtfControlWord Ctrl_PGBRDRL;
    public static RtfControlWord Ctrl_PGBRDROPT;
    public static RtfControlWord Ctrl_PGBRDRR;
    public static RtfControlWord Ctrl_PGBRDRSNAP;
    public static RtfControlWord Ctrl_PGBRDRT;
    public static RtfControlWord Ctrl_PGHSXN;
    public static RtfControlWord Ctrl_PGNBIDIA;
    public static RtfControlWord Ctrl_PGNBIDIB;
    public static RtfControlWord Ctrl_PGNCHOSUNG;
    public static RtfControlWord Ctrl_PGNCNUM;
    public static RtfControlWord Ctrl_PGNCONT;
    public static RtfControlWord Ctrl_PGNDBNUM;
    public static RtfControlWord Ctrl_PGNDBNUMD;
    public static RtfControlWord Ctrl_PGNDBNUMK;
    public static RtfControlWord Ctrl_PGNDBNUMT;
    public static RtfControlWord Ctrl_PGNDEC;
    public static RtfControlWord Ctrl_PGNDECD;
    public static RtfControlWord Ctrl_PGNGANADA;
    public static RtfControlWord Ctrl_PGNGBNUM;
    public static RtfControlWord Ctrl_PGNGBNUMD;
    public static RtfControlWord Ctrl_PGNGBNUMK;
    public static RtfControlWord Ctrl_PGNGBNUML;
    public static RtfControlWord Ctrl_PGNHN;
    public static RtfControlWord Ctrl_PGNHNSC;
    public static RtfControlWord Ctrl_PGNHNSH;
    public static RtfControlWord Ctrl_PGNHNSM;
    public static RtfControlWord Ctrl_PGNHNSN;
    public static RtfControlWord Ctrl_PGNHNSP;
    public static RtfControlWord Ctrl_PGNLCLTR;
    public static RtfControlWord Ctrl_PGNLCRM;
    public static RtfControlWord Ctrl_PGNRESTART;
    public static RtfControlWord Ctrl_PGNSTART;
    public static RtfControlWord Ctrl_PGNSTARTS;
    public static RtfControlWord Ctrl_PGNUCLTR;
    public static RtfControlWord Ctrl_PGNUCRM;
    public static RtfControlWord Ctrl_PGNX;
    public static RtfControlWord Ctrl_PGNY;
    public static RtfControlWord Ctrl_PGNZODIAC;
    public static RtfControlWord Ctrl_PGNZODIACD;
    public static RtfControlWord Ctrl_PGNZODIACL;
    public static RtfControlWord Ctrl_PGWSXN;
    public static RtfControlWord Ctrl_PHCOL;
    public static RtfControlWord Ctrl_PHMRG;
    public static RtfControlWord Ctrl_PHPG;
    public static RtfControlWord Ctrl_PICBMP;
    public static RtfControlWord Ctrl_PICBPP;
    public static RtfControlWord Ctrl_PICCROPB;
    public static RtfControlWord Ctrl_PICCROPL;
    public static RtfControlWord Ctrl_PICCROPR;
    public static RtfControlWord Ctrl_PICCROPT;
    public static RtfControlWord Ctrl_PICH;
    public static RtfControlWord Ctrl_PICHGOAL;
    public static RtfControlWord Ctrl_PICPROP;
    public static RtfControlWord Ctrl_PICSCALED;
    public static RtfControlWord Ctrl_PICSCALEX;
    public static RtfControlWord Ctrl_PICSCALEY;
    public static RtfControlWord Ctrl_PICT;
    public static RtfControlWord Ctrl_PICW;
    public static RtfControlWord Ctrl_PICWGOAL;
    public static RtfControlWord Ctrl_PLAIN;
    public static RtfControlWord Ctrl_PMMETAFILE;
    public static RtfControlWord Ctrl_PN;
    public static RtfControlWord Ctrl_PNACROSS;
    public static RtfControlWord Ctrl_PNAIU;
    public static RtfControlWord Ctrl_PNAIUD;
    public static RtfControlWord Ctrl_PNAIUEO;
    public static RtfControlWord Ctrl_PNAIUEOD;
    public static RtfControlWord Ctrl_PNB;
    public static RtfControlWord Ctrl_PNBIDIA;
    public static RtfControlWord Ctrl_PNBIDIB;
    public static RtfControlWord Ctrl_PNCAPS;
    public static RtfControlWord Ctrl_PNCARD;
    public static RtfControlWord Ctrl_PNCF;
    public static RtfControlWord Ctrl_PNCHOSUNG;
    public static RtfControlWord Ctrl_PNCNUM;
    public static RtfControlWord Ctrl_PNDBNUM;
    public static RtfControlWord Ctrl_PNDBNUMD;
    public static RtfControlWord Ctrl_PNDBNUMK;
    public static RtfControlWord Ctrl_PNDBNUML;
    public static RtfControlWord Ctrl_PNDBNUMT;
    public static RtfControlWord Ctrl_PNDEC;
    public static RtfControlWord Ctrl_PNDECD;
    public static RtfControlWord Ctrl_PNF;
    public static RtfControlWord Ctrl_PNFS;
    public static RtfControlWord Ctrl_PNGANADA;
    public static RtfControlWord Ctrl_PNGBLIP;
    public static RtfControlWord Ctrl_PNGBNUM;
    public static RtfControlWord Ctrl_PNGBNUMD;
    public static RtfControlWord Ctrl_PNGBNUMK;
    public static RtfControlWord Ctrl_PNGBNUML;
    public static RtfControlWord Ctrl_PNHANG;
    public static RtfControlWord Ctrl_PNI;
    public static RtfControlWord Ctrl_PNINDENT;
    public static RtfControlWord Ctrl_PNIROHA;
    public static RtfControlWord Ctrl_PNIROHAD;
    public static RtfControlWord Ctrl_PNLCLTR;
    public static RtfControlWord Ctrl_PNLCRM;
    public static RtfControlWord Ctrl_PNLVL;
    public static RtfControlWord Ctrl_PNLVLBLT;
    public static RtfControlWord Ctrl_PNLVLBODY;
    public static RtfControlWord Ctrl_PNLVLCONT;
    public static RtfControlWord Ctrl_PNNUMONCE;
    public static RtfControlWord Ctrl_PNORD;
    public static RtfControlWord Ctrl_PNORDT;
    public static RtfControlWord Ctrl_PNPREV;
    public static RtfControlWord Ctrl_PNQC;
    public static RtfControlWord Ctrl_PNQL;
    public static RtfControlWord Ctrl_PNQR;
    public static RtfControlWord Ctrl_PNRAUTH;
    public static RtfControlWord Ctrl_PNRDATE;
    public static RtfControlWord Ctrl_PNRESTART;
    public static RtfControlWord Ctrl_PNRNFC;
    public static RtfControlWord Ctrl_PNRNOT;
    public static RtfControlWord Ctrl_PNRPNBR;
    public static RtfControlWord Ctrl_PNRRGB;
    public static RtfControlWord Ctrl_PNRSTART;
    public static RtfControlWord Ctrl_PNRSTOP;
    public static RtfControlWord Ctrl_PNRXST;
    public static RtfControlWord Ctrl_PNSCAPS;
    public static RtfControlWord Ctrl_PNSECLVL;
    public static RtfControlWord Ctrl_PNSP;
    public static RtfControlWord Ctrl_PNSTART;
    public static RtfControlWord Ctrl_PNSTRIKE;
    public static RtfControlWord Ctrl_PNTEXT;
    public static RtfControlWord Ctrl_PNTXTA;
    public static RtfControlWord Ctrl_PNTXTB;
    public static RtfControlWord Ctrl_PNUCLTR;
    public static RtfControlWord Ctrl_PNUCRM;
    public static RtfControlWord Ctrl_PNUL;
    public static RtfControlWord Ctrl_PNULD;
    public static RtfControlWord Ctrl_PNULDASH;
    public static RtfControlWord Ctrl_PNULDASHD;
    public static RtfControlWord Ctrl_PNULDASHDD;
    public static RtfControlWord Ctrl_PNULDB;
    public static RtfControlWord Ctrl_PNULHAIR;
    public static RtfControlWord Ctrl_PNULNONE;
    public static RtfControlWord Ctrl_PNULTH;
    public static RtfControlWord Ctrl_PNULW;
    public static RtfControlWord Ctrl_PNULWAVE;
    public static RtfControlWord Ctrl_PNZODIAC;
    public static RtfControlWord Ctrl_PNZODIACD;
    public static RtfControlWord Ctrl_PNZODIACL;
    public static RtfControlWord Ctrl_POSNEGX;
    public static RtfControlWord Ctrl_POSNEGY;
    public static RtfControlWord Ctrl_POSX;
    public static RtfControlWord Ctrl_POSXC;
    public static RtfControlWord Ctrl_POSXI;
    public static RtfControlWord Ctrl_POSXL;
    public static RtfControlWord Ctrl_POSXO;
    public static RtfControlWord Ctrl_POSXR;
    public static RtfControlWord Ctrl_POSY;
    public static RtfControlWord Ctrl_POSYB;
    public static RtfControlWord Ctrl_POSYC;
    public static RtfControlWord Ctrl_POSYIL;
    public static RtfControlWord Ctrl_POSYIN;
    public static RtfControlWord Ctrl_POSYOUT;
    public static RtfControlWord Ctrl_POSYT;
    public static RtfControlWord Ctrl_PRCOLBL;
    public static RtfControlWord Ctrl_PRINTDATA;
    public static RtfControlWord Ctrl_PRINTIM;
    public static RtfControlWord Ctrl_PRIVATE;
    public static RtfControlWord Ctrl_PROPNAME;
    public static RtfControlWord Ctrl_PROPTYPE;
    public static RtfControlWord Ctrl_PSOVER;
    public static RtfControlWord Ctrl_PSZ;
    public static RtfControlWord Ctrl_PUBAUTO;
    public static RtfControlWord Ctrl_PVMRG;
    public static RtfControlWord Ctrl_PVPARA;
    public static RtfControlWord Ctrl_PVPG;
    public static RtfControlWord Ctrl_PWD;
    public static RtfControlWord Ctrl_PXE;
    public static RtfControlWord Ctrl_QC;
    public static RtfControlWord Ctrl_QD;
    public static RtfControlWord Ctrl_QJ;
    public static RtfControlWord Ctrl_QL;
    public static RtfControlWord Ctrl_QMSPACE;
    public static RtfControlWord Ctrl_QR;
    public static RtfControlWord Ctrl_RDBLQUOTE;
    public static RtfControlWord Ctrl_RED;
    public static RtfControlWord Ctrl_RESULT;
    public static RtfControlWord Ctrl_REVAUTH;
    public static RtfControlWord Ctrl_REVAUTHDEL;
    public static RtfControlWord Ctrl_REVBAR;
    public static RtfControlWord Ctrl_REVDTTM;
    public static RtfControlWord Ctrl_REVDTTMDEL;
    public static RtfControlWord Ctrl_REVISED;
    public static RtfControlWord Ctrl_REVISIONS;
    public static RtfControlWord Ctrl_REVPROP;
    public static RtfControlWord Ctrl_REVPROT;
    public static RtfControlWord Ctrl_REVTBL;
    public static RtfControlWord Ctrl_REVTIM;
    public static RtfControlWord Ctrl_RI;
    public static RtfControlWord Ctrl_RIN;
    public static RtfControlWord Ctrl_ROW;
    public static RtfControlWord Ctrl_RQUOTE;
    public static RtfControlWord Ctrl_RSLTBMP;
    public static RtfControlWord Ctrl_RSLTHTML;
    public static RtfControlWord Ctrl_RSLTMERGE;
    public static RtfControlWord Ctrl_RSLTPICT;
    public static RtfControlWord Ctrl_RSLTRTF;
    public static RtfControlWord Ctrl_RSLTTXT;
    public static RtfControlWord Ctrl_RTF;
    public static RtfControlWord Ctrl_RTLCH;
    public static RtfControlWord Ctrl_RTLDOC;
    public static RtfControlWord Ctrl_RTLGUTTER;
    public static RtfControlWord Ctrl_RTLMARK;
    public static RtfControlWord Ctrl_RTLPAR;
    public static RtfControlWord Ctrl_RTLROW;
    public static RtfControlWord Ctrl_RTLSECT;
    public static RtfControlWord Ctrl_RXE;
    public static RtfControlWord Ctrl_S;
    public static RtfControlWord Ctrl_SA;
    public static RtfControlWord Ctrl_SAAUTO;
    public static RtfControlWord Ctrl_SAUTOUPD;
    public static RtfControlWord Ctrl_SB;
    public static RtfControlWord Ctrl_SBASEDON;
    public static RtfControlWord Ctrl_SBAUTO;
    public static RtfControlWord Ctrl_SBKCOL;
    public static RtfControlWord Ctrl_SBKEVEN;
    public static RtfControlWord Ctrl_SBKNONE;
    public static RtfControlWord Ctrl_SBKODD;
    public static RtfControlWord Ctrl_SBKPAGE;
    public static RtfControlWord Ctrl_SBYS;
    public static RtfControlWord Ctrl_SCAPS;
    public static RtfControlWord Ctrl_SCOMPOSE;
    public static RtfControlWord Ctrl_SEC;
    public static RtfControlWord Ctrl_SECT;
    public static RtfControlWord Ctrl_SECTD;
    public static RtfControlWord Ctrl_SECTDEFAULTCL;
    public static RtfControlWord Ctrl_SECTEXPAND;
    public static RtfControlWord Ctrl_SECTLINEGRID;
    public static RtfControlWord Ctrl_SECTNUM;
    public static RtfControlWord Ctrl_SECTSPECIFYCL;
    public static RtfControlWord Ctrl_SECTSPECIFYGEN;
    public static RtfControlWord Ctrl_SECTSPECIFYL;
    public static RtfControlWord Ctrl_SECTUNLOCKED;
    public static RtfControlWord Ctrl_SHAD;
    public static RtfControlWord Ctrl_SHADING;
    public static RtfControlWord Ctrl_SHIDDEN;
    public static RtfControlWord Ctrl_SHIFT;
    public static RtfControlWord Ctrl_SHPBOTTOM;
    public static RtfControlWord Ctrl_SHPBXCOLUMN;
    public static RtfControlWord Ctrl_SHPBXIGNORE;
    public static RtfControlWord Ctrl_SHPBXMARGIN;
    public static RtfControlWord Ctrl_SHPBXPAGE;
    public static RtfControlWord Ctrl_SHPBYIGNORE;
    public static RtfControlWord Ctrl_SHPBYMARGIN;
    public static RtfControlWord Ctrl_SHPBYPAGE;
    public static RtfControlWord Ctrl_SHPBYPARA;
    public static RtfControlWord Ctrl_SHPFBLWTXT;
    public static RtfControlWord Ctrl_SHPFHDR;
    public static RtfControlWord Ctrl_SHPGRP;
    public static RtfControlWord Ctrl_SHPINST;
    public static RtfControlWord Ctrl_SHPLEFT;
    public static RtfControlWord Ctrl_SHPLID;
    public static RtfControlWord Ctrl_SHPLOCKANCHOR;
    public static RtfControlWord Ctrl_SHPPICT;
    public static RtfControlWord Ctrl_SHPRIGHT;
    public static RtfControlWord Ctrl_SHPRSLT;
    public static RtfControlWord Ctrl_SHPTOP;
    public static RtfControlWord Ctrl_SHPTXT;
    public static RtfControlWord Ctrl_SHPWRK;
    public static RtfControlWord Ctrl_SHPWR;
    public static RtfControlWord Ctrl_SHPZ;
    public static RtfControlWord Ctrl_SL;
    public static RtfControlWord Ctrl_SLMULT;
    public static RtfControlWord Ctrl_SNEXT;
    public static RtfControlWord Ctrl_SOFTCOL;
    public static RtfControlWord Ctrl_SOFTLHEIGHT;
    public static RtfControlWord Ctrl_SOFTLINE;
    public static RtfControlWord Ctrl_SOFTPAGE;
    public static RtfControlWord Ctrl_SPERSONAL;
    public static RtfControlWord Ctrl_SPLYTWNINE;
    public static RtfControlWord Ctrl_SPRSBSP;
    public static RtfControlWord Ctrl_SPRSLNSP;
    public static RtfControlWord Ctrl_SPRSSPBF;
    public static RtfControlWord Ctrl_SPRSTSM;
    public static RtfControlWord Ctrl_SPRSTSP;
    public static RtfControlWord Ctrl_SREPLY;
    public static RtfControlWord Ctrl_STATICVAL;
    public static RtfControlWord Ctrl_STEXTFLOW;
    public static RtfControlWord Ctrl_STRIKE;
    public static RtfControlWord Ctrl_STRIKED;
    public static RtfControlWord Ctrl_STYLESHEET;
    public static RtfControlWord Ctrl_SUB;
    public static RtfControlWord Ctrl_SUBDOCUMENT;
    public static RtfControlWord Ctrl_SUBFONTBYSIZE;
    public static RtfControlWord Ctrl_SUBJECT;
    public static RtfControlWord Ctrl_SUPER;
    public static RtfControlWord Ctrl_SWPBDR;
    public static RtfControlWord Ctrl_TAB;
    public static RtfControlWord Ctrl_TABSNOOVRLP;
    public static RtfControlWord Ctrl_TAPRTL;
    public static RtfControlWord Ctrl_TB;
    public static RtfControlWord Ctrl_TC;
    public static RtfControlWord Ctrl_TCELLD;
    public static RtfControlWord Ctrl_TCF;
    public static RtfControlWord Ctrl_TCL;
    public static RtfControlWord Ctrl_TCN;
    public static RtfControlWord Ctrl_TDFRMTXTBOTTOM;
    public static RtfControlWord Ctrl_TDFRMTXTLEFT;
    public static RtfControlWord Ctrl_TDFRMTXTRIGHT;
    public static RtfControlWord Ctrl_TDFRMTXTTOP;
    public static RtfControlWord Ctrl_TEMPLATE;
    public static RtfControlWord Ctrl_TIME;
    public static RtfControlWord Ctrl_TITLE;
    public static RtfControlWord Ctrl_TITLEPG;
    public static RtfControlWord Ctrl_TLDOT;
    public static RtfControlWord Ctrl_TLEQ;
    public static RtfControlWord Ctrl_TLHYPH;
    public static RtfControlWord Ctrl_TLMDOT;
    public static RtfControlWord Ctrl_TLTH;
    public static RtfControlWord Ctrl_TLUL;
    public static RtfControlWord Ctrl_TPHCOL;
    public static RtfControlWord Ctrl_TPHMRG;
    public static RtfControlWord Ctrl_TPHPG;
    public static RtfControlWord Ctrl_TPOSNEGX;
    public static RtfControlWord Ctrl_TPOSNEGY;
    public static RtfControlWord Ctrl_TPOSXC;
    public static RtfControlWord Ctrl_TPOSXI;
    public static RtfControlWord Ctrl_TPOSXL;
    public static RtfControlWord Ctrl_TPOSX;
    public static RtfControlWord Ctrl_TPOSXO;
    public static RtfControlWord Ctrl_TPOSXR;
    public static RtfControlWord Ctrl_TPOSY;
    public static RtfControlWord Ctrl_TPOSYB;
    public static RtfControlWord Ctrl_TPOSYC;
    public static RtfControlWord Ctrl_TPOSYIL;
    public static RtfControlWord Ctrl_TPOSYIN;
    public static RtfControlWord Ctrl_TPOSYOUTV;
    public static RtfControlWord Ctrl_TPOSYT;
    public static RtfControlWord Ctrl_TPVMRG;
    public static RtfControlWord Ctrl_TPVPARA;
    public static RtfControlWord Ctrl_TPVPG;
    public static RtfControlWord Ctrl_TQC;
    public static RtfControlWord Ctrl_TQDEC;
    public static RtfControlWord Ctrl_TQR;
    public static RtfControlWord Ctrl_TRANSMF;
    public static RtfControlWord Ctrl_TRAUTOFIT;
    public static RtfControlWord Ctrl_TRBRDRB;
    public static RtfControlWord Ctrl_TRBRDRH;
    public static RtfControlWord Ctrl_TRBRDRL;
    public static RtfControlWord Ctrl_TRBRDRR;
    public static RtfControlWord Ctrl_TRBRDRT;
    public static RtfControlWord Ctrl_TRBRDRV;
    public static RtfControlWord Ctrl_TRFTSWIDTHA;
    public static RtfControlWord Ctrl_TRFTSWIDTHB;
    public static RtfControlWord Ctrl_TRFTSWIDTH;
    public static RtfControlWord Ctrl_TRGAPH;
    public static RtfControlWord Ctrl_TRHDR;
    public static RtfControlWord Ctrl_TRKEEP;
    public static RtfControlWord Ctrl_TRLEFT;
    public static RtfControlWord Ctrl_TROWD;
    public static RtfControlWord Ctrl_TRPADDB;
    public static RtfControlWord Ctrl_TRPADDFB;
    public static RtfControlWord Ctrl_TRPADDFL;
    public static RtfControlWord Ctrl_TRPADDFR;
    public static RtfControlWord Ctrl_TRPADDFT;
    public static RtfControlWord Ctrl_TRPADDL;
    public static RtfControlWord Ctrl_TRPADDR;
    public static RtfControlWord Ctrl_TRPADDT;
    public static RtfControlWord Ctrl_TRQC;
    public static RtfControlWord Ctrl_TRQL;
    public static RtfControlWord Ctrl_TRQR;
    public static RtfControlWord Ctrl_TRRH;
    public static RtfControlWord Ctrl_TRSPDB;
    public static RtfControlWord Ctrl_TRSPDFB;
    public static RtfControlWord Ctrl_TRSPDFL;
    public static RtfControlWord Ctrl_TRSPDFR;
    public static RtfControlWord Ctrl_TRSPDFT;
    public static RtfControlWord Ctrl_TRSPDL;
    public static RtfControlWord Ctrl_TRSPDR;
    public static RtfControlWord Ctrl_TRSPDT;
    public static RtfControlWord Ctrl_TRUNCATEFONTHEIGHT;
    public static RtfControlWord Ctrl_TRWWIDTHA;
    public static RtfControlWord Ctrl_TRWWIDTHB;
    public static RtfControlWord Ctrl_TRWWIDTH;
    public static RtfControlWord Ctrl_TWOONONE;
    public static RtfControlWord Ctrl_TX;
    public static RtfControlWord Ctrl_TXE;
    public static RtfControlWord Ctrl_UC;
    public static RtfControlWord Ctrl_UD;
    public static RtfControlWord Ctrl_UL;
    public static RtfControlWord Ctrl_ULC;
    public static RtfControlWord Ctrl_ULD;
    public static RtfControlWord Ctrl_ULDASH;
    public static RtfControlWord Ctrl_ULDASHD;
    public static RtfControlWord Ctrl_ULDASHDD;
    public static RtfControlWord Ctrl_ULDB;
    public static RtfControlWord Ctrl_ULHAIR;
    public static RtfControlWord Ctrl_ULHWAVE;
    public static RtfControlWord Ctrl_ULLDASH;
    public static RtfControlWord Ctrl_ULNONE;
    public static RtfControlWord Ctrl_ULTH;
    public static RtfControlWord Ctrl_ULTHD;
    public static RtfControlWord Ctrl_ULTHDASH;
    public static RtfControlWord Ctrl_ULTHDASHD;
    public static RtfControlWord Ctrl_ULTHDASHDD;
    public static RtfControlWord Ctrl_ULTHLDASH;
    public static RtfControlWord Ctrl_ULULDBWAVE;
    public static RtfControlWord Ctrl_ULW;
    public static RtfControlWord Ctrl_ULWAVE;
    public static RtfControlWord Ctrl_U;
    public static RtfControlWord Ctrl_UP;
    public static RtfControlWord Ctrl_UPR;
    public static RtfControlWord Ctrl_URTF;
    public static RtfControlWord Ctrl_USELTBALN;
    public static RtfControlWord Ctrl_USERPROPS;
    public static RtfControlWord Ctrl_V;
    public static RtfControlWord Ctrl_VERN;
    public static RtfControlWord Ctrl_VERSION;
    public static RtfControlWord Ctrl_VERTALB;
    public static RtfControlWord Ctrl_VERTALC;
    public static RtfControlWord Ctrl_VERTALJ;
    public static RtfControlWord Ctrl_VERTALT;
    public static RtfControlWord Ctrl_VERTDOC;
    public static RtfControlWord Ctrl_VERTSECT;
    public static RtfControlWord Ctrl_VIEWKIND;
    public static RtfControlWord Ctrl_VIEWSCALE;
    public static RtfControlWord Ctrl_VIEWZK;
    public static RtfControlWord Ctrl_WBITMAP;
    public static RtfControlWord Ctrl_WBMBITSPIXEL;
    public static RtfControlWord Ctrl_WBMPLANES;
    public static RtfControlWord Ctrl_WBMWIDTHBYTES;
    public static RtfControlWord Ctrl_WEBHIDDEN;
    public static RtfControlWord Ctrl_WIDCTLPAR;
    public static RtfControlWord Ctrl_WIDOWCTRL;
    public static RtfControlWord Ctrl_WINDOWCAPTION;
    public static RtfControlWord Ctrl_WMETAFILE;
    public static RtfControlWord Ctrl_WPEQN;
    public static RtfControlWord Ctrl_WPJST;
    public static RtfControlWord Ctrl_WPSP;
    public static RtfControlWord Ctrl_WRAPTRSP;
    public static RtfControlWord Ctrl_XE;
    public static RtfControlWord Ctrl_XEF;
    public static RtfControlWord Ctrl_YR;
    public static RtfControlWord Ctrl_YXE;
    public static RtfControlWord Ctrl_ZWBO;
    public static RtfControlWord Ctrl_ZWJ;
    public static RtfControlWord Ctrl_ZWNBO;
    public static RtfControlWord Ctrl_ZWNJ;
}
internal class System.Windows.Documents.RtfControlWordInfo : object {
    internal RtfControlWord Control { get; }
    internal string ControlName { get; }
    internal UInt32 Flags { get; }
    internal RtfControlWordInfo(RtfControlWord controlWord, string controlName, UInt32 flags);
    internal RtfControlWord get_Control();
    internal string get_ControlName();
    internal UInt32 get_Flags();
}
internal enum System.Windows.Documents.RtfDestination : Enum {
    public int value__;
    public static RtfDestination DestNormal;
    public static RtfDestination DestColorTable;
    public static RtfDestination DestFontTable;
    public static RtfDestination DestFontName;
    public static RtfDestination DestListTable;
    public static RtfDestination DestListOverrideTable;
    public static RtfDestination DestList;
    public static RtfDestination DestListLevel;
    public static RtfDestination DestListOverride;
    public static RtfDestination DestListPicture;
    public static RtfDestination DestListText;
    public static RtfDestination DestUPR;
    public static RtfDestination DestField;
    public static RtfDestination DestFieldInstruction;
    public static RtfDestination DestFieldResult;
    public static RtfDestination DestFieldPrivate;
    public static RtfDestination DestShape;
    public static RtfDestination DestShapeInstruction;
    public static RtfDestination DestShapeResult;
    public static RtfDestination DestShapePicture;
    public static RtfDestination DestNoneShapePicture;
    public static RtfDestination DestPicture;
    public static RtfDestination DestPN;
    public static RtfDestination DestUnknown;
}
internal class System.Windows.Documents.RtfFormatStack : ArrayList {
    internal void Push();
    internal void Pop();
    internal FormatState Top();
    internal FormatState PrevTop(int fromTop);
    internal FormatState EntryAt(int index);
}
internal enum System.Windows.Documents.RtfImageFormat : Enum {
    public int value__;
    public static RtfImageFormat Unknown;
    public static RtfImageFormat Bmp;
    public static RtfImageFormat Dib;
    public static RtfImageFormat Emf;
    public static RtfImageFormat Exif;
    public static RtfImageFormat Gif;
    public static RtfImageFormat Jpeg;
    public static RtfImageFormat Png;
    public static RtfImageFormat Tif;
    public static RtfImageFormat Wmf;
}
internal enum System.Windows.Documents.RtfSuperSubscript : Enum {
    public int value__;
    public static RtfSuperSubscript None;
    public static RtfSuperSubscript Normal;
    public static RtfSuperSubscript Super;
    public static RtfSuperSubscript Sub;
}
internal class System.Windows.Documents.RtfToken : object {
    internal static long INVALID_PARAMETER;
    internal RtfTokenType Type { get; internal set; }
    internal RtfControlWordInfo RtfControlWordInfo { get; internal set; }
    internal long Parameter { get; internal set; }
    internal string Text { get; internal set; }
    internal long ToggleValue { get; }
    internal bool FlagValue { get; }
    internal bool HasParameter { get; }
    internal void Empty();
    internal RtfTokenType get_Type();
    internal void set_Type(RtfTokenType value);
    internal RtfControlWordInfo get_RtfControlWordInfo();
    internal void set_RtfControlWordInfo(RtfControlWordInfo value);
    internal long get_Parameter();
    internal void set_Parameter(long value);
    internal string get_Text();
    internal void set_Text(string value);
    internal long get_ToggleValue();
    internal bool get_FlagValue();
    internal bool get_HasParameter();
}
internal enum System.Windows.Documents.RtfTokenType : Enum {
    public int value__;
    public static RtfTokenType TokenInvalid;
    public static RtfTokenType TokenEOF;
    public static RtfTokenType TokenText;
    public static RtfTokenType TokenTextSymbol;
    public static RtfTokenType TokenPictureData;
    public static RtfTokenType TokenNewline;
    public static RtfTokenType TokenNullChar;
    public static RtfTokenType TokenControl;
    public static RtfTokenType TokenDestination;
    public static RtfTokenType TokenHex;
    public static RtfTokenType TokenGroupStart;
    public static RtfTokenType TokenGroupEnd;
}
internal enum System.Windows.Documents.RtfToXamlError : Enum {
    public int value__;
    public static RtfToXamlError None;
    public static RtfToXamlError InvalidFormat;
    public static RtfToXamlError InvalidParameter;
    public static RtfToXamlError InsufficientMemory;
    public static RtfToXamlError OutOfRange;
}
internal class System.Windows.Documents.RtfToXamlLexer : object {
    unknown int CodePage {internal set; }
    internal Encoding CurrentEncoding { get; }
    internal byte CurByte { get; }
    internal RtfToXamlLexer(Byte[] rtfBytes);
    private static RtfToXamlLexer();
    internal RtfToXamlError Next(RtfToken token, FormatState formatState);
    internal RtfToXamlError AdvanceForUnicode(long nSkip);
    internal void AdvanceForBinary(int skip);
    internal void AdvanceForImageData();
    internal void WriteImageData(Stream imageStream, bool isBinary);
    internal void set_CodePage(int value);
    internal Encoding get_CurrentEncoding();
    internal byte get_CurByte();
}
internal class System.Windows.Documents.RtfToXamlReader : object {
    internal string Output { get; }
    internal bool ForceParagraph { get; internal set; }
    internal ConverterState ConverterState { get; }
    unknown WpfPayload WpfPayload {internal set; }
    internal RtfToXamlReader(string rtfString);
    internal RtfToXamlError Process();
    internal string get_Output();
    internal bool get_ForceParagraph();
    internal void set_ForceParagraph(bool value);
    internal ConverterState get_ConverterState();
    internal void set_WpfPayload(WpfPayload value);
    internal bool TreeContainsBlock();
    internal void AppendDocument();
    internal void ProcessField();
    internal DocumentNode ProcessHyperlinkField(string instr);
    internal DocumentNode ProcessSymbolField(string instr);
    internal void ProcessImage(FormatState formatState);
    internal void ProcessListText();
    internal void ProcessShapeResult();
    internal void ProcessGroupEnd();
    internal void SelectFont(long nFont);
    internal void HandleControl(RtfToken token, RtfControlWordInfo controlWordInfo);
    internal void ProcessText(RtfToken token);
    internal void ProcessTextSymbol(RtfToken token);
    internal void HandleBinControl(RtfToken token, FormatState formatState);
    internal void HandlePara(RtfToken token, FormatState formatState);
    internal void WrapPendingInlineInParagraph(RtfToken token, FormatState formatState);
    internal void HandlePage(RtfToken token, FormatState formatState);
    internal void HandleParagraphFromText(FormatState formatState);
    internal void WrapInlineInParagraph(int nInsertAt, int nChildren);
    internal void ProcessPendingTextAtRowEnd();
    internal void HandleTableTokens(RtfToken token, FormatState formatState);
    internal ListOverride GetControllingListOverride();
    internal ListLevelTable GetControllingLevelTable();
    internal void HandleListTokens(RtfToken token, FormatState formatState);
    internal void HandleShapeTokens(RtfToken token, FormatState formatState);
    internal void HandleOldListTokens(RtfToken token, FormatState formatState);
    internal void HandleTableProperties(RtfToken token, FormatState formatState);
    internal void HandleFieldTokens(RtfToken token, FormatState formatState);
    internal void HandleTableNesting(FormatState formatState);
    internal MarkerList GetMarkerStylesOfParagraph(MarkerList mlHave, FormatState fs, bool bMarkerPresent);
    internal void HandleListNesting(FormatState formatState);
    internal void HandleCodePageTokens(RtfToken token, FormatState formatState);
    internal void ProcessFieldText(RtfToken token);
    internal void ProcessFontTableText(RtfToken token);
    internal void HandleFontTableTokens(RtfToken token);
    internal void ProcessColorTableText(RtfToken token);
    internal void ProcessText(string text);
    internal void HandleNormalText(string text, FormatState formatState);
    internal void HandleNormalTextRaw(string text, FormatState formatState);
    internal void ProcessNormalHardLine(FormatState formatState);
    internal void ProcessHardLine(RtfToken token, FormatState formatState);
}
internal class System.Windows.Documents.RubberbandSelector : object {
    internal FixedPage Page { get; }
    internal Rect SelectionRect { get; }
    internal bool HasSelection { get; }
    internal void ClearSelection();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void AttachRubberbandSelector(FrameworkElement scope);
    internal void DetachRubberbandSelector();
    internal FixedPage get_Page();
    internal Rect get_SelectionRect();
    internal bool get_HasSelection();
}
[ContentPropertyAttribute("Text")]
public class System.Windows.Documents.Run : Inline {
    public static DependencyProperty TextProperty;
    public string Text { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Run(string text);
    public Run(string text, TextPointer insertionPosition);
    private static Run();
    public string get_Text();
    public void set_Text(string value);
    internal virtual void OnTextUpdated();
    internal virtual void BeforeLogicalTreeChange();
    internal virtual void AfterLogicalTreeChange();
    internal virtual int get_EffectiveValuesInitialSize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText(XamlDesignerSerializationManager manager);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.Section : Block {
    internal static string HasTrailingParagraphBreakOnPastePropertyName;
    [DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("True")]
public bool HasTrailingParagraphBreakOnPaste { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public Section(Block block);
    public bool get_HasTrailingParagraphBreakOnPaste();
    public void set_HasTrailingParagraphBreakOnPaste(bool value);
    public BlockCollection get_Blocks();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
}
internal static class System.Windows.Documents.SelectionHighlightInfo : object {
    internal static Brush ForegroundBrush { get; }
    internal static Brush BackgroundBrush { get; }
    internal static Brush ObjectMaskBrush { get; }
    private static SelectionHighlightInfo();
    internal static Brush get_ForegroundBrush();
    internal static Brush get_BackgroundBrush();
    internal static Brush get_ObjectMaskBrush();
}
internal static class System.Windows.Documents.SelectionWordBreaker : object {
    internal static int MinContextLength { get; }
    private static SelectionWordBreaker();
    internal static bool IsAtWordBoundary(Char[] text, int position, LogicalDirection insideWordDirection);
    internal static int get_MinContextLength();
}
public interface System.Windows.Documents.Serialization.ISerializerFactory {
    public string DisplayName { get; }
    public string ManufacturerName { get; }
    public Uri ManufacturerWebsite { get; }
    public string DefaultFileExtension { get; }
    public abstract virtual SerializerWriter CreateSerializerWriter(Stream stream);
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_ManufacturerName();
    public abstract virtual Uri get_ManufacturerWebsite();
    public abstract virtual string get_DefaultFileExtension();
}
public class System.Windows.Documents.Serialization.SerializerDescriptor : object {
    public string DisplayName { get; }
    public string ManufacturerName { get; }
    public Uri ManufacturerWebsite { get; }
    public string DefaultFileExtension { get; }
    public string AssemblyName { get; }
    public string AssemblyPath { get; }
    public string FactoryInterfaceName { get; }
    public Version AssemblyVersion { get; }
    public Version WinFXVersion { get; }
    public bool IsLoadable { get; }
    [SecuritySafeCriticalAttribute]
public static SerializerDescriptor CreateFromFactoryInstance(ISerializerFactory factoryInstance);
    [SecuritySafeCriticalAttribute]
internal ISerializerFactory CreateSerializerFactory();
    internal void WriteToRegistryKey(RegistryKey key);
    [SecuritySafeCriticalAttribute]
internal static SerializerDescriptor CreateFromRegistry(RegistryKey plugIns, string keyName);
    public string get_DisplayName();
    public string get_ManufacturerName();
    public Uri get_ManufacturerWebsite();
    public string get_DefaultFileExtension();
    public string get_AssemblyName();
    public string get_AssemblyPath();
    public string get_FactoryInterfaceName();
    public Version get_AssemblyVersion();
    public Version get_WinFXVersion();
    public bool get_IsLoadable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Documents.Serialization.SerializerProvider : object {
    public ReadOnlyCollection`1<SerializerDescriptor> InstalledSerializers { get; }
    private static SerializerProvider();
    [SecuritySafeCriticalAttribute]
public static void RegisterSerializer(SerializerDescriptor serializerDescriptor, bool overwrite);
    [SecuritySafeCriticalAttribute]
public static void UnregisterSerializer(SerializerDescriptor serializerDescriptor);
    [SecuritySafeCriticalAttribute]
public SerializerWriter CreateSerializerWriter(SerializerDescriptor serializerDescriptor, Stream stream);
    public ReadOnlyCollection`1<SerializerDescriptor> get_InstalledSerializers();
}
public abstract class System.Windows.Documents.Serialization.SerializerWriter : object {
    public abstract virtual void Write(Visual visual);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual);
    public abstract virtual void WriteAsync(Visual visual, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket, object userState);
    public abstract virtual void Write(DocumentPaginator documentPaginator);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(DocumentPaginator documentPaginator, PrintTicket printTicket);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, PrintTicket printTicket);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedPage fixedPage);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(FixedPage fixedPage, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedPage fixedPage);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedPage fixedPage, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedPage fixedPage, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedPage fixedPage, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedDocument fixedDocument);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(FixedDocument fixedDocument, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedDocument fixedDocument, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedDocument fixedDocument, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedDocumentSequence fixedDocumentSequence);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket, object userState);
    public abstract virtual void CancelAsync();
    public abstract virtual SerializerWriterCollator CreateVisualsCollator();
    [SecuritySafeCriticalAttribute]
public abstract virtual SerializerWriterCollator CreateVisualsCollator(PrintTicket documentSequencePT, PrintTicket documentPT);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingPrintTicketRequired(WritingPrintTicketRequiredEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingPrintTicketRequired(WritingPrintTicketRequiredEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingProgressChanged(WritingProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingProgressChanged(WritingProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingCompleted(WritingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingCompleted(WritingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingCancelled(WritingCancelledEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingCancelled(WritingCancelledEventHandler value);
}
public abstract class System.Windows.Documents.Serialization.SerializerWriterCollator : object {
    public abstract virtual void BeginBatchWrite();
    public abstract virtual void EndBatchWrite();
    public abstract virtual void Write(Visual visual);
    [SecuritySafeCriticalAttribute]
public abstract virtual void Write(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual);
    public abstract virtual void WriteAsync(Visual visual, object userState);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket);
    [SecuritySafeCriticalAttribute]
public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket, object userState);
    public abstract virtual void CancelAsync();
    public abstract virtual void Cancel();
}
public class System.Windows.Documents.Serialization.WritingCancelledEventArgs : EventArgs {
    public Exception Error { get; }
    public WritingCancelledEventArgs(Exception exception);
    public Exception get_Error();
}
public class System.Windows.Documents.Serialization.WritingCancelledEventHandler : MulticastDelegate {
    public WritingCancelledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingCancelledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingCancelledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingCompletedEventArgs : AsyncCompletedEventArgs {
    public WritingCompletedEventArgs(bool cancelled, object state, Exception exception);
}
public class System.Windows.Documents.Serialization.WritingCompletedEventHandler : MulticastDelegate {
    public WritingCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingPrintTicketRequiredEventArgs : EventArgs {
    public PrintTicketLevel CurrentPrintTicketLevel { get; }
    public int Sequence { get; }
    public PrintTicket CurrentPrintTicket { get; public set; }
    [SecuritySafeCriticalAttribute]
public WritingPrintTicketRequiredEventArgs(PrintTicketLevel printTicketLevel, int sequence);
    [SecuritySafeCriticalAttribute]
public PrintTicketLevel get_CurrentPrintTicketLevel();
    public int get_Sequence();
    [SecuritySafeCriticalAttribute]
public void set_CurrentPrintTicket(PrintTicket value);
    [SecuritySafeCriticalAttribute]
public PrintTicket get_CurrentPrintTicket();
}
public class System.Windows.Documents.Serialization.WritingPrintTicketRequiredEventHandler : MulticastDelegate {
    public WritingPrintTicketRequiredEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingPrintTicketRequiredEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingPrintTicketRequiredEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingProgressChangedEventArgs : ProgressChangedEventArgs {
    public int Number { get; }
    public WritingProgressChangeLevel WritingLevel { get; }
    public WritingProgressChangedEventArgs(WritingProgressChangeLevel writingLevel, int number, int progressPercentage, object state);
    public int get_Number();
    public WritingProgressChangeLevel get_WritingLevel();
}
public class System.Windows.Documents.Serialization.WritingProgressChangedEventHandler : MulticastDelegate {
    public WritingProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Documents.Serialization.WritingProgressChangeLevel : Enum {
    public int value__;
    public static WritingProgressChangeLevel None;
    public static WritingProgressChangeLevel FixedDocumentSequenceWritingProgress;
    public static WritingProgressChangeLevel FixedDocumentWritingProgress;
    public static WritingProgressChangeLevel FixedPageWritingProgress;
}
[ContentPropertyAttribute("Inlines")]
public class System.Windows.Documents.Span : Inline {
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public Span(Inline childInline);
    public Span(Inline childInline, TextPointer insertionPosition);
    public Span(TextPointer start, TextPointer end);
    public InlineCollection get_Inlines();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
}
internal class System.Windows.Documents.Speller : object {
    internal SpellerStatusTable StatusTable { get; }
    internal Speller(TextEditor textEditor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Detach();
    internal SpellingError GetError(ITextPointer position, LogicalDirection direction, bool forceEvaluation);
    internal ITextPointer GetNextSpellingErrorPosition(ITextPointer position, LogicalDirection direction);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal IList GetSuggestionsForError(SpellingError error);
    internal void IgnoreAll(string word);
    internal void SetSpellingReform(SpellingReform spellingReform);
    internal void SetCustomDictionaries(CustomDictionarySources dictionaryLocations, bool add);
    internal void ResetErrors();
    internal static bool IsSpellerAffectingProperty(DependencyProperty property);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDictionaryUriAdded(Uri uri);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDictionaryUriRemoved(Uri uri);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDictionaryUriCollectionCleared();
    internal SpellerStatusTable get_StatusTable();
}
internal class System.Windows.Documents.SpellerHighlightLayer : HighlightLayer {
    internal Type OwnerType { get; }
    private static SpellerHighlightLayer();
    internal SpellerHighlightLayer(Speller speller);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void FireChangedEvent(ITextPointer start, ITextPointer end);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal abstract class System.Windows.Documents.SpellerInteropBase : object {
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    public abstract virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public static SpellerInteropBase CreateInstance();
    [SecurityCriticalAttribute]
internal abstract virtual void SetLocale(CultureInfo culture);
    [SecurityCriticalAttribute]
internal abstract virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
    [SecurityCriticalAttribute]
internal abstract virtual void UnloadDictionary(object dictionary);
    [SecurityCriticalAttribute]
internal abstract virtual object LoadDictionary(string lexiconFilePath);
    [SecurityCriticalAttribute]
internal abstract virtual object LoadDictionary(Uri item, string trustedFolder);
    [SecurityCriticalAttribute]
internal abstract virtual void ReleaseAllLexicons();
    [SecuritySafeCriticalAttribute]
internal abstract virtual void set_Mode(SpellerMode value);
    [SecurityCriticalAttribute]
internal abstract virtual void set_MultiWordMode(bool value);
    [SecurityCriticalAttribute]
internal abstract virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal abstract virtual bool CanSpellCheck(CultureInfo culture);
}
internal class System.Windows.Documents.SpellerStatusTable : object {
    internal SpellerStatusTable(ITextPointer textContainerStart, SpellerHighlightLayer highlightLayer);
    internal void OnTextChange(TextContainerChangeEventArgs e);
    internal void GetFirstDirtyRange(ITextPointer searchStart, ITextPointer& start, ITextPointer& end);
    internal void MarkCleanRange(ITextPointer start, ITextPointer end);
    internal void MarkDirtyRange(ITextPointer start, ITextPointer end);
    internal void MarkErrorRange(ITextPointer start, ITextPointer end);
    internal bool IsRunType(StaticTextPointer textPosition, LogicalDirection direction, RunType runType);
    internal StaticTextPointer GetNextErrorTransition(StaticTextPointer textPosition, LogicalDirection direction);
    internal bool GetError(StaticTextPointer textPosition, LogicalDirection direction, ITextPointer& start, ITextPointer& end);
    internal bool GetRun(StaticTextPointer position, LogicalDirection direction, RunType& runType, StaticTextPointer& end);
}
internal abstract class System.Windows.Documents.SplayTreeNode : object {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal SplayTreeNodeRole Role { get; }
    internal SplayTreeNode GetSiblingAtOffset(int offset, Int32& nodeOffset);
    internal SplayTreeNode GetSiblingAtCharOffset(int charOffset, Int32& nodeCharOffset);
    internal SplayTreeNode GetFirstContainedNode();
    internal SplayTreeNode GetLastContainedNode();
    internal SplayTreeNode GetContainingNode();
    internal SplayTreeNode GetPreviousNode();
    internal SplayTreeNode GetNextNode();
    internal int GetSymbolOffset(UInt32 treeGeneration);
    internal int GetIMECharOffset();
    internal void InsertAtNode(SplayTreeNode positionNode, ElementEdge edge);
    internal void InsertAtNode(SplayTreeNode location, bool insertBefore);
    internal void Remove();
    internal static void Join(SplayTreeNode root, SplayTreeNode leftSubTree, SplayTreeNode rightSubTree);
    internal static SplayTreeNode Join(SplayTreeNode leftSubTree, SplayTreeNode rightSubTree);
    internal SplayTreeNode Split();
    internal SplayTreeNode GetMinSibling();
    internal SplayTreeNode GetMaxSibling();
    internal void Splay();
    internal bool IsChildOfNode(SplayTreeNode parentNode);
    internal abstract virtual SplayTreeNode get_ParentNode();
    internal abstract virtual void set_ParentNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_ContainedNode();
    internal abstract virtual void set_ContainedNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_LeftChildNode();
    internal abstract virtual void set_LeftChildNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_RightChildNode();
    internal abstract virtual void set_RightChildNode(SplayTreeNode value);
    internal abstract virtual int get_SymbolCount();
    internal abstract virtual void set_SymbolCount(int value);
    internal abstract virtual int get_IMECharCount();
    internal abstract virtual void set_IMECharCount(int value);
    internal abstract virtual int get_LeftSymbolCount();
    internal abstract virtual void set_LeftSymbolCount(int value);
    internal abstract virtual int get_LeftCharCount();
    internal abstract virtual void set_LeftCharCount(int value);
    internal abstract virtual UInt32 get_Generation();
    internal abstract virtual void set_Generation(UInt32 value);
    internal abstract virtual int get_SymbolOffsetCache();
    internal abstract virtual void set_SymbolOffsetCache(int value);
    internal SplayTreeNodeRole get_Role();
}
internal enum System.Windows.Documents.SplayTreeNodeRole : Enum {
    public int value__;
    public static SplayTreeNodeRole LocalRoot;
    public static SplayTreeNodeRole LeftChild;
    public static SplayTreeNodeRole RightChild;
}
internal class System.Windows.Documents.StaticTextPointer : ValueType {
    internal static StaticTextPointer Null;
    private ITextContainer _textContainer;
    private UInt32 _generation;
    private object _handle0;
    private int _handle1;
    internal ITextContainer TextContainer { get; }
    internal DependencyObject Parent { get; }
    internal bool IsNull { get; }
    internal object Handle0 { get; }
    internal int Handle1 { get; }
    internal StaticTextPointer(ITextContainer textContainer, object handle0);
    internal StaticTextPointer(ITextContainer textContainer, object handle0, int handle1);
    private static StaticTextPointer();
    internal ITextPointer CreateDynamicTextPointer(LogicalDirection direction);
    internal TextPointerContext GetPointerContext(LogicalDirection direction);
    internal int GetOffsetToPosition(StaticTextPointer position);
    internal int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    internal object GetAdjacentElement(LogicalDirection direction);
    internal StaticTextPointer CreatePointer(int offset);
    internal StaticTextPointer GetNextContextPosition(LogicalDirection direction);
    internal int CompareTo(StaticTextPointer position);
    internal int CompareTo(ITextPointer position);
    internal object GetValue(DependencyProperty formattingProperty);
    internal static StaticTextPointer Min(StaticTextPointer position1, StaticTextPointer position2);
    internal static StaticTextPointer Max(StaticTextPointer position1, StaticTextPointer position2);
    internal void AssertGeneration();
    internal ITextContainer get_TextContainer();
    internal DependencyObject get_Parent();
    internal bool get_IsNull();
    internal object get_Handle0();
    internal int get_Handle1();
}
internal enum System.Windows.Documents.StrikeState : Enum {
    public int value__;
    public static StrikeState StrikeNone;
    public static StrikeState StrikeNormal;
    public static StrikeState StrikeDouble;
}
[ContentPropertyAttribute("RowGroups")]
public class System.Windows.Documents.Table : Block {
    public static DependencyProperty CellSpacingProperty;
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableColumnCollection Columns { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableRowGroupCollection RowGroups { get; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double CellSpacing { get; public set; }
    internal double InternalCellSpacing { get; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal int ColumnCount { get; }
    private static Table();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public virtual void BeginInit();
    public virtual void EndInit();
    protected internal virtual IEnumerator get_LogicalChildren();
    public TableColumnCollection get_Columns();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeColumns();
    public TableRowGroupCollection get_RowGroups();
    public double get_CellSpacing();
    public void set_CellSpacing(double value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal double get_InternalCellSpacing();
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal int get_ColumnCount();
    internal void EnsureColumnCount(int columnCount);
    internal void OnStructureChanged();
    internal void ValidateStructure();
    internal void InvalidateColumns();
    internal bool IsFirstNonEmptyRowGroup(int rowGroupIndex);
    internal bool IsLastNonEmptyRowGroup(int rowGroupIndex);
    [CompilerGeneratedAttribute]
internal void add_TableStructureChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_TableStructureChanged(EventHandler value);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.TableCell : TextElement {
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty ColumnSpanProperty;
    public static DependencyProperty RowSpanProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public int ColumnSpan { get; public set; }
    public int RowSpan { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.Index { get; private set; }
    internal TableRow Row { get; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    internal int RowIndex { get; }
    internal int RowGroupIndex { get; }
    internal int ColumnIndex { get; internal set; }
    internal bool IsIMEStructuralElement { get; }
    public TableCell(Block blockItem);
    private static TableCell();
    internal virtual void OnNewParent(DependencyObject newParent);
    public BlockCollection get_Blocks();
    public int get_ColumnSpan();
    public void set_ColumnSpan(int value);
    public int get_RowSpan();
    public void set_RowSpan(int value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnAfterExitParentTree(TableRow parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(TableRow row);
    internal void ValidateStructure(int columnIndex);
    internal TableRow get_Row();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    internal int get_RowIndex();
    internal int get_RowGroupIndex();
    internal int get_ColumnIndex();
    internal void set_ColumnIndex(int value);
    internal virtual bool get_IsIMEStructuralElement();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableCellCollection : object {
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableCell Item { get; public set; }
    internal TableCellCollection(TableRow owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableCell[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableCell> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableCell>.GetEnumerator();
    public sealed virtual void Add(TableCell item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableCell item);
    public sealed virtual int IndexOf(TableCell item);
    public sealed virtual void Insert(int index, TableCell item);
    public sealed virtual bool Remove(TableCell item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableCell get_Item(int index);
    public sealed virtual void set_Item(int index, TableCell value);
    internal void InternalAdd(TableCell item);
    internal void InternalRemove(TableCell item);
}
public class System.Windows.Documents.TableColumn : FrameworkContentElement {
    public static DependencyProperty WidthProperty;
    public static DependencyProperty BackgroundProperty;
    public GridLength Width { get; public set; }
    public Brush Background { get; public set; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.Index { get; private set; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    internal static GridLength DefaultWidth { get; }
    private static TableColumn();
    public GridLength get_Width();
    public void set_Width(GridLength value);
    public Brush get_Background();
    public void set_Background(Brush value);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnAfterExitParentTree(Table parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    internal static GridLength get_DefaultWidth();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableColumnCollection : object {
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableColumn Item { get; public set; }
    internal TableColumnCollection(Table owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableColumn[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableColumn> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableColumn>.GetEnumerator();
    public sealed virtual void Add(TableColumn item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableColumn item);
    public sealed virtual int IndexOf(TableColumn item);
    public sealed virtual void Insert(int index, TableColumn item);
    public sealed virtual bool Remove(TableColumn item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableColumn get_Item(int index);
    public sealed virtual void set_Item(int index, TableColumn value);
}
[ContentPropertyAttribute("Cells")]
public class System.Windows.Documents.TableRow : TextElement {
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.Index { get; private set; }
    internal TableRowGroup RowGroup { get; }
    internal Table Table { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableCellCollection Cells { get; }
    internal int Index { get; internal set; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal TableCell[] SpannedCells { get; }
    internal int ColumnCount { get; }
    internal bool HasForeignCells { get; }
    internal bool HasRealCells { get; }
    internal int FormatCellCount { get; }
    internal bool IsIMEStructuralElement { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void OnNewParent(DependencyObject newParent);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnAfterExitParentTree(TableRowGroup parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(TableRowGroup rowGroup);
    internal void ValidateStructure(RowSpanVector rowSpanVector);
    internal TableRowGroup get_RowGroup();
    internal Table get_Table();
    public TableCellCollection get_Cells();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCells();
    internal int get_Index();
    internal void set_Index(int value);
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal TableCell[] get_SpannedCells();
    internal int get_ColumnCount();
    internal bool get_HasForeignCells();
    internal bool get_HasRealCells();
    internal int get_FormatCellCount();
    internal virtual bool get_IsIMEStructuralElement();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableRowCollection : object {
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableRow Item { get; public set; }
    internal TableRowCollection(TableRowGroup owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableRow[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableRow> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableRow>.GetEnumerator();
    public sealed virtual void Add(TableRow item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableRow item);
    public sealed virtual int IndexOf(TableRow item);
    public sealed virtual void Insert(int index, TableRow item);
    public sealed virtual bool Remove(TableRow item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableRow get_Item(int index);
    public sealed virtual void set_Item(int index, TableRow value);
    internal void InternalAdd(TableRow item);
    internal void InternalRemove(TableRow item);
}
[ContentPropertyAttribute("Rows")]
public class System.Windows.Documents.TableRowGroup : TextElement {
    [DesignerSerializationVisibilityAttribute("2")]
public TableRowCollection Rows { get; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.Index { get; private set; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal bool IsIMEStructuralElement { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public TableRowCollection get_Rows();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeRows();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnAfterExitParentTree(Table parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(Table table);
    internal void ValidateStructure();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal virtual bool get_IsIMEStructuralElement();
    internal virtual void OnNewParent(DependencyObject newParent);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableRowGroupCollection : object {
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableRowGroup Item { get; public set; }
    internal TableRowGroupCollection(Table owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableRowGroup[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableRowGroup> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableRowGroup>.GetEnumerator();
    public sealed virtual void Add(TableRowGroup item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableRowGroup item);
    public sealed virtual int IndexOf(TableRowGroup item);
    public sealed virtual void Insert(int index, TableRowGroup item);
    public sealed virtual bool Remove(TableRowGroup item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableRowGroup get_Item(int index);
    public sealed virtual void set_Item(int index, TableRowGroup value);
    internal void InternalAdd(TableRowGroup item);
    internal void InternalRemove(TableRowGroup item);
}
internal enum System.Windows.Documents.TextChangeType : Enum {
    public int value__;
    public static TextChangeType ContentAdded;
    public static TextChangeType ContentRemoved;
    public static TextChangeType PropertyModified;
}
internal class System.Windows.Documents.TextContainer : object {
    internal TextPointer Start { get; }
    internal TextPointer End { get; }
    internal DependencyObject Parent { get; }
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    internal ITextView TextView { get; internal set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    internal int SymbolCount { get; }
    internal int InternalSymbolCount { get; }
    internal int IMECharCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal TextTreeRootTextBlock RootTextBlock { get; }
    internal UInt32 Generation { get; }
    internal UInt32 PositionGeneration { get; }
    internal UInt32 LayoutGeneration { get; }
    internal Highlights Highlights { get; }
    internal TextTreeRootNode RootNode { get; }
    internal TextTreeNode FirstContainedNode { get; }
    internal TextTreeNode LastContainedNode { get; }
    internal UndoManager UndoManager { get; }
    internal ITextSelection TextSelection { get; }
    internal bool HasListeners { get; }
    internal bool PlainTextOnly { get; }
    internal bool CollectTextChanges { get; internal set; }
    internal TextContainer(DependencyObject parent, bool plainTextOnly);
    public virtual string ToString();
    internal void EnableUndo(FrameworkElement uiScope);
    internal void DisableUndo(FrameworkElement uiScope);
    internal void SetValue(TextPointer position, DependencyProperty property, object value);
    internal void SetValues(TextPointer position, LocalValueEnumerator values);
    internal void BeginChange();
    internal void BeginChangeNoUndo();
    internal void EndChange();
    internal void EndChange(bool skipEvents);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    internal TextPointer CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    internal TextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    internal StaticTextPointer CreateStaticPointerAtOffset(int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    internal int GetInternalOffset(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    internal void BeforeAddChange();
    internal void AddChange(TextPointer startPosition, int symbolCount, int charCount, PrecursorTextChangeType textChange);
    internal void AddChange(TextPointer startPosition, int symbolCount, int charCount, PrecursorTextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal void AddChange(TextPointer startPosition, TextPointer endPosition, int symbolCount, int leftEdgeCharCount, int childCharCount, PrecursorTextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal void AddLocalValueChange();
    internal void InsertTextInternal(TextPointer position, object text);
    internal void InsertElementInternal(TextPointer startPosition, TextPointer endPosition, TextElement element);
    internal void InsertEmbeddedObjectInternal(TextPointer position, DependencyObject embeddedObject);
    internal void DeleteContentInternal(TextPointer startPosition, TextPointer endPosition);
    internal void GetNodeAndEdgeAtOffset(int offset, SplayTreeNode& node, ElementEdge& edge);
    internal void GetNodeAndEdgeAtOffset(int offset, bool splitNode, SplayTreeNode& node, ElementEdge& edge);
    internal void GetNodeAndEdgeAtCharOffset(int charOffset, TextTreeNode& node, ElementEdge& edge);
    internal void EmptyDeadPositionList();
    internal static int GetTextLength(object text);
    internal void AssertTree();
    internal int GetContentHashCode();
    internal void NextLayoutGeneration();
    internal void ExtractElementInternal(TextElement element);
    internal bool IsAtCaretUnitBoundary(TextPointer position);
    internal TextPointer get_Start();
    internal TextPointer get_End();
    internal DependencyObject get_Parent();
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    internal int get_SymbolCount();
    internal int get_InternalSymbolCount();
    internal int get_IMECharCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    internal TextTreeRootTextBlock get_RootTextBlock();
    internal UInt32 get_Generation();
    internal UInt32 get_PositionGeneration();
    internal UInt32 get_LayoutGeneration();
    internal Highlights get_Highlights();
    internal TextTreeRootNode get_RootNode();
    internal TextTreeNode get_FirstContainedNode();
    internal TextTreeNode get_LastContainedNode();
    internal UndoManager get_UndoManager();
    internal ITextSelection get_TextSelection();
    internal bool get_HasListeners();
    internal bool get_PlainTextOnly();
    internal bool get_CollectTextChanges();
    internal void set_CollectTextChanges(bool value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changed(TextContainerChangedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changed(TextContainerChangedEventHandler value);
    internal void add_Changing(EventHandler value);
    internal void remove_Changing(EventHandler value);
    internal void add_Change(TextContainerChangeEventHandler value);
    internal void remove_Change(TextContainerChangeEventHandler value);
    internal void add_Changed(TextContainerChangedEventHandler value);
    internal void remove_Changed(TextContainerChangedEventHandler value);
}
internal class System.Windows.Documents.TextContainerChangedEventArgs : EventArgs {
    internal bool HasContentAddedOrRemoved { get; }
    internal bool HasLocalPropertyValueChange { get; }
    internal SortedList`2<int, TextChange> Changes { get; }
    internal void SetLocalPropertyValueChanged();
    internal void AddChange(PrecursorTextChangeType textChange, int offset, int length, bool collectTextChanges);
    internal bool get_HasContentAddedOrRemoved();
    internal bool get_HasLocalPropertyValueChange();
    internal SortedList`2<int, TextChange> get_Changes();
}
internal class System.Windows.Documents.TextContainerChangedEventHandler : MulticastDelegate {
    public TextContainerChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextContainerChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextContainerChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.TextContainerChangeEventArgs : EventArgs {
    internal ITextPointer ITextPosition { get; }
    internal int IMECharCount { get; }
    internal bool AffectsRenderOnly { get; }
    internal int Count { get; }
    internal TextChangeType TextChange { get; }
    internal DependencyProperty Property { get; }
    internal TextContainerChangeEventArgs(ITextPointer textPosition, int count, int charCount, TextChangeType textChange);
    internal TextContainerChangeEventArgs(ITextPointer textPosition, int count, int charCount, TextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal ITextPointer get_ITextPosition();
    internal int get_IMECharCount();
    internal bool get_AffectsRenderOnly();
    internal int get_Count();
    internal TextChangeType get_TextChange();
    internal DependencyProperty get_Property();
}
internal class System.Windows.Documents.TextContainerChangeEventHandler : MulticastDelegate {
    public TextContainerChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextContainerChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextContainerChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.TextEditor : object {
    internal static DependencyProperty IsReadOnlyProperty;
    internal static DependencyProperty AllowOvertypeProperty;
    internal static DependencyProperty PageHeightProperty;
    internal Dispatcher _dispatcher;
    internal double _suggestedX;
    internal Cursor _cursor;
    internal IParentUndoUnit _typingUndoUnit;
    internal _DragDropProcess _dragDropProcess;
    internal bool _forceWordSelection;
    internal bool _forceParagraphSelection;
    internal TableColumnResizeInfo _tableColResizeInfo;
    internal bool _mouseCapturingInProgress;
    internal bool _isNextLineAdvanceMovingPositionAtDocumentHead;
    internal ITextContainer TextContainer { get; }
    internal FrameworkElement UiScope { get; }
    internal ITextView TextView { get; internal set; }
    internal ITextSelection Selection { get; }
    internal TextStore TextStore { get; }
    internal ImmComposition ImmComposition { get; }
    internal bool AcceptsReturn { get; }
    internal bool AcceptsTab { get; internal set; }
    internal bool IsReadOnly { get; internal set; }
    internal bool IsSpellCheckEnabled { get; internal set; }
    internal bool AcceptsRichContent { get; internal set; }
    internal bool AllowOvertype { get; }
    internal int MaxLength { get; }
    internal CharacterCasing CharacterCasing { get; }
    internal bool AutoWordSelection { get; }
    internal bool IsReadOnlyCaretVisible { get; }
    internal UndoState UndoState { get; }
    internal bool IsContextMenuOpen { get; internal set; }
    internal Speller Speller { get; }
    internal bool _IsEnabled { get; }
    internal bool _OvertypeMode { get; internal set; }
    internal FrameworkElement _Scroller { get; }
    internal static TextEditorThreadLocalStore _ThreadLocalStore { get; }
    internal long _ContentChangeCounter { get; }
    internal static bool IsTableEditingEnabled { get; internal set; }
    internal ITextPointer _NextLineAdvanceMovingPosition { get; internal set; }
    internal bool _IsNextLineAdvanceMovingPositionAtDocumentHead { get; internal set; }
    internal TextEditor(ITextContainer textContainer, FrameworkElement uiScope, bool isUndoEnabled);
    private static TextEditor();
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDetach();
    internal void SetSpellCheckEnabled(bool value);
    internal void SetCustomDictionaries(bool add);
    internal void SetSpellingReform(SpellingReform spellingReform);
    internal static ITextView GetTextView(UIElement scope);
    internal static ITextSelection GetTextSelection(FrameworkElement frameworkElement);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void RegisterCommandHandlers(Type controlType, bool acceptsRichContent, bool readOnly, bool registerEventListeners);
    internal SpellingError GetSpellingErrorAtPosition(ITextPointer position, LogicalDirection direction);
    internal SpellingError GetSpellingErrorAtSelection();
    internal ITextPointer GetNextSpellingErrorPosition(ITextPointer position, LogicalDirection direction);
    internal void SetText(ITextRange range, string text, CultureInfo cultureInfo);
    internal void SetSelectedText(string text, CultureInfo cultureInfo);
    internal void MarkCultureProperty(TextRange range, CultureInfo inputCultureInfo);
    internal void RequestExtendSelection(Point point);
    internal void CancelExtendSelection();
    internal void CloseToolTip();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Undo();
    internal void Redo();
    internal void OnPreviewKeyDown(KeyEventArgs e);
    internal void OnKeyDown(KeyEventArgs e);
    internal void OnKeyUp(KeyEventArgs e);
    internal void OnTextInput(TextCompositionEventArgs e);
    internal void OnMouseDown(MouseButtonEventArgs e);
    internal void OnMouseMove(MouseEventArgs e);
    internal void OnMouseUp(MouseButtonEventArgs e);
    internal void OnQueryCursor(QueryCursorEventArgs e);
    internal void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    internal void OnGiveFeedback(GiveFeedbackEventArgs e);
    internal void OnDragEnter(DragEventArgs e);
    internal void OnDragOver(DragEventArgs e);
    internal void OnDragLeave(DragEventArgs e);
    internal void OnDrop(DragEventArgs e);
    internal void OnContextMenuOpening(ContextMenuEventArgs e);
    internal void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void OnLostFocus(RoutedEventArgs e);
    internal ITextContainer get_TextContainer();
    internal FrameworkElement get_UiScope();
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    internal ITextSelection get_Selection();
    internal TextStore get_TextStore();
    internal ImmComposition get_ImmComposition();
    internal bool get_AcceptsReturn();
    internal bool get_AcceptsTab();
    internal void set_AcceptsTab(bool value);
    internal bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    internal bool get_IsSpellCheckEnabled();
    internal void set_IsSpellCheckEnabled(bool value);
    internal bool get_AcceptsRichContent();
    internal void set_AcceptsRichContent(bool value);
    internal bool get_AllowOvertype();
    internal int get_MaxLength();
    internal CharacterCasing get_CharacterCasing();
    internal bool get_AutoWordSelection();
    internal bool get_IsReadOnlyCaretVisible();
    internal UndoState get_UndoState();
    internal bool get_IsContextMenuOpen();
    internal void set_IsContextMenuOpen(bool value);
    internal Speller get_Speller();
    internal static TextEditor _GetTextEditor(object element);
    internal UndoManager _GetUndoManager();
    internal string _FilterText(string textData, ITextRange range);
    internal string _FilterText(string textData, int charsToReplaceCount);
    internal string _FilterText(string textData, ITextRange range, bool filterMaxLength);
    internal string _FilterText(string textData, int charsToReplaceCount, bool filterMaxLength);
    internal bool _IsSourceInScope(object source);
    internal void CompleteComposition();
    internal bool get__IsEnabled();
    internal bool get__OvertypeMode();
    internal void set__OvertypeMode(bool value);
    internal FrameworkElement get__Scroller();
    internal static TextEditorThreadLocalStore get__ThreadLocalStore();
    internal long get__ContentChangeCounter();
    internal static bool get_IsTableEditingEnabled();
    internal static void set_IsTableEditingEnabled(bool value);
    internal ITextPointer get__NextLineAdvanceMovingPosition();
    internal void set__NextLineAdvanceMovingPosition(ITextPointer value);
    internal bool get__IsNextLineAdvanceMovingPositionAtDocumentHead();
    internal void set__IsNextLineAdvanceMovingPositionAtDocumentHead(bool value);
}
internal static class System.Windows.Documents.TextEditorCharacters : object {
    internal static double OneFontPoint;
    internal static double MaxFontPoint;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue, bool applyToParagraphs);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue, bool applyToParagraphs, PropertyValueAction propertyValueAction);
}
internal static class System.Windows.Documents.TextEditorContextMenu : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void OnContextMenuOpening(object sender, ContextMenuEventArgs e);
}
internal static class System.Windows.Documents.TextEditorCopyPaste : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void _RegisterClassHandlers(Type controlType, bool acceptsRichContent, bool readOnly, bool registerEventListeners);
    [SecurityCriticalAttribute]
internal static DataObject _CreateDataObject(TextEditor This, bool isDragDrop);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool _DoPaste(TextEditor This, IDataObject dataObject, bool isDragDrop);
    internal static string GetPasteApplyFormat(TextEditor This, IDataObject dataObject);
    [SecurityCriticalAttribute]
internal static void Cut(TextEditor This, bool userInitiated);
    [SecurityCriticalAttribute]
internal static void Copy(TextEditor This, bool userInitiated);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void Paste(TextEditor This);
    internal static string ConvertXamlToRtf(string xamlContent, Stream wpfContainerMemory);
    internal static MemoryStream ConvertRtfToXaml(string rtfContent);
}
internal static class System.Windows.Documents.TextEditorDragDrop : object {
    internal static void _RegisterClassHandlers(Type controlType, bool readOnly, bool registerEventListeners);
    internal static void OnQueryContinueDrag(object sender, QueryContinueDragEventArgs e);
    internal static void OnGiveFeedback(object sender, GiveFeedbackEventArgs e);
    internal static void OnDragEnter(object sender, DragEventArgs e);
    internal static void OnDragOver(object sender, DragEventArgs e);
    internal static void OnDragLeave(object sender, DragEventArgs e);
    internal static void OnDrop(object sender, DragEventArgs e);
    internal static void OnClearState(object sender, DragEventArgs e);
}
internal static class System.Windows.Documents.TextEditorLists : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void DecreaseIndentation(TextEditor This);
}
internal static class System.Windows.Documents.TextEditorMouse : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void SetCaretPositionOnMouseEvent(TextEditor This, Point mouseDownPoint, MouseButton changedButton, int clickCount);
    internal static bool IsPointWithinInteractiveArea(TextEditor textEditor, Point point);
    internal static void OnMouseDown(object sender, MouseButtonEventArgs e);
    internal static void OnMouseMove(object sender, MouseEventArgs e);
    internal static void OnMouseUp(object sender, MouseButtonEventArgs e);
    internal static void OnQueryCursor(object sender, QueryCursorEventArgs e);
}
internal static class System.Windows.Documents.TextEditorParagraphs : object {
    internal static void _RegisterClassHandlers(Type controlType, bool acceptsRichContent, bool registerEventListeners);
}
internal static class System.Windows.Documents.TextEditorSelection : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _ClearSuggestedX(TextEditor This);
    internal static TextSegment GetNormalizedLineRange(ITextView textView, ITextPointer position);
    internal static bool IsPaginated(ITextView textview);
}
internal static class System.Windows.Documents.TextEditorSpelling : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static SpellingError GetSpellingErrorAtPosition(TextEditor This, ITextPointer position, LogicalDirection direction);
    internal static SpellingError GetSpellingErrorAtSelection(TextEditor This);
    internal static ITextPointer GetNextSpellingErrorPosition(TextEditor This, ITextPointer position, LogicalDirection direction);
}
internal static class System.Windows.Documents.TextEditorTables : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
}
internal class System.Windows.Documents.TextEditorThreadLocalStore : object {
    internal int InputLanguageChangeEventHandlerCount { get; internal set; }
    internal ArrayList PendingInputItems { get; internal set; }
    internal bool PureControlShift { get; internal set; }
    internal bool Bidi { get; internal set; }
    internal TextSelection FocusedTextSelection { get; internal set; }
    internal TextServicesHost TextServicesHost { get; internal set; }
    internal bool HideCursor { get; internal set; }
    internal int get_InputLanguageChangeEventHandlerCount();
    internal void set_InputLanguageChangeEventHandlerCount(int value);
    internal ArrayList get_PendingInputItems();
    internal void set_PendingInputItems(ArrayList value);
    internal bool get_PureControlShift();
    internal void set_PureControlShift(bool value);
    internal bool get_Bidi();
    internal void set_Bidi(bool value);
    internal TextSelection get_FocusedTextSelection();
    internal void set_FocusedTextSelection(TextSelection value);
    internal TextServicesHost get_TextServicesHost();
    internal void set_TextServicesHost(TextServicesHost value);
    internal bool get_HideCursor();
    internal void set_HideCursor(bool value);
}
internal static class System.Windows.Documents.TextEditorTyping : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _AddInputLanguageChangedEventHandler(TextEditor This);
    internal static void _RemoveInputLanguageChangedEventHandler(TextEditor This);
    internal static void _BreakTypingSequence(TextEditor This);
    internal static void _FlushPendingInputItems(TextEditor This);
    internal static void _ShowCursor();
    internal static void OnPreviewKeyDown(object sender, KeyEventArgs e);
    internal static void OnKeyDown(object sender, KeyEventArgs e);
    internal static void OnKeyUp(object sender, KeyEventArgs e);
    internal static void OnTextInput(object sender, TextCompositionEventArgs e);
}
public static class System.Windows.Documents.TextEffectResolver : object {
    public static TextEffectTarget[] Resolve(TextPointer startPosition, TextPointer endPosition, TextEffect effect);
}
public class System.Windows.Documents.TextEffectTarget : object {
    public DependencyObject Element { get; }
    public TextEffect TextEffect { get; }
    public bool IsEnabled { get; }
    internal TextEffectTarget(DependencyObject element, TextEffect effect);
    public DependencyObject get_Element();
    public TextEffect get_TextEffect();
    public void Enable();
    public void Disable();
    public bool get_IsEnabled();
}
public abstract class System.Windows.Documents.TextElement : FrameworkContentElement {
    internal static UncommonField`1<TextElement> ContainerTextElementField;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextEffectsProperty;
    internal TextRange TextRange { get; }
    public TextPointer ElementStart { get; }
    internal StaticTextPointer StaticElementStart { get; }
    public TextPointer ContentStart { get; }
    internal StaticTextPointer StaticContentStart { get; }
    public TextPointer ContentEnd { get; }
    internal StaticTextPointer StaticContentEnd { get; }
    public TextPointer ElementEnd { get; }
    internal StaticTextPointer StaticElementEnd { get; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    public Typography Typography { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal TextContainer TextContainer { get; }
    internal bool IsEmpty { get; }
    internal bool IsInTree { get; }
    internal int ElementStartOffset { get; }
    internal int ContentStartOffset { get; }
    internal int ContentEndOffset { get; }
    internal int ElementEndOffset { get; }
    internal int SymbolCount { get; }
    internal TextTreeTextElementNode TextElementNode { get; internal set; }
    internal TypographyProperties TypographyPropertiesGroup { get; }
    internal bool IsIMEStructuralElement { get; }
    internal int IMELeftEdgeCharCount { get; }
    internal bool IsFirstIMEVisibleSibling { get; }
    internal TextElement NextElement { get; }
    internal TextElement PreviousElement { get; }
    internal TextElement FirstChildElement { get; }
    internal TextElement LastChildElement { get; }
    private static TextElement();
    internal void Reposition(TextPointer start, TextPointer end);
    internal void RepositionWithContent(TextPointer textPosition);
    internal TextRange get_TextRange();
    public TextPointer get_ElementStart();
    internal StaticTextPointer get_StaticElementStart();
    public TextPointer get_ContentStart();
    internal StaticTextPointer get_StaticContentStart();
    public TextPointer get_ContentEnd();
    internal StaticTextPointer get_StaticContentEnd();
    internal bool Contains(TextPointer position);
    public TextPointer get_ElementEnd();
    internal StaticTextPointer get_StaticElementEnd();
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public static void SetFontFamily(DependencyObject element, FontFamily value);
    public static FontFamily GetFontFamily(DependencyObject element);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public static void SetFontStyle(DependencyObject element, FontStyle value);
    public static FontStyle GetFontStyle(DependencyObject element);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public static void SetFontWeight(DependencyObject element, FontWeight value);
    public static FontWeight GetFontWeight(DependencyObject element);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public static void SetFontStretch(DependencyObject element, FontStretch value);
    public static FontStretch GetFontStretch(DependencyObject element);
    public double get_FontSize();
    public void set_FontSize(double value);
    public static void SetFontSize(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
public static double GetFontSize(DependencyObject element);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public static void SetForeground(DependencyObject element, Brush value);
    public static Brush GetForeground(DependencyObject element);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public Typography get_Typography();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal void NotifyTypographicPropertyChanged(bool affectsMeasureOrArrange, bool localValueChanged, DependencyProperty property);
    internal static TypographyProperties GetTypographyProperties(DependencyObject element);
    internal void DeepEndInit();
    internal static TextElement GetCommonAncestor(TextElement element1, TextElement element2);
    internal virtual void OnTextUpdated();
    internal virtual void BeforeLogicalTreeChange();
    internal virtual void AfterLogicalTreeChange();
    internal TextContainer get_TextContainer();
    internal bool get_IsEmpty();
    internal bool get_IsInTree();
    internal int get_ElementStartOffset();
    internal int get_ContentStartOffset();
    internal int get_ContentEndOffset();
    internal int get_ElementEndOffset();
    internal int get_SymbolCount();
    internal TextTreeTextElementNode get_TextElementNode();
    internal void set_TextElementNode(TextTreeTextElementNode value);
    internal TypographyProperties get_TypographyPropertiesGroup();
    internal virtual bool get_IsIMEStructuralElement();
    internal int get_IMELeftEdgeCharCount();
    internal virtual bool get_IsFirstIMEVisibleSibling();
    internal TextElement get_NextElement();
    internal TextElement get_PreviousElement();
    internal TextElement get_FirstChildElement();
    internal TextElement get_LastChildElement();
}
public class System.Windows.Documents.TextElementCollection`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal DependencyObject Owner { get; }
    internal DependencyObject Parent { get; }
    internal TextContainer TextContainer { get; }
    internal TextElementType FirstChild { get; }
    internal TextElementType LastChild { get; }
    internal TextElementCollection`1(DependencyObject owner, bool isOwnerParent);
    public sealed virtual void Add(TextElementType item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextElementType item);
    public sealed virtual void CopyTo(TextElementType[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(TextElementType item);
    public void InsertAfter(TextElementType previousSibling, TextElementType newItem);
    public void InsertBefore(TextElementType nextSibling, TextElementType newItem);
    public void AddRange(IEnumerable range);
    public sealed virtual IEnumerator`1<TextElementType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal virtual int OnAdd(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal DependencyObject get_Owner();
    internal DependencyObject get_Parent();
    internal TextContainer get_TextContainer();
    internal TextElementType get_FirstChild();
    internal TextElementType get_LastChild();
    internal virtual void ValidateChild(TextElementType child);
}
internal static class System.Windows.Documents.TextElementCollectionHelper : object {
    private static TextElementCollectionHelper();
    internal static void MarkDirty(DependencyObject parent);
    internal static void MarkClean(DependencyObject parent, object collection);
    internal static bool IsCleanParent(DependencyObject parent, object collection);
}
[AttributeUsageAttribute("4")]
public class System.Windows.Documents.TextElementEditingBehaviorAttribute : Attribute {
    public bool IsMergeable { get; public set; }
    public bool IsTypographicOnly { get; public set; }
    public bool get_IsMergeable();
    public void set_IsMergeable(bool value);
    public bool get_IsTypographicOnly();
    public void set_IsTypographicOnly(bool value);
}
internal class System.Windows.Documents.TextElementEnumerator`1 : object {
    private object System.Collections.IEnumerator.Current { get; }
    public TextElementType Current { get; }
    internal TextElementEnumerator`1(TextPointer start, TextPointer end);
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TextElementType get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class System.Windows.Documents.TextFindEngine : object {
    public static ITextRange Find(ITextPointer findContainerStartPosition, ITextPointer findContainerEndPosition, string findPattern, FindFlags flags, CultureInfo cultureInfo);
    internal static TextRange InternalFind(ITextPointer startPosition, ITextPointer endPosition, string findPattern, CultureInfo cultureInfo, bool matchCase, bool matchWholeWord, bool matchLast, bool matchDiacritics, bool matchKashida, bool matchAlefHamza);
    internal static void InitializeBidiFlags(string textString, Boolean& stringContainedBidiCharacter, Boolean& stringContainedAlefCharacter);
    internal static string ReplaceAlefHamzaWithAlef(string textString);
}
internal class System.Windows.Documents.TextParentUndoUnit : ParentUndoUnit {
    internal TextParentUndoUnit(ITextSelection selection);
    internal TextParentUndoUnit(ITextSelection selection, ITextPointer anchorPosition, ITextPointer movingPosition);
    protected TextParentUndoUnit(TextParentUndoUnit undoUnit);
    public virtual void Do();
    protected virtual IParentUndoUnit CreateParentUndoUnitForSelf();
    protected virtual TextParentUndoUnit CreateRedoUnit();
    protected void MergeRedoSelectionState(TextParentUndoUnit undoUnit);
    internal void RecordRedoSelectionState();
    internal void RecordRedoSelectionState(ITextPointer anchorPosition, ITextPointer movingPosition);
}
public class System.Windows.Documents.TextPointer : ContentPosition {
    public bool HasValidLayout { get; }
    public LogicalDirection LogicalDirection { get; }
    public DependencyObject Parent { get; }
    public bool IsAtInsertionPosition { get; }
    public bool IsAtLineStartPosition { get; }
    public Paragraph Paragraph { get; }
    internal Block ParagraphOrBlockUIContainer { get; }
    public TextPointer DocumentStart { get; }
    public TextPointer DocumentEnd { get; }
    internal bool IsFrozen { get; }
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    internal int Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal int CharOffset { get; }
    internal TextContainer TextContainer { get; }
    internal FrameworkElement ContainingFrameworkElement { get; }
    internal bool IsAtRowEnd { get; }
    internal bool HasNonMergeableInlineAncestor { get; }
    internal bool IsAtNonMergeableInlineStart { get; }
    internal TextTreeNode Node { get; }
    internal ElementEdge Edge { get; }
    internal Block ParentBlock { get; }
    internal TextPointer(TextPointer textPointer);
    internal TextPointer(TextPointer position, int offset);
    internal TextPointer(TextPointer position, LogicalDirection direction);
    internal TextPointer(TextPointer position, int offset, LogicalDirection direction);
    internal TextPointer(TextContainer textContainer, int offset, LogicalDirection direction);
    internal TextPointer(TextContainer tree, TextTreeNode node, ElementEdge edge);
    internal TextPointer(TextContainer tree, TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal TextPointer CreatePointer();
    internal TextPointer CreatePointer(LogicalDirection gravity);
    public bool IsInSameDocument(TextPointer textPosition);
    public int CompareTo(TextPointer position);
    public TextPointerContext GetPointerContext(LogicalDirection direction);
    public int GetTextRunLength(LogicalDirection direction);
    public int GetOffsetToPosition(TextPointer position);
    public string GetTextInRun(LogicalDirection direction);
    public int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public DependencyObject GetAdjacentElement(LogicalDirection direction);
    public TextPointer GetPositionAtOffset(int offset);
    public TextPointer GetPositionAtOffset(int offset, LogicalDirection direction);
    public TextPointer GetNextContextPosition(LogicalDirection direction);
    public TextPointer GetInsertionPosition(LogicalDirection direction);
    internal TextPointer GetInsertionPosition();
    public TextPointer GetNextInsertionPosition(LogicalDirection direction);
    public TextPointer GetLineStartPosition(int count);
    public TextPointer GetLineStartPosition(int count, Int32& actualCount);
    public Rect GetCharacterRect(LogicalDirection direction);
    public void InsertTextInRun(string textData);
    public int DeleteTextInRun(int count);
    internal void InsertTextElement(TextElement textElement);
    public TextPointer InsertParagraphBreak();
    public TextPointer InsertLineBreak();
    public virtual string ToString();
    public bool get_HasValidLayout();
    public LogicalDirection get_LogicalDirection();
    public DependencyObject get_Parent();
    public bool get_IsAtInsertionPosition();
    public bool get_IsAtLineStartPosition();
    public Paragraph get_Paragraph();
    internal Block get_ParagraphOrBlockUIContainer();
    public TextPointer get_DocumentStart();
    public TextPointer get_DocumentEnd();
    internal Inline GetNonMergeableInlineAncestor();
    internal ListItem GetListAncestor();
    internal static int GetTextInRun(TextContainer textContainer, int symbolOffset, TextTreeTextNode textNode, int nodeOffset, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    internal static DependencyObject GetAdjacentElement(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal void MoveToPosition(TextPointer textPosition);
    internal int MoveByOffset(int offset);
    internal bool MoveToNextContextPosition(LogicalDirection direction);
    internal bool MoveToInsertionPosition(LogicalDirection direction);
    internal bool MoveToNextInsertionPosition(LogicalDirection direction);
    internal int MoveToLineBoundary(int count);
    internal void InsertUIElement(UIElement uiElement);
    internal TextElement GetAdjacentElementFromOuterPosition(LogicalDirection direction);
    internal void SetLogicalDirection(LogicalDirection direction);
    internal bool get_IsFrozen();
    internal void Freeze();
    internal TextPointer GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty formattingProperty);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty formattingProperty);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int offset);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int offset, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    internal void MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    internal bool ValidateLayout();
    internal TextTreeTextNode GetAdjacentTextNodeSibling(LogicalDirection direction);
    internal static TextTreeTextNode GetAdjacentTextNodeSibling(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal TextTreeTextElementNode GetAdjacentTextElementNodeSibling(LogicalDirection direction);
    internal TextTreeTextElementNode GetAdjacentTextElementNode(LogicalDirection direction);
    internal TextTreeNode GetAdjacentSiblingNode(LogicalDirection direction);
    internal static TextTreeNode GetAdjacentSiblingNode(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal int GetSymbolOffset();
    internal static int GetSymbolOffset(TextContainer tree, TextTreeNode node, ElementEdge edge);
    internal DependencyObject GetLogicalTreeNode();
    internal void SyncToTreeGeneration();
    internal TextTreeNode GetScopingNode();
    internal static TextTreeNode GetScopingNode(TextTreeNode node, ElementEdge edge);
    internal void DebugAssertGeneration();
    internal bool GetNextNodeAndEdge(TextTreeNode& node, ElementEdge& edge);
    internal static bool GetNextNodeAndEdge(TextTreeNode sourceNode, ElementEdge sourceEdge, bool plainTextOnly, TextTreeNode& node, ElementEdge& edge);
    internal bool GetPreviousNodeAndEdge(TextTreeNode& node, ElementEdge& edge);
    internal static bool GetPreviousNodeAndEdge(TextTreeNode sourceNode, ElementEdge sourceEdge, bool plainTextOnly, TextTreeNode& node, ElementEdge& edge);
    internal static TextPointerContext GetPointerContextForward(TextTreeNode node, ElementEdge edge);
    internal static TextPointerContext GetPointerContextBackward(TextTreeNode node, ElementEdge edge);
    internal void InsertInline(Inline inline);
    internal static DependencyObject GetCommonAncestor(TextPointer position1, TextPointer position2);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    internal int get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal int get_CharOffset();
    internal TextContainer get_TextContainer();
    internal FrameworkElement get_ContainingFrameworkElement();
    internal bool get_IsAtRowEnd();
    internal bool get_HasNonMergeableInlineAncestor();
    internal bool get_IsAtNonMergeableInlineStart();
    internal TextTreeNode get_Node();
    internal ElementEdge get_Edge();
    internal Block get_ParentBlock();
    internal TextTreeNode GetAdjacentNode(LogicalDirection direction);
    internal static TextTreeNode GetAdjacentNode(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
}
internal static class System.Windows.Documents.TextPointerBase : object {
    internal static Char[] NextLineCharacters;
    private static TextPointerBase();
    internal static ITextPointer Min(ITextPointer position1, ITextPointer position2);
    internal static ITextPointer Max(ITextPointer position1, ITextPointer position2);
    internal static string GetTextInRun(ITextPointer position, LogicalDirection direction);
    internal static int GetTextWithLimit(ITextPointer thisPointer, LogicalDirection direction, Char[] textBuffer, int startIndex, int count, ITextPointer limit);
    internal static bool IsAtInsertionPosition(ITextPointer position);
    internal static bool IsAtPotentialRunPosition(ITextPointer position);
    internal static bool IsAtPotentialRunPosition(TextElement run);
    internal static bool IsAtPotentialParagraphPosition(ITextPointer position);
    internal static bool IsBeforeFirstTable(ITextPointer position);
    internal static bool IsInBlockUIContainer(ITextPointer position);
    internal static bool IsAtBlockUIContainerStart(ITextPointer position);
    internal static bool IsAtBlockUIContainerEnd(ITextPointer position);
    internal static bool IsInAnchoredBlock(ITextPointer position);
    internal static bool IsInHyperlinkScope(ITextPointer position);
    internal static ITextPointer GetFollowingNonMergeableInlineContentStart(ITextPointer position);
    internal static bool IsAtNonMergeableInlineStart(ITextPointer position);
    internal static bool IsAtNonMergeableInlineEnd(ITextPointer position);
    internal static bool IsPositionAtNonMergeableInlineBoundary(ITextPointer position);
    internal static bool IsAtFormatNormalizedPosition(ITextPointer position, LogicalDirection direction);
    internal static bool IsAtInsertionPosition(ITextPointer position, LogicalDirection direction);
    internal static bool IsAtNormalizedPosition(ITextPointer position, LogicalDirection direction, bool respectCaretUnitBoundaries);
    internal static int GetOffset(ITextPointer thisPosition);
    internal static bool IsAtWordBoundary(ITextPointer thisPosition, LogicalDirection insideWordDirection);
    internal static TextSegment GetWordRange(ITextPointer thisPosition);
    internal static TextSegment GetWordRange(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsNextToPlainLineBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsCharUnicodeNewLine(char ch);
    internal static bool IsNextToRichLineBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsNextToParagraphBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsNextToAnyBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsAtLineWrappingPosition(ITextPointer position, ITextView textView);
    internal static bool IsAtRowEnd(ITextPointer thisPosition);
    internal static bool IsAfterLastParagraph(ITextPointer thisPosition);
    internal static bool IsAtParagraphOrBlockUIContainerStart(ITextPointer pointer);
    internal static ListItem GetListItem(TextPointer pointer);
    internal static ListItem GetImmediateListItem(TextPointer position);
    internal static bool IsInEmptyListItem(TextPointer position);
    internal static int MoveToLineBoundary(ITextPointer thisPointer, ITextView textView, int count);
    internal static int MoveToLineBoundary(ITextPointer thisPointer, ITextView textView, int count, bool respectNonMeargeableInlineStart);
    internal static Rect GetCharacterRect(ITextPointer thisPointer, LogicalDirection direction);
    internal static Rect GetCharacterRect(ITextPointer thisPointer, LogicalDirection direction, bool transformToUiScope);
    internal static bool MoveToFormatNormalizedPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToInsertionPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToNextInsertionPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToNextWordBoundary(ITextPointer thisNavigator, LogicalDirection movingDirection);
    internal static ITextPointer GetFrozenPointer(ITextPointer thisPointer, LogicalDirection logicalDirection);
    internal static bool ValidateLayout(ITextPointer thisPointer, ITextView textView);
}
public enum System.Windows.Documents.TextPointerContext : Enum {
    public int value__;
    public static TextPointerContext None;
    public static TextPointerContext Text;
    public static TextPointerContext EmbeddedElement;
    public static TextPointerContext ElementStart;
    public static TextPointerContext ElementEnd;
}
public class System.Windows.Documents.TextRange : object {
    private bool System.Windows.Documents.ITextRange.IgnoreTextUnitBoundaries { get; }
    private ITextPointer System.Windows.Documents.ITextRange.Start { get; }
    private ITextPointer System.Windows.Documents.ITextRange.End { get; }
    private bool System.Windows.Documents.ITextRange.IsEmpty { get; }
    private List`1<TextSegment> System.Windows.Documents.ITextRange.TextSegments { get; }
    private bool System.Windows.Documents.ITextRange.HasConcreteTextContainer { get; }
    private string System.Windows.Documents.ITextRange.Text { get; private set; }
    private string System.Windows.Documents.ITextRange.Xml { get; }
    private int System.Windows.Documents.ITextRange.ChangeBlockLevel { get; }
    private bool System.Windows.Documents.ITextRange.IsTableCellRange { get; }
    private bool System.Windows.Documents.ITextRange._IsTableCellRange { get; private set; }
    private List`1<TextSegment> System.Windows.Documents.ITextRange._TextSegments { get; private set; }
    private int System.Windows.Documents.ITextRange._ChangeBlockLevel { get; private set; }
    private ChangeBlockUndoRecord System.Windows.Documents.ITextRange._ChangeBlockUndoRecord { get; private set; }
    private bool System.Windows.Documents.ITextRange._IsChanged { get; private set; }
    private UInt32 System.Windows.Documents.ITextRange._ContentGeneration { get; private set; }
    public TextPointer Start { get; }
    public TextPointer End { get; }
    public bool IsEmpty { get; }
    internal bool HasConcreteTextContainer { get; }
    internal FrameworkElement ContainingFrameworkElement { get; }
    public string Text { get; public set; }
    internal string Xml { get; internal set; }
    internal bool IsTableCellRange { get; }
    internal bool _IsChanged { get; internal set; }
    internal int ChangeBlockLevel { get; }
    public TextRange(TextPointer position1, TextPointer position2);
    internal TextRange(ITextPointer position1, ITextPointer position2);
    internal TextRange(ITextPointer position1, ITextPointer position2, bool ignoreTextUnitBoundaries);
    private sealed virtual override bool System.Windows.Documents.ITextRange.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.Select(ITextPointer position1, ITextPointer position2);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectWord(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectParagraph(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.ApplyTypingHeuristics(bool overType);
    private sealed virtual override object System.Windows.Documents.ITextRange.GetPropertyValue(DependencyProperty formattingProperty);
    private sealed virtual override UIElement System.Windows.Documents.ITextRange.GetUIElementSelected();
    private sealed virtual override bool System.Windows.Documents.ITextRange.CanSave(string dataFormat);
    private sealed virtual override void System.Windows.Documents.ITextRange.Save(Stream stream, string dataFormat);
    private sealed virtual override void System.Windows.Documents.ITextRange.Save(Stream stream, string dataFormat, bool preserveTextElements);
    private sealed virtual override void System.Windows.Documents.ITextRange.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextRange.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextRange.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextRange.EndChange(bool disableScroll, bool skipEvents);
    private sealed virtual override IDisposable System.Windows.Documents.ITextRange.DeclareChangeBlock();
    private sealed virtual override IDisposable System.Windows.Documents.ITextRange.DeclareChangeBlock(bool disableScroll);
    private sealed virtual override void System.Windows.Documents.ITextRange.NotifyChanged(bool disableScroll, bool skipEvents);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IgnoreTextUnitBoundaries();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextRange.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextRange.get_End();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IsEmpty();
    private sealed virtual override List`1<TextSegment> System.Windows.Documents.ITextRange.get_TextSegments();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_HasConcreteTextContainer();
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Text();
    private sealed virtual override void System.Windows.Documents.ITextRange.set_Text(string value);
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Xml();
    private sealed virtual override int System.Windows.Documents.ITextRange.get_ChangeBlockLevel();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IsTableCellRange();
    private sealed virtual override void System.Windows.Documents.ITextRange.add_Changed(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextRange.remove_Changed(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextRange.FireChanged();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsTableCellRange();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsTableCellRange(bool value);
    private sealed virtual override List`1<TextSegment> System.Windows.Documents.ITextRange.get__TextSegments();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__TextSegments(List`1<TextSegment> value);
    private sealed virtual override int System.Windows.Documents.ITextRange.get__ChangeBlockLevel();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ChangeBlockLevel(int value);
    private sealed virtual override ChangeBlockUndoRecord System.Windows.Documents.ITextRange.get__ChangeBlockUndoRecord();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ChangeBlockUndoRecord(ChangeBlockUndoRecord value);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsChanged();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsChanged(bool value);
    private sealed virtual override UInt32 System.Windows.Documents.ITextRange.get__ContentGeneration();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ContentGeneration(UInt32 value);
    public bool Contains(TextPointer textPointer);
    public void Select(TextPointer position1, TextPointer position2);
    internal void SelectWord(TextPointer textPointer);
    internal void SelectParagraph(ITextPointer position);
    public void ApplyPropertyValue(DependencyProperty formattingProperty, object value);
    internal void ApplyPropertyValue(DependencyProperty formattingProperty, object value, bool applyToParagraphs);
    internal void ApplyPropertyValue(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    public void ClearAllProperties();
    public object GetPropertyValue(DependencyProperty formattingProperty);
    internal UIElement GetUIElementSelected();
    public bool CanSave(string dataFormat);
    public bool CanLoad(string dataFormat);
    public void Save(Stream stream, string dataFormat);
    public void Save(Stream stream, string dataFormat, bool preserveTextElements);
    public void Load(Stream stream, string dataFormat);
    internal void InsertEmbeddedUIElement(FrameworkElement embeddedElement);
    internal void InsertImage(Image image);
    internal virtual void SetXmlVirtual(TextElement fragment);
    internal virtual void LoadVirtual(Stream stream, string dataFormat);
    internal Table InsertTable(int rowCount, int columnCount);
    internal TextRange InsertRows(int rowCount);
    internal bool DeleteRows();
    internal TextRange InsertColumns(int columnCount);
    internal bool DeleteColumns();
    internal TextRange MergeCells();
    internal TextRange SplitCell(int splitCountHorizontal, int splitCountVertical);
    public TextPointer get_Start();
    public TextPointer get_End();
    public bool get_IsEmpty();
    internal bool get_HasConcreteTextContainer();
    internal FrameworkElement get_ContainingFrameworkElement();
    public string get_Text();
    public void set_Text(string value);
    internal string get_Xml();
    internal void set_Xml(string value);
    internal bool get_IsTableCellRange();
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    internal void BeginChange();
    internal void EndChange();
    internal IDisposable DeclareChangeBlock();
    internal IDisposable DeclareChangeBlock(bool disableScroll);
    internal bool get__IsChanged();
    internal void set__IsChanged(bool value);
    internal virtual void InsertEmbeddedUIElementVirtual(FrameworkElement embeddedElement);
    internal virtual void ApplyPropertyToTextVirtual(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    internal virtual void ClearAllPropertiesVirtual();
    internal virtual Table InsertTableVirtual(int rowCount, int columnCount);
    internal virtual TextRange InsertRowsVirtual(int rowCount);
    internal virtual bool DeleteRowsVirtual();
    internal virtual TextRange InsertColumnsVirtual(int columnCount);
    internal virtual bool DeleteColumnsVirtual();
    internal virtual TextRange MergeCellsVirtual();
    internal virtual TextRange SplitCellVirtual(int splitCountHorizontal, int splitCountVertical);
    internal int get_ChangeBlockLevel();
}
internal static class System.Windows.Documents.TextRangeBase : object {
    private static TextRangeBase();
    internal static bool Contains(ITextRange thisRange, ITextPointer textPointer);
    internal static void Select(ITextRange thisRange, ITextPointer position1, ITextPointer position2);
    internal static void Select(ITextRange thisRange, ITextPointer position1, ITextPointer position2, bool includeCellAtMovingPosition);
    internal static void SelectWord(ITextRange thisRange, ITextPointer position);
    internal static TextSegment GetAutoWord(ITextRange thisRange);
    internal static void SelectParagraph(ITextRange thisRange, ITextPointer position);
    internal static void ApplyInitialTypingHeuristics(ITextRange thisRange);
    internal static void ApplyFinalTypingHeuristics(ITextRange thisRange, bool overType);
    internal static void ApplyTypingHeuristics(ITextRange thisRange, bool overType);
    internal static void FindParagraphOrListItemBoundaries(ITextPointer position, ITextPointer& start, ITextPointer& end);
    internal static object GetPropertyValue(ITextRange thisRange, DependencyProperty formattingProperty);
    internal static bool IsParagraphBoundaryCrossed(ITextRange thisRange);
    internal static void BeginChange(ITextRange thisRange);
    internal static void BeginChangeNoUndo(ITextRange thisRange);
    internal static void EndChange(ITextRange thisRange);
    internal static void EndChange(ITextRange thisRange, bool disableScroll, bool skipEvents);
    internal static void NotifyChanged(ITextRange thisRange, bool disableScroll);
    internal static string GetTextInternal(ITextPointer startPosition, ITextPointer endPosition);
    internal static string GetTextInternal(ITextPointer startPosition, ITextPointer endPosition, Char[]& charArray);
    internal static ITextPointer GetStart(ITextRange thisRange);
    internal static ITextPointer GetEnd(ITextRange thisRange);
    internal static bool GetIsEmpty(ITextRange thisRange);
    internal static List`1<TextSegment> GetTextSegments(ITextRange thisRange);
    internal static string GetText(ITextRange thisRange);
    internal static void SetText(ITextRange thisRange, string textData);
    internal static string GetXml(ITextRange thisRange);
    internal static bool CanSave(ITextRange thisRange, string dataFormat);
    internal static bool CanLoad(ITextRange thisRange, string dataFormat);
    internal static void Save(ITextRange thisRange, Stream stream, string dataFormat, bool preserveTextElements);
    internal static void Load(TextRange thisRange, Stream stream, string dataFormat);
    internal static int GetChangeBlockLevel(ITextRange thisRange);
    internal static UIElement GetUIElementSelected(ITextRange range);
    internal static bool GetIsTableCellRange(ITextRange thisRange);
    internal static void NormalizeAnchoredBlockBoundaries(TextPointer& start, TextPointer& end);
}
internal static class System.Windows.Documents.TextRangeEdit : object {
    internal static TextElement InsertElementClone(TextPointer start, TextPointer end, TextElement element);
    internal static TextPointer SplitFormattingElements(TextPointer splitPosition, bool keepEmptyFormatting);
    internal static TextPointer SplitFormattingElement(TextPointer splitPosition, bool keepEmptyFormatting);
    internal static void SetInlineProperty(TextPointer start, TextPointer end, DependencyProperty formattingProperty, object value, PropertyValueAction propertyValueAction);
    internal static bool MergeFormattingInlines(TextPointer position);
    internal static void CharacterResetFormatting(TextPointer start, TextPointer end);
    internal static TextPointer SplitElement(TextPointer position);
    internal static TextPointer InsertParagraphBreak(TextPointer position, bool moveIntoSecondParagraph);
    internal static TextPointer InsertLineBreak(TextPointer position);
    internal static void SetParagraphProperty(TextPointer start, TextPointer end, DependencyProperty property, object value);
    internal static void SetParagraphProperty(TextPointer start, TextPointer end, DependencyProperty property, object value, PropertyValueAction propertyValueAction);
    internal static HorizontalAlignment GetHorizontalAlignmentFromTextAlignment(TextAlignment textAlignment);
    internal static TextAlignment GetTextAlignmentFromHorizontalAlignment(HorizontalAlignment horizontalAlignment);
    internal static ITextPointer GetAdjustedRangeEnd(ITextPointer rangeStart, ITextPointer rangeEnd);
    internal static void MergeFlowDirection(TextPointer position);
    internal static bool CanApplyStructuralInlineProperty(TextPointer start, TextPointer end);
    internal static void IncrementParagraphLeadingMargin(TextRange range, double increment, PropertyValueAction propertyValueAction);
    internal static void DeleteInlineContent(ITextPointer start, ITextPointer end);
    internal static void DeleteParagraphContent(ITextPointer start, ITextPointer end);
}
internal static class System.Windows.Documents.TextRangeEditLists : object {
    internal static bool MergeParagraphs(Block firstParagraphOrBlockUIContainer, Block secondParagraphOrBlockUIContainer);
    internal static bool MergeListsAroundNormalizedPosition(TextPointer mergePosition);
    internal static bool MergeLists(TextPointer mergePosition);
    internal static bool IsListOperationApplicable(TextRange range);
    internal static bool ConvertParagraphsToListItems(TextRange range, TextMarkerStyle markerStyle);
    internal static void ConvertListItemsToParagraphs(TextRange range);
    internal static void IndentListItems(TextRange range);
    internal static bool UnindentListItems(TextRange range);
    internal static bool ParagraphsAreMergeable(Block firstParagraphOrBlockUIContainer, Block secondParagraphOrBlockUIContainer);
    internal static bool SplitListsForFlowDirectionChange(TextPointer start, TextPointer end, object newFlowDirectionValue);
}
internal static class System.Windows.Documents.TextRangeEditTables : object {
    internal static bool GetColumnRange(ITextRange range, Table table, Int32& firstColumnIndex, Int32& lastColumnIndex);
    internal static Table GetTableFromPosition(TextPointer position);
    internal static TableCell GetTableCellFromPosition(TextPointer position);
    internal static bool IsTableStructureCrossed(ITextPointer anchorPosition, ITextPointer movingPosition);
    internal static bool IsTableCellRange(TextPointer anchorPosition, TextPointer movingPosition, bool includeCellAtMovingPosition, TableCell& anchorCell, TableCell& movingCell);
    internal static List`1<TextSegment> BuildTableRange(TextPointer anchorPosition, TextPointer movingPosition, bool includeCellAtMovingPosition, Boolean& isTableCellRange);
    internal static void IdentifyValidBoundaries(ITextRange range, ITextPointer& start, ITextPointer& end);
    internal static TextPointer GetNextTableCellRangeInsertionPosition(TextSelection selection, LogicalDirection direction);
    internal static TextPointer GetNextRowEndMovingPosition(TextSelection selection, LogicalDirection direction);
    internal static bool MovingPositionCrossesCellBoundary(TextSelection selection);
    internal static TextPointer GetNextRowStartMovingPosition(TextSelection selection, LogicalDirection direction);
    internal static Table InsertTable(TextPointer insertionPosition, int rowCount, int columnCount);
    internal static TextPointer EnsureInsertionPosition(TextPointer position);
    internal static TextPointer GetAdjustedRowEndPosition(Table currentTable, TextPointer rowEndPosition);
    internal static void DeleteContent(TextPointer start, TextPointer end);
    internal static TextRange InsertRows(TextRange textRange, int rowCount);
    internal static bool DeleteRows(TextRange textRange);
    internal static TextRange InsertColumns(TextRange textRange, int columnCount);
    internal static void DeleteColumn(int colIndex, Table table);
    internal static bool DeleteColumns(TextRange textRange);
    internal static bool TableBorderHitTest(ITextView textView, Point pt);
    internal static TableColumnResizeInfo StartColumnResize(ITextView textView, Point pt);
    internal static void EnsureTableColumnsAreFixedSize(Table table, Double[] columnWidths);
    internal static TextRange MergeCells(TextRange textRange);
    internal static TextRange SplitCell(TextRange textRange, int splitCountHorizontal, int splitCountVertical);
}
internal static class System.Windows.Documents.TextRangeSerialization : object {
    internal static void WriteXaml(XmlWriter xmlWriter, ITextRange range, bool useFlowDocumentAsRoot, WpfPayload wpfPayload);
    internal static void WriteXaml(XmlWriter xmlWriter, ITextRange range, bool useFlowDocumentAsRoot, WpfPayload wpfPayload, bool preserveTextElements);
    internal static void PasteXml(TextRange range, TextElement fragment);
}
internal static class System.Windows.Documents.TextSchema : object {
    internal static DependencyProperty[] BehavioralProperties { get; }
    internal static DependencyProperty[] ImageProperties { get; }
    internal static DependencyProperty[] StructuralCharacterProperties { get; }
    private static TextSchema();
    internal static bool IsInTextContent(ITextPointer position);
    internal static bool ValidateChild(TextElement parent, TextElement child, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidChild(TextElement parent, Type childType);
    internal static bool ValidateChild(TextElement parent, Type childType, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidChild(TextPointer position, Type childType);
    internal static bool ValidateChild(TextPointer position, Type childType, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidSibling(Type siblingType, Type newType);
    internal static bool IsValidChild(ITextPointer position, Type childType);
    internal static bool IsValidChildOfContainer(Type parentType, Type childType);
    internal static bool HasHyperlinkAncestor(TextElement element);
    internal static bool IsFormattingType(Type elementType);
    internal static bool IsKnownType(Type elementType);
    internal static bool IsNonFormattingInline(Type elementType);
    internal static bool IsMergeableInline(Type elementType);
    internal static bool IsNonMergeableInline(Type elementType);
    internal static bool AllowsParagraphMerging(Type elementType);
    internal static bool IsParagraphOrBlockUIContainer(Type elementType);
    internal static bool IsBlock(Type type);
    internal static bool IsBreak(Type type);
    internal static bool HasTextDecorations(object value);
    internal static Type GetStandardElementType(Type type, bool reduceElement);
    internal static DependencyProperty[] GetInheritableProperties(Type type);
    internal static DependencyProperty[] GetNoninheritableProperties(Type type);
    internal static bool ValuesAreEqual(object value1, object value2);
    internal static bool IsParagraphProperty(DependencyProperty formattingProperty);
    internal static bool IsCharacterProperty(DependencyProperty formattingProperty);
    internal static bool IsNonFormattingCharacterProperty(DependencyProperty property);
    internal static DependencyProperty[] GetNonFormattingCharacterProperties();
    internal static bool IsStructuralCharacterProperty(DependencyProperty formattingProperty);
    internal static bool IsPropertyIncremental(DependencyProperty property);
    internal static DependencyProperty[] get_BehavioralProperties();
    internal static DependencyProperty[] get_ImageProperties();
    internal static DependencyProperty[] get_StructuralCharacterProperties();
}
internal class System.Windows.Documents.TextSegment : ValueType {
    internal static TextSegment Null;
    private ITextPointer _start;
    private ITextPointer _end;
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal bool IsNull { get; }
    internal TextSegment(ITextPointer startPosition, ITextPointer endPosition);
    internal TextSegment(ITextPointer startPosition, ITextPointer endPosition, bool preserveLogicalDirection);
    private static TextSegment();
    internal bool Contains(ITextPointer position);
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal bool get_IsNull();
}
public class System.Windows.Documents.TextSelection : TextRange {
    private bool System.Windows.Documents.ITextRange._IsChanged { get; private set; }
    private string System.Windows.Documents.ITextRange.Text { get; private set; }
    private ITextPointer System.Windows.Documents.ITextSelection.AnchorPosition { get; }
    private ITextPointer System.Windows.Documents.ITextSelection.MovingPosition { get; }
    internal bool IsInterimSelection { get; }
    private bool System.Windows.Documents.ITextSelection.IsInterimSelection { get; }
    internal TextPointer AnchorPosition { get; }
    internal TextPointer MovingPosition { get; }
    internal CaretElement CaretElement { get; }
    private CaretElement System.Windows.Documents.ITextSelection.CaretElement { get; }
    private bool System.Windows.Documents.ITextSelection.CoversEntireContent { get; }
    private TextEditor System.Windows.Documents.ITextSelection.TextEditor { get; }
    private ITextView System.Windows.Documents.ITextSelection.TextView { get; }
    internal TextSelection(TextEditor textEditor);
    private sealed virtual override void System.Windows.Documents.ITextRange.Select(ITextPointer anchorPosition, ITextPointer movingPosition);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectWord(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectParagraph(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.ApplyTypingHeuristics(bool overType);
    private sealed virtual override object System.Windows.Documents.ITextRange.GetPropertyValue(DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsChanged();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsChanged(bool value);
    private sealed virtual override void System.Windows.Documents.ITextRange.NotifyChanged(bool disableScroll, bool skipEvents);
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Text();
    private sealed virtual override void System.Windows.Documents.ITextRange.set_Text(string value);
    private sealed virtual override void System.Windows.Documents.ITextSelection.UpdateCaretAndHighlight();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextSelection.get_AnchorPosition();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextSelection.get_MovingPosition();
    private sealed virtual override void System.Windows.Documents.ITextSelection.SetCaretToPosition(ITextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    private sealed virtual override void System.Windows.Documents.ITextSelection.ExtendToPosition(ITextPointer position);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.ExtendToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.Contains(Point point);
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnDetach();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnTextViewUpdated();
    private sealed virtual override void System.Windows.Documents.ITextSelection.DetachFromVisualTree();
    private sealed virtual override void System.Windows.Documents.ITextSelection.RefreshCaret();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnInterimSelectionChanged(bool interimSelection);
    private sealed virtual override void System.Windows.Documents.ITextSelection.SetSelectionByMouse(ITextPointer cursorPosition, Point cursorMousePoint);
    private sealed virtual override void System.Windows.Documents.ITextSelection.ExtendSelectionByMouse(ITextPointer cursorPosition, bool forceWordSelection, bool forceParagraphSelection);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.ExtendToNextTableRow(LogicalDirection direction);
    internal bool get_IsInterimSelection();
    private sealed virtual override bool System.Windows.Documents.ITextSelection.get_IsInterimSelection();
    internal TextPointer get_AnchorPosition();
    internal TextPointer get_MovingPosition();
    internal void SetCaretToPosition(TextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    internal bool ExtendToNextInsertionPosition(LogicalDirection direction);
    internal static void OnInputLanguageChanged(CultureInfo cultureInfo);
    internal bool Contains(Point point);
    internal virtual void InsertEmbeddedUIElementVirtual(FrameworkElement embeddedElement);
    internal virtual void ApplyPropertyToTextVirtual(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    internal virtual void ClearAllPropertiesVirtual();
    internal virtual void SetXmlVirtual(TextElement fragment);
    internal virtual void LoadVirtual(Stream stream, string dataFormat);
    internal virtual Table InsertTableVirtual(int rowCount, int columnCount);
    internal object GetCurrentValue(DependencyProperty formattingProperty);
    internal void SpringloadCurrentFormatting();
    internal void ClearSpringloadFormatting();
    internal void ApplySpringloadFormatting();
    internal void UpdateCaretState(CaretScrollMethod caretScrollMethod);
    internal static Brush GetCaretBrush(TextEditor textEditor);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsBidiInputLanguageInstalled();
    private sealed virtual override void System.Windows.Documents.ITextSelection.ValidateLayout();
    internal CaretElement get_CaretElement();
    private sealed virtual override CaretElement System.Windows.Documents.ITextSelection.get_CaretElement();
    private sealed virtual override bool System.Windows.Documents.ITextSelection.get_CoversEntireContent();
    internal void OnCaretNavigation();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnCaretNavigation();
    private sealed virtual override TextEditor System.Windows.Documents.ITextSelection.get_TextEditor();
    private sealed virtual override ITextView System.Windows.Documents.ITextSelection.get_TextView();
}
internal class System.Windows.Documents.TextSelectionHighlightLayer : HighlightLayer {
    internal Type OwnerType { get; }
    private static TextSelectionHighlightLayer();
    internal TextSelectionHighlightLayer(ITextSelection selection);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void InternalOnSelectionChanged();
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.TextServicesDisplayAttribute : object {
    internal TF_DA_LINESTYLE LineStyle { get; }
    internal bool IsBoldLine { get; }
    internal TF_DA_ATTR_INFO AttrInfo { get; }
    internal TextServicesDisplayAttribute(TF_DISPLAYATTRIBUTE attr);
    internal bool IsEmptyAttribute();
    internal void Apply(ITextPointer start, ITextPointer end);
    internal static Color GetColor(TF_DA_COLOR dacolor, ITextPointer position);
    internal Color GetLineColor(ITextPointer position);
    internal TF_DA_LINESTYLE get_LineStyle();
    internal bool get_IsBoldLine();
    internal TF_DA_ATTR_INFO get_AttrInfo();
}
internal class System.Windows.Documents.TextServicesDisplayAttributePropertyRanges : TextServicesPropertyRanges {
    internal TextServicesDisplayAttributePropertyRanges(TextStore textstore);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void OnRange(ITfProperty property, int ecReadOnly, ITfRange range);
    [SecurityCriticalAttribute]
internal virtual void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    internal void OnLayoutUpdated();
}
internal class System.Windows.Documents.TextServicesHost : DispatcherObject {
    internal static TextServicesHost Current { get; }
    internal ITfThreadMgr ThreadManager { get; }
    [SecurityCriticalAttribute]
internal void RegisterTextStore(TextStore textstore);
    [SecurityCriticalAttribute]
internal void UnregisterTextStore(TextStore textstore, bool finalizer);
    [SecurityCriticalAttribute]
internal void RegisterWinEventSink(TextStore textstore);
    [SecurityCriticalAttribute]
internal void UnregisterWinEventSink(TextStore textstore);
    [SecurityCriticalAttribute]
internal static void StartTransitoryExtension(TextStore textstore);
    [SecurityCriticalAttribute]
internal static void StopTransitoryExtension(TextStore textstore);
    internal static TextServicesHost get_Current();
    [SecurityCriticalAttribute]
internal ITfThreadMgr get_ThreadManager();
}
internal class System.Windows.Documents.TextServicesProperty : object {
    internal TextServicesProperty(TextStore textstore);
    [SecurityCriticalAttribute]
internal void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    internal void OnLayoutUpdated();
}
internal class System.Windows.Documents.TextServicesPropertyRanges : object {
    protected Guid Guid { get; }
    protected TextStore TextStore { get; }
    internal TextServicesPropertyRanges(TextStore textstore, Guid guid);
    [SecurityCriticalAttribute]
internal virtual void OnRange(ITfProperty property, int ecReadonly, ITfRange range);
    [SecurityCriticalAttribute]
internal virtual void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    [SecurityCriticalAttribute]
protected void ConvertToTextPosition(ITfRange range, ITextPointer& start, ITextPointer& end);
    [SecurityCriticalAttribute]
protected static object GetValue(int ecReadOnly, ITfProperty property, ITfRange range);
    protected Guid get_Guid();
    protected TextStore get_TextStore();
}
internal class System.Windows.Documents.TextStore : object {
    internal UIElement RenderScope { get; }
    internal FrameworkElement UiScope { get; }
    internal ITextContainer TextContainer { get; }
    internal ITextView TextView { get; }
    internal ITfDocumentMgr DocumentManager { get; internal set; }
    internal int ThreadFocusCookie { get; internal set; }
    internal int EditSinkCookie { get; internal set; }
    internal int EditCookie { get; internal set; }
    internal bool IsInterimSelection { get; }
    internal bool IsComposing { get; }
    internal bool IsEffectivelyComposing { get; }
    internal int TransitoryExtensionSinkCookie { get; internal set; }
    internal IntPtr CriticalSourceWnd { get; }
    internal TextStore(TextEditor textEditor);
    private static TextStore();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void AdviseSink(Guid& riid, object obj, AdviseFlags flags);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void UnadviseSink(object obj);
    public sealed virtual void RequestLock(LockFlags flags, Int32& hrSession);
    public sealed virtual void GetStatus(TS_STATUS& status);
    public sealed virtual void QueryInsert(int startIndex, int endIndex, int cch, Int32& startResultIndex, Int32& endResultIndex);
    public sealed virtual void GetSelection(int index, int count, TS_SELECTION_ACP[] selection, Int32& fetched);
    public sealed virtual void SetSelection(int count, TS_SELECTION_ACP[] selection);
    public sealed virtual void GetText(int startIndex, int endIndex, Char[] text, int cchReq, Int32& charsCopied, TS_RUNINFO[] runInfo, int cRunInfoReq, Int32& cRunInfoRcv, Int32& nextIndex);
    public sealed virtual void SetText(SetTextFlags flags, int startIndex, int endIndex, Char[] text, int cch, TS_TEXTCHANGE& change);
    public sealed virtual void GetFormattedText(int startIndex, int endIndex, Object& obj);
    public sealed virtual void GetEmbedded(int index, Guid& guidService, Guid& riid, Object& obj);
    public sealed virtual void QueryInsertEmbedded(Guid& guidService, int formatEtc, Boolean& insertable);
    public sealed virtual void InsertEmbedded(InsertEmbeddedFlags flags, int startIndex, int endIndex, object obj, TS_TEXTCHANGE& change);
    public sealed virtual void InsertTextAtSelection(InsertAtSelectionFlags flags, Char[] text, int cch, Int32& startIndex, Int32& endIndex, TS_TEXTCHANGE& change);
    public sealed virtual void InsertEmbeddedAtSelection(InsertAtSelectionFlags flags, object obj, Int32& startIndex, Int32& endIndex, TS_TEXTCHANGE& change);
    public sealed virtual int RequestSupportedAttrs(AttributeFlags flags, int count, Guid[] filterAttributes);
    public sealed virtual int RequestAttrsAtPosition(int index, int count, Guid[] filterAttributes, AttributeFlags flags);
    public sealed virtual void RequestAttrsTransitioningAtPosition(int position, int count, Guid[] filterAttributes, AttributeFlags flags);
    public sealed virtual void FindNextAttrTransition(int startIndex, int haltIndex, int count, Guid[] filterAttributes, AttributeFlags flags, Int32& acpNext, Boolean& found, Int32& foundOffset);
    public sealed virtual void RetrieveRequestedAttrs(int count, TS_ATTRVAL[] attributeVals, Int32& fetched);
    public sealed virtual void GetEnd(Int32& end);
    public sealed virtual void GetActiveView(Int32& viewCookie);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void GetACPFromPoint(int viewCookie, POINT& tsfPoint, GetPositionFromPointFlags flags, Int32& positionCP);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITextStoreACP.GetTextExt(int viewCookie, int startIndex, int endIndex, RECT& rect, Boolean& clipped);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void GetScreenExt(int viewCookie, RECT& rect);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITextStoreACP.GetWnd(int viewCookie, IntPtr& hwnd);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITfThreadFocusSink.OnSetThreadFocus();
    public sealed virtual void OnKillThreadFocus();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void OnStartComposition(ITfCompositionView view, Boolean& ok);
    [SecurityCriticalAttribute]
public sealed virtual void OnUpdateComposition(ITfCompositionView view, ITfRange rangeNew);
    [SecurityCriticalAttribute]
public sealed virtual void OnEndComposition(ITfCompositionView view);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITfTextEditSink.OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void OnTransitoryExtensionUpdated(ITfContext context, int ecReadOnly, ITfRange rangeResult, ITfRange rangeComposition, Boolean& fDeleteResultRange);
    [SecuritySafeCriticalAttribute]
public sealed virtual int AdviceMouseSink(ITfRangeACP range, ITfMouseSink sink, Int32& dwCookie);
    public sealed virtual int UnadviceMouseSink(int dwCookie);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnAttach();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnDetach(bool finalizer);
    [SecurityCriticalAttribute]
internal void OnGotFocus();
    internal void OnLostFocus();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnLayoutUpdated();
    internal void OnSelectionChange();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnSelectionChanged();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool QueryRangeOrReconvertSelection(bool fDoReconvert);
    [SecurityCriticalAttribute]
internal ITfCandidateList GetReconversionCandidateList();
    internal void CompleteCompositionAsync();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CompleteComposition();
    internal ITextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    internal void MakeLayoutChangeOnGotFocus();
    internal void UpdateCompositionText(FrameworkTextComposition composition);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static FrameworkTextComposition CreateComposition(TextEditor editor, object owner);
    internal UIElement get_RenderScope();
    internal FrameworkElement get_UiScope();
    internal ITextContainer get_TextContainer();
    internal ITextView get_TextView();
    [SecurityCriticalAttribute]
internal ITfDocumentMgr get_DocumentManager();
    [SecurityCriticalAttribute]
internal void set_DocumentManager(ITfDocumentMgr value);
    internal int get_ThreadFocusCookie();
    internal void set_ThreadFocusCookie(int value);
    internal int get_EditSinkCookie();
    internal void set_EditSinkCookie(int value);
    internal int get_EditCookie();
    internal void set_EditCookie(int value);
    internal bool get_IsInterimSelection();
    internal bool get_IsComposing();
    internal bool get_IsEffectivelyComposing();
    internal int get_TransitoryExtensionSinkCookie();
    internal void set_TransitoryExtensionSinkCookie(int value);
    [SecurityCriticalAttribute]
internal IntPtr get_CriticalSourceWnd();
}
internal class System.Windows.Documents.TextTreeDeleteContentUndoUnit : TextTreeUndoUnit {
    internal TextTreeDeleteContentUndoUnit(TextContainer tree, TextPointer start, TextPointer end);
    public virtual void DoCore();
    internal static TableColumn[] SaveColumns(Table table);
    internal static void RestoreColumns(Table table, TableColumn[] savedColumns);
}
internal class System.Windows.Documents.TextTreeExtractElementUndoUnit : TextTreeUndoUnit {
    internal TextTreeExtractElementUndoUnit(TextContainer tree, TextTreeTextElementNode elementNode);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeFixupNode : TextTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextTreeNode PreviousNode { get; }
    internal ElementEdge PreviousEdge { get; }
    internal TextTreeNode NextNode { get; }
    internal ElementEdge NextEdge { get; }
    internal TextTreeNode FirstContainedNode { get; }
    internal TextTreeNode LastContainedNode { get; }
    internal TextTreeFixupNode(TextTreeNode previousNode, ElementEdge previousEdge, TextTreeNode nextNode, ElementEdge nextEdge);
    internal TextTreeFixupNode(TextTreeNode previousNode, ElementEdge previousEdge, TextTreeNode nextNode, ElementEdge nextEdge, TextTreeNode firstContainedNode, TextTreeNode lastContainedNode);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextTreeNode get_PreviousNode();
    internal ElementEdge get_PreviousEdge();
    internal TextTreeNode get_NextNode();
    internal ElementEdge get_NextEdge();
    internal TextTreeNode get_FirstContainedNode();
    internal TextTreeNode get_LastContainedNode();
}
internal class System.Windows.Documents.TextTreeInsertElementUndoUnit : TextTreeUndoUnit {
    internal TextTreeInsertElementUndoUnit(TextContainer tree, int symbolOffset, bool deep);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeInsertUndoUnit : TextTreeUndoUnit {
    internal TextTreeInsertUndoUnit(TextContainer tree, int symbolOffset, int symbolCount);
    public virtual void DoCore();
}
internal abstract class System.Windows.Documents.TextTreeNode : SplayTreeNode {
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal abstract virtual TextTreeNode Clone();
    internal TextContainer GetTextTree();
    internal DependencyObject GetDependencyParent();
    internal DependencyObject GetLogicalTreeNode();
    internal abstract virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal TextTreeNode IncrementReferenceCount(ElementEdge edge);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, bool delta);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, int delta);
    internal virtual void DecrementReferenceCount(ElementEdge edge);
    internal void InsertAtPosition(TextPointer position);
    internal ElementEdge GetEdgeFromOffsetNoBias(int nodeOffset);
    internal ElementEdge GetEdgeFromOffset(int nodeOffset, LogicalDirection bias);
    internal int GetOffsetFromEdge(ElementEdge edge);
    internal abstract virtual bool get_BeforeStartReferenceCount();
    internal abstract virtual void set_BeforeStartReferenceCount(bool value);
    internal abstract virtual bool get_AfterStartReferenceCount();
    internal abstract virtual void set_AfterStartReferenceCount(bool value);
    internal abstract virtual bool get_BeforeEndReferenceCount();
    internal abstract virtual void set_BeforeEndReferenceCount(bool value);
    internal abstract virtual bool get_AfterEndReferenceCount();
    internal abstract virtual void set_AfterEndReferenceCount(bool value);
}
internal class System.Windows.Documents.TextTreeObjectNode : TextTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal DependencyObject EmbeddedElement { get; }
    internal TextTreeObjectNode(DependencyObject embeddedElement);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal DependencyObject get_EmbeddedElement();
}
internal class System.Windows.Documents.TextTreePropertyUndoUnit : TextTreeUndoUnit {
    internal TextTreePropertyUndoUnit(TextContainer tree, int symbolOffset, PropertyRecord propertyRecord);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeRootNode : TextTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal UInt32 PositionGeneration { get; internal set; }
    internal UInt32 LayoutGeneration { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextContainer TextContainer { get; }
    internal TextTreeRootTextBlock RootTextBlock { get; internal set; }
    internal DispatcherProcessingDisabled DispatcherProcessingDisabled { get; internal set; }
    internal bool CaretUnitBoundaryCache { get; internal set; }
    internal int CaretUnitBoundaryCacheOffset { get; internal set; }
    internal TextTreeRootNode(TextContainer tree);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal UInt32 get_PositionGeneration();
    internal void set_PositionGeneration(UInt32 value);
    internal UInt32 get_LayoutGeneration();
    internal void set_LayoutGeneration(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextContainer get_TextContainer();
    internal TextTreeRootTextBlock get_RootTextBlock();
    internal void set_RootTextBlock(TextTreeRootTextBlock value);
    internal DispatcherProcessingDisabled get_DispatcherProcessingDisabled();
    internal void set_DispatcherProcessingDisabled(DispatcherProcessingDisabled value);
    internal bool get_CaretUnitBoundaryCache();
    internal void set_CaretUnitBoundaryCache(bool value);
    internal int get_CaretUnitBoundaryCacheOffset();
    internal void set_CaretUnitBoundaryCacheOffset(int value);
}
internal class System.Windows.Documents.TextTreeRootTextBlock : SplayTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
}
internal static class System.Windows.Documents.TextTreeText : object {
    internal static void InsertText(TextTreeRootTextBlock rootTextBlock, int offset, object text);
    internal static void RemoveText(TextTreeRootTextBlock rootTextBlock, int offset, int count);
    internal static Char[] CutText(TextTreeRootTextBlock rootTextBlock, int offset, int count);
    internal static void ReadText(TextTreeRootTextBlock rootTextBlock, int offset, int count, Char[] chars, int startIndex);
    internal static void InsertObject(TextTreeRootTextBlock rootTextBlock, int offset);
    internal static void InsertElementEdges(TextTreeRootTextBlock rootTextBlock, int offset, int childSymbolCount);
    internal static void RemoveElementEdges(TextTreeRootTextBlock rootTextBlock, int offset, int symbolCount);
    internal static void Remove(TextTreeTextBlock firstNode, TextTreeTextBlock lastNode);
}
internal class System.Windows.Documents.TextTreeTextBlock : SplayTreeNode {
    internal static int MaxBlockSize;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal int Count { get; }
    internal int FreeCapacity { get; }
    internal int GapOffset { get; }
    internal TextTreeTextBlock(int size);
    internal int InsertText(int logicalOffset, object text, int textStartIndex, int textEndIndex);
    internal TextTreeTextBlock SplitBlock();
    internal void RemoveText(int logicalOffset, int count);
    internal int ReadText(int logicalOffset, int count, Char[] chars, int charsStartIndex);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal int get_Count();
    internal int get_FreeCapacity();
    internal int get_GapOffset();
}
internal class System.Windows.Documents.TextTreeTextElementNode : TextTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextElement TextElement { get; internal set; }
    internal int IMELeftEdgeCharCount { get; }
    internal bool IsFirstSibling { get; }
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextElement get_TextElement();
    internal void set_TextElement(TextElement value);
    internal int get_IMELeftEdgeCharCount();
    internal bool get_IsFirstSibling();
}
internal class System.Windows.Documents.TextTreeTextNode : TextTreeNode {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, int delta);
    internal virtual void DecrementReferenceCount(ElementEdge edge);
    internal TextTreeTextNode Split(int localOffset, ElementEdge edge);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
}
internal static class System.Windows.Documents.TextTreeUndo : object {
    internal static void CreateInsertUndoUnit(TextContainer tree, int symbolOffset, int symbolCount);
    internal static void CreateInsertElementUndoUnit(TextContainer tree, int symbolOffset, bool deep);
    internal static void CreatePropertyUndoUnit(TextElement element, DependencyPropertyChangedEventArgs e);
    internal static TextTreeDeleteContentUndoUnit CreateDeleteContentUndoUnit(TextContainer tree, TextPointer start, TextPointer end);
    internal static TextTreeExtractElementUndoUnit CreateExtractElementUndoUnit(TextContainer tree, TextTreeTextElementNode elementNode);
    internal static UndoManager GetOrClearUndoManager(ITextContainer textContainer);
}
internal abstract class System.Windows.Documents.TextTreeUndoUnit : object {
    protected TextContainer TextContainer { get; }
    protected int SymbolOffset { get; }
    internal TextTreeUndoUnit(TextContainer tree, int symbolOffset);
    public sealed virtual void Do();
    public abstract virtual void DoCore();
    public sealed virtual bool Merge(IUndoUnit unit);
    protected TextContainer get_TextContainer();
    protected int get_SymbolOffset();
    internal void SetTreeHashCode();
    internal void VerifyTreeContentHashCode();
    internal static PropertyRecord[] GetPropertyRecordArray(DependencyObject d);
    internal static LocalValueEnumerator ArrayToLocalValueEnumerator(PropertyRecord[] records);
}
internal class System.Windows.Documents.Tracing.SpellerCOMActionTraceLogger : object {
    public SpellerCOMActionTraceLogger(WinRTSpellerInterop caller, Actions action);
    private static SpellerCOMActionTraceLogger();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class System.Windows.Documents.Typography : object {
    public static DependencyProperty StandardLigaturesProperty;
    public static DependencyProperty ContextualLigaturesProperty;
    public static DependencyProperty DiscretionaryLigaturesProperty;
    public static DependencyProperty HistoricalLigaturesProperty;
    public static DependencyProperty AnnotationAlternatesProperty;
    public static DependencyProperty ContextualAlternatesProperty;
    public static DependencyProperty HistoricalFormsProperty;
    public static DependencyProperty KerningProperty;
    public static DependencyProperty CapitalSpacingProperty;
    public static DependencyProperty CaseSensitiveFormsProperty;
    public static DependencyProperty StylisticSet1Property;
    public static DependencyProperty StylisticSet2Property;
    public static DependencyProperty StylisticSet3Property;
    public static DependencyProperty StylisticSet4Property;
    public static DependencyProperty StylisticSet5Property;
    public static DependencyProperty StylisticSet6Property;
    public static DependencyProperty StylisticSet7Property;
    public static DependencyProperty StylisticSet8Property;
    public static DependencyProperty StylisticSet9Property;
    public static DependencyProperty StylisticSet10Property;
    public static DependencyProperty StylisticSet11Property;
    public static DependencyProperty StylisticSet12Property;
    public static DependencyProperty StylisticSet13Property;
    public static DependencyProperty StylisticSet14Property;
    public static DependencyProperty StylisticSet15Property;
    public static DependencyProperty StylisticSet16Property;
    public static DependencyProperty StylisticSet17Property;
    public static DependencyProperty StylisticSet18Property;
    public static DependencyProperty StylisticSet19Property;
    public static DependencyProperty StylisticSet20Property;
    public static DependencyProperty FractionProperty;
    public static DependencyProperty SlashedZeroProperty;
    public static DependencyProperty MathematicalGreekProperty;
    public static DependencyProperty EastAsianExpertFormsProperty;
    public static DependencyProperty VariantsProperty;
    public static DependencyProperty CapitalsProperty;
    public static DependencyProperty NumeralStyleProperty;
    public static DependencyProperty NumeralAlignmentProperty;
    public static DependencyProperty EastAsianWidthsProperty;
    public static DependencyProperty EastAsianLanguageProperty;
    public static DependencyProperty StandardSwashesProperty;
    public static DependencyProperty ContextualSwashesProperty;
    public static DependencyProperty StylisticAlternatesProperty;
    internal static DependencyProperty[] TypographyPropertiesList;
    internal static TypographyProperties Default;
    public bool StandardLigatures { get; public set; }
    public bool ContextualLigatures { get; public set; }
    public bool DiscretionaryLigatures { get; public set; }
    public bool HistoricalLigatures { get; public set; }
    public int AnnotationAlternates { get; public set; }
    public bool ContextualAlternates { get; public set; }
    public bool HistoricalForms { get; public set; }
    public bool Kerning { get; public set; }
    public bool CapitalSpacing { get; public set; }
    public bool CaseSensitiveForms { get; public set; }
    public bool StylisticSet1 { get; public set; }
    public bool StylisticSet2 { get; public set; }
    public bool StylisticSet3 { get; public set; }
    public bool StylisticSet4 { get; public set; }
    public bool StylisticSet5 { get; public set; }
    public bool StylisticSet6 { get; public set; }
    public bool StylisticSet7 { get; public set; }
    public bool StylisticSet8 { get; public set; }
    public bool StylisticSet9 { get; public set; }
    public bool StylisticSet10 { get; public set; }
    public bool StylisticSet11 { get; public set; }
    public bool StylisticSet12 { get; public set; }
    public bool StylisticSet13 { get; public set; }
    public bool StylisticSet14 { get; public set; }
    public bool StylisticSet15 { get; public set; }
    public bool StylisticSet16 { get; public set; }
    public bool StylisticSet17 { get; public set; }
    public bool StylisticSet18 { get; public set; }
    public bool StylisticSet19 { get; public set; }
    public bool StylisticSet20 { get; public set; }
    public FontFraction Fraction { get; public set; }
    public bool SlashedZero { get; public set; }
    public bool MathematicalGreek { get; public set; }
    public bool EastAsianExpertForms { get; public set; }
    public FontVariants Variants { get; public set; }
    public FontCapitals Capitals { get; public set; }
    public FontNumeralStyle NumeralStyle { get; public set; }
    public FontNumeralAlignment NumeralAlignment { get; public set; }
    public FontEastAsianWidths EastAsianWidths { get; public set; }
    public FontEastAsianLanguage EastAsianLanguage { get; public set; }
    public int StandardSwashes { get; public set; }
    public int ContextualSwashes { get; public set; }
    public int StylisticAlternates { get; public set; }
    internal Typography(DependencyObject owner);
    private static Typography();
    public bool get_StandardLigatures();
    public void set_StandardLigatures(bool value);
    public bool get_ContextualLigatures();
    public void set_ContextualLigatures(bool value);
    public bool get_DiscretionaryLigatures();
    public void set_DiscretionaryLigatures(bool value);
    public bool get_HistoricalLigatures();
    public void set_HistoricalLigatures(bool value);
    public int get_AnnotationAlternates();
    public void set_AnnotationAlternates(int value);
    public bool get_ContextualAlternates();
    public void set_ContextualAlternates(bool value);
    public bool get_HistoricalForms();
    public void set_HistoricalForms(bool value);
    public bool get_Kerning();
    public void set_Kerning(bool value);
    public bool get_CapitalSpacing();
    public void set_CapitalSpacing(bool value);
    public bool get_CaseSensitiveForms();
    public void set_CaseSensitiveForms(bool value);
    public bool get_StylisticSet1();
    public void set_StylisticSet1(bool value);
    public bool get_StylisticSet2();
    public void set_StylisticSet2(bool value);
    public bool get_StylisticSet3();
    public void set_StylisticSet3(bool value);
    public bool get_StylisticSet4();
    public void set_StylisticSet4(bool value);
    public bool get_StylisticSet5();
    public void set_StylisticSet5(bool value);
    public bool get_StylisticSet6();
    public void set_StylisticSet6(bool value);
    public bool get_StylisticSet7();
    public void set_StylisticSet7(bool value);
    public bool get_StylisticSet8();
    public void set_StylisticSet8(bool value);
    public bool get_StylisticSet9();
    public void set_StylisticSet9(bool value);
    public bool get_StylisticSet10();
    public void set_StylisticSet10(bool value);
    public bool get_StylisticSet11();
    public void set_StylisticSet11(bool value);
    public bool get_StylisticSet12();
    public void set_StylisticSet12(bool value);
    public bool get_StylisticSet13();
    public void set_StylisticSet13(bool value);
    public bool get_StylisticSet14();
    public void set_StylisticSet14(bool value);
    public bool get_StylisticSet15();
    public void set_StylisticSet15(bool value);
    public bool get_StylisticSet16();
    public void set_StylisticSet16(bool value);
    public bool get_StylisticSet17();
    public void set_StylisticSet17(bool value);
    public bool get_StylisticSet18();
    public void set_StylisticSet18(bool value);
    public bool get_StylisticSet19();
    public void set_StylisticSet19(bool value);
    public bool get_StylisticSet20();
    public void set_StylisticSet20(bool value);
    public FontFraction get_Fraction();
    public void set_Fraction(FontFraction value);
    public bool get_SlashedZero();
    public void set_SlashedZero(bool value);
    public bool get_MathematicalGreek();
    public void set_MathematicalGreek(bool value);
    public bool get_EastAsianExpertForms();
    public void set_EastAsianExpertForms(bool value);
    public FontVariants get_Variants();
    public void set_Variants(FontVariants value);
    public FontCapitals get_Capitals();
    public void set_Capitals(FontCapitals value);
    public FontNumeralStyle get_NumeralStyle();
    public void set_NumeralStyle(FontNumeralStyle value);
    public FontNumeralAlignment get_NumeralAlignment();
    public void set_NumeralAlignment(FontNumeralAlignment value);
    public FontEastAsianWidths get_EastAsianWidths();
    public void set_EastAsianWidths(FontEastAsianWidths value);
    public FontEastAsianLanguage get_EastAsianLanguage();
    public void set_EastAsianLanguage(FontEastAsianLanguage value);
    public int get_StandardSwashes();
    public void set_StandardSwashes(int value);
    public int get_ContextualSwashes();
    public void set_ContextualSwashes(int value);
    public int get_StylisticAlternates();
    public void set_StylisticAlternates(int value);
    public static void SetStandardLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStandardLigatures(DependencyObject element);
    public static void SetContextualLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetContextualLigatures(DependencyObject element);
    public static void SetDiscretionaryLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetDiscretionaryLigatures(DependencyObject element);
    public static void SetHistoricalLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHistoricalLigatures(DependencyObject element);
    public static void SetAnnotationAlternates(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetAnnotationAlternates(DependencyObject element);
    public static void SetContextualAlternates(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetContextualAlternates(DependencyObject element);
    public static void SetHistoricalForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHistoricalForms(DependencyObject element);
    public static void SetKerning(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetKerning(DependencyObject element);
    public static void SetCapitalSpacing(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetCapitalSpacing(DependencyObject element);
    public static void SetCaseSensitiveForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetCaseSensitiveForms(DependencyObject element);
    public static void SetStylisticSet1(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet1(DependencyObject element);
    public static void SetStylisticSet2(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet2(DependencyObject element);
    public static void SetStylisticSet3(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet3(DependencyObject element);
    public static void SetStylisticSet4(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet4(DependencyObject element);
    public static void SetStylisticSet5(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet5(DependencyObject element);
    public static void SetStylisticSet6(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet6(DependencyObject element);
    public static void SetStylisticSet7(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet7(DependencyObject element);
    public static void SetStylisticSet8(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet8(DependencyObject element);
    public static void SetStylisticSet9(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet9(DependencyObject element);
    public static void SetStylisticSet10(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet10(DependencyObject element);
    public static void SetStylisticSet11(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet11(DependencyObject element);
    public static void SetStylisticSet12(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet12(DependencyObject element);
    public static void SetStylisticSet13(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet13(DependencyObject element);
    public static void SetStylisticSet14(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet14(DependencyObject element);
    public static void SetStylisticSet15(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet15(DependencyObject element);
    public static void SetStylisticSet16(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet16(DependencyObject element);
    public static void SetStylisticSet17(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet17(DependencyObject element);
    public static void SetStylisticSet18(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet18(DependencyObject element);
    public static void SetStylisticSet19(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet19(DependencyObject element);
    public static void SetStylisticSet20(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet20(DependencyObject element);
    public static void SetFraction(DependencyObject element, FontFraction value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontFraction GetFraction(DependencyObject element);
    public static void SetSlashedZero(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetSlashedZero(DependencyObject element);
    public static void SetMathematicalGreek(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetMathematicalGreek(DependencyObject element);
    public static void SetEastAsianExpertForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetEastAsianExpertForms(DependencyObject element);
    public static void SetVariants(DependencyObject element, FontVariants value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontVariants GetVariants(DependencyObject element);
    public static void SetCapitals(DependencyObject element, FontCapitals value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontCapitals GetCapitals(DependencyObject element);
    public static void SetNumeralStyle(DependencyObject element, FontNumeralStyle value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontNumeralStyle GetNumeralStyle(DependencyObject element);
    public static void SetNumeralAlignment(DependencyObject element, FontNumeralAlignment value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontNumeralAlignment GetNumeralAlignment(DependencyObject element);
    public static void SetEastAsianWidths(DependencyObject element, FontEastAsianWidths value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontEastAsianWidths GetEastAsianWidths(DependencyObject element);
    public static void SetEastAsianLanguage(DependencyObject element, FontEastAsianLanguage value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontEastAsianLanguage GetEastAsianLanguage(DependencyObject element);
    public static void SetStandardSwashes(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetStandardSwashes(DependencyObject element);
    public static void SetContextualSwashes(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetContextualSwashes(DependencyObject element);
    public static void SetStylisticAlternates(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetStylisticAlternates(DependencyObject element);
}
internal class System.Windows.Documents.UIElementPropertyUndoUnit : object {
    public sealed virtual void Do();
    public sealed virtual bool Merge(IUndoUnit unit);
    internal static void Add(ITextContainer textContainer, UIElement uiElement, DependencyProperty property, HorizontalAlignment newValue);
    internal static void Add(ITextContainer textContainer, UIElement uiElement, DependencyProperty property, FlowDirection newValue);
}
internal enum System.Windows.Documents.ULState : Enum {
    public int value__;
    public static ULState ULNone;
    public static ULState ULNormal;
    public static ULState ULDot;
    public static ULState ULDash;
    public static ULState ULDashDot;
    public static ULState ULDashDotDot;
    public static ULState ULDouble;
    public static ULState ULHeavyWave;
    public static ULState ULLongDash;
    public static ULState ULThick;
    public static ULState ULThickDot;
    public static ULState ULThickDash;
    public static ULState ULThickDashDot;
    public static ULState ULThickDashDotDot;
    public static ULState ULThickLongDash;
    public static ULState ULDoubleWave;
    public static ULState ULWord;
    public static ULState ULWave;
}
public class System.Windows.Documents.Underline : Span {
    private static Underline();
    public Underline(Inline childInline);
    public Underline(Inline childInline, TextPointer insertionPosition);
    public Underline(TextPointer start, TextPointer end);
}
internal static class System.Windows.Documents.ValidationHelper : object {
    internal static void VerifyPosition(ITextContainer tree, ITextPointer position);
    internal static void VerifyPosition(ITextContainer container, ITextPointer position, string paramName);
    internal static void VerifyPositionPair(ITextPointer startPosition, ITextPointer endPosition);
    internal static void VerifyDirection(LogicalDirection direction, string argumentName);
    internal static void VerifyElementEdge(ElementEdge edge, string param);
    internal static void ValidateChild(TextPointer position, object child, string paramName);
}
internal static class System.Windows.Documents.Validators : object {
    internal static bool IsValidFontSize(long fs);
    internal static bool IsValidWidthType(long wt);
    internal static long MakeValidShading(long s);
    internal static long MakeValidBorderWidth(long w);
}
internal enum System.Windows.Documents.VAlign : Enum {
    public int value__;
    public static VAlign AlignTop;
    public static VAlign AlignCenter;
    public static VAlign AlignBottom;
}
internal enum System.Windows.Documents.WidthType : Enum {
    public int value__;
    public static WidthType WidthIgnore;
    public static WidthType WidthAuto;
    public static WidthType WidthPercent;
    public static WidthType WidthTwips;
}
internal class System.Windows.Documents.WinEventHandler : object {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal WinEventHandler(int eventMin, int eventMax);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Clear();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Start();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Stop();
}
internal class System.Windows.Documents.WinRTSpellerInterop : SpellerInteropBase {
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    protected virtual override void Finalize();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void SetLocale(CultureInfo culture);
    internal virtual void set_Mode(SpellerMode value);
    internal virtual void set_MultiWordMode(bool value);
    internal virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal virtual bool CanSpellCheck(CultureInfo culture);
    [SecuritySafeCriticalAttribute]
internal virtual void UnloadDictionary(object token);
    internal virtual object LoadDictionary(string lexiconFilePath);
    [SecuritySafeCriticalAttribute]
internal virtual object LoadDictionary(Uri item, string trustedFolder);
    internal virtual void ReleaseAllLexicons();
    internal virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
}
internal class System.Windows.Documents.WpfPayload : object {
    internal static string ImageBmpContentType;
    public Package Package { get; }
    internal static string SaveRange(ITextRange range, Stream& stream, bool useFlowDocumentAsRoot);
    internal static string SaveRange(ITextRange range, Stream& stream, bool useFlowDocumentAsRoot, bool preserveTextElements);
    [SecurityCriticalAttribute]
internal static MemoryStream SaveImage(BitmapSource bitmapSource, string imageContentType);
    internal static object LoadElement(Stream stream);
    public Package get_Package();
    internal string AddImage(Image image);
    internal Stream CreateXamlStream();
    internal Stream CreateImageStream(int imageCount, string contentType, String& imagePartUriString);
    internal Stream GetImageStream(string imageSourceString);
    internal static WpfPayload CreateWpfPayload(Stream stream);
    internal static WpfPayload OpenWpfPayload(Stream stream);
}
internal enum System.Windows.Documents.XamlAttribute : Enum {
    public int value__;
    public static XamlAttribute XAUnknown;
    public static XamlAttribute XAFontWeight;
    public static XamlAttribute XAFontSize;
    public static XamlAttribute XAFontStyle;
    public static XamlAttribute XAFontFamily;
    public static XamlAttribute XAFontStretch;
    public static XamlAttribute XABackground;
    public static XamlAttribute XAForeground;
    public static XamlAttribute XAFlowDirection;
    public static XamlAttribute XATextDecorations;
    public static XamlAttribute XATextAlignment;
    public static XamlAttribute XAMarkerStyle;
    public static XamlAttribute XATextIndent;
    public static XamlAttribute XAColumnSpan;
    public static XamlAttribute XARowSpan;
    public static XamlAttribute XAStartIndex;
    public static XamlAttribute XAMarkerOffset;
    public static XamlAttribute XABorderThickness;
    public static XamlAttribute XABorderBrush;
    public static XamlAttribute XAPadding;
    public static XamlAttribute XAMargin;
    public static XamlAttribute XAKeepTogether;
    public static XamlAttribute XAKeepWithNext;
    public static XamlAttribute XABaselineAlignment;
    public static XamlAttribute XABaselineOffset;
    public static XamlAttribute XANavigateUri;
    public static XamlAttribute XATargetName;
    public static XamlAttribute XALineHeight;
    public static XamlAttribute XALocation;
    public static XamlAttribute XAWidth;
    public static XamlAttribute XAHeight;
    public static XamlAttribute XASource;
    public static XamlAttribute XAUriSource;
    public static XamlAttribute XAStretch;
    public static XamlAttribute XAStretchDirection;
    public static XamlAttribute XACellSpacing;
    public static XamlAttribute XATypographyVariants;
    public static XamlAttribute XALang;
}
internal class System.Windows.Documents.XamlRtfConverter : object {
    internal static int RtfCodePage;
    internal bool ForceParagraph { get; internal set; }
    internal WpfPayload WpfPayload { get; internal set; }
    internal string ConvertXamlToRtf(string xamlContent);
    internal string ConvertRtfToXaml(string rtfContent);
    internal bool get_ForceParagraph();
    internal void set_ForceParagraph(bool value);
    internal WpfPayload get_WpfPayload();
    internal void set_WpfPayload(WpfPayload value);
}
internal enum System.Windows.Documents.XamlTokenType : Enum {
    public int value__;
    public static XamlTokenType XTokInvalid;
    public static XamlTokenType XTokEOF;
    public static XamlTokenType XTokCharacters;
    public static XamlTokenType XTokEntity;
    public static XamlTokenType XTokStartElement;
    public static XamlTokenType XTokEndElement;
    public static XamlTokenType XTokCData;
    public static XamlTokenType XTokPI;
    public static XamlTokenType XTokComment;
    public static XamlTokenType XTokWS;
}
internal enum System.Windows.Documents.XamlToRtfError : Enum {
    public int value__;
    public static XamlToRtfError None;
    public static XamlToRtfError InvalidFormat;
    public static XamlToRtfError InvalidParameter;
    public static XamlToRtfError InsufficientMemory;
    public static XamlToRtfError OutOfRange;
    public static XamlToRtfError Unknown;
}
internal class System.Windows.Documents.XamlToRtfParser : object {
    internal XamlToRtfParser(string xaml);
    internal XamlToRtfError Parse();
    internal void SetCallbacks(IXamlContentHandler xamlContent, IXamlErrorHandler xamlError);
}
internal class System.Windows.Documents.XamlToRtfWriter : object {
    internal string Output { get; }
    internal bool GenerateListTables { get; }
    unknown WpfPayload WpfPayload {internal set; }
    internal ConverterState ConverterState { get; }
    internal XamlToRtfWriter(string xaml);
    internal XamlToRtfError Process();
    internal string get_Output();
    internal bool get_GenerateListTables();
    internal void set_WpfPayload(WpfPayload value);
    internal ConverterState get_ConverterState();
}
internal class System.Windows.Documents.XpsDocStructSchema : XpsSchema {
    public string RootNamespaceUri { get; }
    private static XpsDocStructSchema();
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
}
internal class System.Windows.Documents.XpsS0FixedPageSchema : XpsS0Schema {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual void ValidateRelationships(SecurityCriticalData`1<Package> package, Uri packageUri, Uri partUri, ContentType mimeType);
}
internal class System.Windows.Documents.XpsS0ResourceDictionarySchema : XpsS0Schema {
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
}
internal class System.Windows.Documents.XpsS0Schema : XpsSchema {
    protected static ContentType _fontContentType;
    protected static ContentType _colorContextContentType;
    protected static ContentType _obfuscatedContentType;
    protected static ContentType _jpgContentType;
    protected static ContentType _pngContentType;
    protected static ContentType _tifContentType;
    protected static ContentType _wmpContentType;
    protected static ContentType _fixedDocumentSequenceContentType;
    protected static ContentType _fixedDocumentContentType;
    protected static ContentType _fixedPageContentType;
    protected static ContentType _resourceDictionaryContentType;
    protected static ContentType _printTicketContentType;
    protected static ContentType _discardControlContentType;
    public string RootNamespaceUri { get; }
    private static XpsS0Schema();
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual bool HasRequiredResources(ContentType mimeType);
    public virtual bool HasUriAttributes(ContentType mimeType);
    public virtual bool AllowsMultipleReferencesToSameUri(ContentType mimeType);
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
}
internal class System.Windows.Documents.XpsSchema : object {
    public string RootNamespaceUri { get; }
    private static XpsSchema();
    protected static void RegisterSchema(XpsSchema schema, ContentType[] handledMimeTypes);
    protected void RegisterRequiredResourceMimeTypes(ContentType[] requiredResourceMimeTypes);
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual void ValidateRelationships(SecurityCriticalData`1<Package> package, Uri packageUri, Uri partUri, ContentType mimeType);
    public virtual bool HasRequiredResources(ContentType mimeType);
    public virtual bool HasUriAttributes(ContentType mimeType);
    public virtual bool AllowsMultipleReferencesToSameUri(ContentType mimeType);
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
    public bool IsValidRequiredResourceMimeType(ContentType mimeType);
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
    public static XpsSchema GetSchema(ContentType mimeType);
}
internal class System.Windows.Documents.XpsSchemaValidator : object {
    public XmlReader XmlReader { get; }
    public XpsSchemaValidator(XpsValidatingLoader loader, XpsSchema schema, ContentType mimeType, Stream objectStream, Uri packageUri, Uri baseUri);
    private static XpsSchemaValidator();
    public XmlReader get_XmlReader();
}
internal class System.Windows.Documents.XpsValidatingLoader : object {
    internal static bool DocumentMode { get; }
    private static XpsValidatingLoader();
    internal object Load(Stream stream, Uri parentUri, ParserContext pc, ContentType mimeType);
    internal void Validate(Stream stream, Uri parentUri, ParserContext pc, ContentType mimeType, string rootElement);
    internal static bool get_DocumentMode();
    internal static void AssertDocumentMode();
    internal void UriHitHandler(int node, Uri uri);
}
public class System.Windows.Documents.ZoomPercentageConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[TypeConverterAttribute("System.Windows.DynamicResourceExtensionConverter")]
[MarkupExtensionReturnTypeAttribute("System.Object")]
public class System.Windows.DynamicResourceExtension : MarkupExtension {
    [ConstructorArgumentAttribute("resourceKey")]
public object ResourceKey { get; public set; }
    public DynamicResourceExtension(object resourceKey);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public object get_ResourceKey();
    public void set_ResourceKey(object value);
}
public class System.Windows.DynamicResourceExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.EventSetter : SetterBase {
    public RoutedEvent Event { get; public set; }
    [TypeConverterAttribute("System.Windows.Markup.EventSetterHandlerConverter")]
public Delegate Handler { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool HandledEventsToo { get; public set; }
    public EventSetter(RoutedEvent routedEvent, Delegate handler);
    public RoutedEvent get_Event();
    public void set_Event(RoutedEvent value);
    public Delegate get_Handler();
    public void set_Handler(Delegate value);
    public bool get_HandledEventsToo();
    public void set_HandledEventsToo(bool value);
    internal virtual void Seal();
}
[ContentPropertyAttribute("Actions")]
public class System.Windows.EventTrigger : TriggerBase {
    internal static UncommonField`1<TriggerCollection> TriggerCollectionField;
    public RoutedEvent RoutedEvent { get; public set; }
    [DefaultValueAttribute("")]
public string SourceName { get; public set; }
    internal int TriggerChildIndex { get; internal set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection Actions { get; }
    public EventTrigger(RoutedEvent routedEvent);
    private static EventTrigger();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    public string get_SourceName();
    public void set_SourceName(string value);
    internal int get_TriggerChildIndex();
    internal void set_TriggerChildIndex(int value);
    public TriggerActionCollection get_Actions();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeActions();
    internal sealed virtual void Seal();
    internal static void ProcessTriggerCollection(FrameworkElement triggersHost);
    internal static void ProcessOneTrigger(FrameworkElement triggersHost, TriggerBase triggerBase);
    internal static void DisconnectAllTriggers(FrameworkElement triggersHost);
    internal static void DisconnectOneTrigger(FrameworkElement triggersHost, TriggerBase triggerBase);
}
public class System.Windows.ExceptionRoutedEventArgs : RoutedEventArgs {
    public Exception ErrorException { get; }
    internal ExceptionRoutedEventArgs(RoutedEvent routedEvent, object sender, Exception errorException);
    public Exception get_ErrorException();
}
public class System.Windows.ExitEventArgs : EventArgs {
    internal int _exitCode;
    public int ApplicationExitCode { get; public set; }
    internal ExitEventArgs(int exitCode);
    public int get_ApplicationExitCode();
    public void set_ApplicationExitCode(int value);
}
public class System.Windows.ExitEventHandler : MulticastDelegate {
    public ExitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.FigureHorizontalAnchor : Enum {
    public int value__;
    public static FigureHorizontalAnchor PageLeft;
    public static FigureHorizontalAnchor PageCenter;
    public static FigureHorizontalAnchor PageRight;
    public static FigureHorizontalAnchor ContentLeft;
    public static FigureHorizontalAnchor ContentCenter;
    public static FigureHorizontalAnchor ContentRight;
    public static FigureHorizontalAnchor ColumnLeft;
    public static FigureHorizontalAnchor ColumnCenter;
    public static FigureHorizontalAnchor ColumnRight;
}
[TypeConverterAttribute("System.Windows.FigureLengthConverter")]
public class System.Windows.FigureLength : ValueType {
    private double _unitValue;
    private FigureUnitType _unitType;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsColumn { get; }
    public bool IsContent { get; }
    public bool IsPage { get; }
    public double Value { get; }
    public FigureUnitType FigureUnitType { get; }
    public FigureLength(double pixels);
    public FigureLength(double value, FigureUnitType type);
    public static bool op_Equality(FigureLength fl1, FigureLength fl2);
    public static bool op_Inequality(FigureLength fl1, FigureLength fl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(FigureLength figureLength);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsColumn();
    public bool get_IsContent();
    public bool get_IsPage();
    public double get_Value();
    public FigureUnitType get_FigureUnitType();
    public virtual string ToString();
}
public class System.Windows.FigureLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(FigureLength fl, CultureInfo cultureInfo);
    internal static FigureLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.FigureUnitType : Enum {
    public int value__;
    public static FigureUnitType Auto;
    public static FigureUnitType Pixel;
    public static FigureUnitType Column;
    public static FigureUnitType Content;
    public static FigureUnitType Page;
}
public enum System.Windows.FigureVerticalAnchor : Enum {
    public int value__;
    public static FigureVerticalAnchor PageTop;
    public static FigureVerticalAnchor PageCenter;
    public static FigureVerticalAnchor PageBottom;
    public static FigureVerticalAnchor ContentTop;
    public static FigureVerticalAnchor ContentCenter;
    public static FigureVerticalAnchor ContentBottom;
    public static FigureVerticalAnchor ParagraphTop;
}
public class System.Windows.FontSizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static void FromString(string text, CultureInfo culture, Double& amount);
}
public static class System.Windows.FrameworkCompatibilityPreferences : object {
    internal static bool TargetsDesktop_V4_0 { get; }
    public static bool AreInactiveSelectionHighlightBrushKeysSupported { get; public set; }
    public static bool KeepTextBoxDisplaySynchronizedWithTextProperty { get; public set; }
    internal static HandleBindingOptions HandleTwoWayBindingToPropertyWithNonPublicSetter { get; internal set; }
    internal static bool UseSetWindowPosForTopmostWindows { get; internal set; }
    internal static bool VSP45Compat { get; internal set; }
    public static bool ShouldThrowOnCopyOrCutFailure { get; public set; }
    private static FrameworkCompatibilityPreferences();
    internal static bool get_TargetsDesktop_V4_0();
    public static bool get_AreInactiveSelectionHighlightBrushKeysSupported();
    public static void set_AreInactiveSelectionHighlightBrushKeysSupported(bool value);
    internal static bool GetAreInactiveSelectionHighlightBrushKeysSupported();
    public static bool get_KeepTextBoxDisplaySynchronizedWithTextProperty();
    public static void set_KeepTextBoxDisplaySynchronizedWithTextProperty(bool value);
    internal static bool GetKeepTextBoxDisplaySynchronizedWithTextProperty();
    internal static HandleBindingOptions get_HandleTwoWayBindingToPropertyWithNonPublicSetter();
    internal static void set_HandleTwoWayBindingToPropertyWithNonPublicSetter(HandleBindingOptions value);
    internal static HandleBindingOptions GetHandleTwoWayBindingToPropertyWithNonPublicSetter();
    internal static bool get_UseSetWindowPosForTopmostWindows();
    internal static void set_UseSetWindowPosForTopmostWindows(bool value);
    internal static bool GetUseSetWindowPosForTopmostWindows();
    internal static bool get_VSP45Compat();
    internal static void set_VSP45Compat(bool value);
    internal static bool GetVSP45Compat();
    internal static string GetScrollingTraceTarget();
    internal static string GetScrollingTraceFile();
    public static bool get_ShouldThrowOnCopyOrCutFailure();
    public static void set_ShouldThrowOnCopyOrCutFailure(bool value);
    internal static bool GetShouldThrowOnCopyOrCutFailure();
}
[StyleTypedPropertyAttribute]
[XmlLangPropertyAttribute("Language")]
[UsableDuringInitializationAttribute("True")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.FrameworkContentElement : ContentElement {
    internal static NumberSubstitution DefaultNumberSubstitution;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StyleProperty;
    public static DependencyProperty OverridesDefaultStyleProperty;
    protected internal static DependencyProperty DefaultStyleKeyProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty LanguageProperty;
    public static DependencyProperty FocusVisualStyleProperty;
    public static DependencyProperty CursorProperty;
    public static DependencyProperty ForceCursorProperty;
    public static DependencyProperty InputScopeProperty;
    public static DependencyProperty DataContextProperty;
    public static DependencyProperty BindingGroupProperty;
    public static RoutedEvent LoadedEvent;
    public static RoutedEvent UnloadedEvent;
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty ContextMenuProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    internal DependencyObject _templatedParent;
    internal static DependencyObjectType DType;
    public Style Style { get; public set; }
    public bool OverridesDefaultStyle { get; public set; }
    protected internal object DefaultStyleKey { get; protected internal set; }
    internal Style ThemeStyle { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public DependencyObject TemplatedParent { get; }
    internal bool HasResources { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    [MergablePropertyAttribute("False")]
[LocalizabilityAttribute("17")]
public string Name { get; public set; }
    public object Tag { get; public set; }
    public XmlLanguage Language { get; public set; }
    public Style FocusVisualStyle { get; public set; }
    public Cursor Cursor { get; public set; }
    public bool ForceCursor { get; public set; }
    public InputScope InputScope { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public object DataContext { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public BindingGroup BindingGroup { get; public set; }
    internal InheritanceBehavior InheritanceBehavior { get; internal set; }
    [EditorBrowsableAttribute("2")]
public bool IsInitialized { get; }
    public bool IsLoaded { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public object ToolTip { get; public set; }
    public ContextMenu ContextMenu { get; public set; }
    internal bool HasResourceReference { get; internal set; }
    internal bool IsLogicalChildrenIterationInProgress { get; internal set; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal bool IsLoadedCache { get; internal set; }
    internal bool IsParentAnFE { get; internal set; }
    internal bool IsTemplatedParentAnFE { get; internal set; }
    internal bool HasLogicalChildren { get; internal set; }
    internal int TemplateChildIndex { get; internal set; }
    internal bool IsRequestingExpression { get; internal set; }
    public DependencyObject Parent { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool HasFefLoadedChangeHandler { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsStyleUpdateInProgress { get; internal set; }
    internal bool IsThemeStyleUpdateInProgress { get; internal set; }
    internal bool StoresParentTemplateValues { get; internal set; }
    internal bool HasNumberSubstitutionChanged { get; internal set; }
    internal bool HasTemplateGeneratedSubTree { get; internal set; }
    internal bool HasImplicitStyleFromResources { get; internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal bool HasStyleChanged { get; internal set; }
    internal bool HasStyleInvalidated { get; internal set; }
    internal bool HasStyleEverBeenFetched { get; internal set; }
    internal bool HasLocalStyle { get; internal set; }
    internal bool HasThemeStyleEverBeenFetched { get; internal set; }
    internal bool AncestorChangeInProgress { get; internal set; }
    internal FrugalObjectList`1<DependencyProperty> InheritableProperties { get; internal set; }
    internal Object[] LoadedPending { get; }
    internal Object[] UnloadedPending { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool PotentiallyHasMentees { get; internal set; }
    private static FrameworkContentElement();
    public Style get_Style();
    public void set_Style(Style value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeStyle();
    protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle);
    public bool get_OverridesDefaultStyle();
    public void set_OverridesDefaultStyle(bool value);
    protected internal object get_DefaultStyleKey();
    protected internal void set_DefaultStyleKey(object value);
    internal Style get_ThemeStyle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnThemeStyleChanged(DependencyObject d, object oldValue, object newValue);
    public DependencyObject get_TemplatedParent();
    internal bool get_HasResources();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources();
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    public void SetResourceReference(DependencyProperty dp, object name);
    public void BeginStoryboard(Storyboard storyboard);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable);
    internal sealed virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal void GetRawValue(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    internal Expression GetExpressionCore(DependencyProperty dp, PropertyMetadata metadata);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public Style get_FocusVisualStyle();
    public void set_FocusVisualStyle(Style value);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    public bool get_ForceCursor();
    public void set_ForceCursor(bool value);
    public sealed virtual bool MoveFocus(TraversalRequest request);
    public sealed virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    public void BringIntoView();
    public InputScope get_InputScope();
    public void set_InputScope(InputScope value);
    public void add_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public void remove_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public object get_DataContext();
    public void set_DataContext(object value);
    public BindingExpression GetBindingExpression(DependencyProperty dp);
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding);
    public BindingExpression SetBinding(DependencyProperty dp, string path);
    public BindingGroup get_BindingGroup();
    public void set_BindingGroup(BindingGroup value);
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    internal virtual void AdjustBranchSource(RoutedEventArgs args);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs args);
    internal sealed virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal virtual void OnAncestorChanged();
    internal virtual void OnContentParentChanged(DependencyObject oldParent);
    internal InheritanceBehavior get_InheritanceBehavior();
    internal void set_InheritanceBehavior(InheritanceBehavior value);
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool get_IsInitialized();
    public void add_Initialized(EventHandler value);
    public void remove_Initialized(EventHandler value);
    protected virtual void OnInitialized(EventArgs e);
    public bool get_IsLoaded();
    public void add_Loaded(RoutedEventHandler value);
    public void remove_Loaded(RoutedEventHandler value);
    internal void OnLoaded(RoutedEventArgs args);
    public void add_Unloaded(RoutedEventHandler value);
    public void remove_Unloaded(RoutedEventHandler value);
    internal void OnUnloaded(RoutedEventArgs args);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal void RaiseClrEvent(EventPrivateKey key, EventArgs args);
    public object get_ToolTip();
    public void set_ToolTip(object value);
    public ContextMenu get_ContextMenu();
    public void set_ContextMenu(ContextMenu value);
    public void add_ToolTipOpening(ToolTipEventHandler value);
    public void remove_ToolTipOpening(ToolTipEventHandler value);
    protected virtual void OnToolTipOpening(ToolTipEventArgs e);
    public void add_ToolTipClosing(ToolTipEventHandler value);
    public void remove_ToolTipClosing(ToolTipEventHandler value);
    protected virtual void OnToolTipClosing(ToolTipEventArgs e);
    public void add_ContextMenuOpening(ContextMenuEventHandler value);
    public void remove_ContextMenuOpening(ContextMenuEventHandler value);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    public void add_ContextMenuClosing(ContextMenuEventHandler value);
    public void remove_ContextMenuClosing(ContextMenuEventHandler value);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    internal bool get_HasResourceReference();
    internal void set_HasResourceReference(bool value);
    internal bool get_IsLogicalChildrenIterationInProgress();
    internal void set_IsLogicalChildrenIterationInProgress(bool value);
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal bool get_IsLoadedCache();
    internal void set_IsLoadedCache(bool value);
    internal bool get_IsParentAnFE();
    internal void set_IsParentAnFE(bool value);
    internal bool get_IsTemplatedParentAnFE();
    internal void set_IsTemplatedParentAnFE(bool value);
    internal bool get_HasLogicalChildren();
    internal void set_HasLogicalChildren(bool value);
    internal int get_TemplateChildIndex();
    internal void set_TemplateChildIndex(int value);
    internal bool get_IsRequestingExpression();
    internal void set_IsRequestingExpression(bool value);
    internal bool ReadInternalFlag(InternalFlags reqFlag);
    internal bool ReadInternalFlag2(InternalFlags2 reqFlag);
    internal void WriteInternalFlag(InternalFlags reqFlag, bool set);
    internal void WriteInternalFlag2(InternalFlags2 reqFlag, bool set);
    public DependencyObject get_Parent();
    public void RegisterName(string name, object scopedElement);
    public void UnregisterName(string name);
    public object FindName(string name);
    internal object FindName(string name, DependencyObject& scopeOwner);
    public void UpdateDefaultStyle();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal object FindResourceOnSelf(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal DependencyObject ContextVerifiedGetParent();
    protected internal void AddLogicalChild(object child);
    protected internal void RemoveLogicalChild(object child);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal virtual void OnNewParent(DependencyObject newParent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnAncestorChangedInternal(TreeChangeInfo parentTreeState);
    internal FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo parentTreeState, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_HasFefLoadedChangeHandler();
    internal void UpdateStyleProperty();
    internal void UpdateThemeStyleProperty();
    internal virtual void OnThemeChanged();
    internal void FireLoadedOnDescendentsInternal();
    internal void FireUnloadedOnDescendentsInternal();
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    internal void RaiseInheritedPropertyChangedEvent(InheritablePropertyChangeInfo& info);
    internal bool get_IsStyleUpdateInProgress();
    internal void set_IsStyleUpdateInProgress(bool value);
    internal bool get_IsThemeStyleUpdateInProgress();
    internal void set_IsThemeStyleUpdateInProgress(bool value);
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal bool get_HasNumberSubstitutionChanged();
    internal void set_HasNumberSubstitutionChanged(bool value);
    internal bool get_HasTemplateGeneratedSubTree();
    internal void set_HasTemplateGeneratedSubTree(bool value);
    internal bool get_HasImplicitStyleFromResources();
    internal void set_HasImplicitStyleFromResources(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal bool get_HasStyleChanged();
    internal void set_HasStyleChanged(bool value);
    internal bool get_HasStyleInvalidated();
    internal void set_HasStyleInvalidated(bool value);
    internal bool get_HasStyleEverBeenFetched();
    internal void set_HasStyleEverBeenFetched(bool value);
    internal bool get_HasLocalStyle();
    internal void set_HasLocalStyle(bool value);
    internal bool get_HasThemeStyleEverBeenFetched();
    internal void set_HasThemeStyleEverBeenFetched(bool value);
    internal bool get_AncestorChangeInProgress();
    internal void set_AncestorChangeInProgress(bool value);
    internal FrugalObjectList`1<DependencyProperty> get_InheritableProperties();
    internal void set_InheritableProperties(FrugalObjectList`1<DependencyProperty> value);
    internal Object[] get_LoadedPending();
    internal Object[] get_UnloadedPending();
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool get_PotentiallyHasMentees();
    internal void set_PotentiallyHasMentees(bool value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
}
internal class System.Windows.FrameworkContextData : object {
    public static FrameworkContextData From(Dispatcher context);
    public void AddWalker(object data, DescendentsWalkerBase walker);
    public void RemoveWalker(object data, DescendentsWalkerBase walker);
    public bool WasNodeVisited(DependencyObject d, object data);
}
[StyleTypedPropertyAttribute]
[XmlLangPropertyAttribute("Language")]
[UsableDuringInitializationAttribute("True")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.FrameworkElement : UIElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StyleProperty;
    public static DependencyProperty OverridesDefaultStyleProperty;
    public static DependencyProperty UseLayoutRoundingProperty;
    protected internal static DependencyProperty DefaultStyleKeyProperty;
    internal static NumberSubstitution DefaultNumberSubstitution;
    public static DependencyProperty DataContextProperty;
    internal static EventPrivateKey DataContextChangedKey;
    public static DependencyProperty BindingGroupProperty;
    public static DependencyProperty LanguageProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty NameProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty InputScopeProperty;
    public static RoutedEvent RequestBringIntoViewEvent;
    public static RoutedEvent SizeChangedEvent;
    public static DependencyProperty ActualWidthProperty;
    public static DependencyProperty ActualHeightProperty;
    public static DependencyProperty LayoutTransformProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty WidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinWidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaxWidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinHeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaxHeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FlowDirectionProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MarginProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalAlignmentProperty;
    public static DependencyProperty FocusVisualStyleProperty;
    public static DependencyProperty CursorProperty;
    public static DependencyProperty ForceCursorProperty;
    internal static EventPrivateKey InitializedKey;
    internal static DependencyPropertyKey LoadedPendingPropertyKey;
    internal static DependencyProperty LoadedPendingProperty;
    internal static DependencyPropertyKey UnloadedPendingPropertyKey;
    internal static DependencyProperty UnloadedPendingProperty;
    public static RoutedEvent LoadedEvent;
    public static RoutedEvent UnloadedEvent;
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty ContextMenuProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    internal static UncommonField`1<ResourceDictionary> ResourcesField;
    internal DependencyObject _templatedParent;
    internal static DependencyObjectType UIElementDType;
    internal static EventPrivateKey ResourcesChangedKey;
    internal static EventPrivateKey InheritedPropertyChangedKey;
    internal static DependencyObjectType DType;
    public Style Style { get; public set; }
    public bool OverridesDefaultStyle { get; public set; }
    public bool UseLayoutRounding { get; public set; }
    protected internal object DefaultStyleKey { get; protected internal set; }
    internal Style ThemeStyle { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerCollection Triggers { get; }
    public DependencyObject TemplatedParent { get; }
    internal bool IsTemplateRoot { get; }
    internal UIElement TemplateChild { get; internal set; }
    internal FrameworkElement StateGroupsRoot { get; }
    protected int VisualChildrenCount { get; }
    internal bool HasResources { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    protected internal InheritanceBehavior InheritanceBehavior { get; protected internal set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public object DataContext { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public BindingGroup BindingGroup { get; public set; }
    public XmlLanguage Language { get; public set; }
    [LocalizabilityAttribute("17")]
[MergablePropertyAttribute("False")]
[DesignerSerializationOptionsAttribute("1")]
public string Name { get; public set; }
    [LocalizabilityAttribute("17")]
public object Tag { get; public set; }
    public InputScope InputScope { get; public set; }
    public double ActualWidth { get; }
    public double ActualHeight { get; }
    public Transform LayoutTransform { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double Width { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MinWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MaxWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double Height { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MinHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MaxHeight { get; public set; }
    [LocalizabilityAttribute("0")]
public FlowDirection FlowDirection { get; public set; }
    public Thickness Margin { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    internal static Style DefaultFocusVisualStyle { get; }
    public Style FocusVisualStyle { get; public set; }
    public Cursor Cursor { get; public set; }
    public bool ForceCursor { get; public set; }
    [EditorBrowsableAttribute("2")]
public bool IsInitialized { get; }
    public bool IsLoaded { get; }
    internal static PopupControlService PopupControlService { get; }
    internal static KeyboardNavigation KeyboardNavigation { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("10")]
public object ToolTip { get; public set; }
    public ContextMenu ContextMenu { get; public set; }
    internal bool HasResourceReference { get; internal set; }
    internal bool IsLogicalChildrenIterationInProgress { get; internal set; }
    internal bool InVisibilityCollapsedTree { get; internal set; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal bool IsLoadedCache { get; internal set; }
    internal bool IsParentAnFE { get; internal set; }
    internal bool IsTemplatedParentAnFE { get; internal set; }
    internal bool HasLogicalChildren { get; internal set; }
    internal bool IsRightToLeft { get; internal set; }
    internal int TemplateChildIndex { get; internal set; }
    internal bool IsRequestingExpression { get; internal set; }
    internal bool BypassLayoutPolicies { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    public DependencyObject Parent { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool HasFefLoadedChangeHandler { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsStyleUpdateInProgress { get; internal set; }
    internal bool IsThemeStyleUpdateInProgress { get; internal set; }
    internal bool StoresParentTemplateValues { get; internal set; }
    internal bool HasNumberSubstitutionChanged { get; internal set; }
    internal bool HasTemplateGeneratedSubTree { get; internal set; }
    internal bool HasImplicitStyleFromResources { get; internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal bool HasStyleChanged { get; internal set; }
    internal bool HasTemplateChanged { get; internal set; }
    internal bool HasStyleInvalidated { get; internal set; }
    internal bool HasStyleEverBeenFetched { get; internal set; }
    internal bool HasLocalStyle { get; internal set; }
    internal bool HasThemeStyleEverBeenFetched { get; internal set; }
    internal bool AncestorChangeInProgress { get; internal set; }
    internal FrugalObjectList`1<DependencyProperty> InheritableProperties { get; internal set; }
    internal Object[] LoadedPending { get; }
    internal Object[] UnloadedPending { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool PotentiallyHasMentees { get; internal set; }
    private static FrameworkElement();
    public Style get_Style();
    public void set_Style(Style value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeStyle();
    public bool get_OverridesDefaultStyle();
    public void set_OverridesDefaultStyle(bool value);
    public bool get_UseLayoutRounding();
    public void set_UseLayoutRounding(bool value);
    protected internal object get_DefaultStyleKey();
    protected internal void set_DefaultStyleKey(object value);
    internal Style get_ThemeStyle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnThemeStyleChanged(DependencyObject d, object oldValue, object newValue);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle);
    protected internal virtual void ParentLayoutInvalidated(UIElement child);
    public bool ApplyTemplate();
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    internal virtual void OnPostApplyTemplate();
    public void BeginStoryboard(Storyboard storyboard);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable);
    internal static FrameworkElement FindNamedFrameworkElement(FrameworkElement startElement, string targetName);
    public TriggerCollection get_Triggers();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTriggers();
    public DependencyObject get_TemplatedParent();
    internal bool get_IsTemplateRoot();
    internal virtual UIElement get_TemplateChild();
    internal virtual void set_TemplateChild(UIElement value);
    internal virtual FrameworkElement get_StateGroupsRoot();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal bool get_HasResources();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources();
    protected internal DependencyObject GetTemplateChild(string childName);
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    internal static object FindImplicitStyleResource(FrameworkElement fe, object resourceKey, Object& source);
    internal static object FindImplicitStyleResource(FrameworkContentElement fce, object resourceKey, Object& source);
    internal static object FindResourceInternal(FrameworkElement fe, FrameworkContentElement fce, object resourceKey);
    internal static object FindResourceFromAppOrSystem(object resourceKey, Object& source, bool disableThrowOnResourceNotFound, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal static object FindResourceInternal(FrameworkElement fe, FrameworkContentElement fce, DependencyProperty dp, object resourceKey, object unlinkedParent, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, DependencyObject boundaryElement, bool isImplicitStyleLookup, Object& source);
    internal static object FindResourceInTree(FrameworkElement feStart, FrameworkContentElement fceStart, DependencyProperty dp, object resourceKey, object unlinkedParent, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, DependencyObject boundaryElement, InheritanceBehavior& inheritanceBehavior, Object& source);
    internal static object FindTemplateResourceInternal(DependencyObject target, object item, Type templateType);
    internal bool HasNonDefaultValue(DependencyProperty dp);
    internal static INameScope FindScope(DependencyObject d);
    internal static INameScope FindScope(DependencyObject d, DependencyObject& scopeOwner);
    public void SetResourceReference(DependencyProperty dp, object name);
    internal sealed virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal void GetRawValue(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    internal Expression GetExpressionCore(DependencyProperty dp, PropertyMetadata metadata);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal static DependencyObject GetFrameworkParent(object current);
    internal static bool GetFrameworkParent(FrameworkElement current, FrameworkElement& feParent, FrameworkContentElement& fceParent);
    internal static bool GetFrameworkParent(FrameworkContentElement current, FrameworkElement& feParent, FrameworkContentElement& fceParent);
    internal static bool GetContainingFrameworkElement(DependencyObject current, FrameworkElement& fe, FrameworkContentElement& fce);
    internal static void GetTemplatedParentChildRecord(DependencyObject templatedParent, int childIndex, ChildRecord& childRecord, Boolean& isChildRecordValid);
    internal virtual string GetPlainText();
    internal virtual void pushTextRenderingMode();
    internal virtual void OnAncestorChanged();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    protected internal InheritanceBehavior get_InheritanceBehavior();
    protected internal void set_InheritanceBehavior(InheritanceBehavior value);
    public void add_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public void remove_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public object get_DataContext();
    public void set_DataContext(object value);
    public BindingExpression GetBindingExpression(DependencyProperty dp);
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding);
    public BindingExpression SetBinding(DependencyProperty dp, string path);
    public BindingGroup get_BindingGroup();
    public void set_BindingGroup(BindingGroup value);
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    internal virtual void AdjustBranchSource(RoutedEventArgs args);
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal bool BuildRouteCoreHelper(EventRoute route, RoutedEventArgs args, bool shouldAddIntermediateElementsToRoute);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    internal static void AddStyleHandlersToEventRoute(FrameworkElement fe, FrameworkContentElement fce, EventRoute route, RoutedEventArgs args);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    internal bool InvalidateAutomationAncestorsCoreHelper(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree, bool shouldInvalidateIntermediateElements);
    internal static bool InvalidateAutomationIntermediateElements(DependencyObject mergePoint, DependencyObject modelTreeNode);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public InputScope get_InputScope();
    public void set_InputScope(InputScope value);
    public void add_RequestBringIntoView(RequestBringIntoViewEventHandler value);
    public void remove_RequestBringIntoView(RequestBringIntoViewEventHandler value);
    public void BringIntoView();
    public void BringIntoView(Rect targetRectangle);
    public void add_SizeChanged(SizeChangedEventHandler value);
    public void remove_SizeChanged(SizeChangedEventHandler value);
    public double get_ActualWidth();
    public double get_ActualHeight();
    public Transform get_LayoutTransform();
    public void set_LayoutTransform(Transform value);
    public sealed virtual double get_Width();
    public sealed virtual void set_Width(double value);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public sealed virtual double get_Height();
    public sealed virtual void set_Height(double value);
    public double get_MinHeight();
    public void set_MinHeight(double value);
    public double get_MaxHeight();
    public void set_MaxHeight(double value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public static FlowDirection GetFlowDirection(DependencyObject element);
    public static void SetFlowDirection(DependencyObject element, FlowDirection value);
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    internal static bool ValidateHorizontalAlignmentValue(object value);
    public HorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalAlignment value);
    internal static bool ValidateVerticalAlignmentValue(object value);
    public VerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(VerticalAlignment value);
    internal static Style get_DefaultFocusVisualStyle();
    public Style get_FocusVisualStyle();
    public void set_FocusVisualStyle(Style value);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    public bool get_ForceCursor();
    public void set_ForceCursor(bool value);
    internal static bool ShouldApplyMirrorTransform(FrameworkElement fe);
    internal static bool ApplyMirrorTransform(FlowDirection parentFD, FlowDirection thisFD);
    protected sealed virtual Size MeasureCore(Size availableSize);
    protected sealed virtual void ArrangeCore(Rect finalRect);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal Geometry GetLayoutClipInternal();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal static void InternalSetLayoutTransform(UIElement element, Transform layoutTransform);
    public sealed virtual bool MoveFocus(TraversalRequest request);
    public sealed virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool get_IsInitialized();
    public void add_Initialized(EventHandler value);
    public void remove_Initialized(EventHandler value);
    protected virtual void OnInitialized(EventArgs e);
    internal sealed virtual void OnPresentationSourceChanged(bool attached);
    public bool get_IsLoaded();
    public void add_Loaded(RoutedEventHandler value);
    public void remove_Loaded(RoutedEventHandler value);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal void OnLoaded(RoutedEventArgs args);
    public void add_Unloaded(RoutedEventHandler value);
    public void remove_Unloaded(RoutedEventHandler value);
    internal void OnUnloaded(RoutedEventArgs args);
    internal virtual void AddSynchronizedInputPreOpportunityHandlerCore(EventRoute route, RoutedEventArgs args);
    internal void RaiseClrEvent(EventPrivateKey key, EventArgs args);
    internal static PopupControlService get_PopupControlService();
    internal static KeyboardNavigation get_KeyboardNavigation();
    public object get_ToolTip();
    public void set_ToolTip(object value);
    public ContextMenu get_ContextMenu();
    public void set_ContextMenu(ContextMenu value);
    public void add_ToolTipOpening(ToolTipEventHandler value);
    public void remove_ToolTipOpening(ToolTipEventHandler value);
    protected virtual void OnToolTipOpening(ToolTipEventArgs e);
    public void add_ToolTipClosing(ToolTipEventHandler value);
    public void remove_ToolTipClosing(ToolTipEventHandler value);
    protected virtual void OnToolTipClosing(ToolTipEventArgs e);
    public void add_ContextMenuOpening(ContextMenuEventHandler value);
    public void remove_ContextMenuOpening(ContextMenuEventHandler value);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    public void add_ContextMenuClosing(ContextMenuEventHandler value);
    public void remove_ContextMenuClosing(ContextMenuEventHandler value);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    internal static void AddIntermediateElementsToRoute(DependencyObject mergePoint, EventRoute route, RoutedEventArgs args, DependencyObject modelTreeNode);
    internal void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    internal void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    internal bool get_HasResourceReference();
    internal void set_HasResourceReference(bool value);
    internal bool get_IsLogicalChildrenIterationInProgress();
    internal void set_IsLogicalChildrenIterationInProgress(bool value);
    internal bool get_InVisibilityCollapsedTree();
    internal void set_InVisibilityCollapsedTree(bool value);
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal bool get_IsLoadedCache();
    internal void set_IsLoadedCache(bool value);
    internal bool get_IsParentAnFE();
    internal void set_IsParentAnFE(bool value);
    internal bool get_IsTemplatedParentAnFE();
    internal void set_IsTemplatedParentAnFE(bool value);
    internal bool get_HasLogicalChildren();
    internal void set_HasLogicalChildren(bool value);
    internal bool get_IsRightToLeft();
    internal void set_IsRightToLeft(bool value);
    internal int get_TemplateChildIndex();
    internal void set_TemplateChildIndex(int value);
    internal bool get_IsRequestingExpression();
    internal void set_IsRequestingExpression(bool value);
    internal bool get_BypassLayoutPolicies();
    internal void set_BypassLayoutPolicies(bool value);
    internal bool ReadInternalFlag(InternalFlags reqFlag);
    internal bool ReadInternalFlag2(InternalFlags2 reqFlag);
    internal void WriteInternalFlag(InternalFlags reqFlag, bool set);
    internal void WriteInternalFlag2(InternalFlags2 reqFlag, bool set);
    internal virtual int get_EffectiveValuesInitialSize();
    public DependencyObject get_Parent();
    public void RegisterName(string name, object scopedElement);
    public void UnregisterName(string name);
    public object FindName(string name);
    internal object FindName(string name, DependencyObject& scopeOwner);
    public void UpdateDefaultStyle();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal object FindResourceOnSelf(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal DependencyObject ContextVerifiedGetParent();
    protected internal void AddLogicalChild(object child);
    protected internal void RemoveLogicalChild(object child);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal virtual void OnNewParent(DependencyObject newParent);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void OnAncestorChangedInternal(TreeChangeInfo parentTreeState);
    internal FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo parentTreeState, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_HasFefLoadedChangeHandler();
    internal void UpdateStyleProperty();
    internal void UpdateThemeStyleProperty();
    internal virtual void OnThemeChanged();
    internal void FireLoadedOnDescendentsInternal();
    internal void FireUnloadedOnDescendentsInternal();
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    internal void RaiseInheritedPropertyChangedEvent(InheritablePropertyChangeInfo& info);
    internal bool get_IsStyleUpdateInProgress();
    internal void set_IsStyleUpdateInProgress(bool value);
    internal bool get_IsThemeStyleUpdateInProgress();
    internal void set_IsThemeStyleUpdateInProgress(bool value);
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal bool get_HasNumberSubstitutionChanged();
    internal void set_HasNumberSubstitutionChanged(bool value);
    internal bool get_HasTemplateGeneratedSubTree();
    internal void set_HasTemplateGeneratedSubTree(bool value);
    internal bool get_HasImplicitStyleFromResources();
    internal void set_HasImplicitStyleFromResources(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal bool get_HasStyleChanged();
    internal void set_HasStyleChanged(bool value);
    internal bool get_HasTemplateChanged();
    internal void set_HasTemplateChanged(bool value);
    internal bool get_HasStyleInvalidated();
    internal void set_HasStyleInvalidated(bool value);
    internal bool get_HasStyleEverBeenFetched();
    internal void set_HasStyleEverBeenFetched(bool value);
    internal bool get_HasLocalStyle();
    internal void set_HasLocalStyle(bool value);
    internal bool get_HasThemeStyleEverBeenFetched();
    internal void set_HasThemeStyleEverBeenFetched(bool value);
    internal bool get_AncestorChangeInProgress();
    internal void set_AncestorChangeInProgress(bool value);
    internal FrugalObjectList`1<DependencyProperty> get_InheritableProperties();
    internal void set_InheritableProperties(FrugalObjectList`1<DependencyProperty> value);
    internal Object[] get_LoadedPending();
    internal Object[] get_UnloadedPending();
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool get_PotentiallyHasMentees();
    internal void set_PotentiallyHasMentees(bool value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
}
[LocalizabilityAttribute("17")]
public class System.Windows.FrameworkElementFactory : object {
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    internal bool _hasLoadedChangeHandler;
    internal int _childIndex;
    public Type Type { get; public set; }
    public string Text { get; public set; }
    public string Name { get; public set; }
    internal EventHandlersStore EventHandlersStore { get; internal set; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    public bool IsSealed { get; }
    public FrameworkElementFactory Parent { get; }
    public FrameworkElementFactory FirstChild { get; }
    public FrameworkElementFactory NextSibling { get; }
    internal FrameworkTemplate FrameworkTemplate { get; }
    public FrameworkElementFactory(Type type);
    public FrameworkElementFactory(string text);
    public FrameworkElementFactory(Type type, string name);
    private static FrameworkElementFactory();
    public Type get_Type();
    public void set_Type(Type value);
    public string get_Text();
    public void set_Text(string value);
    public string get_Name();
    public void set_Name(string value);
    public void AppendChild(FrameworkElementFactory child);
    public void SetValue(DependencyProperty dp, object value);
    public void SetBinding(DependencyProperty dp, BindingBase binding);
    public void SetResourceReference(DependencyProperty dp, object name);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal EventHandlersStore get_EventHandlersStore();
    internal void set_EventHandlersStore(EventHandlersStore value);
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    public bool get_IsSealed();
    public FrameworkElementFactory get_Parent();
    public FrameworkElementFactory get_FirstChild();
    public FrameworkElementFactory get_NextSibling();
    internal FrameworkTemplate get_FrameworkTemplate();
    internal object GetValue(DependencyProperty dp);
    internal void Seal(FrameworkTemplate ownerTemplate);
    internal DependencyObject InstantiateTree(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, DependencyObject parent, List`1<DependencyObject> affectedChildren, List`1& noChildIndexChildren, FrugalStructList`1& resourceDependents);
    internal FrameworkObject InstantiateUnoptimizedTree();
    internal static void NewNodeBeginInit(bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    internal static void AddNodeToLogicalTree(DependencyObject parent, Type type, bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    internal bool IsChildNameValid(string childName);
}
public class System.Windows.FrameworkPropertyMetadata : UIPropertyMetadata {
    public bool AffectsMeasure { get; public set; }
    public bool AffectsArrange { get; public set; }
    public bool AffectsParentMeasure { get; public set; }
    public bool AffectsParentArrange { get; public set; }
    public bool AffectsRender { get; public set; }
    public bool Inherits { get; public set; }
    public bool OverridesInheritanceBehavior { get; public set; }
    public bool IsNotDataBindable { get; public set; }
    public bool BindsTwoWayByDefault { get; public set; }
    public UpdateSourceTrigger DefaultUpdateSourceTrigger { get; public set; }
    public bool Journal { get; public set; }
    public bool SubPropertiesDoNotAffectRender { get; public set; }
    public bool IsDataBindingAllowed { get; }
    public FrameworkPropertyMetadata(object defaultValue);
    public FrameworkPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, UpdateSourceTrigger defaultUpdateSourceTrigger);
    public bool get_AffectsMeasure();
    public void set_AffectsMeasure(bool value);
    public bool get_AffectsArrange();
    public void set_AffectsArrange(bool value);
    public bool get_AffectsParentMeasure();
    public void set_AffectsParentMeasure(bool value);
    public bool get_AffectsParentArrange();
    public void set_AffectsParentArrange(bool value);
    public bool get_AffectsRender();
    public void set_AffectsRender(bool value);
    public bool get_Inherits();
    public void set_Inherits(bool value);
    public bool get_OverridesInheritanceBehavior();
    public void set_OverridesInheritanceBehavior(bool value);
    public bool get_IsNotDataBindable();
    public void set_IsNotDataBindable(bool value);
    public bool get_BindsTwoWayByDefault();
    public void set_BindsTwoWayByDefault(bool value);
    public UpdateSourceTrigger get_DefaultUpdateSourceTrigger();
    public void set_DefaultUpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_Journal();
    public void set_Journal(bool value);
    public bool get_SubPropertiesDoNotAffectRender();
    public void set_SubPropertiesDoNotAffectRender(bool value);
    internal virtual PropertyMetadata CreateInstance();
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
    public bool get_IsDataBindingAllowed();
    internal void SetModified(MetadataFlags id);
    internal bool IsModified(MetadataFlags id);
}
[FlagsAttribute]
public enum System.Windows.FrameworkPropertyMetadataOptions : Enum {
    public int value__;
    public static FrameworkPropertyMetadataOptions None;
    public static FrameworkPropertyMetadataOptions AffectsMeasure;
    public static FrameworkPropertyMetadataOptions AffectsArrange;
    public static FrameworkPropertyMetadataOptions AffectsParentMeasure;
    public static FrameworkPropertyMetadataOptions AffectsParentArrange;
    public static FrameworkPropertyMetadataOptions AffectsRender;
    public static FrameworkPropertyMetadataOptions Inherits;
    public static FrameworkPropertyMetadataOptions OverridesInheritanceBehavior;
    public static FrameworkPropertyMetadataOptions NotDataBindable;
    public static FrameworkPropertyMetadataOptions BindsTwoWayByDefault;
    public static FrameworkPropertyMetadataOptions Journal;
    public static FrameworkPropertyMetadataOptions SubPropertiesDoNotAffectRender;
}
[ContentPropertyAttribute("VisualTree")]
[LocalizabilityAttribute("17")]
public abstract class System.Windows.FrameworkTemplate : DispatcherObject {
    internal bool _hasInstanceValues;
    internal ResourceDictionary _resources;
    internal HybridDictionary _triggerActions;
    internal FrugalStructList`1<ChildRecord> ChildRecordFromChildIndex;
    internal FrugalStructList`1<ItemStructMap`1<TriggerSourceRecord>> TriggerSourceRecordFromChildIndex;
    internal FrugalMap PropertyTriggersWithActions;
    internal FrugalStructList`1<ContainerDependent> ContainerDependents;
    internal FrugalStructList`1<ChildPropertyDependent> ResourceDependents;
    internal HybridDictionary _dataTriggerRecordFromBinding;
    internal HybridDictionary DataTriggersWithActions;
    internal ConditionalWeakTable`2<DependencyObject, List`1<DeferredAction>> DeferredActions;
    internal HybridDictionary _TemplateChildLoadedDictionary;
    internal ItemStructList`1<ChildEventDependent> EventDependents;
    public bool IsSealed { get; }
    public FrameworkElementFactory VisualTree { get; public set; }
    [AmbientAttribute]
[DefaultValueAttribute("")]
public TemplateContent Template { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    public bool HasContent { get; }
    internal bool CanBuildVisualTree { get; internal set; }
    internal Type TargetTypeInternal { get; }
    internal object DataTypeInternal { get; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    internal TriggerCollection TriggersInternal { get; }
    internal bool HasResourceReferences { get; }
    internal bool HasContainerResourceReferences { get; }
    internal bool HasChildResourceReferences { get; }
    internal bool HasEventDependents { get; }
    internal bool HasInstanceValues { get; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    internal ParserContext ParserContext { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    internal IStyleConnector StyleConnector { get; internal set; }
    internal IComponentConnector ComponentConnector { get; internal set; }
    internal Object[] StaticResourceValues { get; internal set; }
    internal bool HasXamlNodeContent { get; }
    internal HybridDictionary ChildIndexFromChildName { get; }
    internal Dictionary`2<int, Type> ChildTypeFromChildIndex { get; }
    internal int LastChildIndex { get; internal set; }
    internal List`1<string> ChildNames { get; }
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
    public bool get_IsSealed();
    public FrameworkElementFactory get_VisualTree();
    public void set_VisualTree(FrameworkElementFactory value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeVisualTree();
    public TemplateContent get_Template();
    public void set_Template(TemplateContent value);
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    internal object FindResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    public object FindName(string name, FrameworkElement templatedParent);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
    internal virtual void ProcessTemplateBeforeSeal();
    public void Seal();
    internal void CheckSealed();
    internal void SetResourceReferenceState();
    internal bool ApplyTemplateContent(UncommonField`1<HybridDictionary[]> templateDataField, FrameworkElement container);
    public DependencyObject LoadContent();
    internal DependencyObject LoadContent(DependencyObject container, List`1<DependencyObject> affectedChildren);
    internal static bool IsNameScope(XamlType type);
    public bool get_HasContent();
    internal virtual bool BuildVisualTree(FrameworkElement container);
    internal bool get_CanBuildVisualTree();
    internal void set_CanBuildVisualTree(bool value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources(XamlDesignerSerializationManager manager);
    internal static bool IsNameProperty(XamlMember member, XamlType owner);
    internal static void SetTemplateParentValues(string name, object element, FrameworkTemplate frameworkTemplate, ProvideValueServiceProvider& provideValueServiceProvider);
    internal virtual Type get_TargetTypeInternal();
    internal abstract virtual void SetTargetTypeInternal(Type targetType);
    internal virtual object get_DataTypeInternal();
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal virtual TriggerCollection get_TriggersInternal();
    internal bool get_HasResourceReferences();
    internal bool get_HasContainerResourceReferences();
    internal bool get_HasChildResourceReferences();
    internal bool get_HasEventDependents();
    internal bool get_HasInstanceValues();
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    internal void CopyParserContext(ParserContext parserContext);
    internal ParserContext get_ParserContext();
    internal EventHandlersStore get_EventHandlersStore();
    internal IStyleConnector get_StyleConnector();
    internal void set_StyleConnector(IStyleConnector value);
    internal IComponentConnector get_ComponentConnector();
    internal void set_ComponentConnector(IComponentConnector value);
    internal Object[] get_StaticResourceValues();
    internal void set_StaticResourceValues(Object[] value);
    internal bool get_HasXamlNodeContent();
    internal HybridDictionary get_ChildIndexFromChildName();
    internal Dictionary`2<int, Type> get_ChildTypeFromChildIndex();
    internal int get_LastChildIndex();
    internal void set_LastChildIndex(int value);
    internal List`1<string> get_ChildNames();
}
[TypeConverterAttribute("System.Windows.GridLengthConverter")]
public class System.Windows.GridLength : ValueType {
    private double _unitValue;
    private GridUnitType _unitType;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsStar { get; }
    public double Value { get; }
    public GridUnitType GridUnitType { get; }
    public static GridLength Auto { get; }
    public GridLength(double pixels);
    public GridLength(double value, GridUnitType type);
    private static GridLength();
    public static bool op_Equality(GridLength gl1, GridLength gl2);
    public static bool op_Inequality(GridLength gl1, GridLength gl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(GridLength gridLength);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsStar();
    public double get_Value();
    public GridUnitType get_GridUnitType();
    public virtual string ToString();
    public static GridLength get_Auto();
}
public class System.Windows.GridLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(GridLength gl, CultureInfo cultureInfo);
    internal static GridLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.GridUnitType : Enum {
    public int value__;
    public static GridUnitType Auto;
    public static GridUnitType Pixel;
    public static GridUnitType Star;
}
public class System.Windows.HierarchicalDataTemplate : DataTemplate {
    public BindingBase ItemsSource { get; public set; }
    public DataTemplate ItemTemplate { get; public set; }
    public DataTemplateSelector ItemTemplateSelector { get; public set; }
    public Style ItemContainerStyle { get; public set; }
    public StyleSelector ItemContainerStyleSelector { get; public set; }
    public string ItemStringFormat { get; public set; }
    public int AlternationCount { get; public set; }
    public BindingGroup ItemBindingGroup { get; public set; }
    internal bool IsItemTemplateSet { get; }
    internal bool IsItemTemplateSelectorSet { get; }
    internal bool IsItemContainerStyleSet { get; }
    internal bool IsItemContainerStyleSelectorSet { get; }
    internal bool IsItemStringFormatSet { get; }
    internal bool IsAlternationCountSet { get; }
    internal bool IsItemBindingGroupSet { get; }
    public HierarchicalDataTemplate(object dataType);
    public BindingBase get_ItemsSource();
    public void set_ItemsSource(BindingBase value);
    public DataTemplate get_ItemTemplate();
    public void set_ItemTemplate(DataTemplate value);
    public DataTemplateSelector get_ItemTemplateSelector();
    public void set_ItemTemplateSelector(DataTemplateSelector value);
    public Style get_ItemContainerStyle();
    public void set_ItemContainerStyle(Style value);
    public StyleSelector get_ItemContainerStyleSelector();
    public void set_ItemContainerStyleSelector(StyleSelector value);
    public string get_ItemStringFormat();
    public void set_ItemStringFormat(string value);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    public BindingGroup get_ItemBindingGroup();
    public void set_ItemBindingGroup(BindingGroup value);
    internal bool get_IsItemTemplateSet();
    internal bool get_IsItemTemplateSelectorSet();
    internal bool get_IsItemContainerStyleSet();
    internal bool get_IsItemContainerStyleSelectorSet();
    internal bool get_IsItemStringFormatSet();
    internal bool get_IsAlternationCountSet();
    internal bool get_IsItemBindingGroupSet();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
    public static HorizontalAlignment Stretch;
}
public interface System.Windows.IFrameworkInputElement {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
internal class System.Windows.IndexerParameterInfo : ValueType {
    public Type type;
    public object value;
}
internal class System.Windows.InheritablePropertyChangeInfo : ValueType {
    private DependencyObject _rootElement;
    private DependencyProperty _property;
    private EffectiveValueEntry _oldEntry;
    private EffectiveValueEntry _newEntry;
    internal DependencyObject RootElement { get; }
    internal DependencyProperty Property { get; }
    internal EffectiveValueEntry OldEntry { get; }
    internal EffectiveValueEntry NewEntry { get; }
    internal InheritablePropertyChangeInfo(DependencyObject rootElement, DependencyProperty property, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry);
    internal DependencyObject get_RootElement();
    internal DependencyProperty get_Property();
    internal EffectiveValueEntry get_OldEntry();
    internal EffectiveValueEntry get_NewEntry();
}
public enum System.Windows.InheritanceBehavior : Enum {
    public int value__;
    public static InheritanceBehavior Default;
    public static InheritanceBehavior SkipToAppNow;
    public static InheritanceBehavior SkipToAppNext;
    public static InheritanceBehavior SkipToThemeNow;
    public static InheritanceBehavior SkipToThemeNext;
    public static InheritanceBehavior SkipAllNow;
    public static InheritanceBehavior SkipAllNext;
}
public class System.Windows.Input.CommandConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    internal static ICommand ConvertFromHelper(Type ownerType, string localName);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsKnownType(Type commandType);
    internal static object GetKnownControlCommand(Type ownerType, string commandName);
}
internal class System.Windows.Input.CommandValueSerializer : ValueSerializer {
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual IEnumerable`1<Type> TypeReferences(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
public class System.Windows.Input.KeyboardNavigation : object {
    internal static DependencyProperty ControlTabOnceActiveElementProperty;
    internal static DependencyProperty DirectionalNavigationMarginProperty;
    public static DependencyProperty TabIndexProperty;
    public static DependencyProperty IsTabStopProperty;
    [CustomCategoryAttribute("Accessibility")]
[LocalizabilityAttribute("17")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty TabNavigationProperty;
    [CustomCategoryAttribute("Accessibility")]
[LocalizabilityAttribute("17")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty ControlTabNavigationProperty;
    [CustomCategoryAttribute("Accessibility")]
[LocalizabilityAttribute("17")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty DirectionalNavigationProperty;
    internal static DependencyProperty ShowKeyboardCuesProperty;
    public static DependencyProperty AcceptsReturnProperty;
    internal static bool AlwaysShowFocusVisual { get; internal set; }
    internal static KeyboardNavigation Current { get; }
    private static KeyboardNavigation();
    internal static DependencyObject GetTabOnceActiveElement(DependencyObject d);
    internal static void SetTabOnceActiveElement(DependencyObject d, DependencyObject value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static Visual GetVisualRoot(DependencyObject d);
    internal void add_FocusChanged(KeyboardFocusChangedEventHandler value);
    internal void remove_FocusChanged(KeyboardFocusChangedEventHandler value);
    internal void NotifyFocusChanged(object sender, KeyboardFocusChangedEventArgs e);
    public static void SetTabIndex(DependencyObject element, int index);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetTabIndex(DependencyObject element);
    public static void SetIsTabStop(DependencyObject element, bool isTabStop);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTabStop(DependencyObject element);
    public static void SetTabNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetTabNavigation(DependencyObject element);
    public static void SetControlTabNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetControlTabNavigation(DependencyObject element);
    public static void SetDirectionalNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetDirectionalNavigation(DependencyObject element);
    public static void SetAcceptsReturn(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetAcceptsReturn(DependencyObject element);
    internal static UIElement GetParentUIElementFromContentElement(ContentElement ce);
    internal void HideFocusVisual();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool IsKeyboardMostRecentInputDevice();
    internal static bool get_AlwaysShowFocusVisual();
    internal static void set_AlwaysShowFocusVisual(bool value);
    internal static void ShowFocusVisual();
    internal static void UpdateFocusedElement(DependencyObject focusTarget);
    internal void UpdateActiveElement(DependencyObject activeElement);
    internal void UpdateActiveElement(DependencyObject container, DependencyObject activeElement);
    internal bool Navigate(DependencyObject currentElement, TraversalRequest request);
    internal static KeyboardNavigation get_Current();
    internal static void EnableKeyboardCues(DependencyObject element, bool enable);
    internal static FocusNavigationDirection KeyToTraversalDirection(Key key);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, bool considerDescendants);
    internal DependencyObject PredictFocusedElementAtViewportEdge(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, FrameworkElement viewportBoundsElement, DependencyObject container);
    internal bool Navigate(DependencyObject sourceElement, Key key, ModifierKeys modifiers);
    internal static DependencyObject GetParent(DependencyObject e);
    internal bool IsFocusableInternal(DependencyObject element);
    internal DependencyObject GetFirstTabInGroup(DependencyObject container);
    internal DependencyObject GetLastTabInGroup(DependencyObject container);
    internal static Rect GetRectangle(DependencyObject element);
    internal bool IsAncestorOfEx(DependencyObject sourceElement, DependencyObject targetElement);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void add_EnterMenuMode(EnterMenuModeEventHandler value);
    internal void remove_EnterMenuMode(EnterMenuModeEventHandler value);
    internal void add_FocusEnterMainFocusScope(EventHandler value);
    internal void remove_FocusEnterMainFocusScope(EventHandler value);
}
public enum System.Windows.Input.KeyboardNavigationMode : Enum {
    public int value__;
    public static KeyboardNavigationMode Continue;
    public static KeyboardNavigationMode Once;
    public static KeyboardNavigationMode Cycle;
    public static KeyboardNavigationMode None;
    public static KeyboardNavigationMode Contained;
    public static KeyboardNavigationMode Local;
}
internal enum System.Windows.InstanceStyleData : Enum {
    public int value__;
    public static InstanceStyleData InstanceValues;
    public static InstanceStyleData ArraySize;
}
internal class System.Windows.InstanceValueKey : object {
    internal InstanceValueKey(int childIndex, int dpIndex, int index);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal enum System.Windows.InternalFlags : Enum {
    public UInt32 value__;
    public static InternalFlags HasResourceReferences;
    public static InternalFlags HasNumberSubstitutionChanged;
    public static InternalFlags HasImplicitStyleFromResources;
    public static InternalFlags InheritanceBehavior0;
    public static InternalFlags InheritanceBehavior1;
    public static InternalFlags InheritanceBehavior2;
    public static InternalFlags IsStyleUpdateInProgress;
    public static InternalFlags IsThemeStyleUpdateInProgress;
    public static InternalFlags StoresParentTemplateValues;
    public static InternalFlags NeedsClipBounds;
    public static InternalFlags HasWidthEverChanged;
    public static InternalFlags HasHeightEverChanged;
    public static InternalFlags IsInitialized;
    public static InternalFlags InitPending;
    public static InternalFlags IsResourceParentValid;
    public static InternalFlags AncestorChangeInProgress;
    public static InternalFlags InVisibilityCollapsedTree;
    public static InternalFlags HasStyleEverBeenFetched;
    public static InternalFlags HasThemeStyleEverBeenFetched;
    public static InternalFlags HasLocalStyle;
    public static InternalFlags HasTemplateGeneratedSubTree;
    public static InternalFlags HasLogicalChildren;
    public static InternalFlags IsLogicalChildrenIterationInProgress;
    public static InternalFlags CreatingRoot;
    public static InternalFlags IsRightToLeft;
    public static InternalFlags ShouldLookupImplicitStyles;
    public static InternalFlags PotentiallyHasMentees;
}
[FlagsAttribute]
internal enum System.Windows.InternalFlags2 : Enum {
    public UInt32 value__;
    public static InternalFlags2 R0;
    public static InternalFlags2 R1;
    public static InternalFlags2 R2;
    public static InternalFlags2 R3;
    public static InternalFlags2 R4;
    public static InternalFlags2 R5;
    public static InternalFlags2 R6;
    public static InternalFlags2 R7;
    public static InternalFlags2 R8;
    public static InternalFlags2 R9;
    public static InternalFlags2 RA;
    public static InternalFlags2 RB;
    public static InternalFlags2 RC;
    public static InternalFlags2 RD;
    public static InternalFlags2 RE;
    public static InternalFlags2 RF;
    public static InternalFlags2 TreeHasLoadedChangeHandler;
    public static InternalFlags2 IsLoadedCache;
    public static InternalFlags2 IsStyleSetFromGenerator;
    public static InternalFlags2 IsParentAnFE;
    public static InternalFlags2 IsTemplatedParentAnFE;
    public static InternalFlags2 HasStyleChanged;
    public static InternalFlags2 HasTemplateChanged;
    public static InternalFlags2 HasStyleInvalidated;
    public static InternalFlags2 IsRequestingExpression;
    public static InternalFlags2 HasMultipleInheritanceContexts;
    public static InternalFlags2 BypassLayoutPolicies;
    public static InternalFlags2 Default;
}
public class System.Windows.Interop.ActiveXHost : HwndHost {
    internal static DependencyProperty TabIndexProperty;
    protected bool IsDisposed { get; }
    internal ActiveXSite ActiveXSite { get; }
    internal ActiveXContainer Container { get; }
    internal ActiveXState ActiveXState { get; internal set; }
    internal int TabIndex { get; internal set; }
    internal HandleRef ParentHandle { get; internal set; }
    internal COMRECT Bounds { get; internal set; }
    internal Rect BoundRect { get; }
    internal HandleRef ControlHandle { get; }
    internal object ActiveXInstance { get; }
    internal IOleInPlaceObject ActiveXInPlaceObject { get; }
    internal IOleInPlaceActiveObject ActiveXInPlaceActiveObject { get; }
    private static ActiveXHost();
    [SecurityCriticalAttribute]
internal ActiveXHost(Guid clsid, bool fTrusted);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    [SecurityCriticalAttribute]
protected virtual HandleRef BuildWindowCore(HandleRef hwndParent);
    [SecurityCriticalAttribute]
protected virtual void OnWindowPositionChanged(Rect bounds);
    protected virtual void DestroyWindowCore(HandleRef hwnd);
    protected virtual Size MeasureOverride(Size swConstraint);
    protected virtual void OnAccessKey(AccessKeyEventArgs args);
    protected virtual void Dispose(bool disposing);
    [SecurityCriticalAttribute]
internal virtual ActiveXSite CreateActiveXSite();
    [SecurityCriticalAttribute]
internal virtual object CreateActiveXObject(Guid clsid);
    internal virtual void AttachInterfaces(object nativeActiveXObject);
    internal virtual void DetachInterfaces();
    internal virtual void CreateSink();
    [SecurityCriticalAttribute]
internal virtual void DetachSink();
    internal virtual void OnActiveXStateChange(int oldState, int newState);
    protected bool get_IsDisposed();
    internal void RegisterAccessKey(char key);
    [SecurityCriticalAttribute]
internal ActiveXSite get_ActiveXSite();
    [SecurityCriticalAttribute]
internal ActiveXContainer get_Container();
    internal ActiveXState get_ActiveXState();
    internal void set_ActiveXState(ActiveXState value);
    internal bool GetAxHostState(int mask);
    internal void SetAxHostState(int mask, bool value);
    internal void TransitionUpTo(ActiveXState state);
    internal void TransitionDownTo(ActiveXState state);
    [SecurityCriticalAttribute]
internal bool DoVerb(int verb);
    [SecurityCriticalAttribute]
internal void AttachWindow(IntPtr hwnd);
    internal int get_TabIndex();
    internal void set_TabIndex(int value);
    [SecurityCriticalAttribute]
internal HandleRef get_ParentHandle();
    [SecurityCriticalAttribute]
internal void set_ParentHandle(HandleRef value);
    internal COMRECT get_Bounds();
    internal void set_Bounds(COMRECT value);
    internal Rect get_BoundRect();
    [SecurityCriticalAttribute]
internal HandleRef get_ControlHandle();
    [SecurityCriticalAttribute]
internal object get_ActiveXInstance();
    [SecurityCriticalAttribute]
internal IOleInPlaceObject get_ActiveXInPlaceObject();
    [SecurityCriticalAttribute]
internal IOleInPlaceActiveObject get_ActiveXInPlaceActiveObject();
}
internal class System.Windows.Interop.ApplicationLauncherXappDebug : object {
    [SecurityCriticalAttribute]
public ApplicationLauncherXappDebug(string path, string debugSecurityZoneURL);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public ApplicationProxyInternal Initialize();
}
public static class System.Windows.Interop.BrowserInteropHelper : object {
    [SecurityCriticalAttribute]
internal static IHostBrowser HostBrowser;
    public static object ClientSite { get; }
    [DynamicAttribute]
public static object HostScript { get; }
    public static bool IsBrowserHosted { get; }
    internal static HostingFlags HostingFlags { get; internal set; }
    public static Uri Source { get; }
    internal static bool IsViewer { get; }
    internal static bool IsAvalonTopLevel { get; }
    internal static bool IsHostedInIEorWebOC { get; }
    internal static bool IsInitialViewerNavigation { get; internal set; }
    internal static IServiceProvider HostHtmlDocumentServiceProvider { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static BrowserInteropHelper();
    [SecurityCriticalAttribute]
public static object get_ClientSite();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public static object get_HostScript();
    public static bool get_IsBrowserHosted();
    [SecurityCriticalAttribute]
internal static void SetBrowserHosted(bool value);
    internal static HostingFlags get_HostingFlags();
    [SecurityCriticalAttribute]
internal static void set_HostingFlags(HostingFlags value);
    public static Uri get_Source();
    internal static bool get_IsViewer();
    internal static bool get_IsAvalonTopLevel();
    internal static bool get_IsHostedInIEorWebOC();
    internal static bool get_IsInitialViewerNavigation();
    [SecurityCriticalAttribute]
internal static void set_IsInitialViewerNavigation(bool value);
    [SecurityCriticalAttribute]
internal static void ReleaseBrowserInterfaces();
    [SecurityCriticalAttribute]
internal static IServiceProvider get_HostHtmlDocumentServiceProvider();
    [SecurityCriticalAttribute]
internal static IntPtr PostFilterInput(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static void InitializeHostFilterInput();
}
public class System.Windows.Interop.DocObjHost : MarshalByRefObject {
    [DebuggerBrowsableAttribute("0")]
private RootBrowserWindowProxy MS.Internal.AppModel.IHostService.RootBrowserWindowProxy { get; }
    private IntPtr MS.Internal.AppModel.IHostService.HostWindowHandle { get; }
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override RootBrowserWindowProxy MS.Internal.AppModel.IHostService.get_RootBrowserWindowProxy();
    [SecurityCriticalAttribute]
private sealed virtual override IntPtr MS.Internal.AppModel.IHostService.get_HostWindowHandle();
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Internal.AppModel.IBrowserHostServices.Run(string path, string fragment, MimeType mime, string debugSecurityZoneURL, string applicationId, object streamContainer, object ucomLoadIStream, HostingFlags hostingFlags, INativeProgressPage nativeProgressPage, string progressAssemblyName, string progressClassName, string errorAssemblyName, string errorClassName, IHostBrowser hostBrowser);
    [SecurityCriticalAttribute]
internal void RunApplication(ApplicationRunner runner);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.SetBrowserCallback(object browserCallbackServices);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.SetParent(IntPtr hParent);
    private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.Show(bool show);
    private sealed virtual override bool MS.Internal.AppModel.IBrowserHostServices.IsAppLoaded();
    private sealed virtual override int MS.Internal.AppModel.IBrowserHostServices.GetApplicationExitCode();
    private sealed virtual override bool MS.Internal.AppModel.IBrowserHostServices.CanInvokeJournalEntry(int entryId);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.SaveHistory(object comIStream, bool persistEntireJournal, Int32& entryIndex, String& uri, String& title);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.LoadHistory(object ucomIStream);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Internal.AppModel.IBrowserHostServices.QueryStatus(Guid guidCmdGroup, UInt32 command, UInt32& flags);
    [SecurityCriticalAttribute]
private sealed virtual override int MS.Internal.AppModel.IBrowserHostServices.ExecCommand(Guid guidCommandGroup, UInt32 command, object arg);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.Move(int x, int y, int width, int height);
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.PostShutdown();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.Activate(bool fActivate);
    private sealed virtual override void MS.Internal.AppModel.IBrowserHostServices.TabInto(bool forward);
    private sealed virtual override bool MS.Internal.AppModel.IBrowserHostServices.FocusedElementWantsBackspace();
    [SecurityCriticalAttribute]
private sealed virtual override void MS.Internal.Progressivity.IByteRangeDownloaderService.InitializeByteRangeDownloader(string url, string tempFile, SafeWaitHandle eventHandle);
    private sealed virtual override void MS.Internal.Progressivity.IByteRangeDownloaderService.RequestDownloadByteRanges(Int32[] byteRanges, int size);
    private sealed virtual override void MS.Internal.Progressivity.IByteRangeDownloaderService.GetDownloadedByteRanges(Int32[]& byteRanges, Int32& size);
    private sealed virtual override void MS.Internal.Progressivity.IByteRangeDownloaderService.ReleaseByteRangeDownloader();
    [SecurityCriticalAttribute]
internal static MemoryStream ExtractComStream(object comIStream);
}
public class System.Windows.Interop.DynamicScriptObject : DynamicObject {
    internal IDispatch ScriptObject { get; }
    [SecurityCriticalAttribute]
internal DynamicScriptObject(IDispatch scriptObject);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual string ToString();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal IDispatch get_ScriptObject();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool TryFindMemberAndInvokeNonWrapped(string memberName, int flags, bool cacheDispId, Object[] args, Object& result);
}
public abstract class System.Windows.Interop.HwndHost : FrameworkElement {
    public static RoutedEvent DpiChangedEvent;
    public IntPtr Handle { get; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    internal IntPtr CriticalHandle { get; }
    private static HwndHost();
    [SecurityCriticalAttribute]
internal HwndHost(bool fTrusted);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public sealed virtual IntPtr get_Handle();
    [SecuritySafeCriticalAttribute]
public void add_MessageHook(HwndSourceHook value);
    [SecuritySafeCriticalAttribute]
public void remove_MessageHook(HwndSourceHook value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void OnKeyDown(KeyEventArgs e);
    [SecurityCriticalAttribute]
protected virtual IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    [SecurityCriticalAttribute]
protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    [CompilerGeneratedAttribute]
private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    [SecurityCriticalAttribute]
protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual bool HasFocusWithinCore();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
    [SecurityCriticalAttribute]
public void UpdateWindowPos();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual void Dispose(bool disposing);
    protected abstract virtual HandleRef BuildWindowCore(HandleRef hwndParent);
    protected abstract virtual void DestroyWindowCore(HandleRef hwnd);
    [SecurityCriticalAttribute]
protected virtual IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    [SecurityCriticalAttribute]
protected virtual void OnWindowPositionChanged(Rect rcBoundingBox);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
protected virtual Size MeasureOverride(Size constraint);
    internal virtual DrawingGroup GetDrawing();
    internal virtual Rect GetContentBounds();
    [SecurityCriticalAttribute]
internal IntPtr get_CriticalHandle();
}
public interface System.Windows.Interop.IErrorPage {
    public Uri DeploymentPath { get; public set; }
    public string ErrorTitle { get; public set; }
    public string ErrorText { get; public set; }
    public bool ErrorFlag { get; public set; }
    public string LogFilePath { get; public set; }
    public Uri SupportUri { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public DispatcherOperationCallback GetWinFxCallback { get; public set; }
    public abstract virtual Uri get_DeploymentPath();
    public abstract virtual void set_DeploymentPath(Uri value);
    public abstract virtual string get_ErrorTitle();
    public abstract virtual void set_ErrorTitle(string value);
    public abstract virtual string get_ErrorText();
    public abstract virtual void set_ErrorText(string value);
    public abstract virtual bool get_ErrorFlag();
    public abstract virtual void set_ErrorFlag(bool value);
    public abstract virtual string get_LogFilePath();
    public abstract virtual void set_LogFilePath(string value);
    public abstract virtual Uri get_SupportUri();
    public abstract virtual void set_SupportUri(Uri value);
    public abstract virtual DispatcherOperationCallback get_RefreshCallback();
    public abstract virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public abstract virtual DispatcherOperationCallback get_GetWinFxCallback();
    public abstract virtual void set_GetWinFxCallback(DispatcherOperationCallback value);
}
public interface System.Windows.Interop.IProgressPage {
    public Uri DeploymentPath { get; public set; }
    public DispatcherOperationCallback StopCallback { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public string ApplicationName { get; public set; }
    public string PublisherName { get; public set; }
    public abstract virtual Uri get_DeploymentPath();
    public abstract virtual void set_DeploymentPath(Uri value);
    public abstract virtual DispatcherOperationCallback get_StopCallback();
    public abstract virtual void set_StopCallback(DispatcherOperationCallback value);
    public abstract virtual DispatcherOperationCallback get_RefreshCallback();
    public abstract virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_PublisherName();
    public abstract virtual void set_PublisherName(string value);
    public abstract virtual void UpdateProgress(long bytesDownloaded, long bytesTotal);
}
internal class System.Windows.Interop.PresentationAppDomainManager : AppDomainManager {
    public ApplicationActivator ApplicationActivator { get; }
    public HostSecurityManager HostSecurityManager { get; }
    internal static AppDomain NewAppDomain { get; internal set; }
    internal static bool SaveAppDomain { get; internal set; }
    internal static Uri ActivationUri { get; internal set; }
    internal static Uri DebugSecurityZoneURL { get; internal set; }
    internal static bool IsDebug { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static PresentationAppDomainManager();
    public virtual ApplicationActivator get_ApplicationActivator();
    [SecurityCriticalAttribute]
public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
    [SecurityCriticalAttribute]
public virtual HostSecurityManager get_HostSecurityManager();
    [SecurityCriticalAttribute]
internal ApplicationProxyInternal CreateApplicationProxyInternal();
    internal static AppDomain get_NewAppDomain();
    internal static void set_NewAppDomain(AppDomain value);
    internal static bool get_SaveAppDomain();
    internal static void set_SaveAppDomain(bool value);
    internal static Uri get_ActivationUri();
    internal static void set_ActivationUri(Uri value);
    internal static Uri get_DebugSecurityZoneURL();
    internal static void set_DebugSecurityZoneURL(Uri value);
    internal static bool get_IsDebug();
    internal static void set_IsDebug(bool value);
}
internal class System.Windows.Interop.PresentationApplicationActivator : ApplicationActivator {
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual ObjectHandle CreateInstance(ActivationContext actCtx);
}
internal class System.Windows.Interop.PresentationHostSecurityManager : HostSecurityManager {
    [SecurityCriticalAttribute]
internal static IntPtr ElevationPromptOwnerWindow;
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
    [SecurityCriticalAttribute]
internal static PermissionSet AddPermissionForUri(PermissionSet originalPermSet, Uri srcUri);
}
public class System.Windows.Interop.WindowInteropHelper : object {
    public IntPtr Handle { get; }
    internal IntPtr CriticalHandle { get; }
    public IntPtr Owner { get; public set; }
    public WindowInteropHelper(Window window);
    [SecurityCriticalAttribute]
public IntPtr get_Handle();
    [SecurityCriticalAttribute]
internal IntPtr get_CriticalHandle();
    [SecurityCriticalAttribute]
public IntPtr get_Owner();
    [SecurityCriticalAttribute]
public void set_Owner(IntPtr value);
    [SecurityCriticalAttribute]
public IntPtr EnsureHandle();
}
internal interface System.Windows.IWindowService {
    public string Title { get; public set; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public bool UserResized { get; }
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual double get_Height();
    public abstract virtual void set_Height(double value);
    public abstract virtual double get_Width();
    public abstract virtual void set_Width(double value);
    public abstract virtual bool get_UserResized();
}
internal static class System.Windows.LayoutDoubleUtil : object {
    internal static bool AreClose(double value1, double value2);
    internal static bool LessThan(double value1, double value2);
}
public class System.Windows.LengthConverter : TypeConverter {
    private static LengthConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static double FromString(string s, CultureInfo cultureInfo);
    internal static string ToString(double l, CultureInfo cultureInfo);
}
public enum System.Windows.LineStackingStrategy : Enum {
    public int value__;
    public static LineStackingStrategy BlockLineHeight;
    public static LineStackingStrategy MaxHeight;
}
public static class System.Windows.Localization : object {
    public static DependencyProperty CommentsProperty;
    public static DependencyProperty AttributesProperty;
    private static Localization();
    [AttachedPropertyBrowsableForTypeAttribute("System.Object")]
public static string GetComments(object element);
    public static void SetComments(object element, string comments);
    [AttachedPropertyBrowsableForTypeAttribute("System.Object")]
public static string GetAttributes(object element);
    public static void SetAttributes(object element, string attributes);
}
internal enum System.Windows.LogicalOp : Enum {
    public int value__;
    public static LogicalOp Equals;
    public static LogicalOp NotEquals;
}
public static class System.Windows.LogicalTreeHelper : object {
    public static DependencyObject FindLogicalNode(DependencyObject logicalTreeNode, string elementName);
    public static DependencyObject GetParent(DependencyObject current);
    public static IEnumerable GetChildren(DependencyObject current);
    public static IEnumerable GetChildren(FrameworkElement current);
    public static IEnumerable GetChildren(FrameworkContentElement current);
    public static void BringIntoView(DependencyObject current);
    internal static void AddLogicalChild(DependencyObject parent, object child);
    internal static void AddLogicalChild(FrameworkElement parentFE, FrameworkContentElement parentFCE, object child);
    internal static void RemoveLogicalChild(DependencyObject parent, object child);
    internal static void RemoveLogicalChild(FrameworkElement parentFE, FrameworkContentElement parentFCE, object child);
    internal static IEnumerator GetLogicalChildren(DependencyObject current);
}
public class System.Windows.LostFocusEventManager : WeakEventManager {
    public static void AddListener(DependencyObject source, IWeakEventListener listener);
    public static void RemoveListener(DependencyObject source, IWeakEventListener listener);
    public static void AddHandler(DependencyObject source, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveHandler(DependencyObject source, EventHandler`1<RoutedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
}
internal class System.Windows.Markup.AssemblyInfoKey : ValueType {
    internal string AssemblyFullName;
    public virtual bool Equals(object o);
    public static bool op_Equality(AssemblyInfoKey key1, AssemblyInfoKey key2);
    public static bool op_Inequality(AssemblyInfoKey key1, AssemblyInfoKey key2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum System.Windows.Markup.AttributeContext : Enum {
    public int value__;
    public static AttributeContext Unknown;
    public static AttributeContext Property;
    public static AttributeContext RoutedEvent;
    public static AttributeContext ClrEvent;
    public static AttributeContext Code;
}
internal class System.Windows.Markup.AttributeData : DefAttributeData {
    internal string PropertyName;
    internal Type SerializerType;
    internal short ExtensionTypeId;
    internal bool IsValueNestedExtension;
    internal bool IsValueTypeExtension;
    internal object Info;
    internal bool IsTypeExtension { get; }
    internal bool IsStaticExtension { get; }
    internal AttributeData(string targetAssemblyName, string targetFullName, Type targetType, string args, Type declaringType, string propertyName, object info, Type serializerType, int lineNumber, int linePosition, int depth, string targetNamespaceUri, short extensionTypeId, bool isValueNestedExtension, bool isValueTypeExtension, bool isSimple);
    internal bool get_IsTypeExtension();
    internal bool get_IsStaticExtension();
}
internal class System.Windows.Markup.BamlAssemblyInfoRecord : BamlVariableSizedRecord {
    internal short AssemblyId { get; internal set; }
    internal static Section LastFlagsSection { get; }
    internal string AssemblyFullName { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Assembly Assembly { get; internal set; }
    private static BamlAssemblyInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal static Section get_LastFlagsSection();
    internal string get_AssemblyFullName();
    internal void set_AssemblyFullName(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Assembly get_Assembly();
    internal void set_Assembly(Assembly value);
}
internal class System.Windows.Markup.BamlAttributeInfoRecord : BamlVariableSizedRecord {
    internal short OwnerTypeId { get; internal set; }
    internal short AttributeId { get; internal set; }
    internal string Name { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal object PropertyMember { get; internal set; }
    internal Type OwnerType { get; internal set; }
    internal RoutedEvent Event { get; internal set; }
    internal DependencyProperty DP { get; internal set; }
    internal MethodInfo AttachedPropertySetter { get; internal set; }
    internal MethodInfo AttachedPropertyGetter { get; internal set; }
    internal EventInfo EventInfo { get; internal set; }
    internal PropertyInfo PropInfo { get; internal set; }
    internal bool IsInternal { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlAttributeInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_OwnerTypeId();
    internal void set_OwnerTypeId(short value);
    internal void set_AttributeId(short value);
    internal short get_AttributeId();
    internal string get_Name();
    internal void set_Name(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Type GetPropertyType();
    internal void SetPropertyMember(object propertyMember);
    internal object GetPropertyMember(bool onlyPropInfo);
    internal object get_PropertyMember();
    internal void set_PropertyMember(object value);
    internal Type get_OwnerType();
    internal void set_OwnerType(Type value);
    internal RoutedEvent get_Event();
    internal void set_Event(RoutedEvent value);
    internal DependencyProperty get_DP();
    internal void set_DP(DependencyProperty value);
    internal MethodInfo get_AttachedPropertySetter();
    internal void set_AttachedPropertySetter(MethodInfo value);
    internal MethodInfo get_AttachedPropertyGetter();
    internal void set_AttachedPropertyGetter(MethodInfo value);
    internal EventInfo get_EventInfo();
    internal void set_EventInfo(EventInfo value);
    internal PropertyInfo get_PropInfo();
    internal void set_PropInfo(PropertyInfo value);
    internal bool get_IsInternal();
    internal void set_IsInternal(bool value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal void set_AttributeUsage(BamlAttributeUsage value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal enum System.Windows.Markup.BamlAttributeUsage : Enum {
    public short value__;
    public static BamlAttributeUsage Default;
    public static BamlAttributeUsage XmlLang;
    public static BamlAttributeUsage XmlSpace;
    public static BamlAttributeUsage RuntimeName;
}
internal class System.Windows.Markup.BamlBinaryReader : BinaryReader {
    public BamlBinaryReader(Stream stream, Encoding code);
    public int Read7BitEncodedInt();
}
internal class System.Windows.Markup.BamlBinaryWriter : BinaryWriter {
    public BamlBinaryWriter(Stream stream, Encoding code);
    public void Write7BitEncodedInt(int value);
    public static int SizeOf7bitEncodedSize(int size);
}
internal class System.Windows.Markup.BamlCollectionHolder : object {
    internal object Collection { get; internal set; }
    internal IList List { get; }
    internal IDictionary Dictionary { get; }
    internal ArrayExtension ArrayExt { get; }
    internal object DefaultCollection { get; }
    internal WpfPropertyDefinition PropertyDefinition { get; }
    internal Type PropertyType { get; }
    internal object Parent { get; }
    internal bool ReadOnly { get; internal set; }
    internal bool IsClosed { get; internal set; }
    internal string AttributeName { get; }
    internal BamlCollectionHolder(BamlRecordReader reader, object parent, short attributeId);
    internal BamlCollectionHolder(BamlRecordReader reader, object parent, short attributeId, bool needDefault);
    internal object get_Collection();
    internal void set_Collection(object value);
    internal IList get_List();
    internal IDictionary get_Dictionary();
    internal ArrayExtension get_ArrayExt();
    internal object get_DefaultCollection();
    internal WpfPropertyDefinition get_PropertyDefinition();
    internal Type get_PropertyType();
    internal object get_Parent();
    internal bool get_ReadOnly();
    internal void set_ReadOnly(bool value);
    internal bool get_IsClosed();
    internal void set_IsClosed(bool value);
    internal string get_AttributeName();
    internal void SetPropertyValue();
    internal void InitDefaultValue();
}
internal class System.Windows.Markup.BamlConnectionIdRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal int ConnectionId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal int get_ConnectionId();
    internal void set_ConnectionId(int value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlConstructorParametersEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlConstructorParametersStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlConstructorParameterTypeRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlContentPropertyRecord : BamlRecord {
    internal short AttributeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal bool HasSerializer { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal virtual BamlRecordType get_RecordType();
    internal virtual bool get_HasSerializer();
}
internal class System.Windows.Markup.BamlDefAttributeKeyStringRecord : BamlStringValueRecord {
    internal static int ValuePositionSize;
    internal BamlRecordType RecordType { get; }
    private int System.Windows.Markup.IBamlDictionaryKey.ValuePosition { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.Shared { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.SharedSet { get; private set; }
    internal static Section LastFlagsSection { get; }
    private object System.Windows.Markup.IBamlDictionaryKey.KeyObject { get; private set; }
    private long System.Windows.Markup.IBamlDictionaryKey.ValuePositionPosition { get; private set; }
    internal short ValueId { get; internal set; }
    private Object[] System.Windows.Markup.IBamlDictionaryKey.StaticResourceValues { get; private set; }
    private static BamlDefAttributeKeyStringRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    private sealed virtual override int System.Windows.Markup.IBamlDictionaryKey.get_ValuePosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePosition(int value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_Shared();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_Shared(bool value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_SharedSet();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_SharedSet(bool value);
    internal static Section get_LastFlagsSection();
    private sealed virtual override object System.Windows.Markup.IBamlDictionaryKey.get_KeyObject();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_KeyObject(object value);
    private sealed virtual override long System.Windows.Markup.IBamlDictionaryKey.get_ValuePositionPosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePositionPosition(long value);
    internal short get_ValueId();
    internal void set_ValueId(short value);
    private sealed virtual override Object[] System.Windows.Markup.IBamlDictionaryKey.get_StaticResourceValues();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_StaticResourceValues(Object[] value);
}
internal class System.Windows.Markup.BamlDefAttributeKeyTypeRecord : BamlElementStartRecord {
    internal static int ValuePositionSize;
    internal BamlRecordType RecordType { get; }
    private int System.Windows.Markup.IBamlDictionaryKey.ValuePosition { get; private set; }
    private object System.Windows.Markup.IBamlDictionaryKey.KeyObject { get; private set; }
    private long System.Windows.Markup.IBamlDictionaryKey.ValuePositionPosition { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.Shared { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.SharedSet { get; private set; }
    private Object[] System.Windows.Markup.IBamlDictionaryKey.StaticResourceValues { get; private set; }
    internal static Section LastFlagsSection { get; }
    private static BamlDefAttributeKeyTypeRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    private sealed virtual override int System.Windows.Markup.IBamlDictionaryKey.get_ValuePosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePosition(int value);
    private sealed virtual override object System.Windows.Markup.IBamlDictionaryKey.get_KeyObject();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_KeyObject(object value);
    private sealed virtual override long System.Windows.Markup.IBamlDictionaryKey.get_ValuePositionPosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePositionPosition(long value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_Shared();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_Shared(bool value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_SharedSet();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_SharedSet(bool value);
    private sealed virtual override Object[] System.Windows.Markup.IBamlDictionaryKey.get_StaticResourceValues();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_StaticResourceValues(Object[] value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlDefAttributeRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal short NameId { get; internal set; }
    internal string Name { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_NameId();
    internal void set_NameId(short value);
    internal string get_Name();
    internal void set_Name(string value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal void set_AttributeUsage(BamlAttributeUsage value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlDeferableContentStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal int ContentSize { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal Byte[] ValuesBuffer { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal void UpdateContentSize(int contentSize, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal int get_ContentSize();
    internal void set_ContentSize(int value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal Byte[] get_ValuesBuffer();
    internal void set_ValuesBuffer(Byte[] value);
}
internal class System.Windows.Markup.BamlDocumentEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlDocumentStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal bool LoadAsync { get; internal set; }
    internal int MaxAsyncRecords { get; internal set; }
    internal long FilePos { get; internal set; }
    internal bool DebugBaml { get; internal set; }
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal virtual void UpdateWrite(BinaryWriter bamlBinaryWriter);
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal bool get_LoadAsync();
    internal void set_LoadAsync(bool value);
    internal int get_MaxAsyncRecords();
    internal void set_MaxAsyncRecords(int value);
    internal long get_FilePos();
    internal void set_FilePos(long value);
    internal bool get_DebugBaml();
    internal void set_DebugBaml(bool value);
}
internal class System.Windows.Markup.BamlElementEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlElementStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal bool IsInjected { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlElementStartRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal bool get_IsInjected();
    internal void set_IsInjected(bool value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public virtual string ToString();
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlKeyElementEndRecord : BamlElementEndRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlKeyElementStartRecord : BamlDefAttributeKeyTypeRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlLineAndPositionRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal UInt32 LineNumber { get; internal set; }
    internal UInt32 LinePosition { get; internal set; }
    internal int RecordSize { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal UInt32 get_LineNumber();
    internal void set_LineNumber(UInt32 value);
    internal UInt32 get_LinePosition();
    internal void set_LinePosition(UInt32 value);
    internal virtual int get_RecordSize();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlLinePositionRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal UInt32 LinePosition { get; internal set; }
    internal int RecordSize { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal UInt32 get_LinePosition();
    internal void set_LinePosition(UInt32 value);
    internal virtual int get_RecordSize();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlLiteralContentRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlMapTable : object {
    internal static short NameStringId;
    internal static short UidStringId;
    internal static string NameString;
    internal XamlTypeMapper XamlTypeMapper { get; internal set; }
    private static BamlMapTable();
    internal BamlMapTable(XamlTypeMapper xamlTypeMapper);
    internal object CreateKnownTypeFromId(short id);
    internal static Type GetKnownTypeFromId(short id);
    internal static short GetKnownTypeIdFromName(string assemblyFullName, string clrNamespace, string typeShortName);
    internal static short GetKnownTypeIdFromType(Type type);
    internal static KnownElements GetKnownTypeConverterIdFromType(Type type);
    internal TypeConverter GetKnownConverterFromType(Type type);
    internal static TypeConverter GetKnownConverterFromType_NoCache(Type type);
    internal Type GetKnownConverterTypeFromType(Type type);
    internal void Initialize();
    internal Type GetTypeFromId(short id);
    internal bool HasSerializerForTypeId(short id);
    internal BamlTypeInfoRecord GetTypeInfoFromId(short id);
    internal TypeConverter GetConverterFromId(short typeId, Type propType, ParserContext pc);
    internal string GetStringFromStringId(int id);
    internal BamlAttributeInfoRecord GetAttributeInfoFromId(short id);
    internal BamlAttributeInfoRecord GetAttributeInfoFromIdWithOwnerType(short attributeId);
    internal string GetAttributeNameFromId(short id);
    internal bool DoesAttributeMatch(short id, short ownerTypeId, string name);
    internal bool DoesAttributeMatch(short id, string name);
    internal bool DoesAttributeMatch(short id, BamlAttributeUsage attributeUsage);
    internal void GetAttributeInfoFromId(short id, Int16& ownerTypeId, String& name, BamlAttributeUsage& attributeUsage);
    internal Type GetTypeFromTypeInfo(BamlTypeInfoRecord typeInfo);
    internal Type GetCLRPropertyTypeAndNameFromId(short attributeId, String& propName);
    internal DependencyProperty GetDependencyPropertyValueFromId(short memberId, string memberName, Type& declaringType);
    internal DependencyProperty GetDependencyPropertyValueFromId(short memberId);
    internal DependencyProperty GetDependencyProperty(int id);
    internal DependencyProperty GetDependencyProperty(BamlAttributeInfoRecord bamlAttributeInfoRecord);
    internal RoutedEvent GetRoutedEvent(BamlAttributeInfoRecord bamlAttributeInfoRecord);
    internal short GetAttributeOrTypeId(BinaryWriter binaryWriter, Type declaringType, string memberName, Int16& typeId);
    internal BamlAssemblyInfoRecord GetAssemblyInfoFromId(short id);
    internal BamlAssemblyInfoRecord AddAssemblyMap(BinaryWriter binaryWriter, string assemblyFullName);
    internal void LoadAssemblyInfoRecord(BamlAssemblyInfoRecord record);
    internal void EnsureAssemblyRecord(Assembly asm);
    internal bool GetTypeInfoId(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Int16& typeId);
    internal short AddTypeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type elementType, string serializerAssemblyFullName, string serializerTypeFullName);
    internal void LoadTypeInfoRecord(BamlTypeInfoRecord record);
    internal object GetAttributeInfoKey(string ownerTypeName, string attributeName);
    internal short AddAttributeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type owningType, string fieldName, Type attributeType, BamlAttributeUsage attributeUsage);
    internal short AddAttributeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type owningType, string fieldName, Type attributeType, BamlAttributeUsage attributeUsage, BamlAttributeInfoRecord& bamlAttributeInfoRecord);
    internal bool GetCustomSerializerOrConverter(BinaryWriter binaryWriter, Type ownerType, Type attributeType, object piOrMi, string fieldName, Int16& converterOrSerializerTypeId, Type& converterOrSerializerType);
    internal bool GetStringInfoId(string stringValue, Int16& stringId);
    internal short AddStringInfoMap(BinaryWriter binaryWriter, string stringValue);
    internal short GetStaticMemberId(BinaryWriter binaryWriter, ParserContext pc, short extensionTypeId, string memberValue, Type defaultTargetType);
    internal void LoadAttributeInfoRecord(BamlAttributeInfoRecord record);
    internal void LoadStringInfoRecord(BamlStringInfoRecord record);
    internal object GetHashTableData(object key);
    internal void AddHashTableData(object key, object data);
    internal BamlMapTable Clone();
    internal void ClearConverterCache();
    internal XamlTypeMapper get_XamlTypeMapper();
    internal void set_XamlTypeMapper(XamlTypeMapper value);
}
internal class System.Windows.Markup.BamlNamedElementStartRecord : BamlElementStartRecord {
    internal string RuntimeName { get; internal set; }
    internal bool IsTemplateChild { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal string get_RuntimeName();
    internal void set_RuntimeName(string value);
    internal bool get_IsTemplateChild();
    internal void set_IsTemplateChild(bool value);
}
internal enum System.Windows.Markup.BamlNodeType : Enum {
    public int value__;
    public static BamlNodeType None;
    public static BamlNodeType StartDocument;
    public static BamlNodeType EndDocument;
    public static BamlNodeType ConnectionId;
    public static BamlNodeType StartElement;
    public static BamlNodeType EndElement;
    public static BamlNodeType Property;
    public static BamlNodeType ContentProperty;
    public static BamlNodeType XmlnsProperty;
    public static BamlNodeType StartComplexProperty;
    public static BamlNodeType EndComplexProperty;
    public static BamlNodeType LiteralContent;
    public static BamlNodeType Text;
    public static BamlNodeType RoutedEvent;
    public static BamlNodeType Event;
    public static BamlNodeType IncludeReference;
    public static BamlNodeType DefAttribute;
    public static BamlNodeType PresentationOptionsAttribute;
    public static BamlNodeType PIMapping;
    public static BamlNodeType StartConstructor;
    public static BamlNodeType EndConstructor;
}
internal class System.Windows.Markup.BamlOptimizedStaticResourceRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    public short ExtensionTypeId { get; }
    public short ValueId { get; public set; }
    internal int RecordSize { get; internal set; }
    public bool IsValueTypeExtension { get; public set; }
    public bool IsValueStaticExtension { get; public set; }
    internal static Section LastFlagsSection { get; }
    private static BamlOptimizedStaticResourceRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    public sealed virtual short get_ExtensionTypeId();
    public sealed virtual short get_ValueId();
    public void set_ValueId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public sealed virtual bool get_IsValueTypeExtension();
    public void set_IsValueTypeExtension(bool value);
    public sealed virtual bool get_IsValueStaticExtension();
    public void set_IsValueStaticExtension(bool value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPIMappingRecord : BamlVariableSizedRecord {
    internal BamlRecordType RecordType { get; }
    internal string XmlNamespace { get; internal set; }
    internal string ClrNamespace { get; internal set; }
    internal short AssemblyId { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPIMappingRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal string get_XmlNamespace();
    internal void set_XmlNamespace(string value);
    internal string get_ClrNamespace();
    internal void set_ClrNamespace(string value);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlPresentationOptionsAttributeRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal short NameId { get; internal set; }
    internal string Name { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_NameId();
    internal void set_NameId(short value);
    internal string get_Name();
    internal void set_Name(string value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyArrayEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyArrayStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyComplexEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyComplexStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyCustomRecord : BamlVariableSizedRecord {
    internal static short TypeIdValueMask;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal short SerializerTypeId { get; internal set; }
    internal object ValueObject { get; internal set; }
    internal bool ValueObjectSet { get; internal set; }
    internal bool IsValueTypeId { get; internal set; }
    internal bool IsRawEnumValueSet { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPropertyCustomRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal object GetCustomValue(BinaryReader reader, Type propertyType, short serializerId, BamlRecordReader bamlRecordReader);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal short get_SerializerTypeId();
    internal void set_SerializerTypeId(short value);
    internal object get_ValueObject();
    internal void set_ValueObject(object value);
    internal bool get_ValueObjectSet();
    internal void set_ValueObjectSet(bool value);
    internal bool get_IsValueTypeId();
    internal void set_IsValueTypeId(bool value);
    internal bool get_IsRawEnumValueSet();
    internal void set_IsRawEnumValueSet(bool value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlPropertyCustomWriteInfoRecord : BamlPropertyCustomRecord {
    internal short ValueId { get; internal set; }
    internal string ValueMemberName { get; internal set; }
    internal Type ValueType { get; internal set; }
    internal string Value { get; internal set; }
    internal Type SerializerType { get; internal set; }
    internal ITypeDescriptorContext TypeContext { get; internal set; }
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ValueId();
    internal void set_ValueId(short value);
    internal string get_ValueMemberName();
    internal void set_ValueMemberName(string value);
    internal Type get_ValueType();
    internal void set_ValueType(Type value);
    internal string get_Value();
    internal void set_Value(string value);
    internal Type get_SerializerType();
    internal void set_SerializerType(Type value);
    internal ITypeDescriptorContext get_TypeContext();
    internal void set_TypeContext(ITypeDescriptorContext value);
}
internal class System.Windows.Markup.BamlPropertyIDictionaryEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIDictionaryStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIListEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIListStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyStringReferenceRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal short StringId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_StringId();
    internal void set_StringId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlPropertyTypeReferenceRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlPropertyWithConverterRecord : BamlPropertyRecord {
    internal short ConverterTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ConverterTypeId();
    internal void set_ConverterTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyWithExtensionRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    public short ExtensionTypeId { get; public set; }
    public short ValueId { get; public set; }
    internal int RecordSize { get; internal set; }
    public bool IsValueTypeExtension { get; public set; }
    public bool IsValueStaticExtension { get; public set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPropertyWithExtensionRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public sealed virtual short get_ExtensionTypeId();
    public void set_ExtensionTypeId(short value);
    public sealed virtual short get_ValueId();
    public void set_ValueId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public sealed virtual bool get_IsValueTypeExtension();
    public void set_IsValueTypeExtension(bool value);
    public sealed virtual bool get_IsValueStaticExtension();
    public void set_IsValueStaticExtension(bool value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyWithStaticResourceIdRecord : BamlStaticResourceIdRecord {
    internal BamlRecordType RecordType { get; }
    internal int RecordSize { get; internal set; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlReader : object {
    public int PropertyCount { get; }
    public bool HasProperties { get; }
    public int ConnectionId { get; }
    public BamlAttributeUsage AttributeUsage { get; }
    public BamlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string Prefix { get; }
    public string AssemblyName { get; }
    public string XmlNamespace { get; }
    public string ClrNamespace { get; }
    public string Value { get; }
    public bool IsInjected { get; }
    public bool CreateUsingTypeConverter { get; }
    public string TypeConverterName { get; }
    public string TypeConverterAssemblyName { get; }
    public BamlReader(Stream bamlStream);
    public int get_PropertyCount();
    public bool get_HasProperties();
    public int get_ConnectionId();
    public BamlAttributeUsage get_AttributeUsage();
    public BamlNodeType get_NodeType();
    public string get_Name();
    public string get_LocalName();
    public string get_Prefix();
    public string get_AssemblyName();
    public string get_XmlNamespace();
    public string get_ClrNamespace();
    public string get_Value();
    public bool get_IsInjected();
    public bool get_CreateUsingTypeConverter();
    public string get_TypeConverterName();
    public string get_TypeConverterAssemblyName();
    public bool Read();
    public void Close();
    public bool MoveToFirstProperty();
    public bool MoveToNextProperty();
    internal string GetXmlnsPrefix(string xmlns);
}
internal abstract class System.Windows.Markup.BamlRecord : object {
    internal BitVector32 _flags;
    internal static int RecordTypeFieldLength;
    internal int RecordSize { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal BamlRecord Next { get; internal set; }
    internal bool IsPinned { get; }
    internal int PinnedCount { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlRecord();
    internal virtual bool LoadRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable);
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal virtual BamlRecordType get_RecordType();
    internal BamlRecord get_Next();
    internal void set_Next(BamlRecord value);
    internal bool get_IsPinned();
    internal int get_PinnedCount();
    internal void set_PinnedCount(int value);
    internal void Pin();
    internal void Unpin();
    internal virtual void Copy(BamlRecord record);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
    protected static string GetTypeName(int typeId);
    internal static bool IsContentRecord(BamlRecordType bamlRecordType);
}
internal static class System.Windows.Markup.BamlRecordHelper : object {
    internal static bool IsMapTableRecordType(BamlRecordType bamlRecordType);
    internal static bool IsDebugBamlRecordType(BamlRecordType recordType);
    internal static bool HasDebugExtensionRecord(bool isDebugBamlStream, BamlRecord bamlRecord);
    internal static bool DoesRecordTypeHaveDebugExtension(BamlRecordType recordType);
}
internal class System.Windows.Markup.BamlRecordManager : object {
    internal BamlRecord ReadNextRecord(BinaryReader bamlBinaryReader, long bytesAvailable, BamlRecordType recordType);
    internal static IAddChild AsIAddChild(object obj);
    internal static bool TreatAsIAddChild(Type parentObjectType);
    internal static BamlRecordType GetPropertyStartRecordType(Type propertyType, bool propertyCanWrite);
    internal BamlRecord CloneRecord(BamlRecord record);
    internal BamlRecord GetWriteRecord(BamlRecordType recordType);
    internal void ReleaseWriteRecord(BamlRecord record);
}
internal class System.Windows.Markup.BamlRecordReader : object {
    internal ArrayList RootList { get; internal set; }
    internal bool BuildTopDown { get; internal set; }
    internal int BytesAvailible { get; }
    internal BamlRecord PreParsedRecordsStart { get; internal set; }
    internal BamlRecord PreParsedCurrentRecord { get; internal set; }
    internal Stream BamlStream { get; internal set; }
    internal BamlBinaryReader BinaryReader { get; }
    internal XamlTypeMapper XamlTypeMapper { get; }
    internal ParserContext ParserContext { get; internal set; }
    internal TypeConvertContext TypeConvertContext { get; }
    internal XamlParseMode XamlParseMode { get; internal set; }
    internal int MaxAsyncRecords { get; internal set; }
    internal BamlMapTable MapTable { get; }
    internal XmlnsDictionary XmlnsDictionary { get; }
    internal ReaderContextStackData CurrentContext { get; }
    internal ReaderContextStackData ParentContext { get; }
    internal object ParentObjectData { get; }
    internal ReaderContextStackData GrandParentContext { get; }
    internal object GrandParentObjectData { get; }
    internal ReaderContextStackData GreatGrandParentContext { get; }
    internal ParserStack ReaderContextStack { get; }
    internal BamlRecordManager BamlRecordManager { get; }
    internal bool EndOfDocument { get; internal set; }
    internal object RootElement { get; internal set; }
    internal IComponentConnector ComponentConnector { get; internal set; }
    internal ParserStack ContextStack { get; internal set; }
    internal int LineNumber { get; internal set; }
    internal int LinePosition { get; internal set; }
    internal bool IsDebugBamlStream { get; internal set; }
    internal long StreamPosition { get; }
    internal bool IsRootAlreadyLoaded { get; internal set; }
    internal BamlRecordReader PreviousBamlRecordReader { get; }
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext);
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext, object root);
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext, bool loadMapper);
    private static BamlRecordReader();
    internal void Initialize();
    internal ArrayList get_RootList();
    internal void set_RootList(ArrayList value);
    internal bool get_BuildTopDown();
    internal void set_BuildTopDown(bool value);
    internal int get_BytesAvailible();
    internal BamlRecord GetNextRecord();
    internal BamlRecord ReadNextRecordWithDebugExtension(long bytesAvailable, BamlRecordType recordType);
    internal BamlRecord ReadDebugExtensionRecord();
    internal void ProcessDebugBamlRecord(BamlRecord bamlRecord);
    internal BamlRecordType GetNextRecordType();
    internal void Close();
    internal bool Read(bool singleRecord);
    internal bool Read();
    internal bool Read(BamlRecord bamlRecord, int lineNumber, int linePosition);
    internal void ReadVersionHeader();
    internal object ReadElement(long startPosition, XamlObjectIds contextXamlObjectIds, object dictionaryKey);
    protected virtual void ReadConnectionId(BamlConnectionIdRecord bamlConnectionIdRecord);
    internal virtual bool ReadRecord(BamlRecord bamlRecord);
    protected virtual void ReadXmlnsPropertyRecord(BamlXmlnsPropertyRecord xmlnsRecord);
    protected ReaderFlags GetFlagsFromType(Type elementType);
    internal static void CheckForTreeAdd(ReaderFlags& flags, ReaderContextStackData context);
    internal void SetDependencyValue(DependencyObject dependencyObject, DependencyProperty dependencyProperty, object value);
    internal virtual void SetDependencyValueCore(DependencyObject dependencyObject, DependencyProperty dependencyProperty, object value);
    internal object ProvideValueFromMarkupExtension(MarkupExtension markupExtension, object obj, object member);
    internal void BaseReadElementStartRecord(BamlElementStartRecord bamlElementRecord);
    protected virtual bool ReadElementStartRecord(BamlElementStartRecord bamlElementRecord);
    protected internal virtual void ReadElementEndRecord(bool fromNestedBamlRecordReader);
    internal virtual void ReadKeyElementStartRecord(BamlKeyElementStartRecord bamlElementRecord);
    internal virtual void ReadKeyElementEndRecord();
    internal virtual void ReadConstructorParameterTypeRecord(BamlConstructorParameterTypeRecord constructorParameterType);
    internal virtual void ReadContentPropertyRecord(BamlContentPropertyRecord bamlContentPropertyRecord);
    internal virtual void ReadConstructorParametersStartRecord();
    internal virtual void ReadConstructorParametersEndRecord();
    internal virtual void ReadDeferableContentStart(BamlDeferableContentStartRecord bamlRecord);
    internal void BaseReadDeferableContentStart(BamlDeferableContentStartRecord bamlRecord, ArrayList& defKeyList, List`1& staticResourceValuesList);
    protected virtual void ReadStaticResourceIdRecord(BamlStaticResourceIdRecord bamlStaticResourceIdRecord);
    protected virtual void ReadPropertyWithStaticResourceIdRecord(BamlPropertyWithStaticResourceIdRecord bamlPropertyWithStaticResourceIdRecord);
    internal StaticResourceHolder GetStaticResourceFromId(short staticResourceId);
    internal virtual void ReadLiteralContentRecord(BamlLiteralContentRecord bamlLiteralContentRecord);
    protected virtual void ReadPropertyComplexStartRecord(BamlPropertyComplexStartRecord bamlPropertyRecord);
    protected virtual void ReadPropertyComplexEndRecord();
    internal DependencyProperty GetCustomDependencyPropertyValue(BamlPropertyCustomRecord bamlPropertyRecord);
    internal DependencyProperty GetCustomDependencyPropertyValue(BamlPropertyCustomRecord bamlPropertyRecord, Type& declaringType);
    internal object GetCustomValue(BamlPropertyCustomRecord bamlPropertyRecord, Type propertyType, string propertyName);
    protected virtual void ReadPropertyCustomRecord(BamlPropertyCustomRecord bamlPropertyRecord);
    protected virtual void ReadPropertyRecord(BamlPropertyRecord bamlPropertyRecord);
    protected virtual void ReadPropertyConverterRecord(BamlPropertyWithConverterRecord bamlPropertyRecord);
    protected virtual void ReadPropertyStringRecord(BamlPropertyStringReferenceRecord bamlPropertyRecord);
    internal virtual object GetExtensionValue(IOptimizedMarkupExtension optimizedMarkupExtensionRecord, string propertyName);
    protected virtual void ReadPropertyWithExtensionRecord(BamlPropertyWithExtensionRecord bamlPropertyRecord);
    protected virtual void ReadPropertyTypeRecord(BamlPropertyTypeReferenceRecord bamlPropertyRecord);
    protected void ReadPropertyArrayStartRecord(BamlPropertyArrayStartRecord bamlPropertyArrayStartRecord);
    protected virtual void ReadPropertyArrayEndRecord();
    protected virtual void ReadPropertyIListStartRecord(BamlPropertyIListStartRecord bamlPropertyIListStartRecord);
    protected virtual void ReadPropertyIListEndRecord();
    protected virtual void ReadPropertyIDictionaryStartRecord(BamlPropertyIDictionaryStartRecord bamlPropertyIDictionaryStartRecord);
    protected virtual void ReadPropertyIDictionaryEndRecord();
    protected IDictionary GetDictionaryFromContext(ReaderContextStackData context, bool toInsert);
    protected virtual void ReadDefAttributeRecord(BamlDefAttributeRecord bamlDefAttributeRecord);
    protected virtual void ReadDefAttributeKeyTypeRecord(BamlDefAttributeKeyTypeRecord bamlDefAttributeRecord);
    protected virtual void ReadTextRecord(BamlTextRecord bamlTextRecord);
    protected virtual void ReadPresentationOptionsAttributeRecord(BamlPresentationOptionsAttributeRecord bamlPresentationOptionsAttributeRecord);
    internal static bool IsNullable(Type t);
    internal object OptionallyMakeNullable(Type propertyType, object o, string propName);
    internal static bool TryOptionallyMakeNullable(Type propertyType, string propName, Object& o);
    internal virtual void SetClrComplexPropertyCore(object parentObject, object value, MemberInfo memberInfo);
    protected void SetXmlnsOnCurrentObject(BamlXmlnsPropertyRecord xmlnsRecord);
    internal object ParseProperty(object element, Type propertyType, string propertyName, object dpOrPi, string attribValue, short converterTypeId);
    internal object FindResourceInParserStack(object resourceNameObject, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal object FindResourceInParentChain(object resourceNameObject, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal object LoadResource(string resourceNameString);
    internal object GetCurrentObjectData();
    protected object GetParentObjectData();
    internal void PushContext(ReaderFlags contextFlags, object contextData, Type expectedType, short expectedTypeId);
    internal void PushContext(ReaderFlags contextFlags, object contextData, Type expectedType, short expectedTypeId, bool createUsingTypeConverter);
    internal void PopContext();
    internal string GetPropertyNameFromAttributeId(short id);
    internal string GetPropertyValueFromStringId(short id);
    internal object GetREOrEiFromAttributeId(short id, Boolean& isInternal, Boolean& isRE);
    protected void ThrowException(string id);
    protected internal void ThrowException(string id, string parameter);
    protected void ThrowException(string id, string parameter1, string parameter2);
    protected void ThrowException(string id, string parameter1, string parameter2, string parameter3);
    internal void ThrowExceptionWithLine(string message, Exception innerException);
    internal object CreateInstanceFromType(Type type, short typeId, bool throwOnFail);
    internal void FreezeIfRequired(object element);
    internal void PreParsedBamlReset();
    protected internal void SetPreviousBamlRecordReader(BamlRecordReader previousBamlRecordReader);
    internal BamlRecord get_PreParsedRecordsStart();
    internal void set_PreParsedRecordsStart(BamlRecord value);
    internal BamlRecord get_PreParsedCurrentRecord();
    internal void set_PreParsedCurrentRecord(BamlRecord value);
    internal Stream get_BamlStream();
    internal void set_BamlStream(Stream value);
    internal BamlBinaryReader get_BinaryReader();
    internal XamlTypeMapper get_XamlTypeMapper();
    internal ParserContext get_ParserContext();
    internal void set_ParserContext(ParserContext value);
    internal TypeConvertContext get_TypeConvertContext();
    internal XamlParseMode get_XamlParseMode();
    internal void set_XamlParseMode(XamlParseMode value);
    internal int get_MaxAsyncRecords();
    internal void set_MaxAsyncRecords(int value);
    internal BamlMapTable get_MapTable();
    internal XmlnsDictionary get_XmlnsDictionary();
    internal ReaderContextStackData get_CurrentContext();
    internal ReaderContextStackData get_ParentContext();
    internal object get_ParentObjectData();
    internal ReaderContextStackData get_GrandParentContext();
    internal object get_GrandParentObjectData();
    internal ReaderContextStackData get_GreatGrandParentContext();
    internal ParserStack get_ReaderContextStack();
    internal BamlRecordManager get_BamlRecordManager();
    internal bool get_EndOfDocument();
    internal void set_EndOfDocument(bool value);
    internal object get_RootElement();
    internal void set_RootElement(object value);
    internal IComponentConnector get_ComponentConnector();
    internal void set_ComponentConnector(IComponentConnector value);
    internal ParserStack get_ContextStack();
    internal void set_ContextStack(ParserStack value);
    internal int get_LineNumber();
    internal void set_LineNumber(int value);
    internal int get_LinePosition();
    internal void set_LinePosition(int value);
    internal bool get_IsDebugBamlStream();
    internal void set_IsDebugBamlStream(bool value);
    internal long get_StreamPosition();
    internal bool get_IsRootAlreadyLoaded();
    internal void set_IsRootAlreadyLoaded(bool value);
    internal BamlRecordReader get_PreviousBamlRecordReader();
}
internal enum System.Windows.Markup.BamlRecordType : Enum {
    public byte value__;
    public static BamlRecordType Unknown;
    public static BamlRecordType DocumentStart;
    public static BamlRecordType DocumentEnd;
    public static BamlRecordType ElementStart;
    public static BamlRecordType ElementEnd;
    public static BamlRecordType Property;
    public static BamlRecordType PropertyCustom;
    public static BamlRecordType PropertyComplexStart;
    public static BamlRecordType PropertyComplexEnd;
    public static BamlRecordType PropertyArrayStart;
    public static BamlRecordType PropertyArrayEnd;
    public static BamlRecordType PropertyIListStart;
    public static BamlRecordType PropertyIListEnd;
    public static BamlRecordType PropertyIDictionaryStart;
    public static BamlRecordType PropertyIDictionaryEnd;
    public static BamlRecordType LiteralContent;
    public static BamlRecordType Text;
    public static BamlRecordType TextWithConverter;
    public static BamlRecordType RoutedEvent;
    public static BamlRecordType ClrEvent;
    public static BamlRecordType XmlnsProperty;
    public static BamlRecordType XmlAttribute;
    public static BamlRecordType ProcessingInstruction;
    public static BamlRecordType Comment;
    public static BamlRecordType DefTag;
    public static BamlRecordType DefAttribute;
    public static BamlRecordType EndAttributes;
    public static BamlRecordType PIMapping;
    public static BamlRecordType AssemblyInfo;
    public static BamlRecordType TypeInfo;
    public static BamlRecordType TypeSerializerInfo;
    public static BamlRecordType AttributeInfo;
    public static BamlRecordType StringInfo;
    public static BamlRecordType PropertyStringReference;
    public static BamlRecordType PropertyTypeReference;
    public static BamlRecordType PropertyWithExtension;
    public static BamlRecordType PropertyWithConverter;
    public static BamlRecordType DeferableContentStart;
    public static BamlRecordType DefAttributeKeyString;
    public static BamlRecordType DefAttributeKeyType;
    public static BamlRecordType KeyElementStart;
    public static BamlRecordType KeyElementEnd;
    public static BamlRecordType ConstructorParametersStart;
    public static BamlRecordType ConstructorParametersEnd;
    public static BamlRecordType ConstructorParameterType;
    public static BamlRecordType ConnectionId;
    public static BamlRecordType ContentProperty;
    public static BamlRecordType NamedElementStart;
    public static BamlRecordType StaticResourceStart;
    public static BamlRecordType StaticResourceEnd;
    public static BamlRecordType StaticResourceId;
    public static BamlRecordType TextWithId;
    public static BamlRecordType PresentationOptionsAttribute;
    public static BamlRecordType LineNumberAndPosition;
    public static BamlRecordType LinePosition;
    public static BamlRecordType OptimizedStaticResource;
    public static BamlRecordType PropertyWithStaticResourceId;
    public static BamlRecordType LastRecordType;
}
internal class System.Windows.Markup.BamlRecordWriter : object {
    internal bool UpdateParentNodes { get; }
    public bool DebugBamlStream { get; }
    internal BamlLineAndPositionRecord LineAndPositionRecord { get; }
    internal BamlLinePositionRecord LinePositionRecord { get; }
    public Stream BamlStream { get; }
    internal BamlBinaryWriter BinaryWriter { get; }
    internal BamlMapTable MapTable { get; }
    internal ParserContext ParserContext { get; }
    internal BamlRecordManager BamlRecordManager { get; }
    public BamlRecordWriter(Stream stream, ParserContext parserContext, bool deferLoadingSupport);
    internal virtual void WriteBamlRecord(BamlRecord bamlRecord, int lineNumber, int linePosition);
    internal virtual bool get_UpdateParentNodes();
    internal void SetParseMode(XamlParseMode xamlParseMode);
    internal virtual void SetMaxAsyncRecords(int maxAsyncRecords);
    public bool get_DebugBamlStream();
    internal BamlLineAndPositionRecord get_LineAndPositionRecord();
    internal BamlLinePositionRecord get_LinePositionRecord();
    internal void WriteDebugExtensionRecord(int lineNumber, int linePosition);
    internal void WriteDocumentStart(XamlDocumentStartNode xamlDocumentNode);
    internal void WriteDocumentEnd(XamlDocumentEndNode xamlDocumentEndNode);
    internal void WriteConnectionId(int connectionId);
    internal void WriteElementStart(XamlElementStartNode xamlElementNode);
    internal void WriteElementEnd(XamlElementEndNode xamlElementEndNode);
    internal void WriteEndAttributes(XamlEndAttributesNode xamlEndAttributesNode);
    internal void WriteLiteralContent(XamlLiteralContentNode xamlLiteralContentNode);
    internal void WriteDefAttributeKeyType(XamlDefAttributeKeyTypeNode xamlDefNode);
    internal void WriteDefAttribute(XamlDefAttributeNode xamlDefNode);
    internal void WritePresentationOptionsAttribute(XamlPresentationOptionsAttributeNode xamlPresentationOptionsNode);
    internal void WriteNamespacePrefix(XamlXmlnsPropertyNode xamlXmlnsPropertyNode);
    internal void WritePIMapping(XamlPIMappingNode xamlPIMappingNode);
    internal void WritePropertyComplexStart(XamlPropertyComplexStartNode xamlComplexPropertyNode);
    internal void WritePropertyComplexEnd(XamlPropertyComplexEndNode xamlPropertyComplexEnd);
    public void WriteKeyElementStart(XamlElementStartNode xamlKeyElementNode);
    internal void WriteKeyElementEnd(XamlElementEndNode xamlKeyElementEnd);
    internal void WriteConstructorParametersStart(XamlConstructorParametersStartNode xamlConstructorParametersStartNode);
    internal void WriteConstructorParametersEnd(XamlConstructorParametersEndNode xamlConstructorParametersEndNode);
    internal virtual void WriteContentProperty(XamlContentPropertyNode xamlContentPropertyNode);
    internal virtual void WriteProperty(XamlPropertyNode xamlProperty);
    internal virtual void WritePropertyWithExtension(XamlPropertyWithExtensionNode xamlPropertyNode);
    internal virtual void WritePropertyWithType(XamlPropertyWithTypeNode xamlPropertyWithType);
    internal void BaseWriteProperty(XamlPropertyNode xamlProperty);
    internal void WriteClrEvent(XamlClrEventNode xamlClrEventNode);
    internal void WritePropertyArrayStart(XamlPropertyArrayStartNode xamlPropertyArrayStartNode);
    internal virtual void WritePropertyArrayEnd(XamlPropertyArrayEndNode xamlPropertyArrayEndNode);
    internal void WritePropertyIListStart(XamlPropertyIListStartNode xamlPropertyIListStart);
    internal virtual void WritePropertyIListEnd(XamlPropertyIListEndNode xamlPropertyIListEndNode);
    internal void WritePropertyIDictionaryStart(XamlPropertyIDictionaryStartNode xamlPropertyIDictionaryStartNode);
    internal virtual void WritePropertyIDictionaryEnd(XamlPropertyIDictionaryEndNode xamlPropertyIDictionaryEndNode);
    internal void WriteRoutedEvent(XamlRoutedEventNode xamlRoutedEventNode);
    internal void WriteText(XamlTextNode xamlTextNode);
    public Stream get_BamlStream();
    internal BamlBinaryWriter get_BinaryWriter();
    internal BamlMapTable get_MapTable();
    internal ParserContext get_ParserContext();
    internal virtual BamlRecordManager get_BamlRecordManager();
}
internal class System.Windows.Markup.BamlRoutedEventRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
}
internal class System.Windows.Markup.BamlStaticResourceEndRecord : BamlElementEndRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlStaticResourceIdRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal int RecordSize { get; internal set; }
    internal short StaticResourceId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal short get_StaticResourceId();
    internal void set_StaticResourceId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlStaticResourceStartRecord : BamlElementStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlStringInfoRecord : BamlVariableSizedRecord {
    internal short StringId { get; internal set; }
    internal string Value { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal bool HasSerializer { get; }
    internal static Section LastFlagsSection { get; }
    private static BamlStringInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_StringId();
    internal void set_StringId(short value);
    internal string get_Value();
    internal void set_Value(string value);
    internal virtual BamlRecordType get_RecordType();
    internal virtual bool get_HasSerializer();
    public virtual string ToString();
    internal static Section get_LastFlagsSection();
}
internal abstract class System.Windows.Markup.BamlStringValueRecord : BamlVariableSizedRecord {
    internal string Value { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal string get_Value();
    internal void set_Value(string value);
}
internal class System.Windows.Markup.BamlTextRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlTextWithConverterRecord : BamlTextRecord {
    internal short ConverterTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ConverterTypeId();
    internal void set_ConverterTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlTextWithIdRecord : BamlTextRecord {
    internal BamlRecordType RecordType { get; }
    internal short ValueId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_ValueId();
    internal void set_ValueId(short value);
}
internal class System.Windows.Markup.BamlTypeInfoRecord : BamlVariableSizedRecord {
    internal short TypeId { get; internal set; }
    internal short AssemblyId { get; internal set; }
    internal string TypeFullName { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Type Type { get; internal set; }
    internal string ClrNamespace { get; }
    internal bool HasSerializer { get; }
    internal bool IsInternalType { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlTypeInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal string get_TypeFullName();
    internal void set_TypeFullName(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Type get_Type();
    internal void set_Type(Type value);
    internal string get_ClrNamespace();
    internal virtual bool get_HasSerializer();
    internal bool get_IsInternalType();
    internal void set_IsInternalType(bool value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlTypeInfoWithSerializerRecord : BamlTypeInfoRecord {
    internal short SerializerTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Type SerializerType { get; internal set; }
    internal bool HasSerializer { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_SerializerTypeId();
    internal void set_SerializerTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
    internal Type get_SerializerType();
    internal void set_SerializerType(Type value);
    internal virtual bool get_HasSerializer();
}
internal abstract class System.Windows.Markup.BamlVariableSizedRecord : BamlRecord {
    internal static int MaxRecordSizeFieldLength;
    internal int RecordSize { get; internal set; }
    internal static Section LastFlagsSection { get; }
    internal virtual bool LoadRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable);
    internal static bool LoadVariableRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable, Int32& recordSize);
    protected int ComputeSizeOfVariableLengthRecord(long start, long end);
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal void WriteRecordSize(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlVersionHeader : object {
    internal static VersionPair BamlWriterVersion;
    public FormatVersion BamlVersion { get; public set; }
    public static int BinarySerializationSize { get; }
    private static BamlVersionHeader();
    public FormatVersion get_BamlVersion();
    public void set_BamlVersion(FormatVersion value);
    public static int get_BinarySerializationSize();
    internal void LoadVersion(BinaryReader bamlBinaryReader);
    internal void WriteVersion(BinaryWriter bamlBinaryWriter);
}
internal class System.Windows.Markup.BamlWriter : object {
    public BamlWriter(Stream stream);
    public void Close();
    private sealed virtual override string System.Windows.Markup.IParserHelper.LookupNamespace(string prefix);
    private sealed virtual override bool System.Windows.Markup.IParserHelper.GetElementType(bool extensionFirst, string localName, string namespaceURI, String& assemblyName, String& typeFullName, Type& baseType, Type& serializerType);
    private sealed virtual override bool System.Windows.Markup.IParserHelper.CanResolveLocalAssemblies();
    public void WriteStartDocument();
    public void WriteEndDocument();
    public void WriteConnectionId(int connectionId);
    public void WriteStartElement(string assemblyName, string typeFullName, bool isInjected, bool useTypeConverter);
    public void WriteEndElement();
    public void WriteStartConstructor();
    public void WriteEndConstructor();
    public void WriteProperty(string assemblyName, string ownerTypeFullName, string propName, string value, BamlAttributeUsage propUsage);
    public void WriteContentProperty(string assemblyName, string ownerTypeFullName, string propName);
    public void WriteXmlnsProperty(string localName, string xmlNamespace);
    public void WriteDefAttribute(string name, string value);
    public void WritePresentationOptionsAttribute(string name, string value);
    public void WriteStartComplexProperty(string assemblyName, string ownerTypeFullName, string propName);
    public void WriteEndComplexProperty();
    public void WriteLiteralContent(string contents);
    public void WritePIMapping(string xmlNamespace, string clrNamespace, string assemblyName);
    public void WriteText(string textContent, string typeConverterAssemblyName, string typeConverterName);
    public void WriteRoutedEvent(string assemblyName, string ownerTypeFullName, string eventIdName, string handlerName);
    public void WriteEvent(string eventName, string handlerName);
}
internal class System.Windows.Markup.BamlWriterXamlTypeMapper : XamlTypeMapper {
    internal BamlWriterXamlTypeMapper(String[] assemblyNames, NamespaceMapEntry[] namespaceMaps);
    protected sealed virtual bool AllowInternalType(Type type);
}
internal class System.Windows.Markup.BamlXmlnsPropertyRecord : BamlVariableSizedRecord {
    internal BamlRecordType RecordType { get; }
    internal string Prefix { get; internal set; }
    internal string XmlNamespace { get; internal set; }
    internal Int16[] AssemblyIds { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal string get_Prefix();
    internal void set_Prefix(string value);
    internal string get_XmlNamespace();
    internal void set_XmlNamespace(string value);
    internal Int16[] get_AssemblyIds();
    internal void set_AssemblyIds(Int16[] value);
}
internal class System.Windows.Markup.ClrNamespaceAssemblyPair : ValueType {
    private string _assemblyName;
    private string _clrNamespace;
    internal string AssemblyName { get; }
    internal string ClrNamespace { get; }
    internal ClrNamespaceAssemblyPair(string clrNamespace, string assemblyName);
    internal string get_AssemblyName();
    internal string get_ClrNamespace();
}
public class System.Windows.Markup.ComponentResourceKeyConverter : ExpressionConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.DefAttributeData : object {
    internal Type TargetType;
    internal Type DeclaringType;
    internal string TargetFullName;
    internal string TargetAssemblyName;
    internal string Args;
    internal string TargetNamespaceUri;
    internal int LineNumber;
    internal int LinePosition;
    internal int Depth;
    internal bool IsSimple;
    internal bool IsUnknownExtension { get; }
    internal DefAttributeData(string targetAssemblyName, string targetFullName, Type targetType, string args, Type declaringType, string targetNamespaceUri, int lineNumber, int linePosition, int depth, bool isSimple);
    internal bool get_IsUnknownExtension();
}
public class System.Windows.Markup.DependencyPropertyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static DependencyProperty ResolveProperty(IServiceProvider serviceProvider, string targetName, object source);
}
public class System.Windows.Markup.EventSetterHandlerConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.FilteredXmlReader : XmlTextReader {
    public int AttributeCount { get; }
    public bool HasAttributes { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    internal FilteredXmlReader(string xmlFragment, XmlNodeType fragmentType, XmlParserContext context);
    public virtual int get_AttributeCount();
    public virtual bool get_HasAttributes();
    public virtual string get_Item(int attributeIndex);
    public virtual string get_Item(string attributeName);
    public virtual string get_Item(string localName, string namespaceUri);
    public virtual string GetAttribute(int attributeIndex);
    public virtual string GetAttribute(string attributeName);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual void MoveToAttribute(int attributeIndex);
    public virtual bool MoveToAttribute(string attributeName);
    public virtual bool MoveToAttribute(string localName, string namespaceUri);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
}
internal interface System.Windows.Markup.IBamlDictionaryKey {
    public int ValuePosition { get; public set; }
    public object KeyObject { get; public set; }
    public long ValuePositionPosition { get; public set; }
    public bool Shared { get; public set; }
    public bool SharedSet { get; public set; }
    public Object[] StaticResourceValues { get; public set; }
    public abstract virtual void UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    public abstract virtual int get_ValuePosition();
    public abstract virtual void set_ValuePosition(int value);
    public abstract virtual object get_KeyObject();
    public abstract virtual void set_KeyObject(object value);
    public abstract virtual long get_ValuePositionPosition();
    public abstract virtual void set_ValuePositionPosition(long value);
    public abstract virtual bool get_Shared();
    public abstract virtual void set_Shared(bool value);
    public abstract virtual bool get_SharedSet();
    public abstract virtual void set_SharedSet(bool value);
    public abstract virtual Object[] get_StaticResourceValues();
    public abstract virtual void set_StaticResourceValues(Object[] value);
}
internal interface System.Windows.Markup.IHaveResources {
    public ResourceDictionary Resources { get; public set; }
    public abstract virtual ResourceDictionary get_Resources();
    public abstract virtual void set_Resources(ResourceDictionary value);
}
internal interface System.Windows.Markup.IOptimizedMarkupExtension {
    public short ExtensionTypeId { get; }
    public short ValueId { get; }
    public bool IsValueTypeExtension { get; }
    public bool IsValueStaticExtension { get; }
    public abstract virtual short get_ExtensionTypeId();
    public abstract virtual short get_ValueId();
    public abstract virtual bool get_IsValueTypeExtension();
    public abstract virtual bool get_IsValueStaticExtension();
}
internal interface System.Windows.Markup.IParserHelper {
    public abstract virtual string LookupNamespace(string prefix);
    public abstract virtual bool GetElementType(bool extensionFirst, string localName, string namespaceURI, String& assemblyName, String& typeFullName, Type& baseType, Type& serializerType);
    public abstract virtual bool CanResolveLocalAssemblies();
}
internal interface System.Windows.Markup.IStreamInfo {
    public Assembly Assembly { get; }
    public abstract virtual Assembly get_Assembly();
}
public interface System.Windows.Markup.IStyleConnector {
    public abstract virtual void Connect(int connectionId, object target);
}
internal enum System.Windows.Markup.KnownElements : Enum {
    public short value__;
    public static KnownElements UnknownElement;
    public static KnownElements AccessText;
    public static KnownElements AdornedElementPlaceholder;
    public static KnownElements Adorner;
    public static KnownElements AdornerDecorator;
    public static KnownElements AdornerLayer;
    public static KnownElements AffineTransform3D;
    public static KnownElements AmbientLight;
    public static KnownElements AnchoredBlock;
    public static KnownElements Animatable;
    public static KnownElements AnimationClock;
    public static KnownElements AnimationTimeline;
    public static KnownElements Application;
    public static KnownElements ArcSegment;
    public static KnownElements ArrayExtension;
    public static KnownElements AxisAngleRotation3D;
    public static KnownElements BaseIListConverter;
    public static KnownElements BeginStoryboard;
    public static KnownElements BevelBitmapEffect;
    public static KnownElements BezierSegment;
    public static KnownElements Binding;
    public static KnownElements BindingBase;
    public static KnownElements BindingExpression;
    public static KnownElements BindingExpressionBase;
    public static KnownElements BindingListCollectionView;
    public static KnownElements BitmapDecoder;
    public static KnownElements BitmapEffect;
    public static KnownElements BitmapEffectCollection;
    public static KnownElements BitmapEffectGroup;
    public static KnownElements BitmapEffectInput;
    public static KnownElements BitmapEncoder;
    public static KnownElements BitmapFrame;
    public static KnownElements BitmapImage;
    public static KnownElements BitmapMetadata;
    public static KnownElements BitmapPalette;
    public static KnownElements BitmapSource;
    public static KnownElements Block;
    public static KnownElements BlockUIContainer;
    public static KnownElements BlurBitmapEffect;
    public static KnownElements BmpBitmapDecoder;
    public static KnownElements BmpBitmapEncoder;
    public static KnownElements Bold;
    public static KnownElements BoolIListConverter;
    public static KnownElements Boolean;
    public static KnownElements BooleanAnimationBase;
    public static KnownElements BooleanAnimationUsingKeyFrames;
    public static KnownElements BooleanConverter;
    public static KnownElements BooleanKeyFrame;
    public static KnownElements BooleanKeyFrameCollection;
    public static KnownElements BooleanToVisibilityConverter;
    public static KnownElements Border;
    public static KnownElements BorderGapMaskConverter;
    public static KnownElements Brush;
    public static KnownElements BrushConverter;
    public static KnownElements BulletDecorator;
    public static KnownElements Button;
    public static KnownElements ButtonBase;
    public static KnownElements Byte;
    public static KnownElements ByteAnimation;
    public static KnownElements ByteAnimationBase;
    public static KnownElements ByteAnimationUsingKeyFrames;
    public static KnownElements ByteConverter;
    public static KnownElements ByteKeyFrame;
    public static KnownElements ByteKeyFrameCollection;
    public static KnownElements CachedBitmap;
    public static KnownElements Camera;
    public static KnownElements Canvas;
    public static KnownElements Char;
    public static KnownElements CharAnimationBase;
    public static KnownElements CharAnimationUsingKeyFrames;
    public static KnownElements CharConverter;
    public static KnownElements CharIListConverter;
    public static KnownElements CharKeyFrame;
    public static KnownElements CharKeyFrameCollection;
    public static KnownElements CheckBox;
    public static KnownElements Clock;
    public static KnownElements ClockController;
    public static KnownElements ClockGroup;
    public static KnownElements CollectionContainer;
    public static KnownElements CollectionView;
    public static KnownElements CollectionViewSource;
    public static KnownElements Color;
    public static KnownElements ColorAnimation;
    public static KnownElements ColorAnimationBase;
    public static KnownElements ColorAnimationUsingKeyFrames;
    public static KnownElements ColorConvertedBitmap;
    public static KnownElements ColorConvertedBitmapExtension;
    public static KnownElements ColorConverter;
    public static KnownElements ColorKeyFrame;
    public static KnownElements ColorKeyFrameCollection;
    public static KnownElements ColumnDefinition;
    public static KnownElements CombinedGeometry;
    public static KnownElements ComboBox;
    public static KnownElements ComboBoxItem;
    public static KnownElements CommandConverter;
    public static KnownElements ComponentResourceKey;
    public static KnownElements ComponentResourceKeyConverter;
    public static KnownElements CompositionTarget;
    public static KnownElements Condition;
    public static KnownElements ContainerVisual;
    public static KnownElements ContentControl;
    public static KnownElements ContentElement;
    public static KnownElements ContentPresenter;
    public static KnownElements ContentPropertyAttribute;
    public static KnownElements ContentWrapperAttribute;
    public static KnownElements ContextMenu;
    public static KnownElements ContextMenuService;
    public static KnownElements Control;
    public static KnownElements ControlTemplate;
    public static KnownElements ControllableStoryboardAction;
    public static KnownElements CornerRadius;
    public static KnownElements CornerRadiusConverter;
    public static KnownElements CroppedBitmap;
    public static KnownElements CultureInfo;
    public static KnownElements CultureInfoConverter;
    public static KnownElements CultureInfoIetfLanguageTagConverter;
    public static KnownElements Cursor;
    public static KnownElements CursorConverter;
    public static KnownElements DashStyle;
    public static KnownElements DataChangedEventManager;
    public static KnownElements DataTemplate;
    public static KnownElements DataTemplateKey;
    public static KnownElements DataTrigger;
    public static KnownElements DateTime;
    public static KnownElements DateTimeConverter;
    public static KnownElements DateTimeConverter2;
    public static KnownElements Decimal;
    public static KnownElements DecimalAnimation;
    public static KnownElements DecimalAnimationBase;
    public static KnownElements DecimalAnimationUsingKeyFrames;
    public static KnownElements DecimalConverter;
    public static KnownElements DecimalKeyFrame;
    public static KnownElements DecimalKeyFrameCollection;
    public static KnownElements Decorator;
    public static KnownElements DefinitionBase;
    public static KnownElements DependencyObject;
    public static KnownElements DependencyProperty;
    public static KnownElements DependencyPropertyConverter;
    public static KnownElements DialogResultConverter;
    public static KnownElements DiffuseMaterial;
    public static KnownElements DirectionalLight;
    public static KnownElements DiscreteBooleanKeyFrame;
    public static KnownElements DiscreteByteKeyFrame;
    public static KnownElements DiscreteCharKeyFrame;
    public static KnownElements DiscreteColorKeyFrame;
    public static KnownElements DiscreteDecimalKeyFrame;
    public static KnownElements DiscreteDoubleKeyFrame;
    public static KnownElements DiscreteInt16KeyFrame;
    public static KnownElements DiscreteInt32KeyFrame;
    public static KnownElements DiscreteInt64KeyFrame;
    public static KnownElements DiscreteMatrixKeyFrame;
    public static KnownElements DiscreteObjectKeyFrame;
    public static KnownElements DiscretePoint3DKeyFrame;
    public static KnownElements DiscretePointKeyFrame;
    public static KnownElements DiscreteQuaternionKeyFrame;
    public static KnownElements DiscreteRectKeyFrame;
    public static KnownElements DiscreteRotation3DKeyFrame;
    public static KnownElements DiscreteSingleKeyFrame;
    public static KnownElements DiscreteSizeKeyFrame;
    public static KnownElements DiscreteStringKeyFrame;
    public static KnownElements DiscreteThicknessKeyFrame;
    public static KnownElements DiscreteVector3DKeyFrame;
    public static KnownElements DiscreteVectorKeyFrame;
    public static KnownElements DockPanel;
    public static KnownElements DocumentPageView;
    public static KnownElements DocumentReference;
    public static KnownElements DocumentViewer;
    public static KnownElements DocumentViewerBase;
    public static KnownElements Double;
    public static KnownElements DoubleAnimation;
    public static KnownElements DoubleAnimationBase;
    public static KnownElements DoubleAnimationUsingKeyFrames;
    public static KnownElements DoubleAnimationUsingPath;
    public static KnownElements DoubleCollection;
    public static KnownElements DoubleCollectionConverter;
    public static KnownElements DoubleConverter;
    public static KnownElements DoubleIListConverter;
    public static KnownElements DoubleKeyFrame;
    public static KnownElements DoubleKeyFrameCollection;
    public static KnownElements Drawing;
    public static KnownElements DrawingBrush;
    public static KnownElements DrawingCollection;
    public static KnownElements DrawingContext;
    public static KnownElements DrawingGroup;
    public static KnownElements DrawingImage;
    public static KnownElements DrawingVisual;
    public static KnownElements DropShadowBitmapEffect;
    public static KnownElements Duration;
    public static KnownElements DurationConverter;
    public static KnownElements DynamicResourceExtension;
    public static KnownElements DynamicResourceExtensionConverter;
    public static KnownElements Ellipse;
    public static KnownElements EllipseGeometry;
    public static KnownElements EmbossBitmapEffect;
    public static KnownElements EmissiveMaterial;
    public static KnownElements EnumConverter;
    public static KnownElements EventManager;
    public static KnownElements EventSetter;
    public static KnownElements EventTrigger;
    public static KnownElements Expander;
    public static KnownElements Expression;
    public static KnownElements ExpressionConverter;
    public static KnownElements Figure;
    public static KnownElements FigureLength;
    public static KnownElements FigureLengthConverter;
    public static KnownElements FixedDocument;
    public static KnownElements FixedDocumentSequence;
    public static KnownElements FixedPage;
    public static KnownElements Floater;
    public static KnownElements FlowDocument;
    public static KnownElements FlowDocumentPageViewer;
    public static KnownElements FlowDocumentReader;
    public static KnownElements FlowDocumentScrollViewer;
    public static KnownElements FocusManager;
    public static KnownElements FontFamily;
    public static KnownElements FontFamilyConverter;
    public static KnownElements FontSizeConverter;
    public static KnownElements FontStretch;
    public static KnownElements FontStretchConverter;
    public static KnownElements FontStyle;
    public static KnownElements FontStyleConverter;
    public static KnownElements FontWeight;
    public static KnownElements FontWeightConverter;
    public static KnownElements FormatConvertedBitmap;
    public static KnownElements Frame;
    public static KnownElements FrameworkContentElement;
    public static KnownElements FrameworkElement;
    public static KnownElements FrameworkElementFactory;
    public static KnownElements FrameworkPropertyMetadata;
    public static KnownElements FrameworkPropertyMetadataOptions;
    public static KnownElements FrameworkRichTextComposition;
    public static KnownElements FrameworkTemplate;
    public static KnownElements FrameworkTextComposition;
    public static KnownElements Freezable;
    public static KnownElements GeneralTransform;
    public static KnownElements GeneralTransformCollection;
    public static KnownElements GeneralTransformGroup;
    public static KnownElements Geometry;
    public static KnownElements Geometry3D;
    public static KnownElements GeometryCollection;
    public static KnownElements GeometryConverter;
    public static KnownElements GeometryDrawing;
    public static KnownElements GeometryGroup;
    public static KnownElements GeometryModel3D;
    public static KnownElements GestureRecognizer;
    public static KnownElements GifBitmapDecoder;
    public static KnownElements GifBitmapEncoder;
    public static KnownElements GlyphRun;
    public static KnownElements GlyphRunDrawing;
    public static KnownElements GlyphTypeface;
    public static KnownElements Glyphs;
    public static KnownElements GradientBrush;
    public static KnownElements GradientStop;
    public static KnownElements GradientStopCollection;
    public static KnownElements Grid;
    public static KnownElements GridLength;
    public static KnownElements GridLengthConverter;
    public static KnownElements GridSplitter;
    public static KnownElements GridView;
    public static KnownElements GridViewColumn;
    public static KnownElements GridViewColumnHeader;
    public static KnownElements GridViewHeaderRowPresenter;
    public static KnownElements GridViewRowPresenter;
    public static KnownElements GridViewRowPresenterBase;
    public static KnownElements GroupBox;
    public static KnownElements GroupItem;
    public static KnownElements Guid;
    public static KnownElements GuidConverter;
    public static KnownElements GuidelineSet;
    public static KnownElements HeaderedContentControl;
    public static KnownElements HeaderedItemsControl;
    public static KnownElements HierarchicalDataTemplate;
    public static KnownElements HostVisual;
    public static KnownElements Hyperlink;
    public static KnownElements IAddChild;
    public static KnownElements IAddChildInternal;
    public static KnownElements ICommand;
    public static KnownElements IComponentConnector;
    public static KnownElements INameScope;
    public static KnownElements IStyleConnector;
    public static KnownElements IconBitmapDecoder;
    public static KnownElements Image;
    public static KnownElements ImageBrush;
    public static KnownElements ImageDrawing;
    public static KnownElements ImageMetadata;
    public static KnownElements ImageSource;
    public static KnownElements ImageSourceConverter;
    public static KnownElements InPlaceBitmapMetadataWriter;
    public static KnownElements InkCanvas;
    public static KnownElements InkPresenter;
    public static KnownElements Inline;
    public static KnownElements InlineCollection;
    public static KnownElements InlineUIContainer;
    public static KnownElements InputBinding;
    public static KnownElements InputDevice;
    public static KnownElements InputLanguageManager;
    public static KnownElements InputManager;
    public static KnownElements InputMethod;
    public static KnownElements InputScope;
    public static KnownElements InputScopeConverter;
    public static KnownElements InputScopeName;
    public static KnownElements InputScopeNameConverter;
    public static KnownElements Int16;
    public static KnownElements Int16Animation;
    public static KnownElements Int16AnimationBase;
    public static KnownElements Int16AnimationUsingKeyFrames;
    public static KnownElements Int16Converter;
    public static KnownElements Int16KeyFrame;
    public static KnownElements Int16KeyFrameCollection;
    public static KnownElements Int32;
    public static KnownElements Int32Animation;
    public static KnownElements Int32AnimationBase;
    public static KnownElements Int32AnimationUsingKeyFrames;
    public static KnownElements Int32Collection;
    public static KnownElements Int32CollectionConverter;
    public static KnownElements Int32Converter;
    public static KnownElements Int32KeyFrame;
    public static KnownElements Int32KeyFrameCollection;
    public static KnownElements Int32Rect;
    public static KnownElements Int32RectConverter;
    public static KnownElements Int64;
    public static KnownElements Int64Animation;
    public static KnownElements Int64AnimationBase;
    public static KnownElements Int64AnimationUsingKeyFrames;
    public static KnownElements Int64Converter;
    public static KnownElements Int64KeyFrame;
    public static KnownElements Int64KeyFrameCollection;
    public static KnownElements Italic;
    public static KnownElements ItemCollection;
    public static KnownElements ItemsControl;
    public static KnownElements ItemsPanelTemplate;
    public static KnownElements ItemsPresenter;
    public static KnownElements JournalEntry;
    public static KnownElements JournalEntryListConverter;
    public static KnownElements JournalEntryUnifiedViewConverter;
    public static KnownElements JpegBitmapDecoder;
    public static KnownElements JpegBitmapEncoder;
    public static KnownElements KeyBinding;
    public static KnownElements KeyConverter;
    public static KnownElements KeyGesture;
    public static KnownElements KeyGestureConverter;
    public static KnownElements KeySpline;
    public static KnownElements KeySplineConverter;
    public static KnownElements KeyTime;
    public static KnownElements KeyTimeConverter;
    public static KnownElements KeyboardDevice;
    public static KnownElements Label;
    public static KnownElements LateBoundBitmapDecoder;
    public static KnownElements LengthConverter;
    public static KnownElements Light;
    public static KnownElements Line;
    public static KnownElements LineBreak;
    public static KnownElements LineGeometry;
    public static KnownElements LineSegment;
    public static KnownElements LinearByteKeyFrame;
    public static KnownElements LinearColorKeyFrame;
    public static KnownElements LinearDecimalKeyFrame;
    public static KnownElements LinearDoubleKeyFrame;
    public static KnownElements LinearGradientBrush;
    public static KnownElements LinearInt16KeyFrame;
    public static KnownElements LinearInt32KeyFrame;
    public static KnownElements LinearInt64KeyFrame;
    public static KnownElements LinearPoint3DKeyFrame;
    public static KnownElements LinearPointKeyFrame;
    public static KnownElements LinearQuaternionKeyFrame;
    public static KnownElements LinearRectKeyFrame;
    public static KnownElements LinearRotation3DKeyFrame;
    public static KnownElements LinearSingleKeyFrame;
    public static KnownElements LinearSizeKeyFrame;
    public static KnownElements LinearThicknessKeyFrame;
    public static KnownElements LinearVector3DKeyFrame;
    public static KnownElements LinearVectorKeyFrame;
    public static KnownElements List;
    public static KnownElements ListBox;
    public static KnownElements ListBoxItem;
    public static KnownElements ListCollectionView;
    public static KnownElements ListItem;
    public static KnownElements ListView;
    public static KnownElements ListViewItem;
    public static KnownElements Localization;
    public static KnownElements LostFocusEventManager;
    public static KnownElements MarkupExtension;
    public static KnownElements Material;
    public static KnownElements MaterialCollection;
    public static KnownElements MaterialGroup;
    public static KnownElements Matrix;
    public static KnownElements Matrix3D;
    public static KnownElements Matrix3DConverter;
    public static KnownElements MatrixAnimationBase;
    public static KnownElements MatrixAnimationUsingKeyFrames;
    public static KnownElements MatrixAnimationUsingPath;
    public static KnownElements MatrixCamera;
    public static KnownElements MatrixConverter;
    public static KnownElements MatrixKeyFrame;
    public static KnownElements MatrixKeyFrameCollection;
    public static KnownElements MatrixTransform;
    public static KnownElements MatrixTransform3D;
    public static KnownElements MediaClock;
    public static KnownElements MediaElement;
    public static KnownElements MediaPlayer;
    public static KnownElements MediaTimeline;
    public static KnownElements Menu;
    public static KnownElements MenuBase;
    public static KnownElements MenuItem;
    public static KnownElements MenuScrollingVisibilityConverter;
    public static KnownElements MeshGeometry3D;
    public static KnownElements Model3D;
    public static KnownElements Model3DCollection;
    public static KnownElements Model3DGroup;
    public static KnownElements ModelVisual3D;
    public static KnownElements ModifierKeysConverter;
    public static KnownElements MouseActionConverter;
    public static KnownElements MouseBinding;
    public static KnownElements MouseDevice;
    public static KnownElements MouseGesture;
    public static KnownElements MouseGestureConverter;
    public static KnownElements MultiBinding;
    public static KnownElements MultiBindingExpression;
    public static KnownElements MultiDataTrigger;
    public static KnownElements MultiTrigger;
    public static KnownElements NameScope;
    public static KnownElements NavigationWindow;
    public static KnownElements NullExtension;
    public static KnownElements NullableBoolConverter;
    public static KnownElements NullableConverter;
    public static KnownElements NumberSubstitution;
    public static KnownElements Object;
    public static KnownElements ObjectAnimationBase;
    public static KnownElements ObjectAnimationUsingKeyFrames;
    public static KnownElements ObjectDataProvider;
    public static KnownElements ObjectKeyFrame;
    public static KnownElements ObjectKeyFrameCollection;
    public static KnownElements OrthographicCamera;
    public static KnownElements OuterGlowBitmapEffect;
    public static KnownElements Page;
    public static KnownElements PageContent;
    public static KnownElements PageFunctionBase;
    public static KnownElements Panel;
    public static KnownElements Paragraph;
    public static KnownElements ParallelTimeline;
    public static KnownElements ParserContext;
    public static KnownElements PasswordBox;
    public static KnownElements Path;
    public static KnownElements PathFigure;
    public static KnownElements PathFigureCollection;
    public static KnownElements PathFigureCollectionConverter;
    public static KnownElements PathGeometry;
    public static KnownElements PathSegment;
    public static KnownElements PathSegmentCollection;
    public static KnownElements PauseStoryboard;
    public static KnownElements Pen;
    public static KnownElements PerspectiveCamera;
    public static KnownElements PixelFormat;
    public static KnownElements PixelFormatConverter;
    public static KnownElements PngBitmapDecoder;
    public static KnownElements PngBitmapEncoder;
    public static KnownElements Point;
    public static KnownElements Point3D;
    public static KnownElements Point3DAnimation;
    public static KnownElements Point3DAnimationBase;
    public static KnownElements Point3DAnimationUsingKeyFrames;
    public static KnownElements Point3DCollection;
    public static KnownElements Point3DCollectionConverter;
    public static KnownElements Point3DConverter;
    public static KnownElements Point3DKeyFrame;
    public static KnownElements Point3DKeyFrameCollection;
    public static KnownElements Point4D;
    public static KnownElements Point4DConverter;
    public static KnownElements PointAnimation;
    public static KnownElements PointAnimationBase;
    public static KnownElements PointAnimationUsingKeyFrames;
    public static KnownElements PointAnimationUsingPath;
    public static KnownElements PointCollection;
    public static KnownElements PointCollectionConverter;
    public static KnownElements PointConverter;
    public static KnownElements PointIListConverter;
    public static KnownElements PointKeyFrame;
    public static KnownElements PointKeyFrameCollection;
    public static KnownElements PointLight;
    public static KnownElements PointLightBase;
    public static KnownElements PolyBezierSegment;
    public static KnownElements PolyLineSegment;
    public static KnownElements PolyQuadraticBezierSegment;
    public static KnownElements Polygon;
    public static KnownElements Polyline;
    public static KnownElements Popup;
    public static KnownElements PresentationSource;
    public static KnownElements PriorityBinding;
    public static KnownElements PriorityBindingExpression;
    public static KnownElements ProgressBar;
    public static KnownElements ProjectionCamera;
    public static KnownElements PropertyPath;
    public static KnownElements PropertyPathConverter;
    public static KnownElements QuadraticBezierSegment;
    public static KnownElements Quaternion;
    public static KnownElements QuaternionAnimation;
    public static KnownElements QuaternionAnimationBase;
    public static KnownElements QuaternionAnimationUsingKeyFrames;
    public static KnownElements QuaternionConverter;
    public static KnownElements QuaternionKeyFrame;
    public static KnownElements QuaternionKeyFrameCollection;
    public static KnownElements QuaternionRotation3D;
    public static KnownElements RadialGradientBrush;
    public static KnownElements RadioButton;
    public static KnownElements RangeBase;
    public static KnownElements Rect;
    public static KnownElements Rect3D;
    public static KnownElements Rect3DConverter;
    public static KnownElements RectAnimation;
    public static KnownElements RectAnimationBase;
    public static KnownElements RectAnimationUsingKeyFrames;
    public static KnownElements RectConverter;
    public static KnownElements RectKeyFrame;
    public static KnownElements RectKeyFrameCollection;
    public static KnownElements Rectangle;
    public static KnownElements RectangleGeometry;
    public static KnownElements RelativeSource;
    public static KnownElements RemoveStoryboard;
    public static KnownElements RenderOptions;
    public static KnownElements RenderTargetBitmap;
    public static KnownElements RepeatBehavior;
    public static KnownElements RepeatBehaviorConverter;
    public static KnownElements RepeatButton;
    public static KnownElements ResizeGrip;
    public static KnownElements ResourceDictionary;
    public static KnownElements ResourceKey;
    public static KnownElements ResumeStoryboard;
    public static KnownElements RichTextBox;
    public static KnownElements RotateTransform;
    public static KnownElements RotateTransform3D;
    public static KnownElements Rotation3D;
    public static KnownElements Rotation3DAnimation;
    public static KnownElements Rotation3DAnimationBase;
    public static KnownElements Rotation3DAnimationUsingKeyFrames;
    public static KnownElements Rotation3DKeyFrame;
    public static KnownElements Rotation3DKeyFrameCollection;
    public static KnownElements RoutedCommand;
    public static KnownElements RoutedEvent;
    public static KnownElements RoutedEventConverter;
    public static KnownElements RoutedUICommand;
    public static KnownElements RoutingStrategy;
    public static KnownElements RowDefinition;
    public static KnownElements Run;
    public static KnownElements RuntimeNamePropertyAttribute;
    public static KnownElements SByte;
    public static KnownElements SByteConverter;
    public static KnownElements ScaleTransform;
    public static KnownElements ScaleTransform3D;
    public static KnownElements ScrollBar;
    public static KnownElements ScrollContentPresenter;
    public static KnownElements ScrollViewer;
    public static KnownElements Section;
    public static KnownElements SeekStoryboard;
    public static KnownElements Selector;
    public static KnownElements Separator;
    public static KnownElements SetStoryboardSpeedRatio;
    public static KnownElements Setter;
    public static KnownElements SetterBase;
    public static KnownElements Shape;
    public static KnownElements Single;
    public static KnownElements SingleAnimation;
    public static KnownElements SingleAnimationBase;
    public static KnownElements SingleAnimationUsingKeyFrames;
    public static KnownElements SingleConverter;
    public static KnownElements SingleKeyFrame;
    public static KnownElements SingleKeyFrameCollection;
    public static KnownElements Size;
    public static KnownElements Size3D;
    public static KnownElements Size3DConverter;
    public static KnownElements SizeAnimation;
    public static KnownElements SizeAnimationBase;
    public static KnownElements SizeAnimationUsingKeyFrames;
    public static KnownElements SizeConverter;
    public static KnownElements SizeKeyFrame;
    public static KnownElements SizeKeyFrameCollection;
    public static KnownElements SkewTransform;
    public static KnownElements SkipStoryboardToFill;
    public static KnownElements Slider;
    public static KnownElements SolidColorBrush;
    public static KnownElements SoundPlayerAction;
    public static KnownElements Span;
    public static KnownElements SpecularMaterial;
    public static KnownElements SpellCheck;
    public static KnownElements SplineByteKeyFrame;
    public static KnownElements SplineColorKeyFrame;
    public static KnownElements SplineDecimalKeyFrame;
    public static KnownElements SplineDoubleKeyFrame;
    public static KnownElements SplineInt16KeyFrame;
    public static KnownElements SplineInt32KeyFrame;
    public static KnownElements SplineInt64KeyFrame;
    public static KnownElements SplinePoint3DKeyFrame;
    public static KnownElements SplinePointKeyFrame;
    public static KnownElements SplineQuaternionKeyFrame;
    public static KnownElements SplineRectKeyFrame;
    public static KnownElements SplineRotation3DKeyFrame;
    public static KnownElements SplineSingleKeyFrame;
    public static KnownElements SplineSizeKeyFrame;
    public static KnownElements SplineThicknessKeyFrame;
    public static KnownElements SplineVector3DKeyFrame;
    public static KnownElements SplineVectorKeyFrame;
    public static KnownElements SpotLight;
    public static KnownElements StackPanel;
    public static KnownElements StaticExtension;
    public static KnownElements StaticResourceExtension;
    public static KnownElements StatusBar;
    public static KnownElements StatusBarItem;
    public static KnownElements StickyNoteControl;
    public static KnownElements StopStoryboard;
    public static KnownElements Storyboard;
    public static KnownElements StreamGeometry;
    public static KnownElements StreamGeometryContext;
    public static KnownElements StreamResourceInfo;
    public static KnownElements String;
    public static KnownElements StringAnimationBase;
    public static KnownElements StringAnimationUsingKeyFrames;
    public static KnownElements StringConverter;
    public static KnownElements StringKeyFrame;
    public static KnownElements StringKeyFrameCollection;
    public static KnownElements StrokeCollection;
    public static KnownElements StrokeCollectionConverter;
    public static KnownElements Style;
    public static KnownElements Stylus;
    public static KnownElements StylusDevice;
    public static KnownElements TabControl;
    public static KnownElements TabItem;
    public static KnownElements TabPanel;
    public static KnownElements Table;
    public static KnownElements TableCell;
    public static KnownElements TableColumn;
    public static KnownElements TableRow;
    public static KnownElements TableRowGroup;
    public static KnownElements TabletDevice;
    public static KnownElements TemplateBindingExpression;
    public static KnownElements TemplateBindingExpressionConverter;
    public static KnownElements TemplateBindingExtension;
    public static KnownElements TemplateBindingExtensionConverter;
    public static KnownElements TemplateKey;
    public static KnownElements TemplateKeyConverter;
    public static KnownElements TextBlock;
    public static KnownElements TextBox;
    public static KnownElements TextBoxBase;
    public static KnownElements TextComposition;
    public static KnownElements TextCompositionManager;
    public static KnownElements TextDecoration;
    public static KnownElements TextDecorationCollection;
    public static KnownElements TextDecorationCollectionConverter;
    public static KnownElements TextEffect;
    public static KnownElements TextEffectCollection;
    public static KnownElements TextElement;
    public static KnownElements TextSearch;
    public static KnownElements ThemeDictionaryExtension;
    public static KnownElements Thickness;
    public static KnownElements ThicknessAnimation;
    public static KnownElements ThicknessAnimationBase;
    public static KnownElements ThicknessAnimationUsingKeyFrames;
    public static KnownElements ThicknessConverter;
    public static KnownElements ThicknessKeyFrame;
    public static KnownElements ThicknessKeyFrameCollection;
    public static KnownElements Thumb;
    public static KnownElements TickBar;
    public static KnownElements TiffBitmapDecoder;
    public static KnownElements TiffBitmapEncoder;
    public static KnownElements TileBrush;
    public static KnownElements TimeSpan;
    public static KnownElements TimeSpanConverter;
    public static KnownElements Timeline;
    public static KnownElements TimelineCollection;
    public static KnownElements TimelineGroup;
    public static KnownElements ToggleButton;
    public static KnownElements ToolBar;
    public static KnownElements ToolBarOverflowPanel;
    public static KnownElements ToolBarPanel;
    public static KnownElements ToolBarTray;
    public static KnownElements ToolTip;
    public static KnownElements ToolTipService;
    public static KnownElements Track;
    public static KnownElements Transform;
    public static KnownElements Transform3D;
    public static KnownElements Transform3DCollection;
    public static KnownElements Transform3DGroup;
    public static KnownElements TransformCollection;
    public static KnownElements TransformConverter;
    public static KnownElements TransformGroup;
    public static KnownElements TransformedBitmap;
    public static KnownElements TranslateTransform;
    public static KnownElements TranslateTransform3D;
    public static KnownElements TreeView;
    public static KnownElements TreeViewItem;
    public static KnownElements Trigger;
    public static KnownElements TriggerAction;
    public static KnownElements TriggerBase;
    public static KnownElements TypeExtension;
    public static KnownElements TypeTypeConverter;
    public static KnownElements Typography;
    public static KnownElements UIElement;
    public static KnownElements UInt16;
    public static KnownElements UInt16Converter;
    public static KnownElements UInt32;
    public static KnownElements UInt32Converter;
    public static KnownElements UInt64;
    public static KnownElements UInt64Converter;
    public static KnownElements UShortIListConverter;
    public static KnownElements Underline;
    public static KnownElements UniformGrid;
    public static KnownElements Uri;
    public static KnownElements UriTypeConverter;
    public static KnownElements UserControl;
    public static KnownElements Validation;
    public static KnownElements Vector;
    public static KnownElements Vector3D;
    public static KnownElements Vector3DAnimation;
    public static KnownElements Vector3DAnimationBase;
    public static KnownElements Vector3DAnimationUsingKeyFrames;
    public static KnownElements Vector3DCollection;
    public static KnownElements Vector3DCollectionConverter;
    public static KnownElements Vector3DConverter;
    public static KnownElements Vector3DKeyFrame;
    public static KnownElements Vector3DKeyFrameCollection;
    public static KnownElements VectorAnimation;
    public static KnownElements VectorAnimationBase;
    public static KnownElements VectorAnimationUsingKeyFrames;
    public static KnownElements VectorCollection;
    public static KnownElements VectorCollectionConverter;
    public static KnownElements VectorConverter;
    public static KnownElements VectorKeyFrame;
    public static KnownElements VectorKeyFrameCollection;
    public static KnownElements VideoDrawing;
    public static KnownElements ViewBase;
    public static KnownElements Viewbox;
    public static KnownElements Viewport3D;
    public static KnownElements Viewport3DVisual;
    public static KnownElements VirtualizingPanel;
    public static KnownElements VirtualizingStackPanel;
    public static KnownElements Visual;
    public static KnownElements Visual3D;
    public static KnownElements VisualBrush;
    public static KnownElements VisualTarget;
    public static KnownElements WeakEventManager;
    public static KnownElements WhitespaceSignificantCollectionAttribute;
    public static KnownElements Window;
    public static KnownElements WmpBitmapDecoder;
    public static KnownElements WmpBitmapEncoder;
    public static KnownElements WrapPanel;
    public static KnownElements WriteableBitmap;
    public static KnownElements XamlBrushSerializer;
    public static KnownElements XamlInt32CollectionSerializer;
    public static KnownElements XamlPathDataSerializer;
    public static KnownElements XamlPoint3DCollectionSerializer;
    public static KnownElements XamlPointCollectionSerializer;
    public static KnownElements XamlReader;
    public static KnownElements XamlStyleSerializer;
    public static KnownElements XamlTemplateSerializer;
    public static KnownElements XamlVector3DCollectionSerializer;
    public static KnownElements XamlWriter;
    public static KnownElements XmlDataProvider;
    public static KnownElements XmlLangPropertyAttribute;
    public static KnownElements XmlLanguage;
    public static KnownElements XmlLanguageConverter;
    public static KnownElements XmlNamespaceMapping;
    public static KnownElements ZoomPercentageConverter;
    public static KnownElements MaxElement;
}
internal enum System.Windows.Markup.KnownProperties : Enum {
    public short value__;
    public static KnownProperties UnknownProperty;
    public static KnownProperties AccessText_Text;
    public static KnownProperties BeginStoryboard_Storyboard;
    public static KnownProperties BitmapEffectGroup_Children;
    public static KnownProperties Border_Background;
    public static KnownProperties Border_BorderBrush;
    public static KnownProperties Border_BorderThickness;
    public static KnownProperties ButtonBase_Command;
    public static KnownProperties ButtonBase_CommandParameter;
    public static KnownProperties ButtonBase_CommandTarget;
    public static KnownProperties ButtonBase_IsPressed;
    public static KnownProperties ColumnDefinition_MaxWidth;
    public static KnownProperties ColumnDefinition_MinWidth;
    public static KnownProperties ColumnDefinition_Width;
    public static KnownProperties ContentControl_Content;
    public static KnownProperties ContentControl_ContentTemplate;
    public static KnownProperties ContentControl_ContentTemplateSelector;
    public static KnownProperties ContentControl_HasContent;
    public static KnownProperties ContentElement_Focusable;
    public static KnownProperties ContentPresenter_Content;
    public static KnownProperties ContentPresenter_ContentSource;
    public static KnownProperties ContentPresenter_ContentTemplate;
    public static KnownProperties ContentPresenter_ContentTemplateSelector;
    public static KnownProperties ContentPresenter_RecognizesAccessKey;
    public static KnownProperties Control_Background;
    public static KnownProperties Control_BorderBrush;
    public static KnownProperties Control_BorderThickness;
    public static KnownProperties Control_FontFamily;
    public static KnownProperties Control_FontSize;
    public static KnownProperties Control_FontStretch;
    public static KnownProperties Control_FontStyle;
    public static KnownProperties Control_FontWeight;
    public static KnownProperties Control_Foreground;
    public static KnownProperties Control_HorizontalContentAlignment;
    public static KnownProperties Control_IsTabStop;
    public static KnownProperties Control_Padding;
    public static KnownProperties Control_TabIndex;
    public static KnownProperties Control_Template;
    public static KnownProperties Control_VerticalContentAlignment;
    public static KnownProperties DockPanel_Dock;
    public static KnownProperties DockPanel_LastChildFill;
    public static KnownProperties DocumentViewerBase_Document;
    public static KnownProperties DrawingGroup_Children;
    public static KnownProperties FlowDocumentReader_Document;
    public static KnownProperties FlowDocumentScrollViewer_Document;
    public static KnownProperties FrameworkContentElement_Style;
    public static KnownProperties FrameworkElement_FlowDirection;
    public static KnownProperties FrameworkElement_Height;
    public static KnownProperties FrameworkElement_HorizontalAlignment;
    public static KnownProperties FrameworkElement_Margin;
    public static KnownProperties FrameworkElement_MaxHeight;
    public static KnownProperties FrameworkElement_MaxWidth;
    public static KnownProperties FrameworkElement_MinHeight;
    public static KnownProperties FrameworkElement_MinWidth;
    public static KnownProperties FrameworkElement_Name;
    public static KnownProperties FrameworkElement_Style;
    public static KnownProperties FrameworkElement_VerticalAlignment;
    public static KnownProperties FrameworkElement_Width;
    public static KnownProperties GeneralTransformGroup_Children;
    public static KnownProperties GeometryGroup_Children;
    public static KnownProperties GradientBrush_GradientStops;
    public static KnownProperties Grid_Column;
    public static KnownProperties Grid_ColumnSpan;
    public static KnownProperties Grid_Row;
    public static KnownProperties Grid_RowSpan;
    public static KnownProperties GridViewColumn_Header;
    public static KnownProperties HeaderedContentControl_HasHeader;
    public static KnownProperties HeaderedContentControl_Header;
    public static KnownProperties HeaderedContentControl_HeaderTemplate;
    public static KnownProperties HeaderedContentControl_HeaderTemplateSelector;
    public static KnownProperties HeaderedItemsControl_HasHeader;
    public static KnownProperties HeaderedItemsControl_Header;
    public static KnownProperties HeaderedItemsControl_HeaderTemplate;
    public static KnownProperties HeaderedItemsControl_HeaderTemplateSelector;
    public static KnownProperties Hyperlink_NavigateUri;
    public static KnownProperties Image_Source;
    public static KnownProperties Image_Stretch;
    public static KnownProperties ItemsControl_ItemContainerStyle;
    public static KnownProperties ItemsControl_ItemContainerStyleSelector;
    public static KnownProperties ItemsControl_ItemTemplate;
    public static KnownProperties ItemsControl_ItemTemplateSelector;
    public static KnownProperties ItemsControl_ItemsPanel;
    public static KnownProperties ItemsControl_ItemsSource;
    public static KnownProperties MaterialGroup_Children;
    public static KnownProperties Model3DGroup_Children;
    public static KnownProperties Page_Content;
    public static KnownProperties Panel_Background;
    public static KnownProperties Path_Data;
    public static KnownProperties PathFigure_Segments;
    public static KnownProperties PathGeometry_Figures;
    public static KnownProperties Popup_Child;
    public static KnownProperties Popup_IsOpen;
    public static KnownProperties Popup_Placement;
    public static KnownProperties Popup_PopupAnimation;
    public static KnownProperties RowDefinition_Height;
    public static KnownProperties RowDefinition_MaxHeight;
    public static KnownProperties RowDefinition_MinHeight;
    public static KnownProperties ScrollViewer_CanContentScroll;
    public static KnownProperties ScrollViewer_HorizontalScrollBarVisibility;
    public static KnownProperties ScrollViewer_VerticalScrollBarVisibility;
    public static KnownProperties Shape_Fill;
    public static KnownProperties Shape_Stroke;
    public static KnownProperties Shape_StrokeThickness;
    public static KnownProperties TextBlock_Background;
    public static KnownProperties TextBlock_FontFamily;
    public static KnownProperties TextBlock_FontSize;
    public static KnownProperties TextBlock_FontStretch;
    public static KnownProperties TextBlock_FontStyle;
    public static KnownProperties TextBlock_FontWeight;
    public static KnownProperties TextBlock_Foreground;
    public static KnownProperties TextBlock_Text;
    public static KnownProperties TextBlock_TextDecorations;
    public static KnownProperties TextBlock_TextTrimming;
    public static KnownProperties TextBlock_TextWrapping;
    public static KnownProperties TextBox_Text;
    public static KnownProperties TextElement_Background;
    public static KnownProperties TextElement_FontFamily;
    public static KnownProperties TextElement_FontSize;
    public static KnownProperties TextElement_FontStretch;
    public static KnownProperties TextElement_FontStyle;
    public static KnownProperties TextElement_FontWeight;
    public static KnownProperties TextElement_Foreground;
    public static KnownProperties TimelineGroup_Children;
    public static KnownProperties Track_IsDirectionReversed;
    public static KnownProperties Track_Maximum;
    public static KnownProperties Track_Minimum;
    public static KnownProperties Track_Orientation;
    public static KnownProperties Track_Value;
    public static KnownProperties Track_ViewportSize;
    public static KnownProperties Transform3DGroup_Children;
    public static KnownProperties TransformGroup_Children;
    public static KnownProperties UIElement_ClipToBounds;
    public static KnownProperties UIElement_Focusable;
    public static KnownProperties UIElement_IsEnabled;
    public static KnownProperties UIElement_RenderTransform;
    public static KnownProperties UIElement_Visibility;
    public static KnownProperties Viewport3D_Children;
    public static KnownProperties MaxDependencyProperty;
    public static KnownProperties AdornedElementPlaceholder_Child;
    public static KnownProperties AdornerDecorator_Child;
    public static KnownProperties AnchoredBlock_Blocks;
    public static KnownProperties ArrayExtension_Items;
    public static KnownProperties BlockUIContainer_Child;
    public static KnownProperties Bold_Inlines;
    public static KnownProperties BooleanAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Border_Child;
    public static KnownProperties BulletDecorator_Child;
    public static KnownProperties Button_Content;
    public static KnownProperties ButtonBase_Content;
    public static KnownProperties ByteAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Canvas_Children;
    public static KnownProperties CharAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties CheckBox_Content;
    public static KnownProperties ColorAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties ComboBox_Items;
    public static KnownProperties ComboBoxItem_Content;
    public static KnownProperties ContextMenu_Items;
    public static KnownProperties ControlTemplate_VisualTree;
    public static KnownProperties DataTemplate_VisualTree;
    public static KnownProperties DataTrigger_Setters;
    public static KnownProperties DecimalAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Decorator_Child;
    public static KnownProperties DockPanel_Children;
    public static KnownProperties DocumentViewer_Document;
    public static KnownProperties DoubleAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties EventTrigger_Actions;
    public static KnownProperties Expander_Content;
    public static KnownProperties Figure_Blocks;
    public static KnownProperties FixedDocument_Pages;
    public static KnownProperties FixedDocumentSequence_References;
    public static KnownProperties FixedPage_Children;
    public static KnownProperties Floater_Blocks;
    public static KnownProperties FlowDocument_Blocks;
    public static KnownProperties FlowDocumentPageViewer_Document;
    public static KnownProperties FrameworkTemplate_VisualTree;
    public static KnownProperties Grid_Children;
    public static KnownProperties GridView_Columns;
    public static KnownProperties GridViewColumnHeader_Content;
    public static KnownProperties GroupBox_Content;
    public static KnownProperties GroupItem_Content;
    public static KnownProperties HeaderedContentControl_Content;
    public static KnownProperties HeaderedItemsControl_Items;
    public static KnownProperties HierarchicalDataTemplate_VisualTree;
    public static KnownProperties Hyperlink_Inlines;
    public static KnownProperties InkCanvas_Children;
    public static KnownProperties InkPresenter_Child;
    public static KnownProperties InlineUIContainer_Child;
    public static KnownProperties InputScopeName_NameValue;
    public static KnownProperties Int16AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Int32AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Int64AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Italic_Inlines;
    public static KnownProperties ItemsControl_Items;
    public static KnownProperties ItemsPanelTemplate_VisualTree;
    public static KnownProperties Label_Content;
    public static KnownProperties LinearGradientBrush_GradientStops;
    public static KnownProperties List_ListItems;
    public static KnownProperties ListBox_Items;
    public static KnownProperties ListBoxItem_Content;
    public static KnownProperties ListItem_Blocks;
    public static KnownProperties ListView_Items;
    public static KnownProperties ListViewItem_Content;
    public static KnownProperties MatrixAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Menu_Items;
    public static KnownProperties MenuBase_Items;
    public static KnownProperties MenuItem_Items;
    public static KnownProperties ModelVisual3D_Children;
    public static KnownProperties MultiBinding_Bindings;
    public static KnownProperties MultiDataTrigger_Setters;
    public static KnownProperties MultiTrigger_Setters;
    public static KnownProperties ObjectAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PageContent_Child;
    public static KnownProperties PageFunctionBase_Content;
    public static KnownProperties Panel_Children;
    public static KnownProperties Paragraph_Inlines;
    public static KnownProperties ParallelTimeline_Children;
    public static KnownProperties Point3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PointAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PriorityBinding_Bindings;
    public static KnownProperties QuaternionAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties RadialGradientBrush_GradientStops;
    public static KnownProperties RadioButton_Content;
    public static KnownProperties RectAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties RepeatButton_Content;
    public static KnownProperties RichTextBox_Document;
    public static KnownProperties Rotation3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Run_Text;
    public static KnownProperties ScrollViewer_Content;
    public static KnownProperties Section_Blocks;
    public static KnownProperties Selector_Items;
    public static KnownProperties SingleAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties SizeAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Span_Inlines;
    public static KnownProperties StackPanel_Children;
    public static KnownProperties StatusBar_Items;
    public static KnownProperties StatusBarItem_Content;
    public static KnownProperties Storyboard_Children;
    public static KnownProperties StringAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Style_Setters;
    public static KnownProperties TabControl_Items;
    public static KnownProperties TabItem_Content;
    public static KnownProperties TabPanel_Children;
    public static KnownProperties Table_RowGroups;
    public static KnownProperties TableCell_Blocks;
    public static KnownProperties TableRow_Cells;
    public static KnownProperties TableRowGroup_Rows;
    public static KnownProperties TextBlock_Inlines;
    public static KnownProperties ThicknessAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties ToggleButton_Content;
    public static KnownProperties ToolBar_Items;
    public static KnownProperties ToolBarOverflowPanel_Children;
    public static KnownProperties ToolBarPanel_Children;
    public static KnownProperties ToolBarTray_ToolBars;
    public static KnownProperties ToolTip_Content;
    public static KnownProperties TreeView_Items;
    public static KnownProperties TreeViewItem_Items;
    public static KnownProperties Trigger_Setters;
    public static KnownProperties Underline_Inlines;
    public static KnownProperties UniformGrid_Children;
    public static KnownProperties UserControl_Content;
    public static KnownProperties Vector3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties VectorAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Viewbox_Child;
    public static KnownProperties Viewport3DVisual_Children;
    public static KnownProperties VirtualizingPanel_Children;
    public static KnownProperties VirtualizingStackPanel_Children;
    public static KnownProperties Window_Content;
    public static KnownProperties WrapPanel_Children;
    public static KnownProperties XmlDataProvider_XmlSerializer;
    public static KnownProperties MaxProperty;
}
internal static class System.Windows.Markup.KnownTypes : object {
    internal static TypeIndexer Types { get; }
    private static KnownTypes();
    internal static object CreateKnownElement(KnownElements knownElement);
    internal static DependencyProperty GetKnownDependencyPropertyFromId(KnownProperties knownProperty);
    internal static KnownElements GetKnownElementFromKnownCommonProperty(KnownProperties knownProperty);
    internal static string GetKnownClrPropertyNameFromId(KnownProperties knownProperty);
    internal static IList GetCollectionForCPA(object o, KnownElements knownElement);
    internal static bool CanCollectionTypeAcceptStrings(KnownElements knownElement);
    internal static string GetContentPropertyName(KnownElements knownElement);
    internal static short GetKnownPropertyAttributeId(KnownElements typeID, string fieldName);
    internal static KnownElements GetKnownTypeConverterId(KnownElements knownElement);
    internal static KnownElements GetKnownTypeConverterIdForProperty(KnownElements id, string propName);
    internal static TypeIndexer get_Types();
}
public abstract class System.Windows.Markup.Localizer.BamlLocalizabilityResolver : object {
    public abstract virtual ElementLocalizability GetElementLocalizability(string assembly, string className);
    public abstract virtual LocalizabilityAttribute GetPropertyLocalizability(string assembly, string className, string property);
    public abstract virtual string ResolveFormattingTagToClass(string formattingTag);
    public abstract virtual string ResolveAssemblyFromClass(string className);
}
public class System.Windows.Markup.Localizer.BamlLocalizableResource : object {
    public string Content { get; public set; }
    public string Comments { get; public set; }
    public bool Modifiable { get; public set; }
    public bool Readable { get; public set; }
    public LocalizationCategory Category { get; public set; }
    public BamlLocalizableResource(string content, string comments, LocalizationCategory category, bool modifiable, bool readable);
    internal BamlLocalizableResource(BamlLocalizableResource other);
    public string get_Content();
    public void set_Content(string value);
    public string get_Comments();
    public void set_Comments(string value);
    public bool get_Modifiable();
    public void set_Modifiable(bool value);
    public bool get_Readable();
    public void set_Readable(bool value);
    public LocalizationCategory get_Category();
    public void set_Category(LocalizationCategory value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class System.Windows.Markup.Localizer.BamlLocalizableResourceKey : object {
    public string Uid { get; }
    public string ClassName { get; }
    public string PropertyName { get; }
    public string AssemblyName { get; }
    internal BamlLocalizableResourceKey(string uid, string className, string propertyName, string assemblyName);
    public BamlLocalizableResourceKey(string uid, string className, string propertyName);
    public string get_Uid();
    public string get_ClassName();
    public string get_PropertyName();
    public string get_AssemblyName();
    public bool Equals(BamlLocalizableResourceKey other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Markup.Localizer.BamlLocalizationDictionary : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public BamlLocalizableResourceKey RootElementKey { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public BamlLocalizableResource Item { get; public set; }
    public int Count { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public BamlLocalizableResourceKey get_RootElementKey();
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public BamlLocalizableResource get_Item(BamlLocalizableResourceKey key);
    public void set_Item(BamlLocalizableResourceKey key, BamlLocalizableResource value);
    public void Add(BamlLocalizableResourceKey key, BamlLocalizableResource value);
    public sealed virtual void Clear();
    public void Remove(BamlLocalizableResourceKey key);
    public bool Contains(BamlLocalizableResourceKey key);
    public BamlLocalizationDictionaryEnumerator GetEnumerator();
    public int get_Count();
    public void CopyTo(DictionaryEntry[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal BamlLocalizationDictionary Copy();
    internal void SetRootElementKey(BamlLocalizableResourceKey key);
}
public class System.Windows.Markup.Localizer.BamlLocalizationDictionaryEnumerator : object {
    public DictionaryEntry Entry { get; }
    public BamlLocalizableResourceKey Key { get; }
    public BamlLocalizableResource Value { get; }
    public DictionaryEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private object System.Collections.IDictionaryEnumerator.Key { get; }
    private object System.Collections.IDictionaryEnumerator.Value { get; }
    internal BamlLocalizationDictionaryEnumerator(IEnumerator enumerator);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual DictionaryEntry get_Entry();
    public BamlLocalizableResourceKey get_Key();
    public BamlLocalizableResource get_Value();
    public DictionaryEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override object System.Collections.IDictionaryEnumerator.get_Key();
    private sealed virtual override object System.Collections.IDictionaryEnumerator.get_Value();
}
public class System.Windows.Markup.Localizer.BamlLocalizer : object {
    public BamlLocalizer(Stream source);
    public BamlLocalizer(Stream source, BamlLocalizabilityResolver resolver);
    public BamlLocalizer(Stream source, BamlLocalizabilityResolver resolver, TextReader comments);
    public BamlLocalizationDictionary ExtractResources();
    public void UpdateBaml(Stream target, BamlLocalizationDictionary updates);
    [CompilerGeneratedAttribute]
public void add_ErrorNotify(BamlLocalizerErrorNotifyEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ErrorNotify(BamlLocalizerErrorNotifyEventHandler value);
    protected virtual void OnErrorNotify(BamlLocalizerErrorNotifyEventArgs e);
    internal void RaiseErrorNotifyEvent(BamlLocalizerErrorNotifyEventArgs e);
}
public enum System.Windows.Markup.Localizer.BamlLocalizerError : Enum {
    public int value__;
    public static BamlLocalizerError DuplicateUid;
    public static BamlLocalizerError DuplicateElement;
    public static BamlLocalizerError IncompleteElementPlaceholder;
    public static BamlLocalizerError InvalidCommentingXml;
    public static BamlLocalizerError InvalidLocalizationAttributes;
    public static BamlLocalizerError InvalidLocalizationComments;
    public static BamlLocalizerError InvalidUid;
    public static BamlLocalizerError MismatchedElements;
    public static BamlLocalizerError SubstitutionAsPlaintext;
    public static BamlLocalizerError UidMissingOnChildElement;
    public static BamlLocalizerError UnknownFormattingTag;
}
public class System.Windows.Markup.Localizer.BamlLocalizerErrorNotifyEventArgs : EventArgs {
    public BamlLocalizableResourceKey Key { get; }
    public BamlLocalizerError Error { get; }
    internal BamlLocalizerErrorNotifyEventArgs(BamlLocalizableResourceKey key, BamlLocalizerError error);
    public BamlLocalizableResourceKey get_Key();
    public BamlLocalizerError get_Error();
}
public class System.Windows.Markup.Localizer.BamlLocalizerErrorNotifyEventHandler : MulticastDelegate {
    public BamlLocalizerErrorNotifyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BamlLocalizerErrorNotifyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BamlLocalizerErrorNotifyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Markup.Localizer.ElementLocalizability : object {
    public string FormattingTag { get; public set; }
    public LocalizabilityAttribute Attribute { get; public set; }
    public ElementLocalizability(string formattingTag, LocalizabilityAttribute attribute);
    public string get_FormattingTag();
    public void set_FormattingTag(string value);
    public LocalizabilityAttribute get_Attribute();
    public void set_Attribute(LocalizabilityAttribute value);
}
internal class System.Windows.Markup.MarkupExtensionParser : object {
    internal MarkupExtensionParser(IParserHelper parserHelper, ParserContext parserContext);
    internal AttributeData IsMarkupExtensionAttribute(Type declaringType, string propIdName, String& attrValue, int lineNumber, int linePosition, int depth, object info);
    internal DefAttributeData IsMarkupExtensionDefAttribute(Type declaringType, String& attrValue, int lineNumber, int linePosition, int depth);
    internal static bool LooksLikeAMarkupExtension(string attrValue);
    internal static string AddEscapeToLiteralString(string literalString);
    internal static bool GetMarkupExtensionTypeAndArgs(String& attrValue, String& typeName, String& args);
    internal ArrayList CompileAttributes(ArrayList markupExtensionList, int startingDepth);
    internal void CompileAttribute(ArrayList xamlNodes, AttributeData data);
    internal void CompileAttributeCore(ArrayList xamlNodes, AttributeData data);
    internal ArrayList CompileDictionaryKeys(ArrayList complexDefAttributesList, int startingDepth);
    internal void CompileDictionaryKey(ArrayList xamlNodes, DefAttributeData data);
    internal static void RemoveEscapes(String& value);
}
[DebuggerDisplayAttribute("'{_xmlNamespace}'={_clrNamespace}:{_assemblyName}")]
public class System.Windows.Markup.NamespaceMapEntry : object {
    public string XmlNamespace { get; public set; }
    public string AssemblyName { get; public set; }
    public string ClrNamespace { get; public set; }
    internal Assembly Assembly { get; }
    internal string AssemblyPath { get; internal set; }
    public NamespaceMapEntry(string xmlNamespace, string assemblyName, string clrNamespace);
    internal NamespaceMapEntry(string xmlNamespace, string assemblyName, string clrNamespace, string assemblyPath);
    public string get_XmlNamespace();
    public void set_XmlNamespace(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    internal Assembly get_Assembly();
    internal string get_AssemblyPath();
    internal void set_AssemblyPath(string value);
}
internal enum System.Windows.Markup.ParserAction : Enum {
    public int value__;
    public static ParserAction Normal;
    public static ParserAction Skip;
}
public class System.Windows.Markup.ParserContext : object {
    public XmlnsDictionary XmlnsDictionary { get; }
    public string XmlLang { get; public set; }
    public string XmlSpace { get; public set; }
    internal Type TargetType { get; internal set; }
    public XamlTypeMapper XamlTypeMapper { get; public set; }
    internal Stack NameScopeStack { get; }
    public Uri BaseUri { get; public set; }
    internal bool SkipJournaledProperties { get; internal set; }
    internal Assembly StreamCreatedAssembly { get; internal set; }
    internal int LineNumber { get; internal set; }
    internal int LinePosition { get; internal set; }
    internal bool IsDebugBamlStream { get; internal set; }
    internal object RootElement { get; internal set; }
    internal bool OwnsBamlStream { get; internal set; }
    internal BamlMapTable MapTable { get; internal set; }
    internal IStyleConnector StyleConnector { get; internal set; }
    internal ProvideValueServiceProvider ProvideValueProvider { get; }
    internal List`1<Object[]> StaticResourcesStack { get; }
    internal bool InDeferredSection { get; }
    internal Dictionary`2<Type, Dictionary`2<string, SpecialBracketCharacters>> MasterBracketCharacterCache { get; }
    internal bool FreezeFreezables { get; internal set; }
    public ParserContext(XmlParserContext xmlParserContext);
    internal ParserContext(XmlReader xmlReader);
    internal ParserContext(ParserContext parserContext);
    internal void Initialize();
    internal Dictionary`2<string, SpecialBracketCharacters> InitBracketCharacterCacheForType(Type type);
    internal void PushScope();
    internal void PopScope();
    public XmlnsDictionary get_XmlnsDictionary();
    public string get_XmlLang();
    public void set_XmlLang(string value);
    public string get_XmlSpace();
    public void set_XmlSpace(string value);
    internal Type get_TargetType();
    internal void set_TargetType(Type value);
    public XamlTypeMapper get_XamlTypeMapper();
    public void set_XamlTypeMapper(XamlTypeMapper value);
    internal Stack get_NameScopeStack();
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    internal bool get_SkipJournaledProperties();
    internal void set_SkipJournaledProperties(bool value);
    internal Assembly get_StreamCreatedAssembly();
    [SecurityCriticalAttribute]
internal void set_StreamCreatedAssembly(Assembly value);
    public static XmlParserContext op_Implicit(ParserContext parserContext);
    public static XmlParserContext ToXmlParserContext(ParserContext parserContext);
    internal int get_LineNumber();
    internal void set_LineNumber(int value);
    internal int get_LinePosition();
    internal void set_LinePosition(int value);
    internal bool get_IsDebugBamlStream();
    internal void set_IsDebugBamlStream(bool value);
    internal object get_RootElement();
    internal void set_RootElement(object value);
    internal bool get_OwnsBamlStream();
    internal void set_OwnsBamlStream(bool value);
    internal BamlMapTable get_MapTable();
    internal void set_MapTable(BamlMapTable value);
    internal IStyleConnector get_StyleConnector();
    internal void set_StyleConnector(IStyleConnector value);
    internal ProvideValueServiceProvider get_ProvideValueProvider();
    internal List`1<Object[]> get_StaticResourcesStack();
    internal bool get_InDeferredSection();
    internal ParserContext ScopedCopy();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal ParserContext ScopedCopy(bool copyNameScopeStack);
    internal void TrimState();
    internal Dictionary`2<Type, Dictionary`2<string, SpecialBracketCharacters>> get_MasterBracketCharacterCache();
    internal ParserContext Clone();
    internal bool get_FreezeFreezables();
    internal void set_FreezeFreezables(bool value);
    internal bool TryCacheFreezable(string value, Freezable freezable);
    internal Freezable TryGetFreezable(string value);
}
internal abstract class System.Windows.Markup.ParserHooks : object {
    internal virtual ParserAction LoadNode(XamlNode tokenNode);
}
internal class System.Windows.Markup.ParserStack : ArrayList {
    internal object CurrentContext { get; }
    internal object ParentContext { get; }
    internal object GrandParentContext { get; }
    internal object GreatGrandParentContext { get; }
    private ParserStack(ICollection collection);
    public void Push(object o);
    public object Pop();
    public object Peek();
    public virtual object Clone();
    internal object get_CurrentContext();
    internal object get_ParentContext();
    internal object get_GrandParentContext();
    internal object get_GreatGrandParentContext();
}
internal class System.Windows.Markup.Primitives.ElementConstructorArgument : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsConstructorArgument { get; }
    internal ElementConstructorArgument(object value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsConstructorArgument();
}
internal class System.Windows.Markup.Primitives.ElementDictionaryItemsPseudoProperty : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    internal ElementDictionaryItemsPseudoProperty(IDictionary value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementDictionaryItemsPseudoProperty/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
}
internal class System.Windows.Markup.Primitives.ElementItemsPseudoProperty : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    internal ElementItemsPseudoProperty(IEnumerable value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementItemsPseudoProperty/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
}
internal class System.Windows.Markup.Primitives.ElementKey : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsKey { get; }
    internal ElementKey(object value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsKey();
}
internal class System.Windows.Markup.Primitives.ElementMarkupObject : MarkupObject {
    public Type ObjectType { get; }
    public object Instance { get; }
    public AttributeCollection Attributes { get; }
    internal IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    internal ElementMarkupObject(object instance, XamlDesignerSerializationManager manager);
    private static ElementMarkupObject();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementMarkupObject/<GetProperties>d__5")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public virtual AttributeCollection get_Attributes();
    public virtual void AssignRootContext(IValueSerializerContext context);
    internal IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
    internal void SetKey(ElementKey key);
}
internal abstract class System.Windows.Markup.Primitives.ElementObjectPropertyBase : ElementPropertyBase {
    protected ElementMarkupObject _object;
    protected ElementObjectPropertyBase(ElementMarkupObject obj);
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
}
internal class System.Windows.Markup.Primitives.ElementProperty : ElementObjectPropertyBase {
    public string Name { get; }
    public Type PropertyType { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public bool IsAttached { get; }
    public DependencyProperty DependencyProperty { get; }
    public object Value { get; }
    public AttributeCollection Attributes { get; }
    internal ElementProperty(ElementMarkupObject obj, PropertyDescriptor descriptor);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual bool get_IsAttached();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual object get_Value();
    public virtual AttributeCollection get_Attributes();
    internal static object CheckForMarkupExtension(Type propertyType, object value, IValueSerializerContext context, bool convertEnums);
}
internal abstract class System.Windows.Markup.Primitives.ElementPropertyBase : MarkupProperty {
    public bool IsComposite { get; }
    public string StringValue { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    protected IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public ElementPropertyBase(XamlDesignerSerializationManager manager);
    private static ElementPropertyBase();
    public virtual bool get_IsComposite();
    public virtual string get_StringValue();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementPropertyBase/<get_Items>d__6")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    protected IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
    public virtual IEnumerable`1<Type> get_TypeReferences();
    protected bool CanConvertToString(object value);
    protected abstract virtual IValueSerializerContext GetItemContext();
    protected abstract virtual Type GetObjectType();
}
internal abstract class System.Windows.Markup.Primitives.ElementPseudoPropertyBase : ElementObjectPropertyBase {
    public Type PropertyType { get; }
    public object Value { get; }
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    internal ElementPseudoPropertyBase(object value, Type type, ElementMarkupObject obj);
    public virtual Type get_PropertyType();
    public virtual object get_Value();
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<Type> get_TypeReferences();
}
internal class System.Windows.Markup.Primitives.ElementStringValueProperty : MarkupProperty {
    public string Name { get; }
    public Type PropertyType { get; }
    public bool IsValueAsString { get; }
    public object Value { get; }
    public string StringValue { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    internal ElementStringValueProperty(ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual bool get_IsValueAsString();
    public virtual object get_Value();
    public virtual string get_StringValue();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<Type> get_TypeReferences();
}
internal class System.Windows.Markup.Primitives.ExtensionSimplifierMarkupObject : MarkupObjectWrapper {
    public ExtensionSimplifierMarkupObject(MarkupObject baseObject, IValueSerializerContext context);
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ExtensionSimplifierMarkupObject/<GetProperties>d__3")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public virtual void AssignRootContext(IValueSerializerContext context);
}
internal class System.Windows.Markup.Primitives.ExtensionSimplifierProperty : MarkupPropertyWrapper {
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string StringValue { get; }
    public ExtensionSimplifierProperty(MarkupProperty baseProperty, IValueSerializerContext context);
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ExtensionSimplifierProperty/<get_Items>d__6")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual string get_StringValue();
    internal virtual void VerifyOnlySerializableTypes();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryContent : ElementPropertyBase {
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public Type PropertyType { get; }
    public object Value { get; }
    internal FrameworkElementFactoryContent(FrameworkElementFactory factory, FrameworkElementFactoryMarkupObject item);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.FrameworkElementFactoryContent/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_PropertyType();
    public virtual object get_Value();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryMarkupObject : MarkupObject {
    public AttributeCollection Attributes { get; }
    public Type ObjectType { get; }
    public object Instance { get; }
    internal IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    internal FrameworkElementFactoryMarkupObject(FrameworkElementFactory factory, XamlDesignerSerializationManager manager);
    public virtual void AssignRootContext(IValueSerializerContext context);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.FrameworkElementFactoryMarkupObject/<GetProperties>d__8")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    internal IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryProperty : ElementPropertyBase {
    public PropertyDescriptor PropertyDescriptor { get; }
    public bool IsAttached { get; }
    public AttributeCollection Attributes { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public DependencyProperty DependencyProperty { get; }
    public object Value { get; }
    public FrameworkElementFactoryProperty(PropertyValue propertyValue, FrameworkElementFactoryMarkupObject item);
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual bool get_IsAttached();
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual object get_Value();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryStringContent : ElementPropertyBase {
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public bool IsValueAsString { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public Type PropertyType { get; }
    public object Value { get; }
    internal FrameworkElementFactoryStringContent(FrameworkElementFactory factory, FrameworkElementFactoryMarkupObject item);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    public virtual bool get_IsValueAsString();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_PropertyType();
    public virtual object get_Value();
}
internal class System.Windows.Markup.Primitives.MarkupObjectWrapper : MarkupObject {
    public AttributeCollection Attributes { get; }
    public Type ObjectType { get; }
    public object Instance { get; }
    public MarkupObjectWrapper(MarkupObject baseObject);
    public virtual void AssignRootContext(IValueSerializerContext context);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
}
internal class System.Windows.Markup.Primitives.MarkupPropertyWrapper : MarkupProperty {
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public object Value { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsComposite { get; }
    public bool IsConstructorArgument { get; }
    public bool IsKey { get; }
    public bool IsValueAsString { get; }
    public bool IsContent { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public MarkupPropertyWrapper(MarkupProperty baseProperty);
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual string get_StringValue();
    public virtual IEnumerable`1<Type> get_TypeReferences();
    public virtual object get_Value();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsComposite();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsKey();
    public virtual bool get_IsValueAsString();
    public virtual bool get_IsContent();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    internal virtual void VerifyOnlySerializableTypes();
}
public class System.Windows.Markup.Primitives.MarkupWriter : object {
    internal MarkupWriter(XmlWriter writer);
    public static MarkupObject GetMarkupObjectFor(object instance);
    public static MarkupObject GetMarkupObjectFor(object instance, XamlDesignerSerializationManager manager);
    internal static void SaveAsXml(XmlWriter writer, object instance);
    internal static void SaveAsXml(XmlWriter writer, object instance, XamlDesignerSerializationManager manager);
    internal static void SaveAsXml(XmlWriter writer, MarkupObject item);
    internal static void VerifyTypeIsSerializable(Type type);
    public sealed virtual void Dispose();
    internal void WriteItem(MarkupObject item);
}
internal class System.Windows.Markup.Primitives.ValueSerializerContextWrapper : object {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ValueSerializerContextWrapper(IValueSerializerContext baseContext);
    public sealed virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
    public sealed virtual ValueSerializer GetValueSerializerFor(Type type);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual object GetService(Type serviceType);
}
internal class System.Windows.Markup.ProvideValueServiceProvider : object {
    private object System.Windows.Markup.IProvideValueTarget.TargetObject { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetProperty { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    private bool System.Windows.Media.IFreezeFreezables.FreezeFreezables { get; }
    internal ProvideValueServiceProvider(ParserContext context);
    internal void SetData(object targetObject, object targetProperty);
    internal void ClearData();
    private sealed virtual override Type System.Windows.Markup.IXamlTypeResolver.Resolve(string qualifiedTypeName);
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetObject();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetProperty();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.get_FreezeFreezables();
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.TryFreeze(string value, Freezable freezable);
    private sealed virtual override Freezable System.Windows.Media.IFreezeFreezables.TryGetFreezable(string value);
    public sealed virtual object GetService(Type service);
}
internal class System.Windows.Markup.ReaderContextStackData : object {
    internal ReaderFlags ContextType { get; }
    internal object ObjectData { get; internal set; }
    internal object Key { get; internal set; }
    internal string Uid { get; internal set; }
    internal string ElementNameOrPropertyName { get; internal set; }
    internal object ContentProperty { get; internal set; }
    internal Type ExpectedType { get; internal set; }
    internal short ExpectedTypeId { get; internal set; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal ReaderFlags ContextFlags { get; internal set; }
    internal bool NeedToAddToTree { get; }
    internal bool IsObjectElement { get; }
    internal ReaderFlags get_ContextType();
    internal object get_ObjectData();
    internal void set_ObjectData(object value);
    internal object get_Key();
    internal void set_Key(object value);
    internal string get_Uid();
    internal void set_Uid(string value);
    internal string get_ElementNameOrPropertyName();
    internal void set_ElementNameOrPropertyName(string value);
    internal object get_ContentProperty();
    internal void set_ContentProperty(object value);
    internal Type get_ExpectedType();
    internal void set_ExpectedType(Type value);
    internal short get_ExpectedTypeId();
    internal void set_ExpectedTypeId(short value);
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal ReaderFlags get_ContextFlags();
    internal void set_ContextFlags(ReaderFlags value);
    internal bool get_NeedToAddToTree();
    internal void MarkAddedToTree();
    internal bool CheckFlag(ReaderFlags flag);
    internal void SetFlag(ReaderFlags flag);
    internal void ClearFlag(ReaderFlags flag);
    internal bool get_IsObjectElement();
    internal void ClearData();
}
internal enum System.Windows.Markup.ReaderFlags : Enum {
    public ushort value__;
    public static ReaderFlags Unknown;
    public static ReaderFlags DependencyObject;
    public static ReaderFlags ClrObject;
    public static ReaderFlags PropertyComplexClr;
    public static ReaderFlags PropertyComplexDP;
    public static ReaderFlags PropertyArray;
    public static ReaderFlags PropertyIList;
    public static ReaderFlags PropertyIDictionary;
    public static ReaderFlags PropertyIAddChild;
    public static ReaderFlags RealizeDeferContent;
    public static ReaderFlags ConstructorParams;
    public static ReaderFlags ContextTypeMask;
    public static ReaderFlags StyleObject;
    public static ReaderFlags FrameworkTemplateObject;
    public static ReaderFlags TableTemplateObject;
    public static ReaderFlags SingletonConstructorParam;
    public static ReaderFlags NeedToAddToTree;
    public static ReaderFlags AddedToTree;
    public static ReaderFlags InjectedElement;
    public static ReaderFlags CollectionHolder;
    public static ReaderFlags IDictionary;
    public static ReaderFlags IList;
    public static ReaderFlags ArrayExt;
    public static ReaderFlags IAddChild;
}
internal class System.Windows.Markup.ReaderStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ReaderStream(ReadWriteStreamManager streamManager);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void ReaderDoneWithFileUpToPosition(long position);
}
internal class System.Windows.Markup.ReadWriteStreamManager : object {
    internal WriterStream WriterStream { get; }
    internal ReaderStream ReaderStream { get; }
    internal long ReadPosition { get; internal set; }
    internal long ReadLength { get; internal set; }
    internal long WritePosition { get; internal set; }
    internal long WriteLength { get; internal set; }
    internal void Write(Byte[] buffer, int offset, int count);
    internal long WriterSeek(long offset, SeekOrigin loc);
    internal void UpdateReaderLength(long position);
    internal void WriterClose();
    internal int Read(Byte[] buffer, int offset, int count);
    internal int ReadByte();
    internal long ReaderSeek(long offset, SeekOrigin loc);
    internal void ReaderDoneWithFileUpToPosition(long position);
    internal WriterStream get_WriterStream();
    internal ReaderStream get_ReaderStream();
    internal long get_ReadPosition();
    internal void set_ReadPosition(long value);
    internal long get_ReadLength();
    internal void set_ReadLength(long value);
    internal long get_WritePosition();
    internal void set_WritePosition(long value);
    internal long get_WriteLength();
    internal void set_WriteLength(long value);
}
public class System.Windows.Markup.ResourceReferenceExpressionConverter : ExpressionConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Markup.RoutedEventConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.Markup.RoutedEventValueSerializer : ValueSerializer {
    private static RoutedEventValueSerializer();
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
public class System.Windows.Markup.SetterTriggerConditionValueConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static object ResolveValue(ITypeDescriptorContext serviceProvider, DependencyProperty property, CultureInfo culture, object source);
}
internal class System.Windows.Markup.StaticResourceHolder : StaticResourceExtension {
    internal DeferredResourceReference PrefetchedValue { get; }
    internal StaticResourceHolder(object resourceKey, DeferredResourceReference prefetchedValue);
    internal virtual DeferredResourceReference get_PrefetchedValue();
}
internal enum System.Windows.Markup.StyleMode : Enum {
    public byte value__;
    public static StyleMode Base;
    public static StyleMode TargetTypeProperty;
    public static StyleMode BasedOnProperty;
    public static StyleMode DataTypeProperty;
    public static StyleMode ComplexProperty;
    public static StyleMode Resources;
    public static StyleMode Setters;
    public static StyleMode Key;
    public static StyleMode TriggerBase;
    public static StyleMode TriggerActions;
    public static StyleMode TriggerSetters;
    public static StyleMode TriggerEnterExitActions;
    public static StyleMode VisualTree;
}
internal class System.Windows.Markup.StyleModeStack : object {
    internal int Depth { get; }
    internal StyleMode Mode { get; }
    internal int get_Depth();
    internal StyleMode get_Mode();
    internal void Push(StyleMode mode);
    internal void Push();
    internal StyleMode Pop();
}
internal class System.Windows.Markup.SystemKeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static Type GetSystemClassType(SystemResourceKeyID id);
    internal static string GetSystemClassName(SystemResourceKeyID id);
    internal static string GetSystemKeyName(SystemResourceKeyID id);
    internal static string GetSystemPropertyName(SystemResourceKeyID id);
}
internal class System.Windows.Markup.TemplateComponentConnector : object {
    internal TemplateComponentConnector(IComponentConnector componentConnector, IStyleConnector styleConnector);
    public sealed virtual void InitializeComponent();
    public sealed virtual void Connect(int connectionId, object target);
}
public class System.Windows.Markup.TemplateKeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.TypeAndSerializer : object {
    public Type ObjectType;
    public Type SerializerType;
    public bool IsSerializerTypeSet;
    public PropertyInfo XmlLangProperty;
}
internal class System.Windows.Markup.TypeConvertContext : object {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ParserContext ParserContext { get; }
    public TypeConvertContext(ParserContext parserContext);
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public virtual object GetService(Type serviceType);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public ParserContext get_ParserContext();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.TypeIndexer : object {
    public Type Item { get; }
    public TypeIndexer(int size);
    public Type get_Item(int index);
}
internal class System.Windows.Markup.TypeInfoKey : ValueType {
    internal string DeclaringAssembly;
    internal string TypeFullName;
    public virtual bool Equals(object o);
    public static bool op_Equality(TypeInfoKey key1, TypeInfoKey key2);
    public static bool op_Inequality(TypeInfoKey key1, TypeInfoKey key2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.Windows.Markup.WpfPropertyDefinition : ValueType {
    private BamlRecordReader _reader;
    private short _attributeId;
    private BamlAttributeInfoRecord _attributeInfo;
    private DependencyProperty _dependencyProperty;
    public DependencyProperty DependencyProperty { get; }
    public BamlAttributeUsage AttributeUsage { get; }
    public BamlAttributeInfoRecord AttributeInfo { get; }
    public PropertyInfo PropertyInfo { get; }
    public MethodInfo AttachedPropertyGetter { get; }
    public MethodInfo AttachedPropertySetter { get; }
    public bool IsInternal { get; }
    public Type PropertyType { get; }
    public string Name { get; }
    internal object DpOrPiOrMi { get; }
    public WpfPropertyDefinition(BamlRecordReader reader, short attributeId, bool targetIsDependencyObject);
    public DependencyProperty get_DependencyProperty();
    public BamlAttributeUsage get_AttributeUsage();
    public BamlAttributeInfoRecord get_AttributeInfo();
    public PropertyInfo get_PropertyInfo();
    public MethodInfo get_AttachedPropertyGetter();
    public MethodInfo get_AttachedPropertySetter();
    public bool get_IsInternal();
    public Type get_PropertyType();
    public string get_Name();
    internal object get_DpOrPiOrMi();
}
internal class System.Windows.Markup.WpfXamlFrame : XamlFrame {
    public bool FreezeFreezable { get; public set; }
    public XamlMember Property { get; public set; }
    public XamlType Type { get; public set; }
    public object Instance { get; public set; }
    public XmlnsDictionary XmlnsDictionary { get; public set; }
    public Nullable`1<bool> XmlSpace { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FreezeFreezable();
    [CompilerGeneratedAttribute]
public void set_FreezeFreezable(bool value);
    [CompilerGeneratedAttribute]
public XamlMember get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(XamlMember value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public XmlnsDictionary get_XmlnsDictionary();
    [CompilerGeneratedAttribute]
public void set_XmlnsDictionary(XmlnsDictionary value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_XmlSpace();
    [CompilerGeneratedAttribute]
public void set_XmlSpace(Nullable`1<bool> value);
    public virtual void Reset();
}
internal class System.Windows.Markup.WpfXamlLoader : object {
    private static WpfXamlLoader();
    public static object Load(XamlReader xamlReader, bool skipJournaledProperties, Uri baseUri);
    public static object LoadDeferredContent(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, bool skipJournaledProperties, object rootObject, XamlObjectWriterSettings parentSettings, Uri baseUri);
    public static object LoadBaml(XamlReader xamlReader, bool skipJournaledProperties, object rootObject, XamlAccessLevel accessLevel, Uri baseUri);
    internal static void EnsureXmlNamespaceMaps(object rootObject, XamlSchemaContext schemaContext);
    internal static void TransformNodes(XamlReader xamlReader, XamlObjectWriter xamlWriter, bool onlyLoadOneNode, bool skipJournaledProperties, bool shouldPassLineNumberInfo, IXamlLineInfo xamlLineInfo, IXamlLineInfoConsumer xamlLineInfoConsumer, XamlContextStack`1<WpfXamlFrame> stack, IStyleConnector styleConnector);
}
internal class System.Windows.Markup.WriterStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal WriterStream(ReadWriteStreamManager streamManager);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void UpdateReaderLength(long position);
}
[DebuggerDisplayAttribute("Attr:{_value}")]
internal class System.Windows.Markup.XamlAttributeNode : XamlNode {
    internal string Value { get; }
    internal XamlAttributeNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth, string value);
    internal string get_Value();
}
internal class System.Windows.Markup.XamlBrushSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlClrEventNode : XamlAttributeNode {
    internal XamlClrEventNode(int lineNumber, int linePosition, int depth, string eventName, MemberInfo eventMember, string value);
}
internal class System.Windows.Markup.XamlConstructorParametersEndNode : XamlNode {
    internal XamlConstructorParametersEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlConstructorParametersStartNode : XamlNode {
    internal XamlConstructorParametersStartNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlContentPropertyNode : XamlNode {
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string PropName { get; }
    internal Type PropDeclaringType { get; }
    internal Type PropValidType { get; }
    internal XamlContentPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_PropName();
    internal Type get_PropDeclaringType();
    internal Type get_PropValidType();
}
internal class System.Windows.Markup.XamlDefAttributeKeyTypeNode : XamlAttributeNode {
    internal string AssemblyName { get; }
    internal Type ValueType { get; }
    internal XamlDefAttributeKeyTypeNode(int lineNumber, int linePosition, int depth, string value, string assemblyName, Type valueType);
    internal string get_AssemblyName();
    internal Type get_ValueType();
}
internal class System.Windows.Markup.XamlDefAttributeNode : XamlAttributeNode {
    internal string Name { get; }
    internal BamlAttributeUsage AttributeUsage { get; }
    internal XamlDefAttributeNode(int lineNumber, int linePosition, int depth, string name, string value);
    internal XamlDefAttributeNode(int lineNumber, int linePosition, int depth, string name, string value, BamlAttributeUsage bamlAttributeUsage);
    internal string get_Name();
    internal BamlAttributeUsage get_AttributeUsage();
}
internal class System.Windows.Markup.XamlDefTagNode : XamlAttributeNode {
    internal XamlDefTagNode(int lineNumber, int linePosition, int depth, bool isEmptyElement, XmlReader xmlReader, string defTagName);
}
public class System.Windows.Markup.XamlDesignerSerializationManager : ServiceProviders {
    public XamlWriterMode XamlWriterMode { get; public set; }
    internal XmlWriter XmlWriter { get; }
    public XamlDesignerSerializationManager(XmlWriter xmlWriter);
    public XamlWriterMode get_XamlWriterMode();
    public void set_XamlWriterMode(XamlWriterMode value);
    internal XmlWriter get_XmlWriter();
    internal void ClearXmlWriter();
}
internal class System.Windows.Markup.XamlDocumentEndNode : XamlNode {
    internal XamlDocumentEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlDocumentStartNode : XamlNode {
    internal XamlDocumentStartNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlElementEndNode : XamlNode {
    internal XamlElementEndNode(int lineNumber, int linePosition, int depth);
    internal XamlElementEndNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth);
}
[DebuggerDisplayAttribute("Elem:{_typeFullName}")]
internal class System.Windows.Markup.XamlElementStartNode : XamlNode {
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal Type ElementType { get; }
    internal Type SerializerType { get; }
    internal string SerializerTypeFullName { get; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal bool IsInjected { get; internal set; }
    internal XamlElementStartNode(int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType);
    internal XamlElementStartNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType, bool isEmptyElement, bool needsDictionaryKey, bool isInjected);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal Type get_ElementType();
    internal Type get_SerializerType();
    internal string get_SerializerTypeFullName();
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal bool get_IsInjected();
    internal void set_IsInjected(bool value);
}
internal class System.Windows.Markup.XamlEndAttributesNode : XamlNode {
    internal bool IsCompact { get; }
    internal XamlEndAttributesNode(int lineNumber, int linePosition, int depth, bool compact);
    internal bool get_IsCompact();
}
internal class System.Windows.Markup.XamlFigureLengthSerializer : XamlSerializer {
    private static XamlFigureLengthSerializer();
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal static void FromString(string s, CultureInfo cultureInfo, Double& value, FigureUnitType& unit);
}
internal class System.Windows.Markup.XamlGridLengthSerializer : XamlSerializer {
    private static XamlGridLengthSerializer();
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal static void FromString(string s, CultureInfo cultureInfo, Double& value, GridUnitType& unit);
}
public abstract class System.Windows.Markup.XamlInstanceCreator : object {
    public abstract virtual object CreateObject();
}
internal class System.Windows.Markup.XamlInt32CollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlKeyElementEndNode : XamlElementEndNode {
    internal XamlKeyElementEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlKeyElementStartNode : XamlElementStartNode {
    internal XamlKeyElementStartNode(int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType);
}
[DebuggerDisplayAttribute("Cont:{_content}")]
internal class System.Windows.Markup.XamlLiteralContentNode : XamlNode {
    internal string Content { get; }
    internal XamlLiteralContentNode(int lineNumber, int linePosition, int depth, string content);
    internal string get_Content();
}
internal class System.Windows.Markup.XamlNode : object {
    internal static XamlNodeType[] ScopeStartTokens;
    internal static XamlNodeType[] ScopeEndTokens;
    internal XamlNodeType TokenType { get; }
    internal int LineNumber { get; }
    internal int LinePosition { get; }
    internal int Depth { get; }
    internal XamlNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth);
    private static XamlNode();
    internal XamlNodeType get_TokenType();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal int get_Depth();
}
internal enum System.Windows.Markup.XamlNodeType : Enum {
    public int value__;
    public static XamlNodeType Unknown;
    public static XamlNodeType DocumentStart;
    public static XamlNodeType DocumentEnd;
    public static XamlNodeType ElementStart;
    public static XamlNodeType ElementEnd;
    public static XamlNodeType Property;
    public static XamlNodeType PropertyComplexStart;
    public static XamlNodeType PropertyComplexEnd;
    public static XamlNodeType PropertyArrayStart;
    public static XamlNodeType PropertyArrayEnd;
    public static XamlNodeType PropertyIListStart;
    public static XamlNodeType PropertyIListEnd;
    public static XamlNodeType PropertyIDictionaryStart;
    public static XamlNodeType PropertyIDictionaryEnd;
    public static XamlNodeType PropertyWithExtension;
    public static XamlNodeType PropertyWithType;
    public static XamlNodeType LiteralContent;
    public static XamlNodeType Text;
    public static XamlNodeType RoutedEvent;
    public static XamlNodeType ClrEvent;
    public static XamlNodeType XmlnsProperty;
    public static XamlNodeType XmlAttribute;
    public static XamlNodeType ProcessingInstruction;
    public static XamlNodeType Comment;
    public static XamlNodeType DefTag;
    public static XamlNodeType DefAttribute;
    public static XamlNodeType PresentationOptionsAttribute;
    public static XamlNodeType DefKeyTypeAttribute;
    public static XamlNodeType EndAttributes;
    public static XamlNodeType PIMapping;
    public static XamlNodeType UnknownTagStart;
    public static XamlNodeType UnknownTagEnd;
    public static XamlNodeType UnknownAttribute;
    public static XamlNodeType KeyElementStart;
    public static XamlNodeType KeyElementEnd;
    public static XamlNodeType ConstructorParametersStart;
    public static XamlNodeType ConstructorParametersEnd;
    public static XamlNodeType ConstructorParameterType;
    public static XamlNodeType ContentProperty;
}
internal class System.Windows.Markup.XamlObjectIds : object {
    public string Name;
    public string Uid;
    public object Key;
}
public class System.Windows.Markup.XamlParseException : SystemException {
    internal static string BamlExt;
    internal static string XamlExt;
    public int LineNumber { get; internal set; }
    public int LinePosition { get; internal set; }
    public object KeyContext { get; internal set; }
    public string UidContext { get; internal set; }
    public string NameContext { get; internal set; }
    public Uri BaseUri { get; internal set; }
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
    public XamlParseException(string message, int lineNumber, int linePosition);
    public XamlParseException(string message, int lineNumber, int linePosition, Exception innerException);
    internal XamlParseException(string message, int lineNumber, int linePosition, Uri baseUri, Exception innerException);
    protected XamlParseException(SerializationInfo info, StreamingContext context);
    public int get_LineNumber();
    internal void set_LineNumber(int value);
    public int get_LinePosition();
    internal void set_LinePosition(int value);
    public object get_KeyContext();
    internal void set_KeyContext(object value);
    public string get_UidContext();
    internal void set_UidContext(string value);
    public string get_NameContext();
    internal void set_NameContext(string value);
    public Uri get_BaseUri();
    internal void set_BaseUri(Uri value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static string GetMarkupFilePath(Uri resourceUri);
    internal static string GenerateErrorMessageContext(int lineNumber, int linePosition, Uri baseUri, XamlObjectIds xamlObjectIds, Type objectType);
    internal static void ThrowException(string message, Exception innerException, int lineNumber, int linePosition, Uri baseUri, XamlObjectIds currentXamlObjectIds, XamlObjectIds contextXamlObjectIds, Type objectType);
    internal static void ThrowException(ParserContext parserContext, int lineNumber, int linePosition, string message, Exception innerException);
    internal static void ThrowException(string message, Exception innerException, int lineNumber, int linePosition);
}
internal enum System.Windows.Markup.XamlParseMode : Enum {
    public int value__;
    public static XamlParseMode Uninitialized;
    public static XamlParseMode Synchronous;
    public static XamlParseMode Asynchronous;
}
internal class System.Windows.Markup.XamlParser : object {
    internal static void ThrowException(string id, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, string value3, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, string value3, string value4, int lineNumber, int linePosition);
}
internal class System.Windows.Markup.XamlPathDataSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
[DebuggerDisplayAttribute("PIMap:{_xmlns}={_clrns};{_assy}")]
internal class System.Windows.Markup.XamlPIMappingNode : XamlNode {
    internal string XmlNamespace { get; }
    internal string ClrNamespace { get; }
    internal string AssemblyName { get; }
    internal XamlPIMappingNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string clrNamespace, string assemblyName);
    internal string get_XmlNamespace();
    internal string get_ClrNamespace();
    internal string get_AssemblyName();
}
internal class System.Windows.Markup.XamlPoint3DCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlPointCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlPresentationOptionsAttributeNode : XamlAttributeNode {
    internal string Name { get; }
    internal XamlPresentationOptionsAttributeNode(int lineNumber, int linePosition, int depth, string name, string value);
    internal string get_Name();
}
internal class System.Windows.Markup.XamlPropertyArrayEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyArrayEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyArrayStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyArrayStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
[DebuggerDisplayAttribute("Prop:{_typeFullName}.{_propName}")]
internal class System.Windows.Markup.XamlPropertyBaseNode : XamlNode {
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string PropName { get; }
    internal Type PropDeclaringType { get; }
    internal Type PropValidType { get; }
    internal object PropertyMember { get; }
    internal XamlPropertyBaseNode(XamlNodeType token, int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_PropName();
    internal Type get_PropDeclaringType();
    internal Type get_PropValidType();
    internal object get_PropertyMember();
}
internal class System.Windows.Markup.XamlPropertyComplexEndNode : XamlNode {
    internal XamlPropertyComplexEndNode(int lineNumber, int linePosition, int depth);
    internal XamlPropertyComplexEndNode(XamlNodeType token, int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyComplexStartNode : XamlPropertyBaseNode {
    internal XamlPropertyComplexStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal XamlPropertyComplexStartNode(XamlNodeType token, int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyIDictionaryEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyIDictionaryEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyIDictionaryStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyIDictionaryStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyIListEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyIListEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyIListStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyIListStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyNode : XamlPropertyBaseNode {
    internal string Value { get; }
    internal Type ValueDeclaringType { get; internal set; }
    internal string ValuePropertyName { get; internal set; }
    internal Type ValuePropertyType { get; internal set; }
    internal object ValuePropertyMember { get; internal set; }
    internal bool HasValueId { get; }
    internal short ValueId { get; internal set; }
    internal string MemberName { get; internal set; }
    internal Type DefaultTargetType { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; }
    internal bool ComplexAsSimple { get; }
    internal XamlPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, BamlAttributeUsage attributeUsage, bool complexAsSimple);
    internal XamlPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, BamlAttributeUsage attributeUsage, bool complexAsSimple, bool isDefinitionName);
    internal string get_Value();
    internal void SetValue(string value);
    internal Type get_ValueDeclaringType();
    internal void set_ValueDeclaringType(Type value);
    internal string get_ValuePropertyName();
    internal void set_ValuePropertyName(string value);
    internal Type get_ValuePropertyType();
    internal void set_ValuePropertyType(Type value);
    internal object get_ValuePropertyMember();
    internal void set_ValuePropertyMember(object value);
    internal bool get_HasValueId();
    internal short get_ValueId();
    internal void set_ValueId(short value);
    internal string get_MemberName();
    internal void set_MemberName(string value);
    internal Type get_DefaultTargetType();
    internal void set_DefaultTargetType(Type value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal bool get_ComplexAsSimple();
}
internal class System.Windows.Markup.XamlPropertyWithExtensionNode : XamlPropertyBaseNode {
    internal short ExtensionTypeId { get; }
    internal string Value { get; }
    internal bool IsValueNestedExtension { get; }
    internal bool IsValueTypeExtension { get; }
    internal Type DefaultTargetType { get; internal set; }
    internal XamlPropertyWithExtensionNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, short extensionTypeId, bool isValueNestedExtension, bool isValueTypeExtension);
    internal short get_ExtensionTypeId();
    internal string get_Value();
    internal bool get_IsValueNestedExtension();
    internal bool get_IsValueTypeExtension();
    internal Type get_DefaultTargetType();
    internal void set_DefaultTargetType(Type value);
}
internal class System.Windows.Markup.XamlPropertyWithTypeNode : XamlPropertyBaseNode {
    internal string ValueTypeFullName { get; }
    internal string ValueTypeAssemblyName { get; }
    internal Type ValueElementType { get; }
    internal string ValueSerializerTypeFullName { get; }
    internal string ValueSerializerTypeAssemblyName { get; }
    internal XamlPropertyWithTypeNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string valueTypeFullName, string valueAssemblyName, Type valueElementType, string valueSerializerTypeFullName, string valueSerializerTypeAssemblyName);
    internal string get_ValueTypeFullName();
    internal string get_ValueTypeAssemblyName();
    internal Type get_ValueElementType();
    internal string get_ValueSerializerTypeFullName();
    internal string get_ValueSerializerTypeAssemblyName();
}
public class System.Windows.Markup.XamlReader : object {
    internal static WpfSharedBamlSchemaContext BamlSharedSchemaContext { get; }
    internal static WpfSharedBamlSchemaContext XamlV3SharedSchemaContext { get; }
    private static XamlReader();
    public static object Parse(string xamlText);
    public static object Parse(string xamlText, ParserContext parserContext);
    public static object Load(Stream stream);
    public static object Load(XmlReader reader);
    public static object Load(Stream stream, ParserContext parserContext);
    public object LoadAsync(Stream stream);
    public object LoadAsync(XmlReader reader);
    public object LoadAsync(Stream stream, ParserContext parserContext);
    internal static bool ShouldReWrapException(Exception e, Uri baseUri);
    internal static void RewrapException(Exception e, Uri baseUri);
    internal static void RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri);
    internal static XamlParseException WrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri);
    internal void Post();
    internal void Post(DispatcherPriority priority);
    internal virtual void HandleAsyncQueueItem();
    internal void TreeBuildComplete();
    public void CancelAsync();
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(AsyncCompletedEventHandler value);
    internal static XamlObjectWriterSettings CreateObjectWriterSettings();
    internal static XamlObjectWriterSettings CreateObjectWriterSettings(XamlObjectWriterSettings parentSettings);
    internal static XamlObjectWriterSettings CreateObjectWriterSettingsForBaml();
    internal static Baml2006ReaderSettings CreateBamlReaderSettings();
    internal static XamlSchemaContextSettings CreateSchemaContextSettings();
    internal static WpfSharedBamlSchemaContext get_BamlSharedSchemaContext();
    internal static WpfSharedBamlSchemaContext get_XamlV3SharedSchemaContext();
    public static XamlSchemaContext GetWpfSchemaContext();
    internal static object Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode);
    internal static object Load(XamlReader xamlReader, ParserContext parserContext);
    public static object Load(XamlReader reader);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static object LoadBaml(Stream stream, ParserContext parserContext, object parent, bool closeStream);
}
internal class System.Windows.Markup.XamlReaderHelper : object {
    internal static string DefinitionNamespaceURI;
    internal static string DefinitionUid;
    internal static string DefinitionType;
    internal static string DefinitionTypeArgs;
    internal static string DefinitionName;
    internal static string DefinitionRuntimeName;
    internal static string DefinitionShared;
    internal static string DefinitionSynchronousMode;
    internal static string DefinitionAsyncRecords;
    internal static string DefinitionContent;
    internal static string DefinitionClass;
    internal static string DefinitionSubclass;
    internal static string DefinitionClassModifier;
    internal static string DefinitionFieldModifier;
    internal static string DefinitionCodeTag;
    internal static string DefinitionXDataTag;
    internal static string MappingProtocol;
    internal static string MappingAssembly;
    internal static string PresentationOptionsFreeze;
    internal static string DefaultNamespaceURI;
    internal static string DefinitionMetroNamespaceURI;
    internal static string PresentationOptionsNamespaceURI;
    internal static XamlDirective Freeze { get; }
    internal static XamlDirective get_Freeze();
}
internal class System.Windows.Markup.XamlRoutedEventNode : XamlAttributeNode {
    internal RoutedEvent Event { get; }
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string EventName { get; }
    internal XamlRoutedEventNode(int lineNumber, int linePosition, int depth, RoutedEvent routedEvent, string assemblyName, string typeFullName, string routedEventName, string value);
    internal RoutedEvent get_Event();
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_EventName();
}
internal class System.Windows.Markup.XamlSerializer : object {
    internal static string DefNamespacePrefix;
    internal static string DefNamespace;
    internal static string ArrayTag;
    internal static string ArrayTagTypeAttribute;
    internal virtual void ConvertXamlToBaml(XamlReaderHelper tokenReader, ParserContext context, XamlNode xamlNode, BamlRecordWriter bamlWriter);
    internal virtual void ConvertXamlToObject(XamlReaderHelper tokenReader, ReadWriteStreamManager streamManager, ParserContext context, XamlNode xamlNode, BamlRecordReader reader);
    internal virtual void ConvertBamlToObject(BamlRecordReader reader, BamlRecord bamlRecord, ParserContext context);
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal virtual object GetDictionaryKey(BamlRecord bamlRecord, ParserContext parserContext);
}
internal static class System.Windows.Markup.XamlSerializerUtil : object {
    internal static void ThrowIfNonWhiteSpaceInAddText(string s, object parent);
}
internal class System.Windows.Markup.XamlStyleSerializer : XamlSerializer {
    internal static string StyleTagName;
    internal static string TargetTypePropertyName;
    internal static string BasedOnPropertyName;
    internal static string VisualTriggersPropertyName;
    internal static string ResourcesPropertyName;
    internal static string SettersPropertyName;
    internal static string VisualTriggersFullPropertyName;
    internal static string SettersFullPropertyName;
    internal static string ResourcesFullPropertyName;
    internal static string PropertyTriggerPropertyName;
    internal static string PropertyTriggerValuePropertyName;
    internal static string PropertyTriggerSourceName;
    internal static string PropertyTriggerEnterActions;
    internal static string PropertyTriggerExitActions;
    internal static string DataTriggerBindingPropertyName;
    internal static string EventTriggerEventName;
    internal static string EventTriggerSourceName;
    internal static string EventTriggerActions;
    internal static string MultiPropertyTriggerConditionsPropertyName;
    internal static string SetterTagName;
    internal static string SetterPropertyAttributeName;
    internal static string SetterValueAttributeName;
    internal static string SetterTargetAttributeName;
    internal static string SetterEventAttributeName;
    internal static string SetterHandlerAttributeName;
    internal virtual object GetDictionaryKey(BamlRecord startRecord, ParserContext parserContext);
}
internal class System.Windows.Markup.XamlTemplateSerializer : XamlSerializer {
    internal static string ControlTemplateTagName;
    internal static string DataTemplateTagName;
    internal static string HierarchicalDataTemplateTagName;
    internal static string ItemsPanelTemplateTagName;
    internal static string TargetTypePropertyName;
    internal static string DataTypePropertyName;
    internal static string TriggersPropertyName;
    internal static string ResourcesPropertyName;
    internal static string SettersPropertyName;
    internal static string ItemsSourcePropertyName;
    internal static string ItemTemplatePropertyName;
    internal static string ItemTemplateSelectorPropertyName;
    internal static string ItemContainerStylePropertyName;
    internal static string ItemContainerStyleSelectorPropertyName;
    internal static string ItemStringFormatPropertyName;
    internal static string ItemBindingGroupPropertyName;
    internal static string AlternationCountPropertyName;
    internal static string ControlTemplateTriggersFullPropertyName;
    internal static string ControlTemplateResourcesFullPropertyName;
    internal static string DataTemplateTriggersFullPropertyName;
    internal static string DataTemplateResourcesFullPropertyName;
    internal static string HierarchicalDataTemplateTriggersFullPropertyName;
    internal static string HierarchicalDataTemplateItemsSourceFullPropertyName;
    internal static string HierarchicalDataTemplateItemTemplateFullPropertyName;
    internal static string HierarchicalDataTemplateItemTemplateSelectorFullPropertyName;
    internal static string HierarchicalDataTemplateItemContainerStyleFullPropertyName;
    internal static string HierarchicalDataTemplateItemContainerStyleSelectorFullPropertyName;
    internal static string HierarchicalDataTemplateItemStringFormatFullPropertyName;
    internal static string HierarchicalDataTemplateItemBindingGroupFullPropertyName;
    internal static string HierarchicalDataTemplateAlternationCountFullPropertyName;
    internal static string PropertyTriggerPropertyName;
    internal static string PropertyTriggerValuePropertyName;
    internal static string PropertyTriggerSourceName;
    internal static string PropertyTriggerEnterActions;
    internal static string PropertyTriggerExitActions;
    internal static string DataTriggerBindingPropertyName;
    internal static string EventTriggerEventName;
    internal static string EventTriggerSourceName;
    internal static string EventTriggerActions;
    internal static string MultiPropertyTriggerConditionsPropertyName;
    internal static string SetterTagName;
    internal static string SetterPropertyAttributeName;
    internal static string SetterValueAttributeName;
    internal static string SetterTargetAttributeName;
    internal static string SetterEventAttributeName;
    internal static string SetterHandlerAttributeName;
    internal virtual object GetDictionaryKey(BamlRecord startRecord, ParserContext parserContext);
}
[DebuggerDisplayAttribute("Text:{_text}")]
internal class System.Windows.Markup.XamlTextNode : XamlNode {
    internal string Text { get; }
    internal Type ConverterType { get; }
    internal XamlTextNode(int lineNumber, int linePosition, int depth, string textContent, Type converterType);
    internal string get_Text();
    internal Type get_ConverterType();
    internal void UpdateText(string text);
}
public class System.Windows.Markup.XamlTypeMapper : object {
    internal static string MarkupExtensionTypeString;
    internal static string MarkupExtensionStaticString;
    internal static string MarkupExtensionDynamicResourceString;
    internal static string PresentationFrameworkDllName;
    internal static string GeneratedNamespace;
    internal static string GeneratedInternalTypeHelperClassName;
    internal static string MarkupExtensionTemplateBindingString;
    public static XamlTypeMapper DefaultMapper { get; }
    internal HybridDictionary PITable { get; }
    internal BamlMapTable MapTable { get; internal set; }
    unknown int LineNumber {internal set; }
    unknown int LinePosition {internal set; }
    internal Hashtable NamespaceMapHashList { get; }
    internal XamlSchemaContext SchemaContext { get; }
    public XamlTypeMapper(String[] assemblyNames);
    public XamlTypeMapper(String[] assemblyNames, NamespaceMapEntry[] namespaceMaps);
    private static XamlTypeMapper();
    public Type GetType(string xmlNamespace, string localName);
    public void AddMappingProcessingInstruction(string xmlNamespace, string clrNamespace, string assemblyName);
    public void SetAssemblyPath(string assemblyName, string assemblyPath);
    public static XamlTypeMapper get_DefaultMapper();
    internal void Initialize();
    internal XamlTypeMapper Clone();
    internal string AssemblyPathFor(string assemblyName);
    internal RoutedEvent GetRoutedEvent(Type owner, string xmlNamespace, string localName);
    internal object ParseProperty(object targetObject, Type propType, string propName, object dpOrPiOrFi, ITypeDescriptorContext typeContext, ParserContext parserContext, string value, short converterTypeId);
    internal void ValidateNames(string value, int lineNumber, int linePosition);
    internal void ValidateEnums(string propName, Type propType, string attribValue);
    internal void UpdateClrPropertyInfo(Type currentParentType, BamlAttributeInfoRecord attribInfo);
    internal void UpdateAttachedPropertySetter(BamlAttributeInfoRecord attributeInfo);
    internal void UpdateAttachedPropertyGetter(BamlAttributeInfoRecord attributeInfo);
    internal MemberInfo GetClrInfo(bool isEvent, Type owner, string xmlNamespace, string localName, String& propName);
    internal bool IsAllowedPropertySet(PropertyInfo pi);
    internal bool IsAllowedPropertyGet(PropertyInfo pi);
    internal static bool IsAllowedPropertySet(PropertyInfo pi, bool allowProtected, Boolean& isPublic);
    protected virtual bool AllowInternalType(Type type);
    internal MemberInfo GetClrInfoForClass(bool isEvent, Type owner, string xmlNamespace, string localName, string globalClassName, String& propName);
    internal EventInfo GetClrEventInfo(Type owner, string eventName);
    internal object GetDependencyObject(bool isEvent, Type owner, string xmlNamespace, string localName, Type& baseType, String& dynamicObjectName);
    internal DependencyProperty DependencyPropertyFromName(string localName, string xmlNamespace, Type& ownerType);
    internal PropertyInfo GetXmlLangProperty(string xmlNamespace, string localName);
    internal RoutedEvent RoutedEventFromName(string localName, Type ownerType);
    internal static Type GetPropertyType(object propertyMember);
    internal static void GetPropertyType(object propertyMember, Type& propertyType, Boolean& propertyCanWrite);
    internal static string GetPropertyName(object propertyMember);
    internal static Type GetDeclaringType(object propertyMember);
    internal static Type GetTypeFromName(string typeName, DependencyObject element);
    internal Type GetTargetTypeAndMember(string valueParam, ParserContext context, bool isTypeExpected, String& memberName);
    internal Type GetDependencyPropertyOwnerAndName(string memberValue, ParserContext context, Type defaultTargetType, String& memberName);
    internal MemberInfo GetStaticMemberInfo(Type targetType, string memberName, bool fieldInfoOnly);
    internal TypeAndSerializer GetTypeOnly(string xmlNamespace, string localName);
    internal TypeAndSerializer GetTypeAndSerializer(string xmlNamespace, string localName, object dpOrPiorMi);
    internal int GetCustomBamlSerializerIdForType(Type objectType);
    internal Type GetXamlSerializerForType(Type objectType);
    internal static Type GetInternalTypeHelperTypeFromAssembly(ParserContext pc);
    internal static object CreateInternalInstance(ParserContext pc, Type type);
    internal static object GetInternalPropertyValue(ParserContext pc, object rootElement, PropertyInfo pi, object target);
    internal static bool SetInternalPropertyValue(ParserContext pc, object rootElement, PropertyInfo pi, object target, object value);
    internal static Delegate CreateDelegate(ParserContext pc, Type delegateType, object target, string handler);
    internal static bool AddInternalEventHandler(ParserContext pc, object rootElement, EventInfo eventInfo, object target, Delegate handler);
    internal bool IsLocalAssembly(string namespaceUri);
    internal Type GetTypeFromBaseString(string typeString, ParserContext context, bool throwOnError);
    internal static string ProcessNameString(ParserContext parserContext, String& nameString);
    internal static DependencyProperty ParsePropertyName(ParserContext parserContext, string propertyName, Type& ownerType);
    internal static RoutedEvent ParseEventName(ParserContext parserContext, string eventName, Type ownerType);
    internal object CreateInstance(Type t);
    internal bool IsXmlNamespaceKnown(string xmlNamespace, String& newXmlNamespace);
    internal void SetUriToAssemblyNameMapping(string xmlNamespace, Int16[] assemblyIds);
    internal NamespaceMapEntry[] GetNamespaceMapEntries(string xmlNamespace);
    internal string GetXmlNamespace(string clrNamespaceFullName, string assemblyFullName);
    internal static List`1<ClrNamespaceAssemblyPair> GetClrNamespacePairFromCache(string namespaceUri);
    internal Type GetTypeConverterType(Type type);
    internal TypeConverter GetTypeConverter(Type type);
    internal Type GetPropertyConverterType(Type propType, object dpOrPiOrMi);
    internal TypeConverter GetPropertyConverter(Type propType, object dpOrPiOrMi);
    internal object GetDictionaryKey(string keyString, ParserContext context);
    internal ConstructorData GetConstructors(Type type);
    internal bool GetCachedTrimSurroundingWhitespace(Type t);
    internal void ThrowException(string id, string parameter);
    internal void ThrowExceptionWithLine(string message, Exception innerException);
    internal HybridDictionary get_PITable();
    internal BamlMapTable get_MapTable();
    internal void set_MapTable(BamlMapTable value);
    internal void set_LineNumber(int value);
    internal void set_LinePosition(int value);
    internal Hashtable get_NamespaceMapHashList();
    internal XamlSchemaContext get_SchemaContext();
}
internal class System.Windows.Markup.XamlUnknownAttributeNode : XamlAttributeNode {
    internal string XmlNamespace { get; }
    internal string Name { get; }
    internal XamlUnknownAttributeNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string name, string value, BamlAttributeUsage attributeUsage);
    internal string get_XmlNamespace();
    internal string get_Name();
}
internal class System.Windows.Markup.XamlUnknownTagEndNode : XamlNode {
    internal XamlUnknownTagEndNode(int lineNumber, int linePosition, int depth, string localName, string xmlNamespace);
}
internal class System.Windows.Markup.XamlUnknownTagStartNode : XamlAttributeNode {
    internal string XmlNamespace { get; }
    internal XamlUnknownTagStartNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string value);
    internal string get_XmlNamespace();
}
internal class System.Windows.Markup.XamlVector3DCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
public static class System.Windows.Markup.XamlWriter : object {
    [SecuritySafeCriticalAttribute]
public static string Save(object obj);
    [SecuritySafeCriticalAttribute]
public static void Save(object obj, TextWriter writer);
    [SecuritySafeCriticalAttribute]
public static void Save(object obj, Stream stream);
    [SecuritySafeCriticalAttribute]
public static void Save(object obj, XmlWriter xmlWriter);
    [SecuritySafeCriticalAttribute]
public static void Save(object obj, XamlDesignerSerializationManager manager);
}
public enum System.Windows.Markup.XamlWriterMode : Enum {
    public int value__;
    public static XamlWriterMode Expression;
    public static XamlWriterMode Value;
}
public enum System.Windows.Markup.XamlWriterState : Enum {
    public int value__;
    public static XamlWriterState Starting;
    public static XamlWriterState Finished;
}
[DebuggerDisplayAttribute("Xmlns:{_prefix)={_xmlNamespace}")]
internal class System.Windows.Markup.XamlXmlnsPropertyNode : XamlNode {
    internal string Prefix { get; }
    internal string XmlNamespace { get; }
    internal XamlXmlnsPropertyNode(int lineNumber, int linePosition, int depth, string prefix, string xmlNamespace);
    internal string get_Prefix();
    internal string get_XmlNamespace();
}
public class System.Windows.Markup.XmlAttributeProperties : object {
    [BrowsableAttribute("False")]
[LocalizabilityAttribute("17")]
public static DependencyProperty XmlSpaceProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlnsDictionaryProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlnsDefinitionProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlNamespaceMapsProperty;
    internal static string XmlSpaceString;
    internal static string XmlLangString;
    internal static string XmlnsDefinitionString;
    internal static MethodInfo XmlSpaceSetter { get; }
    private static XmlAttributeProperties();
    [DesignerSerializationOptionsAttribute("1")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetXmlSpace(DependencyObject dependencyObject);
    public static void SetXmlSpace(DependencyObject dependencyObject, string value);
    [DesignerSerializationVisibilityAttribute("0")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static XmlnsDictionary GetXmlnsDictionary(DependencyObject dependencyObject);
    public static void SetXmlnsDictionary(DependencyObject dependencyObject, XmlnsDictionary value);
    [DesignerSerializationVisibilityAttribute("0")]
[DesignerSerializationOptionsAttribute("1")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetXmlnsDefinition(DependencyObject dependencyObject);
    public static void SetXmlnsDefinition(DependencyObject dependencyObject, string value);
    [DesignerSerializationVisibilityAttribute("0")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetXmlNamespaceMaps(DependencyObject dependencyObject);
    public static void SetXmlNamespaceMaps(DependencyObject dependencyObject, string value);
    internal static MethodInfo get_XmlSpaceSetter();
}
internal class System.Windows.Markup.XmlnsCache : object {
    internal List`1<ClrNamespaceAssemblyPair> GetMappingArray(string xmlns);
    internal void SetUriToAssemblyNameMapping(string namespaceUri, String[] asmNameList);
    internal string GetNewXmlnamespace(string oldXmlnamespace);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Markup.XmlnsDictionary : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public string Item { get; public set; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool Sealed { get; }
    public XmlnsDictionary(XmlnsDictionary xmlnsDictionary);
    public sealed virtual void Add(object prefix, object xmlNamespace);
    public void Add(string prefix, string xmlNamespace);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public void Remove(string prefix);
    public sealed virtual void Remove(object prefix);
    public void CopyTo(DictionaryEntry[] array, int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual string GetNamespace(string prefix);
    [IteratorStateMachineAttribute("System.Windows.Markup.XmlnsDictionary/<GetNamespacePrefixes>d__15")]
public sealed virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    protected IDictionaryEnumerator GetDictionaryEnumerator();
    protected IEnumerator GetEnumerator();
    public void Seal();
    public string LookupNamespace(string prefix);
    public string LookupPrefix(string xmlNamespace);
    public string DefaultNamespace();
    public void PushScope();
    public void PopScope();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public string get_Item(string prefix);
    public void set_Item(string prefix, string value);
    public sealed virtual object get_Item(object prefix);
    public sealed virtual void set_Item(object prefix, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public bool get_Sealed();
    internal void Unseal();
}
internal static class System.Windows.Markup.XmlParserDefaults : object {
    internal static XamlTypeMapper DefaultMapper { get; }
    private static XmlParserDefaults();
    internal static XamlTypeMapper get_DefaultMapper();
    internal static String[] GetDefaultAssemblyNames();
    internal static NamespaceMapEntry[] GetDefaultNamespaceMaps();
}
public class System.Windows.Media.AdornerHitTestResult : PointHitTestResult {
    public Adorner Adorner { get; }
    internal AdornerHitTestResult(Visual visual, Point pt, Adorner adorner);
    public Adorner get_Adorner();
}
[RuntimeNamePropertyAttribute("Name")]
[ContentPropertyAttribute("Storyboard")]
public class System.Windows.Media.Animation.BeginStoryboard : TriggerAction {
    public static DependencyProperty StoryboardProperty;
    [DefaultValueAttribute("")]
public Storyboard Storyboard { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HandoffBehavior HandoffBehavior { get; public set; }
    [DefaultValueAttribute("")]
public string Name { get; public set; }
    private static BeginStoryboard();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    public HandoffBehavior get_HandoffBehavior();
    public void set_HandoffBehavior(HandoffBehavior value);
    public string get_Name();
    public void set_Name(string value);
    internal virtual void Seal();
    internal sealed virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate frameworkTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement fe);
}
public abstract class System.Windows.Media.Animation.ControllableStoryboardAction : TriggerAction {
    [DefaultValueAttribute("")]
public string BeginStoryboardName { get; public set; }
    public string get_BeginStoryboardName();
    public void set_BeginStoryboardName(string value);
    internal sealed virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate frameworkTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement fe);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.DiscreteThicknessKeyFrame : ThicknessKeyFrame {
    public DiscreteThicknessKeyFrame(Thickness value);
    public DiscreteThicknessKeyFrame(Thickness value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingThicknessKeyFrame : ThicknessKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingThicknessKeyFrame(Thickness value);
    public EasingThicknessKeyFrame(Thickness value, KeyTime keyTime);
    public EasingThicknessKeyFrame(Thickness value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingThicknessKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.LinearThicknessKeyFrame : ThicknessKeyFrame {
    public LinearThicknessKeyFrame(Thickness value);
    public LinearThicknessKeyFrame(Thickness value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.PauseStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.RemoveStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.ResumeStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SeekStoryboard : ControllableStoryboardAction {
    public TimeSpan Offset { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TimeSeekOrigin Origin { get; public set; }
    public TimeSpan get_Offset();
    public void set_Offset(TimeSpan value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeOffset();
    public TimeSeekOrigin get_Origin();
    public void set_Origin(TimeSeekOrigin value);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SetStoryboardSpeedRatio : ControllableStoryboardAction {
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SkipStoryboardToFill : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SplineThicknessKeyFrame : ThicknessKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineThicknessKeyFrame(Thickness value);
    public SplineThicknessKeyFrame(Thickness value, KeyTime keyTime);
    public SplineThicknessKeyFrame(Thickness value, KeyTime keyTime, KeySpline keySpline);
    private static SplineThicknessKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.StopStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.Storyboard : ParallelTimeline {
    public static DependencyProperty TargetProperty;
    public static DependencyProperty TargetNameProperty;
    public static DependencyProperty TargetPropertyProperty;
    private static Storyboard();
    protected virtual Freezable CreateInstanceCore();
    public Storyboard Clone();
    public static void SetTarget(DependencyObject element, DependencyObject value);
    [DesignerSerializationVisibilityAttribute("0")]
public static DependencyObject GetTarget(DependencyObject element);
    public static void SetTargetName(DependencyObject element, string name);
    public static string GetTargetName(DependencyObject element);
    public static void SetTargetProperty(DependencyObject element, PropertyPath path);
    public static PropertyPath GetTargetProperty(DependencyObject element);
    internal static DependencyObject ResolveTargetName(string targetName, INameScope nameScope, DependencyObject element);
    internal static BeginStoryboard ResolveBeginStoryboardName(string targetName, INameScope nameScope, FrameworkElement fe, FrameworkContentElement fce);
    internal static void VerifyPathIsAnimatable(PropertyPath path);
    internal static void GetComplexPathValue(DependencyObject targetObject, DependencyProperty targetProperty, EffectiveValueEntry& entry, PropertyMetadata metadata);
    public void Begin(FrameworkElement containingObject);
    public void Begin(FrameworkElement containingObject, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkElement containingObject, bool isControllable);
    public void Begin(FrameworkElement containingObject, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, bool isControllable);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin(FrameworkContentElement containingObject);
    public void Begin(FrameworkContentElement containingObject, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkContentElement containingObject, bool isControllable);
    public void Begin(FrameworkContentElement containingObject, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin();
    internal void BeginCommon(DependencyObject containingObject, INameScope nameScope, HandoffBehavior handoffBehavior, bool isControllable, long layer);
    public Nullable`1<double> GetCurrentGlobalSpeed(FrameworkElement containingObject);
    public Nullable`1<double> GetCurrentGlobalSpeed(FrameworkContentElement containingObject);
    public double GetCurrentGlobalSpeed();
    public Nullable`1<int> GetCurrentIteration(FrameworkElement containingObject);
    public Nullable`1<int> GetCurrentIteration(FrameworkContentElement containingObject);
    public int GetCurrentIteration();
    public Nullable`1<double> GetCurrentProgress(FrameworkElement containingObject);
    public Nullable`1<double> GetCurrentProgress(FrameworkContentElement containingObject);
    public double GetCurrentProgress();
    public ClockState GetCurrentState(FrameworkElement containingObject);
    public ClockState GetCurrentState(FrameworkContentElement containingObject);
    public ClockState GetCurrentState();
    public Nullable`1<TimeSpan> GetCurrentTime(FrameworkElement containingObject);
    public Nullable`1<TimeSpan> GetCurrentTime(FrameworkContentElement containingObject);
    public TimeSpan GetCurrentTime();
    public bool GetIsPaused(FrameworkElement containingObject);
    public bool GetIsPaused(FrameworkContentElement containingObject);
    public bool GetIsPaused();
    public void Pause(FrameworkElement containingObject);
    public void Pause(FrameworkContentElement containingObject);
    public void Pause();
    public void Remove(FrameworkElement containingObject);
    public void Remove(FrameworkContentElement containingObject);
    public void Remove();
    public void Resume(FrameworkElement containingObject);
    public void Resume(FrameworkContentElement containingObject);
    public void Resume();
    public void Seek(FrameworkElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(FrameworkContentElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(TimeSpan offset);
    public void SeekAlignedToLastTick(FrameworkElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(FrameworkContentElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset);
    public void SetSpeedRatio(FrameworkElement containingObject, double speedRatio);
    public void SetSpeedRatio(FrameworkContentElement containingObject, double speedRatio);
    public void SetSpeedRatio(double speedRatio);
    public void SkipToFill(FrameworkElement containingObject);
    public void SkipToFill(FrameworkContentElement containingObject);
    public void SkipToFill();
    public void Stop(FrameworkElement containingObject);
    public void Stop(FrameworkContentElement containingObject);
    public void Stop();
}
public class System.Windows.Media.Animation.ThicknessAnimation : ThicknessAnimationBase {
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Thickness> From { get; public set; }
    public Nullable`1<Thickness> To { get; public set; }
    public Nullable`1<Thickness> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ThicknessAnimation();
    public ThicknessAnimation(Thickness toValue, Duration duration);
    public ThicknessAnimation(Thickness toValue, Duration duration, FillBehavior fillBehavior);
    public ThicknessAnimation(Thickness fromValue, Thickness toValue, Duration duration);
    public ThicknessAnimation(Thickness fromValue, Thickness toValue, Duration duration, FillBehavior fillBehavior);
    public ThicknessAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    public Nullable`1<Thickness> get_From();
    public void set_From(Nullable`1<Thickness> value);
    public Nullable`1<Thickness> get_To();
    public void set_To(Nullable`1<Thickness> value);
    public Nullable`1<Thickness> get_By();
    public void set_By(Nullable`1<Thickness> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ThicknessAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ThicknessAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Thickness GetCurrentValue(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames : ThicknessAnimationBase {
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ThicknessKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    public ThicknessAnimationUsingKeyFrames Clone();
    public ThicknessAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ThicknessKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ThicknessKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ThicknessKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Thickness Value { get; public set; }
    protected ThicknessKeyFrame(Thickness value);
    protected ThicknessKeyFrame(Thickness value, KeyTime keyTime);
    private static ThicknessKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Thickness get_Value();
    public void set_Value(Thickness value);
    public Thickness InterpolateValue(Thickness baseValue, double keyFrameProgress);
    protected abstract virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ThicknessKeyFrameCollection : Freezable {
    public static ThicknessKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ThicknessKeyFrame Item { get; public set; }
    public static ThicknessKeyFrameCollection get_Empty();
    public ThicknessKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ThicknessKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ThicknessKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ThicknessKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ThicknessKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ThicknessKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ThicknessKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ThicknessKeyFrame get_Item(int index);
    public void set_Item(int index, ThicknessKeyFrame value);
}
public static class System.Windows.Media.TextOptions : object {
    public static DependencyProperty TextFormattingModeProperty;
    public static DependencyProperty TextRenderingModeProperty;
    public static DependencyProperty TextHintingModeProperty;
    private static TextOptions();
    internal static bool IsTextFormattingModeValid(object valueObject);
    public static void SetTextFormattingMode(DependencyObject element, TextFormattingMode value);
    public static TextFormattingMode GetTextFormattingMode(DependencyObject element);
    public static void SetTextRenderingMode(DependencyObject element, TextRenderingMode value);
    public static TextRenderingMode GetTextRenderingMode(DependencyObject element);
    public static void SetTextHintingMode(DependencyObject element, TextHintingMode value);
    public static TextHintingMode GetTextHintingMode(DependencyObject element);
}
public class System.Windows.MediaScriptCommandRoutedEventArgs : RoutedEventArgs {
    public string ParameterType { get; }
    public string ParameterValue { get; }
    internal MediaScriptCommandRoutedEventArgs(RoutedEvent routedEvent, object sender, string parameterType, string parameterValue);
    public string get_ParameterType();
    public string get_ParameterValue();
}
public class System.Windows.MessageBox : object {
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText, string caption);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(string messageBoxText);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText, string caption);
    [SecurityCriticalAttribute]
public static MessageBoxResult Show(Window owner, string messageBoxText);
    [SecurityCriticalAttribute]
internal static MessageBoxResult ShowCore(IntPtr owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
}
public enum System.Windows.MessageBoxButton : Enum {
    public int value__;
    public static MessageBoxButton OK;
    public static MessageBoxButton OKCancel;
    public static MessageBoxButton YesNoCancel;
    public static MessageBoxButton YesNo;
}
public enum System.Windows.MessageBoxImage : Enum {
    public int value__;
    public static MessageBoxImage None;
    public static MessageBoxImage Hand;
    public static MessageBoxImage Question;
    public static MessageBoxImage Exclamation;
    public static MessageBoxImage Asterisk;
    public static MessageBoxImage Stop;
    public static MessageBoxImage Error;
    public static MessageBoxImage Warning;
    public static MessageBoxImage Information;
}
[FlagsAttribute]
public enum System.Windows.MessageBoxOptions : Enum {
    public int value__;
    public static MessageBoxOptions None;
    public static MessageBoxOptions ServiceNotification;
    public static MessageBoxOptions DefaultDesktopOnly;
    public static MessageBoxOptions RightAlign;
    public static MessageBoxOptions RtlReading;
}
public enum System.Windows.MessageBoxResult : Enum {
    public int value__;
    public static MessageBoxResult None;
    public static MessageBoxResult OK;
    public static MessageBoxResult Cancel;
    public static MessageBoxResult Yes;
    public static MessageBoxResult No;
}
[ContentPropertyAttribute("Setters")]
public class System.Windows.MultiDataTrigger : TriggerBase {
    [DesignerSerializationVisibilityAttribute("2")]
public ConditionCollection Conditions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public ConditionCollection get_Conditions();
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
}
[ContentPropertyAttribute("Setters")]
public class System.Windows.MultiTrigger : TriggerBase {
    [DesignerSerializationVisibilityAttribute("2")]
public ConditionCollection Conditions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public ConditionCollection get_Conditions();
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
}
internal class System.Windows.Navigation.BPReadyEventArgs : CancelEventArgs {
    internal object Content { get; }
    internal Uri Uri { get; }
    internal BPReadyEventArgs(object content, Uri uri);
    internal object get_Content();
    internal Uri get_Uri();
}
internal class System.Windows.Navigation.BPReadyEventHandler : MulticastDelegate {
    public BPReadyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BPReadyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BPReadyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Navigation.CustomContentState : object {
    public string JournalEntryName { get; }
    public virtual string get_JournalEntryName();
    public abstract virtual void Replay(NavigationService navigationService, NavigationMode mode);
}
internal class System.Windows.Navigation.DisposeTreeQueueItem : object {
    internal DisposeTreeQueueItem(object node);
    internal object Dispatch(object o);
    internal void DisposeElement(object node);
}
internal class System.Windows.Navigation.EventToRaiseTypedEvent : MulticastDelegate {
    public EventToRaiseTypedEvent(object object, IntPtr method);
    public virtual void Invoke(PageFunctionBase sender, RaiseTypedEventArgs args);
    public virtual IAsyncResult BeginInvoke(PageFunctionBase sender, RaiseTypedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.FinishEventHandler : MulticastDelegate {
    public FinishEventHandler(object object, IntPtr method);
    public virtual void Invoke(PageFunctionBase sender, object ReturnEventArgs);
    public virtual IAsyncResult BeginInvoke(PageFunctionBase sender, object ReturnEventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.FragmentNavigationEventArgs : EventArgs {
    public string Fragment { get; }
    public bool Handled { get; public set; }
    public object Navigator { get; }
    internal FragmentNavigationEventArgs(string fragment, object Navigator);
    public string get_Fragment();
    public bool get_Handled();
    public void set_Handled(bool value);
    public object get_Navigator();
}
public class System.Windows.Navigation.FragmentNavigationEventHandler : MulticastDelegate {
    public FragmentNavigationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FragmentNavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FragmentNavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.Navigation.IProvideCustomContentState {
    public abstract virtual CustomContentState GetContentState();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Navigation.Journal : object {
    internal JournalEntry Item { get; }
    internal int TotalCount { get; }
    internal int CurrentIndex { get; }
    internal JournalEntry CurrentEntry { get; }
    internal bool HasUncommittedNavigation { get; }
    internal JournalEntryStack BackStack { get; }
    internal JournalEntryStack ForwardStack { get; }
    internal bool CanGoBack { get; }
    internal bool CanGoForward { get; }
    internal int Version { get; }
    internal JournalEntryFilter Filter { get; internal set; }
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal JournalEntry get_Item(int index);
    internal int get_TotalCount();
    internal int get_CurrentIndex();
    internal JournalEntry get_CurrentEntry();
    internal bool get_HasUncommittedNavigation();
    internal JournalEntryStack get_BackStack();
    internal JournalEntryStack get_ForwardStack();
    internal bool get_CanGoBack();
    internal bool get_CanGoForward();
    internal int get_Version();
    internal JournalEntryFilter get_Filter();
    internal void set_Filter(JournalEntryFilter value);
    internal void add_BackForwardStateChange(EventHandler value);
    internal void remove_BackForwardStateChange(EventHandler value);
    internal JournalEntry RemoveBackEntry();
    internal void UpdateCurrentEntry(JournalEntry journalEntry);
    internal void RecordNewNavigation();
    internal bool ClearForwardStack();
    internal void CommitJournalNavigation(JournalEntry navigated);
    internal void AbortJournalNavigation();
    internal JournalEntry BeginBackNavigation();
    internal JournalEntry BeginForwardNavigation();
    internal NavigationMode GetNavigationMode(JournalEntry entry);
    internal void NavigateTo(JournalEntry target);
    internal int FindIndexForEntryWithId(int id);
    internal void PruneKeepAliveEntries();
    internal JournalEntry RemoveEntryInternal(int index);
    internal void RemoveEntries(Guid navSvcId);
    internal void UpdateView();
    internal JournalEntry GetGoBackEntry(Int32& index);
    internal JournalEntry GetGoBackEntry();
    internal void GetGoForwardEntryIndex(Int32& index);
    internal bool IsNavigable(JournalEntry entry);
}
public class System.Windows.Navigation.JournalEntry : DependencyObject {
    public static DependencyProperty NameProperty;
    public static DependencyProperty KeepAliveProperty;
    public Uri Source { get; public set; }
    public CustomContentState CustomContentState { get; internal set; }
    public string Name { get; public set; }
    internal JournalEntryGroupState JEGroupState { get; internal set; }
    internal int Id { get; internal set; }
    internal Guid NavigationServiceId { get; }
    internal JournalEntryType EntryType { get; internal set; }
    internal UInt32 ContentId { get; }
    internal CustomJournalStateInternal RootViewerState { get; internal set; }
    internal JournalEntry(JournalEntryGroupState jeGroupState, Uri uri);
    protected JournalEntry(SerializationInfo info, StreamingContext context);
    private static JournalEntry();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static string GetName(DependencyObject dependencyObject);
    public static void SetName(DependencyObject dependencyObject, string name);
    public static bool GetKeepAlive(DependencyObject dependencyObject);
    public static void SetKeepAlive(DependencyObject dependencyObject, bool keepAlive);
    public Uri get_Source();
    public void set_Source(Uri value);
    public CustomContentState get_CustomContentState();
    internal void set_CustomContentState(CustomContentState value);
    public string get_Name();
    public void set_Name(string value);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal virtual void SaveState(object contentObject);
    internal virtual void RestoreState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
    internal static string GetDisplayName(Uri uri, Uri siteOfOrigin);
    internal JournalEntryGroupState get_JEGroupState();
    internal void set_JEGroupState(JournalEntryGroupState value);
    internal int get_Id();
    internal void set_Id(int value);
    internal Guid get_NavigationServiceId();
    internal JournalEntryType get_EntryType();
    internal void set_EntryType(JournalEntryType value);
    internal bool IsNavigable();
    internal UInt32 get_ContentId();
    internal CustomJournalStateInternal get_RootViewerState();
    internal void set_RootViewerState(CustomJournalStateInternal value);
}
internal class System.Windows.Navigation.JournalEntryBackStack : JournalEntryStack {
    public JournalEntryBackStack(Journal journal);
    public virtual IEnumerator GetEnumerator();
}
internal class System.Windows.Navigation.JournalEntryFilter : MulticastDelegate {
    public JournalEntryFilter(object object, IntPtr method);
    public virtual bool Invoke(JournalEntry entry);
    public virtual IAsyncResult BeginInvoke(JournalEntry entry, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.JournalEntryForwardStack : JournalEntryStack {
    public JournalEntryForwardStack(Journal journal);
    public virtual IEnumerator GetEnumerator();
}
public class System.Windows.Navigation.JournalEntryListConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public enum System.Windows.Navigation.JournalEntryPosition : Enum {
    public int value__;
    public static JournalEntryPosition Back;
    public static JournalEntryPosition Current;
    public static JournalEntryPosition Forward;
}
internal abstract class System.Windows.Navigation.JournalEntryStack : object {
    protected JournalEntryFilter _filter;
    protected Journal _journal;
    internal JournalEntryFilter Filter { get; internal set; }
    internal JournalEntryStack(Journal journal);
    internal void OnCollectionChanged();
    internal JournalEntryFilter get_Filter();
    internal void set_Filter(JournalEntryFilter value);
    internal IEnumerable GetLimitedJournalEntryStackEnumerable();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual IEnumerator GetEnumerator();
}
internal class System.Windows.Navigation.JournalEntryStackEnumerator : object {
    public object Current { get; }
    public JournalEntryStackEnumerator(Journal journal, int start, int delta, JournalEntryFilter filter);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    protected void VerifyUnchanged();
}
public class System.Windows.Navigation.JournalEntryUnifiedViewConverter : object {
    public static DependencyProperty JournalEntryPositionProperty;
    private static JournalEntryUnifiedViewConverter();
    public static JournalEntryPosition GetJournalEntryPosition(DependencyObject element);
    public static void SetJournalEntryPosition(DependencyObject element, JournalEntryPosition position);
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public enum System.Windows.Navigation.JournalOwnership : Enum {
    public int value__;
    public static JournalOwnership Automatic;
    public static JournalOwnership OwnsJournal;
    public static JournalOwnership UsesParentJournal;
}
internal class System.Windows.Navigation.LimitedJournalEntryStackEnumerable : object {
    internal LimitedJournalEntryStackEnumerable(IEnumerable ieble);
    public sealed virtual IEnumerator GetEnumerator();
    internal void PropogateCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.Navigation.LimitedJournalEntryStackEnumerator : object {
    public object Current { get; }
    internal LimitedJournalEntryStackEnumerator(IEnumerable ieble, UInt32 viewLimit);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
}
public class System.Windows.Navigation.LoadCompletedEventHandler : MulticastDelegate {
    public LoadCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigatedEventHandler : MulticastDelegate {
    public NavigatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.NavigateInfo : object {
    internal Uri Source { get; }
    internal NavigationMode NavigationMode { get; }
    internal JournalEntry JournalEntry { get; }
    internal bool IsConsistent { get; }
    internal NavigateInfo(Uri source);
    internal NavigateInfo(Uri source, NavigationMode navigationMode);
    internal NavigateInfo(Uri source, NavigationMode navigationMode, JournalEntry journalEntry);
    internal Uri get_Source();
    internal NavigationMode get_NavigationMode();
    internal JournalEntry get_JournalEntry();
    internal bool get_IsConsistent();
}
internal class System.Windows.Navigation.NavigateQueueItem : object {
    internal Uri Source { get; }
    internal object NavState { get; }
    internal NavigateQueueItem(Uri source, object content, NavigationMode mode, object navState, NavigationService nc);
    internal void PostNavigation();
    internal void Stop();
    internal Uri get_Source();
    internal object get_NavState();
}
public class System.Windows.Navigation.NavigatingCancelEventArgs : CancelEventArgs {
    public Uri Uri { get; }
    public object Content { get; }
    public CustomContentState TargetContentState { get; }
    public CustomContentState ContentStateToSave { get; public set; }
    public object ExtraData { get; }
    public NavigationMode NavigationMode { get; }
    public WebRequest WebRequest { get; }
    public bool IsNavigationInitiator { get; }
    public object Navigator { get; }
    internal NavigatingCancelEventArgs(Uri uri, object content, CustomContentState customContentState, object extraData, NavigationMode navigationMode, WebRequest request, object Navigator, bool isNavInitiator);
    public Uri get_Uri();
    public object get_Content();
    public CustomContentState get_TargetContentState();
    public void set_ContentStateToSave(CustomContentState value);
    public CustomContentState get_ContentStateToSave();
    public object get_ExtraData();
    public NavigationMode get_NavigationMode();
    public WebRequest get_WebRequest();
    public bool get_IsNavigationInitiator();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigatingCancelEventHandler : MulticastDelegate {
    public NavigatingCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigatingCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigatingCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigationEventArgs : EventArgs {
    public Uri Uri { get; }
    public object Content { get; }
    public bool IsNavigationInitiator { get; }
    public object ExtraData { get; }
    public WebResponse WebResponse { get; }
    public object Navigator { get; }
    internal NavigationEventArgs(Uri uri, object content, object extraData, WebResponse response, object Navigator, bool isNavigationInitiator);
    public Uri get_Uri();
    public object get_Content();
    public bool get_IsNavigationInitiator();
    public object get_ExtraData();
    public WebResponse get_WebResponse();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigationFailedEventArgs : EventArgs {
    public Uri Uri { get; }
    public object ExtraData { get; }
    public object Navigator { get; }
    public WebRequest WebRequest { get; }
    public WebResponse WebResponse { get; }
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal NavigationFailedEventArgs(Uri uri, object extraData, object navigator, WebRequest request, WebResponse response, Exception e);
    public Uri get_Uri();
    public object get_ExtraData();
    public object get_Navigator();
    public WebRequest get_WebRequest();
    public WebResponse get_WebResponse();
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Navigation.NavigationFailedEventHandler : MulticastDelegate {
    public NavigationFailedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationFailedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationFailedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Navigation.NavigationMode : Enum {
    public byte value__;
    public static NavigationMode New;
    public static NavigationMode Back;
    public static NavigationMode Forward;
    public static NavigationMode Refresh;
}
public class System.Windows.Navigation.NavigationProgressEventArgs : EventArgs {
    public Uri Uri { get; }
    public long BytesRead { get; }
    public long MaxBytes { get; }
    public object Navigator { get; }
    internal NavigationProgressEventArgs(Uri uri, long bytesRead, long maxBytes, object Navigator);
    public Uri get_Uri();
    public long get_BytesRead();
    public long get_MaxBytes();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigationProgressEventHandler : MulticastDelegate {
    public NavigationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigationService : object {
    internal static DependencyProperty NavigationServiceProperty;
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    internal Application Application { get; }
    private bool AllowWindowNavigation { get; internal set; }
    internal long BytesRead { get; internal set; }
    internal long MaxBytes { get; internal set; }
    internal UInt32 ContentId { get; }
    internal Guid GuidId { get; internal set; }
    internal NavigationService ParentNavigationService { get; }
    internal bool CanReloadFromUri { get; }
    internal ArrayList ChildNavigationServices { get; }
    internal INavigator INavigatorHost { get; internal set; }
    internal NavigationStatus NavStatus { get; internal set; }
    internal ArrayList PendingNavigationList { get; }
    internal WebBrowser WebBrowser { get; }
    internal bool IsDisposed { get; }
    internal NavigationService(INavigator nav);
    private static NavigationService();
    internal static INavigatorBase FindTargetInApplication(string targetName);
    internal void InvalidateJournalNavigationScope();
    internal void OnParentNavigationServiceChanged();
    internal void AddChild(NavigationService ncChild);
    internal void RemoveChild(NavigationService ncChild);
    internal NavigationService FindTarget(Guid navigationServiceId);
    internal INavigatorBase FindTarget(string name);
    internal bool IsContentKeepAlive();
    internal void VisualTreeAvailable(Visual v);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnContentReady(ContentType contentType, object bp, Uri bpu, object navState);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnNavigationProgress(Uri sourceUri, long bytesRead, long maxBytes);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnStreamClosed(Uri sourceUri);
    public static NavigationService GetNavigationService(DependencyObject dependencyObject);
    public Uri get_Source();
    public void set_Source(Uri value);
    public Uri get_CurrentSource();
    public object get_Content();
    public void set_Content(object value);
    public void AddBackEntry(CustomContentState state);
    public JournalEntry RemoveBackEntry();
    public bool Navigate(Uri source);
    public bool Navigate(object root);
    public bool Navigate(Uri source, object navigationState);
    public bool Navigate(Uri source, object navigationState, bool sandboxExternalContent);
    internal bool Navigate(Uri source, object navigationState, bool sandboxExternalContent, bool navigateOnSourceChanged);
    public bool Navigate(object root, object navigationState);
    public bool get_CanGoForward();
    public bool get_CanGoBack();
    public void GoForward();
    public void GoBack();
    public void StopLoading();
    public void Refresh();
    [CompilerGeneratedAttribute]
public void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationFailed(NavigationFailedEventHandler value);
    public void add_Navigating(NavigatingCancelEventHandler value);
    public void remove_Navigating(NavigatingCancelEventHandler value);
    public void add_Navigated(NavigatedEventHandler value);
    public void remove_Navigated(NavigatedEventHandler value);
    public void add_NavigationProgress(NavigationProgressEventHandler value);
    public void remove_NavigationProgress(NavigationProgressEventHandler value);
    public void add_LoadCompleted(LoadCompletedEventHandler value);
    public void remove_LoadCompleted(LoadCompletedEventHandler value);
    public void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    public void add_NavigationStopped(NavigationStoppedEventHandler value);
    public void remove_NavigationStopped(NavigationStoppedEventHandler value);
    internal void DoNavigate(Uri source, NavigationMode f, object navState);
    internal void DoNavigate(object bp, NavigationMode navFlags, object navState);
    internal JournalEntry MakeJournalEntry(JournalReason journalReason);
    internal void RequestCustomContentStateOnAppShutdown();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void CallUpdateTravelLog(bool addNewEntry);
    internal Application get_Application();
    private bool get_AllowWindowNavigation();
    internal void set_AllowWindowNavigation(bool value);
    internal long get_BytesRead();
    internal void set_BytesRead(long value);
    internal long get_MaxBytes();
    internal void set_MaxBytes(long value);
    internal UInt32 get_ContentId();
    internal Guid get_GuidId();
    internal void set_GuidId(Guid value);
    internal NavigationService get_ParentNavigationService();
    internal bool get_CanReloadFromUri();
    internal ArrayList get_ChildNavigationServices();
    internal INavigator get_INavigatorHost();
    internal void set_INavigatorHost(INavigator value);
    internal NavigationStatus get_NavStatus();
    internal void set_NavStatus(NavigationStatus value);
    internal ArrayList get_PendingNavigationList();
    internal WebBrowser get_WebBrowser();
    internal bool get_IsDisposed();
    internal void Dispose();
    internal static bool IsPageFunction(object content);
    [CompilerGeneratedAttribute]
internal void add_BPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_PreBPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PreBPReady(BPReadyEventHandler value);
}
public class System.Windows.Navigation.NavigationStoppedEventHandler : MulticastDelegate {
    public NavigationStoppedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Navigation.NavigationUIVisibility : Enum {
    public int value__;
    public static NavigationUIVisibility Automatic;
    public static NavigationUIVisibility Visible;
    public static NavigationUIVisibility Hidden;
}
[ContentPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Navigation.NavigationWindow : Window {
    public static DependencyProperty SandboxExternalContentProperty;
    public static DependencyProperty ShowsNavigationUIProperty;
    public static DependencyProperty BackStackProperty;
    public static DependencyProperty ForwardStackProperty;
    public static DependencyProperty CanGoBackProperty;
    public static DependencyProperty CanGoForwardProperty;
    public static DependencyProperty SourceProperty;
    public bool SandboxExternalContent { get; public set; }
    private NavigationService MS.Internal.AppModel.IDownloader.Downloader { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public NavigationService NavigationService { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    public bool ShowsNavigationUI { get; public set; }
    [DefaultValueAttribute("")]
public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    private NavigationService MS.Internal.AppModel.IJournalNavigationScopeHost.NavigationService { get; }
    internal Journal Journal { get; }
    internal JournalNavigationScope JournalNavigationScope { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static NavigationWindow();
    [SecurityCriticalAttribute]
internal NavigationWindow(bool inRbw);
    public bool get_SandboxExternalContent();
    public void set_SandboxExternalContent(bool value);
    private sealed virtual override NavigationService MS.Internal.AppModel.IDownloader.get_Downloader();
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    public sealed virtual void GoForward();
    public sealed virtual void GoBack();
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    [SecurityCriticalAttribute]
public virtual void OnApplyTemplate();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    public NavigationService get_NavigationService();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    public bool get_ShowsNavigationUI();
    public void set_ShowsNavigationUI(bool value);
    private sealed virtual override void MS.Internal.AppModel.INavigatorImpl.OnSourceUpdatedFromNavService(bool journalOrCancel);
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void AddChild(object value);
    protected virtual void AddText(string text);
    protected virtual void OnClosed(EventArgs args);
    internal virtual void OnPreApplyTemplate();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.VerifyContextAndObjectState();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.OnJournalAvailable();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoBackOverride();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoForwardOverride();
    private sealed virtual override NavigationService MS.Internal.AppModel.IJournalNavigationScopeHost.get_NavigationService();
    private sealed virtual override Visual MS.Internal.AppModel.INavigatorImpl.FindRootViewer();
    internal Journal get_Journal();
    internal JournalNavigationScope get_JournalNavigationScope();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Navigation.PageFunction`1 : PageFunctionBase {
    protected virtual void OnReturn(ReturnEventArgs`1<T> e);
    internal void RaiseTypedReturnEvent(PageFunctionBase b, RaiseTypedEventArgs args);
    public void add_Return(ReturnEventHandler`1<T> value);
    public void remove_Return(ReturnEventHandler`1<T> value);
}
public abstract class System.Windows.Navigation.PageFunctionBase : Page {
    public bool RemoveFromJournal { get; public set; }
    internal Guid PageFunctionId { get; internal set; }
    internal Guid ParentPageFunctionId { get; internal set; }
    internal Delegate _Return { get; }
    internal bool _Resume { get; internal set; }
    internal ReturnEventSaver _Saver { get; internal set; }
    internal FinishEventHandler FinishHandler { get; internal set; }
    public bool get_RemoveFromJournal();
    public void set_RemoveFromJournal(bool value);
    protected virtual void Start();
    internal void CallStart();
    internal void _OnReturnUnTyped(object o);
    internal void _AddEventHandler(Delegate d);
    internal void _RemoveEventHandler(Delegate d);
    internal void _DetachEvents();
    internal void _OnFinish(object returnEventArgs);
    internal Guid get_PageFunctionId();
    internal void set_PageFunctionId(Guid value);
    internal Guid get_ParentPageFunctionId();
    internal void set_ParentPageFunctionId(Guid value);
    internal Delegate get__Return();
    internal bool get__Resume();
    internal void set__Resume(bool value);
    internal ReturnEventSaver get__Saver();
    internal void set__Saver(ReturnEventSaver value);
    internal FinishEventHandler get_FinishHandler();
    internal void set_FinishHandler(FinishEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_RaiseTypedEvent(EventToRaiseTypedEvent value);
    [CompilerGeneratedAttribute]
internal void remove_RaiseTypedEvent(EventToRaiseTypedEvent value);
}
internal class System.Windows.Navigation.PageFunctionReturnInfo : NavigateInfo {
    internal object ReturnEventArgs { get; }
    internal PageFunctionBase FinishingChildPageFunction { get; }
    internal PageFunctionReturnInfo(PageFunctionBase finishingChildPageFunction, Uri source, NavigationMode navigationMode, JournalEntry journalEntry, object returnEventArgs);
    internal object get_ReturnEventArgs();
    internal PageFunctionBase get_FinishingChildPageFunction();
}
internal class System.Windows.Navigation.RaiseTypedEventArgs : EventArgs {
    internal Delegate D;
    internal object O;
    internal RaiseTypedEventArgs(Delegate d, object o);
}
public class System.Windows.Navigation.RequestNavigateEventArgs : RoutedEventArgs {
    public Uri Uri { get; }
    public string Target { get; }
    public RequestNavigateEventArgs(Uri uri, string target);
    public Uri get_Uri();
    public string get_Target();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Navigation.RequestNavigateEventHandler : MulticastDelegate {
    public RequestNavigateEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RequestNavigateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestNavigateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.RequestState : object {
    internal WebRequest Request { get; }
    internal Uri Source { get; }
    internal object NavState { get; }
    internal Dispatcher CallbackDispatcher { get; }
    internal RequestState(WebRequest request, Uri source, object navState, Dispatcher callbackDispatcher);
    internal WebRequest get_Request();
    internal Uri get_Source();
    internal object get_NavState();
    internal Dispatcher get_CallbackDispatcher();
}
public class System.Windows.Navigation.ReturnEventArgs`1 : EventArgs {
    public T Result { get; public set; }
    public ReturnEventArgs`1(T result);
    public T get_Result();
    public void set_Result(T value);
}
public class System.Windows.Navigation.ReturnEventHandler`1 : MulticastDelegate {
    public ReturnEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, ReturnEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, ReturnEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.UnifiedJournalEntryStackEnumerable : object {
    internal UnifiedJournalEntryStackEnumerable(LimitedJournalEntryStackEnumerable backStack, LimitedJournalEntryStackEnumerable forwardStack);
    public sealed virtual IEnumerator GetEnumerator();
    internal void StacksChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.NestedBamlLoadInfo : object {
    internal Uri BamlUri { get; internal set; }
    internal Stream BamlStream { get; }
    internal bool SkipJournaledProperties { get; }
    internal NestedBamlLoadInfo(Uri uri, Stream stream, bool bSkipJournalProperty);
    internal Uri get_BamlUri();
    internal void set_BamlUri(Uri value);
    internal Stream get_BamlStream();
    internal bool get_SkipJournaledProperties();
}
public class System.Windows.NullableBoolConverter : NullableConverter {
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
public enum System.Windows.PowerLineStatus : Enum {
    public int value__;
    public static PowerLineStatus Offline;
    public static PowerLineStatus Online;
    public static PowerLineStatus Unknown;
}
[TypeConverterAttribute("System.Windows.PropertyPathConverter")]
public class System.Windows.PropertyPath : object {
    public string Path { get; public set; }
    public Collection`1<object> PathParameters { get; }
    internal int Length { get; }
    internal PropertyPathStatus Status { get; }
    internal string LastError { get; }
    internal object LastItem { get; }
    internal object LastAccessor { get; }
    internal Object[] LastIndexerArguments { get; }
    internal bool StartsWithStaticProperty { get; }
    internal SourceValueInfo[] SVI { get; }
    public PropertyPath(string path, Object[] pathParameters);
    public PropertyPath(object parameter);
    internal PropertyPath(string path, ITypeDescriptorContext typeDescriptorContext);
    private static PropertyPath();
    public string get_Path();
    public void set_Path(string value);
    public Collection`1<object> get_PathParameters();
    internal int get_Length();
    internal PropertyPathStatus get_Status();
    internal string get_LastError();
    internal object get_LastItem();
    internal object get_LastAccessor();
    internal Object[] get_LastIndexerArguments();
    internal bool get_StartsWithStaticProperty();
    internal static bool IsStaticProperty(object accessor);
    internal static void DowncastAccessor(object accessor, DependencyProperty& dp, PropertyInfo& pi, PropertyDescriptor& pd, DynamicObjectAccessor& doa);
    internal IDisposable SetContext(object rootItem);
    internal object GetItem(int k);
    internal object GetAccessor(int k);
    internal Object[] GetIndexerArguments(int k);
    internal object GetValue();
    internal int ComputeUnresolvedAttachedPropertiesInPath();
    internal SourceValueInfo[] get_SVI();
    internal object ResolvePropertyName(int level, object item, Type ownerType, object context);
    internal IndexerParameterInfo[] ResolveIndexerParams(int level, object context);
    internal void ReplaceIndexerByProperty(int level, string name);
    internal static bool IsPropertyReference(string name);
    internal static bool IsParameterIndex(string name, Int32& index);
}
public class System.Windows.PropertyPathConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal enum System.Windows.PropertyPathStatus : Enum {
    public byte value__;
    public static PropertyPathStatus Inactive;
    public static PropertyPathStatus Active;
    public static PropertyPathStatus PathError;
    public static PropertyPathStatus AsyncRequestPending;
}
internal class System.Windows.PropertyValue : ValueType {
    internal PropertyValueType ValueType;
    internal TriggerCondition[] Conditions;
    internal string ChildName;
    internal DependencyProperty Property;
    internal object ValueInternal;
    internal object Value { get; }
    internal object get_Value();
}
internal enum System.Windows.PropertyValueType : Enum {
    public int value__;
    public static PropertyValueType Set;
    public static PropertyValueType Trigger;
    public static PropertyValueType PropertyTriggerResource;
    public static PropertyValueType DataTrigger;
    public static PropertyValueType DataTriggerResource;
    public static PropertyValueType TemplateBinding;
    public static PropertyValueType Resource;
}
internal class System.Windows.ReadOnlyFrameworkPropertyMetadata : FrameworkPropertyMetadata {
    internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    public ReadOnlyFrameworkPropertyMetadata(object defaultValue, GetReadOnlyValueCallback getValueCallback);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
}
public enum System.Windows.ReasonSessionEnding : Enum {
    public byte value__;
    public static ReasonSessionEnding Logoff;
    public static ReasonSessionEnding Shutdown;
}
public class System.Windows.RequestBringIntoViewEventArgs : RoutedEventArgs {
    public DependencyObject TargetObject { get; }
    public Rect TargetRect { get; }
    internal RequestBringIntoViewEventArgs(DependencyObject target, Rect targetRect);
    public DependencyObject get_TargetObject();
    public Rect get_TargetRect();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.RequestBringIntoViewEventHandler : MulticastDelegate {
    public RequestBringIntoViewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RequestBringIntoViewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestBringIntoViewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.ResizeMode : Enum {
    public int value__;
    public static ResizeMode NoResize;
    public static ResizeMode CanMinimize;
    public static ResizeMode CanResize;
    public static ResizeMode CanResizeWithGrip;
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
[AmbientAttribute]
[UsableDuringInitializationAttribute("True")]
public class System.Windows.ResourceDictionary : object {
    internal bool IsSourcedFromThemeDictionary;
    public Collection`1<ResourceDictionary> MergedDictionaries { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; internal set; }
    [DefaultValueAttribute("False")]
public bool InvalidatesImplicitDataTemplateResources { get; public set; }
    public object Item { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DeferrableContent DeferrableContent { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal WeakReferenceList FrameworkElementOwners { get; }
    internal WeakReferenceList FrameworkContentElementOwners { get; }
    internal WeakReferenceList ApplicationOwners { get; }
    internal WeakReferenceList DeferredResourceReferences { get; }
    internal bool HasImplicitStyles { get; internal set; }
    internal bool HasImplicitDataTemplates { get; internal set; }
    internal bool CanBeAccessedAcrossThreads { get; internal set; }
    private static ResourceDictionary();
    public void CopyTo(DictionaryEntry[] array, int arrayIndex);
    public Collection`1<ResourceDictionary> get_MergedDictionaries();
    public Uri get_Source();
    public void set_Source(Uri value);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    public bool get_InvalidatesImplicitDataTemplateResources();
    public void set_InvalidatesImplicitDataTemplateResources(bool value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public DeferrableContent get_DeferrableContent();
    public void set_DeferrableContent(DeferrableContent value);
    internal object GetValue(object key, Boolean& canCache);
    internal Type GetValueType(object key, Boolean& found);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    protected virtual void OnGettingValue(object key, Object& value, Boolean& canCache);
    internal object Lookup(object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, bool canCacheAsThemeResource);
    internal void AddOwner(DispatcherObject owner);
    internal void RemoveOwner(DispatcherObject owner);
    internal bool ContainsOwner(DispatcherObject owner);
    internal object FetchResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, Boolean& canCache);
    internal void RemoveParentOwners(ResourceDictionary mergedDictionary);
    internal WeakReferenceList get_FrameworkElementOwners();
    internal WeakReferenceList get_FrameworkContentElementOwners();
    internal WeakReferenceList get_ApplicationOwners();
    internal WeakReferenceList get_DeferredResourceReferences();
    internal bool get_HasImplicitStyles();
    internal void set_HasImplicitStyles(bool value);
    internal bool get_HasImplicitDataTemplates();
    internal void set_HasImplicitDataTemplates(bool value);
    internal bool get_CanBeAccessedAcrossThreads();
    internal void set_CanBeAccessedAcrossThreads(bool value);
}
internal class System.Windows.ResourceDictionaryCollection : ObservableCollection`1<ResourceDictionary> {
    internal ResourceDictionaryCollection(ResourceDictionary owner);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, ResourceDictionary item);
    protected virtual void SetItem(int index, ResourceDictionary item);
}
public enum System.Windows.ResourceDictionaryLocation : Enum {
    public int value__;
    public static ResourceDictionaryLocation None;
    public static ResourceDictionaryLocation SourceAssembly;
    public static ResourceDictionaryLocation ExternalAssembly;
}
[MarkupExtensionReturnTypeAttribute("System.Windows.ResourceKey")]
public abstract class System.Windows.ResourceKey : MarkupExtension {
    public Assembly Assembly { get; }
    public abstract virtual Assembly get_Assembly();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[TypeConverterAttribute("System.Windows.Markup.ResourceReferenceExpressionConverter")]
internal class System.Windows.ResourceReferenceExpression : Expression {
    public object ResourceKey { get; }
    public ResourceReferenceExpression(object resourceKey);
    internal virtual DependencySource[] GetSources();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    internal object GetRawValue(DependencyObject d, Object& source, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    public object get_ResourceKey();
    internal void InvalidateExpressionValue(object sender, EventArgs e);
    internal void OnDeferredResourceInflated(DeferredResourceReference deferredResourceReference);
}
public class System.Windows.ResourceReferenceKeyNotFoundException : InvalidOperationException {
    public object Key { get; }
    public ResourceReferenceKeyNotFoundException(string message, object resourceKey);
    protected ResourceReferenceKeyNotFoundException(SerializationInfo info, StreamingContext context);
    public object get_Key();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Windows.Resources.ContentTypes : object {
    public static string XamlContentType;
}
public class System.Windows.Resources.StreamResourceInfo : object {
    public string ContentType { get; }
    public Stream Stream { get; }
    public StreamResourceInfo(Stream stream, string contentType);
    public string get_ContentType();
    public Stream get_Stream();
}
internal class System.Windows.ResourcesChangedEventArgs : EventArgs {
    internal ResourcesChangeInfo Info { get; }
    internal ResourcesChangedEventArgs(ResourcesChangeInfo info);
    internal ResourcesChangeInfo get_Info();
}
internal class System.Windows.ResourcesChangeInfo : ValueType {
    private List`1<ResourceDictionary> _oldDictionaries;
    private List`1<ResourceDictionary> _newDictionaries;
    private object _key;
    private DependencyObject _container;
    private PrivateFlags _flags;
    internal static ResourcesChangeInfo ThemeChangeInfo { get; }
    internal static ResourcesChangeInfo TreeChangeInfo { get; }
    internal static ResourcesChangeInfo SysColorsOrSettingsChangeInfo { get; }
    internal static ResourcesChangeInfo CatastrophicDictionaryChangeInfo { get; }
    internal bool IsThemeChange { get; internal set; }
    internal bool IsTreeChange { get; internal set; }
    internal bool IsStyleResourcesChange { get; internal set; }
    internal bool IsTemplateResourcesChange { get; internal set; }
    internal bool IsSysColorsOrSettingsChange { get; internal set; }
    internal bool IsCatastrophicDictionaryChange { get; internal set; }
    internal bool IsImplicitDataTemplateChange { get; internal set; }
    internal bool IsResourceAddOperation { get; }
    internal DependencyObject Container { get; }
    internal ResourcesChangeInfo(object key);
    internal ResourcesChangeInfo(ResourceDictionary oldDictionary, ResourceDictionary newDictionary);
    internal ResourcesChangeInfo(List`1<ResourceDictionary> oldDictionaries, List`1<ResourceDictionary> newDictionaries, bool isStyleResourcesChange, bool isTemplateResourcesChange, DependencyObject container);
    internal static ResourcesChangeInfo get_ThemeChangeInfo();
    internal static ResourcesChangeInfo get_TreeChangeInfo();
    internal static ResourcesChangeInfo get_SysColorsOrSettingsChangeInfo();
    internal static ResourcesChangeInfo get_CatastrophicDictionaryChangeInfo();
    internal bool get_IsThemeChange();
    internal void set_IsThemeChange(bool value);
    internal bool get_IsTreeChange();
    internal void set_IsTreeChange(bool value);
    internal bool get_IsStyleResourcesChange();
    internal void set_IsStyleResourcesChange(bool value);
    internal bool get_IsTemplateResourcesChange();
    internal void set_IsTemplateResourcesChange(bool value);
    internal bool get_IsSysColorsOrSettingsChange();
    internal void set_IsSysColorsOrSettingsChange(bool value);
    internal bool get_IsCatastrophicDictionaryChange();
    internal void set_IsCatastrophicDictionaryChange(bool value);
    internal bool get_IsImplicitDataTemplateChange();
    internal void set_IsImplicitDataTemplateChange(bool value);
    internal bool get_IsResourceAddOperation();
    internal DependencyObject get_Container();
    internal bool Contains(object key, bool isImplicitStyleKey);
    internal void SetIsImplicitDataTemplateChange();
}
public class System.Windows.RoutedPropertyChangedEventArgs`1 : RoutedEventArgs {
    public T OldValue { get; }
    public T NewValue { get; }
    public RoutedPropertyChangedEventArgs`1(T oldValue, T newValue);
    public RoutedPropertyChangedEventArgs`1(T oldValue, T newValue, RoutedEvent routedEvent);
    public T get_OldValue();
    public T get_NewValue();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.RoutedPropertyChangedEventHandler`1 : MulticastDelegate {
    public RoutedPropertyChangedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedPropertyChangedEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedPropertyChangedEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.SessionEndingCancelEventArgs : CancelEventArgs {
    public ReasonSessionEnding ReasonSessionEnding { get; }
    internal SessionEndingCancelEventArgs(ReasonSessionEnding reasonSessionEnding);
    public ReasonSessionEnding get_ReasonSessionEnding();
}
public class System.Windows.SessionEndingCancelEventHandler : MulticastDelegate {
    public SessionEndingCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndingCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndingCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
public class System.Windows.Setter : SetterBase {
    [AmbientAttribute]
[DefaultValueAttribute("")]
[LocalizabilityAttribute("0")]
public DependencyProperty Property { get; public set; }
    [DependsOnAttribute("Property")]
[DependsOnAttribute("TargetName")]
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    internal object ValueInternal { get; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public string TargetName { get; public set; }
    public Setter(DependencyProperty property, object value);
    public Setter(DependencyProperty property, object value, string targetName);
    internal virtual void Seal();
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public object get_Value();
    public void set_Value(object value);
    internal object get_ValueInternal();
    public string get_TargetName();
    public void set_TargetName(string value);
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[LocalizabilityAttribute("16")]
public abstract class System.Windows.SetterBase : object {
    public bool IsSealed { get; }
    public bool get_IsSealed();
    internal virtual void Seal();
    protected void CheckSealed();
}
public class System.Windows.SetterBaseCollection : Collection`1<SetterBase> {
    public bool IsSealed { get; }
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SetterBase item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SetterBase item);
    public bool get_IsSealed();
    internal void Seal();
}
internal class System.Windows.Shapes.BoxedMatrix : object {
    public Matrix Value;
    public BoxedMatrix(Matrix value);
}
public class System.Windows.Shapes.Ellipse : Shape {
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Ellipse();
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry get_DefiningGeometry();
    protected virtual void OnRender(DrawingContext drawingContext);
    internal virtual void CacheDefiningGeometry();
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Shapes.Line : Shape {
    public static DependencyProperty X1Property;
    public static DependencyProperty Y1Property;
    public static DependencyProperty X2Property;
    public static DependencyProperty Y2Property;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double X1 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Y1 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double X2 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Y2 { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Line();
    public double get_X1();
    public void set_X1(double value);
    public double get_Y1();
    public void set_Y1(double value);
    public double get_X2();
    public void set_X2(double value);
    public double get_Y2();
    public void set_Y2(double value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Path : Shape {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty DataProperty;
    public Geometry Data { get; public set; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Path();
    public Geometry get_Data();
    public void set_Data(Geometry value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Shapes.Polygon : Shape {
    public static DependencyProperty PointsProperty;
    public static DependencyProperty FillRuleProperty;
    public PointCollection Points { get; public set; }
    public FillRule FillRule { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Polygon();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Polyline : Shape {
    public static DependencyProperty PointsProperty;
    public static DependencyProperty FillRuleProperty;
    public PointCollection Points { get; public set; }
    public FillRule FillRule { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Polyline();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Rectangle : Shape {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double RadiusX { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double RadiusY { get; public set; }
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Rectangle();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry get_DefiningGeometry();
    protected virtual void OnRender(DrawingContext drawingContext);
    internal virtual void CacheDefiningGeometry();
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Shapes.Shape : FrameworkElement {
    public static DependencyProperty StretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FillProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StrokeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StrokeThicknessProperty;
    public static DependencyProperty StrokeStartLineCapProperty;
    public static DependencyProperty StrokeEndLineCapProperty;
    public static DependencyProperty StrokeDashCapProperty;
    public static DependencyProperty StrokeLineJoinProperty;
    public static DependencyProperty StrokeMiterLimitProperty;
    public static DependencyProperty StrokeDashOffsetProperty;
    public static DependencyProperty StrokeDashArrayProperty;
    public Stretch Stretch { get; public set; }
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    public Brush Fill { get; public set; }
    public Brush Stroke { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double StrokeThickness { get; public set; }
    public PenLineCap StrokeStartLineCap { get; public set; }
    public PenLineCap StrokeEndLineCap { get; public set; }
    public PenLineCap StrokeDashCap { get; public set; }
    public PenLineJoin StrokeLineJoin { get; public set; }
    public double StrokeMiterLimit { get; public set; }
    public double StrokeDashOffset { get; public set; }
    public DoubleCollection StrokeDashArray { get; public set; }
    protected Geometry DefiningGeometry { get; }
    internal bool IsPenNoOp { get; }
    private static Shape();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public Brush get_Stroke();
    public void set_Stroke(Brush value);
    public double get_StrokeThickness();
    public void set_StrokeThickness(double value);
    public PenLineCap get_StrokeStartLineCap();
    public void set_StrokeStartLineCap(PenLineCap value);
    public PenLineCap get_StrokeEndLineCap();
    public void set_StrokeEndLineCap(PenLineCap value);
    public PenLineCap get_StrokeDashCap();
    public void set_StrokeDashCap(PenLineCap value);
    public PenLineJoin get_StrokeLineJoin();
    public void set_StrokeLineJoin(PenLineJoin value);
    public double get_StrokeMiterLimit();
    public void set_StrokeMiterLimit(double value);
    public double get_StrokeDashOffset();
    public void set_StrokeDashOffset(double value);
    public DoubleCollection get_StrokeDashArray();
    public void set_StrokeDashArray(DoubleCollection value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected abstract virtual Geometry get_DefiningGeometry();
    internal bool SizeIsInvalidOrEmpty(Size size);
    internal bool get_IsPenNoOp();
    internal double GetStrokeThickness();
    internal Pen GetPen();
    internal static bool IsDoubleFiniteNonNegative(object o);
    internal static bool IsDoubleFinite(object o);
    internal static bool IsDoubleFiniteOrNaN(object o);
    internal virtual void CacheDefiningGeometry();
    internal Size GetStretchedRenderSize(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds);
    internal Size GetStretchedRenderSizeAndSetStretchMatrix(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds);
    internal void ResetRenderedGeometry();
    internal void GetStretchMetrics(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds, Double& xScale, Double& yScale, Double& dX, Double& dY, Size& stretchedSize);
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal void EnsureRenderedGeometry();
}
internal class System.Windows.SharedDp : object {
    internal DependencyProperty Dp;
    internal object Value;
    internal string ElementName;
    internal SharedDp(DependencyProperty dp, object value, string elementName);
}
public abstract class System.Windows.Shell.JumpItem : object {
    public string CustomCategory { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CustomCategory();
    [CompilerGeneratedAttribute]
public void set_CustomCategory(string value);
}
public enum System.Windows.Shell.JumpItemRejectionReason : Enum {
    public int value__;
    public static JumpItemRejectionReason None;
    public static JumpItemRejectionReason InvalidItem;
    public static JumpItemRejectionReason NoRegisteredHandler;
    public static JumpItemRejectionReason RemovedByUser;
}
public class System.Windows.Shell.JumpItemsRejectedEventArgs : EventArgs {
    public IList`1<JumpItem> RejectedItems { get; private set; }
    public IList`1<JumpItemRejectionReason> RejectionReasons { get; private set; }
    public JumpItemsRejectedEventArgs(IList`1<JumpItem> rejectedItems, IList`1<JumpItemRejectionReason> reasons);
    [CompilerGeneratedAttribute]
public IList`1<JumpItem> get_RejectedItems();
    [CompilerGeneratedAttribute]
private void set_RejectedItems(IList`1<JumpItem> value);
    [CompilerGeneratedAttribute]
public IList`1<JumpItemRejectionReason> get_RejectionReasons();
    [CompilerGeneratedAttribute]
private void set_RejectionReasons(IList`1<JumpItemRejectionReason> value);
}
public class System.Windows.Shell.JumpItemsRemovedEventArgs : EventArgs {
    public IList`1<JumpItem> RemovedItems { get; private set; }
    public JumpItemsRemovedEventArgs(IList`1<JumpItem> removedItems);
    [CompilerGeneratedAttribute]
public IList`1<JumpItem> get_RemovedItems();
    [CompilerGeneratedAttribute]
private void set_RemovedItems(IList`1<JumpItem> value);
}
[SecurityCriticalAttribute]
[ContentPropertyAttribute("JumpItems")]
public class System.Windows.Shell.JumpList : object {
    public bool ShowFrequentCategory { get; public set; }
    public bool ShowRecentCategory { get; public set; }
    public List`1<JumpItem> JumpItems { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static JumpList();
    [SecurityCriticalAttribute]
public JumpList(IEnumerable`1<JumpItem> items, bool showFrequent, bool showRecent);
    [SecurityCriticalAttribute]
public static void AddToRecentCategory(string itemPath);
    [SecurityCriticalAttribute]
public static void AddToRecentCategory(JumpPath jumpPath);
    [SecurityCriticalAttribute]
public static void AddToRecentCategory(JumpTask jumpTask);
    [SecuritySafeCriticalAttribute]
public static void SetJumpList(Application application, JumpList value);
    public static JumpList GetJumpList(Application application);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public bool get_ShowFrequentCategory();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public void set_ShowFrequentCategory(bool value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public bool get_ShowRecentCategory();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public void set_ShowRecentCategory(bool value);
    public List`1<JumpItem> get_JumpItems();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void BeginInit();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
public sealed virtual void EndInit();
    [SecurityCriticalAttribute]
public void Apply();
    [CompilerGeneratedAttribute]
public void add_JumpItemsRejected(EventHandler`1<JumpItemsRejectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_JumpItemsRejected(EventHandler`1<JumpItemsRejectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_JumpItemsRemovedByUser(EventHandler`1<JumpItemsRemovedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_JumpItemsRemovedByUser(EventHandler`1<JumpItemsRemovedEventArgs> value);
}
public class System.Windows.Shell.JumpPath : JumpItem {
    public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
public class System.Windows.Shell.JumpTask : JumpItem {
    public string Title { get; public set; }
    public string Description { get; public set; }
    public string ApplicationPath { get; public set; }
    public string Arguments { get; public set; }
    public string WorkingDirectory { get; public set; }
    public string IconResourcePath { get; public set; }
    public int IconResourceIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationPath();
    [CompilerGeneratedAttribute]
public void set_ApplicationPath(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_IconResourcePath();
    [CompilerGeneratedAttribute]
public void set_IconResourcePath(string value);
    [CompilerGeneratedAttribute]
public int get_IconResourceIndex();
    [CompilerGeneratedAttribute]
public void set_IconResourceIndex(int value);
}
[FlagsAttribute]
public enum System.Windows.Shell.NonClientFrameEdges : Enum {
    public int value__;
    public static NonClientFrameEdges None;
    public static NonClientFrameEdges Left;
    public static NonClientFrameEdges Top;
    public static NonClientFrameEdges Right;
    public static NonClientFrameEdges Bottom;
}
public enum System.Windows.Shell.ResizeGripDirection : Enum {
    public int value__;
    public static ResizeGripDirection None;
    public static ResizeGripDirection TopLeft;
    public static ResizeGripDirection Top;
    public static ResizeGripDirection TopRight;
    public static ResizeGripDirection Right;
    public static ResizeGripDirection BottomRight;
    public static ResizeGripDirection Bottom;
    public static ResizeGripDirection BottomLeft;
    public static ResizeGripDirection Left;
}
public class System.Windows.Shell.TaskbarItemInfo : Freezable {
    public static DependencyProperty ProgressStateProperty;
    public static DependencyProperty ProgressValueProperty;
    public static DependencyProperty OverlayProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty ThumbnailClipMarginProperty;
    public static DependencyProperty ThumbButtonInfosProperty;
    public TaskbarItemProgressState ProgressState { get; public set; }
    public double ProgressValue { get; public set; }
    public ImageSource Overlay { get; public set; }
    public string Description { get; public set; }
    public Thickness ThumbnailClipMargin { get; public set; }
    public ThumbButtonInfoCollection ThumbButtonInfos { get; public set; }
    private static TaskbarItemInfo();
    protected virtual Freezable CreateInstanceCore();
    public TaskbarItemProgressState get_ProgressState();
    public void set_ProgressState(TaskbarItemProgressState value);
    public double get_ProgressValue();
    public void set_ProgressValue(double value);
    public ImageSource get_Overlay();
    public void set_Overlay(ImageSource value);
    public string get_Description();
    public void set_Description(string value);
    public Thickness get_ThumbnailClipMargin();
    public void set_ThumbnailClipMargin(Thickness value);
    public ThumbButtonInfoCollection get_ThumbButtonInfos();
    public void set_ThumbButtonInfos(ThumbButtonInfoCollection value);
    [CompilerGeneratedAttribute]
internal void add_PropertyChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChanged(DependencyPropertyChangedEventHandler value);
}
public enum System.Windows.Shell.TaskbarItemProgressState : Enum {
    public int value__;
    public static TaskbarItemProgressState None;
    public static TaskbarItemProgressState Indeterminate;
    public static TaskbarItemProgressState Normal;
    public static TaskbarItemProgressState Error;
    public static TaskbarItemProgressState Paused;
}
public class System.Windows.Shell.ThumbButtonInfo : Freezable {
    public static DependencyProperty VisibilityProperty;
    public static DependencyProperty DismissWhenClickedProperty;
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty IsBackgroundVisibleProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsInteractiveProperty;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    public Visibility Visibility { get; public set; }
    public bool DismissWhenClicked { get; public set; }
    public ImageSource ImageSource { get; public set; }
    public bool IsBackgroundVisible { get; public set; }
    public string Description { get; public set; }
    public bool IsEnabled { get; public set; }
    public bool IsInteractive { get; public set; }
    public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    private static ThumbButtonInfo();
    protected virtual Freezable CreateInstanceCore();
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public bool get_DismissWhenClicked();
    public void set_DismissWhenClicked(bool value);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public bool get_IsBackgroundVisible();
    public void set_IsBackgroundVisible(bool value);
    public string get_Description();
    public void set_Description(string value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsInteractive();
    public void set_IsInteractive(bool value);
    [CompilerGeneratedAttribute]
public void add_Click(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Click(EventHandler value);
    internal void InvokeClick();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
}
public class System.Windows.Shell.ThumbButtonInfoCollection : FreezableCollection`1<ThumbButtonInfo> {
    internal static ThumbButtonInfoCollection Empty { get; }
    protected virtual Freezable CreateInstanceCore();
    internal static ThumbButtonInfoCollection get_Empty();
}
public class System.Windows.Shell.WindowChrome : Freezable {
    public static DependencyProperty WindowChromeProperty;
    public static DependencyProperty IsHitTestVisibleInChromeProperty;
    public static DependencyProperty ResizeGripDirectionProperty;
    public static DependencyProperty CaptionHeightProperty;
    public static DependencyProperty ResizeBorderThicknessProperty;
    public static DependencyProperty GlassFrameThicknessProperty;
    public static DependencyProperty UseAeroCaptionButtonsProperty;
    public static DependencyProperty CornerRadiusProperty;
    public static DependencyProperty NonClientFrameEdgesProperty;
    public static Thickness GlassFrameCompleteThickness { get; }
    public double CaptionHeight { get; public set; }
    public Thickness ResizeBorderThickness { get; public set; }
    public Thickness GlassFrameThickness { get; public set; }
    public bool UseAeroCaptionButtons { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public NonClientFrameEdges NonClientFrameEdges { get; public set; }
    private static WindowChrome();
    public static Thickness get_GlassFrameCompleteThickness();
    public static WindowChrome GetWindowChrome(Window window);
    public static void SetWindowChrome(Window window, WindowChrome chrome);
    public static bool GetIsHitTestVisibleInChrome(IInputElement inputElement);
    public static void SetIsHitTestVisibleInChrome(IInputElement inputElement, bool hitTestVisible);
    public static ResizeGripDirection GetResizeGripDirection(IInputElement inputElement);
    public static void SetResizeGripDirection(IInputElement inputElement, ResizeGripDirection direction);
    public double get_CaptionHeight();
    public void set_CaptionHeight(double value);
    public Thickness get_ResizeBorderThickness();
    public void set_ResizeBorderThickness(Thickness value);
    public Thickness get_GlassFrameThickness();
    public void set_GlassFrameThickness(Thickness value);
    public bool get_UseAeroCaptionButtons();
    public void set_UseAeroCaptionButtons(bool value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    public NonClientFrameEdges get_NonClientFrameEdges();
    public void set_NonClientFrameEdges(NonClientFrameEdges value);
    protected virtual Freezable CreateInstanceCore();
    [CompilerGeneratedAttribute]
internal void add_PropertyChangedThatRequiresRepaint(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChangedThatRequiresRepaint(EventHandler value);
}
internal class System.Windows.Shell.WindowChromeWorker : DependencyObject {
    public static DependencyProperty WindowChromeWorkerProperty;
    [SecurityCriticalAttribute]
private static WindowChromeWorker();
    [SecuritySafeCriticalAttribute]
public void SetWindowChrome(WindowChrome newChrome);
    public static WindowChromeWorker GetWindowChromeWorker(Window window);
    public static void SetWindowChromeWorker(Window window, WindowChromeWorker chrome);
}
public enum System.Windows.ShutdownMode : Enum {
    public byte value__;
    public static ShutdownMode OnLastWindowClose;
    public static ShutdownMode OnMainWindowClose;
    public static ShutdownMode OnExplicitShutdown;
}
internal class System.Windows.SingleChildEnumerator : object {
    private object System.Collections.IEnumerator.Current { get; }
    internal SingleChildEnumerator(object Child);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class System.Windows.SizeChangedEventArgs : RoutedEventArgs {
    public Size PreviousSize { get; }
    public Size NewSize { get; }
    public bool WidthChanged { get; }
    public bool HeightChanged { get; }
    internal SizeChangedEventArgs(UIElement element, SizeChangedInfo info);
    private static SizeChangedEventArgs();
    public Size get_PreviousSize();
    public Size get_NewSize();
    public bool get_WidthChanged();
    public bool get_HeightChanged();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SizeChangedEventHandler : MulticastDelegate {
    public SizeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SizeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SizeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.SR : object {
    internal static ResourceManager ResourceManager { get; }
    private static SR();
    internal static string Get(string id);
    internal static string Get(string id, Object[] args);
    internal static ResourceManager get_ResourceManager();
}
internal class System.Windows.SRID : ValueType {
    public static string Default;
    public static string UnexpectedParameterType;
    public static string CannotConvertStringToType;
    public static string CannotConvertType;
    public static string StringEmpty;
    public static string ParameterCannotBeNegative;
    public static string Enum_Invalid;
    public static string Collection_BadType;
    public static string Collection_CopyTo_IndexGreaterThanOrEqualToArrayLength;
    public static string Collection_CopyTo_NumberOfElementsExceedsArrayLength;
    public static string Collection_CopyTo_ArrayCannotBeMultidimensional;
    public static string CollectionNumberOfElementsMustBeLessOrEqualTo;
    public static string Enumerator_VerifyContext;
    public static string Animation_ChildMustBeKeyFrame;
    public static string Animation_NoTextChildren;
    public static string Animation_InvalidBaseValue;
    public static string Animation_InvalidTimeKeyTime;
    public static string Animation_InvalidResolvedKeyTimes;
    public static string Animation_InvalidAnimationUsingKeyFramesDuration;
    public static string Animation_Invalid_DefaultValue;
    public static string Freezable_CantBeFrozen;
    public static string CannotModifyReadOnlyContainer;
    public static string CannotRetrievePartsOfWriteOnlyContainer;
    public static string TokenizerHelperPrematureStringTermination;
    public static string TokenizerHelperMissingEndQuote;
    public static string TokenizerHelperExtraDataEncountered;
    public static string TokenizerHelperEmptyToken;
    public static string InvalidPermissionType;
    public static string InvalidPermissionStateValue;
    public static string SecurityExceptionForSettingSandboxExternalToTrue;
    public static string FileFormatException;
    public static string FileFormatExceptionWithFileName;
    public static string TypeMetadataCannotChangeAfterUse;
    public static string Visual_ArgumentOutOfRange;
    public static string Argument_InvalidOffLen;
    public static string InvalidOperation_IComparerFailed;
    public static string Rect_WidthAndHeightCannotBeNegative;
    public static string UnexpectedCollectionChangeAction;
    public static string Collection_NoNull;
    public static string PropertyIsImmutable;
    public static string PropertyIsInitializeOnly;
    public static string PropertyMustHaveValue;
    public static string CompatibilityPreferencesSealed;
    public static string AudioVideo_InvalidDependencyObject;
    public static string AudioVideo_InvalidMediaState;
    public static string AudioVideo_CannotControlMedia;
    public static string ChangingTypeNotAllowed;
    public static string ChangingIdNotAllowed;
    public static string CanOnlyHaveOneChild;
    public static string DocumentApplicationCannotInitializeUI;
    public static string DocumentApplicationNotInFullTrust;
    public static string DocumentApplicationRegistryKeyNotFound;
    public static string DocumentApplicationStatusLoaded;
    public static string DocumentApplicationUnableToOpenDocument;
    public static string DocumentApplicationUnknownFileFormat;
    public static string DocumentApplicationContextMenuPreviousPageHeader;
    public static string DocumentApplicationContextMenuPreviousPageInputGesture;
    public static string DocumentApplicationContextMenuNextPageHeader;
    public static string DocumentApplicationContextMenuNextPageInputGesture;
    public static string DocumentApplicationContextMenuFirstPageInputGesture;
    public static string DocumentApplicationContextMenuLastPageInputGesture;
    public static string DocumentPageView_ParentNotDocumentPageHost;
    public static string DocumentViewerPageViewsCollectionEmpty;
    public static string DocumentViewerOneMasterPage;
    public static string DocumentViewerArgumentMustBeInteger;
    public static string DocumentViewerArgumentMustBePercentage;
    public static string DocumentViewerCanHaveOnlyOneChild;
    public static string DocumentViewerChildMustImplementIDocumentPaginatorSource;
    public static string DocumentViewerStyleMustIncludeContentHost;
    public static string DocumentViewerOnlySupportsFixedDocumentSequence;
    public static string FlowDocumentPageViewerOnlySupportsFlowDocument;
    public static string FlowDocumentScrollViewerCanHaveOnlyOneChild;
    public static string FlowDocumentScrollViewerDocumentBelongsToAnotherFlowDocumentScrollViewerAlready;
    public static string FlowDocumentScrollViewerMarkedAsContentHostMustHaveNoContent;
    public static string SwitchViewingMode;
    public static string FlowDocumentReaderCanHaveOnlyOneChild;
    public static string FlowDocumentReaderDecoratorMarkedAsContentHostMustHaveNoContent;
    public static string FlowDocumentReaderCannotDisableAllViewingModes;
    public static string FlowDocumentReaderViewingModeEnabledConflict;
    public static string ZoomPercentageConverterStringFormat;
    public static string DocumentGridVisualTreeContainsNonDocumentGridPage;
    public static string DocumentGridVisualTreeContainsNonBorderAsFirstElement;
    public static string DocumentGridVisualTreeOutOfSync;
    public static string DocumentGridVisualTreeContainsNonUIElement;
    public static string DocumentGridInvalidViewMode;
    public static string RowCacheRecalcWithNoPageCache;
    public static string RowCacheCannotModifyNonExistentLayout;
    public static string RowCachePageNotFound;
    public static string Panel_BoundPanel_NoChildren;
    public static string Panel_NoNullVisualParent;
    public static string Panel_NoNullChildren;
    public static string Panel_ItemsControlNotFound;
    public static string ItemsControl_ParentNotFrameworkElement;
    public static string Stack_VisualInDifferentSubTree;
    public static string Track_SameButtons;
    public static string ToolBar_InvalidStyle_ToolBarPanel;
    public static string ToolBar_InvalidStyle_ToolBarOverflowPanel;
    public static string ScrollViewer_OutOfRange;
    public static string ScrollViewer_CannotBeNaN;
    public static string ScrollBar_ContextMenu_ScrollHere;
    public static string ScrollBar_ContextMenu_LeftEdge;
    public static string ScrollBar_ContextMenu_RightEdge;
    public static string ScrollBar_ContextMenu_Top;
    public static string ScrollBar_ContextMenu_Bottom;
    public static string ScrollBar_ContextMenu_PageLeft;
    public static string ScrollBar_ContextMenu_PageRight;
    public static string ScrollBar_ContextMenu_PageUp;
    public static string ScrollBar_ContextMenu_PageDown;
    public static string ScrollBar_ContextMenu_ScrollLeft;
    public static string ScrollBar_ContextMenu_ScrollRight;
    public static string ScrollBar_ContextMenu_ScrollUp;
    public static string ScrollBar_ContextMenu_ScrollDown;
    public static string XpsValidatingLoaderUnsupportedMimeType;
    public static string XpsValidatingLoaderUnlistedResource;
    public static string XpsValidatingLoaderUriNotInSamePackage;
    public static string XpsValidatingLoaderDuplicateReference;
    public static string XpsValidatingLoaderMoreThanOnePrintTicketPart;
    public static string XpsValidatingLoaderMoreThanOneThumbnailInPackage;
    public static string XpsValidatingLoaderMoreThanOneThumbnailPart;
    public static string XpsValidatingLoaderMoreThanOneDiscardControlInPackage;
    public static string XpsValidatingLoaderThumbnailHasIncorrectType;
    public static string XpsValidatingLoaderPrintTicketHasIncorrectType;
    public static string XpsValidatingLoaderDiscardControlHasIncorrectType;
    public static string XpsValidatingLoaderRestrictedFontHasIncorrectType;
    public static string XpsValidatingLoaderUnsupportedEncoding;
    public static string XpsValidatingLoaderUnsupportedRootNamespaceUri;
    public static string SerializerProviderWrongVersion;
    public static string SerializerProviderCannotLoad;
    public static string SerializerProviderUnknownSerializer;
    public static string SerializerProviderAlreadyRegistered;
    public static string SerializerProviderNotRegistered;
    public static string SerializerProviderDisplayNameNull;
    public static string SerializerProviderManufacturerNameNull;
    public static string SerializerProviderManufacturerWebsiteNull;
    public static string SerializerProviderDefaultFileExtensionNull;
    public static string PageContentUnsupportedMimeType;
    public static string PageContentNotFound;
    public static string PageContentUnsupportedPageType;
    public static string ExceptionInGetPage;
    public static string PrevoiusPartialPageContentOutstanding;
    public static string BadFixedTextPosition;
    public static string FixedDocumentReadonly;
    public static string NotInAssociatedContainer;
    public static string FixedDocumentExpectsDependencyObject;
    public static string InvalidStoryFragmentsMarkup;
    public static string InvalidSFContentType;
    public static string InvalidDSContentType;
    public static string DocumentReferenceUnsupportedMimeType;
    public static string DocumentReferenceNotFound;
    public static string DocumentReferenceHasInvalidDocument;
    public static string PrevoiusUninitializedDocumentReferenceOutstanding;
    public static string DocumentReadOnly;
    public static string DocumentStructureUnexpectedParameterType1;
    public static string DocumentStructureUnexpectedParameterType2;
    public static string DocumentStructureUnexpectedParameterType4;
    public static string DocumentStructureUnexpectedParameterType6;
    public static string FrameNoAddChild;
    public static string GlyphsClusterNoNestedClusters;
    public static string GlyphsClusterNoMatchingBracket;
    public static string GlyphsClusterMisplacedSeparator;
    public static string GlyphsClusterBadCharactersBeforeBracket;
    public static string GlyphsIndexRequiredIfNoUnicode;
    public static string GlyphsAdvanceWidthCannotBeNegative;
    public static string GlyphsTooManyCommas;
    public static string GlyphsIndexRequiredWithinCluster;
    public static string GlyphsUnicodeStringAndIndicesCannotBothBeEmpty;
    public static string GlyphsUnicodeStringIsTooShort;
    public static string GlyphsCaretStopsContainsHexDigits;
    public static string GlyphsCaretStopsLengthCorrespondsToUnicodeString;
    public static string AlreadyHasLogicalChildren;
    public static string CannotHookupFCERoot;
    public static string ChildNameMustBeNonEmpty;
    public static string ChildNameNamePatternReserved;
    public static string ChildTemplateInstanceDoesNotExist;
    public static string EventTriggerDoNotSetProperties;
    public static string EventTriggerDoesNotEnterExit;
    public static string EventTriggerEventUnresolvable;
    public static string EventTriggerNeedEvent;
    public static string EventTriggerTargetNameUnresolvable;
    public static string EventTriggerOnStyleNotAllowedToHaveTarget;
    public static string NamesNotSupportedInsideResourceDictionary;
    public static string FrameworkElementFactoryAlreadyParented;
    public static string FrameworkElementFactoryCannotAddText;
    public static string FrameworkElementFactoryMustBeSealed;
    public static string InputStreamMustBeReadable;
    public static string InvalidPropertyValue;
    public static string KeyCollectionHasInvalidKey;
    public static string MustBaseOnStyleOfABaseType;
    public static string MustBeFrameworkDerived;
    public static string MustBeFrameworkOr3DDerived;
    public static string MustBeTriggerAction;
    public static string MustBeCondition;
    public static string InvalidControlTemplateTargetType;
    public static string Illegal_InheritanceBehaviorSettor;
    public static string NullPropertyIllegal;
    public static string NullTypeIllegal;
    public static string NameScopeNameNotEmptyString;
    public static string NameScopeNameNotFound;
    public static string NameScopeDuplicateNamesNotAllowed;
    public static string NameScopeNotFound;
    public static string NameScopeInvalidIdentifierName;
    public static string CrossThreadAccessOfUnshareableFreezable;
    public static string CyclicStyleReferenceDetected;
    public static string CyclicThemeStyleReferenceDetected;
    public static string PropertyTriggerCycleDetected;
    public static string PropertyTriggerLayerLimitExceeded;
    public static string ReadOnlyPropertyNotAllowed;
    public static string SetterOnStyleNotAllowedToHaveTarget;
    public static string SetterValueCannotBeUnset;
    public static string StyleBasedOnHasLoop;
    public static string StyleCannotBeBasedOnSelf;
    public static string CannotChangeAfterSealed;
    public static string TemplateCircularReferenceFound;
    public static string TemplateCannotHaveNestedContentPresenterAndGridViewRowPresenter;
    public static string Template3DValueOnly;
    public static string StyleForWrongType;
    public static string NameNotEmptyString;
    public static string NameNotFound;
    public static string StylePropertyInStyleNotAllowed;
    public static string SystemResourceForTypeIsNotStyle;
    public static string TargetNameNotFound;
    public static string TypeMustImplementIAddChild;
    public static string NestedBeginInitNotSupported;
    public static string EndInitWithoutBeginInitNotSupported;
    public static string VisualTreeRootIsFrameworkElement;
    public static string VisualTriggerSettersIncludeUnsupportedSetterType;
    public static string ModifyingLogicalTreeViaStylesNotImplemented;
    public static string InvalidSetterValue;
    public static string TemplateChildIndexOutOfRange;
    public static string NamedObjectMustBeFrameworkElement;
    public static string StyleHasTooManyElements;
    public static string TemplateHasNestedNameScope;
    public static string TriggerActionMustBelongToASingleTrigger;
    public static string TriggerActionAlreadySealed;
    public static string TriggersSupportsEventTriggersOnly;
    public static string HandlerTypeIllegal;
    public static string UnexpectedValueTypeForDataTrigger;
    public static string UnexpectedValueTypeForCondition;
    public static string ConditionCannotUseBothPropertyAndBinding;
    public static string CannotHaveOverridesDefaultStyleInThemeStyle;
    public static string CannotHavePropertyInStyle;
    public static string CannotHavePropertyInTemplate;
    public static string CannotHaveEventHandlersInThemeStyle;
    public static string StyleTargetTypeMismatchWithElement;
    public static string StyleTriggersCannotTargetTheTemplate;
    public static string CannotModifyLogicalChildrenDuringTreeWalk;
    public static string EventTriggerBadAction;
    public static string SourceNameNotSupportedForDataTriggers;
    public static string TriggerOnStyleNotAllowedToHaveSource;
    public static string ResourceDictionaryLoadFromFailure;
    public static string ResourceDictionaryDeferredContentFailure;
    public static string ResourceDictionaryDuplicateDeferredContent;
    public static string NoDefaultUpdateSourceTrigger;
    public static string UnsupportedTriggerInStyle;
    public static string Storyboard_AnimationMismatch;
    public static string Storyboard_BeginStoryboardNameNotFound;
    public static string Storyboard_BeginStoryboardNameRequired;
    public static string Storyboard_BeginStoryboardNoStoryboard;
    public static string Storyboard_ComplexPathNotSupported;
    public static string Storyboard_ImmutableTargetNotSupported;
    public static string Storyboard_MediaElementNotFound;
    public static string Storyboard_MediaElementRequired;
    public static string Storyboard_NameNotFound;
    public static string Storyboard_NoNameScope;
    public static string Storyboard_NeverApplied;
    public static string Storyboard_PropertyPathEmpty;
    public static string Storyboard_PropertyPathFrozenCheckFailed;
    public static string Storyboard_PropertyPathSealedCheckFailed;
    public static string Storyboard_PropertyPathIncludesNonAnimatableProperty;
    public static string Storyboard_PropertyPathMustPointToDependencyObject;
    public static string Storyboard_PropertyPathMustPointToDependencyProperty;
    public static string Storyboard_PropertyPathObjectNotFound;
    public static string Storyboard_PropertyPathPropertyNotFound;
    public static string Storyboard_PropertyPathUnresolved;
    public static string Storyboard_StoryboardReferenceRequired;
    public static string Storyboard_TargetNameNotDependencyObject;
    public static string Storyboard_TargetNameNotAllowedInStyle;
    public static string Storyboard_TargetPropertyRequired;
    public static string Storyboard_UnableToFreeze;
    public static string Storyboard_UnrecognizedHandoffBehavior;
    public static string Storyboard_UnrecognizedTimeSeekOrigin;
    public static string Storyboard_NoTarget;
    public static string TemplateInvalidBamlRecord;
    public static string TemplateTargetTypeMismatch;
    public static string TemplateNotTargetType;
    public static string MustNotTemplateUnassociatedControl;
    public static string UnsupportedTriggerInTemplate;
    public static string TemplateFindNameInInvalidElement;
    public static string TemplateContentSetTwice;
    public static string ElementMustBelongToTemplate;
    public static string ConditionValueOfMarkupExtensionNotSupported;
    public static string ConditionValueOfExpressionNotSupported;
    public static string SetterValueOfMarkupExtensionNotSupported;
    public static string StyleValueOfExpressionNotSupported;
    public static string ReparentModelChildIllegal;
    public static string CannotBeSelfParent;
    public static string LogicalTreeLoop;
    public static string HasLogicalParent;
    public static string InvalidStringThickness;
    public static string InvalidStringVirtualizationCacheLength;
    public static string InvalidStringCornerRadius;
    public static string InvalidCtorParameterNoNaN;
    public static string InvalidCtorParameterNoInfinity;
    public static string InvalidCtorParameterNoNegative;
    public static string InvalidCtorParameterUnknownGridUnitType;
    public static string InvalidCtorParameterUnknownFigureUnitType;
    public static string InvalidCtorParameterUnknownVirtualizationCacheLengthUnitType;
    public static string InvalidItemContainer;
    public static string MeasureReentrancyInvalid;
    public static string ArrangeReentrancyInvalid;
    public static string TextContainerChangingReentrancyInvalid;
    public static string IDPNegativePageNumber;
    public static string IDPInvalidContentPosition;
    public static string FlowDocumentFormattingReentrancy;
    public static string FlowDocumentInvalidContnetChange;
    public static string PTSError;
    public static string PTSInvalidHandle;
    public static string IllegalTreeChangeDetected;
    public static string IllegalTreeChangeDetectedPostAction;
    public static string FormatRestrictionsExceeded;
    public static string TextPanelIllegalParaTypeForIAddChild;
    public static string TextContainerDoesNotContainElement;
    public static string HyphenatorDisposed;
    public static string Grid_UnexpectedParameterType;
    public static string GridCollection_CannotModifyReadOnly;
    public static string GridCollection_MustBeCertainType;
    public static string GridCollection_InOtherCollection;
    public static string GridCollection_DestArrayInvalidLowerBound;
    public static string GridCollection_DestArrayInvalidRank;
    public static string GridCollection_DestArrayInvalidLength;
    public static string TableCollectionElementTypeExpected;
    public static string TableCollectionRankMultiDimNotSupported;
    public static string TableCollectionOutOfRange;
    public static string TableCollectionRangeOutOfRange;
    public static string TableCollectionOutOfRangeNeedNonNegNum;
    public static string TableCollectionCountNeedNonNegNum;
    public static string TableCollectionInvalidOffLen;
    public static string TableCollectionNotEnoughCapacity;
    public static string TableCollectionInOtherCollection;
    public static string TableCollectionWrongProxyParent;
    public static string TableInvalidParentNodeType;
    public static string EnumeratorNotStarted;
    public static string EnumeratorReachedEnd;
    public static string EnumeratorVersionChanged;
    public static string EnumeratorInvalidOperation;
    public static string EnumeratorCollectionDisposed;
    public static string ListElementItemNotAChildOfList;
    public static string TextPositionIsFrozen;
    public static string NotInThisTree;
    public static string NotInAssociatedTree;
    public static string BadDistance;
    public static string NegativeValue;
    public static string InDifferentTextContainers;
    public static string InDifferentParagraphs;
    public static string InDifferentScope;
    public static string BadTextPositionOrder;
    public static string NoElement;
    public static string NoElementObject;
    public static string NoScopingElement;
    public static string TextContainer_UndoManagerCreatedMoreThanOnce;
    public static string StartIndexExceedsBufferSize;
    public static string MaxLengthExceedsBufferSize;
    public static string TextElementCollection_TextElementTypeExpected;
    public static string TextElementCollection_IndexOutOfRange;
    public static string TextElementCollection_PreviousSiblingDoesNotBelongToThisCollection;
    public static string TextElementCollection_NextSiblingDoesNotBelongToThisCollection;
    public static string TextElementCollection_CannotCopyToArrayNotSufficientMemory;
    public static string TextElementCollection_ItemHasUnexpectedType;
    public static string TextElementCollection_NoEnumerator;
    public static string TextSchema_TextIsNotAllowedInThisContext;
    public static string TextSchema_ChildTypeIsInvalid;
    public static string TextSchema_TheChildElementBelongsToAnotherTreeAlready;
    public static string TextSchema_TextIsNotAllowed;
    public static string TextSchema_UIElementNotAllowedInThisPosition;
    public static string TextSchema_CannotInsertContentInThisPosition;
    public static string TextSchema_ThisInlineUIContainerHasAChildUIElementAlready;
    public static string TextSchema_ThisBlockUIContainerHasAChildUIElementAlready;
    public static string TextSchema_CannotSplitElement;
    public static string TextSchema_IllegalHyperlinkChild;
    public static string TextSchema_IllegalElement;
    public static string TextElement_UnmatchedEndPointer;
    public static string TextPointer_CannotInsertTextElementBecauseItBelongsToAnotherTree;
    public static string TextRange_InvalidParameterValue;
    public static string TextRange_UnsupportedDataFormat;
    public static string TextRange_UnrecognizedStructureInDataFormat;
    public static string TextRange_PropertyCannotBeIncrementedOrDecremented;
    public static string TextRangeEdit_InvalidStructuralPropertyApply;
    public static string KeyCorrectionList;
    public static string KeyToggleInsert;
    public static string KeyDelete;
    public static string KeyBackspace;
    public static string KeyShiftBackspace;
    public static string KeyDeleteNextWord;
    public static string KeyDeletePreviousWord;
    public static string KeyEnterParagraphBreak;
    public static string KeyEnterLineBreak;
    public static string KeyTabForward;
    public static string KeyTabBackward;
    public static string KeySpace;
    public static string KeyShiftSpace;
    public static string KeyMoveRightByCharacter;
    public static string KeyMoveLeftByCharacter;
    public static string KeyMoveRightByWord;
    public static string KeyMoveLeftByWord;
    public static string KeyMoveDownByLine;
    public static string KeyMoveUpByLine;
    public static string KeyMoveDownByParagraph;
    public static string KeyMoveUpByParagraph;
    public static string KeyMoveDownByPage;
    public static string KeyMoveUpByPage;
    public static string KeyMoveToLineStart;
    public static string KeyMoveToLineEnd;
    public static string KeyMoveToColumnStart;
    public static string KeyMoveToColumnEnd;
    public static string KeyMoveToWindowTop;
    public static string KeyMoveToWindowBottom;
    public static string KeyMoveToDocumentStart;
    public static string KeyMoveToDocumentEnd;
    public static string KeySelectAll;
    public static string KeySelectRightByCharacter;
    public static string KeySelectLeftByCharacter;
    public static string KeySelectRightByWord;
    public static string KeySelectLeftByWord;
    public static string KeySelectDownByLine;
    public static string KeySelectUpByLine;
    public static string KeySelectDownByParagraph;
    public static string KeySelectUpByParagraph;
    public static string KeySelectDownByPage;
    public static string KeySelectUpByPage;
    public static string KeySelectToLineStart;
    public static string KeySelectToLineEnd;
    public static string KeySelectToColumnStart;
    public static string KeySelectToColumnEnd;
    public static string KeySelectToWindowTop;
    public static string KeySelectToWindowBottom;
    public static string KeySelectToDocumentStart;
    public static string KeySelectToDocumentEnd;
    public static string KeyUndo;
    public static string KeyAltUndo;
    public static string KeyRedo;
    public static string KeyCut;
    public static string KeyCopy;
    public static string KeyShiftDelete;
    public static string KeyCtrlInsert;
    public static string KeyShiftInsert;
    public static string KeyCopyFormat;
    public static string KeyPasteFormat;
    public static string KeyResetFormat;
    public static string KeyToggleBold;
    public static string KeyToggleItalic;
    public static string KeyToggleUnderline;
    public static string KeyToggleSubscript;
    public static string KeyToggleSuperscript;
    public static string KeyIncreaseFontSize;
    public static string KeyDecreaseFontSize;
    public static string KeyApplyFontSize;
    public static string KeyApplyFontFamily;
    public static string KeyApplyForeground;
    public static string KeyApplyBackground;
    public static string KeyToggleSpellCheck;
    public static string KeyAlignLeft;
    public static string KeyAlignCenter;
    public static string KeyAlignRight;
    public static string KeyAlignJustify;
    public static string KeyApplySingleSpace;
    public static string KeyApplyOneAndAHalfSpace;
    public static string KeyApplyDoubleSpace;
    public static string KeyIncreaseIndentation;
    public static string KeyDecreaseIndentation;
    public static string KeyRemoveListMarkers;
    public static string KeyToggleBullets;
    public static string KeyToggleNumbering;
    public static string KeyInsertTable;
    public static string KeyInsertRows;
    public static string KeyInsertColumns;
    public static string KeyDeleteRows;
    public static string KeyDeleteColumns;
    public static string KeyMergeCells;
    public static string KeySplitCell;
    public static string KeyCorrectionListDisplayString;
    public static string KeyToggleInsertDisplayString;
    public static string KeyDeleteDisplayString;
    public static string KeyBackspaceDisplayString;
    public static string KeyShiftBackspaceDisplayString;
    public static string KeyDeleteNextWordDisplayString;
    public static string KeyDeletePreviousWordDisplayString;
    public static string KeyEnterParagraphBreakDisplayString;
    public static string KeyEnterLineBreakDisplayString;
    public static string KeyTabForwardDisplayString;
    public static string KeyTabBackwardDisplayString;
    public static string KeySpaceDisplayString;
    public static string KeyShiftSpaceDisplayString;
    public static string KeyMoveRightByCharacterDisplayString;
    public static string KeyMoveLeftByCharacterDisplayString;
    public static string KeyMoveRightByWordDisplayString;
    public static string KeyMoveLeftByWordDisplayString;
    public static string KeyMoveDownByLineDisplayString;
    public static string KeyMoveUpByLineDisplayString;
    public static string KeyMoveDownByParagraphDisplayString;
    public static string KeyMoveUpByParagraphDisplayString;
    public static string KeyMoveDownByPageDisplayString;
    public static string KeyMoveUpByPageDisplayString;
    public static string KeyMoveToLineStartDisplayString;
    public static string KeyMoveToLineEndDisplayString;
    public static string KeyMoveToColumnStartDisplayString;
    public static string KeyMoveToColumnEndDisplayString;
    public static string KeyMoveToWindowTopDisplayString;
    public static string KeyMoveToWindowBottomDisplayString;
    public static string KeyMoveToDocumentStartDisplayString;
    public static string KeyMoveToDocumentEndDisplayString;
    public static string KeySelectAllDisplayString;
    public static string KeySelectRightByCharacterDisplayString;
    public static string KeySelectLeftByCharacterDisplayString;
    public static string KeySelectRightByWordDisplayString;
    public static string KeySelectLeftByWordDisplayString;
    public static string KeySelectDownByLineDisplayString;
    public static string KeySelectUpByLineDisplayString;
    public static string KeySelectDownByParagraphDisplayString;
    public static string KeySelectUpByParagraphDisplayString;
    public static string KeySelectDownByPageDisplayString;
    public static string KeySelectUpByPageDisplayString;
    public static string KeySelectToLineStartDisplayString;
    public static string KeySelectToLineEndDisplayString;
    public static string KeySelectToColumnStartDisplayString;
    public static string KeySelectToColumnEndDisplayString;
    public static string KeySelectToWindowTopDisplayString;
    public static string KeySelectToWindowBottomDisplayString;
    public static string KeySelectToDocumentStartDisplayString;
    public static string KeySelectToDocumentEndDisplayString;
    public static string KeyUndoDisplayString;
    public static string KeyAltUndoDisplayString;
    public static string KeyRedoDisplayString;
    public static string KeyCutDisplayString;
    public static string KeyCopyDisplayString;
    public static string KeyShiftDeleteDisplayString;
    public static string KeyCtrlInsertDisplayString;
    public static string KeyShiftInsertDisplayString;
    public static string KeyCopyFormatDisplayString;
    public static string KeyPasteFormatDisplayString;
    public static string KeyResetFormatDisplayString;
    public static string KeyToggleBoldDisplayString;
    public static string KeyToggleItalicDisplayString;
    public static string KeyToggleUnderlineDisplayString;
    public static string KeyToggleSubscriptDisplayString;
    public static string KeyToggleSuperscriptDisplayString;
    public static string KeyIncreaseFontSizeDisplayString;
    public static string KeyDecreaseFontSizeDisplayString;
    public static string KeyApplyFontSizeDisplayString;
    public static string KeyApplyFontFamilyDisplayString;
    public static string KeyApplyForegroundDisplayString;
    public static string KeyApplyBackgroundDisplayString;
    public static string KeyToggleSpellCheckDisplayString;
    public static string KeyAlignLeftDisplayString;
    public static string KeyAlignCenterDisplayString;
    public static string KeyAlignRightDisplayString;
    public static string KeyAlignJustifyDisplayString;
    public static string KeyApplySingleSpaceDisplayString;
    public static string KeyApplyOneAndAHalfSpaceDisplayString;
    public static string KeyApplyDoubleSpaceDisplayString;
    public static string KeyIncreaseIndentationDisplayString;
    public static string KeyDecreaseIndentationDisplayString;
    public static string KeyRemoveListMarkersDisplayString;
    public static string KeyToggleBulletsDisplayString;
    public static string KeyToggleNumberingDisplayString;
    public static string KeyInsertTableDisplayString;
    public static string KeyInsertRowsDisplayString;
    public static string KeyInsertColumnsDisplayString;
    public static string KeyDeleteRowsDisplayString;
    public static string KeyDeleteColumnsDisplayString;
    public static string KeyMergeCellsDisplayString;
    public static string KeySplitCellDisplayString;
    public static string KeySwitchViewingMode;
    public static string KeySwitchViewingModeDisplayString;
    public static string TextStore_E_NOTIMPL;
    public static string TextStore_E_NOINTERFACE;
    public static string TextStore_CONNECT_E_CANNOTCONNECT;
    public static string TextStore_CONNECT_E_NOCONNECTION;
    public static string TextStore_TS_E_INVALIDPOINT;
    public static string TextStore_TS_E_NOLAYOUT;
    public static string TextStore_TS_E_READONLY;
    public static string TextStore_TS_E_FORMAT;
    public static string TextStore_NoSink;
    public static string TextStore_BadLockFlags;
    public static string TextStore_ReentrantRequestLock;
    public static string TextStore_CompositionRejected;
    public static string TextStore_BadIMECharOffset;
    public static string InputScopeAttribute_E_OUTOFMEMORY;
    public static string WpfPayload_InvalidImageSource;
    public static string SelectionChangeActive;
    public static string SelectionChangeNotActive;
    public static string CannotSelectNotSelectableItem;
    public static string ListBoxSelectAllSelectionMode;
    public static string ChangingCollectionNotSupported;
    public static string DeferSelectionActive;
    public static string DeferSelectionNotActive;
    public static string InsertInDeferSelectionActive;
    public static string SetInDeferSelectionActive;
    public static string MoveInDeferSelectionActive;
    public static string MultiSelectorSelectAll;
    public static string ListBoxSelectAllKey;
    public static string ListBoxSelectAllKeyDisplayString;
    public static string ListBoxSelectAllText;
    public static string ListBoxInvalidAnchorItem;
    public static string CreateRootPopup_ChildHasLogicalParent;
    public static string CreateRootPopup_ChildHasVisualParent;
    public static string ElementMustBeInPopup;
    public static string PopupReopeningNotAllowed;
    public static string ContextMenuInDifferentDispatcher;
    public static string ToolTipStaysOpenFalseNotAllowed;
    public static string StyleImpliedAndComplexChildren;
    public static string StyleInvalidElementTag;
    public static string StyleKnownTagWrongLocation;
    public static string StyleNoTemplateBindInSetters;
    public static string StyleNoTemplateBindInVisualTrigger;
    public static string StyleNoClrEvent;
    public static string StyleNoDef;
    public static string StyleNoDictionaryKey;
    public static string StyleNoSetterResource;
    public static string StyleNoTopLevelElement;
    public static string StylePropertyCustom;
    public static string StylePropertySetterMinAttrs;
    public static string StylePropTriggerPropMissing;
    public static string StyleDataTriggerBindingMissing;
    public static string StyleDataTriggerBindingHasBadValue;
    public static string StyleSetterUnknownProp;
    public static string StyleTagNotSupported;
    public static string StyleTextNotSupported;
    public static string StyleUnknownProp;
    public static string StyleUnknownTrigger;
    public static string StyleNoEventSetters;
    public static string SourceNameNotSupportedForStyleTriggers;
    public static string StyleNoPropOrEvent;
    public static string StyleNoTarget;
    public static string TargetNameNotSupportedForStyleSetters;
    public static string TemplateDupName;
    public static string TemplateBadDictionaryKey;
    public static string TemplateInvalidRootElementTag;
    public static string TemplateKnownTagWrongLocation;
    public static string TemplateNoTemplateBindInVisualTrigger;
    public static string TemplateNoMultipleRoots;
    public static string TemplateNoTriggerTarget;
    public static string TemplateNoProp;
    public static string TemplateNoTarget;
    public static string TemplateTagNotSupported;
    public static string TemplateTextNotSupported;
    public static string TemplateUnknownProp;
    public static string ContentControlCannotHaveMultipleContent;
    public static string MissingContentSource;
    public static string CannotQueryPropertiesWhenPageNotInTreeWithWindow;
    public static string ParentOfPageMustBeWindowOrFrame;
    public static string PageCannotHaveMultipleContent;
    public static string WindowMustBeRoot;
    public static string CircularOwnerChild;
    public static string CannotSetOwnerToItself;
    public static string CantSetOwnerToClosedWindow;
    public static string CantSetOwnerWhosHwndIsNotCreated;
    public static string ShowDialogOnVisible;
    public static string ShowDialogOnModal;
    public static string CantSetOwnerAfterDialogIsShown;
    public static string DragMoveFail;
    public static string IncorrectFlowDirection;
    public static string CantSetInMarkup;
    public static string ValueNotBetweenInt32MinMax;
    public static string InvalidValueForTopLeft;
    public static string TransformNotSupported;
    public static string ClipToBoundsNotSupported;
    public static string DialogResultMustBeSetAfterShowDialog;
    public static string IconMustBeBitmapFrame;
    public static string ReshowNotAllowed;
    public static string InvalidOperationDuringClosing;
    public static string InvalidCompositionTarget;
    public static string ChangeNotAllowedAfterShow;
    public static string MustUseWindowStyleNone;
    public static string ShowNonActivatedAndMaximized;
    public static string NotAllowedBeforeShow;
    public static string NotSupportedInBrowser;
    public static string WebBrowserOverlap;
    public static string PrintJobDescription;
    public static string UntitledPrintJobDescription;
    public static string CannotBeInsidePopup;
    public static string CannotInvokeScript;
    public static string NeedToBeComVisible;
    public static string AbsoluteUriOnly;
    public static string CantShowMBServiceWithOwner;
    public static string NoMulticastHandlers;
    public static string PropertyPathSyntaxError;
    public static string PropertyPathNoProperty;
    public static string PropertyPathNoOwnerType;
    public static string PropertyPathInvalidAccessor;
    public static string BindingConflict;
    public static string PropertyNotBindable;
    public static string RequiresExplicitCulture;
    public static string BindingExpressionStatusChanged;
    public static string PathSyntax;
    public static string UnmatchedBracket;
    public static string UnmatchedParen;
    public static string BindingListCanOnlySortByOneProperty;
    public static string BindingListCannotCustomFilter;
    public static string InconsistentBindingList;
    public static string RequiresXmlNamespaceMapping;
    public static string RequiresXmlNamespaceMappingUri;
    public static string ChildHasWrongType;
    public static string BadTargetArray;
    public static string CopyToNotEnoughSpace;
    public static string MissingValueConverter;
    public static string MultiBindingHasNoConverter;
    public static string NoUpdateSourceTriggerForInnerBindingOfMultiBinding;
    public static string BindingExpressionIsDetached;
    public static string DuplicatesNotAllowed;
    public static string ImplementOtherMembersWithSort;
    public static string NoCheckOrChangeWhenDeferred;
    public static string TwoWayBindingNeedsPath;
    public static string AdornedElementPlaceholderMustBeInTemplate;
    public static string BindingCollectionContainsNonBinding;
    public static string CannotWriteToReadOnly;
    public static string PathParametersIndexOutOfRange;
    public static string PathParameterIsNull;
    public static string PropertyPathIndexWrongType;
    public static string ChangeSealedBinding;
    public static string CannotChangeLiveShaping;
    public static string ObjectDataProviderHasNoSource;
    public static string ObjectDataProviderCanHaveOnlyOneSource;
    public static string ObjectDataProviderNonCLSException;
    public static string ObjectDataProviderNonCLSExceptionInvoke;
    public static string ObjectDataProviderParameterCollectionIsNotInUse;
    public static string RelativeSourceNotInFindAncestorMode;
    public static string RelativeSourceInvalidAncestorLevel;
    public static string RelativeSourceNeedsMode;
    public static string RelativeSourceNeedsAncestorType;
    public static string RelativeSourceModeIsImmutable;
    public static string RelativeSourceModeInvalid;
    public static string ExceptionValidationRuleValidateNotSupported;
    public static string ValidationRule_UnexpectedValue;
    public static string ValidationRule_UnknownStep;
    public static string Validation_ConversionFailed;
    public static string BindingGroup_NoEntry;
    public static string BindingGroup_ValueUnavailable;
    public static string BindingGroup_CannotChangeGroups;
    public static string IndexedPropDescNotImplemented;
    public static string NonCLSException;
    public static string DisplayMemberPathAndItemTemplateSelectorDefined;
    public static string DisplayMemberPathAndItemTemplateDefined;
    public static string ItemTemplateSelectorBreaksDisplayMemberPath;
    public static string CannotFindRemovedItem;
    public static string PanelIsNotItemsHost;
    public static string CannotRemoveUnrealizedItems;
    public static string GenerationInProgress;
    public static string GenerationNotInProgress;
    public static string RemoveRequiresOffsetZero;
    public static string RemoveRequiresPositiveCount;
    public static string MustBeTypeOrString;
    public static string DataTypeCannotBeObject;
    public static string ItemsPanelNotAPanel;
    public static string ItemsPanelNotSingleNode;
    public static string TemplateMustBeFE;
    public static string CollectionViewTypeIsInitOnly;
    public static string CannotSortView;
    public static string CannotFilterView;
    public static string CannotGroupView;
    public static string RangeActionsNotSupported;
    public static string AddedItemNotInCollection;
    public static string AddedItemNotAtIndex;
    public static string RemovedItemNotFound;
    public static string CollectionChangeIndexOutOfRange;
    public static string MultiThreadedCollectionChangeNotSupported;
    public static string CannotMoveToUnknownPosition;
    public static string CompositeCollectionResetOnlyOnClear;
    public static string CollectionContainerMustBeUniqueForComposite;
    public static string MemberNotAllowedDuringAddOrEdit;
    public static string MemberNotAllowedForView;
    public static string MemberNotAllowedDuringTransaction;
    public static string RemovingPlaceholder;
    public static string CannotEditPlaceholder;
    public static string CancelEditNotSupported;
    public static string MultiSingleton;
    public static string ApplicationAlreadyRunning;
    public static string CannotCallRunMultipleTimes;
    public static string WindowPassedShouldBeOnApplicationThread;
    public static string ShutdownModeWhenAppShutdown;
    public static string UnknownContainerFormat;
    public static string ContentTypeNotSupported;
    public static string UriNotMatchWithRootType;
    public static string WebRequestCreationFailed;
    public static string GetResponseFailed;
    public static string GetStreamFailed;
    public static string EntryAssemblyIsNull;
    public static string UnableToLocateResource;
    public static string CannotCallRunFromBrowserHostedApp;
    public static string AbsoluteUriNotAllowed;
    public static string CannotChangeMainWindowInBrowser;
    public static string ArgumentPropertyMustNotBeNull;
    public static string NonPackAppAbsoluteUriNotAllowed;
    public static string NonPackSooAbsoluteUriNotAllowed;
    public static string NonClsActivationException;
    public static string AppActivationException;
    public static string KillBitEnforcedShutdown;
    public static string ApplicationShuttingDown;
    public static string AffectedByMsCtfIssue;
    public static string AxRequiresApartmentThread;
    public static string AXNohWnd;
    public static string AxNoEventInterface;
    public static string AxNoSinkImplementation;
    public static string AxNoSinkAdvise;
    public static string AxNoConnectionPointContainer;
    public static string AxNoConnectionPoint;
    public static string WebBrowserNoCastToIWebBrowser2;
    public static string AxWindowlessControl;
    public static string HyperLinkTargetNotFound;
    public static string FailToNavigateUsingHyperlinkTarget;
    public static string WrongNavigateRootElement;
    public static string LoopDetected;
    public static string RequestNavigateEventMustHaveRoutedEvent;
    public static string MustImplementIUriContext;
    public static string FailedToConvertResource;
    public static string WindowAlreadyClosed;
    public static string BamlIsNotSupportedOutsideOfApplicationResources;
    public static string UiLessPageFunctionNotCallingOnReturn;
    public static string FailToLaunchDefaultBrowser;
    public static string NoBackEntry;
    public static string NoForwardEntry;
    public static string NoAddChild;
    public static string InvalidOperation_CannotClearFwdStack;
    public static string InvalidOperation_MustImplementIPCCSOrHandleNavigating;
    public static string CustomContentStateMustBeSerializable;
    public static string InvalidOperation_CantChangeJournalOwnership;
    public static string InvalidOperation_NoJournal;
    public static string InvalidOperation_AddBackEntryNoContent;
    public static string InvalidPageFunctionType;
    public static string InvalidOperation_CannotReenterPageFunction;
    public static string ReturnEventHandlerMustBeOnParentPage;
    public static string FailedResumePageFunction;
    public static string PropertyToSortByNotFoundOnType;
    public static string CannotDetermineSortByPropertiesForCollection;
    public static string BamlReaderClosed;
    public static string BamlReaderNoOwnerType;
    public static string BamlScopeError;
    public static string BamlBadExtensionValue;
    public static string BamlWriterBadAssembly;
    public static string BamlWriterBadScope;
    public static string BamlWriterBadStream;
    public static string BamlWriterBadXmlns;
    public static string BamlWriterClosed;
    public static string BamlWriterNoInElement;
    public static string BamlWriterStartDoc;
    public static string BamlWriterUnknownMarkupExtension;
    public static string MarkupExtensionDynamicOrBindingOnClrProp;
    public static string MarkupExtensionDynamicOrBindingInCollection;
    public static string MarkupExtensionNoContext;
    public static string MarkupExtensionProperty;
    public static string MarkupExtensionResourceKey;
    public static string MarkupExtensionResourceNotFound;
    public static string ColorConvertedBitmapExtensionSyntax;
    public static string ColorConvertedBitmapExtensionNoSourceImage;
    public static string ColorConvertedBitmapExtensionNoSourceProfile;
    public static string ParserAbandonedTypeConverterText;
    public static string ParserAsyncOnRoot;
    public static string ParserAttachedPropInheritError;
    public static string ParserAttributeArgsLow;
    public static string ParserBadAssemblyName;
    public static string ParserBadAssemblyPath;
    public static string ParserBadChild;
    public static string ParserBadConstructorParams;
    public static string ParserBadName;
    public static string ParserBadUidOrNameME;
    public static string ParserBadNullableType;
    public static string ParserBadKey;
    public static string ParserBadSyncMode;
    public static string ParserBadTypeInArrayProperty;
    public static string ParserBadEncoding;
    public static string ParserBamlEvent;
    public static string ParserBamlVersion;
    public static string ParserCannotAddChild;
    public static string ParserCannotConvertString;
    public static string ParserCannotSetValue;
    public static string ParserCantCreateTextComplexProp;
    public static string ParserCantCreateInstanceType;
    public static string ParserCantGetDPOrPi;
    public static string ParserCompatDuplicate;
    public static string ParserDefaultConverterProperty;
    public static string ParserDefaultConverterElement;
    public static string ParserDeferContentAsync;
    public static string ParserDefTag;
    public static string ParserDefSharedOnlyInCompiled;
    public static string ParserDictionarySealed;
    public static string ParserDupDictionaryKey;
    public static string ParserDuplicateMarkupExtensionProperty;
    public static string ParserDuplicateProperty1;
    public static string ParserDuplicateProperty2;
    public static string ParserEmptyComplexProp;
    public static string ParserEntityReference;
    public static string ParserErrorCreatingInstance;
    public static string ParserErrorParsingAttrib;
    public static string ParserErrorParsingAttribType;
    public static string ParserFailFindType;
    public static string ParserFailedToCreateFromConstructor;
    public static string ParserFilterXmlReaderNoDefinitionPrefixChangeAllowed;
    public static string ParserFilterXmlReaderNoIndexAttributeAccess;
    public static string ParserCannotAddAnyChildren;
    public static string ParserCannotAddAnyChildren2;
    public static string ParserIAddChildText;
    public static string ParserIEnumerableIAddChild;
    public static string ParserInvalidContentPropertyAttribute;
    public static string ParserInvalidIdentifierName;
    public static string ParserKeyOnExplicitDictionary;
    public static string ParserKeysAreStrings;
    public static string ParserLineAndOffset;
    public static string ParserMapPIMissingKey;
    public static string ParserMapPIMissingAssembly;
    public static string ParserMappingUriInvalid;
    public static string ParserMarkupExtensionBadConstructorParam;
    public static string ParserMarkupExtensionBadDelimiter;
    public static string ParserMarkupExtensionNoEndCurlie;
    public static string ParserMarkupExtensionNoNameValue;
    public static string ParserMarkupExtensionNoQuotesInName;
    public static string ParserMarkupExtensionTrailingGarbage;
    public static string ParserMarkupExtensionUnknownAttr;
    public static string ParserMarkupExtensionDelimiterBeforeFirstAttribute;
    public static string ParserMetroUnknownAttribute;
    public static string ParserMultiBamls;
    public static string ParserMultiRoot;
    public static string ParserAttributeNamespaceMisMatch;
    public static string ParserNestedComplexProp;
    public static string ParserNoAttrArray;
    public static string ParserNoChildrenTag;
    public static string ParserNoComplexMulti;
    public static string ParserNoDefaultConstructor;
    public static string ParserNoDefaultPropConstructor;
    public static string ParserNoDictionaryKey;
    public static string ParserNoDictionaryName;
    public static string ParserNoDigitEnums;
    public static string ParserNoElementCreate2;
    public static string ParserNoEvents;
    public static string ParserNoEventTag;
    public static string ParserNoMatchingArray;
    public static string ParserNoMatchingIDictionary;
    public static string ParserNoMatchingIList;
    public static string ParserNoNamespace;
    public static string ParserNoPropOnComplexProp;
    public static string ParserNoResource;
    public static string ParserNoSerializer;
    public static string ParserNoSetterChild;
    public static string ParserNotMarkupExtension;
    public static string ParserNoType;
    public static string ParserNoTypeConv;
    public static string ParserNotMarkedPublic;
    public static string ParserNotAllowedInternalType;
    public static string ParserNullReturned;
    public static string ParserNullPropertyCollection;
    public static string ParserOwnerEventMustBePublic;
    public static string ParserParentDO;
    public static string ParserPrefixNSProperty;
    public static string ParserPrefixNSElement;
    public static string ParserPropertyCollectionClosed;
    public static string ParserPropNoValue;
    public static string ParserPublicType;
    public static string ParserReadOnlyProp;
    public static string ParserResourceKeyType;
    public static string ParserSyncOnRoot;
    public static string ParserTextInvalidInArrayOrDictionary;
    public static string ParserTextInComplexProp;
    public static string ParserTooManyAssemblies;
    public static string ParserUndeclaredNS;
    public static string ParserUnexpectedEndEle;
    public static string ParserUnexpInBAML;
    public static string ParserUnknownAttribute;
    public static string ParserUnknownBaml;
    public static string ParserUnknownDefAttribute;
    public static string ParserUnknownPresentationOptionsAttribute;
    public static string ParserUnknownDefAttributeCompiler;
    public static string ParserUnknownTag;
    public static string ParserUnknownXmlType;
    public static string ParserWriterNoSeekEnd;
    public static string ParserWriterUnknownOrigin;
    public static string ParserXmlReaderNoLineInfo;
    public static string ParserNoNameOnType;
    public static string ParserErrorContext_Type;
    public static string ParserErrorContext_File;
    public static string ParserErrorContext_Type_File;
    public static string ParserErrorContext_Line;
    public static string ParserErrorContext_Type_Line;
    public static string ParserErrorContext_File_Line;
    public static string ParserErrorContext_Type_File_Line;
    public static string ParserCannotConvertInitializationText;
    public static string ParserCannotConvertPropertyValueString;
    public static string ParserCannotConvertPropertyValue;
    public static string ParserCantSetAttribute;
    public static string ParserCantGetProperty;
    public static string ParserReadOnlyNullProperty;
    public static string ParserCantSetTriggerCondition;
    public static string ParserEventDelegateTypeNotAccessible;
    public static string ParserCantCreateDelegate;
    public static string ParserNoNestedXmlDataIslands;
    public static string ParserXmlIslandUnexpected;
    public static string ParserXmlIslandMissing;
    public static string ParserCantSetContentProperty;
    public static string ParserContentMustBeContiguous;
    public static string ParserCanOnlyHaveOneChild;
    public static string ParserProvideValueCantSetUri;
    public static string ParserTypeConverterTextUnusable;
    public static string ParserXmlLangPropertyValueInvalid;
    public static string ParserNoNameUnderDefinitionScopeType;
    public static string ParserBadString;
    public static string ParserTypeConverterTextNeedsEndElement;
    public static string ParserInvalidStaticMember;
    public static string ParserBadMemberReference;
    public static string ParserNoDPOnOwner;
    public static string ParserNoPropType;
    public static string ParserFailedEndInit;
    public static string ParserCannotReuseXamlReader;
    public static string PositionalArgumentsWrongLength;
    public static string InvalidDeSerialize;
    public static string InvalidCustomSerialize;
    public static string MustBeOfType;
    public static string NonWhiteSpaceInAddText;
    public static string TypeValueSerializerUnavailable;
    public static string UnserializableKeyValue;
    public static string ValueSerializerContextUnavailable;
    public static string MarkupWriter_CannotSerializeNonPublictype;
    public static string MarkupWriter_CannotSerializeNestedPublictype;
    public static string MarkupWriter_CannotSerializeGenerictype;
    public static string FilterBindRegionNotImplemented;
    public static string FilterInitInvalidAttributes;
    public static string FilterGetValueMustBeStringOrDateTime;
    public static string FilterGetValueAlreadyCalledOnCurrentChunk;
    public static string FilterGetTextBufferOverflow;
    public static string FilterGetTextNotSupported;
    public static string FilterGetValueNotSupported;
    public static string FilterPropSpecUnknownUnionSelector;
    public static string FilterGetChunkNoStream;
    public static string FileNameNullOrEmpty;
    public static string FileToFilterNotLoaded;
    public static string FilterLoadInvalidModeFlag;
    public static string XamlFilterNestedFixedPage;
    public static string FilterEndOfChunks;
    public static string FilterNullGetTextBufferPointer;
    public static string XmlGlyphRunInfoIsNonGraphic;
    public static string UnexpectedXmlNodeInXmlFixedPageInfoConstructor;
    public static string StreamDoesNotSupportWrite;
    public static string FilterIPersistFileIsReadOnly;
    public static string FilterIPersistStreamIsReadOnly;
    public static string AuxiliaryFilterReturnedAnomalousCountOfCharacters;
    public static string CorePropertyEnumeratorPositionedOutOfBounds;
    public static string CannotSetNegativePosition;
    public static string AnnotationAdorner_NotUIElement;
    public static string CreateHighlight;
    public static string CreateTextNote;
    public static string CreateInkNote;
    public static string ClearHighlight;
    public static string DeleteNotes;
    public static string DeleteAnnotations;
    public static string XmlNodeAlreadyOwned;
    public static string InvalidGuid;
    public static string TypeNameMustBeSpecified;
    public static string ModificationEarlierThanCreation;
    public static string AlreadyHasParent;
    public static string OnlyFlowAndFixedSupported;
    public static string RequiredAttributeMissing;
    public static string InvalidXmlContent;
    public static string CannotSerializeInvalidInstance;
    public static string UnexpectedAttribute;
    public static string InvalidAttributeValue;
    public static string AnnotationAlreadyExists;
    public static string CannotParseId;
    public static string StreamNotSet;
    public static string ObjectDisposed_StoreClosed;
    public static string StreamCannotBeWritten;
    public static string SeekNegative;
    public static string NullUri;
    public static string DuplicatedUri;
    public static string DuplicatedCompatibleUri;
    public static string InvalidNamespace;
    public static string StreamDoesNotSupportSeek;
    public static string TextSegmentsMustNotOverlap;
    public static string SelectionMustBeServiceProvider;
    public static string IncorrectLocatorPartType;
    public static string InvalidLocatorPart;
    public static string InvalidSubTreeProcessor;
    public static string NoProcessorForSelectionType;
    public static string WrongSelectionType;
    public static string StartNodeMustBeDocumentPageViewOrFixedPage;
    public static string StartNodeMustBeFixedPageProxy;
    public static string SelectionDoesNotResolveToAPage;
    public static string IncorrectAnchorLength;
    public static string InvalidStartNodeForTextSelection;
    public static string AnnotationServiceNotEnabled;
    public static string AnnotationServiceIsAlreadyEnabled;
    public static string AnnotationAlreadyExistInService;
    public static string ParameterMustBeLogicalNode;
    public static string OnlyFlowFixedSupported;
    public static string AnnotationServiceAlreadyExists;
    public static string EmptySelectionNotSupported;
    public static string InvalidHighlightColor;
    public static string InvalidSelectionPages;
    public static string NotHighlightAnnotationType;
    public static string ComponentNotInPresentationContext;
    public static string ComponentAlreadyInPresentationContext;
    public static string NoPresentationContextForGivenElement;
    public static string MoreThanOneAttachedAnnotation;
    public static string InvalidAttachedAnnotation;
    public static string MissingAnnotationHighlightLayer;
    public static string NoAttachedAnnotationToModify;
    public static string InvalidAttachedAnchor;
    public static string InvalidValueSpecified;
    public static string UndefinedHighlightAnchor;
    public static string UndoNotInNormalState;
    public static string UndoUnitAlreadyOpen;
    public static string UndoUnitNotOnTopOfStack;
    public static string UndoContainerTypeMismatch;
    public static string UndoUnitCantBeOpenedTwice;
    public static string UndoUnitCantBeAddedTwice;
    public static string UndoServiceDisabled;
    public static string UndoUnitLocked;
    public static string UndoNoOpenUnit;
    public static string UndoNoOpenParentUnit;
    public static string UndoUnitNotFound;
    public static string UndoManagerAlreadyAttached;
    public static string UndoUnitOpen;
    public static string TextBoxBase_CantSetIsUndoEnabledInsideChangeBlock;
    public static string TextBoxBase_UnmatchedEndChange;
    public static string TextBoxInvalidTextContainer;
    public static string TextBoxScrollViewerMarkedAsTextBoxContentMustHaveNoContent;
    public static string TextBoxDecoratorMarkedAsTextBoxContentMustHaveNoContent;
    public static string TextBoxMinMaxLinesMismatch;
    public static string TextBoxInvalidChild;
    public static string RichTextBox_DocumentBelongsToAnotherRichTextBoxAlready;
    public static string RichTextBox_PointerNotInSameDocument;
    public static string RichTextBox_CantSetDocumentInsideChangeBlock;
    public static string PasswordBoxInvalidTextContainer;
    public static string TextEditorCanNotRegisterCommandHandler;
    public static string TextEditorPropertyIsNotApplicableForTextFormatting;
    public static string TextEditorTypeOfParameterIsNotAppropriateForFormattingProperty;
    public static string TextEditorCopyPaste_EntryPartIsMissingInXamlPackage;
    public static string TextEditorSpellerInteropHasBeenDisposed;
    public static string CustomDictionarySourcesUnsupportedURI;
    public static string CustomDictionaryFailedToLoadDictionaryUri;
    public static string CustomDictionaryFailedToUnLoadDictionaryUri;
    public static string CustomDictionaryNullItem;
    public static string CustomDictionaryItemAlreadyExists;
    public static string SetLengthNotSupported;
    public static string ReadCountNegative;
    public static string WriteNotSupported;
    public static string AdornedElementNotFound;
    public static string AdornerNotFound;
    public static string ItemsSourceInUse;
    public static string CannotUseItemsSource;
    public static string ItemCollectionRemoveArgumentOutOfRange;
    public static string ItemCollectionShouldUseInnerSyncRoot;
    public static string ItemCollectionHasNoCollection;
    public static string MoreThanOneStartingParts;
    public static string CollectionAddEventMissingItem;
    public static string CannotRecyleHeterogeneousTypes;
    public static string Generator_Readme0;
    public static string Generator_Readme1;
    public static string Generator_Readme2;
    public static string Generator_Readme3;
    public static string Generator_Readme4;
    public static string Generator_Readme5;
    public static string Generator_Readme6;
    public static string Generator_Readme7;
    public static string Generator_Readme8;
    public static string Generator_Readme9;
    public static string Generator_CountIsWrong;
    public static string Generator_ItemIsWrong;
    public static string Generator_MoreErrors;
    public static string Generator_Unnamed;
    public static string Generator_Inconsistent;
    public static string CollectionView_NameTypeDuplicity;
    public static string CollectionView_ViewTypeInsufficient;
    public static string CollectionView_WrongType;
    public static string CollectionView_MissingSynchronizationCallback;
    public static string AccessCollectionAfterShutDown;
    public static string ListView_IllegalChildrenType;
    public static string ListView_NotAllowShareColumnToTwoColumnCollection;
    public static string ListView_GridViewColumnCollectionIsReadOnly;
    public static string ListView_ViewCannotBeShared;
    public static string ListView_MissingParameterlessConstructor;
    public static string DataGridCellItemAutomationPeer_NameCoreFormat;
    public static string DataGridCellItemAutomationPeer_LocalizedControlType;
    public static string DataGridColumnHeaderItemAutomationPeer_NameCoreFormat;
    public static string DataGridColumnHeaderItemAutomationPeer_Unsupported;
    public static string DataGridColumnHeaderItemAutomationPeer_Unresizable;
    public static string CalendarAutomationPeer_CalendarButtonLocalizedControlType;
    public static string CalendarAutomationPeer_DayButtonLocalizedControlType;
    public static string CalendarAutomationPeer_BlackoutDayHelpText;
    public static string Calendar_NextButtonName;
    public static string Calendar_PreviousButtonName;
    public static string DatePickerAutomationPeer_LocalizedControlType;
    public static string DatePickerTextBox_DefaultWatermarkText;
    public static string DatePicker_DropDownButtonName;
    public static string DatePicker_WatermarkText;
    public static string DataGrid_ColumnIndexOutOfRange;
    public static string DataGrid_ColumnDisplayIndexOutOfRange;
    public static string DataGrid_DisplayIndexOutOfRange;
    public static string DataGrid_InvalidColumnReuse;
    public static string DataGrid_DuplicateDisplayIndex;
    public static string DataGrid_NewColumnInvalidDisplayIndex;
    public static string DataGrid_NullColumn;
    public static string DataGrid_ReadonlyCellsItemsSource;
    public static string DataGrid_InvalidSortDescription;
    public static string DataGrid_ProbableInvalidSortDescription;
    public static string DataGrid_AutomationInvokeFailed;
    public static string DataGrid_ColumnIsReadOnly;
    public static string DataGridLength_InvalidType;
    public static string DataGridLength_Infinity;
    public static string DataGrid_CannotSelectCell;
    public static string DataGridRow_CannotSelectRowWhenCells;
    public static string SelectedCellsCollection_InvalidItem;
    public static string SelectedCellsCollection_DuplicateItem;
    public static string VirtualizedCellInfoCollection_IsReadOnly;
    public static string VirtualizedCellInfoCollection_DoesNotSupportIndexChanges;
    public static string ClipboardCopyMode_Disabled;
    public static string Calendar_OnDisplayModePropertyChanged_InvalidValue;
    public static string Calendar_OnFirstDayOfWeekChanged_InvalidValue;
    public static string Calendar_OnSelectedDateChanged_InvalidValue;
    public static string Calendar_OnSelectedDateChanged_InvalidOperation;
    public static string CalendarCollection_MultiThreadedCollectionChangeNotSupported;
    public static string Calendar_CheckSelectionMode_InvalidOperation;
    public static string Calendar_OnSelectionModeChanged_InvalidValue;
    public static string Calendar_UnSelectableDates;
    public static string DatePickerTextBox_TemplatePartIsOfIncorrectType;
    public static string DatePicker_OnSelectedDateFormatChanged_InvalidValue;
    public static string CalendarAutomationPeer_MonthMode;
    public static string CalendarAutomationPeer_YearMode;
    public static string CalendarAutomationPeer_DecadeMode;
    public static string CalendarNamePropertyValueNotValid;
    public static string SetFocusFailed;
    public static string PropertyNotSupported;
    public static string InavalidStartItem;
    public static string VirtualizedElement;
    public static string UIA_OperationCannotBePerformed;
    public static string TextProvider_InvalidPoint;
    public static string TextProvider_InvalidChildElement;
    public static string TextProvider_TextSelectionNotSupported;
    public static string TextRangeProvider_WrongTextRange;
    public static string TextRangeProvider_InvalidParameterValue;
    public static string TextRangeProvider_EmptyStringParameter;
    public static string TextViewInvalidLayout;
    public static string ThemeDictionaryExtension_Name;
    public static string ThemeDictionaryExtension_Source;
    public static string ProgressBarReadOnly;
    public static string CantShowModalOnNonInteractive;
    public static string FileDialogInvalidFilter;
    public static string FileDialogInvalidFilterIndex;
    public static string FileDialogSubClassFailure;
    public static string FileNameMustNotBeNull;
    public static string CantShowOnDifferentThread;
    public static string ResourceDictionaryIsReadOnly;
    public static string StaticResourceInXamlOnly;
    public static string ResourceDictionaryInvalidMergedDictionary;
    public static string IntegerCollectionLengthLessThanZero;
    public static string UnknownIndexType;
    public static string CantSwitchVirtualizationModePostMeasure;
    public static string PageCacheSizeNotAllowed;
    public static string Untitled;
    public static string LengthFormatError;
    public static string HostedWindowMustBeAChildWindow;
    public static string ChildWindowNotCreated;
    public static string ChildWindowMustHaveCorrectParent;
    public static string HwndHostDoesNotSupportChildKeyboardSinks;
    public static string DesignerMetadata_CustomCategory_Accessibility;
    public static string DesignerMetadata_CustomCategory_Content;
    public static string DesignerMetadata_CustomCategory_Navigation;
    public static string ToStringFormatString_Control;
    public static string ToStringFormatString_ToggleButton;
    public static string ToStringFormatString_ItemsControl;
    public static string ToStringFormatString_HeaderedContentControl;
    public static string ToStringFormatString_HeaderedItemsControl;
    public static string ToStringFormatString_RangeBase;
    public static string ToStringFormatString_GridView;
    public static string ToStringFormatString_GridViewColumn;
    public static string ToStringFormatString_GridViewRowPresenterBase;
    public static string ToStringFormatString_GridViewRowPresenter;
    public static string TextBox_ContextMenu_Cut;
    public static string TextBox_ContextMenu_Copy;
    public static string TextBox_ContextMenu_Paste;
    public static string TextBox_ContextMenu_NoSpellingSuggestions;
    public static string TextBox_ContextMenu_IgnoreAll;
    public static string TextBox_ContextMenu_More;
    public static string TextBox_ContextMenu_Description_SBCSSpace;
    public static string TextBox_ContextMenu_Description_DBCSSpace;
    public static string DocumentViewerSearchDownCompleteLabel;
    public static string DocumentViewerSearchUpCompleteLabel;
    public static string DocumentViewerSearchCompleteTitle;
    public static string DocumentViewerViewThumbnailsCommandText;
    public static string DocumentViewerViewFitToWidthCommandText;
    public static string DocumentViewerViewFitToHeightCommandText;
    public static string DocumentViewerViewFitToMaxPagesAcrossCommandText;
    public static string FlowDocumentReader_MultipleViewProvider_PageViewName;
    public static string FlowDocumentReader_MultipleViewProvider_TwoPageViewName;
    public static string FlowDocumentReader_MultipleViewProvider_ScrollViewName;
    public static string FileDialogBufferTooSmall;
    public static string FileDialogCreatePrompt;
    public static string FileDialogFileNotFound;
    public static string FileDialogInvalidFileName;
    public static string FileDialogOverwritePrompt;
    public static string NavWindowMenuCurrentPage;
    public static string InvalidStartOfBaml;
    public static string UnRecognizedBamlNodeType;
    public static string InvalidEndOfBaml;
    public static string NullParentNode;
    public static string BamlTypeIdNotFound;
    public static string BamlAssemblyIdNotFound;
    public static string InvalidLocCommentTarget;
    public static string InvalidLocCommentValue;
    public static string UnmatchedLocComment;
    public static string InvalidLocalizabilityValue;
    public static string InvalidTempFileName;
    public static string InvalidByteRanges;
    public static string ByteRangeDownloaderNotInitialized;
    public static string InvalidEventHandle;
    public static string CannotProcessInkCommand;
    public static string InvalidStickyNoteTemplate;
    public static string InvalidInkForeground;
    public static string AddAnnotationsNotImplemented;
    public static string AnnotationIsNull;
    public static string NotSupported;
    public static string InvalidAnchorPosition;
    public static string InvalidStickyNoteAnnotation;
    public static string MaximumNoteSizeExceeded;
    public static string InvalidEmptyStrokeCollection;
    public static string InvalidEmptyArray;
    public static string InvalidClipboardFormat;
    public static string InvalidPoint;
    public static string InkCanvasDeselectKey;
    public static string InkCanvasDeselectKeyDisplayString;
    public static string InvalidDiameter;
    public static string HostingStatusDownloadAppInfo;
    public static string HostingStatusVerifying;
    public static string HostingStatusDownloadApp;
    public static string HostingStatusFailed;
    public static string HostingStatusCancelled;
    public static string HostingStatusPreparingToRun;
    public static string CancelledTitle;
    public static string CancelledText;
    public static string InvalidDeployTitle;
    public static string InvalidDeployText;
    public static string PlatformRequirementTitle;
    public static string TrustNotGrantedTitle;
    public static string TrustNotGrantedText;
    public static string DeployTitle;
    public static string DeployText;
    public static string DownloadTitle;
    public static string DownloadText;
    public static string UnknownErrorTitle;
    public static string UnknownErrorText;
    public static string IncompatibleWinFXText;
    public static string IncompatibleCLRText;
    public static string SetPositionNotSupported;
    public static string SeekFailed;
    public static string SeekNotSupported;
    public static string ReadNotSupported;
    public static string BufferOffsetNegative;
    public static string BufferTooSmall;
    public static string StreamObjectDisposed;
    public static string PrintDialogPageRange;
    public static string PrintDialogZeroNotAllowed;
    public static string PrintDialogInvalidPageRange;
    public static string PartialTrustPrintDialogMustBeInvoked;
    public static string PrintDialogInstallPrintSupportCaption;
    public static string PrintDialogInstallPrintSupportMessageBox;
    public static string MediaElement_CannotSetSourceOnMediaElementDrivenByClock;
    public static string UnexpectedType;
    public static string UnexpectedProperty;
    public static string ArgumentLengthMismatch;
    public static string AttachablePropertyNotFound;
    public static string PropertyNotFound;
    public static string PropertyFoundOutsideStartElement;
    public static string PropertyOutOfOrder;
    public static string MissingTagInNamespace;
    public static string AssemblyTagMissing;
    public static string UnableToConvertInt32;
    public static string MultipleAssemblyMatches;
    public static string AssemblyIdOutOfSequence;
    public static string TypeIdOutOfSequence;
    public static string PropertyIdOutOfSequence;
    public static string StringIdOutOfSequence;
    public static string RecordOutOfOrder;
    public static string UnknownBamlRecord;
    public static string ValueMustBeXamlReader;
    public static string ExpectedBinaryContent;
    public static string DeferringLoaderNoContext;
    public static string ExpectedBamlSchemaContext;
    public static string ExpectedResourceDictionaryTarget;
    public static string DeferringLoaderNoSave;
    public static string MarkupExtensionBadStatic;
    public static string MarkupExtensionStaticMember;
    public static string JumpList_CantNestBeginInitCalls;
    public static string JumpList_CantCallUnbalancedEndInit;
    public static string JumpList_CantApplyUntilEndInit;
    public static string JumpItemsRejectedEventArgs_CountMismatch;
    public static string RuntimeTypeRequired;
    public static string AssemblyIdNegative;
    public static string KnownTypeIdNegative;
    public static string MissingTriggerProperty;
    public static string SharedAttributeInLooseXaml;
    public static string ParserMarkupExtensionInvalidClosingBracketCharacers;
    public static string ParserMarkupExtensionMalformedBracketCharacers;
}
public class System.Windows.StartupEventArgs : EventArgs {
    public String[] Args { get; }
    internal bool PerformDefaultAction { get; internal set; }
    public String[] get_Args();
    internal bool get_PerformDefaultAction();
    internal void set_PerformDefaultAction(bool value);
}
public class System.Windows.StartupEventHandler : MulticastDelegate {
    public StartupEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StartupEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StartupEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MarkupExtensionReturnTypeAttribute("System.Object")]
[LocalizabilityAttribute("17")]
public class System.Windows.StaticResourceExtension : MarkupExtension {
    [ConstructorArgumentAttribute("resourceKey")]
public object ResourceKey { get; public set; }
    internal DeferredResourceReference PrefetchedValue { get; }
    public StaticResourceExtension(object resourceKey);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public object get_ResourceKey();
    public void set_ResourceKey(object value);
    internal virtual DeferredResourceReference get_PrefetchedValue();
    internal object ProvideValueInternal(IServiceProvider serviceProvider, bool allowDeferredReference);
    internal object TryProvideValueInternal(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    internal object FindResourceInDeferredContent(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
}
[LocalizabilityAttribute("16")]
[DictionaryKeyPropertyAttribute("TargetType")]
[ContentPropertyAttribute("Setters")]
public class System.Windows.Style : DispatcherObject {
    internal static Type DefaultTargetType;
    internal ResourceDictionary _resources;
    internal int GlobalIndex;
    internal FrugalStructList`1<ChildRecord> ChildRecordFromChildIndex;
    internal FrugalStructList`1<ItemStructMap`1<TriggerSourceRecord>> TriggerSourceRecordFromChildIndex;
    internal FrugalMap PropertyTriggersWithActions;
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    internal FrugalStructList`1<ContainerDependent> ContainerDependents;
    internal FrugalStructList`1<ChildPropertyDependent> ResourceDependents;
    internal ItemStructList`1<ChildEventDependent> EventDependents;
    internal HybridDictionary _triggerActions;
    internal HybridDictionary _dataTriggerRecordFromBinding;
    internal HybridDictionary DataTriggersWithActions;
    internal static object Synchronized;
    internal static int BasedOnID;
    public bool IsSealed { get; }
    [AmbientAttribute]
[LocalizabilityAttribute("17")]
public Type TargetType { get; public set; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public Style BasedOn { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerCollection Triggers { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    internal bool HasResourceReferences { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    internal bool HasEventDependents { get; }
    internal bool HasEventSetters { get; }
    internal bool HasInstanceValues { get; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    internal bool IsBasedOnModified { get; }
    private static Style();
    public Style(Type targetType);
    public Style(Type targetType, Style basedOn);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
    public bool get_IsSealed();
    public Type get_TargetType();
    public void set_TargetType(Type value);
    public Style get_BasedOn();
    public void set_BasedOn(Style value);
    public TriggerCollection get_Triggers();
    public SetterBaseCollection get_Setters();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    internal object FindResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal ResourceDictionary FindResourceDictionary(object resourceKey);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal void CheckTargetType(object element);
    public void Seal();
    public virtual int GetHashCode();
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal bool get_HasResourceReferences();
    internal EventHandlersStore get_EventHandlersStore();
    internal bool get_HasEventDependents();
    internal bool get_HasEventSetters();
    internal bool get_HasInstanceValues();
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    internal bool get_IsBasedOnModified();
    internal bool IsModified(int id);
}
internal static class System.Windows.StyleHelper : object {
    internal static UncommonField`1<HybridDictionary[]> StyleDataField;
    internal static UncommonField`1<HybridDictionary[]> TemplateDataField;
    internal static UncommonField`1<HybridDictionary> ParentTemplateValuesField;
    internal static UncommonField`1<HybridDictionary[]> ThemeStyleDataField;
    internal static UncommonField`1<List`1<DependencyObject>> TemplatedFeChildrenField;
    internal static UncommonField`1<Hashtable> TemplatedNonFeChildrenField;
    internal static string SelfName;
    internal static FrugalStructList`1<ContainerDependent> EmptyContainerDependents;
    internal static object NotYetApplied;
    internal static RoutedEventHandler EventTriggerHandlerOnContainer;
    internal static RoutedEventHandler EventTriggerHandlerOnChild;
    internal static int UnsharedTemplateContentPropertyIndex;
    private static StyleHelper();
    internal static void UpdateStyleCache(FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle, Style& styleCache);
    internal static void UpdateThemeStyleCache(FrameworkElement fe, FrameworkContentElement fce, Style oldThemeStyle, Style newThemeStyle, Style& themeStyleCache);
    internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement fce);
    internal static void UpdateTemplateCache(FrameworkElement fe, FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate, DependencyProperty templateProperty);
    internal static void SealTemplate(FrameworkTemplate frameworkTemplate, Boolean& isSealed, FrameworkElementFactory templateRoot, TriggerCollection triggers, ResourceDictionary resources, HybridDictionary childIndexFromChildID, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& containerDependents, FrugalStructList`1& resourceDependents, ItemStructList`1& eventDependents, HybridDictionary& triggerActions, HybridDictionary& dataTriggerRecordFromBinding, Boolean& hasInstanceValues, EventHandlersStore& eventHandlersStore);
    internal static void UpdateTables(PropertyValue& propertyValue, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, HybridDictionary& dataTriggerRecordFromBinding, HybridDictionary childIndexFromChildName, Boolean& hasInstanceValues);
    internal static void AddContainerDependent(DependencyProperty dp, bool fromVisualTrigger, FrugalStructList`1& containerDependents);
    internal static void AddEventDependent(int childIndex, EventHandlersStore eventHandlersStore, ItemStructList`1& eventDependents);
    internal static void ProcessTemplateContentFromFEF(FrameworkElementFactory factory, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, ItemStructList`1& eventDependents, HybridDictionary& dataTriggerRecordFromBinding, HybridDictionary childIndexFromChildID, Boolean& hasInstanceValues);
    internal static void ProcessEventTrigger(EventTrigger eventTrigger, HybridDictionary childIndexFromChildName, HybridDictionary& triggerActions, ItemStructList`1& eventDependents, FrameworkElementFactory templateRoot, FrameworkTemplate frameworkTemplate, EventHandlersStore& eventHandlersStore, Boolean& hasLoadedChangeHandler);
    internal static void SealIfSealable(object value);
    internal static void UpdateInstanceData(UncommonField`1<HybridDictionary[]> dataField, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle, FrameworkTemplate oldFrameworkTemplate, FrameworkTemplate newFrameworkTemplate, InternalFlags hasGeneratedSubTreeFlag);
    internal static void CreateInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style newStyle, FrameworkTemplate newFrameworkTemplate);
    internal static void CreateInstanceDataForChild(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, DependencyObject child, int childIndex, bool hasInstanceValues, FrugalStructList`1& childRecordFromChildIndex);
    internal static void ReleaseInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, FrameworkTemplate oldFrameworkTemplate, InternalFlags hasGeneratedSubTreeFlag);
    internal static HybridDictionary EnsureInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, InstanceStyleData dataType);
    internal static HybridDictionary EnsureInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, InstanceStyleData dataType, int initialSize);
    internal static void ProcessInstanceValue(DependencyObject target, int childIndex, HybridDictionary instanceValues, DependencyProperty dp, int i, bool apply);
    internal static bool ApplyTemplateContent(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElementFactory templateRoot, int lastChildIndex, HybridDictionary childIndexFromChildID, FrameworkTemplate frameworkTemplate);
    internal static void AddCustomTemplateRoot(FrameworkElement container, UIElement child);
    internal static void AddCustomTemplateRoot(FrameworkElement container, UIElement child, bool checkVisualParent, bool mustCacheTreeStateOnChild);
    internal static void ClearGeneratedSubTree(HybridDictionary[] instanceData, FrameworkElement feContainer, FrameworkContentElement fceContainer, FrameworkTemplate oldFrameworkTemplate);
    internal static void SpecialDowncastToFEorFCE(DependencyObject d, FrameworkElement& fe, FrameworkContentElement& fce, bool throwIfNeither);
    internal static FrameworkElementFactory FindFEF(FrameworkElementFactory root, int childIndex);
    internal static object GetChildValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, int childIndex, FrameworkObject child, DependencyProperty dp, FrugalStructList`1& childRecordFromChildIndex, EffectiveValueEntry& entry, ValueLookupType& sourceType, FrameworkElementFactory templateRoot);
    internal static object GetDataTriggerValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, BindingBase binding);
    internal static object GetInstanceValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement feChild, FrameworkContentElement fceChild, int childIndex, DependencyProperty dp, int i, EffectiveValueEntry& entry);
    internal static bool ShouldGetValueFromStyle(DependencyProperty dp);
    internal static bool ShouldGetValueFromThemeStyle(DependencyProperty dp);
    internal static bool ShouldGetValueFromTemplate(DependencyProperty dp);
    internal static void DoStyleInvalidations(FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle);
    internal static void DoThemeStyleInvalidations(FrameworkElement fe, FrameworkContentElement fce, Style oldThemeStyle, Style newThemeStyle, Style style);
    internal static void DoTemplateInvalidations(FrameworkElement feContainer, FrameworkTemplate oldFrameworkTemplate);
    internal static void DoStyleResourcesInvalidations(DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle);
    internal static void DoTemplateResourcesInvalidations(DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, object oldTemplate, object newTemplate);
    internal static void UpdateLoadedFlag(DependencyObject d, Style oldStyle, Style newStyle);
    internal static void UpdateLoadedFlag(DependencyObject d, FrameworkTemplate oldFrameworkTemplate, FrameworkTemplate newFrameworkTemplate);
    internal static void InvalidateContainerDependents(DependencyObject container, FrugalStructList`1& exclusionContainerDependents, FrugalStructList`1& oldContainerDependents, FrugalStructList`1& newContainerDependents);
    internal static void ApplyTemplatedParentValue(DependencyObject container, FrameworkObject child, int childIndex, FrugalStructList`1& childRecordFromChildIndex, DependencyProperty dp, FrameworkElementFactory templateRoot);
    internal static bool IsValueDynamic(DependencyObject container, int childIndex, DependencyProperty dp);
    internal static bool GetValueFromTemplatedParent(DependencyObject container, int childIndex, FrameworkObject child, DependencyProperty dp, FrugalStructList`1& childRecordFromChildIndex, FrameworkElementFactory templateRoot, EffectiveValueEntry& entry);
    internal static void ApplyStyleOrTemplateValue(FrameworkObject fo, DependencyProperty dp);
    internal static bool GetValueFromStyleOrTemplate(FrameworkObject fo, DependencyProperty dp, EffectiveValueEntry& entry);
    internal static void SortResourceDependents(FrugalStructList`1& resourceDependents);
    internal static void InvalidateResourceDependents(DependencyObject container, ResourcesChangeInfo info, FrugalStructList`1& resourceDependents, bool invalidateVisualTreeToo);
    internal static void InvalidateResourceDependentsForChild(DependencyObject container, DependencyObject child, int childIndex, ResourcesChangeInfo info, FrameworkTemplate parentTemplate);
    internal static bool HasResourceDependentsForChild(int childIndex, FrugalStructList`1& resourceDependents);
    internal static void InvalidatePropertiesOnTemplateNode(DependencyObject container, FrameworkObject child, int childIndex, FrugalStructList`1& childRecordFromChildIndex, bool isDetach, FrameworkElementFactory templateRoot);
    internal static bool IsSetOnContainer(DependencyProperty dp, FrugalStructList`1& containerDependents, bool alsoFromTriggers);
    internal static void OnTriggerSourcePropertyInvalidated(Style ownerStyle, FrameworkTemplate frameworkTemplate, DependencyObject container, DependencyProperty dp, DependencyPropertyChangedEventArgs changedArgs, bool invalidateOnlyContainer, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalMap& propertyTriggersWithActions, int sourceChildIndex);
    internal static void InvokeDeferredActions(DependencyObject triggerContainer, FrameworkTemplate frameworkTemplate);
    internal static void InvokeActions(TriggerBase triggerBase, DependencyObject triggerContainer, TriggerActionCollection actions, Style style, FrameworkTemplate frameworkTemplate);
    internal static void AddPropertyTriggerWithAction(TriggerBase triggerBase, DependencyProperty property, FrugalMap& triggersWithActions);
    internal static void AddDataTriggerWithAction(TriggerBase triggerBase, BindingBase binding, HybridDictionary& dataTriggersWithActions);
    internal static int CreateChildIndexFromChildName(string childName, FrameworkTemplate frameworkTemplate);
    internal static int QueryChildIndexFromChildName(string childName, HybridDictionary childIndexFromChildName);
    internal static object FindNameInTemplateContent(DependencyObject container, string childName, FrameworkTemplate frameworkTemplate);
    internal static DependencyObject GetChild(DependencyObject container, int childIndex);
    internal static DependencyObject GetChild(List`1<DependencyObject> styledChildren, int childIndex);
    internal static void RegisterAlternateExpressionStorage();
    internal static Expression GetExpression(DependencyObject d, DependencyProperty dp);
    internal static RoutedEventHandlerInfo[] GetChildRoutedEventHandlers(int childIndex, RoutedEvent routedEvent, ItemStructList`1& eventDependents);
    internal static bool IsStylingLogicalTree(DependencyProperty dp, object value);
}
[AttributeUsageAttribute("4")]
public class System.Windows.StyleTypedPropertyAttribute : Attribute {
    public string Property { get; public set; }
    public Type StyleTargetType { get; public set; }
    public string get_Property();
    public void set_Property(string value);
    public Type get_StyleTargetType();
    public void set_StyleTargetType(Type value);
}
public static class System.Windows.SystemColors : object {
    public static Color ActiveBorderColor { get; }
    public static Color ActiveCaptionColor { get; }
    public static Color ActiveCaptionTextColor { get; }
    public static Color AppWorkspaceColor { get; }
    public static Color ControlColor { get; }
    public static Color ControlDarkColor { get; }
    public static Color ControlDarkDarkColor { get; }
    public static Color ControlLightColor { get; }
    public static Color ControlLightLightColor { get; }
    public static Color ControlTextColor { get; }
    public static Color DesktopColor { get; }
    public static Color GradientActiveCaptionColor { get; }
    public static Color GradientInactiveCaptionColor { get; }
    public static Color GrayTextColor { get; }
    public static Color HighlightColor { get; }
    public static Color HighlightTextColor { get; }
    public static Color HotTrackColor { get; }
    public static Color InactiveBorderColor { get; }
    public static Color InactiveCaptionColor { get; }
    public static Color InactiveCaptionTextColor { get; }
    public static Color InfoColor { get; }
    public static Color InfoTextColor { get; }
    public static Color MenuColor { get; }
    public static Color MenuBarColor { get; }
    public static Color MenuHighlightColor { get; }
    public static Color MenuTextColor { get; }
    public static Color ScrollBarColor { get; }
    public static Color WindowColor { get; }
    public static Color WindowFrameColor { get; }
    public static Color WindowTextColor { get; }
    public static ResourceKey ActiveBorderColorKey { get; }
    public static ResourceKey ActiveCaptionColorKey { get; }
    public static ResourceKey ActiveCaptionTextColorKey { get; }
    public static ResourceKey AppWorkspaceColorKey { get; }
    public static ResourceKey ControlColorKey { get; }
    public static ResourceKey ControlDarkColorKey { get; }
    public static ResourceKey ControlDarkDarkColorKey { get; }
    public static ResourceKey ControlLightColorKey { get; }
    public static ResourceKey ControlLightLightColorKey { get; }
    public static ResourceKey ControlTextColorKey { get; }
    public static ResourceKey DesktopColorKey { get; }
    public static ResourceKey GradientActiveCaptionColorKey { get; }
    public static ResourceKey GradientInactiveCaptionColorKey { get; }
    public static ResourceKey GrayTextColorKey { get; }
    public static ResourceKey HighlightColorKey { get; }
    public static ResourceKey HighlightTextColorKey { get; }
    public static ResourceKey HotTrackColorKey { get; }
    public static ResourceKey InactiveBorderColorKey { get; }
    public static ResourceKey InactiveCaptionColorKey { get; }
    public static ResourceKey InactiveCaptionTextColorKey { get; }
    public static ResourceKey InfoColorKey { get; }
    public static ResourceKey InfoTextColorKey { get; }
    public static ResourceKey MenuColorKey { get; }
    public static ResourceKey MenuBarColorKey { get; }
    public static ResourceKey MenuHighlightColorKey { get; }
    public static ResourceKey MenuTextColorKey { get; }
    public static ResourceKey ScrollBarColorKey { get; }
    public static ResourceKey WindowColorKey { get; }
    public static ResourceKey WindowFrameColorKey { get; }
    public static ResourceKey WindowTextColorKey { get; }
    public static SolidColorBrush ActiveBorderBrush { get; }
    public static SolidColorBrush ActiveCaptionBrush { get; }
    public static SolidColorBrush ActiveCaptionTextBrush { get; }
    public static SolidColorBrush AppWorkspaceBrush { get; }
    public static SolidColorBrush ControlBrush { get; }
    public static SolidColorBrush ControlDarkBrush { get; }
    public static SolidColorBrush ControlDarkDarkBrush { get; }
    public static SolidColorBrush ControlLightBrush { get; }
    public static SolidColorBrush ControlLightLightBrush { get; }
    public static SolidColorBrush ControlTextBrush { get; }
    public static SolidColorBrush DesktopBrush { get; }
    public static SolidColorBrush GradientActiveCaptionBrush { get; }
    public static SolidColorBrush GradientInactiveCaptionBrush { get; }
    public static SolidColorBrush GrayTextBrush { get; }
    public static SolidColorBrush HighlightBrush { get; }
    public static SolidColorBrush HighlightTextBrush { get; }
    public static SolidColorBrush HotTrackBrush { get; }
    public static SolidColorBrush InactiveBorderBrush { get; }
    public static SolidColorBrush InactiveCaptionBrush { get; }
    public static SolidColorBrush InactiveCaptionTextBrush { get; }
    public static SolidColorBrush InfoBrush { get; }
    public static SolidColorBrush InfoTextBrush { get; }
    public static SolidColorBrush MenuBrush { get; }
    public static SolidColorBrush MenuBarBrush { get; }
    public static SolidColorBrush MenuHighlightBrush { get; }
    public static SolidColorBrush MenuTextBrush { get; }
    public static SolidColorBrush ScrollBarBrush { get; }
    public static SolidColorBrush WindowBrush { get; }
    public static SolidColorBrush WindowFrameBrush { get; }
    public static SolidColorBrush WindowTextBrush { get; }
    public static SolidColorBrush InactiveSelectionHighlightBrush { get; }
    public static SolidColorBrush InactiveSelectionHighlightTextBrush { get; }
    public static ResourceKey ActiveBorderBrushKey { get; }
    public static ResourceKey ActiveCaptionBrushKey { get; }
    public static ResourceKey ActiveCaptionTextBrushKey { get; }
    public static ResourceKey AppWorkspaceBrushKey { get; }
    public static ResourceKey ControlBrushKey { get; }
    public static ResourceKey ControlDarkBrushKey { get; }
    public static ResourceKey ControlDarkDarkBrushKey { get; }
    public static ResourceKey ControlLightBrushKey { get; }
    public static ResourceKey ControlLightLightBrushKey { get; }
    public static ResourceKey ControlTextBrushKey { get; }
    public static ResourceKey DesktopBrushKey { get; }
    public static ResourceKey GradientActiveCaptionBrushKey { get; }
    public static ResourceKey GradientInactiveCaptionBrushKey { get; }
    public static ResourceKey GrayTextBrushKey { get; }
    public static ResourceKey HighlightBrushKey { get; }
    public static ResourceKey HighlightTextBrushKey { get; }
    public static ResourceKey HotTrackBrushKey { get; }
    public static ResourceKey InactiveBorderBrushKey { get; }
    public static ResourceKey InactiveCaptionBrushKey { get; }
    public static ResourceKey InactiveCaptionTextBrushKey { get; }
    public static ResourceKey InfoBrushKey { get; }
    public static ResourceKey InfoTextBrushKey { get; }
    public static ResourceKey MenuBrushKey { get; }
    public static ResourceKey MenuBarBrushKey { get; }
    public static ResourceKey MenuHighlightBrushKey { get; }
    public static ResourceKey MenuTextBrushKey { get; }
    public static ResourceKey ScrollBarBrushKey { get; }
    public static ResourceKey WindowBrushKey { get; }
    public static ResourceKey WindowFrameBrushKey { get; }
    public static ResourceKey WindowTextBrushKey { get; }
    public static ResourceKey InactiveSelectionHighlightBrushKey { get; }
    public static ResourceKey InactiveSelectionHighlightTextBrushKey { get; }
    private static SystemColors();
    public static Color get_ActiveBorderColor();
    public static Color get_ActiveCaptionColor();
    public static Color get_ActiveCaptionTextColor();
    public static Color get_AppWorkspaceColor();
    public static Color get_ControlColor();
    public static Color get_ControlDarkColor();
    public static Color get_ControlDarkDarkColor();
    public static Color get_ControlLightColor();
    public static Color get_ControlLightLightColor();
    public static Color get_ControlTextColor();
    public static Color get_DesktopColor();
    public static Color get_GradientActiveCaptionColor();
    public static Color get_GradientInactiveCaptionColor();
    public static Color get_GrayTextColor();
    public static Color get_HighlightColor();
    public static Color get_HighlightTextColor();
    public static Color get_HotTrackColor();
    public static Color get_InactiveBorderColor();
    public static Color get_InactiveCaptionColor();
    public static Color get_InactiveCaptionTextColor();
    public static Color get_InfoColor();
    public static Color get_InfoTextColor();
    public static Color get_MenuColor();
    public static Color get_MenuBarColor();
    public static Color get_MenuHighlightColor();
    public static Color get_MenuTextColor();
    public static Color get_ScrollBarColor();
    public static Color get_WindowColor();
    public static Color get_WindowFrameColor();
    public static Color get_WindowTextColor();
    public static ResourceKey get_ActiveBorderColorKey();
    public static ResourceKey get_ActiveCaptionColorKey();
    public static ResourceKey get_ActiveCaptionTextColorKey();
    public static ResourceKey get_AppWorkspaceColorKey();
    public static ResourceKey get_ControlColorKey();
    public static ResourceKey get_ControlDarkColorKey();
    public static ResourceKey get_ControlDarkDarkColorKey();
    public static ResourceKey get_ControlLightColorKey();
    public static ResourceKey get_ControlLightLightColorKey();
    public static ResourceKey get_ControlTextColorKey();
    public static ResourceKey get_DesktopColorKey();
    public static ResourceKey get_GradientActiveCaptionColorKey();
    public static ResourceKey get_GradientInactiveCaptionColorKey();
    public static ResourceKey get_GrayTextColorKey();
    public static ResourceKey get_HighlightColorKey();
    public static ResourceKey get_HighlightTextColorKey();
    public static ResourceKey get_HotTrackColorKey();
    public static ResourceKey get_InactiveBorderColorKey();
    public static ResourceKey get_InactiveCaptionColorKey();
    public static ResourceKey get_InactiveCaptionTextColorKey();
    public static ResourceKey get_InfoColorKey();
    public static ResourceKey get_InfoTextColorKey();
    public static ResourceKey get_MenuColorKey();
    public static ResourceKey get_MenuBarColorKey();
    public static ResourceKey get_MenuHighlightColorKey();
    public static ResourceKey get_MenuTextColorKey();
    public static ResourceKey get_ScrollBarColorKey();
    public static ResourceKey get_WindowColorKey();
    public static ResourceKey get_WindowFrameColorKey();
    public static ResourceKey get_WindowTextColorKey();
    public static SolidColorBrush get_ActiveBorderBrush();
    public static SolidColorBrush get_ActiveCaptionBrush();
    public static SolidColorBrush get_ActiveCaptionTextBrush();
    public static SolidColorBrush get_AppWorkspaceBrush();
    public static SolidColorBrush get_ControlBrush();
    public static SolidColorBrush get_ControlDarkBrush();
    public static SolidColorBrush get_ControlDarkDarkBrush();
    public static SolidColorBrush get_ControlLightBrush();
    public static SolidColorBrush get_ControlLightLightBrush();
    public static SolidColorBrush get_ControlTextBrush();
    public static SolidColorBrush get_DesktopBrush();
    public static SolidColorBrush get_GradientActiveCaptionBrush();
    public static SolidColorBrush get_GradientInactiveCaptionBrush();
    public static SolidColorBrush get_GrayTextBrush();
    public static SolidColorBrush get_HighlightBrush();
    public static SolidColorBrush get_HighlightTextBrush();
    public static SolidColorBrush get_HotTrackBrush();
    public static SolidColorBrush get_InactiveBorderBrush();
    public static SolidColorBrush get_InactiveCaptionBrush();
    public static SolidColorBrush get_InactiveCaptionTextBrush();
    public static SolidColorBrush get_InfoBrush();
    public static SolidColorBrush get_InfoTextBrush();
    public static SolidColorBrush get_MenuBrush();
    public static SolidColorBrush get_MenuBarBrush();
    public static SolidColorBrush get_MenuHighlightBrush();
    public static SolidColorBrush get_MenuTextBrush();
    public static SolidColorBrush get_ScrollBarBrush();
    public static SolidColorBrush get_WindowBrush();
    public static SolidColorBrush get_WindowFrameBrush();
    public static SolidColorBrush get_WindowTextBrush();
    public static SolidColorBrush get_InactiveSelectionHighlightBrush();
    public static SolidColorBrush get_InactiveSelectionHighlightTextBrush();
    public static ResourceKey get_ActiveBorderBrushKey();
    public static ResourceKey get_ActiveCaptionBrushKey();
    public static ResourceKey get_ActiveCaptionTextBrushKey();
    public static ResourceKey get_AppWorkspaceBrushKey();
    public static ResourceKey get_ControlBrushKey();
    public static ResourceKey get_ControlDarkBrushKey();
    public static ResourceKey get_ControlDarkDarkBrushKey();
    public static ResourceKey get_ControlLightBrushKey();
    public static ResourceKey get_ControlLightLightBrushKey();
    public static ResourceKey get_ControlTextBrushKey();
    public static ResourceKey get_DesktopBrushKey();
    public static ResourceKey get_GradientActiveCaptionBrushKey();
    public static ResourceKey get_GradientInactiveCaptionBrushKey();
    public static ResourceKey get_GrayTextBrushKey();
    public static ResourceKey get_HighlightBrushKey();
    public static ResourceKey get_HighlightTextBrushKey();
    public static ResourceKey get_HotTrackBrushKey();
    public static ResourceKey get_InactiveBorderBrushKey();
    public static ResourceKey get_InactiveCaptionBrushKey();
    public static ResourceKey get_InactiveCaptionTextBrushKey();
    public static ResourceKey get_InfoBrushKey();
    public static ResourceKey get_InfoTextBrushKey();
    public static ResourceKey get_MenuBrushKey();
    public static ResourceKey get_MenuBarBrushKey();
    public static ResourceKey get_MenuHighlightBrushKey();
    public static ResourceKey get_MenuTextBrushKey();
    public static ResourceKey get_ScrollBarBrushKey();
    public static ResourceKey get_WindowBrushKey();
    public static ResourceKey get_WindowFrameBrushKey();
    public static ResourceKey get_WindowTextBrushKey();
    public static ResourceKey get_InactiveSelectionHighlightBrushKey();
    public static ResourceKey get_InactiveSelectionHighlightTextBrushKey();
    internal static bool InvalidateCache();
}
public static class System.Windows.SystemCommands : object {
    public static RoutedCommand CloseWindowCommand { get; private set; }
    public static RoutedCommand MaximizeWindowCommand { get; private set; }
    public static RoutedCommand MinimizeWindowCommand { get; private set; }
    public static RoutedCommand RestoreWindowCommand { get; private set; }
    public static RoutedCommand ShowSystemMenuCommand { get; private set; }
    private static SystemCommands();
    [CompilerGeneratedAttribute]
public static RoutedCommand get_CloseWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_CloseWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MaximizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MaximizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MinimizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MinimizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_RestoreWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_RestoreWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_ShowSystemMenuCommand();
    [CompilerGeneratedAttribute]
private static void set_ShowSystemMenuCommand(RoutedCommand value);
    [SecuritySafeCriticalAttribute]
public static void CloseWindow(Window window);
    [SecuritySafeCriticalAttribute]
public static void MaximizeWindow(Window window);
    [SecuritySafeCriticalAttribute]
public static void MinimizeWindow(Window window);
    [SecuritySafeCriticalAttribute]
public static void RestoreWindow(Window window);
    [SecuritySafeCriticalAttribute]
public static void ShowSystemMenu(Window window, Point screenLocation);
    [SecurityCriticalAttribute]
internal static void ShowSystemMenuPhysicalCoordinates(Window window, Point physicalScreenLocation);
}
public static class System.Windows.SystemFonts : object {
    public static double IconFontSize { get; }
    public static FontFamily IconFontFamily { get; }
    public static FontStyle IconFontStyle { get; }
    public static FontWeight IconFontWeight { get; }
    public static TextDecorationCollection IconFontTextDecorations { get; }
    public static double CaptionFontSize { get; }
    public static FontFamily CaptionFontFamily { get; }
    public static FontStyle CaptionFontStyle { get; }
    public static FontWeight CaptionFontWeight { get; }
    public static TextDecorationCollection CaptionFontTextDecorations { get; }
    public static double SmallCaptionFontSize { get; }
    public static FontFamily SmallCaptionFontFamily { get; }
    public static FontStyle SmallCaptionFontStyle { get; }
    public static FontWeight SmallCaptionFontWeight { get; }
    public static TextDecorationCollection SmallCaptionFontTextDecorations { get; }
    public static double MenuFontSize { get; }
    public static FontFamily MenuFontFamily { get; }
    public static FontStyle MenuFontStyle { get; }
    public static FontWeight MenuFontWeight { get; }
    public static TextDecorationCollection MenuFontTextDecorations { get; }
    public static double StatusFontSize { get; }
    public static FontFamily StatusFontFamily { get; }
    public static FontStyle StatusFontStyle { get; }
    public static FontWeight StatusFontWeight { get; }
    public static TextDecorationCollection StatusFontTextDecorations { get; }
    public static double MessageFontSize { get; }
    public static FontFamily MessageFontFamily { get; }
    public static FontStyle MessageFontStyle { get; }
    public static FontWeight MessageFontWeight { get; }
    public static TextDecorationCollection MessageFontTextDecorations { get; }
    public static ResourceKey IconFontSizeKey { get; }
    public static ResourceKey IconFontFamilyKey { get; }
    public static ResourceKey IconFontStyleKey { get; }
    public static ResourceKey IconFontWeightKey { get; }
    public static ResourceKey IconFontTextDecorationsKey { get; }
    public static ResourceKey CaptionFontSizeKey { get; }
    public static ResourceKey CaptionFontFamilyKey { get; }
    public static ResourceKey CaptionFontStyleKey { get; }
    public static ResourceKey CaptionFontWeightKey { get; }
    public static ResourceKey CaptionFontTextDecorationsKey { get; }
    public static ResourceKey SmallCaptionFontSizeKey { get; }
    public static ResourceKey SmallCaptionFontFamilyKey { get; }
    public static ResourceKey SmallCaptionFontStyleKey { get; }
    public static ResourceKey SmallCaptionFontWeightKey { get; }
    public static ResourceKey SmallCaptionFontTextDecorationsKey { get; }
    public static ResourceKey MenuFontSizeKey { get; }
    public static ResourceKey MenuFontFamilyKey { get; }
    public static ResourceKey MenuFontStyleKey { get; }
    public static ResourceKey MenuFontWeightKey { get; }
    public static ResourceKey MenuFontTextDecorationsKey { get; }
    public static ResourceKey StatusFontSizeKey { get; }
    public static ResourceKey StatusFontFamilyKey { get; }
    public static ResourceKey StatusFontStyleKey { get; }
    public static ResourceKey StatusFontWeightKey { get; }
    public static ResourceKey StatusFontTextDecorationsKey { get; }
    public static ResourceKey MessageFontSizeKey { get; }
    public static ResourceKey MessageFontFamilyKey { get; }
    public static ResourceKey MessageFontStyleKey { get; }
    public static ResourceKey MessageFontWeightKey { get; }
    public static ResourceKey MessageFontTextDecorationsKey { get; }
    public static double get_IconFontSize();
    public static FontFamily get_IconFontFamily();
    public static FontStyle get_IconFontStyle();
    public static FontWeight get_IconFontWeight();
    public static TextDecorationCollection get_IconFontTextDecorations();
    public static double get_CaptionFontSize();
    public static FontFamily get_CaptionFontFamily();
    public static FontStyle get_CaptionFontStyle();
    public static FontWeight get_CaptionFontWeight();
    public static TextDecorationCollection get_CaptionFontTextDecorations();
    public static double get_SmallCaptionFontSize();
    public static FontFamily get_SmallCaptionFontFamily();
    public static FontStyle get_SmallCaptionFontStyle();
    public static FontWeight get_SmallCaptionFontWeight();
    public static TextDecorationCollection get_SmallCaptionFontTextDecorations();
    public static double get_MenuFontSize();
    public static FontFamily get_MenuFontFamily();
    public static FontStyle get_MenuFontStyle();
    public static FontWeight get_MenuFontWeight();
    public static TextDecorationCollection get_MenuFontTextDecorations();
    public static double get_StatusFontSize();
    public static FontFamily get_StatusFontFamily();
    public static FontStyle get_StatusFontStyle();
    public static FontWeight get_StatusFontWeight();
    public static TextDecorationCollection get_StatusFontTextDecorations();
    public static double get_MessageFontSize();
    public static FontFamily get_MessageFontFamily();
    public static FontStyle get_MessageFontStyle();
    public static FontWeight get_MessageFontWeight();
    public static TextDecorationCollection get_MessageFontTextDecorations();
    public static ResourceKey get_IconFontSizeKey();
    public static ResourceKey get_IconFontFamilyKey();
    public static ResourceKey get_IconFontStyleKey();
    public static ResourceKey get_IconFontWeightKey();
    public static ResourceKey get_IconFontTextDecorationsKey();
    public static ResourceKey get_CaptionFontSizeKey();
    public static ResourceKey get_CaptionFontFamilyKey();
    public static ResourceKey get_CaptionFontStyleKey();
    public static ResourceKey get_CaptionFontWeightKey();
    public static ResourceKey get_CaptionFontTextDecorationsKey();
    public static ResourceKey get_SmallCaptionFontSizeKey();
    public static ResourceKey get_SmallCaptionFontFamilyKey();
    public static ResourceKey get_SmallCaptionFontStyleKey();
    public static ResourceKey get_SmallCaptionFontWeightKey();
    public static ResourceKey get_SmallCaptionFontTextDecorationsKey();
    public static ResourceKey get_MenuFontSizeKey();
    public static ResourceKey get_MenuFontFamilyKey();
    public static ResourceKey get_MenuFontStyleKey();
    public static ResourceKey get_MenuFontWeightKey();
    public static ResourceKey get_MenuFontTextDecorationsKey();
    public static ResourceKey get_StatusFontSizeKey();
    public static ResourceKey get_StatusFontFamilyKey();
    public static ResourceKey get_StatusFontStyleKey();
    public static ResourceKey get_StatusFontWeightKey();
    public static ResourceKey get_StatusFontTextDecorationsKey();
    public static ResourceKey get_MessageFontSizeKey();
    public static ResourceKey get_MessageFontFamilyKey();
    public static ResourceKey get_MessageFontStyleKey();
    public static ResourceKey get_MessageFontWeightKey();
    public static ResourceKey get_MessageFontTextDecorationsKey();
    internal static void InvalidateIconMetrics();
    internal static void InvalidateNonClientMetrics();
}
public static class System.Windows.SystemParameters : object {
    public static double FocusBorderWidth { get; }
    public static double FocusBorderHeight { get; }
    public static bool HighContrast { get; }
    internal static bool MouseVanish { get; }
    public static ResourceKey FocusBorderWidthKey { get; }
    public static ResourceKey FocusBorderHeightKey { get; }
    public static ResourceKey HighContrastKey { get; }
    public static bool DropShadow { get; }
    public static bool FlatMenu { get; }
    internal static RECT WorkAreaInternal { get; }
    public static Rect WorkArea { get; }
    public static ResourceKey DropShadowKey { get; }
    public static ResourceKey FlatMenuKey { get; }
    public static ResourceKey WorkAreaKey { get; }
    internal static ICONMETRICS IconMetrics { get; }
    public static double IconHorizontalSpacing { get; }
    public static double IconVerticalSpacing { get; }
    public static bool IconTitleWrap { get; }
    public static ResourceKey IconHorizontalSpacingKey { get; }
    public static ResourceKey IconVerticalSpacingKey { get; }
    public static ResourceKey IconTitleWrapKey { get; }
    public static bool KeyboardCues { get; }
    public static int KeyboardDelay { get; }
    public static bool KeyboardPreference { get; }
    public static int KeyboardSpeed { get; }
    public static bool SnapToDefaultButton { get; }
    public static int WheelScrollLines { get; }
    public static TimeSpan MouseHoverTime { get; }
    internal static int MouseHoverTimeMilliseconds { get; }
    public static double MouseHoverHeight { get; }
    public static double MouseHoverWidth { get; }
    public static ResourceKey KeyboardCuesKey { get; }
    public static ResourceKey KeyboardDelayKey { get; }
    public static ResourceKey KeyboardPreferenceKey { get; }
    public static ResourceKey KeyboardSpeedKey { get; }
    public static ResourceKey SnapToDefaultButtonKey { get; }
    public static ResourceKey WheelScrollLinesKey { get; }
    public static ResourceKey MouseHoverTimeKey { get; }
    public static ResourceKey MouseHoverHeightKey { get; }
    public static ResourceKey MouseHoverWidthKey { get; }
    public static bool MenuDropAlignment { get; }
    public static bool MenuFade { get; }
    public static int MenuShowDelay { get; }
    public static ResourceKey MenuDropAlignmentKey { get; }
    public static ResourceKey MenuFadeKey { get; }
    public static ResourceKey MenuShowDelayKey { get; }
    public static PopupAnimation ComboBoxPopupAnimation { get; }
    public static bool ComboBoxAnimation { get; }
    public static bool ClientAreaAnimation { get; }
    public static bool CursorShadow { get; }
    public static bool GradientCaptions { get; }
    public static bool HotTracking { get; }
    public static bool ListBoxSmoothScrolling { get; }
    public static PopupAnimation MenuPopupAnimation { get; }
    public static bool MenuAnimation { get; }
    public static bool SelectionFade { get; }
    public static bool StylusHotTracking { get; }
    public static PopupAnimation ToolTipPopupAnimation { get; }
    public static bool ToolTipAnimation { get; }
    public static bool ToolTipFade { get; }
    public static bool UIEffects { get; }
    public static ResourceKey ComboBoxAnimationKey { get; }
    public static ResourceKey ClientAreaAnimationKey { get; }
    public static ResourceKey CursorShadowKey { get; }
    public static ResourceKey GradientCaptionsKey { get; }
    public static ResourceKey HotTrackingKey { get; }
    public static ResourceKey ListBoxSmoothScrollingKey { get; }
    public static ResourceKey MenuAnimationKey { get; }
    public static ResourceKey SelectionFadeKey { get; }
    public static ResourceKey StylusHotTrackingKey { get; }
    public static ResourceKey ToolTipAnimationKey { get; }
    public static ResourceKey ToolTipFadeKey { get; }
    public static ResourceKey UIEffectsKey { get; }
    public static ResourceKey ComboBoxPopupAnimationKey { get; }
    public static ResourceKey MenuPopupAnimationKey { get; }
    public static ResourceKey ToolTipPopupAnimationKey { get; }
    public static bool MinimizeAnimation { get; }
    public static int Border { get; }
    public static double CaretWidth { get; }
    public static bool DragFullWindows { get; }
    public static int ForegroundFlashCount { get; }
    internal static NONCLIENTMETRICS NonClientMetrics { get; }
    public static double BorderWidth { get; }
    public static double ScrollWidth { get; }
    public static double ScrollHeight { get; }
    public static double CaptionWidth { get; }
    public static double CaptionHeight { get; }
    public static double SmallCaptionWidth { get; }
    public static double SmallCaptionHeight { get; }
    public static double MenuWidth { get; }
    public static double MenuHeight { get; }
    public static ResourceKey MinimizeAnimationKey { get; }
    public static ResourceKey BorderKey { get; }
    public static ResourceKey CaretWidthKey { get; }
    public static ResourceKey ForegroundFlashCountKey { get; }
    public static ResourceKey DragFullWindowsKey { get; }
    public static ResourceKey BorderWidthKey { get; }
    public static ResourceKey ScrollWidthKey { get; }
    public static ResourceKey ScrollHeightKey { get; }
    public static ResourceKey CaptionWidthKey { get; }
    public static ResourceKey CaptionHeightKey { get; }
    public static ResourceKey SmallCaptionWidthKey { get; }
    public static ResourceKey MenuWidthKey { get; }
    public static ResourceKey MenuHeightKey { get; }
    public static double ThinHorizontalBorderHeight { get; }
    public static double ThinVerticalBorderWidth { get; }
    public static double CursorWidth { get; }
    public static double CursorHeight { get; }
    public static double ThickHorizontalBorderHeight { get; }
    public static double ThickVerticalBorderWidth { get; }
    public static double MinimumHorizontalDragDistance { get; }
    public static double MinimumVerticalDragDistance { get; }
    public static double FixedFrameHorizontalBorderHeight { get; }
    public static double FixedFrameVerticalBorderWidth { get; }
    public static double FocusHorizontalBorderHeight { get; }
    public static double FocusVerticalBorderWidth { get; }
    public static double FullPrimaryScreenWidth { get; }
    public static double FullPrimaryScreenHeight { get; }
    public static double HorizontalScrollBarButtonWidth { get; }
    public static double HorizontalScrollBarHeight { get; }
    public static double HorizontalScrollBarThumbWidth { get; }
    public static double IconWidth { get; }
    public static double IconHeight { get; }
    public static double IconGridWidth { get; }
    public static double IconGridHeight { get; }
    public static double MaximizedPrimaryScreenWidth { get; }
    public static double MaximizedPrimaryScreenHeight { get; }
    public static double MaximumWindowTrackWidth { get; }
    public static double MaximumWindowTrackHeight { get; }
    public static double MenuCheckmarkWidth { get; }
    public static double MenuCheckmarkHeight { get; }
    public static double MenuButtonWidth { get; }
    public static double MenuButtonHeight { get; }
    public static double MinimumWindowWidth { get; }
    public static double MinimumWindowHeight { get; }
    public static double MinimizedWindowWidth { get; }
    public static double MinimizedWindowHeight { get; }
    public static double MinimizedGridWidth { get; }
    public static double MinimizedGridHeight { get; }
    public static double MinimumWindowTrackWidth { get; }
    public static double MinimumWindowTrackHeight { get; }
    public static double PrimaryScreenWidth { get; }
    public static double PrimaryScreenHeight { get; }
    public static double WindowCaptionButtonWidth { get; }
    public static double WindowCaptionButtonHeight { get; }
    public static double ResizeFrameHorizontalBorderHeight { get; }
    public static double ResizeFrameVerticalBorderWidth { get; }
    public static double SmallIconWidth { get; }
    public static double SmallIconHeight { get; }
    public static double SmallWindowCaptionButtonWidth { get; }
    public static double SmallWindowCaptionButtonHeight { get; }
    public static double VirtualScreenWidth { get; }
    public static double VirtualScreenHeight { get; }
    public static double VerticalScrollBarWidth { get; }
    public static double VerticalScrollBarButtonHeight { get; }
    public static double WindowCaptionHeight { get; }
    public static double KanjiWindowHeight { get; }
    public static double MenuBarHeight { get; }
    public static double VerticalScrollBarThumbHeight { get; }
    public static bool IsImmEnabled { get; }
    public static bool IsMediaCenter { get; }
    public static bool IsMenuDropRightAligned { get; }
    public static bool IsMiddleEastEnabled { get; }
    public static bool IsMousePresent { get; }
    public static bool IsMouseWheelPresent { get; }
    public static bool IsPenWindows { get; }
    public static bool IsRemotelyControlled { get; }
    public static bool IsRemoteSession { get; }
    public static bool ShowSounds { get; }
    public static bool IsSlowMachine { get; }
    public static bool SwapButtons { get; }
    public static bool IsTabletPC { get; }
    public static double VirtualScreenLeft { get; }
    public static double VirtualScreenTop { get; }
    public static ResourceKey ThinHorizontalBorderHeightKey { get; }
    public static ResourceKey ThinVerticalBorderWidthKey { get; }
    public static ResourceKey CursorWidthKey { get; }
    public static ResourceKey CursorHeightKey { get; }
    public static ResourceKey ThickHorizontalBorderHeightKey { get; }
    public static ResourceKey ThickVerticalBorderWidthKey { get; }
    public static ResourceKey FixedFrameHorizontalBorderHeightKey { get; }
    public static ResourceKey FixedFrameVerticalBorderWidthKey { get; }
    public static ResourceKey FocusHorizontalBorderHeightKey { get; }
    public static ResourceKey FocusVerticalBorderWidthKey { get; }
    public static ResourceKey FullPrimaryScreenWidthKey { get; }
    public static ResourceKey FullPrimaryScreenHeightKey { get; }
    public static ResourceKey HorizontalScrollBarButtonWidthKey { get; }
    public static ResourceKey HorizontalScrollBarHeightKey { get; }
    public static ResourceKey HorizontalScrollBarThumbWidthKey { get; }
    public static ResourceKey IconWidthKey { get; }
    public static ResourceKey IconHeightKey { get; }
    public static ResourceKey IconGridWidthKey { get; }
    public static ResourceKey IconGridHeightKey { get; }
    public static ResourceKey MaximizedPrimaryScreenWidthKey { get; }
    public static ResourceKey MaximizedPrimaryScreenHeightKey { get; }
    public static ResourceKey MaximumWindowTrackWidthKey { get; }
    public static ResourceKey MaximumWindowTrackHeightKey { get; }
    public static ResourceKey MenuCheckmarkWidthKey { get; }
    public static ResourceKey MenuCheckmarkHeightKey { get; }
    public static ResourceKey MenuButtonWidthKey { get; }
    public static ResourceKey MenuButtonHeightKey { get; }
    public static ResourceKey MinimumWindowWidthKey { get; }
    public static ResourceKey MinimumWindowHeightKey { get; }
    public static ResourceKey MinimizedWindowWidthKey { get; }
    public static ResourceKey MinimizedWindowHeightKey { get; }
    public static ResourceKey MinimizedGridWidthKey { get; }
    public static ResourceKey MinimizedGridHeightKey { get; }
    public static ResourceKey MinimumWindowTrackWidthKey { get; }
    public static ResourceKey MinimumWindowTrackHeightKey { get; }
    public static ResourceKey PrimaryScreenWidthKey { get; }
    public static ResourceKey PrimaryScreenHeightKey { get; }
    public static ResourceKey WindowCaptionButtonWidthKey { get; }
    public static ResourceKey WindowCaptionButtonHeightKey { get; }
    public static ResourceKey ResizeFrameHorizontalBorderHeightKey { get; }
    public static ResourceKey ResizeFrameVerticalBorderWidthKey { get; }
    public static ResourceKey SmallIconWidthKey { get; }
    public static ResourceKey SmallIconHeightKey { get; }
    public static ResourceKey SmallWindowCaptionButtonWidthKey { get; }
    public static ResourceKey SmallWindowCaptionButtonHeightKey { get; }
    public static ResourceKey VirtualScreenWidthKey { get; }
    public static ResourceKey VirtualScreenHeightKey { get; }
    public static ResourceKey VerticalScrollBarWidthKey { get; }
    public static ResourceKey VerticalScrollBarButtonHeightKey { get; }
    public static ResourceKey WindowCaptionHeightKey { get; }
    public static ResourceKey KanjiWindowHeightKey { get; }
    public static ResourceKey MenuBarHeightKey { get; }
    public static ResourceKey SmallCaptionHeightKey { get; }
    public static ResourceKey VerticalScrollBarThumbHeightKey { get; }
    public static ResourceKey IsImmEnabledKey { get; }
    public static ResourceKey IsMediaCenterKey { get; }
    public static ResourceKey IsMenuDropRightAlignedKey { get; }
    public static ResourceKey IsMiddleEastEnabledKey { get; }
    public static ResourceKey IsMousePresentKey { get; }
    public static ResourceKey IsMouseWheelPresentKey { get; }
    public static ResourceKey IsPenWindowsKey { get; }
    public static ResourceKey IsRemotelyControlledKey { get; }
    public static ResourceKey IsRemoteSessionKey { get; }
    public static ResourceKey ShowSoundsKey { get; }
    public static ResourceKey IsSlowMachineKey { get; }
    public static ResourceKey SwapButtonsKey { get; }
    public static ResourceKey IsTabletPCKey { get; }
    public static ResourceKey VirtualScreenLeftKey { get; }
    public static ResourceKey VirtualScreenTopKey { get; }
    public static ResourceKey FocusVisualStyleKey { get; }
    public static ResourceKey NavigationChromeStyleKey { get; }
    public static ResourceKey NavigationChromeDownLevelStyleKey { get; }
    public static PowerLineStatus PowerLineStatus { get; }
    public static ResourceKey PowerLineStatusKey { get; }
    public static bool IsGlassEnabled { get; }
    public static string UxThemeName { get; }
    public static string UxThemeColor { get; }
    public static CornerRadius WindowCornerRadius { get; }
    public static Color WindowGlassColor { get; }
    public static Brush WindowGlassBrush { get; }
    public static Thickness WindowResizeBorderThickness { get; }
    public static Thickness WindowNonClientFrameThickness { get; }
    internal static int Dpi { get; }
    internal static int DpiX { get; }
    private static SystemParameters();
    [CompilerGeneratedAttribute]
public static void add_StaticPropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_StaticPropertyChanged(PropertyChangedEventHandler value);
    [SecurityCriticalAttribute]
public static double get_FocusBorderWidth();
    [SecurityCriticalAttribute]
public static double get_FocusBorderHeight();
    [SecurityCriticalAttribute]
public static bool get_HighContrast();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static bool get_MouseVanish();
    public static ResourceKey get_FocusBorderWidthKey();
    public static ResourceKey get_FocusBorderHeightKey();
    public static ResourceKey get_HighContrastKey();
    [SecurityCriticalAttribute]
public static bool get_DropShadow();
    [SecurityCriticalAttribute]
public static bool get_FlatMenu();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static RECT get_WorkAreaInternal();
    public static Rect get_WorkArea();
    public static ResourceKey get_DropShadowKey();
    public static ResourceKey get_FlatMenuKey();
    public static ResourceKey get_WorkAreaKey();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static ICONMETRICS get_IconMetrics();
    public static double get_IconHorizontalSpacing();
    public static double get_IconVerticalSpacing();
    public static bool get_IconTitleWrap();
    public static ResourceKey get_IconHorizontalSpacingKey();
    public static ResourceKey get_IconVerticalSpacingKey();
    public static ResourceKey get_IconTitleWrapKey();
    [SecurityCriticalAttribute]
public static bool get_KeyboardCues();
    [SecurityCriticalAttribute]
public static int get_KeyboardDelay();
    [SecurityCriticalAttribute]
public static bool get_KeyboardPreference();
    [SecurityCriticalAttribute]
public static int get_KeyboardSpeed();
    [SecurityCriticalAttribute]
public static bool get_SnapToDefaultButton();
    [SecurityCriticalAttribute]
public static int get_WheelScrollLines();
    public static TimeSpan get_MouseHoverTime();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int get_MouseHoverTimeMilliseconds();
    [SecurityCriticalAttribute]
public static double get_MouseHoverHeight();
    [SecurityCriticalAttribute]
public static double get_MouseHoverWidth();
    public static ResourceKey get_KeyboardCuesKey();
    public static ResourceKey get_KeyboardDelayKey();
    public static ResourceKey get_KeyboardPreferenceKey();
    public static ResourceKey get_KeyboardSpeedKey();
    public static ResourceKey get_SnapToDefaultButtonKey();
    public static ResourceKey get_WheelScrollLinesKey();
    public static ResourceKey get_MouseHoverTimeKey();
    public static ResourceKey get_MouseHoverHeightKey();
    public static ResourceKey get_MouseHoverWidthKey();
    [SecurityCriticalAttribute]
public static bool get_MenuDropAlignment();
    [SecurityCriticalAttribute]
public static bool get_MenuFade();
    [SecurityCriticalAttribute]
public static int get_MenuShowDelay();
    public static ResourceKey get_MenuDropAlignmentKey();
    public static ResourceKey get_MenuFadeKey();
    public static ResourceKey get_MenuShowDelayKey();
    public static PopupAnimation get_ComboBoxPopupAnimation();
    [SecurityCriticalAttribute]
public static bool get_ComboBoxAnimation();
    [SecurityCriticalAttribute]
public static bool get_ClientAreaAnimation();
    [SecurityCriticalAttribute]
public static bool get_CursorShadow();
    [SecurityCriticalAttribute]
public static bool get_GradientCaptions();
    [SecurityCriticalAttribute]
public static bool get_HotTracking();
    [SecurityCriticalAttribute]
public static bool get_ListBoxSmoothScrolling();
    public static PopupAnimation get_MenuPopupAnimation();
    [SecurityCriticalAttribute]
public static bool get_MenuAnimation();
    [SecurityCriticalAttribute]
public static bool get_SelectionFade();
    [SecurityCriticalAttribute]
public static bool get_StylusHotTracking();
    public static PopupAnimation get_ToolTipPopupAnimation();
    [SecurityCriticalAttribute]
public static bool get_ToolTipAnimation();
    [SecurityCriticalAttribute]
public static bool get_ToolTipFade();
    [SecurityCriticalAttribute]
public static bool get_UIEffects();
    public static ResourceKey get_ComboBoxAnimationKey();
    public static ResourceKey get_ClientAreaAnimationKey();
    public static ResourceKey get_CursorShadowKey();
    public static ResourceKey get_GradientCaptionsKey();
    public static ResourceKey get_HotTrackingKey();
    public static ResourceKey get_ListBoxSmoothScrollingKey();
    public static ResourceKey get_MenuAnimationKey();
    public static ResourceKey get_SelectionFadeKey();
    public static ResourceKey get_StylusHotTrackingKey();
    public static ResourceKey get_ToolTipAnimationKey();
    public static ResourceKey get_ToolTipFadeKey();
    public static ResourceKey get_UIEffectsKey();
    public static ResourceKey get_ComboBoxPopupAnimationKey();
    public static ResourceKey get_MenuPopupAnimationKey();
    public static ResourceKey get_ToolTipPopupAnimationKey();
    [SecurityCriticalAttribute]
public static bool get_MinimizeAnimation();
    [SecurityCriticalAttribute]
public static int get_Border();
    [SecurityCriticalAttribute]
public static double get_CaretWidth();
    [SecurityCriticalAttribute]
public static bool get_DragFullWindows();
    [SecurityCriticalAttribute]
public static int get_ForegroundFlashCount();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static NONCLIENTMETRICS get_NonClientMetrics();
    public static double get_BorderWidth();
    public static double get_ScrollWidth();
    public static double get_ScrollHeight();
    public static double get_CaptionWidth();
    public static double get_CaptionHeight();
    public static double get_SmallCaptionWidth();
    public static double get_SmallCaptionHeight();
    public static double get_MenuWidth();
    public static double get_MenuHeight();
    public static ResourceKey get_MinimizeAnimationKey();
    public static ResourceKey get_BorderKey();
    public static ResourceKey get_CaretWidthKey();
    public static ResourceKey get_ForegroundFlashCountKey();
    public static ResourceKey get_DragFullWindowsKey();
    public static ResourceKey get_BorderWidthKey();
    public static ResourceKey get_ScrollWidthKey();
    public static ResourceKey get_ScrollHeightKey();
    public static ResourceKey get_CaptionWidthKey();
    public static ResourceKey get_CaptionHeightKey();
    public static ResourceKey get_SmallCaptionWidthKey();
    public static ResourceKey get_MenuWidthKey();
    public static ResourceKey get_MenuHeightKey();
    [SecurityCriticalAttribute]
public static double get_ThinHorizontalBorderHeight();
    [SecurityCriticalAttribute]
public static double get_ThinVerticalBorderWidth();
    [SecurityCriticalAttribute]
public static double get_CursorWidth();
    [SecurityCriticalAttribute]
public static double get_CursorHeight();
    [SecurityCriticalAttribute]
public static double get_ThickHorizontalBorderHeight();
    [SecurityCriticalAttribute]
public static double get_ThickVerticalBorderWidth();
    [SecurityCriticalAttribute]
public static double get_MinimumHorizontalDragDistance();
    [SecurityCriticalAttribute]
public static double get_MinimumVerticalDragDistance();
    [SecurityCriticalAttribute]
public static double get_FixedFrameHorizontalBorderHeight();
    [SecurityCriticalAttribute]
public static double get_FixedFrameVerticalBorderWidth();
    [SecurityCriticalAttribute]
public static double get_FocusHorizontalBorderHeight();
    [SecurityCriticalAttribute]
public static double get_FocusVerticalBorderWidth();
    [SecurityCriticalAttribute]
public static double get_FullPrimaryScreenWidth();
    [SecurityCriticalAttribute]
public static double get_FullPrimaryScreenHeight();
    [SecurityCriticalAttribute]
public static double get_HorizontalScrollBarButtonWidth();
    [SecurityCriticalAttribute]
public static double get_HorizontalScrollBarHeight();
    [SecurityCriticalAttribute]
public static double get_HorizontalScrollBarThumbWidth();
    [SecurityCriticalAttribute]
public static double get_IconWidth();
    [SecurityCriticalAttribute]
public static double get_IconHeight();
    [SecurityCriticalAttribute]
public static double get_IconGridWidth();
    [SecurityCriticalAttribute]
public static double get_IconGridHeight();
    [SecurityCriticalAttribute]
public static double get_MaximizedPrimaryScreenWidth();
    [SecurityCriticalAttribute]
public static double get_MaximizedPrimaryScreenHeight();
    [SecurityCriticalAttribute]
public static double get_MaximumWindowTrackWidth();
    [SecurityCriticalAttribute]
public static double get_MaximumWindowTrackHeight();
    [SecurityCriticalAttribute]
public static double get_MenuCheckmarkWidth();
    [SecurityCriticalAttribute]
public static double get_MenuCheckmarkHeight();
    [SecurityCriticalAttribute]
public static double get_MenuButtonWidth();
    [SecurityCriticalAttribute]
public static double get_MenuButtonHeight();
    [SecurityCriticalAttribute]
public static double get_MinimumWindowWidth();
    [SecurityCriticalAttribute]
public static double get_MinimumWindowHeight();
    [SecurityCriticalAttribute]
public static double get_MinimizedWindowWidth();
    [SecurityCriticalAttribute]
public static double get_MinimizedWindowHeight();
    [SecurityCriticalAttribute]
public static double get_MinimizedGridWidth();
    [SecurityCriticalAttribute]
public static double get_MinimizedGridHeight();
    [SecurityCriticalAttribute]
public static double get_MinimumWindowTrackWidth();
    [SecurityCriticalAttribute]
public static double get_MinimumWindowTrackHeight();
    [SecurityCriticalAttribute]
public static double get_PrimaryScreenWidth();
    [SecurityCriticalAttribute]
public static double get_PrimaryScreenHeight();
    [SecurityCriticalAttribute]
public static double get_WindowCaptionButtonWidth();
    [SecurityCriticalAttribute]
public static double get_WindowCaptionButtonHeight();
    [SecurityCriticalAttribute]
public static double get_ResizeFrameHorizontalBorderHeight();
    [SecurityCriticalAttribute]
public static double get_ResizeFrameVerticalBorderWidth();
    [SecurityCriticalAttribute]
public static double get_SmallIconWidth();
    [SecurityCriticalAttribute]
public static double get_SmallIconHeight();
    [SecurityCriticalAttribute]
public static double get_SmallWindowCaptionButtonWidth();
    [SecurityCriticalAttribute]
public static double get_SmallWindowCaptionButtonHeight();
    [SecurityCriticalAttribute]
public static double get_VirtualScreenWidth();
    [SecurityCriticalAttribute]
public static double get_VirtualScreenHeight();
    [SecurityCriticalAttribute]
public static double get_VerticalScrollBarWidth();
    [SecurityCriticalAttribute]
public static double get_VerticalScrollBarButtonHeight();
    [SecurityCriticalAttribute]
public static double get_WindowCaptionHeight();
    [SecurityCriticalAttribute]
public static double get_KanjiWindowHeight();
    [SecurityCriticalAttribute]
public static double get_MenuBarHeight();
    [SecurityCriticalAttribute]
public static double get_VerticalScrollBarThumbHeight();
    [SecurityCriticalAttribute]
public static bool get_IsImmEnabled();
    [SecurityCriticalAttribute]
public static bool get_IsMediaCenter();
    [SecurityCriticalAttribute]
public static bool get_IsMenuDropRightAligned();
    [SecurityCriticalAttribute]
public static bool get_IsMiddleEastEnabled();
    [SecurityCriticalAttribute]
public static bool get_IsMousePresent();
    [SecurityCriticalAttribute]
public static bool get_IsMouseWheelPresent();
    [SecurityCriticalAttribute]
public static bool get_IsPenWindows();
    [SecurityCriticalAttribute]
public static bool get_IsRemotelyControlled();
    [SecurityCriticalAttribute]
public static bool get_IsRemoteSession();
    [SecurityCriticalAttribute]
public static bool get_ShowSounds();
    [SecurityCriticalAttribute]
public static bool get_IsSlowMachine();
    [SecurityCriticalAttribute]
public static bool get_SwapButtons();
    [SecurityCriticalAttribute]
public static bool get_IsTabletPC();
    [SecurityCriticalAttribute]
public static double get_VirtualScreenLeft();
    [SecurityCriticalAttribute]
public static double get_VirtualScreenTop();
    public static ResourceKey get_ThinHorizontalBorderHeightKey();
    public static ResourceKey get_ThinVerticalBorderWidthKey();
    public static ResourceKey get_CursorWidthKey();
    public static ResourceKey get_CursorHeightKey();
    public static ResourceKey get_ThickHorizontalBorderHeightKey();
    public static ResourceKey get_ThickVerticalBorderWidthKey();
    public static ResourceKey get_FixedFrameHorizontalBorderHeightKey();
    public static ResourceKey get_FixedFrameVerticalBorderWidthKey();
    public static ResourceKey get_FocusHorizontalBorderHeightKey();
    public static ResourceKey get_FocusVerticalBorderWidthKey();
    public static ResourceKey get_FullPrimaryScreenWidthKey();
    public static ResourceKey get_FullPrimaryScreenHeightKey();
    public static ResourceKey get_HorizontalScrollBarButtonWidthKey();
    public static ResourceKey get_HorizontalScrollBarHeightKey();
    public static ResourceKey get_HorizontalScrollBarThumbWidthKey();
    public static ResourceKey get_IconWidthKey();
    public static ResourceKey get_IconHeightKey();
    public static ResourceKey get_IconGridWidthKey();
    public static ResourceKey get_IconGridHeightKey();
    public static ResourceKey get_MaximizedPrimaryScreenWidthKey();
    public static ResourceKey get_MaximizedPrimaryScreenHeightKey();
    public static ResourceKey get_MaximumWindowTrackWidthKey();
    public static ResourceKey get_MaximumWindowTrackHeightKey();
    public static ResourceKey get_MenuCheckmarkWidthKey();
    public static ResourceKey get_MenuCheckmarkHeightKey();
    public static ResourceKey get_MenuButtonWidthKey();
    public static ResourceKey get_MenuButtonHeightKey();
    public static ResourceKey get_MinimumWindowWidthKey();
    public static ResourceKey get_MinimumWindowHeightKey();
    public static ResourceKey get_MinimizedWindowWidthKey();
    public static ResourceKey get_MinimizedWindowHeightKey();
    public static ResourceKey get_MinimizedGridWidthKey();
    public static ResourceKey get_MinimizedGridHeightKey();
    public static ResourceKey get_MinimumWindowTrackWidthKey();
    public static ResourceKey get_MinimumWindowTrackHeightKey();
    public static ResourceKey get_PrimaryScreenWidthKey();
    public static ResourceKey get_PrimaryScreenHeightKey();
    public static ResourceKey get_WindowCaptionButtonWidthKey();
    public static ResourceKey get_WindowCaptionButtonHeightKey();
    public static ResourceKey get_ResizeFrameHorizontalBorderHeightKey();
    public static ResourceKey get_ResizeFrameVerticalBorderWidthKey();
    public static ResourceKey get_SmallIconWidthKey();
    public static ResourceKey get_SmallIconHeightKey();
    public static ResourceKey get_SmallWindowCaptionButtonWidthKey();
    public static ResourceKey get_SmallWindowCaptionButtonHeightKey();
    public static ResourceKey get_VirtualScreenWidthKey();
    public static ResourceKey get_VirtualScreenHeightKey();
    public static ResourceKey get_VerticalScrollBarWidthKey();
    public static ResourceKey get_VerticalScrollBarButtonHeightKey();
    public static ResourceKey get_WindowCaptionHeightKey();
    public static ResourceKey get_KanjiWindowHeightKey();
    public static ResourceKey get_MenuBarHeightKey();
    public static ResourceKey get_SmallCaptionHeightKey();
    public static ResourceKey get_VerticalScrollBarThumbHeightKey();
    public static ResourceKey get_IsImmEnabledKey();
    public static ResourceKey get_IsMediaCenterKey();
    public static ResourceKey get_IsMenuDropRightAlignedKey();
    public static ResourceKey get_IsMiddleEastEnabledKey();
    public static ResourceKey get_IsMousePresentKey();
    public static ResourceKey get_IsMouseWheelPresentKey();
    public static ResourceKey get_IsPenWindowsKey();
    public static ResourceKey get_IsRemotelyControlledKey();
    public static ResourceKey get_IsRemoteSessionKey();
    public static ResourceKey get_ShowSoundsKey();
    public static ResourceKey get_IsSlowMachineKey();
    public static ResourceKey get_SwapButtonsKey();
    public static ResourceKey get_IsTabletPCKey();
    public static ResourceKey get_VirtualScreenLeftKey();
    public static ResourceKey get_VirtualScreenTopKey();
    public static ResourceKey get_FocusVisualStyleKey();
    public static ResourceKey get_NavigationChromeStyleKey();
    public static ResourceKey get_NavigationChromeDownLevelStyleKey();
    [SecurityCriticalAttribute]
public static PowerLineStatus get_PowerLineStatus();
    public static ResourceKey get_PowerLineStatusKey();
    internal static void InvalidateCache();
    internal static bool InvalidateDeviceDependentCache();
    internal static bool InvalidateDisplayDependentCache();
    internal static bool InvalidatePowerDependentCache();
    internal static bool InvalidateCache(int param);
    internal static bool InvalidateIsGlassEnabled();
    internal static void InvalidateDerivedThemeRelatedProperties();
    internal static void InvalidateWindowGlassColorizationProperties();
    internal static void InvalidateWindowFrameThicknessProperties();
    [SecurityCriticalAttribute]
public static bool get_IsGlassEnabled();
    [SecurityCriticalAttribute]
public static string get_UxThemeName();
    [SecurityCriticalAttribute]
public static string get_UxThemeColor();
    [SecurityCriticalAttribute]
public static CornerRadius get_WindowCornerRadius();
    [SecurityCriticalAttribute]
public static Color get_WindowGlassColor();
    [SecurityCriticalAttribute]
public static Brush get_WindowGlassBrush();
    [SecurityCriticalAttribute]
public static Thickness get_WindowResizeBorderThickness();
    [SecurityCriticalAttribute]
public static Thickness get_WindowNonClientFrameThickness();
    internal static int get_Dpi();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal static int get_DpiX();
    internal static double ConvertPixel(int pixel);
}
internal class System.Windows.SystemResourceHost : object {
    internal static SystemResourceHost Instance { get; }
    internal static SystemResourceHost get_Instance();
}
[TypeConverterAttribute("System.Windows.Markup.SystemKeyConverter")]
internal class System.Windows.SystemResourceKey : ResourceKey {
    internal object Resource { get; }
    internal SystemResourceKeyID InternalKey { get; }
    public Assembly Assembly { get; }
    internal static ComponentResourceKey DataGridFocusBorderBrushKey { get; }
    internal static ComponentResourceKey DataGridComboBoxColumnTextBlockComboBoxStyleKey { get; }
    internal static ResourceKey MenuItemSeparatorStyleKey { get; }
    internal static ComponentResourceKey DataGridColumnHeaderColumnFloatingHeaderStyleKey { get; }
    internal static ComponentResourceKey DataGridColumnHeaderColumnHeaderDropSeparatorStyleKey { get; }
    internal static ResourceKey GridViewItemContainerStyleKey { get; }
    internal static ResourceKey GridViewScrollViewerStyleKey { get; }
    internal static ResourceKey GridViewStyleKey { get; }
    internal static ResourceKey StatusBarSeparatorStyleKey { get; }
    internal static ResourceKey ToolBarButtonStyleKey { get; }
    internal static ResourceKey ToolBarToggleButtonStyleKey { get; }
    internal static ResourceKey ToolBarSeparatorStyleKey { get; }
    internal static ResourceKey ToolBarCheckBoxStyleKey { get; }
    internal static ResourceKey ToolBarRadioButtonStyleKey { get; }
    internal static ResourceKey ToolBarComboBoxStyleKey { get; }
    internal static ResourceKey ToolBarTextBoxStyleKey { get; }
    internal static ResourceKey ToolBarMenuStyleKey { get; }
    internal SystemResourceKey(SystemResourceKeyID id);
    private static SystemResourceKey();
    internal static short GetSystemResourceKeyIdFromBamlId(short bamlId, Boolean& isKey);
    internal static short GetBamlIdBasedOnSystemResourceKeyId(Type targetType, string memberName);
    internal object get_Resource();
    internal static ResourceKey GetResourceKey(short id);
    internal static ResourceKey GetSystemResourceKey(string keyName);
    internal static object GetResource(short id);
    internal SystemResourceKeyID get_InternalKey();
    public virtual Assembly get_Assembly();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static ComponentResourceKey get_DataGridFocusBorderBrushKey();
    internal static ComponentResourceKey get_DataGridComboBoxColumnTextBlockComboBoxStyleKey();
    internal static ResourceKey get_MenuItemSeparatorStyleKey();
    internal static ComponentResourceKey get_DataGridColumnHeaderColumnFloatingHeaderStyleKey();
    internal static ComponentResourceKey get_DataGridColumnHeaderColumnHeaderDropSeparatorStyleKey();
    internal static ResourceKey get_GridViewItemContainerStyleKey();
    internal static ResourceKey get_GridViewScrollViewerStyleKey();
    internal static ResourceKey get_GridViewStyleKey();
    internal static ResourceKey get_StatusBarSeparatorStyleKey();
    internal static ResourceKey get_ToolBarButtonStyleKey();
    internal static ResourceKey get_ToolBarToggleButtonStyleKey();
    internal static ResourceKey get_ToolBarSeparatorStyleKey();
    internal static ResourceKey get_ToolBarCheckBoxStyleKey();
    internal static ResourceKey get_ToolBarRadioButtonStyleKey();
    internal static ResourceKey get_ToolBarComboBoxStyleKey();
    internal static ResourceKey get_ToolBarTextBoxStyleKey();
    internal static ResourceKey get_ToolBarMenuStyleKey();
}
internal enum System.Windows.SystemResourceKeyID : Enum {
    public int value__;
    public static SystemResourceKeyID InternalSystemColorsStart;
    public static SystemResourceKeyID ActiveBorderBrush;
    public static SystemResourceKeyID ActiveCaptionBrush;
    public static SystemResourceKeyID ActiveCaptionTextBrush;
    public static SystemResourceKeyID AppWorkspaceBrush;
    public static SystemResourceKeyID ControlBrush;
    public static SystemResourceKeyID ControlDarkBrush;
    public static SystemResourceKeyID ControlDarkDarkBrush;
    public static SystemResourceKeyID ControlLightBrush;
    public static SystemResourceKeyID ControlLightLightBrush;
    public static SystemResourceKeyID ControlTextBrush;
    public static SystemResourceKeyID DesktopBrush;
    public static SystemResourceKeyID GradientActiveCaptionBrush;
    public static SystemResourceKeyID GradientInactiveCaptionBrush;
    public static SystemResourceKeyID GrayTextBrush;
    public static SystemResourceKeyID HighlightBrush;
    public static SystemResourceKeyID HighlightTextBrush;
    public static SystemResourceKeyID HotTrackBrush;
    public static SystemResourceKeyID InactiveBorderBrush;
    public static SystemResourceKeyID InactiveCaptionBrush;
    public static SystemResourceKeyID InactiveCaptionTextBrush;
    public static SystemResourceKeyID InfoBrush;
    public static SystemResourceKeyID InfoTextBrush;
    public static SystemResourceKeyID MenuBrush;
    public static SystemResourceKeyID MenuBarBrush;
    public static SystemResourceKeyID MenuHighlightBrush;
    public static SystemResourceKeyID MenuTextBrush;
    public static SystemResourceKeyID ScrollBarBrush;
    public static SystemResourceKeyID WindowBrush;
    public static SystemResourceKeyID WindowFrameBrush;
    public static SystemResourceKeyID WindowTextBrush;
    public static SystemResourceKeyID ActiveBorderColor;
    public static SystemResourceKeyID ActiveCaptionColor;
    public static SystemResourceKeyID ActiveCaptionTextColor;
    public static SystemResourceKeyID AppWorkspaceColor;
    public static SystemResourceKeyID ControlColor;
    public static SystemResourceKeyID ControlDarkColor;
    public static SystemResourceKeyID ControlDarkDarkColor;
    public static SystemResourceKeyID ControlLightColor;
    public static SystemResourceKeyID ControlLightLightColor;
    public static SystemResourceKeyID ControlTextColor;
    public static SystemResourceKeyID DesktopColor;
    public static SystemResourceKeyID GradientActiveCaptionColor;
    public static SystemResourceKeyID GradientInactiveCaptionColor;
    public static SystemResourceKeyID GrayTextColor;
    public static SystemResourceKeyID HighlightColor;
    public static SystemResourceKeyID HighlightTextColor;
    public static SystemResourceKeyID HotTrackColor;
    public static SystemResourceKeyID InactiveBorderColor;
    public static SystemResourceKeyID InactiveCaptionColor;
    public static SystemResourceKeyID InactiveCaptionTextColor;
    public static SystemResourceKeyID InfoColor;
    public static SystemResourceKeyID InfoTextColor;
    public static SystemResourceKeyID MenuColor;
    public static SystemResourceKeyID MenuBarColor;
    public static SystemResourceKeyID MenuHighlightColor;
    public static SystemResourceKeyID MenuTextColor;
    public static SystemResourceKeyID ScrollBarColor;
    public static SystemResourceKeyID WindowColor;
    public static SystemResourceKeyID WindowFrameColor;
    public static SystemResourceKeyID WindowTextColor;
    public static SystemResourceKeyID InternalSystemColorsEnd;
    public static SystemResourceKeyID InternalSystemFontsStart;
    public static SystemResourceKeyID CaptionFontSize;
    public static SystemResourceKeyID CaptionFontFamily;
    public static SystemResourceKeyID CaptionFontStyle;
    public static SystemResourceKeyID CaptionFontWeight;
    public static SystemResourceKeyID CaptionFontTextDecorations;
    public static SystemResourceKeyID SmallCaptionFontSize;
    public static SystemResourceKeyID SmallCaptionFontFamily;
    public static SystemResourceKeyID SmallCaptionFontStyle;
    public static SystemResourceKeyID SmallCaptionFontWeight;
    public static SystemResourceKeyID SmallCaptionFontTextDecorations;
    public static SystemResourceKeyID MenuFontSize;
    public static SystemResourceKeyID MenuFontFamily;
    public static SystemResourceKeyID MenuFontStyle;
    public static SystemResourceKeyID MenuFontWeight;
    public static SystemResourceKeyID MenuFontTextDecorations;
    public static SystemResourceKeyID StatusFontSize;
    public static SystemResourceKeyID StatusFontFamily;
    public static SystemResourceKeyID StatusFontStyle;
    public static SystemResourceKeyID StatusFontWeight;
    public static SystemResourceKeyID StatusFontTextDecorations;
    public static SystemResourceKeyID MessageFontSize;
    public static SystemResourceKeyID MessageFontFamily;
    public static SystemResourceKeyID MessageFontStyle;
    public static SystemResourceKeyID MessageFontWeight;
    public static SystemResourceKeyID MessageFontTextDecorations;
    public static SystemResourceKeyID IconFontSize;
    public static SystemResourceKeyID IconFontFamily;
    public static SystemResourceKeyID IconFontStyle;
    public static SystemResourceKeyID IconFontWeight;
    public static SystemResourceKeyID IconFontTextDecorations;
    public static SystemResourceKeyID InternalSystemFontsEnd;
    public static SystemResourceKeyID InternalSystemParametersStart;
    public static SystemResourceKeyID ThinHorizontalBorderHeight;
    public static SystemResourceKeyID ThinVerticalBorderWidth;
    public static SystemResourceKeyID CursorWidth;
    public static SystemResourceKeyID CursorHeight;
    public static SystemResourceKeyID ThickHorizontalBorderHeight;
    public static SystemResourceKeyID ThickVerticalBorderWidth;
    public static SystemResourceKeyID FixedFrameHorizontalBorderHeight;
    public static SystemResourceKeyID FixedFrameVerticalBorderWidth;
    public static SystemResourceKeyID FocusHorizontalBorderHeight;
    public static SystemResourceKeyID FocusVerticalBorderWidth;
    public static SystemResourceKeyID FullPrimaryScreenWidth;
    public static SystemResourceKeyID FullPrimaryScreenHeight;
    public static SystemResourceKeyID HorizontalScrollBarButtonWidth;
    public static SystemResourceKeyID HorizontalScrollBarHeight;
    public static SystemResourceKeyID HorizontalScrollBarThumbWidth;
    public static SystemResourceKeyID IconWidth;
    public static SystemResourceKeyID IconHeight;
    public static SystemResourceKeyID IconGridWidth;
    public static SystemResourceKeyID IconGridHeight;
    public static SystemResourceKeyID MaximizedPrimaryScreenWidth;
    public static SystemResourceKeyID MaximizedPrimaryScreenHeight;
    public static SystemResourceKeyID MaximumWindowTrackWidth;
    public static SystemResourceKeyID MaximumWindowTrackHeight;
    public static SystemResourceKeyID MenuCheckmarkWidth;
    public static SystemResourceKeyID MenuCheckmarkHeight;
    public static SystemResourceKeyID MenuButtonWidth;
    public static SystemResourceKeyID MenuButtonHeight;
    public static SystemResourceKeyID MinimumWindowWidth;
    public static SystemResourceKeyID MinimumWindowHeight;
    public static SystemResourceKeyID MinimizedWindowWidth;
    public static SystemResourceKeyID MinimizedWindowHeight;
    public static SystemResourceKeyID MinimizedGridWidth;
    public static SystemResourceKeyID MinimizedGridHeight;
    public static SystemResourceKeyID MinimumWindowTrackWidth;
    public static SystemResourceKeyID MinimumWindowTrackHeight;
    public static SystemResourceKeyID PrimaryScreenWidth;
    public static SystemResourceKeyID PrimaryScreenHeight;
    public static SystemResourceKeyID WindowCaptionButtonWidth;
    public static SystemResourceKeyID WindowCaptionButtonHeight;
    public static SystemResourceKeyID ResizeFrameHorizontalBorderHeight;
    public static SystemResourceKeyID ResizeFrameVerticalBorderWidth;
    public static SystemResourceKeyID SmallIconWidth;
    public static SystemResourceKeyID SmallIconHeight;
    public static SystemResourceKeyID SmallWindowCaptionButtonWidth;
    public static SystemResourceKeyID SmallWindowCaptionButtonHeight;
    public static SystemResourceKeyID VirtualScreenWidth;
    public static SystemResourceKeyID VirtualScreenHeight;
    public static SystemResourceKeyID VerticalScrollBarWidth;
    public static SystemResourceKeyID VerticalScrollBarButtonHeight;
    public static SystemResourceKeyID WindowCaptionHeight;
    public static SystemResourceKeyID KanjiWindowHeight;
    public static SystemResourceKeyID MenuBarHeight;
    public static SystemResourceKeyID SmallCaptionHeight;
    public static SystemResourceKeyID VerticalScrollBarThumbHeight;
    public static SystemResourceKeyID IsImmEnabled;
    public static SystemResourceKeyID IsMediaCenter;
    public static SystemResourceKeyID IsMenuDropRightAligned;
    public static SystemResourceKeyID IsMiddleEastEnabled;
    public static SystemResourceKeyID IsMousePresent;
    public static SystemResourceKeyID IsMouseWheelPresent;
    public static SystemResourceKeyID IsPenWindows;
    public static SystemResourceKeyID IsRemotelyControlled;
    public static SystemResourceKeyID IsRemoteSession;
    public static SystemResourceKeyID ShowSounds;
    public static SystemResourceKeyID IsSlowMachine;
    public static SystemResourceKeyID SwapButtons;
    public static SystemResourceKeyID IsTabletPC;
    public static SystemResourceKeyID VirtualScreenLeft;
    public static SystemResourceKeyID VirtualScreenTop;
    public static SystemResourceKeyID FocusBorderWidth;
    public static SystemResourceKeyID FocusBorderHeight;
    public static SystemResourceKeyID HighContrast;
    public static SystemResourceKeyID DropShadow;
    public static SystemResourceKeyID FlatMenu;
    public static SystemResourceKeyID WorkArea;
    public static SystemResourceKeyID IconHorizontalSpacing;
    public static SystemResourceKeyID IconVerticalSpacing;
    public static SystemResourceKeyID IconTitleWrap;
    public static SystemResourceKeyID KeyboardCues;
    public static SystemResourceKeyID KeyboardDelay;
    public static SystemResourceKeyID KeyboardPreference;
    public static SystemResourceKeyID KeyboardSpeed;
    public static SystemResourceKeyID SnapToDefaultButton;
    public static SystemResourceKeyID WheelScrollLines;
    public static SystemResourceKeyID MouseHoverTime;
    public static SystemResourceKeyID MouseHoverHeight;
    public static SystemResourceKeyID MouseHoverWidth;
    public static SystemResourceKeyID MenuDropAlignment;
    public static SystemResourceKeyID MenuFade;
    public static SystemResourceKeyID MenuShowDelay;
    public static SystemResourceKeyID ComboBoxAnimation;
    public static SystemResourceKeyID ClientAreaAnimation;
    public static SystemResourceKeyID CursorShadow;
    public static SystemResourceKeyID GradientCaptions;
    public static SystemResourceKeyID HotTracking;
    public static SystemResourceKeyID ListBoxSmoothScrolling;
    public static SystemResourceKeyID MenuAnimation;
    public static SystemResourceKeyID SelectionFade;
    public static SystemResourceKeyID StylusHotTracking;
    public static SystemResourceKeyID ToolTipAnimation;
    public static SystemResourceKeyID ToolTipFade;
    public static SystemResourceKeyID UIEffects;
    public static SystemResourceKeyID MinimizeAnimation;
    public static SystemResourceKeyID Border;
    public static SystemResourceKeyID CaretWidth;
    public static SystemResourceKeyID ForegroundFlashCount;
    public static SystemResourceKeyID DragFullWindows;
    public static SystemResourceKeyID BorderWidth;
    public static SystemResourceKeyID ScrollWidth;
    public static SystemResourceKeyID ScrollHeight;
    public static SystemResourceKeyID CaptionWidth;
    public static SystemResourceKeyID CaptionHeight;
    public static SystemResourceKeyID SmallCaptionWidth;
    public static SystemResourceKeyID MenuWidth;
    public static SystemResourceKeyID MenuHeight;
    public static SystemResourceKeyID ComboBoxPopupAnimation;
    public static SystemResourceKeyID MenuPopupAnimation;
    public static SystemResourceKeyID ToolTipPopupAnimation;
    public static SystemResourceKeyID PowerLineStatus;
    public static SystemResourceKeyID InternalSystemThemeStylesStart;
    public static SystemResourceKeyID FocusVisualStyle;
    public static SystemResourceKeyID NavigationChromeDownLevelStyle;
    public static SystemResourceKeyID NavigationChromeStyle;
    public static SystemResourceKeyID InternalSystemParametersEnd;
    public static SystemResourceKeyID MenuItemSeparatorStyle;
    public static SystemResourceKeyID GridViewScrollViewerStyle;
    public static SystemResourceKeyID GridViewStyle;
    public static SystemResourceKeyID GridViewItemContainerStyle;
    public static SystemResourceKeyID StatusBarSeparatorStyle;
    public static SystemResourceKeyID ToolBarButtonStyle;
    public static SystemResourceKeyID ToolBarToggleButtonStyle;
    public static SystemResourceKeyID ToolBarSeparatorStyle;
    public static SystemResourceKeyID ToolBarCheckBoxStyle;
    public static SystemResourceKeyID ToolBarRadioButtonStyle;
    public static SystemResourceKeyID ToolBarComboBoxStyle;
    public static SystemResourceKeyID ToolBarTextBoxStyle;
    public static SystemResourceKeyID ToolBarMenuStyle;
    public static SystemResourceKeyID InternalSystemThemeStylesEnd;
    public static SystemResourceKeyID InternalSystemColorsExtendedStart;
    public static SystemResourceKeyID InactiveSelectionHighlightBrush;
    public static SystemResourceKeyID InactiveSelectionHighlightTextBrush;
    public static SystemResourceKeyID InternalSystemColorsExtendedEnd;
}
internal static class System.Windows.SystemResources : object {
    internal static string GenericResourceName;
    internal static string ClassicResourceName;
    internal static string PresentationFrameworkName;
    internal static bool SystemResourcesHaveChanged;
    [ThreadStaticAttribute]
internal static bool SystemResourcesAreChanging;
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> ThemedResourceDictionaries { get; }
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> GenericResourceDictionaries { get; }
    internal static bool IsSystemResourcesParsing { get; internal set; }
    internal static object ThemeDictionaryLock { get; }
    internal static HwndWrapper Hwnd { get; }
    private static SystemResources();
    internal static object FindThemeStyle(DependencyObjectType key);
    internal static object FindResourceInternal(object key);
    internal static object FindResourceInternal(object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> get_ThemedResourceDictionaries();
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> get_GenericResourceDictionaries();
    internal static void CacheResource(object key, object resource, bool isTraceEnabled);
    internal static bool ClearBitArray(BitArray cacheValid);
    internal static bool ClearSlot(BitArray cacheValid, int slot);
    internal static bool get_IsSystemResourcesParsing();
    internal static void set_IsSystemResourcesParsing(bool value);
    internal static object get_ThemeDictionaryLock();
    [SecurityCriticalAttribute]
internal static HwndWrapper get_Hwnd();
    internal static void DelayHwndShutdown();
    [CompilerGeneratedAttribute]
internal static void add_ThemedDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_ThemedDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void add_ThemedDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_ThemedDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void add_GenericDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_GenericDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
}
[TypeConverterAttribute("System.Windows.Markup.SystemKeyConverter")]
internal class System.Windows.SystemThemeKey : ResourceKey {
    public Assembly Assembly { get; }
    internal SystemResourceKeyID InternalKey { get; }
    internal SystemThemeKey(SystemResourceKeyID id);
    public virtual Assembly get_Assembly();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal SystemResourceKeyID get_InternalKey();
}
[TypeConverterAttribute("System.Windows.TemplateBindingExpressionConverter")]
public class System.Windows.TemplateBindingExpression : Expression {
    public TemplateBindingExtension TemplateBindingExtension { get; }
    internal TemplateBindingExpression(TemplateBindingExtension templateBindingExtension);
    public TemplateBindingExtension get_TemplateBindingExtension();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
}
public class System.Windows.TemplateBindingExpressionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeConverterAttribute("System.Windows.TemplateBindingExtensionConverter")]
[MarkupExtensionReturnTypeAttribute("System.Object")]
public class System.Windows.TemplateBindingExtension : MarkupExtension {
    [ConstructorArgumentAttribute("property")]
public DependencyProperty Property { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    public TemplateBindingExtension(DependencyProperty property);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
}
public class System.Windows.TemplateBindingExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[XamlDeferLoadAttribute("System.Windows.TemplateContentLoader", "System.Windows.FrameworkElement")]
public class System.Windows.TemplateContent : object {
    [SecurityCriticalAttribute]
internal XamlNodeList _xamlNodeList;
    internal XamlLoadPermission LoadPermission { get; internal set; }
    internal XamlType RootType { get; private set; }
    internal FrameworkTemplate OwnerTemplate { get; internal set; }
    internal IXamlObjectWriterFactory ObjectWriterFactory { get; private set; }
    internal XamlObjectWriterSettings ObjectWriterParentSettings { get; private set; }
    internal XamlSchemaContext SchemaContext { get; private set; }
    internal TemplateLoadData TemplateLoadData { get; internal set; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal TemplateContent(XamlReader xamlReader, IXamlObjectWriterFactory factory, IServiceProvider context);
    private static TemplateContent();
    internal void ParseXaml();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal XamlReader PlayXaml();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal XamlLoadPermission get_LoadPermission();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal void set_LoadPermission(XamlLoadPermission value);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void ResetTemplateLoadData();
    [CompilerGeneratedAttribute]
internal XamlType get_RootType();
    [CompilerGeneratedAttribute]
private void set_RootType(XamlType value);
    internal XamlType GetTypeForName(string name);
    [CompilerGeneratedAttribute]
internal FrameworkTemplate get_OwnerTemplate();
    [CompilerGeneratedAttribute]
internal void set_OwnerTemplate(FrameworkTemplate value);
    [CompilerGeneratedAttribute]
internal IXamlObjectWriterFactory get_ObjectWriterFactory();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterFactory(IXamlObjectWriterFactory value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriterSettings get_ObjectWriterParentSettings();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterParentSettings(XamlObjectWriterSettings value);
    [CompilerGeneratedAttribute]
internal XamlSchemaContext get_SchemaContext();
    [CompilerGeneratedAttribute]
private void set_SchemaContext(XamlSchemaContext value);
    [CompilerGeneratedAttribute]
internal TemplateLoadData get_TemplateLoadData();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal void set_TemplateLoadData(TemplateLoadData value);
}
public class System.Windows.TemplateContentLoader : XamlDeferringLoader {
    public virtual object Load(XamlReader xamlReader, IServiceProvider serviceProvider);
    public virtual XamlReader Save(object value, IServiceProvider serviceProvider);
}
[TypeConverterAttribute("System.Windows.Markup.TemplateKeyConverter")]
public abstract class System.Windows.TemplateKey : ResourceKey {
    public object DataType { get; public set; }
    public Assembly Assembly { get; }
    protected TemplateKey(TemplateType templateType);
    protected TemplateKey(TemplateType templateType, object dataType);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public object get_DataType();
    public void set_DataType(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
    public virtual Assembly get_Assembly();
    internal static Exception ValidateDataType(object dataType, string argName);
}
internal class System.Windows.TemplateLoadData : object {
    internal Dictionary`2<string, XamlType> _namedTypes;
    internal StackOfFrames Stack { get; internal set; }
    internal Dictionary`2<string, XamlType> NamedTypes { get; }
    internal XamlReader Reader { get; internal set; }
    internal string RootName { get; internal set; }
    internal object RootObject { get; internal set; }
    internal ServiceProviderWrapper ServiceProviderWrapper { get; internal set; }
    internal XamlObjectWriter ObjectWriter { get; internal set; }
    [CompilerGeneratedAttribute]
internal StackOfFrames get_Stack();
    [CompilerGeneratedAttribute]
internal void set_Stack(StackOfFrames value);
    internal Dictionary`2<string, XamlType> get_NamedTypes();
    [CompilerGeneratedAttribute]
internal XamlReader get_Reader();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
internal void set_Reader(XamlReader value);
    [CompilerGeneratedAttribute]
internal string get_RootName();
    [CompilerGeneratedAttribute]
internal void set_RootName(string value);
    [CompilerGeneratedAttribute]
internal object get_RootObject();
    [CompilerGeneratedAttribute]
internal void set_RootObject(object value);
    [CompilerGeneratedAttribute]
internal ServiceProviderWrapper get_ServiceProviderWrapper();
    [CompilerGeneratedAttribute]
internal void set_ServiceProviderWrapper(ServiceProviderWrapper value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriter get_ObjectWriter();
    [CompilerGeneratedAttribute]
internal void set_ObjectWriter(XamlObjectWriter value);
}
internal class System.Windows.TemplateNameScope : object {
    internal TemplateNameScope(DependencyObject templatedParent);
    internal TemplateNameScope(DependencyObject templatedParent, List`1<DependencyObject> affectedChildren, FrameworkTemplate frameworkTemplate);
    private static TemplateNameScope();
    private sealed virtual override void System.Windows.Markup.INameScope.RegisterName(string name, object scopedElement);
    internal void RegisterNameInternal(string name, object scopedElement);
    private sealed virtual override void System.Windows.Markup.INameScope.UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
}
[AttributeUsageAttribute("4")]
public class System.Windows.TemplatePartAttribute : Attribute {
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
}
[AttributeUsageAttribute("4")]
public class System.Windows.TemplateVisualStateAttribute : Attribute {
    public string Name { get; public set; }
    public string GroupName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_GroupName();
    [CompilerGeneratedAttribute]
public void set_GroupName(string value);
}
[MarkupExtensionReturnTypeAttribute("System.Uri")]
public class System.Windows.ThemeDictionaryExtension : MarkupExtension {
    public string AssemblyName { get; public set; }
    public ThemeDictionaryExtension(string assemblyName);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    internal static Uri GenerateFallbackUri(ResourceDictionary dictionary, string resourceName);
    internal static void OnThemeChanged();
}
[AttributeUsageAttribute("1")]
public class System.Windows.ThemeInfoAttribute : Attribute {
    public ResourceDictionaryLocation ThemeDictionaryLocation { get; }
    public ResourceDictionaryLocation GenericDictionaryLocation { get; }
    public ThemeInfoAttribute(ResourceDictionaryLocation themeDictionaryLocation, ResourceDictionaryLocation genericDictionaryLocation);
    public ResourceDictionaryLocation get_ThemeDictionaryLocation();
    public ResourceDictionaryLocation get_GenericDictionaryLocation();
    internal static ThemeInfoAttribute FromAssembly(Assembly assembly);
}
[TypeConverterAttribute("System.Windows.ThicknessConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Thickness : ValueType {
    private double _Left;
    private double _Top;
    private double _Right;
    private double _Bottom;
    internal bool IsZero { get; }
    internal bool IsUniform { get; }
    public double Left { get; public set; }
    public double Top { get; public set; }
    public double Right { get; public set; }
    public double Bottom { get; public set; }
    internal Size Size { get; }
    public Thickness(double uniformLength);
    public Thickness(double left, double top, double right, double bottom);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Thickness thickness);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToString(CultureInfo cultureInfo);
    internal bool get_IsZero();
    internal bool get_IsUniform();
    internal bool IsValid(bool allowNegative, bool allowNaN, bool allowPositiveInfinity, bool allowNegativeInfinity);
    internal bool IsClose(Thickness thickness);
    internal static bool AreClose(Thickness thickness0, Thickness thickness1);
    public static bool op_Equality(Thickness t1, Thickness t2);
    public static bool op_Inequality(Thickness t1, Thickness t2);
    public double get_Left();
    public void set_Left(double value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Right();
    public void set_Right(double value);
    public double get_Bottom();
    public void set_Bottom(double value);
    internal Size get_Size();
}
public class System.Windows.ThicknessConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    [SecurityCriticalAttribute]
public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(Thickness th, CultureInfo cultureInfo);
    internal static Thickness FromString(string s, CultureInfo cultureInfo);
}
internal class System.Windows.TreeChangeInfo : ValueType {
    private Stack`1<FrugalObjectList`1<DependencyProperty>> _inheritablePropertiesStack;
    private object _topmostCollapsedParentNode;
    private bool _isAddOperation;
    private DependencyObject _rootOfChange;
    private InheritablePropertyChangeInfo[] _rootInheritableValues;
    private int _valueIndexer;
    internal Stack`1<FrugalObjectList`1<DependencyProperty>> InheritablePropertiesStack { get; }
    internal object TopmostCollapsedParentNode { get; internal set; }
    internal bool IsAddOperation { get; }
    internal DependencyObject Root { get; }
    public TreeChangeInfo(DependencyObject root, DependencyObject parent, bool isAddOperation);
    internal FrugalObjectList`1<DependencyProperty> CreateParentInheritableProperties(DependencyObject d, DependencyObject parent, bool isAddOperation);
    internal void ResetInheritableValueIndexer();
    internal InheritablePropertyChangeInfo GetRootInheritableValue(DependencyProperty dp);
    internal Stack`1<FrugalObjectList`1<DependencyProperty>> get_InheritablePropertiesStack();
    internal object get_TopmostCollapsedParentNode();
    internal void set_TopmostCollapsedParentNode(object value);
    internal bool get_IsAddOperation();
    internal DependencyObject get_Root();
}
internal static class System.Windows.TreeWalkHelper : object {
    private static TreeWalkHelper();
    internal static void InvalidateOnTreeChange(FrameworkElement fe, FrameworkContentElement fce, DependencyObject parent, bool isAddOperation);
    internal static FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo info, FrameworkElement fe, FrameworkContentElement fce, Style selfStyle, Style selfThemeStyle, ChildRecord& childRecord, bool isChildRecordValid, bool hasStyleChanged, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal static void InvalidateOnResourcesChange(FrameworkElement fe, FrameworkContentElement fce, ResourcesChangeInfo info);
    internal static void OnResourcesChanged(DependencyObject d, ResourcesChangeInfo info, bool raiseResourceChangedEvent);
    internal static void InvalidateOnInheritablePropertyChange(FrameworkElement fe, FrameworkContentElement fce, InheritablePropertyChangeInfo info, bool skipStartNode);
    internal static void OnInheritedPropertyChanged(DependencyObject d, InheritablePropertyChangeInfo& info, InheritanceBehavior inheritanceBehavior);
    internal static bool IsInheritanceNode(DependencyObject d, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool IsInheritanceNode(FrameworkElement fe, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool IsInheritanceNode(FrameworkContentElement fce, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool SkipNow(InheritanceBehavior inheritanceBehavior);
    internal static bool SkipNext(InheritanceBehavior inheritanceBehavior);
    internal static bool HasChildren(FrameworkElement fe, FrameworkContentElement fce);
}
internal enum System.Windows.TreeWalkPriority : Enum {
    public int value__;
    public static TreeWalkPriority LogicalTree;
    public static TreeWalkPriority VisualTree;
}
[ContentPropertyAttribute("Setters")]
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
public class System.Windows.Trigger : TriggerBase {
    [AmbientAttribute]
[LocalizabilityAttribute("0")]
public DependencyProperty Property { get; public set; }
    [DependsOnAttribute("Property")]
[DependsOnAttribute("SourceName")]
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public string SourceName { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public object get_Value();
    public void set_Value(object value);
    public string get_SourceName();
    public void set_SourceName(string value);
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal static Setter CheckChildIsSetter(object o);
    internal sealed virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
}
public abstract class System.Windows.TriggerAction : DependencyObject {
    internal TriggerBase ContainingTrigger { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal abstract virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate targetTemplate, long layer);
    internal abstract virtual void Invoke(FrameworkElement fe);
    internal TriggerBase get_ContainingTrigger();
    internal void Seal(TriggerBase containingTrigger);
    internal virtual void Seal();
    internal void CheckSealed();
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.TriggerActionCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TriggerAction Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    internal DependencyObject Owner { get; internal set; }
    public TriggerActionCollection(int initialSize);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(TriggerAction value);
    public sealed virtual bool Contains(TriggerAction value);
    public sealed virtual void CopyTo(TriggerAction[] array, int index);
    public sealed virtual int IndexOf(TriggerAction value);
    public sealed virtual void Insert(int index, TriggerAction value);
    public sealed virtual bool Remove(TriggerAction value);
    public sealed virtual TriggerAction get_Item(int index);
    public sealed virtual void set_Item(int index, TriggerAction value);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<TriggerAction> GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Seal(TriggerBase containingTrigger);
    internal DependencyObject get_Owner();
    internal void set_Owner(DependencyObject value);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.TriggerBase : DependencyObject {
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection EnterActions { get; }
    internal bool HasEnterActions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection ExitActions { get; }
    internal bool HasExitActions { get; }
    internal bool ExecuteEnterActionsOnApply { get; }
    internal bool ExecuteExitActionsOnApply { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal long Layer { get; }
    internal TriggerCondition[] TriggerConditions { get; internal set; }
    private static TriggerBase();
    public TriggerActionCollection get_EnterActions();
    internal bool get_HasEnterActions();
    public TriggerActionCollection get_ExitActions();
    internal bool get_HasExitActions();
    internal bool get_ExecuteEnterActionsOnApply();
    internal bool get_ExecuteExitActionsOnApply();
    internal void ProcessParametersContainer(DependencyProperty dp);
    internal string ProcessParametersVisualTreeChild(DependencyProperty dp, string target);
    internal void AddToPropertyValues(string childName, DependencyProperty dp, object value, PropertyValueType valueType);
    internal virtual void Seal();
    internal void ProcessSettersCollection(SetterBaseCollection setters);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal long get_Layer();
    internal void EstablishLayer();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    internal TriggerCondition[] get_TriggerConditions();
    internal void set_TriggerConditions(TriggerCondition[] value);
}
[LocalizabilityAttribute("0")]
public class System.Windows.TriggerCollection : Collection`1<TriggerBase> {
    public bool IsSealed { get; }
    internal FrameworkElement Owner { get; }
    internal TriggerCollection(FrameworkElement owner);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TriggerBase item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TriggerBase item);
    public bool get_IsSealed();
    internal void Seal();
    internal FrameworkElement get_Owner();
}
internal class System.Windows.TriggerCondition : ValueType {
    internal DependencyProperty Property;
    internal BindingBase Binding;
    internal LogicalOp LogicalOp;
    internal object Value;
    internal string SourceName;
    internal int SourceChildIndex;
    internal BindingValueCache BindingValueCache;
    internal TriggerCondition(DependencyProperty dp, LogicalOp logicalOp, object value, string sourceName);
    internal TriggerCondition(BindingBase binding, LogicalOp logicalOp, object value);
    internal TriggerCondition(BindingBase binding, LogicalOp logicalOp, object value, string sourceName);
    internal bool Match(object state);
    internal bool ConvertAndMatch(object state);
    internal bool TypeSpecificEquals(TriggerCondition value);
}
internal class System.Windows.TriggerSourceRecord : ValueType {
    public FrugalStructList`1<ChildPropertyDependent> ChildPropertyDependents;
}
internal enum System.Windows.ValueLookupType : Enum {
    public int value__;
    public static ValueLookupType Simple;
    public static ValueLookupType Trigger;
    public static ValueLookupType PropertyTriggerResource;
    public static ValueLookupType DataTrigger;
    public static ValueLookupType DataTriggerResource;
    public static ValueLookupType TemplateBinding;
    public static ValueLookupType Resource;
}
public class System.Windows.ValueSource : ValueType {
    private BaseValueSource _baseValueSource;
    private bool _isExpression;
    private bool _isAnimated;
    private bool _isCoerced;
    private bool _isCurrent;
    public BaseValueSource BaseValueSource { get; }
    public bool IsExpression { get; }
    public bool IsAnimated { get; }
    public bool IsCoerced { get; }
    public bool IsCurrent { get; }
    internal ValueSource(BaseValueSourceInternal source, bool isExpression, bool isAnimated, bool isCoerced, bool isCurrent);
    public BaseValueSource get_BaseValueSource();
    public bool get_IsExpression();
    public bool get_IsAnimated();
    public bool get_IsCoerced();
    public bool get_IsCurrent();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(ValueSource vs1, ValueSource vs2);
    public static bool op_Inequality(ValueSource vs1, ValueSource vs2);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.VerticalAlignment : Enum {
    public int value__;
    public static VerticalAlignment Top;
    public static VerticalAlignment Center;
    public static VerticalAlignment Bottom;
    public static VerticalAlignment Stretch;
}
internal class System.Windows.VisitedCallback`1 : MulticastDelegate {
    public VisitedCallback`1(object object, IntPtr method);
    public virtual bool Invoke(DependencyObject d, T data, bool visitedViaVisualTree);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, T data, bool visitedViaVisualTree, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ContentPropertyAttribute("Storyboard")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.VisualState : DependencyObject {
    public string Name { get; public set; }
    public Storyboard Storyboard { get; public set; }
    private static VisualState();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
}
public class System.Windows.VisualStateChangedEventArgs : EventArgs {
    public VisualState OldState { get; }
    public VisualState NewState { get; }
    public FrameworkElement Control { get; }
    public FrameworkElement StateGroupsRoot { get; }
    internal VisualStateChangedEventArgs(VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    public VisualState get_OldState();
    public VisualState get_NewState();
    public FrameworkElement get_Control();
    public FrameworkElement get_StateGroupsRoot();
}
[ContentPropertyAttribute("States")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.VisualStateGroup : DependencyObject {
    public string Name { get; public set; }
    public IList States { get; }
    public IList Transitions { get; }
    public VisualState CurrentState { get; internal set; }
    internal Collection`1<Storyboard> CurrentStoryboards { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public IList get_States();
    public IList get_Transitions();
    [CompilerGeneratedAttribute]
public VisualState get_CurrentState();
    [CompilerGeneratedAttribute]
internal void set_CurrentState(VisualState value);
    internal VisualState GetState(string stateName);
    internal Collection`1<Storyboard> get_CurrentStoryboards();
    internal void StartNewThenStopOld(FrameworkElement element, Storyboard[] newStoryboards);
    internal void RaiseCurrentStateChanging(FrameworkElement stateGroupsRoot, VisualState oldState, VisualState newState, FrameworkElement control);
    internal void RaiseCurrentStateChanged(FrameworkElement stateGroupsRoot, VisualState oldState, VisualState newState, FrameworkElement control);
    [CompilerGeneratedAttribute]
public void add_CurrentStateChanged(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateChanged(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CurrentStateChanging(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateChanging(EventHandler`1<VisualStateChangedEventArgs> value);
}
public class System.Windows.VisualStateManager : DependencyObject {
    public static DependencyProperty CustomVisualStateManagerProperty;
    public static DependencyProperty VisualStateGroupsProperty;
    private static VisualStateManager();
    public static bool GoToState(FrameworkElement control, string stateName, bool useTransitions);
    public static bool GoToElementState(FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);
    protected virtual bool GoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions);
    public static VisualStateManager GetCustomVisualStateManager(FrameworkElement obj);
    public static void SetCustomVisualStateManager(FrameworkElement obj, VisualStateManager value);
    internal static Collection`1<VisualStateGroup> GetVisualStateGroupsInternal(FrameworkElement obj);
    [DesignerSerializationVisibilityAttribute("2")]
public static IList GetVisualStateGroups(FrameworkElement obj);
    internal static bool TryGetState(IList`1<VisualStateGroup> groups, string stateName, VisualStateGroup& group, VisualState& state);
    protected void RaiseCurrentStateChanging(VisualStateGroup stateGroup, VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    protected void RaiseCurrentStateChanged(VisualStateGroup stateGroup, VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    internal static VisualTransition GetTransition(FrameworkElement element, VisualStateGroup group, VisualState from, VisualState to);
}
[ContentPropertyAttribute("Storyboard")]
public class System.Windows.VisualTransition : DependencyObject {
    public string From { get; public set; }
    public string To { get; public set; }
    public Storyboard Storyboard { get; public set; }
    [TypeConverterAttribute("System.Windows.DurationConverter")]
public Duration GeneratedDuration { get; public set; }
    public IEasingFunction GeneratedEasingFunction { get; public set; }
    internal bool IsDefault { get; }
    internal bool DynamicStoryboardCompleted { get; internal set; }
    internal bool ExplicitStoryboardCompleted { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_From();
    [CompilerGeneratedAttribute]
public void set_From(string value);
    [CompilerGeneratedAttribute]
public string get_To();
    [CompilerGeneratedAttribute]
public void set_To(string value);
    [CompilerGeneratedAttribute]
public Storyboard get_Storyboard();
    [CompilerGeneratedAttribute]
public void set_Storyboard(Storyboard value);
    public Duration get_GeneratedDuration();
    public void set_GeneratedDuration(Duration value);
    [CompilerGeneratedAttribute]
public IEasingFunction get_GeneratedEasingFunction();
    [CompilerGeneratedAttribute]
public void set_GeneratedEasingFunction(IEasingFunction value);
    internal bool get_IsDefault();
    [CompilerGeneratedAttribute]
internal bool get_DynamicStoryboardCompleted();
    [CompilerGeneratedAttribute]
internal void set_DynamicStoryboardCompleted(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExplicitStoryboardCompleted();
    [CompilerGeneratedAttribute]
internal void set_ExplicitStoryboardCompleted(bool value);
}
[LocalizabilityAttribute("16")]
public class System.Windows.Window : ContentControl {
    public static DependencyProperty TaskbarItemInfoProperty;
    public static RoutedEvent DpiChangedEvent;
    public static DependencyProperty AllowsTransparencyProperty;
    public static DependencyProperty TitleProperty;
    public static DependencyProperty IconProperty;
    public static DependencyProperty SizeToContentProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty ShowInTaskbarProperty;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty WindowStyleProperty;
    public static DependencyProperty WindowStateProperty;
    public static DependencyProperty ResizeModeProperty;
    public static DependencyProperty TopmostProperty;
    public static DependencyProperty ShowActivatedProperty;
    internal static RoutedCommand DialogCancelCommand;
    internal static DependencyProperty IWindowServiceProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public TaskbarItemInfo TaskbarItemInfo { get; public set; }
    public bool AllowsTransparency { get; public set; }
    [LocalizabilityAttribute("2")]
public string Title { get; public set; }
    public ImageSource Icon { get; public set; }
    public SizeToContent SizeToContent { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double Top { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double Left { get; public set; }
    public Rect RestoreBounds { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WindowStartupLocation WindowStartupLocation { get; public set; }
    public bool ShowInTaskbar { get; public set; }
    public bool IsActive { get; }
    [DefaultValueAttribute("")]
public Window Owner { get; public set; }
    public WindowCollection OwnedWindows { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[TypeConverterAttribute("System.Windows.DialogResultConverter")]
public Nullable`1<bool> DialogResult { get; public set; }
    public WindowStyle WindowStyle { get; public set; }
    public WindowState WindowState { get; public set; }
    public ResizeMode ResizeMode { get; public set; }
    public bool Topmost { get; public set; }
    public bool ShowActivated { get; public set; }
    internal bool IsSourceWindowNull { get; }
    internal bool IsCompositionTargetInvalid { get; }
    internal RECT WorkAreaBoundsForNearestMonitor { get; }
    internal Size WindowSize { get; }
    internal HwndSource HwndSourceWindow { get; }
    internal bool HwndCreatedButNotShown { get; }
    internal bool IsDisposed { get; }
    internal bool IsVisibilitySet { get; }
    internal IntPtr CriticalHandle { get; }
    internal IntPtr OwnerHandle { get; internal set; }
    internal int Win32Style { get; internal set; }
    internal int _Style { get; internal set; }
    internal int _StyleEx { get; internal set; }
    internal HwndStyleManager Manager { get; internal set; }
    private bool System.Windows.IWindowService.UserResized { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
private static Window();
    [SecurityCriticalAttribute]
internal Window(bool inRbw);
    public void Show();
    public void Hide();
    [SecurityCriticalAttribute]
public void Close();
    [SecurityCriticalAttribute]
public void DragMove();
    [SecurityCriticalAttribute]
public Nullable`1<bool> ShowDialog();
    [SecurityCriticalAttribute]
public bool Activate();
    protected internal virtual IEnumerator get_LogicalChildren();
    public static Window GetWindow(DependencyObject dependencyObject);
    public TaskbarItemInfo get_TaskbarItemInfo();
    public void set_TaskbarItemInfo(TaskbarItemInfo value);
    public bool get_AllowsTransparency();
    public void set_AllowsTransparency(bool value);
    public sealed virtual string get_Title();
    public sealed virtual void set_Title(string value);
    public ImageSource get_Icon();
    [SecurityCriticalAttribute]
public void set_Icon(ImageSource value);
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Left();
    public void set_Left(double value);
    [SecurityCriticalAttribute]
public Rect get_RestoreBounds();
    public WindowStartupLocation get_WindowStartupLocation();
    public void set_WindowStartupLocation(WindowStartupLocation value);
    public bool get_ShowInTaskbar();
    public void set_ShowInTaskbar(bool value);
    public bool get_IsActive();
    [SecurityCriticalAttribute]
public Window get_Owner();
    [SecurityCriticalAttribute]
public void set_Owner(Window value);
    public WindowCollection get_OwnedWindows();
    public Nullable`1<bool> get_DialogResult();
    public void set_DialogResult(Nullable`1<bool> value);
    public WindowStyle get_WindowStyle();
    public void set_WindowStyle(WindowStyle value);
    public WindowState get_WindowState();
    public void set_WindowState(WindowState value);
    public ResizeMode get_ResizeMode();
    public void set_ResizeMode(ResizeMode value);
    public bool get_Topmost();
    public void set_Topmost(bool value);
    public bool get_ShowActivated();
    public void set_ShowActivated(bool value);
    public void add_SourceInitialized(EventHandler value);
    public void remove_SourceInitialized(EventHandler value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    public void add_Activated(EventHandler value);
    public void remove_Activated(EventHandler value);
    public void add_Deactivated(EventHandler value);
    public void remove_Deactivated(EventHandler value);
    public void add_StateChanged(EventHandler value);
    public void remove_StateChanged(EventHandler value);
    public void add_LocationChanged(EventHandler value);
    public void remove_LocationChanged(EventHandler value);
    public void add_Closing(CancelEventHandler value);
    public void remove_Closing(CancelEventHandler value);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    public sealed virtual void add_ContentRendered(EventHandler value);
    public sealed virtual void remove_ContentRendered(EventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected internal sealed virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnSourceInitialized(EventArgs e);
    protected virtual void OnActivated(EventArgs e);
    protected virtual void OnDeactivated(EventArgs e);
    protected virtual void OnStateChanged(EventArgs e);
    protected virtual void OnLocationChanged(EventArgs e);
    protected virtual void OnClosing(CancelEventArgs e);
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnContentRendered(EventArgs e);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Point DeviceToLogicalUnits(Point ptDeviceUnits);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal Point LogicalToDeviceUnits(Point ptLogicalUnits);
    internal static bool VisibilityToBool(Visibility v);
    internal virtual void SetResizeGripControl(Control ctrl);
    internal virtual void ClearResizeGripControl(Control oldCtrl);
    internal virtual void TryClearingMainWindow();
    [SecurityCriticalAttribute]
internal void InternalClose(bool shutdown, bool ignoreCancel);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsSourceWindowNull();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal bool get_IsCompositionTargetInvalid();
    internal RECT get_WorkAreaBoundsForNearestMonitor();
    internal Size get_WindowSize();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal HwndSource get_HwndSourceWindow();
    internal virtual void OnAncestorChanged();
    internal virtual void CreateAllStyle();
    [SecurityCriticalAttribute]
internal virtual void CreateSourceWindowDuringShow();
    [SecurityCriticalAttribute]
internal void CreateSourceWindow(bool duringShow);
    [SecurityCriticalAttribute]
internal virtual HwndSourceParameters CreateHwndSourceParameters();
    internal virtual void CorrectStyleForBorderlessWindowCase();
    internal virtual void GetRequestedDimensions(Double& requestedLeft, Double& requestedTop, Double& requestedWidth, Double& requestedHeight);
    [SecurityCriticalAttribute]
internal virtual void SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight);
    [SecurityCriticalAttribute]
internal void SetRootVisual();
    [SecurityCriticalAttribute]
internal void SetRootVisualAndUpdateSTC();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void UpdateTitle(string title);
    internal void HandleActivate(bool windowActivated);
    internal virtual void UpdateHeight(double newHeight);
    internal virtual void UpdateWidth(double newWidth);
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal virtual void VerifyApiSupported();
    internal bool get_HwndCreatedButNotShown();
    internal bool get_IsDisposed();
    internal bool get_IsVisibilitySet();
    [SecurityCriticalAttribute]
internal IntPtr get_CriticalHandle();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal IntPtr get_OwnerHandle();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set_OwnerHandle(IntPtr value);
    internal int get_Win32Style();
    internal void set_Win32Style(int value);
    internal int get__Style();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set__Style(int value);
    internal int get__StyleEx();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void set__StyleEx(int value);
    internal HwndStyleManager get_Manager();
    internal void set_Manager(HwndStyleManager value);
    private sealed virtual override bool System.Windows.IWindowService.get_UserResized();
    internal virtual WindowMinMax GetWindowMinMax();
    internal void VerifyContextAndObjectState();
    [SecurityCriticalAttribute]
internal static void CalculateCenterScreenPosition(IntPtr hMonitor, Size currentSizeDeviceUnits, Double& leftDeviceUnits, Double& topDeviceUnits);
    internal virtual void WmMoveChangedHelper();
    internal virtual bool HandleWmNcHitTestMsg(IntPtr lParam, IntPtr& refInt);
    internal virtual int nCmdForShow();
    [SecurityCriticalAttribute]
[SecurityTreatAsSafeAttribute]
internal void Flush();
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.WindowCollection : object {
    public Window Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal WindowCollection(int count);
    public Window get_Item(int index);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Window[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    internal WindowCollection Clone();
    internal void Remove(Window win);
    internal void RemoveAt(int index);
    internal int Add(Window win);
    internal bool HasItem(Window win);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.WindowStartupLocation : Enum {
    public int value__;
    public static WindowStartupLocation Manual;
    public static WindowStartupLocation CenterScreen;
    public static WindowStartupLocation CenterOwner;
}
public enum System.Windows.WindowState : Enum {
    public int value__;
    public static WindowState Normal;
    public static WindowState Minimized;
    public static WindowState Maximized;
}
public enum System.Windows.WindowStyle : Enum {
    public int value__;
    public static WindowStyle None;
    public static WindowStyle SingleBorderWindow;
    public static WindowStyle ThreeDBorderWindow;
    public static WindowStyle ToolWindow;
}
public enum System.Windows.WrapDirection : Enum {
    public int value__;
    public static WrapDirection None;
    public static WrapDirection Left;
    public static WrapDirection Right;
    public static WrapDirection Both;
}
