internal class System.ServiceModel.Activation.ApplyHostConfigurationBehavior : object {
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase service);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase service, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase service);
}
internal class System.ServiceModel.Activation.AspNetRouteServiceHttpHandler : object {
    public bool IsReusable { get; }
    public AspNetRouteServiceHttpHandler(string virtualPath);
    public sealed virtual bool get_IsReusable();
    [SecurityCriticalAttribute]
public sealed virtual void ProcessRequest(HttpContext context);
    [SecurityCriticalAttribute]
public sealed virtual IAsyncResult BeginProcessRequest(HttpContext context, AsyncCallback callback, object extraData);
    public sealed virtual void EndProcessRequest(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.ServiceModel.Activation.AuthFlags : Enum {
    public int value__;
    public static AuthFlags None;
    public static AuthFlags AuthAnonymous;
    public static AuthFlags AuthBasic;
    public static AuthFlags AuthNTLM;
    public static AuthFlags AuthMD5;
    public static AuthFlags AuthPassport;
}
[DefaultMemberAttribute("Item")]
internal class System.ServiceModel.Activation.CollectibleLRUCache`2 : object {
    public CollectibleNode<TKey, TValue> Item { get; }
    public int Count { get; }
    public CollectibleLRUCache`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public CollectibleNode<TKey, TValue> get_Item(TKey key);
    public CollectibleNode<TKey, TValue> UnsafeGet(TKey key);
    public void Touch(TKey key);
    public void UnsafeRemove(CollectibleNode<TKey, TValue> node);
    public void UnsafeAdd(CollectibleNode<TKey, TValue> node);
    public bool UnsafeBeginBatchCollect();
    public bool UnsafeBeginBatchCollect(bool collectingAll);
    public void EndBatchCollect();
    public void Abort();
    public int get_Count();
    public IDisposable CreateWriterLockScope();
}
internal static class System.ServiceModel.Activation.Configuration.AppSettings : object {
    internal static bool UseClassicReadEntityMode { get; }
    private static AppSettings();
    internal static bool get_UseClassicReadEntityMode();
}
internal static class System.ServiceModel.Activation.Diagnostics.TraceCode : object {
    public static int Activation;
    public static int WebHostFailedToCompile;
    public static int WebHostServiceActivated;
    public static int WebHostFailedToActivateService;
    public static int WebHostCompilation;
    public static int WebHostDebugRequest;
    public static int WebHostProtocolMisconfigured;
    public static int WebHostServiceCloseFailed;
    public static int WebHostNoCBTSupport;
}
internal static class System.ServiceModel.Activation.Diagnostics.TraceUtility : object {
    private static TraceUtility();
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, object source, Exception exception);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord record, object source, Exception exception);
    internal static string CreateSourceString(object source);
}
[FlagsAttribute]
internal enum System.ServiceModel.Activation.ExtendedProtectionFlags : Enum {
    public int value__;
    public static ExtendedProtectionFlags None;
    public static ExtendedProtectionFlags Proxy;
    public static ExtendedProtectionFlags NoServiceNameCheck;
    public static ExtendedProtectionFlags AllowDotlessSpn;
    public static ExtendedProtectionFlags ProxyCohosting;
}
internal enum System.ServiceModel.Activation.ExtendedProtectionTokenChecking : Enum {
    public int value__;
    public static ExtendedProtectionTokenChecking None;
    public static ExtendedProtectionTokenChecking Allow;
    public static ExtendedProtectionTokenChecking Require;
}
internal static class System.ServiceModel.Activation.FxTrace : object {
    public static bool ShouldTraceCritical { get; }
    public static bool TracingEnabled { get; }
    public static bool ShouldTraceError { get; }
    public static bool ShouldTraceInformation { get; }
    public static bool ShouldTraceVerbose { get; }
    public static bool ShouldTraceWarning { get; }
    public static bool ShouldTraceCriticalToTraceSource { get; }
    public static bool ShouldTraceErrorToTraceSource { get; }
    public static bool ShouldTraceInformationToTraceSource { get; }
    public static bool ShouldTraceVerboseToTraceSource { get; }
    public static bool ShouldTraceWarningToTraceSource { get; }
    public static ExceptionTrace Exception { get; }
    public static EtwDiagnosticTrace Trace { get; }
    public static EventLogger EventLog { get; }
    private static FxTrace();
    [SecuritySafeCriticalAttribute]
public static void UpdateEventDefinitions(EventDescriptor[] eventDescriptors, UInt16[] end2EndEvents);
    public static bool IsEventEnabled(int index);
    public static bool get_ShouldTraceCritical();
    public static bool get_TracingEnabled();
    public static bool get_ShouldTraceError();
    public static bool get_ShouldTraceInformation();
    public static bool get_ShouldTraceVerbose();
    public static bool get_ShouldTraceWarning();
    public static bool get_ShouldTraceCriticalToTraceSource();
    public static bool get_ShouldTraceErrorToTraceSource();
    public static bool get_ShouldTraceInformationToTraceSource();
    public static bool get_ShouldTraceVerboseToTraceSource();
    public static bool get_ShouldTraceWarningToTraceSource();
    public static ExceptionTrace get_Exception();
    public static EtwDiagnosticTrace get_Trace();
    public static EventLogger get_EventLog();
}
internal class System.ServiceModel.Activation.HostedAspNetEnvironment : AspNetEnvironment {
    public bool AspNetCompatibilityEnabled { get; }
    public string ConfigurationPath { get; }
    public bool IsConfigurationBased { get; }
    public string CurrentVirtualPath { get; }
    public string XamlFileBaseLocation { get; }
    public bool UsingIntegratedPipeline { get; }
    public string WebSocketVersion { get; }
    public bool IsSimpleApplicationHost { get; }
    private static HostedAspNetEnvironment();
    public virtual bool get_AspNetCompatibilityEnabled();
    public virtual string get_ConfigurationPath();
    public virtual bool get_IsConfigurationBased();
    public virtual string get_CurrentVirtualPath();
    public virtual string get_XamlFileBaseLocation();
    public virtual bool get_UsingIntegratedPipeline();
    public virtual string get_WebSocketVersion();
    public static void Enable();
    public static void TrySetWebSocketVersion(HttpApplication application);
    public virtual void AddHostingBehavior(ServiceHostBase serviceHost, ServiceDescription description);
    public virtual bool IsWebConfigAboveApplication(object configHostingContext);
    public virtual void EnsureCompatibilityRequirements(ServiceDescription description);
    public virtual bool TryGetFullVirtualPath(String& virtualPath);
    public virtual string GetAnnotationFromHost(ServiceHostBase host);
    public virtual void EnsureAllReferencedAssemblyLoaded();
    public virtual BaseUriWithWildcard GetBaseUri(string transportScheme, Uri listenUri);
    public virtual void ValidateHttpSettings(string virtualPath, bool isMetadataListener, bool usingDefaultSpnList, AuthenticationSchemes& bindingElementAuthenticationSchemes, ExtendedProtectionPolicy& extendedProtectionPolicy, String& realm);
    public virtual bool ValidateHttpsSettings(string virtualPath, Boolean& requireClientCertificate);
    public virtual void ProcessNotMatchedEndpointAddress(Uri uri, string endpointName);
    public virtual void ValidateCompatibilityRequirements(AspNetCompatibilityRequirementsMode compatibilityMode);
    public virtual IAspNetMessageProperty GetHostingProperty(Message message);
    public virtual IAspNetMessageProperty GetHostingProperty(Message message, bool removeFromMessage);
    public virtual void PrepareMessageForDispatch(Message message);
    public virtual void ApplyHostedContext(TransportChannelListener listener, BindingContext context);
    internal virtual void AddMetadataBindingParameters(Uri listenUri, KeyedByTypeCollection`1<IServiceBehavior> serviceBehaviors, BindingParameterCollection bindingParameters);
    internal virtual bool IsMetadataListener(BindingParameterCollection bindingParameters);
    public virtual void IncrementBusyCount();
    public virtual void DecrementBusyCount();
    public virtual bool TraceIncrementBusyCountIsEnabled();
    public virtual bool TraceDecrementBusyCountIsEnabled();
    public virtual void TraceIncrementBusyCount(string data);
    public virtual void TraceDecrementBusyCount(string data);
    public virtual object GetConfigurationSection(string sectionPath);
    [SecurityCriticalAttribute]
public virtual object UnsafeGetConfigurationSection(string sectionPath);
    public virtual bool get_IsSimpleApplicationHost();
    public virtual AuthenticationSchemes GetAuthenticationSchemes(Uri baseAddress);
    [SecuritySafeCriticalAttribute]
public virtual bool IsWindowsAuthenticationConfigured();
    [SecurityCriticalAttribute]
internal static object UnsafeGetSectionFromWebConfigurationManager(string sectionPath, string virtualPath);
    public virtual bool IsWithinApp(string absoluteVirtualPath);
}
internal class System.ServiceModel.Activation.HostedBindingBehavior : object {
    public VirtualPathExtension VirtualPathExtension { get; }
    internal HostedBindingBehavior(VirtualPathExtension virtualPathExtension);
    public VirtualPathExtension get_VirtualPathExtension();
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription description, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription description, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection parameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription description, ServiceHostBase serviceHostBase);
}
internal class System.ServiceModel.Activation.HostedHttpContext : HttpRequestContext {
    public string HttpMethod { get; }
    public bool IsWebSocketRequest { get; }
    public HostedHttpContext(HttpChannelListener listener, HostedHttpRequestAsyncResult result);
    public virtual string get_HttpMethod();
    internal void CompleteWithException(Exception ex);
    protected virtual SecurityMessageProperty OnProcessAuthentication();
    protected virtual HttpStatusCode ValidateAuthentication();
    protected virtual Task`1<WebSocketContext> AcceptWebSocketCore(HttpResponseMessage response, string protocol);
    protected virtual void OnAcceptWebSocketSuccess(WebSocketContext context, HttpRequestMessage requestMessage);
    public virtual bool get_IsWebSocketRequest();
    protected virtual void OnReply(Message message, TimeSpan timeout);
    protected virtual IAsyncResult OnBeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual void OnAbort();
    protected virtual void Cleanup();
    protected virtual HttpInput GetHttpInput();
    public virtual HttpOutput GetHttpOutput(Message message);
    protected virtual void OnClose(TimeSpan timeout);
}
internal class System.ServiceModel.Activation.HostedHttpRequestAsyncResult : AsyncResult {
    public static WindowsIdentity AnonymousIdentity { get; }
    public static Action`1<object> WaitOnBeginRequest { get; }
    public static Action`1<object> WaitOnBeginRequestWithFlow { get; }
    public static ContextCallback ContextOnBeginRequest { get; }
    public static AsyncCallback ProcessRequestCompleteCallback { get; }
    public bool IISSupportsExtendedProtection { get; }
    public bool IsWebSocketRequest { get; }
    public WindowsIdentity LogonUserIdentity { get; }
    public HostedImpersonationContext ImpersonationContext { get; }
    public HostedThreadData HostedThreadData { get; }
    public EventTraceActivity EventTraceActivity { get; }
    public Uri OriginalRequestUri { get; private set; }
    public Uri RequestUri { get; private set; }
    public HttpApplication Application { get; }
    public string AspNetRouteServiceVirtualPath { get; private set; }
    [SecurityCriticalAttribute]
public HostedHttpRequestAsyncResult(HttpApplication context, bool flowContext, bool ensureWFService, AsyncCallback callback, object state);
    [SecurityCriticalAttribute]
public HostedHttpRequestAsyncResult(HttpApplication context, string aspNetRouteServiceVirtualPath, bool flowContext, bool ensureWFService, AsyncCallback callback, object state);
    [SecuritySafeCriticalAttribute]
public static WindowsIdentity get_AnonymousIdentity();
    [SecuritySafeCriticalAttribute]
public static Action`1<object> get_WaitOnBeginRequest();
    [SecuritySafeCriticalAttribute]
public static Action`1<object> get_WaitOnBeginRequestWithFlow();
    [SecuritySafeCriticalAttribute]
public static ContextCallback get_ContextOnBeginRequest();
    [SecuritySafeCriticalAttribute]
public static AsyncCallback get_ProcessRequestCompleteCallback();
    public sealed virtual bool get_IISSupportsExtendedProtection();
    public bool get_IsWebSocketRequest();
    [SecurityCriticalAttribute]
public static void ExecuteSynchronous(HttpApplication context, bool flowContext, bool ensureWFService);
    [SecurityCriticalAttribute]
public static void ExecuteSynchronous(HttpApplication context, string routeServiceVirtualPath, bool flowContext, bool ensureWFService);
    public WindowsIdentity get_LogonUserIdentity();
    private sealed virtual override WindowsIdentity System.ServiceModel.Channels.HttpChannelListener.IHttpAuthenticationContext.get_LogonUserIdentity();
    [SecuritySafeCriticalAttribute]
public HostedImpersonationContext get_ImpersonationContext();
    [SecuritySafeCriticalAttribute]
public HostedThreadData get_HostedThreadData();
    public EventTraceActivity get_EventTraceActivity();
    [CompilerGeneratedAttribute]
public Uri get_OriginalRequestUri();
    [CompilerGeneratedAttribute]
private void set_OriginalRequestUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
private void set_RequestUri(Uri value);
    [SecuritySafeCriticalAttribute]
public HttpApplication get_Application();
    [CompilerGeneratedAttribute]
public string get_AspNetRouteServiceVirtualPath();
    [CompilerGeneratedAttribute]
private void set_AspNetRouteServiceVirtualPath(string value);
    [SecuritySafeCriticalAttribute]
public Stream GetInputStream();
    public void OnReplySent();
    internal void CompleteOperation(Exception exception);
    public void Abort();
    internal bool TryStartStreamedRead();
    internal void SetStreamedReadFinished();
    public static void End(IAsyncResult result);
    private sealed virtual override X509Certificate2 System.ServiceModel.Channels.HttpChannelListener.IHttpAuthenticationContext.GetClientCertificate(Boolean& isValidCertificate);
    private sealed virtual override TraceRecord System.ServiceModel.Channels.HttpChannelListener.IHttpAuthenticationContext.CreateTraceRecord();
    [SecuritySafeCriticalAttribute]
internal void AddRefForImpersonation();
    [SecuritySafeCriticalAttribute]
internal void ReleaseImpersonation();
    [SecuritySafeCriticalAttribute]
internal void SetContentType(string contentType);
    [SecuritySafeCriticalAttribute]
internal void SetContentEncoding(string contentEncoding);
    [SecuritySafeCriticalAttribute]
internal void CompleteRequest();
    [SecuritySafeCriticalAttribute]
internal void SetTransferModeToStreaming();
    [SecuritySafeCriticalAttribute]
internal void AppendHeader(string name, string value);
    [SecuritySafeCriticalAttribute]
internal void SetStatusCode(int statusCode);
    [SecuritySafeCriticalAttribute]
internal void SetStatusDescription(string statusDescription);
    [SecuritySafeCriticalAttribute]
internal void SetConnectionClose();
    [SecuritySafeCriticalAttribute]
internal Byte[] GetPrereadBuffer(Int32& contentLength);
    [SecuritySafeCriticalAttribute]
internal Stream GetOutputStream();
    [SecuritySafeCriticalAttribute]
internal string GetHttpMethod();
    [SecuritySafeCriticalAttribute]
internal string GetContentType();
    [SecuritySafeCriticalAttribute]
internal string GetAcceptEncoding();
    [SecuritySafeCriticalAttribute]
internal string GetContentTypeFast();
    [SecuritySafeCriticalAttribute]
internal int GetContentLength();
    [SecuritySafeCriticalAttribute]
internal string GetSoapAction();
    [SecuritySafeCriticalAttribute]
internal ChannelBinding GetChannelBinding();
}
internal class System.ServiceModel.Activation.HostedHttpTransportManager : HttpTransportManager {
    internal string Scheme { get; }
    internal string Host { get; }
    internal int Port { get; }
    internal HostedHttpTransportManager(BaseUriWithWildcard baseAddress);
    private static HostedHttpTransportManager();
    internal virtual bool IsCompatible(HttpChannelListener factory);
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnOpen();
    internal virtual void OnAbort();
    internal virtual string get_Scheme();
    internal string get_Host();
    internal int get_Port();
    public void TraceConnectionInformation(HostedHttpRequestAsyncResult result);
    [SecuritySafeCriticalAttribute]
public ServiceModelActivity CreateReceiveBytesActivity(HostedHttpRequestAsyncResult result);
    internal void HttpContextReceived(HostedHttpRequestAsyncResult result);
}
internal class System.ServiceModel.Activation.HostedImpersonationContext : object {
    public bool IsImpersonated { get; }
    [SecuritySafeCriticalAttribute]
public bool get_IsImpersonated();
    [SecurityCriticalAttribute]
public IDisposable Impersonate();
    [SecurityCriticalAttribute]
public void AddRef();
    [SecurityCriticalAttribute]
public void Release();
}
internal class System.ServiceModel.Activation.HostedNamedPipeTransportManager : NamedPipeTransportManager {
    public HostedNamedPipeTransportManager(BaseUriWithWildcard baseAddress);
    protected virtual bool IsCompatible(NamedPipeChannelListener channelListener);
    internal void Start(int queueId, Guid token, Action messageReceivedCallback);
    internal virtual void OnOpen();
    internal virtual void OnAbort();
    internal void Stop(TimeSpan timeout);
    internal virtual void OnClose(TimeSpan timeout);
    protected virtual void OnSelecting(NamedPipeChannelListener channelListener);
}
internal class System.ServiceModel.Activation.HostedServiceTransportSettings : object {
    public string Realm;
    public HttpAccessSslFlags AccessSslFlags;
    public AuthFlags AuthFlags;
    public String[] AuthProviders;
    public ExtendedProtectionPolicy IisExtendedProtectionPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public ExtendedProtectionPolicy get_IisExtendedProtectionPolicy();
    [CompilerGeneratedAttribute]
public void set_IisExtendedProtectionPolicy(ExtendedProtectionPolicy value);
}
internal class System.ServiceModel.Activation.HostedTcpTransportManager : SharedTcpTransportManager {
    public HostedTcpTransportManager(BaseUriWithWildcard baseAddress);
    internal void Start(int queueId, Guid token, Action messageReceivedCallback);
    internal virtual void OnOpen();
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnAbort();
    internal void Stop(TimeSpan timeout);
    protected virtual Action`1<Uri> GetOnViaCallback();
    protected virtual void OnSelecting(TcpChannelListener channelListener);
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Activation.HostedThreadData : object {
    public IDisposable CreateContext();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.ServiceModel.Activation.HostedTransportConfiguration : object {
    public abstract virtual Uri[] GetBaseAddresses(string virtualPath);
}
internal abstract class System.ServiceModel.Activation.HostedTransportConfigurationBase : HostedTransportConfiguration {
    internal string Scheme { get; }
    protected internal IList`1<BaseUriWithWildcard> ListenAddresses { get; }
    protected internal HostedTransportConfigurationBase(string scheme);
    internal string get_Scheme();
    protected internal IList`1<BaseUriWithWildcard> get_ListenAddresses();
    public virtual Uri[] GetBaseAddresses(string virtualPath);
    internal BaseUriWithWildcard FindBaseAddress(Uri uri);
}
internal class System.ServiceModel.Activation.HostedTransportConfigurationManager : object {
    internal static MetabaseSettings MetabaseSettings { get; }
    private static HostedTransportConfigurationManager();
    internal static void EnsureInitializedForSimpleApplicationHost(HostedHttpRequestAsyncResult result);
    internal static MetabaseSettings get_MetabaseSettings();
    internal static Uri[] GetBaseAddresses(string virtualPath);
    internal static HostedTransportConfiguration GetConfiguration(string scheme);
}
internal class System.ServiceModel.Activation.HostingMessageProperty : object {
    public Uri OriginalRequestUri { get; private set; }
    internal static string Name { get; }
    [SecurityCriticalAttribute]
internal HostingMessageProperty(HostedHttpRequestAsyncResult result);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_OriginalRequestUri();
    [CompilerGeneratedAttribute]
private void set_OriginalRequestUri(Uri value);
    internal static string get_Name();
    [SecurityCriticalAttribute]
public sealed virtual IDisposable ApplyIntegrationContext();
    [SecurityCriticalAttribute]
public sealed virtual IDisposable Impersonate();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Close();
}
[FlagsAttribute]
internal enum System.ServiceModel.Activation.HttpAccessSslFlags : Enum {
    public int value__;
    public static HttpAccessSslFlags None;
    public static HttpAccessSslFlags Ssl;
    public static HttpAccessSslFlags SslNegotiateCert;
    public static HttpAccessSslFlags SslRequireCert;
    public static HttpAccessSslFlags SslMapCert;
    public static HttpAccessSslFlags Ssl128;
}
internal class System.ServiceModel.Activation.HttpHandler : object {
    public bool IsReusable { get; }
    public sealed virtual bool get_IsReusable();
    [SecurityCriticalAttribute]
public sealed virtual void ProcessRequest(HttpContext context);
}
internal class System.ServiceModel.Activation.HttpHostedTransportConfiguration : HostedTransportConfigurationBase {
    protected internal HttpHostedTransportConfiguration(string scheme);
    private static HttpHostedTransportConfiguration();
    internal HostedHttpTransportManager GetHttpTransportManager(Uri uri);
}
internal class System.ServiceModel.Activation.HttpModule : object {
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public sealed virtual void Init(HttpApplication context);
}
internal class System.ServiceModel.Activation.HttpsHostedTransportConfiguration : HttpHostedTransportConfiguration {
}
[GuidAttribute("70B51430-B6CA-11d0-B9B9-00A0C922E750")]
[InterfaceTypeAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface System.ServiceModel.Activation.IMSAdminBase {
    public abstract virtual UInt32 AddKey(UInt32 hMDHandle, string pszMDPath);
    public abstract virtual UInt32 DeleteKey(UInt32 hMDHandle, string pszMDPath);
    public abstract virtual UInt32 DeleteChildKeys(UInt32 hMDHandle, string pszMDPath);
    public abstract virtual UInt32 EnumKeys(UInt32 hMDHandle, string pszMDPath, string pszMDName, UInt32 dwMDEnumObjectIndex);
    public abstract virtual UInt32 CopyKey(UInt32 hMDSourceHandle, string pszMDSourcePath, UInt32 hMDDestHandle, string pszMDDestPath, int bMDOverwriteFlag, int bMDCopyFlag);
    public abstract virtual UInt32 RenameKey(UInt32 hMDHandle, string pszMDPath, string pszMDNewName);
    [SecurityCriticalAttribute]
public abstract virtual UInt32 SetData(UInt32 hMDHandle, string pszMDPath, METADATA_RECORD pmdrMDData);
    [SecurityCriticalAttribute]
public abstract virtual UInt32 GetData(UInt32 hMDHandle, string pszMDPath, METADATA_RECORD& pmdrMDData, UInt32& pdwMDRequiredDataLen);
    public abstract virtual UInt32 DeleteData(UInt32 hMDHandle, string pszMDPath, UInt32 dwMDIdentifier, UInt32 dwMDDataType);
    [SecurityCriticalAttribute]
public abstract virtual UInt32 EnumData(UInt32 hMDHandle, string pszMDPath, METADATA_RECORD pmdrMDData, UInt32 dwMDEnumDataIndex, UInt32& pdwMDRequiredDataLen);
    public abstract virtual UInt32 GetAllData(UInt32 hMDHandle, string pszMDPath, UInt32 dwMDAttributes, UInt32 dwMDUserType, UInt32 dwMDDataType, UInt32& pdwMDNumDataEntries, UInt32& pdwMDDataSetNumber, UInt32 dwMDBufferSize, UInt32& pdwMDRequiredBufferSize, IntPtr ppDataBlob);
    public abstract virtual UInt32 DeleteAllData(UInt32 hMDHandle, string pszMDPath, UInt32 dwMDUserType, UInt32 dwMDDataType);
    public abstract virtual UInt32 CopyData(UInt32 hMDSourceHandle, string pszMDSourcePath, UInt32 hMDDestHandle, string pszMDDestPath, UInt32 dwMDAttributes, UInt32 dwMDUserType, UInt32 dwMDDataType, int bMDCopyFlag);
    public abstract virtual UInt32 GetDataPaths(UInt32 hMDHandle, string pszMDPath, UInt32 dwMDIdentifier, UInt32 dwMDDataType, UInt32 dwMDBufferSize, IntPtr pszBuffer, UInt32& pdwMDRequiredBufferSize);
    public abstract virtual UInt32 OpenKey(UInt32 hMDHandle, string pszMDPath, UInt32 dwMDAccessRequested, UInt32 dwMDTimeOut, UInt32& phMDNewHandle);
    public abstract virtual UInt32 CloseKey(UInt32 hMDHandle);
    public abstract virtual UInt32 ChangePermissions(UInt32 hMDHandle, UInt32 dwMDTimeOut, UInt32 dwMDAccessRequested);
    public abstract virtual UInt32 SaveData();
    public abstract virtual UInt32 GetHandleInfo(UInt32 hMDHandle, METADATA_HANDLE_INFO pmdhiInfo);
    public abstract virtual UInt32 GetSystemChangeNumber(UInt32& pdwSystemChangeNumber);
    public abstract virtual UInt32 GetDataSetNumber(UInt32 hMDHandle, string pszMDPath, UInt32& pdwMDDataSetNumber);
    public abstract virtual UInt32 SetLastChangeTime(UInt32 hMDHandle, string pszMDPath, FILETIME& pftMDLastChangeTime, int bLocalTime);
    public abstract virtual UInt32 GetLastChangeTime(UInt32 hMDHandle, string pszMDPath, FILETIME& pftMDLastChangeTime, int bLocalTime);
    public abstract virtual UInt32 KeyExchangePhase1();
    public abstract virtual UInt32 KeyExchangePhase2();
    public abstract virtual UInt32 Backup(string pszMDBackupLocation, UInt32 dwMDVersion, UInt32 dwMDFlags);
    public abstract virtual UInt32 Restore(string pszMDBackupLocation, UInt32 dwMDVersion, UInt32 dwMDFlags);
    public abstract virtual UInt32 EnumBackups(string pszMDBackupLocation, UInt32& pdwMDVersion, FILETIME& pftMDBackupTime, UInt32 dwMDEnumIndex);
    public abstract virtual UInt32 DeleteBackup(string pszMDBackupLocation, UInt32 dwMDVersion);
    public abstract virtual UInt32 UnmarshalInterface(IMSAdminBase& piadmbwInterface);
    public abstract virtual UInt32 GetServerGuid(Guid& pServerGuid);
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Activation.Interop.SafeCloseHandleCritical : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Activation.Interop.SafeHGlobalHandleCritical : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeHGlobalHandleCritical InvalidHandle { get; }
    protected virtual bool ReleaseHandle();
    public static SafeHGlobalHandleCritical get_InvalidHandle();
    public static SafeHGlobalHandleCritical AllocHGlobal(string s);
    public static SafeHGlobalHandleCritical AllocHGlobal(Byte[] bytes);
    public static SafeHGlobalHandleCritical AllocHGlobal(UInt32 cb);
    public static SafeHGlobalHandleCritical AllocHGlobal(int cb);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.ServiceModel.Activation.Interop.SafeNativeMethods : object {
    public static int ERROR_NO_TOKEN;
    [SecurityCriticalAttribute]
internal static bool OpenCurrentThreadTokenCritical(TokenAccessLevels desiredAccess, bool openAsSelf, SafeCloseHandleCritical& tokenHandle, Int32& error);
}
internal interface System.ServiceModel.Activation.IServiceModelActivationHandler {
    public abstract virtual ServiceHostFactoryBase GetFactory();
}
internal enum System.ServiceModel.Activation.MetabasePropertyType : Enum {
    public int value__;
    public static MetabasePropertyType ServerBindings;
    public static MetabasePropertyType SecureBindings;
    public static MetabasePropertyType AuthFlags;
    public static MetabasePropertyType Realm;
    public static MetabasePropertyType AnonymousUserName;
    public static MetabasePropertyType AnonymousPassword;
    public static MetabasePropertyType AccessSslFlags;
    public static MetabasePropertyType AuthPersistence;
    public static MetabasePropertyType AuthProviders;
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Activation.MetabaseReader : object {
    internal static string LMPath;
    private static MetabaseReader();
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
public object GetData(string path, MetabasePropertyType propertyType);
    public sealed virtual void Dispose();
}
internal abstract class System.ServiceModel.Activation.MetabaseSettings : object {
    internal static char AboPathDelimiter;
    internal static string DotDelimiter;
    internal static string LocalMachine;
    protected List`1<string> Protocols { get; protected set; }
    protected IDictionary`2<string, String[]> Bindings { get; protected set; }
    internal abstract virtual string GetRealm(string virtualPath);
    internal abstract virtual HttpAccessSslFlags GetAccessSslFlags(string virtualPath);
    internal abstract virtual AuthenticationSchemes GetAuthenticationSchemes(string virtualPath);
    internal abstract virtual ExtendedProtectionPolicy GetExtendedProtectionPolicy(string virtualPath);
    internal abstract virtual bool IsWithinApp(string absoluteVirtualPath);
    protected List`1<string> get_Protocols();
    protected void set_Protocols(List`1<string> value);
    protected IDictionary`2<string, String[]> get_Bindings();
    protected void set_Bindings(IDictionary`2<string, String[]> value);
    internal bool GetAllowSslOnly(string virtualPath);
    internal String[] GetProtocols();
    internal String[] GetBindings(string scheme);
    protected static ExtendedProtectionPolicy BuildExtendedProtectionPolicy(ExtendedProtectionTokenChecking tokenChecking, ExtendedProtectionFlags flags, List`1<string> spnList);
}
internal class System.ServiceModel.Activation.MetabaseSettingsCassini : MetabaseSettings {
    internal MetabaseSettingsCassini(HostedHttpRequestAsyncResult result);
    internal virtual string GetRealm(string virtualPath);
    internal virtual HttpAccessSslFlags GetAccessSslFlags(string virtualPath);
    internal virtual AuthenticationSchemes GetAuthenticationSchemes(string virtualPath);
    internal virtual ExtendedProtectionPolicy GetExtendedProtectionPolicy(string virtualPath);
    internal virtual bool IsWithinApp(string absoluteVirtualPath);
}
internal abstract class System.ServiceModel.Activation.MetabaseSettingsIis : MetabaseSettings {
    internal static string NegotiateAuthProvider;
    internal static string NtlmAuthProvider;
    internal static String[] DefaultAuthProviders;
    private static MetabaseSettingsIis();
    protected abstract virtual HostedServiceTransportSettings CreateTransportSettings(string relativeVirtualPath);
    internal virtual string GetRealm(string virtualPath);
    internal virtual HttpAccessSslFlags GetAccessSslFlags(string virtualPath);
    internal virtual AuthenticationSchemes GetAuthenticationSchemes(string virtualPath);
    internal virtual ExtendedProtectionPolicy GetExtendedProtectionPolicy(string virtualPath);
    protected abstract virtual IEnumerable`1<string> GetSiteApplicationPaths();
    internal virtual bool IsWithinApp(string absoluteVirtualPath);
}
internal class System.ServiceModel.Activation.MetabaseSettingsIis6 : MetabaseSettingsIis {
    [SecuritySafeCriticalAttribute]
protected virtual HostedServiceTransportSettings CreateTransportSettings(string relativeVirtualPath);
    protected virtual IEnumerable`1<string> GetSiteApplicationPaths();
}
internal class System.ServiceModel.Activation.METADATA_HANDLE_INFO : ValueType {
    public UInt32 dwMDPermissions;
    public UInt32 dwMDSystemChangeNumber;
}
internal class System.ServiceModel.Activation.METADATA_RECORD : ValueType {
    public UInt32 dwMDIdentifier;
    public UInt32 dwMDAttributes;
    public UInt32 dwMDUserType;
    public UInt32 dwMDDataType;
    public UInt32 dwMDDataLen;
    [SecurityCriticalAttribute]
public IntPtr pbMDData;
    public UInt32 dwMDDataTag;
}
[GuidAttribute("A9E69610-B80D-11D0-B9B9-00A0C922E750")]
[SecurityCriticalAttribute]
internal class System.ServiceModel.Activation.MSAdminBase : object {
    internal static UInt32 DEFAULT_METABASE_TIMEOUT;
    internal static int METADATA_MASTER_ROOT_HANDLE;
    internal static int METADATA_PERMISSION_READ;
    internal static int METADATA_INHERIT;
    internal static int IIS_MD_UT_SERVER;
    internal static int ALL_METADATA;
    internal static int DWORD_METADATA;
    internal static int STRING_METADATA;
    internal static int BINARY_METADATA;
    internal static int EXPANDSZ_METADATA;
    internal static int MULTISZ_METADATA;
}
internal class System.ServiceModel.Activation.MsmqHostedTransportConfiguration : HostedTransportConfigurationBase {
    internal MsmqHostedTransportManager TransportManager { get; }
    protected MsmqHostedTransportConfiguration(IAddressTranslator addressing);
    public virtual Uri[] GetBaseAddresses(string virtualPath);
    internal MsmqHostedTransportManager get_TransportManager();
}
internal class System.ServiceModel.Activation.MsmqIntegrationHostedTransportConfiguration : MsmqHostedTransportConfiguration {
}
internal class System.ServiceModel.Activation.NamedPipeHostedTransportConfiguration : HostedTransportConfigurationBase {
    internal NamedPipeTransportManager TransportManager { get; }
    internal NamedPipeTransportManager get_TransportManager();
}
[AttributeUsageAttribute("4")]
public class System.ServiceModel.Activation.ServiceActivationBuildProviderAttribute : Attribute {
}
[SecurityCriticalAttribute("1")]
[BuildProviderAppliesToAttribute("1")]
[ServiceActivationBuildProviderAttribute]
public class System.ServiceModel.Activation.ServiceBuildProvider : BuildProvider {
    public CompilerType CodeCompilerType { get; }
    public ICollection VirtualPathDependencies { get; }
    public virtual CompilerType get_CodeCompilerType();
    protected virtual CodeCompileUnit GetCodeCompileUnit(IDictionary& linePragmasTable);
    public virtual BuildProviderResultFlags GetResultFlags(CompilerResults results);
    public virtual void GenerateCode(AssemblyBuilder assemblyBuilder);
    public virtual string GetCustomString(CompilerResults results);
    public virtual ICollection get_VirtualPathDependencies();
    internal CompilerType GetDefaultCompilerTypeForLanguageInternal(string language);
    internal CompilerType GetDefaultCompilerTypeInternal();
    internal TextReader OpenReaderInternal();
}
internal class System.ServiceModel.Activation.ServiceDeploymentInfo : object {
    public bool MessageHandledByRoute { get; public set; }
    public string VirtualPath { get; private set; }
    public string ServiceType { get; private set; }
    public ServiceHostFactoryBase ServiceHostFactory { get; private set; }
    public ServiceDeploymentInfo(string virtualPath, ServiceHostFactoryBase serviceHostFactory, string serviceType);
    [CompilerGeneratedAttribute]
public bool get_MessageHandledByRoute();
    [CompilerGeneratedAttribute]
public void set_MessageHandledByRoute(bool value);
    [CompilerGeneratedAttribute]
public string get_VirtualPath();
    [CompilerGeneratedAttribute]
private void set_VirtualPath(string value);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
private void set_ServiceType(string value);
    [CompilerGeneratedAttribute]
public ServiceHostFactoryBase get_ServiceHostFactory();
    [CompilerGeneratedAttribute]
private void set_ServiceHostFactory(ServiceHostFactoryBase value);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Activation.ServiceHostFactory : ServiceHostFactoryBase {
    internal void AddAssemblyReference(string assemblyName);
    public virtual ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses);
    protected virtual ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses);
}
internal class System.ServiceModel.Activation.ServiceHttpHandlerFactory : object {
    public sealed virtual IHttpHandler GetHandler(HttpContext context, string requestType, string url, string pathTranslated);
    public sealed virtual void ReleaseHandler(IHttpHandler handler);
}
internal class System.ServiceModel.Activation.ServiceHttpModule : object {
    private static ServiceHttpModule();
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public sealed virtual void Init(HttpApplication context);
    [SecurityCriticalAttribute]
public static IAsyncResult BeginProcessRequest(object sender, EventArgs e, AsyncCallback cb, object extraData);
    public static void EndProcessRequest(IAsyncResult ar);
}
internal static class System.ServiceModel.Activation.ServiceMemoryGates : object {
    [SecurityCriticalAttribute]
internal static bool Check(int minFreeMemoryPercentage, bool throwOnLowMemory, UInt64& availableMemoryBytes);
}
[SecurityCriticalAttribute("1")]
internal class System.ServiceModel.Activation.ServiceParser : object {
    internal CompilerType CompilerType { get; }
    internal ICollection AssemblyDependencies { get; }
    internal ICollection SourceDependencies { get; }
    internal bool HasInlineCode { get; }
    private static ServiceParser();
    internal ServiceParser(string virtualPath, ServiceBuildProvider buildProvider);
    internal static IDictionary`2<string, string> ParseServiceDirective(string serviceText);
    internal CompilerType get_CompilerType();
    internal ICollection get_AssemblyDependencies();
    internal ICollection get_SourceDependencies();
    internal bool get_HasInlineCode();
    internal void Parse(ICollection referencedAssemblies);
    internal CodeCompileUnit GetCodeModel();
    internal string CreateParseString(Assembly compiledAssembly);
    internal IDictionary GetLinePragmasTable();
}
public class System.ServiceModel.Activation.ServiceRoute : Route {
    internal static string LeftCurlyBracket;
    internal static string RightCurlyBracket;
    internal static string UnmatchedPathSegment;
    internal static char PathSeperator;
    public ServiceRoute(string routePrefix, ServiceHostFactoryBase serviceHostFactory, Type serviceType);
}
internal class System.ServiceModel.Activation.ServiceRouteHandler : object {
    public ServiceRouteHandler(string baseAddress, ServiceHostFactoryBase serviceHostFactory, Type webServiceType);
    private static ServiceRouteHandler();
    public sealed virtual IHttpHandler GetHttpHandler(RequestContext requestContext);
    public static ServiceDeploymentInfo GetServiceInfo(string normalizedVirtualPath);
    public static bool IsActiveAspNetRoute(string virtualPath);
    public static void MarkRouteAsActive(string normalizedVirtualPath);
    public static void MarkARouteAsInactive(string normalizedVirtualPath);
}
internal class System.ServiceModel.Activation.SR : object {
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string ValueMustBeNonNegative { get; }
    internal static string RequestContextAborted { get; }
    internal static string PipeListenerProxyStopped { get; }
    internal static string Hosting_AuthSchemesRequireWindowsAuth { get; }
    internal static string Hosting_BuildProviderDirectiveNameMissing { get; }
    internal static string Hosting_BuildProviderMainAttributeMissing { get; }
    internal static string Hosting_UnrecognizedTokenCheckingValue { get; }
    internal static string Hosting_GetGlobalMemoryFailed { get; }
    internal static string Hosting_ImpersonationFailed { get; }
    internal static string Hosting_MemoryGatesCheckFailedUnderPartialTrust { get; }
    internal static string Hosting_MetabaseAccessError { get; }
    internal static string Hosting_ServiceCompatibilityNotAllowed { get; }
    internal static string Hosting_ServiceCompatibilityRequire { get; }
    internal static string Hosting_ServiceTypeNotProvided { get; }
    internal static string BaseAddressesNotProvided { get; }
    internal static string ExtendedProtectionNotSupported { get; }
    internal static string ExtendedProtectionPolicyCustomChannelBindingMismatch { get; }
    internal static string Hosting_ExtendedProtectionSPNListNotSubset { get; }
    internal static string Hosting_RouteServiceRequiresCompatibilityMode { get; }
    internal static string WorkflowServiceHostFactoryConstructorStringNotProvided { get; }
    internal static string TraceCodeWebHostDebugRequest { get; }
    internal static string TraceCodeWebHostProtocolMisconfigured { get; }
    internal static string TraceCodeWebHostCompilation { get; }
    internal static string TraceCodeWebHostServiceActivated { get; }
    internal static string TraceCodeWebHostServiceCloseFailed { get; }
    internal static string TraceCodeRequestContextAbort { get; }
    internal static string TraceCodeWebHostNoCBTSupport { get; }
    internal static string TraceCodeHttpChannelMessageReceiveFailed { get; }
    internal static string DefaultBusyCountSource { get; }
    internal static string ServiceTypeUnknown { get; }
    internal static string Hosting_MaxRequestLengthExceeded { get; }
    internal static string CannotRunInPartialTrustOutsideAspNet { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ValueMustBeNonNegative();
    internal static string get_RequestContextAborted();
    internal static string get_PipeListenerProxyStopped();
    internal static string get_Hosting_AuthSchemesRequireWindowsAuth();
    internal static string get_Hosting_BuildProviderDirectiveNameMissing();
    internal static string get_Hosting_BuildProviderMainAttributeMissing();
    internal static string get_Hosting_UnrecognizedTokenCheckingValue();
    internal static string get_Hosting_GetGlobalMemoryFailed();
    internal static string get_Hosting_ImpersonationFailed();
    internal static string get_Hosting_MemoryGatesCheckFailedUnderPartialTrust();
    internal static string get_Hosting_MetabaseAccessError();
    internal static string get_Hosting_ServiceCompatibilityNotAllowed();
    internal static string get_Hosting_ServiceCompatibilityRequire();
    internal static string get_Hosting_ServiceTypeNotProvided();
    internal static string get_BaseAddressesNotProvided();
    internal static string get_ExtendedProtectionNotSupported();
    internal static string get_ExtendedProtectionPolicyCustomChannelBindingMismatch();
    internal static string get_Hosting_ExtendedProtectionSPNListNotSubset();
    internal static string get_Hosting_RouteServiceRequiresCompatibilityMode();
    internal static string get_WorkflowServiceHostFactoryConstructorStringNotProvided();
    internal static string get_TraceCodeWebHostDebugRequest();
    internal static string get_TraceCodeWebHostProtocolMisconfigured();
    internal static string get_TraceCodeWebHostCompilation();
    internal static string get_TraceCodeWebHostServiceActivated();
    internal static string get_TraceCodeWebHostServiceCloseFailed();
    internal static string get_TraceCodeRequestContextAbort();
    internal static string get_TraceCodeWebHostNoCBTSupport();
    internal static string get_TraceCodeHttpChannelMessageReceiveFailed();
    internal static string get_DefaultBusyCountSource();
    internal static string get_ServiceTypeUnknown();
    internal static string get_Hosting_MaxRequestLengthExceeded();
    internal static string get_CannotRunInPartialTrustOutsideAspNet();
    internal static string Hosting_AddressIsAbsoluteUri(object param0);
    internal static string Hosting_AddressPointsOutsideTheVirtualDirectory(object param0, object param1);
    internal static string Hosting_AuthSchemesRequireOtherAuth(object param0);
    internal static string Hosting_BadMetabaseSettingsIis7Type(object param0);
    internal static string Hosting_BuildProviderAmbiguousType(object param0, object param1, object param2);
    internal static string Hosting_BuildProviderAttributeEmpty(object param0);
    internal static string Hosting_BuildProviderAttributeMissing(object param0);
    internal static string Hosting_BuildProviderCouldNotCreateType(object param0);
    internal static string Hosting_BuildProviderDirectiveEndBracketMissing(object param0);
    internal static string Hosting_BuildProviderDirectiveMissing(object param0);
    internal static string Hosting_BuildProviderDuplicateAttribute(object param0);
    internal static string Hosting_BuildProviderDuplicateDirective(object param0);
    internal static string Hosting_BuildProviderInvalidValueForBooleanAttribute(object param0, object param1);
    internal static string Hosting_BuildProviderInvalidValueForNonNegativeIntegerAttribute(object param0, object param1);
    internal static string Hosting_BuildProviderMutualExclusiveAttributes(object param0, object param1);
    internal static string Hosting_BuildProviderRequiredAttributesMissing(object param0, object param1);
    internal static string Hosting_BuildProviderUnknownAttribute(object param0);
    internal static string Hosting_BuildProviderUnknownDirective(object param0);
    internal static string Hosting_CompilationResultInvalid(object param0);
    internal static string Hosting_EnvironmentShuttingDown(object param0, object param1);
    internal static string Hosting_ExtendedProtectionDotlessSpnNotEnabled(object param0);
    internal static string Hosting_ExtendedProtectionFlagsNotSupport(object param0);
    internal static string Hosting_ExtendedProtectionSpnFormatError(object param0);
    internal static string Hosting_InvalidHandlerForWorkflowService(object param0, object param1, object param2);
    internal static string Hosting_IServiceHostNotImplemented(object param0);
    internal static string Hosting_ServiceCannotBeActivated(object param0, object param1);
    internal static string Hosting_ListenerNotFoundForActivation(object param0);
    internal static string Hosting_ListenerNotFoundForActivationInRecycling(object param0);
    internal static string Hosting_MemoryGatesCheckFailed(object param0, object param1);
    internal static string Hosting_MetabaseDataStringsTerminate(object param0);
    internal static string Hosting_MetabaseDataTypeUnsupported(object param0, object param1);
    internal static string Hosting_MetabaseSettingsIis7TypeNotFound(object param0, object param1);
    internal static string Hosting_NoDefaultCtor(object param0);
    internal static string Hosting_NonHTTPInCompatibilityMode(object param0);
    internal static string Hosting_NoServiceAndFactorySpecifiedForFilelessService(object param0, object param1, object param2, object param3);
    internal static string Hosting_NoValidExtensionFoundForRegistedFilelessService(object param0, object param1);
    internal static string Hosting_NotSupportedAuthScheme(object param0);
    internal static string Hosting_ProtocolNoConfiguration(object param0);
    internal static string Hosting_FactoryTypeNotResolved(object param0);
    internal static string Hosting_RelativeAddressExtensionNotSupportError(object param0, object param1, object param2);
    internal static string Hosting_RelativeAddressFormatError(object param0);
    internal static string Hosting_RelativeAddressHasBeenAdded(object param0, object param1);
    internal static string Hosting_ServiceHostBaseIsNull(object param0);
    internal static string Hosting_ServiceNotExist(object param0);
    internal static string Hosting_SslSettingsMisconfigured(object param0, object param1);
    internal static string Hosting_TransportBindingNotFound(object param0);
    internal static string Hosting_NotSupportedProtocol(object param0);
    internal static string Hosting_ServiceTypeNotResolved(object param0);
    internal static string Hosting_ProcessNotExecutingUnderHostedContext(object param0);
    internal static string Hosting_NotLoggingInsufficientMemoryExceptionsOnActivationForNextTimeInterval(object param0);
    internal static string PartialTrustNonHttpActivation(object param0, object param1);
    internal static string ExtendedProtectionPolicyEnforcementMismatch(object param0, object param1);
    internal static string ExtendedProtectionPolicyScenarioMismatch(object param0, object param1);
    internal static string Hosting_ExtendedProtectionPoliciesMustMatch(object param0);
    internal static string Hosting_RouteHasAlreadyBeenAdded(object param0);
    internal static string Hosting_CurlyBracketFoundInRoutePrefix(object param0, object param1);
    internal static string CannotResolveConstructorStringToWorkflowType(object param0);
    internal static string TypeNotActivity(object param0);
    internal static string InvalidCompiledString(object param0);
    internal static string Hosting_SharedEndpointRequiresRelativeEndpoint(object param0);
    internal static string XamlBuildProviderExtensionException(object param0);
    internal static string ExceptionLoadingSupportedVersion(object param0, object param1);
}
internal class System.ServiceModel.Activation.TcpHostedTransportConfiguration : HostedTransportConfigurationBase {
    internal TcpTransportManager TransportManager { get; }
    internal TcpTransportManager get_TransportManager();
}
internal class System.ServiceModel.Activation.TD : object {
    internal static CultureInfo Culture { get; internal set; }
    private static TD();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool CompilationStartIsEnabled();
    internal static void CompilationStart(EventTraceActivity eventTraceActivity);
    internal static bool CompilationStopIsEnabled();
    internal static void CompilationStop(EventTraceActivity eventTraceActivity);
    internal static bool ServiceHostFactoryCreationStartIsEnabled();
    internal static void ServiceHostFactoryCreationStart(EventTraceActivity eventTraceActivity);
    internal static bool ServiceHostFactoryCreationStopIsEnabled();
    internal static void ServiceHostFactoryCreationStop(EventTraceActivity eventTraceActivity);
    internal static bool CreateServiceHostStartIsEnabled();
    internal static void CreateServiceHostStart(EventTraceActivity eventTraceActivity);
    internal static bool CreateServiceHostStopIsEnabled();
    internal static void CreateServiceHostStop(EventTraceActivity eventTraceActivity);
    internal static bool HostedTransportConfigurationManagerConfigInitStartIsEnabled();
    internal static void HostedTransportConfigurationManagerConfigInitStart();
    internal static bool HostedTransportConfigurationManagerConfigInitStopIsEnabled();
    internal static void HostedTransportConfigurationManagerConfigInitStop();
    internal static bool WebHostRequestStartIsEnabled();
    internal static void WebHostRequestStart(EventTraceActivity eventTraceActivity, string AppDomainFriendlyName, string VirtualPath, Guid relatedActivityId);
    internal static bool WebHostRequestStopIsEnabled();
    internal static void WebHostRequestStop(EventTraceActivity eventTraceActivity);
    internal static bool AspNetRoutingServiceIsEnabled();
    internal static void AspNetRoutingService(EventTraceActivity eventTraceActivity, string IncomingAddress);
    internal static bool AspNetRouteIsEnabled();
    internal static void AspNetRoute(string AspNetRoutePrefix, string ServiceType, string ServiceHostFactoryType);
    internal static bool ServiceHostStartedIsEnabled();
    internal static void ServiceHostStarted(EventTraceActivity eventTraceActivity, string ServiceTypeName, string reference);
    internal static bool IdleServicesClosedIsEnabled();
    internal static void IdleServicesClosed(EventTraceActivity eventTraceActivity, int ClosedCount, int TotalCount);
    internal static bool CBAEntryReadIsEnabled();
    internal static void CBAEntryRead(string RelativeAddress, string NormalizedAddress);
    internal static bool CBAMatchFoundIsEnabled();
    internal static void CBAMatchFound(EventTraceActivity eventTraceActivity, string IncomingAddress);
    internal static bool XamlServicesLoadStartIsEnabled();
    internal static void XamlServicesLoadStart();
    internal static bool XamlServicesLoadStopIsEnabled();
    internal static void XamlServicesLoadStop();
    internal static bool IncrementBusyCountIsEnabled();
    internal static void IncrementBusyCount(string Data);
    internal static bool DecrementBusyCountIsEnabled();
    internal static void DecrementBusyCount(string Data);
    internal static bool ServiceActivationStartIsEnabled();
    internal static void ServiceActivationStart(EventTraceActivity eventTraceActivity);
    internal static bool ServiceActivationStopIsEnabled();
    internal static void ServiceActivationStop(EventTraceActivity eventTraceActivity);
    internal static bool ServiceActivationAvailableMemoryIsEnabled();
    internal static void ServiceActivationAvailableMemory(ulong availableMemoryBytes);
    internal static bool ServiceActivationExceptionIsEnabled();
    internal static void ServiceActivationException(string param0, Exception exception);
}
internal class System.ServiceModel.Activities.Activation.ServiceModelActivitiesActivationHandler : HttpHandler {
    public sealed virtual ServiceHostFactoryBase GetFactory();
}
internal class System.ServiceModel.Activities.Activation.ServiceModelActivitiesActivationHandlerAsync : ServiceHttpHandlerFactory {
    public sealed virtual ServiceHostFactoryBase GetFactory();
    public sealed virtual IXamlBuildProviderExtension GetXamlBuildProviderExtension();
}
public class System.ServiceModel.Activities.Activation.WorkflowServiceHostFactory : ServiceHostFactoryBase {
    public virtual ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses);
    internal static object LoadXaml(Stream activityStream);
    internal static bool TryWrapSupportedVersionException(string filePath, Exception e, Exception& newException);
    internal static string GetSupportedVersionGeneratedTypeName(string filePath);
    [SecuritySafeCriticalAttribute]
internal static void GetSupportedVersionStreams(string xamlFileName, IList`1& streams);
    internal static WorkflowService CreatetWorkflowService(Stream activityStream, XName defaultServiceName);
    protected virtual WorkflowServiceHost CreateWorkflowServiceHost(Activity activity, Uri[] baseAddresses);
    protected virtual WorkflowServiceHost CreateWorkflowServiceHost(WorkflowService service, Uri[] baseAddresses);
}
internal class System.ServiceModel.Activities.Activation.XamlBuildProviderExtension : object {
    public sealed virtual void GenerateCode(AssemblyBuilder assemblyBuilder, Stream xamlStream, BuildProvider buildProvider);
    public sealed virtual Type GetGeneratedType(CompilerResults results);
    internal static ICompiledExpressionRoot GetExpressionRoot(string supportedVersionXamlxfilePath, WorkflowService service, string virtualPath);
}
internal static class System.ServiceModel.AspNetPartialTrustHelpers : object {
    internal static bool NeedPartialTrustInvoke { get; }
    private static AspNetPartialTrustHelpers();
    [SecuritySafeCriticalAttribute]
internal static bool get_NeedPartialTrustInvoke();
    [SecuritySafeCriticalAttribute]
internal static void PartialTrustInvoke(ContextCallback callback, object state);
    [SecuritySafeCriticalAttribute]
internal static void FailIfInPartialTrustOutsideAspNet();
}
internal class System.ServiceModel.Channels.MsmqHostedTransportManager : TransportManager {
    internal string Scheme { get; }
    public MsmqHostedTransportManager(String[] hosts, IAddressTranslator addressing);
    public Uri[] GetBaseAddresses(string virtualPath);
    internal virtual string get_Scheme();
    internal virtual void OnClose(TimeSpan timeout);
    internal virtual void OnOpen();
    internal virtual void Register(TransportChannelListener channelListener);
    internal void Start(Action messageReceivedCallback);
    internal virtual void Unregister(TransportChannelListener channelListener);
}
internal class System.ServiceModel.Diagnostics.HttpRequestTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal HttpRequestTraceRecord(HttpRequest request);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal static class System.ServiceModel.HostingEnvironmentWrapper : object {
    public static string ApplicationVirtualPath { get; }
    public static bool IsHosted { get; }
    public static VirtualPathProvider VirtualPathProvider { get; }
    public static string UnsafeApplicationID { get; }
    public static string get_ApplicationVirtualPath();
    public static bool get_IsHosted();
    [SecuritySafeCriticalAttribute]
public static VirtualPathProvider get_VirtualPathProvider();
    [SecuritySafeCriticalAttribute]
public static void DecrementBusyCount();
    public static IDisposable Impersonate();
    public static IDisposable Impersonate(IntPtr token);
    [SecuritySafeCriticalAttribute]
public static void IncrementBusyCount();
    public static string MapPath(string virtualPath);
    [SecurityCriticalAttribute]
public static string get_UnsafeApplicationID();
    [SecurityCriticalAttribute]
public static IDisposable UnsafeImpersonate();
    [SecurityCriticalAttribute]
public static IDisposable UnsafeImpersonate(IntPtr token);
    [SecurityCriticalAttribute]
public static void UnsafeRegisterObject(IRegisteredObject target);
    [SecurityCriticalAttribute]
public static void UnsafeUnregisterObject(IRegisteredObject target);
    [SecuritySafeCriticalAttribute]
public static bool ServiceFileExists(string normalizedVirtualPath);
    [SecuritySafeCriticalAttribute]
public static VirtualFile GetServiceFile(string normalizedVirtualPath);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public static class System.ServiceModel.ServiceHostingEnvironment : object {
    internal static string VerbPost;
    internal static string ISAPIApplicationIdPrefix;
    internal static string RelativeVirtualPathPrefix;
    internal static string ServiceParserDelimiter;
    internal static string RootVirtualPath;
    internal static string PathSeparatorString;
    public static bool AspNetCompatibilityEnabled { get; }
    public static bool MultipleSiteBindingsEnabled { get; }
    internal static Uri[] PrefixFilters { get; }
    internal static string CurrentVirtualPath { get; }
    internal static string ServiceActivationElementPath { get; }
    internal static string SiteName { get; }
    internal static string ApplicationVirtualPath { get; }
    internal static string FullVirtualPath { get; }
    internal static string XamlFileBaseLocation { get; }
    internal static bool IsConfigurationBased { get; }
    internal static bool IsRecycling { get; }
    internal static bool IsHosted { get; }
    internal static bool IsSimpleApplicationHost { get; }
    private static ServiceHostingEnvironment();
    public static bool get_AspNetCompatibilityEnabled();
    public static bool get_MultipleSiteBindingsEnabled();
    internal static Uri[] get_PrefixFilters();
    public static void EnsureServiceAvailable(string virtualPath);
    internal static void EnsureServiceAvailableFast(string relativeVirtualPath, EventTraceActivity eventTraceActivity);
    internal static void IncrementRequestCount(EventTraceActivity& eventTraceActivity, string requestUrl);
    internal static void DecrementRequestCount(EventTraceActivity eventTraceActivity);
    internal static string get_CurrentVirtualPath();
    internal static string get_ServiceActivationElementPath();
    internal static string get_SiteName();
    internal static string get_ApplicationVirtualPath();
    internal static string get_FullVirtualPath();
    internal static string get_XamlFileBaseLocation();
    internal static bool get_IsConfigurationBased();
    internal static ServiceType GetServiceType(string extension);
    internal static bool EnsureWorkflowService(string path);
    internal static bool get_IsRecycling();
    internal static bool IsConfigurationBasedService(HttpApplication application);
    internal static bool IsConfigurationBasedService(string virtualPath);
    internal static bool IsConfigurationBasedService(HttpApplication application, String& matchedVirtualPath);
    internal static void SafeEnsureInitialized();
    internal static void EnsureAllReferencedAssemblyLoaded();
    [EditorBrowsableAttribute("1")]
public static void EnsureInitialized();
    internal static string NormalizeVirtualPath(string virtualPath);
    internal static bool get_IsHosted();
    internal static bool get_IsSimpleApplicationHost();
}
