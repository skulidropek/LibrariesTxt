internal static class FXAssembly : object {
    internal static string Version;
}
internal class GUID : ValueType {
    public int Data1;
    public ushort Data2;
    public ushort Data3;
    public Byte[] Data4;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
internal interface IEnumString {
    public abstract virtual void RemoteNext(int celt, String& rgelt, Int32& pceltFetched);
    public abstract virtual void Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[GuidAttribute("79EAC9EE-BAF9-11CE-8C82-00AA004BA90B")]
[InterfaceTypeAttribute("1")]
[ComConversionLossAttribute]
internal interface IInternetSecurityManager {
    public abstract virtual void SetSecuritySite(IInternetSecurityMgrSite pSite);
    public abstract virtual void GetSecuritySite(IInternetSecurityMgrSite& ppSite);
    public abstract virtual void MapUrlToZone(string pwszUrl, Int32& pdwZone, int dwFlags);
    public abstract virtual void GetSecurityId(string pwszUrl, Byte& pbSecurityId, Int32& pcbSecurityId, int dwReserved);
    public abstract virtual void ProcessUrlAction(string pwszUrl, int dwAction, Byte& pPolicy, int cbPolicy, Byte& pContext, int cbContext, int dwFlags, int dwReserved);
    public abstract virtual void QueryCustomPolicy(string pwszUrl, GUID& guidKey, IntPtr ppPolicy, Int32& pcbPolicy, Byte& pContext, int cbContext, int dwReserved);
    public abstract virtual void SetZoneMapping(int dwZone, string lpszPattern, int dwFlags);
    public abstract virtual void GetZoneMappings(int dwZone, IEnumString& ppenumString, int dwFlags);
}
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("79EAC9ED-BAF9-11CE-8C82-00AA004BA90B")]
internal interface IInternetSecurityMgrSite {
    public abstract virtual void GetWindow(IntPtr phwnd);
    public abstract virtual void EnableModeless(int fEnable);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`2 : object {
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static CopyOnWriteDictionary`2<K, V> Dummy { get; }
    internal bool IsDummy { get; }
    internal IEqualityComparer`1<K> Comparer { get; }
    public V Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`2(int capacity);
    internal CopyOnWriteDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal CopyOnWriteDictionary`2(int capacity, IEqualityComparer`1<K> keyComparer);
    protected CopyOnWriteDictionary`2(SerializationInfo info, StreamingContext context);
    private static CopyOnWriteDictionary`2();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal static CopyOnWriteDictionary`2<K, V> get_Dummy();
    internal bool get_IsDummy();
    internal IEqualityComparer`1<K> get_Comparer();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`2<K, V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`2<K, V> other);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.HybridDictionary`2 : object {
    internal static int MaxListSize;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public TValue Item { get; public set; }
    public object Item { get; public set; }
    private static HybridDictionary`2();
    public HybridDictionary`2(int capacity);
    public HybridDictionary`2(IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public HybridDictionary`2(SerializationInfo info, StreamingContext context);
    public HybridDictionary`2(HybridDictionary`2<TKey, TValue> other, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = 0")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyList`1 : object {
    public static ReadOnlyEmptyList`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    public static ReadOnlyEmptyList`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyList`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal static class Microsoft.Build.OpportunisticIntern : object {
    private static OpportunisticIntern();
    internal static int AssignViaEnvironment(string env, int default);
    internal static void EnableStatisticsGathering();
    internal static string InternableToString(IInternable candidate);
    internal static string StringBuilderToString(StringBuilder candidate);
    internal static string CharArrayToString(Char[] candidate, int count);
    internal static string CharArrayToString(Char[] candidate, int startIndex, int count);
    internal static string InternStringIfPossible(string candidate);
    internal static void ReportStatistics();
}
internal class Microsoft.Build.Shared.AssemblyFoldersEx : object {
    internal AssemblyFoldersEx(string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, ProcessorArchitecture targetProcessorArchitecture, OpenBaseKey openBaseKey);
    internal static List`1<ExtensionFoldersRegistryKey> GatherVersionStrings(string targetRuntimeVersion, IEnumerable versions);
    private sealed virtual override IEnumerator`1<AssemblyFoldersExInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersExInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool CompareCulture(AssemblyNameExtension that);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal bool get_IsUnnamedAssembly();
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    internal static ResourceManager get_PrimaryResources();
    internal static ResourceManager get_SharedResources();
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static CanonicalError();
    internal static Parts Parse(string message);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static bool CanConvertStringToBool(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    internal static Encoding CurrentSystemOemEncoding { get; }
    internal static Encoding get_CurrentSystemOemEncoding();
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static EscapingUtilities();
    internal static string UnescapeAll(string escapedString);
    internal static string UnescapeAll(string escapedString, Boolean& escapingWasNecessary);
    internal static string Escape(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    internal string RegistryKey { get; private set; }
    internal Version ComponentVersion { get; private set; }
    internal Version TargetFrameworkVersion { get; private set; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    internal ExtensionFoldersRegistryKey(string registryKey, Version componentVersion, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
private void set_RegistryKey(string value);
    [CompilerGeneratedAttribute]
internal Version get_ComponentVersion();
    [CompilerGeneratedAttribute]
private void set_ComponentVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworkVersion(Version value);
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.FileMatcher : object {
    internal static Char[] directorySeparatorCharacters;
    private static FileMatcher();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal static void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, GetFileSystemEntries getFileSystemEntries);
    internal static bool IsDirectorySeparator(char c);
    internal static void RemoveProjectDirectory(String[] paths, string projectDirectory);
    internal static void GetFileSpecInfo(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec, GetFileSystemEntries getFileSystemEntries);
    internal static Result FileMatch(string filespec, string fileToMatch);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped);
    internal static String[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, GetFileSystemEntries getFileSystemEntries, DirectoryExists directoryExists);
}
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static int MaxPath;
    internal static string cacheDirectory;
    internal static string FileTimeFormat;
    internal static string ExecutingAssemblyPath { get; }
    internal static string CurrentExecutableName { get; }
    internal static string CurrentExecutablePath { get; }
    internal static string CurrentExecutableDirectory { get; }
    internal static string CurrentExecutableConfigurationFilePath { get; }
    private static FileUtilities();
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string extension);
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingSlash(string path);
    internal static string EnsureNoTrailingSlash(string path);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string NormalizePath(string path);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string get_CurrentExecutableName();
    internal static string get_CurrentExecutablePath();
    internal static string get_CurrentExecutableDirectory();
    internal static string get_CurrentExecutableConfigurationFilePath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive);
    internal static bool IsRootedNoThrow(string path);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath);
    internal static bool FileExistsNoThrow(string fullPath);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    internal static Regex DrivePattern;
    internal static Regex UNCPattern;
    private static FileUtilitiesRegex();
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue : MulticastDelegate {
    public GetRegistrySubKeyDefaultValue(object object, IntPtr method);
    public virtual string Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyNames : MulticastDelegate {
    public GetRegistrySubKeyNames(object object, IntPtr method);
    public virtual IEnumerable`1<string> Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.InternalErrorException : Exception {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.Build.Shared.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
}
internal class Microsoft.Build.Shared.LanguageParser.BooleanLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CloseConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.CommentToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenCharReader : TokenCharReader {
    internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkLongIntegerSuffix();
    internal bool SinkOperatorOrPunctuator();
    internal bool SinkStringEscape();
    internal bool MatchRegularStringLiteral();
    internal bool SinkMultipleWhiteSpace();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenEnumerator : TokenEnumerator {
    internal TokenCharReader Reader { get; }
    internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static CSharpTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenizer : object {
    internal CSharpTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.DecimalIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.EndOfFileInsideStringToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedIdentifierToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedValidHexDigitToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.HexIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.IdentifierToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.IntegerLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.KeywordToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.LiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OpenConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorOrPunctuatorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorToken : OperatorOrPunctuatorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.PreprocessorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.StreamMappedString : object {
    public int PagesAllocated { get; }
    public static int DefaultPageSize { get; }
    public StreamMappedString(Stream binaryStream, bool forceANSI);
    internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize);
    public int get_PagesAllocated();
    public static int get_DefaultPageSize();
    public char GetAt(int offset);
    public bool IsPastEnd(int offset);
    public string Substring(int startPosition, int length);
}
internal class Microsoft.Build.Shared.LanguageParser.StringLiteralToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.SyntaxErrorToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.Token : object {
    internal string InnerText { get; internal set; }
    internal int Line { get; internal set; }
    internal string get_InnerText();
    internal void set_InnerText(string value);
    internal int get_Line();
    internal void set_Line(int value);
    internal bool EqualsIgnoreCase(string compareTo);
}
internal static class Microsoft.Build.Shared.LanguageParser.TokenChar : object {
    internal static bool IsNewLine(char c);
    internal static bool IsLetter(char c);
    internal static bool IsDecimalDigit(char c);
    internal static bool IsConnecting(char c);
    internal static bool IsCombining(char c);
    internal static bool IsFormatting(char c);
    internal static bool IsHexDigit(char c);
    internal static bool IsOctalDigit(char c);
}
internal class Microsoft.Build.Shared.LanguageParser.TokenCharReader : object {
    internal int CurrentLine { get; }
    internal int Position { get; internal set; }
    internal char CurrentCharacter { get; }
    internal bool EndOfLines { get; }
    internal TokenCharReader(Stream binaryStream, bool forceANSI);
    internal void Reset();
    internal int get_CurrentLine();
    internal int get_Position();
    internal void set_Position(int value);
    protected void Skip();
    protected void Skip(int n);
    internal char get_CurrentCharacter();
    internal bool get_EndOfLines();
    internal string GetCurrentMatchedString(int startPosition);
    internal bool Sink(string match);
    internal char SinkCharacter();
    internal bool SinkIgnoreCase(string match);
    internal bool MatchNextIdentifierStart();
    internal bool SinkIdentifierStart();
    internal bool SinkIdentifierPart();
    internal bool SinkNewLine();
    internal bool SinkToEndOfLine();
    internal bool SinkUntil(string find);
    internal bool SinkMultipleHexDigits();
    internal bool SinkMultipleDecimalDigits();
}
internal abstract class Microsoft.Build.Shared.LanguageParser.TokenEnumerator : object {
    protected Token current;
    internal TokenCharReader Reader { get; }
    public object Current { get; }
    internal abstract virtual TokenCharReader get_Reader();
    internal abstract virtual bool FindNextToken();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
internal class Microsoft.Build.Shared.LanguageParser.UnrecognizedToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenCharReader : TokenCharReader {
    internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkSeparatorCharacter();
    internal bool SinkLineContinuationCharacter();
    internal bool SinkLineCommentStart();
    internal bool SinkHexIntegerPrefix();
    internal bool SinkOctalIntegerPrefix();
    internal bool SinkWhiteSpace();
    internal bool SinkIntegerSuffix();
    internal bool SinkDecimalIntegerSuffix();
    internal bool SinkMultipleOctalDigits();
    internal bool SinkOperator();
    internal bool SinkTypeCharacter();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenEnumerator : TokenEnumerator {
    internal TokenCharReader Reader { get; }
    internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static VisualBasicTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenizer : object {
    internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.WhitespaceToken : Token {
}
internal static class Microsoft.Build.Shared.MetadataConversionUtilities : object {
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName, Boolean& metadataFound);
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.NativeMethodsShared : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static HandleRef NullHandleRef;
    internal static IntPtr NullIntPtr;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    internal static int MAX_PATH;
    private static NativeMethodsShared();
    internal static int SetErrorMode(int newMode);
    public static int WaitForMultipleObjects(UInt32 handle, IntPtr[] handles, bool waitAll, UInt32 milliseconds);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    internal static string FindOnPath(string filename);
    internal static void KillTree(int processIdTokill);
    internal static int GetParentProcessId(int processId);
    internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    internal static int GetOEMCP();
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static bool FreeLibrary(IntPtr module);
    internal static IntPtr GetProcAddress(IntPtr module, string procName);
    internal static IntPtr LoadLibrary(string fileName);
    internal static UInt32 GetRequestedRuntimeInfo(string pExe, string pwszVersion, string pConfigurationFile, UInt32 startupFlags, UInt32 runtimeInfoFlags, StringBuilder pDirectory, int dwDirectory, UInt32& dwDirectoryLength, StringBuilder pVersion, int cchBuffer, UInt32& dwlength);
    internal static int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static int GetCurrentDirectory(int nBufferLength, StringBuilder lpBuffer);
    internal static bool SetCurrentDirectory(string path);
    internal static int GetFullPathName(string target, int bufferLength, StringBuilder buffer, IntPtr mustBeZero);
    internal static int GetShortPathName(string path, StringBuilder fullpath, int length);
    internal static int GetLongPathName(string path, StringBuilder fullpath, int length);
    internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, TimeSpan timeout);
    [ExtensionAttribute]
internal static bool MsgWaitOne(WaitHandle handle, int timeout);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
internal class Microsoft.Build.Shared.OpenBaseKey : MulticastDelegate {
    public OpenBaseKey(object object, IntPtr method);
    public virtual RegistryKey Invoke(RegistryHive hive, RegistryView view);
    public virtual IAsyncResult BeginInvoke(RegistryHive hive, RegistryView view, AsyncCallback callback, object object);
    public virtual RegistryKey EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
internal static class Microsoft.Build.Shared.RegistryHelper : object {
    internal static IEnumerable`1<string> GetSubKeyNames(RegistryKey baseKey, string subkey);
    internal static string GetDefaultValue(RegistryKey baseKey, string subkey);
    internal static RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceString(String& code, String& helpKeyword, string resourceName, Object[] args);
    internal static string FormatResourceString(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
public class Microsoft.Build.Tasks.AL : ToolTaskExtension {
    public string AlgorithmId { get; public set; }
    public string BaseAddress { get; public set; }
    public string CompanyName { get; public set; }
    public string Configuration { get; public set; }
    public string Copyright { get; public set; }
    public string Culture { get; public set; }
    public bool DelaySign { get; public set; }
    public string Description { get; public set; }
    public string EvidenceFile { get; public set; }
    public string FileVersion { get; public set; }
    public string Flags { get; public set; }
    public bool GenerateFullPaths { get; public set; }
    public string KeyFile { get; public set; }
    public string KeyContainer { get; public set; }
    public string MainEntryPoint { get; public set; }
    [OutputAttribute]
[RequiredAttribute]
public ITaskItem OutputAssembly { get; public set; }
    public string Platform { get; public set; }
    internal string PlatformWith32BitPreference { get; }
    public bool Prefer32Bit { get; public set; }
    public string ProductName { get; public set; }
    public string ProductVersion { get; public set; }
    public String[] ResponseFiles { get; public set; }
    public string TargetType { get; public set; }
    public string TemplateFile { get; public set; }
    public string Title { get; public set; }
    public string Trademark { get; public set; }
    public string Version { get; public set; }
    public string Win32Icon { get; public set; }
    public string Win32Resource { get; public set; }
    public ITaskItem[] SourceModules { get; public set; }
    public ITaskItem[] EmbedResources { get; public set; }
    public ITaskItem[] LinkResources { get; public set; }
    public string SdkToolsPath { get; public set; }
    protected string ToolName { get; }
    public void set_AlgorithmId(string value);
    public string get_AlgorithmId();
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_CompanyName(string value);
    public string get_CompanyName();
    public void set_Configuration(string value);
    public string get_Configuration();
    public void set_Copyright(string value);
    public string get_Copyright();
    public void set_Culture(string value);
    public string get_Culture();
    public void set_DelaySign(bool value);
    public bool get_DelaySign();
    public void set_Description(string value);
    public string get_Description();
    public void set_EvidenceFile(string value);
    public string get_EvidenceFile();
    public void set_FileVersion(string value);
    public string get_FileVersion();
    public void set_Flags(string value);
    public string get_Flags();
    public void set_GenerateFullPaths(bool value);
    public bool get_GenerateFullPaths();
    public void set_KeyFile(string value);
    public string get_KeyFile();
    public void set_KeyContainer(string value);
    public string get_KeyContainer();
    public void set_MainEntryPoint(string value);
    public string get_MainEntryPoint();
    public void set_OutputAssembly(ITaskItem value);
    public ITaskItem get_OutputAssembly();
    public void set_Platform(string value);
    public string get_Platform();
    internal string get_PlatformWith32BitPreference();
    public void set_Prefer32Bit(bool value);
    public bool get_Prefer32Bit();
    public void set_ProductName(string value);
    public string get_ProductName();
    public void set_ProductVersion(string value);
    public string get_ProductVersion();
    public void set_ResponseFiles(String[] value);
    public String[] get_ResponseFiles();
    public void set_TargetType(string value);
    public string get_TargetType();
    public void set_TemplateFile(string value);
    public string get_TemplateFile();
    public void set_Title(string value);
    public string get_Title();
    public void set_Trademark(string value);
    public string get_Trademark();
    public void set_Version(string value);
    public string get_Version();
    public void set_Win32Icon(string value);
    public string get_Win32Icon();
    public void set_Win32Resource(string value);
    public string get_Win32Resource();
    public void set_SourceModules(ITaskItem[] value);
    public ITaskItem[] get_SourceModules();
    public void set_EmbedResources(ITaskItem[] value);
    public ITaskItem[] get_EmbedResources();
    public void set_LinkResources(ITaskItem[] value);
    public ITaskItem[] get_LinkResources();
    public void set_SdkToolsPath(string value);
    public string get_SdkToolsPath();
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.AppConfig : object {
    internal RuntimeSection Runtime { get; }
    internal void Load(string appConfigFile);
    internal void Read(XmlTextReader reader);
    internal RuntimeSection get_Runtime();
    internal static bool StringEquals(string a, string b);
}
internal class Microsoft.Build.Tasks.AppConfigException : ApplicationException {
    internal string FileName { get; }
    internal int Line { get; }
    internal int Column { get; }
    public AppConfigException(string message, string fileName, int line, int column, Exception inner);
    protected AppConfigException(SerializationInfo info, StreamingContext context);
    internal string get_FileName();
    internal int get_Line();
    internal int get_Column();
}
[LoadInSeparateAppDomainAttribute]
public abstract class Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension : AppDomainIsolatedTask {
    public TaskLoggingHelper Log { get; }
    public TaskLoggingHelper get_Log();
}
public class Microsoft.Build.Tasks.AspNetCompiler : ToolTaskExtension {
    public bool AllowPartiallyTrustedCallers { get; public set; }
    public bool DelaySign { get; public set; }
    public bool FixedNames { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public string MetabasePath { get; public set; }
    public string PhysicalPath { get; public set; }
    public string TargetPath { get; public set; }
    public string VirtualPath { get; public set; }
    public bool Updateable { get; public set; }
    public bool Force { get; public set; }
    public bool Debug { get; public set; }
    public bool Clean { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    protected string ToolName { get; }
    public bool get_AllowPartiallyTrustedCallers();
    public void set_AllowPartiallyTrustedCallers(bool value);
    public bool get_DelaySign();
    public void set_DelaySign(bool value);
    public bool get_FixedNames();
    public void set_FixedNames(bool value);
    public string get_KeyContainer();
    public void set_KeyContainer(string value);
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_MetabasePath();
    public void set_MetabasePath(string value);
    public string get_PhysicalPath();
    public void set_PhysicalPath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public string get_VirtualPath();
    public void set_VirtualPath(string value);
    public bool get_Updateable();
    public void set_Updateable(bool value);
    public bool get_Force();
    public void set_Force(bool value);
    public bool get_Debug();
    public void set_Debug(bool value);
    public bool get_Clean();
    public void set_Clean(bool value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    protected virtual string get_ToolName();
    public virtual bool Execute();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
}
internal class Microsoft.Build.Tasks.ASSEMBLY_INFO : ValueType {
    public UInt32 cbAssemblyInfo;
    public UInt32 dwAssemblyFlags;
    public ulong uliAssemblySizeInKB;
    public string pszCurrentAssemblyPathBuf;
    public UInt32 cchBuf;
}
[FlagsAttribute]
internal enum Microsoft.Build.Tasks.AssemblyCacheFlags : Enum {
    public int value__;
    public static AssemblyCacheFlags ZAP;
    public static AssemblyCacheFlags GAC;
    public static AssemblyCacheFlags DOWNLOAD;
}
internal class Microsoft.Build.Tasks.AssemblyEntry : object {
    public string FullName { get; }
    public bool InGAC { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public string SimpleName { get; }
    public string FrameworkDirectory { get; }
    public bool Retargetable { get; }
    public AssemblyNameExtension AssemblyNameExtension { get; }
    public AssemblyEntry(string name, string version, string publicKeyToken, string culture, bool inGAC, Nullable`1<bool> isRedistRoot, string redistName, string frameworkDirectory, bool retargetable);
    public string get_FullName();
    public bool get_InGAC();
    public Nullable`1<bool> get_IsRedistRoot();
    public string get_RedistName();
    public string get_SimpleName();
    public string get_FrameworkDirectory();
    public bool get_Retargetable();
    public AssemblyNameExtension get_AssemblyNameExtension();
}
internal static class Microsoft.Build.Tasks.AssemblyFolder : object {
    private static AssemblyFolder();
    internal static ICollection GetAssemblyFolders(string regKeyAlias);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersExCache : object {
    internal AssemblyFoldersEx AssemblyFoldersEx { get; }
    internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists fileExists);
    internal AssemblyFoldersEx get_AssemblyFoldersEx();
    internal bool FileExists(string path);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersExResolver : Resolver {
    internal AssemblyFoldersEx AssemblyFoldersExLocations { get; }
    public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine);
    private static AssemblyFoldersExResolver();
    internal AssemblyFoldersEx get_AssemblyFoldersExLocations();
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersResolver : Resolver {
    public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal enum Microsoft.Build.Tasks.ASSEMBLYINFO_FLAG : Enum {
    public int value__;
    public static ASSEMBLYINFO_FLAG VALIDATE;
    public static ASSEMBLYINFO_FLAG GETSIZE;
}
internal class Microsoft.Build.Tasks.AssemblyInformation : DisposableBase {
    public AssemblyNameExtension[] Dependencies { get; }
    public String[] Files { get; }
    public FrameworkName FrameworkNameAttribute { get; }
    internal AssemblyInformation(string sourceFile);
    private static AssemblyInformation();
    public AssemblyNameExtension[] get_Dependencies();
    public String[] get_Files();
    public FrameworkName get_FrameworkNameAttribute();
    internal static void GetAssemblyMetadata(string path, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkName);
    internal static FrameworkName GetTargetFrameworkAttribute(string path);
    internal static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    protected virtual void DisposeUnmanagedResources();
    internal static string GetRuntimeVersion(string path);
}
internal class Microsoft.Build.Tasks.ASSEMBLYMETADATA : ValueType {
    public ushort usMajorVersion;
    public ushort usMinorVersion;
    public ushort usBuildNumber;
    public ushort usRevisionNumber;
    public IntPtr rpLocale;
    public UInt32 cchLocale;
    public IntPtr rpProcessors;
    public UInt32 cProcessors;
    public IntPtr rOses;
    public UInt32 cOses;
}
[FlagsAttribute]
internal enum Microsoft.Build.Tasks.AssemblyNameDisplayFlags : Enum {
    public int value__;
    public static AssemblyNameDisplayFlags VERSION;
    public static AssemblyNameDisplayFlags CULTURE;
    public static AssemblyNameDisplayFlags PUBLIC_KEY_TOKEN;
    public static AssemblyNameDisplayFlags PROCESSORARCHITECTURE;
    public static AssemblyNameDisplayFlags RETARGETABLE;
    public static AssemblyNameDisplayFlags ALL;
}
internal class Microsoft.Build.Tasks.AssemblyNameReference : ValueType {
    internal AssemblyNameExtension assemblyName;
    internal Reference reference;
    public virtual string ToString();
    public sealed virtual int CompareTo(AssemblyNameReference other);
    public static AssemblyNameReference Create(AssemblyNameExtension assemblyName, Reference reference);
}
internal class Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer : object {
    internal static IComparer comparer;
    private static AssemblyNameReferenceAscendingVersionComparer();
    public sealed virtual int Compare(object o1, object o2);
}
internal class Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService : object {
    internal AssemblyNamesTypeResolutionService(ITaskItem[] referencePaths);
    public sealed virtual Assembly GetAssembly(AssemblyName name);
    public sealed virtual Assembly GetAssembly(AssemblyName name, bool throwOnError);
    public sealed virtual string GetPathOfAssembly(AssemblyName name);
    public sealed virtual Type GetType(string name);
    public sealed virtual Type GetType(string name, bool throwOnError);
    public sealed virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public sealed virtual void ReferenceAssembly(AssemblyName name);
}
internal class Microsoft.Build.Tasks.AssemblyRegistrationCache : StateFileBase {
    internal int Count { get; }
    internal int get_Count();
    internal void AddEntry(string assemblyPath, string typeLibraryPath);
    internal void GetEntry(int index, String& assemblyPath, String& typeLibraryPath);
}
internal class Microsoft.Build.Tasks.AssemblyRemapping : object {
    public AssemblyNameExtension From { get; }
    public AssemblyNameExtension To { get; }
    public AssemblyRemapping(AssemblyNameExtension from, AssemblyNameExtension to);
    public AssemblyNameExtension get_From();
    public AssemblyNameExtension get_To();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AssemblyRemapping other);
}
internal static class Microsoft.Build.Tasks.AssemblyResolution : object {
    internal static string ResolveReference(IEnumerable`1<Resolver[]> jaggedResolvers, AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& resolvedSearchPath, Boolean& userRequestedSpecificFile);
    public static Resolver[] CompileSearchPaths(IBuildEngine buildEngine, String[] searchPaths, String[] candidateAssemblyFiles, ProcessorArchitecture targetProcessorArchitecture, String[] frameworkPaths, FileExists fileExists, GetAssemblyName getAssemblyName, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, InstalledAssemblies installedAssemblies, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion);
    internal static Resolver[] CompileDirectories(IEnumerable`1<string> directories, FileExists fileExists, GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion);
}
internal static class Microsoft.Build.Tasks.AssemblyResolutionConstants : object {
    public static string hintPathSentinel;
    public static string assemblyFoldersSentinel;
    public static string candidateAssemblyFilesSentinel;
    public static string gacSentinel;
    public static string frameworkPathSentinel;
    public static string rawFileNameSentinel;
    public static string assemblyFoldersExSentinel;
}
internal class Microsoft.Build.Tasks.AssemblyTableInfo : object {
    internal string Path { get; }
    internal string FrameworkDirectory { get; }
    internal string Descriptor { get; }
    internal AssemblyTableInfo(string path, string frameworkDirectory);
    internal string get_Path();
    internal string get_FrameworkDirectory();
    internal string get_Descriptor();
    public sealed virtual int CompareTo(object obj);
}
public class Microsoft.Build.Tasks.AssignCulture : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithCulture { get; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithNoCulture { get; }
    [OutputAttribute]
public ITaskItem[] CultureNeutralAssignedFiles { get; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_AssignedFiles();
    public ITaskItem[] get_AssignedFilesWithCulture();
    public ITaskItem[] get_AssignedFilesWithNoCulture();
    public ITaskItem[] get_CultureNeutralAssignedFiles();
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.AssignProjectConfiguration : ResolveProjectBase {
    public string SolutionConfigurationContents { get; public set; }
    public bool AddSyntheticProjectReferencesForSolutionDependencies { get; public set; }
    public string DefaultToVcxPlatformMapping { get; public set; }
    public string VcxToDefaultPlatformMapping { get; public set; }
    public string CurrentProject { get; public set; }
    public string CurrentProjectConfiguration { get; public set; }
    public string CurrentProjectPlatform { get; public set; }
    public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; public set; }
    public bool ShouldUnsetParentConfigurationAndPlatform { get; public set; }
    public string OutputType { get; public set; }
    public bool ResolveConfigurationPlatformUsingMappings { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedProjects { get; public set; }
    [OutputAttribute]
public ITaskItem[] UnassignedProjects { get; public set; }
    private static AssignProjectConfiguration();
    public string get_SolutionConfigurationContents();
    public void set_SolutionConfigurationContents(string value);
    [CompilerGeneratedAttribute]
public bool get_AddSyntheticProjectReferencesForSolutionDependencies();
    [CompilerGeneratedAttribute]
public void set_AddSyntheticProjectReferencesForSolutionDependencies(bool value);
    public string get_DefaultToVcxPlatformMapping();
    public void set_DefaultToVcxPlatformMapping(string value);
    public string get_VcxToDefaultPlatformMapping();
    public void set_VcxToDefaultPlatformMapping(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProject();
    [CompilerGeneratedAttribute]
public void set_CurrentProject(string value);
    public string get_CurrentProjectConfiguration();
    public void set_CurrentProjectConfiguration(string value);
    public string get_CurrentProjectPlatform();
    public void set_CurrentProjectPlatform(string value);
    public bool get_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration();
    public void set_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration(bool value);
    public bool get_ShouldUnsetParentConfigurationAndPlatform();
    public void set_ShouldUnsetParentConfigurationAndPlatform(bool value);
    public string get_OutputType();
    public void set_OutputType(string value);
    public bool get_ResolveConfigurationPlatformUsingMappings();
    public void set_ResolveConfigurationPlatformUsingMappings(bool value);
    public ITaskItem[] get_AssignedProjects();
    public void set_AssignedProjects(ITaskItem[] value);
    public ITaskItem[] get_UnassignedProjects();
    public void set_UnassignedProjects(ITaskItem[] value);
    public virtual bool Execute();
    internal bool ResolveProject(ITaskItem projectRef, ITaskItem& resolvedProjectWithConfiguration);
    internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration, ITaskItem resolvedProjectWithConfiguration, XmlElement projectConfigurationElement);
}
public class Microsoft.Build.Tasks.AssignTargetPath : TaskExtension {
    [RequiredAttribute]
public string RootFolder { get; public set; }
    public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; }
    public string get_RootFolder();
    public void set_RootFolder(string value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_AssignedFiles();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.AxReference : AxTlbBaseReference {
    internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, string sdkToolsPath, IBuildEngine buildEngine, String[] environmentVariables);
    protected virtual string GetWrapperFileNameInternal(string typeLibName);
    internal bool GenerateWrapper(ComReferenceWrapperInfo& wrapperInfo);
}
internal abstract class Microsoft.Build.Tasks.AxTlbBaseReference : ComReference {
    protected string OutputDirectory { get; }
    protected IComReferenceResolver ResolverCallback { get; }
    protected string KeyContainer { get; protected set; }
    protected string KeyFile { get; protected set; }
    protected bool DelaySign { get; protected set; }
    protected bool ExecuteAsTool { get; protected set; }
    protected IBuildEngine BuildEngine { get; protected set; }
    protected String[] EnvironmentVariables { get; protected set; }
    protected string ToolPath { get; protected set; }
    protected bool IncludeTypeLibVersionInName { get; protected set; }
    internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, String[] environmentVariables);
    protected virtual string get_OutputDirectory();
    protected IComReferenceResolver get_ResolverCallback();
    [CompilerGeneratedAttribute]
protected string get_KeyContainer();
    [CompilerGeneratedAttribute]
protected void set_KeyContainer(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyFile();
    [CompilerGeneratedAttribute]
protected void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
protected bool get_DelaySign();
    [CompilerGeneratedAttribute]
protected void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
protected bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
protected void set_ExecuteAsTool(bool value);
    [CompilerGeneratedAttribute]
protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
protected void set_BuildEngine(IBuildEngine value);
    [CompilerGeneratedAttribute]
protected String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
protected void set_EnvironmentVariables(String[] value);
    [CompilerGeneratedAttribute]
protected string get_ToolPath();
    [CompilerGeneratedAttribute]
protected void set_ToolPath(string value);
    protected bool get_IncludeTypeLibVersionInName();
    protected void set_IncludeTypeLibVersionInName(bool value);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
    protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp);
    internal string GetWrapperPath();
    internal string GetWrapperFileName();
    protected abstract virtual string GetWrapperFileNameInternal(string typeLibName);
    internal static string GetWrapperFileName(string interopDllHeader, string typeLibName, bool includeTypeLibVersionInName, short majorVerNum, short minorVerNum);
    internal void GetAndValidateStrongNameKey(StrongNameKeyPair& keyPair, Byte[]& publicKey);
}
internal abstract class Microsoft.Build.Tasks.AxTlbBaseTask : ToolTaskExtension {
    public bool DelaySign { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public string SdkToolsPath { get; public set; }
    protected string ToolName { get; }
    public bool get_DelaySign();
    public void set_DelaySign(bool value);
    public string get_KeyContainer();
    public void set_KeyContainer(string value);
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    protected virtual string get_ToolName();
    public virtual bool Execute();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
}
internal class Microsoft.Build.Tasks.BadImageReferenceException : Exception {
    internal BadImageReferenceException(string message, Exception innerException);
    private BadImageReferenceException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.BindingRedirect : object {
    internal Version OldVersionLow { get; internal set; }
    internal Version OldVersionHigh { get; internal set; }
    internal Version NewVersion { get; internal set; }
    internal void set_OldVersionLow(Version value);
    internal Version get_OldVersionLow();
    internal void set_OldVersionHigh(Version value);
    internal Version get_OldVersionHigh();
    internal void set_NewVersion(Version value);
    internal Version get_NewVersion();
    internal void Read(XmlTextReader reader);
}
internal class Microsoft.Build.Tasks.BuildCacheDisposeWrapper : object {
    internal BuildCacheDisposeWrapper(CallDuringDispose callDuringDispose);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.CallTarget : TaskExtension {
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    public String[] get_Targets();
    public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    public bool get_RunEachTargetSeparately();
    public void set_RunEachTargetSeparately(bool value);
    public bool get_UseResultsCache();
    public void set_UseResultsCache(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.CandidateAssemblyFilesResolver : Resolver {
    public CandidateAssemblyFilesResolver(String[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.CheckIfAssemblyInGac : MulticastDelegate {
    public CheckIfAssemblyInGac(object object, IntPtr method);
    public virtual bool Invoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists);
    public virtual IAsyncResult BeginInvoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.CodeTaskFactory : object {
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    private static CodeTaskFactory();
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine loggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
public class Microsoft.Build.Tasks.CombinePath : TaskExtension {
    public string BasePath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] CombinedPaths { get; public set; }
    public string get_BasePath();
    public void set_BasePath(string value);
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    public ITaskItem[] get_CombinedPaths();
    public void set_CombinedPaths(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ComDependencyWalker : object {
    internal List`1<Exception> EncounteredProblems { get; }
    internal ComDependencyWalker(MarshalReleaseComObject marshalReleaseComObject);
    internal List`1<Exception> get_EncounteredProblems();
    internal void AnalyzeTypeLibrary(ITypeLib typeLibrary);
    internal TYPELIBATTR[] GetDependencies();
    internal ICollection`1<string> GetAnalyzedTypeNames();
    internal void ClearDependencyList();
    internal void ClearAnalyzedTypeCache();
}
public class Microsoft.Build.Tasks.CommandLineBuilderExtension : CommandLineBuilder {
    internal void AppendWhenTrue(string switchName, Hashtable bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, Hashtable bag, string parameterName);
    internal void AppendByChoiceSwitch(string switchName, Hashtable bag, string parameterName, string choice1, string choice2);
    internal void AppendSwitchWithInteger(string switchName, Hashtable bag, string parameterName);
    internal void AppendSwitchAliased(string switchName, string alias, string parameter);
    internal void AppendNestedSwitch(string outerSwitchName, string innerSwitchName, string parameter);
    protected string GetQuotedText(string unquotedText);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] attributes);
    internal void AppendSwitchWithSplitting(string switchName, string parameter, string delimiter, Char[] splitOn);
    internal static bool IsParameterEmpty(string parameter, Char[] splitOn);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] metadataNames, Boolean[] treatAsFlags);
}
internal abstract class Microsoft.Build.Tasks.ComReference : object {
    internal static bool ado27PropertyInitialized;
    internal static bool ado27Installed;
    internal static string ado27ErrorMessage;
    internal ComReferenceInfo ReferenceInfo { get; }
    internal string ItemName { get; }
    protected internal TaskLoggingHelper Log { get; }
    protected internal bool Silent { get; }
    internal static bool Ado27Installed { get; }
    internal static string Ado27ErrorMessage { get; }
    internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName);
    private static ComReference();
    internal virtual ComReferenceInfo get_ReferenceInfo();
    internal virtual string get_ItemName();
    protected internal TaskLoggingHelper get_Log();
    protected internal bool get_Silent();
    internal static bool get_Ado27Installed();
    internal static string get_Ado27ErrorMessage();
    internal static string UniqueKeyFromTypeLibAttr(TYPELIBATTR attr);
    internal static bool AreTypeLibAttrEqual(TYPELIBATTR attr1, TYPELIBATTR attr2);
    internal static void GetTypeLibAttrForTypeLib(ITypeLib& typeLib, TYPELIBATTR& typeLibAttr);
    internal static void GetTypeAttrForTypeInfo(ITypeInfo typeInfo, TYPEATTR& typeAttr);
    internal static void GetVarDescForVarIndex(ITypeInfo typeInfo, int varIndex, VARDESC& varDesc, IntPtr& varDescHandle);
    internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, FUNCDESC& funcDesc, IntPtr& funcDescHandle);
    internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, String& typeLibName);
    internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR typeLibAttr, String& typeLibName);
    internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists);
    internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, TYPELIBATTR& typeLibAttr, String& typeLibPath);
    internal static bool RemapAdoTypeLib(TaskLoggingHelper log, bool silent, TYPELIBATTR& typeLibAttr);
    internal abstract virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
}
internal class Microsoft.Build.Tasks.ComReferenceInfo : object {
    internal ITypeLib typeLibPointer;
    internal TYPELIBATTR attr;
    internal string typeLibName;
    internal string strippedTypeLibPath;
    internal string fullTypeLibPath;
    internal ITaskItem taskItem;
    internal ComReferenceInfo primaryOfAxImpRef;
    internal ComReferenceWrapperInfo resolvedWrapper;
    internal List`1<string> dependentWrapperPaths;
    internal ITaskItem referencePathItem;
    internal string SourceItemSpec { get; }
    internal ComReferenceInfo(ComReferenceInfo copyFrom);
    internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR tlbAttr, ITaskItem originalTaskItem, string targetProcessorArchitecture);
    internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture);
    internal string get_SourceItemSpec();
    internal void ReleaseTypeLibPtr();
}
internal static class Microsoft.Build.Tasks.ComReferenceItemMetadataNames : object {
    internal static string guid;
    internal static string versionMinor;
    internal static string versionMajor;
    internal static string lcid;
    internal static string privatized;
    internal static string wrapperTool;
    internal static string tlbReferenceName;
}
internal class Microsoft.Build.Tasks.ComReferenceResolutionException : Exception {
    internal ComReferenceResolutionException(Exception innerException);
    protected ComReferenceResolutionException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.Build.Tasks.ComReferenceTypes : object {
    internal static string tlbimp;
    internal static string aximp;
    internal static string primary;
    internal static string primaryortlbimp;
    internal static bool IsTlbImp(string refType);
    internal static bool IsAxImp(string refType);
    internal static bool IsPia(string refType);
    internal static bool IsPiaOrTlbImp(string refType);
}
internal class Microsoft.Build.Tasks.ComReferenceWrapperInfo : object {
    internal string path;
    internal Assembly assembly;
    internal AssemblyNameExtension originalPiaName;
}
internal enum Microsoft.Build.Tasks.ConflictLossReason : Enum {
    public int value__;
    public static ConflictLossReason DidntLose;
    public static ConflictLossReason HadLowerVersion;
    public static ConflictLossReason InsolubleConflict;
    public static ConflictLossReason WasNotPrimary;
    public static ConflictLossReason FusionEquivalentWithSameVersion;
}
public class Microsoft.Build.Tasks.ConvertToAbsolutePath : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] AbsolutePaths { get; public set; }
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    public ITaskItem[] get_AbsolutePaths();
    public void set_AbsolutePaths(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Copy : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public int Retries { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool UseHardlinksIfPossible { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] CopiedFiles { get; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    private static Copy();
    public ITaskItem[] get_SourceFiles();
    public void set_SourceFiles(ITaskItem[] value);
    public ITaskItem get_DestinationFolder();
    public void set_DestinationFolder(ITaskItem value);
    public int get_Retries();
    public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public bool get_UseHardlinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseHardlinksIfPossible(bool value);
    public bool get_SkipUnchangedFiles();
    public void set_SkipUnchangedFiles(bool value);
    public ITaskItem[] get_DestinationFiles();
    public void set_DestinationFiles(ITaskItem[] value);
    public ITaskItem[] get_CopiedFiles();
    public bool get_OverwriteReadOnlyFiles();
    public void set_OverwriteReadOnlyFiles(bool value);
    public sealed virtual void Cancel();
    internal bool Execute(CopyFileWithState copyFile);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.CopyFile : MulticastDelegate {
    public CopyFile(object object, IntPtr method);
    public virtual bool Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.CopyFileWithState : MulticastDelegate {
    public CopyFileWithState(object object, IntPtr method);
    public virtual Nullable`1<bool> Invoke(FileState source, FileState destination);
    public virtual IAsyncResult BeginInvoke(FileState source, FileState destination, AsyncCallback callback, object object);
    public virtual Nullable`1<bool> EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Tasks.CopyLocalState : Enum {
    public int value__;
    public static CopyLocalState Undecided;
    public static CopyLocalState YesBecauseOfHeuristic;
    public static CopyLocalState YesBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseFrameworkFile;
    public static CopyLocalState NoBecausePrerequisite;
    public static CopyLocalState NoBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseReferenceFoundInGAC;
    public static CopyLocalState NoBecauseConflictVictim;
    public static CopyLocalState NoBecauseUnresolved;
    public static CopyLocalState NoBecauseEmbedded;
    public static CopyLocalState NoBecauseParentReferencesFoundInGAC;
}
internal static class Microsoft.Build.Tasks.CopyLocalStateUtility : object {
    internal static bool IsCopyLocal(CopyLocalState state);
}
internal enum Microsoft.Build.Tasks.CorAssemblyFlags : Enum {
    public UInt32 value__;
    public static CorAssemblyFlags afPublicKey;
    public static CorAssemblyFlags afRetargetable;
}
[GuidAttribute("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
[TypeLibTypeAttribute("2")]
[ClassInterfaceAttribute("0")]
internal class Microsoft.Build.Tasks.CorMetaDataDispenser : object {
}
internal enum Microsoft.Build.Tasks.CorOpenFlags : Enum {
    public int value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofCacheImage;
    public static CorOpenFlags ofNoTypeLib;
}
internal enum Microsoft.Build.Tasks.CreateAssemblyNameObjectFlags : Enum {
    public int value__;
    public static CreateAssemblyNameObjectFlags CANOF_DEFAULT;
    public static CreateAssemblyNameObjectFlags CANOF_PARSE_DISPLAY_NAME;
}
public class Microsoft.Build.Tasks.CreateCSharpManifestResourceName : CreateManifestResourceName {
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log);
    protected virtual bool IsSourceFile(string fileName);
}
internal class Microsoft.Build.Tasks.CreateFileStream : MulticastDelegate {
    public CreateFileStream(object object, IntPtr method);
    public virtual Stream Invoke(string path, FileMode mode, FileAccess access);
    public virtual IAsyncResult BeginInvoke(string path, FileMode mode, FileAccess access, AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.CreateItem : TaskExtension {
    [OutputAttribute]
public ITaskItem[] Include { get; public set; }
    public ITaskItem[] Exclude { get; public set; }
    public bool PreserveExistingMetadata { get; public set; }
    public String[] AdditionalMetadata { get; public set; }
    public ITaskItem[] get_Include();
    public void set_Include(ITaskItem[] value);
    public ITaskItem[] get_Exclude();
    public void set_Exclude(ITaskItem[] value);
    public bool get_PreserveExistingMetadata();
    public void set_PreserveExistingMetadata(bool value);
    public String[] get_AdditionalMetadata();
    public void set_AdditionalMetadata(String[] value);
    public virtual bool Execute();
}
public abstract class Microsoft.Build.Tasks.CreateManifestResourceName : TaskExtension {
    protected Dictionary`2<string, ITaskItem> itemSpecToTaskitem;
    public bool PrependCultureAsDirectory { get; public set; }
    [RequiredAttribute]
public ITaskItem[] ResourceFiles { get; public set; }
    public string RootNamespace { get; public set; }
    [OutputAttribute]
public ITaskItem[] ManifestResourceNames { get; }
    [OutputAttribute]
public ITaskItem[] ResourceFilesWithManifestResourceNames { get; public set; }
    public bool get_PrependCultureAsDirectory();
    public void set_PrependCultureAsDirectory(bool value);
    public ITaskItem[] get_ResourceFiles();
    public void set_ResourceFiles(ITaskItem[] value);
    public string get_RootNamespace();
    public void set_RootNamespace(string value);
    public ITaskItem[] get_ManifestResourceNames();
    public ITaskItem[] get_ResourceFilesWithManifestResourceNames();
    public void set_ResourceFilesWithManifestResourceNames(ITaskItem[] value);
    protected abstract virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, Stream binaryStream);
    protected abstract virtual bool IsSourceFile(string fileName);
    internal bool Execute(CreateFileStream createFileStream);
    public virtual bool Execute();
    internal static string MakeValidEverettFolderIdentifier(string name);
    public static string MakeValidEverettIdentifier(string name);
}
public class Microsoft.Build.Tasks.CreateProperty : TaskExtension {
    [OutputAttribute]
public String[] Value { get; public set; }
    [OutputAttribute]
public String[] ValueSetByTask { get; }
    public String[] get_Value();
    public void set_Value(String[] value);
    public String[] get_ValueSetByTask();
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName : CreateManifestResourceName {
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log);
    protected virtual bool IsSourceFile(string fileName);
}
public class Microsoft.Build.Tasks.Csc : ManagedCompiler {
    public bool AllowUnsafeBlocks { get; public set; }
    public string ApplicationConfiguration { get; public set; }
    public string BaseAddress { get; public set; }
    public bool CheckForOverflowUnderflow { get; public set; }
    public string DocumentationFile { get; public set; }
    public string DisabledWarnings { get; public set; }
    public bool ErrorEndLocation { get; public set; }
    public string ErrorReport { get; public set; }
    public bool GenerateFullPaths { get; public set; }
    public string LangVersion { get; public set; }
    public string ModuleAssemblyName { get; public set; }
    public bool NoStandardLib { get; public set; }
    public string PdbFile { get; public set; }
    public string PreferredUILang { get; public set; }
    public bool UseHostCompilerIfAvailable { get; public set; }
    public int WarningLevel { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    protected string ToolName { get; }
    public void set_AllowUnsafeBlocks(bool value);
    public bool get_AllowUnsafeBlocks();
    public void set_ApplicationConfiguration(string value);
    public string get_ApplicationConfiguration();
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_CheckForOverflowUnderflow(bool value);
    public bool get_CheckForOverflowUnderflow();
    public void set_DocumentationFile(string value);
    public string get_DocumentationFile();
    public void set_DisabledWarnings(string value);
    public string get_DisabledWarnings();
    public void set_ErrorEndLocation(bool value);
    public bool get_ErrorEndLocation();
    public void set_ErrorReport(string value);
    public string get_ErrorReport();
    public void set_GenerateFullPaths(bool value);
    public bool get_GenerateFullPaths();
    public void set_LangVersion(string value);
    public string get_LangVersion();
    public void set_ModuleAssemblyName(string value);
    public string get_ModuleAssemblyName();
    public void set_NoStandardLib(bool value);
    public bool get_NoStandardLib();
    public void set_PdbFile(string value);
    public string get_PdbFile();
    public void set_PreferredUILang(string value);
    public string get_PreferredUILang();
    public void set_UseHostCompilerIfAvailable(bool value);
    public bool get_UseHostCompilerIfAvailable();
    public void set_WarningLevel(int value);
    public int get_WarningLevel();
    public void set_WarningsAsErrors(string value);
    public string get_WarningsAsErrors();
    public void set_WarningsNotAsErrors(string value);
    public string get_WarningsNotAsErrors();
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    internal string GetDefineConstantsSwitch(string originalDefineConstants);
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual bool CallHostObjectToExecute();
}
internal static class Microsoft.Build.Tasks.CSharpParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
}
internal static class Microsoft.Build.Tasks.Culture : object {
    internal static ItemCultureInfo GetItemCultureInfo(string name, string dependentUponFilename);
}
internal static class Microsoft.Build.Tasks.CultureStringUtilities : object {
    internal static bool IsValidCultureString(string cultureString);
    internal static void PopulateCultureInfoArray();
}
public class Microsoft.Build.Tasks.Delete : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public bool TreatErrorsAsWarnings { get; public set; }
    [OutputAttribute]
public ITaskItem[] DeletedFiles { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public bool get_TreatErrorsAsWarnings();
    public void set_TreatErrorsAsWarnings(bool value);
    public ITaskItem[] get_DeletedFiles();
    public void set_DeletedFiles(ITaskItem[] value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.Dependencies : object {
    internal DependencyFile GetDependencyFile(string filename);
    internal void AddDependencyFile(string filename, DependencyFile file);
    internal void RemoveDependencyFile(string filename);
    internal void Clear();
}
internal class Microsoft.Build.Tasks.DependencyFile : object {
    internal string FileName { get; }
    internal DateTime LastModified { get; }
    internal bool Exists { get; }
    internal DependencyFile(string filename);
    internal string get_FileName();
    internal DateTime get_LastModified();
    internal bool get_Exists();
    internal bool HasFileChanged();
}
internal class Microsoft.Build.Tasks.DependencyResolutionException : Exception {
    internal DependencyResolutionException(string message, Exception innerException);
    private DependencyResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.DependentAssembly : object {
    internal AssemblyName PartialAssemblyName { get; internal set; }
    internal BindingRedirect[] BindingRedirects { get; internal set; }
    internal void set_PartialAssemblyName(AssemblyName value);
    internal AssemblyName get_PartialAssemblyName();
    internal void Read(XmlTextReader reader);
    internal void set_BindingRedirects(BindingRedirect[] value);
    internal BindingRedirect[] get_BindingRedirects();
}
[ComVisibleAttribute("True")]
[GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder : object {
    public string Path { get; public set; }
    public ProductCollection Products { get; }
    internal String[] Cultures { get; }
    internal bool Validate { get; internal set; }
    public BootstrapperBuilder(string visualStudioVersion);
    private static BootstrapperBuilder();
    public sealed virtual string get_Path();
    public sealed virtual void set_Path(string value);
    public sealed virtual ProductCollection get_Products();
    public sealed virtual BuildResults Build(BuildSettings settings);
    public String[] GetOutputFolders(String[] productCodes, string culture, string fallbackCulture, ComponentsLocation componentsLocation);
    internal bool ContainsCulture(string culture);
    internal String[] get_Cultures();
    internal bool get_Validate();
    internal void set_Validate(bool value);
}
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage : object {
    public BuildMessageSeverity Severity { get; }
    public string Message { get; }
    public string HelpKeyword { get; }
    public int HelpId { get; }
    internal string HelpCode { get; }
    private static BuildMessage();
    internal static BuildMessage CreateMessage(BuildMessageSeverity severity, string resourceName, Object[] args);
    public sealed virtual BuildMessageSeverity get_Severity();
    public sealed virtual string get_Message();
    public sealed virtual string get_HelpKeyword();
    public sealed virtual int get_HelpId();
    internal string get_HelpCode();
}
[ComVisibleAttribute("True")]
[GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
public enum Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity : Enum {
    public int value__;
    public static BuildMessageSeverity Info;
    public static BuildMessageSeverity Warning;
    public static BuildMessageSeverity Error;
}
[ComVisibleAttribute("True")]
[GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults : object {
    public bool Succeeded { get; }
    public string KeyFile { get; }
    public String[] ComponentFiles { get; }
    public BuildMessage[] Messages { get; }
    public sealed virtual bool get_Succeeded();
    public sealed virtual string get_KeyFile();
    public sealed virtual String[] get_ComponentFiles();
    public sealed virtual BuildMessage[] get_Messages();
    internal void AddMessage(BuildMessage message);
    internal void AddComponentFiles(String[] filePaths);
    internal void BuildSucceeded();
    internal void SetKeyFile(string filePath);
}
[ComVisibleAttribute("True")]
[GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings : object {
    public string ApplicationName { get; public set; }
    public string ApplicationFile { get; public set; }
    public bool ApplicationRequiresElevation { get; public set; }
    public string ApplicationUrl { get; public set; }
    public ComponentsLocation ComponentsLocation { get; public set; }
    public string ComponentsUrl { get; public set; }
    public bool CopyComponents { get; public set; }
    public int LCID { get; public set; }
    public int FallbackLCID { get; public set; }
    public string OutputPath { get; public set; }
    public ProductBuilderCollection ProductBuilders { get; }
    public string SupportUrl { get; public set; }
    public bool Validate { get; public set; }
    internal string Culture { get; internal set; }
    internal string FallbackCulture { get; internal set; }
    public sealed virtual string get_ApplicationName();
    public sealed virtual void set_ApplicationName(string value);
    public sealed virtual string get_ApplicationFile();
    public sealed virtual void set_ApplicationFile(string value);
    public sealed virtual bool get_ApplicationRequiresElevation();
    public sealed virtual void set_ApplicationRequiresElevation(bool value);
    public sealed virtual string get_ApplicationUrl();
    public sealed virtual void set_ApplicationUrl(string value);
    public sealed virtual ComponentsLocation get_ComponentsLocation();
    public sealed virtual void set_ComponentsLocation(ComponentsLocation value);
    public sealed virtual string get_ComponentsUrl();
    public sealed virtual void set_ComponentsUrl(string value);
    public sealed virtual bool get_CopyComponents();
    public sealed virtual void set_CopyComponents(bool value);
    public sealed virtual int get_LCID();
    public sealed virtual void set_LCID(int value);
    public sealed virtual int get_FallbackLCID();
    public sealed virtual void set_FallbackLCID(int value);
    public sealed virtual string get_OutputPath();
    public sealed virtual void set_OutputPath(string value);
    public sealed virtual ProductBuilderCollection get_ProductBuilders();
    public sealed virtual string get_SupportUrl();
    public sealed virtual void set_SupportUrl(string value);
    public sealed virtual bool get_Validate();
    public sealed virtual void set_Validate(bool value);
    internal string get_Culture();
    internal void set_Culture(string value);
    internal string get_FallbackCulture();
    internal void set_FallbackCulture(string value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
public enum Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation : Enum {
    public int value__;
    public static ComponentsLocation HomeSite;
    public static ComponentsLocation Relative;
    public static ComponentsLocation Absolute;
}
internal enum Microsoft.Build.Tasks.Deployment.Bootstrapper.CopyAllFilesType : Enum {
    public int value__;
    public static CopyAllFilesType CopyAllFilesFalse;
    public static CopyAllFilesType CopyAllFilesTrue;
    public static CopyAllFilesType CopyAllFilesIfNotHomeSite;
}
[ComVisibleAttribute("True")]
[GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder {
    [DispIdAttribute("1")]
public string Path { get; public set; }
    [DispIdAttribute("4")]
public ProductCollection Products { get; }
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual ProductCollection get_Products();
    [DispIdAttribute("5")]
public abstract virtual BuildResults Build(BuildSettings settings);
}
[ComVisibleAttribute("True")]
[GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage {
    [DispIdAttribute("1")]
public BuildMessageSeverity Severity { get; }
    [DispIdAttribute("2")]
public string Message { get; }
    [DispIdAttribute("3")]
public string HelpKeyword { get; }
    [DispIdAttribute("4")]
public int HelpId { get; }
    public abstract virtual BuildMessageSeverity get_Severity();
    public abstract virtual string get_Message();
    public abstract virtual string get_HelpKeyword();
    public abstract virtual int get_HelpId();
}
[ComVisibleAttribute("True")]
[GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults {
    [DispIdAttribute("1")]
public bool Succeeded { get; }
    [DispIdAttribute("2")]
public string KeyFile { get; }
    [DispIdAttribute("3")]
public String[] ComponentFiles { get; }
    [DispIdAttribute("4")]
public BuildMessage[] Messages { get; }
    public abstract virtual bool get_Succeeded();
    public abstract virtual string get_KeyFile();
    public abstract virtual String[] get_ComponentFiles();
    public abstract virtual BuildMessage[] get_Messages();
}
[ComVisibleAttribute("True")]
[GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings {
    [DispIdAttribute("1")]
public string ApplicationName { get; public set; }
    [DispIdAttribute("2")]
public string ApplicationFile { get; public set; }
    [DispIdAttribute("3")]
public string ApplicationUrl { get; public set; }
    [DispIdAttribute("4")]
public string ComponentsUrl { get; public set; }
    [DispIdAttribute("5")]
public bool CopyComponents { get; public set; }
    [DispIdAttribute("6")]
public int LCID { get; public set; }
    [DispIdAttribute("7")]
public int FallbackLCID { get; public set; }
    [DispIdAttribute("8")]
public string OutputPath { get; public set; }
    [DispIdAttribute("9")]
public ProductBuilderCollection ProductBuilders { get; }
    [DispIdAttribute("10")]
public bool Validate { get; public set; }
    [DispIdAttribute("11")]
public ComponentsLocation ComponentsLocation { get; public set; }
    [DispIdAttribute("12")]
public string SupportUrl { get; public set; }
    [DispIdAttribute("13")]
public bool ApplicationRequiresElevation { get; public set; }
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_ApplicationFile();
    public abstract virtual void set_ApplicationFile(string value);
    public abstract virtual string get_ApplicationUrl();
    public abstract virtual void set_ApplicationUrl(string value);
    public abstract virtual string get_ComponentsUrl();
    public abstract virtual void set_ComponentsUrl(string value);
    public abstract virtual bool get_CopyComponents();
    public abstract virtual void set_CopyComponents(bool value);
    public abstract virtual int get_LCID();
    public abstract virtual void set_LCID(int value);
    public abstract virtual int get_FallbackLCID();
    public abstract virtual void set_FallbackLCID(int value);
    public abstract virtual string get_OutputPath();
    public abstract virtual void set_OutputPath(string value);
    public abstract virtual ProductBuilderCollection get_ProductBuilders();
    public abstract virtual bool get_Validate();
    public abstract virtual void set_Validate(bool value);
    public abstract virtual ComponentsLocation get_ComponentsLocation();
    public abstract virtual void set_ComponentsLocation(ComponentsLocation value);
    public abstract virtual string get_SupportUrl();
    public abstract virtual void set_SupportUrl(string value);
    public abstract virtual bool get_ApplicationRequiresElevation();
    public abstract virtual void set_ApplicationRequiresElevation(bool value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct {
    [DispIdAttribute("1")]
public ProductBuilder ProductBuilder { get; }
    [DispIdAttribute("2")]
public string Name { get; }
    [DispIdAttribute("3")]
public string ProductCode { get; }
    [DispIdAttribute("4")]
public ProductCollection Includes { get; }
    public abstract virtual ProductBuilder get_ProductBuilder();
    public abstract virtual string get_Name();
    public abstract virtual string get_ProductCode();
    public abstract virtual ProductCollection get_Includes();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder {
    [DispIdAttribute("1")]
public Product Product { get; }
    public abstract virtual Product get_Product();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection {
    [DispIdAttribute("2")]
public abstract virtual void Add(ProductBuilder builder);
}
[ComVisibleAttribute("True")]
[GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection {
    [DispIdAttribute("1")]
public int Count { get; }
    public abstract virtual int get_Count();
    [DispIdAttribute("2")]
public abstract virtual Product Item(int index);
    [DispIdAttribute("3")]
public abstract virtual Product Product(string productCode);
}
internal static class Microsoft.Build.Tasks.Deployment.Bootstrapper.NativeMethods : object {
    internal static IntPtr BeginUpdateResourceW(string fileName, bool deleteExistingResource);
    internal static bool UpdateResourceW(IntPtr hUpdate, IntPtr lpType, string lpName, short wLanguage, Byte[] data, int cbData);
    internal static bool EndUpdateResource(IntPtr hUpdate, bool fDiscard);
}
[ComVisibleAttribute("False")]
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.Package : object {
    internal XmlNode Node { get; }
    public string Name { get; }
    public string Culture { get; }
    public Product Product { get; }
    internal bool ValidationPassed { get; }
    internal XmlValidationResults ValidationResults { get; }
    public Package(Product product, XmlNode node, XmlValidationResults validationResults, string name, string culture);
    internal XmlNode get_Node();
    public string get_Name();
    public string get_Culture();
    public Product get_Product();
    internal bool get_ValidationPassed();
    internal XmlValidationResults get_ValidationResults();
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.PackageCollection : object {
    public int Count { get; }
    public Package Item(int index);
    public Package Package(string culture);
    public int get_Count();
    internal void Add(Package package);
    public sealed virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
[GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.Product : object {
    internal XmlNode Node { get; }
    internal CopyAllFilesType CopyAllPackageFiles { get; }
    public ProductBuilder ProductBuilder { get; }
    public string ProductCode { get; }
    public string Name { get; }
    public ProductCollection Includes { get; }
    internal List`1<List`1<Product>> Dependencies { get; }
    internal ArrayList MissingDependencies { get; }
    internal PackageCollection Packages { get; }
    internal bool ValidationPassed { get; }
    internal ProductValidationResults ValidationResults { get; }
    internal Product(XmlNode node, string code, ProductValidationResults validationResults, string copyAll);
    internal XmlNode get_Node();
    internal CopyAllFilesType get_CopyAllPackageFiles();
    public sealed virtual ProductBuilder get_ProductBuilder();
    public sealed virtual string get_ProductCode();
    public sealed virtual string get_Name();
    public sealed virtual ProductCollection get_Includes();
    internal List`1<List`1<Product>> get_Dependencies();
    internal bool ContainsCulture(string culture);
    internal bool ContainsDependencies(List`1<Product> dependenciesToCheck);
    internal ArrayList get_MissingDependencies();
    internal void AddPackage(Package package);
    internal void AddIncludedProduct(Product product);
    internal void AddDependentProduct(Product product);
    internal void AddMissingDependency(ArrayList productCodes);
    internal PackageCollection get_Packages();
    internal XmlValidationResults GetPackageValidationResults(string culture);
    internal bool get_ValidationPassed();
    internal ProductValidationResults get_ValidationResults();
}
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder : object {
    public Product Product { get; }
    internal string Name { get; }
    internal string ProductCode { get; }
    internal ProductBuilder(Product product);
    internal ProductBuilder(Product product, string culture);
    public sealed virtual Product get_Product();
    internal string get_Name();
    internal string get_ProductCode();
}
[ComVisibleAttribute("True")]
[GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection : object {
    internal int Count { get; }
    public sealed virtual void Add(ProductBuilder builder);
    public sealed virtual IEnumerator GetEnumerator();
    internal int get_Count();
    internal ProductBuilder Item(int index);
    internal void Insert(int index, ProductBuilder builder);
}
[ComVisibleAttribute("True")]
[GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection : object {
    public int Count { get; }
    internal void Add(Product product);
    public sealed virtual Product Item(int index);
    public sealed virtual Product Product(string productCode);
    public sealed virtual int get_Count();
    internal void Clear();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductValidationResults : XmlValidationResults {
    public ProductValidationResults(string filePath);
    public void AddPackageResults(string culture, XmlValidationResults results);
    public XmlValidationResults PackageResults(string culture);
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.ResourceUpdater : object {
    public void AddStringResource(int type, string name, string data);
    public void AddFileResource(string filename, string key);
    public bool UpdateResources(string filename, BuildResults results);
}
internal static class Microsoft.Build.Tasks.Deployment.Bootstrapper.Util : object {
    public static CultureInfo DefaultCultureInfo { get; }
    public static string DefaultPath { get; }
    public static string AddTrailingChar(string str, char ch);
    public static bool IsUncPath(string path);
    public static bool IsWebUrl(string path);
    public static CultureInfo GetCultureInfoFromString(string cultureName);
    public static CultureInfo get_DefaultCultureInfo();
    public static string get_DefaultPath();
    public static string GetDefaultPath(string visualStudioVersion);
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults : object {
    public string FilePath { get; }
    public String[] ValidationErrors { get; }
    public bool ValidationPassed { get; }
    public String[] ValidationWarnings { get; }
    public XmlValidationResults(string filePath);
    public string get_FilePath();
    public void SchemaValidationEventHandler(object sender, ValidationEventArgs e);
    public String[] get_ValidationErrors();
    public bool get_ValidationPassed();
    public String[] get_ValidationWarnings();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity : object {
    public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath);
    public ApplicationIdentity(string url, AssemblyIdentity deployManifestIdentity, AssemblyIdentity applicationManifestIdentity);
    public virtual string ToString();
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("ApplicationManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest : AssemblyManifest {
    [XmlIgnoreAttribute]
public string ConfigFile { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public string TargetFrameworkVersion { get; public set; }
    [XmlIgnoreAttribute]
public string ErrorReportUrl { get; public set; }
    [XmlIgnoreAttribute]
public FileAssociationCollection FileAssociations { get; }
    [XmlIgnoreAttribute]
public bool HostInBrowser { get; public set; }
    [XmlIgnoreAttribute]
public string IconFile { get; public set; }
    [XmlIgnoreAttribute]
public bool IsClickOnceManifest { get; public set; }
    [XmlIgnoreAttribute]
public int MaxTargetPath { get; public set; }
    [XmlIgnoreAttribute]
public string OSDescription { get; public set; }
    [XmlIgnoreAttribute]
public string OSSupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public string OSVersion { get; public set; }
    [XmlIgnoreAttribute]
public string Product { get; public set; }
    [XmlIgnoreAttribute]
public string Publisher { get; public set; }
    [XmlIgnoreAttribute]
public string SuiteName { get; public set; }
    [XmlIgnoreAttribute]
public string SupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public TrustInfo TrustInfo { get; public set; }
    [XmlIgnoreAttribute]
public bool UseApplicationTrust { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ConfigFile")]
public string XmlConfigFile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("EntryPointIdentity")]
public AssemblyIdentity XmlEntryPointIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("EntryPointParameters")]
public string XmlEntryPointParameters { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("EntryPointPath")]
public string XmlEntryPointPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ErrorReportUrl")]
public string XmlErrorReportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("FileAssociations")]
public FileAssociation[] XmlFileAssociations { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HostInBrowser")]
public string XmlHostInBrowser { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IconFile")]
public string XmlIconFile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsClickOnceManifest")]
public string XmlIsClickOnceManifest { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSMajor")]
public string XmlOSMajor { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSMinor")]
public string XmlOSMinor { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSBuild")]
public string XmlOSBuild { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSRevision")]
public string XmlOSRevision { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSSupportUrl")]
public string XmlOSSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSDescription")]
public string XmlOSDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Product")]
public string XmlProduct { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Publisher")]
public string XmlPublisher { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SuiteName")]
public string XmlSuiteName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportUrl")]
public string XmlSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UseApplicationTrust")]
public string XmlUseApplicationTrust { get; public set; }
    public ApplicationManifest(string targetFrameworkVersion);
    public string get_ConfigFile();
    public void set_ConfigFile(string value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public FileAssociationCollection get_FileAssociations();
    public bool get_HostInBrowser();
    public void set_HostInBrowser(bool value);
    public string get_IconFile();
    public void set_IconFile(string value);
    public bool get_IsClickOnceManifest();
    public void set_IsClickOnceManifest(bool value);
    public int get_MaxTargetPath();
    public void set_MaxTargetPath(int value);
    internal virtual void OnBeforeSave();
    public string get_OSDescription();
    public void set_OSDescription(string value);
    public string get_OSSupportUrl();
    public void set_OSSupportUrl(string value);
    public string get_OSVersion();
    public void set_OSVersion(string value);
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public TrustInfo get_TrustInfo();
    public void set_TrustInfo(TrustInfo value);
    public bool get_UseApplicationTrust();
    public void set_UseApplicationTrust(bool value);
    public virtual void Validate();
    public string get_XmlConfigFile();
    public void set_XmlConfigFile(string value);
    public AssemblyIdentity get_XmlEntryPointIdentity();
    public void set_XmlEntryPointIdentity(AssemblyIdentity value);
    public string get_XmlEntryPointParameters();
    public void set_XmlEntryPointParameters(string value);
    public string get_XmlEntryPointPath();
    public void set_XmlEntryPointPath(string value);
    public string get_XmlErrorReportUrl();
    public void set_XmlErrorReportUrl(string value);
    public FileAssociation[] get_XmlFileAssociations();
    public void set_XmlFileAssociations(FileAssociation[] value);
    public string get_XmlHostInBrowser();
    public void set_XmlHostInBrowser(string value);
    public string get_XmlIconFile();
    public void set_XmlIconFile(string value);
    public string get_XmlIsClickOnceManifest();
    public void set_XmlIsClickOnceManifest(string value);
    public string get_XmlOSMajor();
    public void set_XmlOSMajor(string value);
    public string get_XmlOSMinor();
    public void set_XmlOSMinor(string value);
    public string get_XmlOSBuild();
    public void set_XmlOSBuild(string value);
    public string get_XmlOSRevision();
    public void set_XmlOSRevision(string value);
    public string get_XmlOSSupportUrl();
    public void set_XmlOSSupportUrl(string value);
    public string get_XmlOSDescription();
    public void set_XmlOSDescription(string value);
    public string get_XmlProduct();
    public void set_XmlProduct(string value);
    public string get_XmlPublisher();
    public void set_XmlPublisher(string value);
    public string get_XmlSuiteName();
    public void set_XmlSuiteName(string value);
    public string get_XmlSupportUrl();
    public void set_XmlSupportUrl(string value);
    public string get_XmlUseApplicationTrust();
    public void set_XmlUseApplicationTrust(string value);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("AssemblyIdentity")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity : object {
    [XmlIgnoreAttribute]
public bool IsFrameworkAssembly { get; }
    [XmlIgnoreAttribute]
public string Culture { get; public set; }
    [XmlIgnoreAttribute]
public bool IsNeutralPlatform { get; }
    [XmlIgnoreAttribute]
public bool IsStrongName { get; }
    [XmlIgnoreAttribute]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public string ProcessorArchitecture { get; public set; }
    [XmlIgnoreAttribute]
public string PublicKeyToken { get; public set; }
    [XmlIgnoreAttribute]
public string Type { get; public set; }
    [XmlIgnoreAttribute]
public string Version { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("PublicKeyToken")]
public string XmlPublicKeyToken { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Culture")]
public string XmlCulture { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ProcessorArchitecture")]
public string XmlProcessorArchitecture { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Type")]
public string XmlType { get; public set; }
    public AssemblyIdentity(string name);
    public AssemblyIdentity(string name, string version);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type);
    public AssemblyIdentity(AssemblyIdentity identity);
    public static AssemblyIdentity FromAssemblyName(string assemblyName);
    public static AssemblyIdentity FromManifest(string path);
    public static AssemblyIdentity FromManagedAssembly(string path);
    public static AssemblyIdentity FromNativeAssembly(string path);
    public static AssemblyIdentity FromFile(string path);
    internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2);
    internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2, bool specificVersion);
    public bool get_IsFrameworkAssembly();
    public string get_Culture();
    public void set_Culture(string value);
    public string GetFullName(FullNameFlags flags);
    public bool get_IsNeutralPlatform();
    public bool get_IsStrongName();
    public string get_Name();
    public void set_Name(string value);
    public string get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(string value);
    public string get_PublicKeyToken();
    public void set_PublicKeyToken(string value);
    internal string Resolve(String[] searchPaths);
    internal string Resolve(String[] searchPaths, bool specificVersion);
    public virtual string ToString();
    public string get_Type();
    public void set_Type(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
    public string get_XmlPublicKeyToken();
    public void set_XmlPublicKeyToken(string value);
    public string get_XmlCulture();
    public void set_XmlCulture(string value);
    public string get_XmlProcessorArchitecture();
    public void set_XmlProcessorArchitecture(string value);
    public string get_XmlType();
    public void set_XmlType(string value);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("AssemblyManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest : Manifest {
    [XmlIgnoreAttribute]
public ProxyStub[] ExternalProxyStubs { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ExternalProxyStubs")]
public ProxyStub[] XmlExternalProxyStubs { get; public set; }
    public ProxyStub[] get_ExternalProxyStubs();
    public ProxyStub[] get_XmlExternalProxyStubs();
    public void set_XmlExternalProxyStubs(ProxyStub[] value);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference : BaseReference {
    [XmlIgnoreAttribute]
public AssemblyIdentity AssemblyIdentity { get; public set; }
    [XmlIgnoreAttribute]
public bool IsPrerequisite { get; public set; }
    [XmlIgnoreAttribute]
internal bool IsVirtual { get; }
    [XmlIgnoreAttribute]
public AssemblyReferenceType ReferenceType { get; public set; }
    [XmlIgnoreAttribute]
internal bool IsPrimary { get; internal set; }
    protected internal string SortName { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("AssemblyIdentity")]
public AssemblyIdentity XmlAssemblyIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsNative")]
public string XmlIsNative { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsPrerequisite")]
public string XmlIsPrerequisite { get; public set; }
    public AssemblyReference(string path);
    public AssemblyIdentity get_AssemblyIdentity();
    public void set_AssemblyIdentity(AssemblyIdentity value);
    public bool get_IsPrerequisite();
    public void set_IsPrerequisite(bool value);
    internal bool get_IsVirtual();
    public AssemblyReferenceType get_ReferenceType();
    public void set_ReferenceType(AssemblyReferenceType value);
    internal bool get_IsPrimary();
    internal void set_IsPrimary(bool value);
    protected internal virtual string get_SortName();
    public virtual string ToString();
    public AssemblyIdentity get_XmlAssemblyIdentity();
    public void set_XmlAssemblyIdentity(AssemblyIdentity value);
    public string get_XmlIsNative();
    public void set_XmlIsNative(string value);
    public string get_XmlIsPrerequisite();
    public void set_XmlIsPrerequisite(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection : object {
    public AssemblyReference Item { get; }
    public int Count { get; }
    internal AssemblyReferenceCollection(AssemblyReference[] array);
    public AssemblyReference get_Item(int index);
    public AssemblyReference Add(string path);
    public AssemblyReference Add(AssemblyReference assembly);
    public void Clear();
    public int get_Count();
    public AssemblyReference Find(string name);
    public AssemblyReference Find(AssemblyIdentity identity);
    public AssemblyReference FindTargetPath(string targetPath);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(AssemblyReference assemblyReference);
    internal AssemblyReference[] ToArray();
}
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType : Enum {
    public int value__;
    public static AssemblyReferenceType Unspecified;
    public static AssemblyReferenceType ClickOnceManifest;
    public static AssemblyReferenceType ManagedAssembly;
    public static AssemblyReferenceType NativeAssembly;
}
[ComVisibleAttribute("False")]
public abstract class Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference : object {
    internal bool IncludeHash { get; internal set; }
    [XmlIgnoreAttribute]
public string Group { get; public set; }
    [XmlIgnoreAttribute]
public string Hash { get; public set; }
    [XmlIgnoreAttribute]
public bool IsOptional { get; public set; }
    [XmlIgnoreAttribute]
public string ResolvedPath { get; public set; }
    [XmlIgnoreAttribute]
public long Size { get; public set; }
    protected internal string SortName { get; }
    [XmlIgnoreAttribute]
public string SourcePath { get; public set; }
    [XmlIgnoreAttribute]
public string TargetPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Group")]
public string XmlGroup { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Hash")]
public string XmlHash { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HashAlg")]
public string XmlHashAlgorithm { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsOptional")]
public string XmlIsOptional { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Path")]
public string XmlPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Size")]
public string XmlSize { get; public set; }
    protected internal BaseReference(string path);
    internal static string GetDefaultTargetPath(string path);
    internal bool get_IncludeHash();
    internal void set_IncludeHash(bool value);
    public string get_Group();
    public void set_Group(string value);
    public string get_Hash();
    public void set_Hash(string value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public string get_ResolvedPath();
    public void set_ResolvedPath(string value);
    public long get_Size();
    public void set_Size(long value);
    protected internal abstract virtual string get_SortName();
    public string get_SourcePath();
    public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public virtual string ToString();
    public string get_XmlGroup();
    public void set_XmlGroup(string value);
    public string get_XmlHash();
    public void set_XmlHash(string value);
    public string get_XmlHashAlgorithm();
    public void set_XmlHashAlgorithm(string value);
    public string get_XmlIsOptional();
    public void set_XmlIsOptional(string value);
    public string get_XmlPath();
    public void set_XmlPath(string value);
    public string get_XmlSize();
    public void set_XmlSize(string value);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass : object {
    [XmlIgnoreAttribute]
public string ClsId { get; }
    [XmlIgnoreAttribute]
public string Description { get; }
    [XmlIgnoreAttribute]
public string ProgId { get; }
    [XmlIgnoreAttribute]
public string ThreadingModel { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Clsid")]
public string XmlClsId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Progid")]
public string XmlProgId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ThreadingModel")]
public string XmlThreadingModel { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel, string description);
    public string get_ClsId();
    public string get_Description();
    public string get_ProgId();
    public string get_ThreadingModel();
    public string get_TlbId();
    public string get_XmlClsId();
    public void set_XmlClsId(string value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public string get_XmlProgId();
    public void set_XmlProgId(string value);
    public string get_XmlThreadingModel();
    public void set_XmlThreadingModel(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComImporter : object {
    public bool Success { get; }
    public ComClass[] ComClasses { get; }
    public TypeLib TypeLib { get; }
    public ComImporter(string path, OutputMessageCollection outputMessages, string outputDisplayName);
    private static ComImporter();
    public bool get_Success();
    public ComClass[] get_ComClasses();
    public TypeLib get_TypeLib();
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComInfo : object {
    public string ComponentFileName { get; }
    public string ClsId { get; }
    public string ManifestFileName { get; }
    public string TlbId { get; }
    public ComInfo(string manifestFileName, string componentFileName, string clsid, string tlbid);
    public string get_ComponentFileName();
    public string get_ClsId();
    public string get_ManifestFileName();
    public string get_TlbId();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework : object {
    [XmlIgnoreAttribute]
public string Version { get; public set; }
    [XmlIgnoreAttribute]
public string Profile { get; public set; }
    [XmlIgnoreAttribute]
public string SupportedRuntime { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Profile")]
public string XmlProfile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportedRuntime")]
public string XmlSupportedRuntime { get; public set; }
    public string get_Version();
    public void set_Version(string value);
    public string get_Profile();
    public void set_Profile(string value);
    public string get_SupportedRuntime();
    public void set_SupportedRuntime(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
    public string get_XmlProfile();
    public void set_XmlProfile(string value);
    public string get_XmlSupportedRuntime();
    public void set_XmlSupportedRuntime(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection : object {
    public CompatibleFramework Item { get; }
    public int Count { get; }
    internal CompatibleFrameworkCollection(CompatibleFramework[] compatibleFrameworks);
    public CompatibleFramework get_Item(int index);
    public void Add(CompatibleFramework compatibleFramework);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal CompatibleFramework[] ToArray();
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Constants : object {
    public static string CLRPlatformAssemblyName;
    public static string DeployFileExtension;
    public static string OSVersion_Win9X;
    public static string OSVersion_WinXP;
    public static Version EntryPointMinimumImageVersion;
    public static string TargetFrameworkVersion20;
    public static string TargetFrameworkVersion30;
    public static string TargetFrameworkVersion35;
    public static string TargetFrameworkVersion40;
    public static String[] NET30AssemblyIdentity;
    public static String[] NET35AssemblyIdentity;
    public static String[] NET35SP1AssemblyIdentity;
    public static String[] NET35ClientAssemblyIdentity;
    public static string UACAsInvoker;
    public static string UACUIAccess;
    public static int MaxFileAssociationsCount;
    public static int MaxFileAssociationExtensionLength;
    public static string ClientFrameworkSubset;
    private static Constants();
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ConvertUtil : object {
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, bool defaultValue);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("DeployManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest : Manifest {
    [XmlIgnoreAttribute]
public bool CreateDesktopShortcut { get; public set; }
    [XmlIgnoreAttribute]
public string TargetFrameworkMoniker { get; public set; }
    [XmlIgnoreAttribute]
public CompatibleFrameworkCollection CompatibleFrameworks { get; }
    [XmlIgnoreAttribute]
public string DeploymentUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool DisallowUrlActivation { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public string ErrorReportUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool Install { get; public set; }
    [XmlIgnoreAttribute]
public bool MapFileExtensions { get; public set; }
    [XmlIgnoreAttribute]
public string MinimumRequiredVersion { get; public set; }
    [XmlIgnoreAttribute]
public string Product { get; public set; }
    [XmlIgnoreAttribute]
public string Publisher { get; public set; }
    [XmlIgnoreAttribute]
public string SuiteName { get; public set; }
    [XmlIgnoreAttribute]
public string SupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool TrustUrlParameters { get; public set; }
    [XmlIgnoreAttribute]
public bool UpdateEnabled { get; public set; }
    [XmlIgnoreAttribute]
public int UpdateInterval { get; public set; }
    [XmlIgnoreAttribute]
public UpdateMode UpdateMode { get; public set; }
    [XmlIgnoreAttribute]
public UpdateUnit UpdateUnit { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("CreateDesktopShortcut")]
public string XmlCreateDesktopShortcut { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("CompatibleFrameworks")]
public CompatibleFramework[] XmlCompatibleFrameworks { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DeploymentUrl")]
public string XmlDeploymentUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DisallowUrlActivation")]
public string XmlDisallowUrlActivation { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ErrorReportUrl")]
public string XmlErrorReportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Install")]
public string XmlInstall { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("MapFileExtensions")]
public string XmlMapFileExtensions { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("MinimumRequiredVersion")]
public string XmlMinimumRequiredVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Product")]
public string XmlProduct { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Publisher")]
public string XmlPublisher { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SuiteName")]
public string XmlSuiteName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportUrl")]
public string XmlSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("TrustUrlParameters")]
public string XmlTrustUrlParameters { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateEnabled")]
public string XmlUpdateEnabled { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateInterval")]
public string XmlUpdateInterval { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateMode")]
public string XmlUpdateMode { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateUnit")]
public string XmlUpdateUnit { get; public set; }
    public DeployManifest(string targetFrameworkMoniker);
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    public CompatibleFrameworkCollection get_CompatibleFrameworks();
    public string get_DeploymentUrl();
    public void set_DeploymentUrl(string value);
    public bool get_DisallowUrlActivation();
    public void set_DisallowUrlActivation(bool value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public bool get_Install();
    public void set_Install(bool value);
    public bool get_MapFileExtensions();
    public void set_MapFileExtensions(bool value);
    public string get_MinimumRequiredVersion();
    public void set_MinimumRequiredVersion(string value);
    internal virtual void OnAfterLoad();
    internal virtual void OnBeforeSave();
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public bool get_TrustUrlParameters();
    public void set_TrustUrlParameters(bool value);
    public bool get_UpdateEnabled();
    public void set_UpdateEnabled(bool value);
    public int get_UpdateInterval();
    public void set_UpdateInterval(int value);
    public UpdateMode get_UpdateMode();
    public void set_UpdateMode(UpdateMode value);
    public UpdateUnit get_UpdateUnit();
    public void set_UpdateUnit(UpdateUnit value);
    public virtual void Validate();
    public string get_XmlCreateDesktopShortcut();
    public void set_XmlCreateDesktopShortcut(string value);
    public CompatibleFramework[] get_XmlCompatibleFrameworks();
    public void set_XmlCompatibleFrameworks(CompatibleFramework[] value);
    public string get_XmlDeploymentUrl();
    public void set_XmlDeploymentUrl(string value);
    public string get_XmlDisallowUrlActivation();
    public void set_XmlDisallowUrlActivation(string value);
    public string get_XmlErrorReportUrl();
    public void set_XmlErrorReportUrl(string value);
    public string get_XmlInstall();
    public void set_XmlInstall(string value);
    public string get_XmlMapFileExtensions();
    public void set_XmlMapFileExtensions(string value);
    public string get_XmlMinimumRequiredVersion();
    public void set_XmlMinimumRequiredVersion(string value);
    public string get_XmlProduct();
    public void set_XmlProduct(string value);
    public string get_XmlPublisher();
    public void set_XmlPublisher(string value);
    public string get_XmlSuiteName();
    public void set_XmlSuiteName(string value);
    public string get_XmlSupportUrl();
    public void set_XmlSupportUrl(string value);
    public string get_XmlTrustUrlParameters();
    public void set_XmlTrustUrlParameters(string value);
    public string get_XmlUpdateEnabled();
    public void set_XmlUpdateEnabled(string value);
    public string get_XmlUpdateInterval();
    public void set_XmlUpdateInterval(string value);
    public string get_XmlUpdateMode();
    public void set_XmlUpdateMode(string value);
    public string get_XmlUpdateUnit();
    public void set_XmlUpdateUnit(string value);
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.EmbeddedManifestReader : object {
    private static EmbeddedManifestReader();
    public static Stream Read(string path);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation : object {
    [XmlIgnoreAttribute]
public string DefaultIcon { get; public set; }
    [XmlIgnoreAttribute]
public string Description { get; public set; }
    [XmlIgnoreAttribute]
public string Extension { get; public set; }
    [XmlIgnoreAttribute]
public string ProgId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DefaultIcon")]
public string XmlDefaultIcon { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Extension")]
public string XmlExtension { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Progid")]
public string XmlProgId { get; public set; }
    public string get_DefaultIcon();
    public void set_DefaultIcon(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_Extension();
    public void set_Extension(string value);
    public string get_ProgId();
    public void set_ProgId(string value);
    public string get_XmlDefaultIcon();
    public void set_XmlDefaultIcon(string value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public string get_XmlExtension();
    public void set_XmlExtension(string value);
    public string get_XmlProgId();
    public void set_XmlProgId(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection : object {
    public FileAssociation Item { get; }
    public int Count { get; }
    internal FileAssociationCollection(FileAssociation[] fileAssociations);
    public FileAssociation get_Item(int index);
    public void Add(FileAssociation fileAssociation);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal FileAssociation[] ToArray();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference : BaseReference {
    [XmlIgnoreAttribute]
public ComClass[] ComClasses { get; }
    [XmlIgnoreAttribute]
public bool IsDataFile { get; public set; }
    [XmlIgnoreAttribute]
public ProxyStub[] ProxyStubs { get; }
    protected internal string SortName { get; }
    [XmlIgnoreAttribute]
public TypeLib[] TypeLibs { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ComClasses")]
public ComClass[] XmlComClasses { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ProxyStubs")]
public ProxyStub[] XmlProxyStubs { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("TypeLibs")]
public TypeLib[] XmlTypeLibs { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("WriteableType")]
public string XmlWriteableType { get; public set; }
    public FileReference(string path);
    public ComClass[] get_ComClasses();
    internal bool ImportComComponent(string path, OutputMessageCollection outputMessages, string outputDisplayName);
    public bool get_IsDataFile();
    public void set_IsDataFile(bool value);
    public ProxyStub[] get_ProxyStubs();
    protected internal virtual string get_SortName();
    public TypeLib[] get_TypeLibs();
    public ComClass[] get_XmlComClasses();
    public void set_XmlComClasses(ComClass[] value);
    public ProxyStub[] get_XmlProxyStubs();
    public void set_XmlProxyStubs(ProxyStub[] value);
    public TypeLib[] get_XmlTypeLibs();
    public void set_XmlTypeLibs(TypeLib[] value);
    public string get_XmlWriteableType();
    public void set_XmlWriteableType(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection : object {
    public FileReference Item { get; }
    public int Count { get; }
    internal FileReferenceCollection(FileReference[] array);
    public FileReference get_Item(int index);
    public FileReference Add(string path);
    public FileReference Add(FileReference file);
    public void Clear();
    public int get_Count();
    public FileReference FindTargetPath(string targetPath);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(FileReference file);
    internal FileReference[] ToArray();
}
[ComVisibleAttribute("False")]
public abstract class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest : object {
    [XmlIgnoreAttribute]
public AssemblyIdentity AssemblyIdentity { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReferenceCollection AssemblyReferences { get; }
    [XmlIgnoreAttribute]
public string Description { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public FileReferenceCollection FileReferences { get; }
    [XmlIgnoreAttribute]
public Stream InputStream { get; public set; }
    [XmlIgnoreAttribute]
public OutputMessageCollection OutputMessages { get; }
    [XmlIgnoreAttribute]
public bool ReadOnly { get; public set; }
    [XmlIgnoreAttribute]
public string SourcePath { get; public set; }
    internal bool TreatUnfoundNativeAssembliesAsPrerequisites { get; internal set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("AssemblyIdentity")]
public AssemblyIdentity XmlAssemblyIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("AssemblyReferences")]
public AssemblyReference[] XmlAssemblyReferences { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("FileReferences")]
public FileReference[] XmlFileReferences { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Schema")]
public string XmlSchema { get; public set; }
    public AssemblyIdentity get_AssemblyIdentity();
    public void set_AssemblyIdentity(AssemblyIdentity value);
    public AssemblyReferenceCollection get_AssemblyReferences();
    public string get_Description();
    public void set_Description(string value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public FileReferenceCollection get_FileReferences();
    public Stream get_InputStream();
    public void set_InputStream(Stream value);
    internal virtual void OnAfterLoad();
    internal virtual void OnBeforeSave();
    public OutputMessageCollection get_OutputMessages();
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public void ResolveFiles();
    public void ResolveFiles(String[] searchPaths);
    public string get_SourcePath();
    public void set_SourcePath(string value);
    public virtual string ToString();
    internal bool get_TreatUnfoundNativeAssembliesAsPrerequisites();
    internal void set_TreatUnfoundNativeAssembliesAsPrerequisites(bool value);
    internal static void UpdateEntryPoint(string inputPath, string outputPath, string updatedApplicationPath, string applicationManifestPath, string targetFrameworkVersion);
    public void UpdateFileInfo();
    public void UpdateFileInfo(string targetFrameworkVersion);
    public virtual void Validate();
    protected void ValidatePlatform();
    public AssemblyIdentity get_XmlAssemblyIdentity();
    public void set_XmlAssemblyIdentity(AssemblyIdentity value);
    public AssemblyReference[] get_XmlAssemblyReferences();
    public void set_XmlAssemblyReferences(AssemblyReference[] value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public FileReference[] get_XmlFileReferences();
    public void set_XmlFileReferences(FileReference[] value);
    public string get_XmlSchema();
    public void set_XmlSchema(string value);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestFormatter : object {
    public static Stream Format(Stream input);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader : object {
    internal static ComInfo[] GetComInfo(string path);
    public static Manifest ReadManifest(string path, bool preserveStream);
    public static Manifest ReadManifest(string manifestType, string path, bool preserveStream);
    public static Manifest ReadManifest(Stream input, bool preserveStream);
    public static Manifest ReadManifest(string manifestType, Stream input, bool preserveStream);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter : object {
    public static void WriteManifest(Manifest manifest);
    public static void WriteManifest(Manifest manifest, string path);
    public static void WriteManifest(Manifest manifest, string path, string targetframeWorkVersion);
    public static void WriteManifest(Manifest manifest, Stream output);
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.MetadataReader : object {
    public string Name { get; }
    public string Version { get; }
    public string PublicKeyToken { get; }
    public string Culture { get; }
    public string ProcessorArchitecture { get; }
    private static MetadataReader();
    public static MetadataReader Create(string path);
    public bool HasAssemblyAttribute(string name);
    public string get_Name();
    public string get_Version();
    public string get_PublicKeyToken();
    public string get_Culture();
    public string get_ProcessorArchitecture();
    public void Close();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.NativeMethods : object {
    public static UInt32 LOAD_LIBRARY_AS_DATAFILE;
    public static IntPtr RT_MANIFEST;
    private static NativeMethods();
    public static IntPtr LoadLibraryExW(string strFileName, IntPtr hFile, UInt32 ulFlags);
    public static bool FreeLibrary(IntPtr hModule);
    public static IntPtr FindResource(IntPtr hModule, IntPtr pName, IntPtr pType);
    public static IntPtr LoadResource(IntPtr hModule, IntPtr hResource);
    public static UInt32 SizeofResource(IntPtr hModule, IntPtr hResource);
    public static IntPtr LockResource(IntPtr hGlobal);
    public static int EnumResourceNames(IntPtr hModule, IntPtr pType, EnumResNameProc enumFunc, IntPtr param);
    public static void LoadTypeLibEx(string strTypeLibName, RegKind regKind, Object& typeLib);
    public static int SfcIsFileProtected(IntPtr RpcHandle, string ProtFileName);
    public static object GetAssemblyIdentityFromFile(string filePath, Guid& riid);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage : object {
    public string Name { get; }
    public string Text { get; }
    public OutputMessageType Type { get; }
    internal OutputMessage(OutputMessageType type, string name, string text, String[] arguments);
    public String[] GetArguments();
    public string get_Name();
    public string get_Text();
    public OutputMessageType get_Type();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection : object {
    public OutputMessage Item { get; }
    public int ErrorCount { get; }
    public int WarningCount { get; }
    public OutputMessage get_Item(int index);
    internal void AddErrorMessage(string taskResourceName, String[] arguments);
    internal void AddWarningMessage(string taskResourceName, String[] arguments);
    public void Clear();
    public int get_ErrorCount();
    public sealed virtual IEnumerator GetEnumerator();
    internal bool LogTaskMessages(Task task);
    public int get_WarningCount();
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType : Enum {
    public int value__;
    public static OutputMessageType Info;
    public static OutputMessageType Warning;
    public static OutputMessageType Error;
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.PathUtil : object {
    public static string CanonicalizePath(string path);
    public static string CanonicalizeUrl(string url);
    public static String[] GetPathSegments(string path);
    public static string Format(string path);
    public static bool IsAssembly(string path);
    public static bool IsDataFile(string path);
    public static bool IsEqualPath(string path1, string path2);
    public static bool IsLocalPath(string path);
    public static bool IsManagedAssembly(string path);
    public static bool IsNativeAssembly(string path);
    public static bool IsPEFile(string path);
    public static bool IsProgramFile(string path);
    public static bool IsUncPath(string path);
    public static bool IsUrl(string path);
    public static string Resolve(string path);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub : object {
    [XmlIgnoreAttribute]
public string BaseInterface { get; }
    [XmlIgnoreAttribute]
public string IID { get; }
    [XmlIgnoreAttribute]
public string Name { get; }
    [XmlIgnoreAttribute]
public string NumMethods { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("BaseInterface")]
public string XmlBaseInterface { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Iid")]
public string XmlIID { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("NumMethods")]
public string XmlNumMethods { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    public string get_BaseInterface();
    public string get_IID();
    public string get_Name();
    public string get_NumMethods();
    public string get_TlbId();
    public string get_XmlBaseInterface();
    public void set_XmlBaseInterface(string value);
    public string get_XmlIID();
    public void set_XmlIID(string value);
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlNumMethods();
    public void set_XmlNumMethods(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities : object {
    private static SecurityUtilities();
    public static PermissionSet ComputeZonePermissionSet(string targetZone, PermissionSet includedPermissionSet, String[] excludedPermissions);
    internal static PermissionSet ComputeZonePermissionSetHelper(string targetZone, PermissionSet includedPermissionSet, ITaskItem[] dependencies, string targetFrameworkMoniker);
    internal static bool ParseElementForAssemblyIdentification(SecurityElement el, String& className, String& assemblyName, String& assemblyVersion);
    public static PermissionSet IdentityListToPermissionSet(String[] ids);
    public static String[] PermissionSetToIdentityList(PermissionSet permissionSet);
    internal static XmlDocument PermissionSetToXml(PermissionSet ps);
    public static PermissionSet XmlToPermissionSet(XmlElement element);
    public static void SignFile(string certThumbprint, Uri timestampUrl, string path);
    public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path);
    public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path);
    internal static string GetCommandLineParameters(string certThumbprint, Uri timestampUrl, string path, bool useSha256);
    internal static string GetPathToTool();
    internal static X509Certificate2 GetCert(string thumbprint);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo : object {
    public bool HasUnmanagedCodePermission { get; }
    public bool IsFullTrust { get; public set; }
    public PermissionSet PermissionSet { get; public set; }
    public bool PreserveFullTrustPermissionSet { get; public set; }
    public string SameSiteAccess { get; public set; }
    public void Clear();
    public bool get_HasUnmanagedCodePermission();
    public bool get_IsFullTrust();
    public void set_IsFullTrust(bool value);
    public PermissionSet get_PermissionSet();
    public void set_PermissionSet(PermissionSet value);
    public bool get_PreserveFullTrustPermissionSet();
    public void set_PreserveFullTrustPermissionSet(bool value);
    public void Read(string path);
    public void Read(Stream input);
    public void ReadManifest(string path);
    public void ReadManifest(Stream input);
    public string get_SameSiteAccess();
    public void set_SameSiteAccess(string value);
    public virtual string ToString();
    public void Write(string path);
    public void Write(Stream output);
    public void WriteManifest(string path);
    public void WriteManifest(Stream output);
    public void WriteManifest(Stream input, Stream output);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib : object {
    [XmlIgnoreAttribute]
public string Flags { get; }
    [XmlIgnoreAttribute]
public string HelpDirectory { get; }
    [XmlIgnoreAttribute]
public string ResourceId { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [XmlIgnoreAttribute]
public string Version { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Flags")]
public string XmlFlags { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HelpDir")]
public string XmlHelpDirectory { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ResourceId")]
public string XmlResourceId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    internal TypeLib(Guid tlbId, Version version, string helpDirectory, int resourceId, int flags);
    public string get_Flags();
    public string get_HelpDirectory();
    public string get_ResourceId();
    public string get_TlbId();
    public string get_Version();
    public string get_XmlFlags();
    public void set_XmlFlags(string value);
    public string get_XmlHelpDirectory();
    public void set_XmlHelpDirectory(string value);
    public string get_XmlResourceId();
    public void set_XmlResourceId(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode : Enum {
    public int value__;
    public static UpdateMode Background;
    public static UpdateMode Foreground;
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit : Enum {
    public int value__;
    public static UpdateUnit Hours;
    public static UpdateUnit Days;
    public static UpdateUnit Weeks;
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Util : object {
    internal static string Schema;
    internal static bool logging;
    internal static string logPath;
    private static Util();
    public static string ByteArrayToHex(Byte[] a);
    public static string ByteArrayToString(Byte[] a);
    public static int CopyStream(Stream input, Stream output);
    public static string FilterNonprintableChars(string value);
    public static string GetAssemblyPath();
    public static string GetClrVersion();
    public static string GetClrVersion(string targetFrameworkVersion);
    public static string GetEmbeddedResourceString(string name);
    public static Stream GetEmbeddedResourceStream(string name);
    public static void GetFileInfo(string path, String& hash, Int64& length);
    public static void GetFileInfo(string path, string targetFrameworkVersion, String& hash, Int64& length);
    public static string GetRegisteredOrganization();
    public static bool IsValidAssemblyName(string value);
    public static bool IsValidCulture(string value);
    public static bool IsValidFileName(string value);
    public static bool IsValidVersion(string value, int octets);
    internal static bool IsValidFrameworkVersion(string value);
    public static string PlatformToProcessorArchitecture(string platform);
    public static ITaskItem[] SortItems(ITaskItem[] items);
    public static void WriteFile(string path, string s);
    public static void WriteFile(string path, Stream s);
    public static void WriteLog(string text);
    public static void WriteLogFile(string filename, Stream s);
    public static void WriteLogFile(string filename, string s);
    public static void WriteLogFile(string filename, XmlElement element);
    public static string WriteTempFile(Stream s);
    public static string WriteTempFile(string s);
    public static Version ConvertFrameworkVersionToString(string version);
    public static int CompareFrameworkVersions(string versionA, string versionB);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass : object {
    [XmlIgnoreAttribute]
public string Name { get; }
    [XmlIgnoreAttribute]
public bool Versioned { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Versioned")]
public string XmlVersioned { get; public set; }
    public WindowClass(string name, bool versioned);
    public string get_Name();
    public bool get_Versioned();
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlVersioned();
    public void set_XmlVersioned(string value);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XmlNamespaces : object {
    public static string asmv1;
    public static string asmv2;
    public static string asmv3;
    public static string dsig;
    public static string xrml;
    public static string xsi;
    public static XmlNamespaceManager GetNamespaceManager(XmlNameTable nameTable);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XmlUtil : object {
    private static XmlUtil();
    public static string GetQName(XmlTextReader r, XmlNamespaceManager nsmgr);
    public static XmlElement CloneElementToDocument(XmlElement element, XmlDocument document, string namespaceURI);
    public static string TrimPrefix(string s);
    public static Stream XslTransform(string resource, Stream input, DictionaryEntry[] entries);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XPaths : object {
    public static string applicationRequestMinimumElement;
    public static string assemblyElement;
    public static string assemblyIdentityPath;
    public static string clsidAttribute;
    public static string comFilesPath;
    public static string configBindingRedirect;
    public static string defaultAssemblyRequestElement;
    public static string dependencyPublicKeyTokenAttribute;
    public static string fileNameAttribute;
    public static string fileSizeAttribute;
    public static string hashElement;
    public static string idAttribute;
    public static string languageAttribute1;
    public static string languageAttribute2;
    public static string manifestTrustInfoPath;
    public static string permissionIdentityQuery;
    public static string permissionClassAttributeQuery;
    public static string permissionSetElement;
    public static string permissionSetReferenceAttribute;
    public static string publicKeyTokenAttribute;
    public static string requestedExecutionLevelPath;
    public static string requestedPrivilegeElement;
    public static string requestedExecutionLevelElement;
    public static string sameSiteAttribute;
    public static string securityElement;
    public static string signaturePath;
    public static string tlbidAttribute;
    public static string trustInfoElement;
    public static string trustInfoPath;
    public static string unrestrictedAttribute;
    public static String[] codebasePaths;
    public static String[] emptyAttributeList;
    private static XPaths();
}
internal class Microsoft.Build.Tasks.DirectoryResolver : Resolver {
    public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal abstract class Microsoft.Build.Tasks.DisposableBase : object {
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void DisposeManagedResources();
    protected virtual void DisposeUnmanagedResources();
}
public class Microsoft.Build.Tasks.Error : TaskExtension {
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    public string get_Code();
    public void set_Code(string value);
    public string get_File();
    public void set_File(string value);
    public string get_HelpKeyword();
    public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Exec : ToolTaskExtension {
    internal bool workingDirectoryIsUNC;
    [RequiredAttribute]
public string Command { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool IgnoreExitCode { get; public set; }
    public bool ConsoleToMSBuild { get; public set; }
    public string CustomErrorRegularExpression { get; public set; }
    public string CustomWarningRegularExpression { get; public set; }
    public bool IgnoreStandardErrorWarningFormat { get; public set; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    [OutputAttribute]
public string StdOutEncoding { get; public set; }
    [OutputAttribute]
public string StdErrEncoding { get; public set; }
    [OutputAttribute]
public ITaskItem[] Outputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] ConsoleOutput { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public string get_Command();
    public void set_Command(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_IgnoreExitCode();
    public void set_IgnoreExitCode(bool value);
    public bool get_ConsoleToMSBuild();
    public void set_ConsoleToMSBuild(bool value);
    public string get_CustomErrorRegularExpression();
    public void set_CustomErrorRegularExpression(string value);
    public string get_CustomWarningRegularExpression();
    public void set_CustomWarningRegularExpression(string value);
    public bool get_IgnoreStandardErrorWarningFormat();
    public void set_IgnoreStandardErrorWarningFormat(bool value);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    public string get_StdOutEncoding();
    public void set_StdOutEncoding(string value);
    public string get_StdErrEncoding();
    public void set_StdErrEncoding(string value);
    public ITaskItem[] get_Outputs();
    public void set_Outputs(ITaskItem[] value);
    public ITaskItem[] get_ConsoleOutput();
    public void set_ConsoleOutput(ITaskItem[] value);
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    protected virtual void LogToolCommand(string message);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    protected virtual bool ValidateParameters();
    internal bool ValidateParametersAccessor();
    protected virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    internal string GetWorkingDirectoryAccessor();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
}
public class Microsoft.Build.Tasks.ExtractedClassName : ValueType {
    private bool isInsideConditionalBlock;
    private string name;
    public bool IsInsideConditionalBlock { get; public set; }
    public string Name { get; public set; }
    public bool get_IsInsideConditionalBlock();
    public void set_IsInsideConditionalBlock(bool value);
    public string get_Name();
    public void set_Name(string value);
}
internal class Microsoft.Build.Tasks.FileState : object {
    internal bool IsReadOnly { get; }
    internal bool FileExists { get; }
    internal bool DirectoryExists { get; }
    internal DateTime LastWriteTime { get; }
    internal DateTime LastWriteTimeUtcFast { get; }
    internal long Length { get; }
    internal string Name { get; }
    internal bool IsDirectory { get; }
    internal FileState(string filename);
    internal bool get_IsReadOnly();
    internal bool get_FileExists();
    internal bool get_DirectoryExists();
    internal DateTime get_LastWriteTime();
    internal DateTime get_LastWriteTimeUtcFast();
    internal long get_Length();
    internal string get_Name();
    internal bool get_IsDirectory();
    internal void Reset();
}
public class Microsoft.Build.Tasks.FindAppConfigFile : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] PrimaryList { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SecondaryList { get; public set; }
    [RequiredAttribute]
public string TargetPath { get; public set; }
    [OutputAttribute]
public ITaskItem AppConfigFile { get; public set; }
    public ITaskItem[] get_PrimaryList();
    public void set_PrimaryList(ITaskItem[] value);
    public ITaskItem[] get_SecondaryList();
    public void set_SecondaryList(ITaskItem[] value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public ITaskItem get_AppConfigFile();
    public void set_AppConfigFile(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FindInList : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] List { get; public set; }
    public bool MatchFileNameOnly { get; public set; }
    [OutputAttribute]
public ITaskItem ItemFound { get; public set; }
    [RequiredAttribute]
public string ItemSpecToFind { get; public set; }
    public bool CaseSensitive { get; public set; }
    public bool FindLastMatch { get; public set; }
    public ITaskItem[] get_List();
    public void set_List(ITaskItem[] value);
    public bool get_MatchFileNameOnly();
    public void set_MatchFileNameOnly(bool value);
    public ITaskItem get_ItemFound();
    public void set_ItemFound(ITaskItem value);
    public string get_ItemSpecToFind();
    public void set_ItemSpecToFind(string value);
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public bool get_FindLastMatch();
    public void set_FindLastMatch(bool value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FindUnderPath : TaskExtension {
    [RequiredAttribute]
public ITaskItem Path { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool UpdateToAbsolutePaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] InPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutOfPath { get; public set; }
    public ITaskItem get_Path();
    public void set_Path(ITaskItem value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public bool get_UpdateToAbsolutePaths();
    public void set_UpdateToAbsolutePaths(bool value);
    public ITaskItem[] get_InPath();
    public void set_InPath(ITaskItem[] value);
    public ITaskItem[] get_OutOfPath();
    public void set_OutOfPath(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FormatUrl : TaskExtension {
    public string InputUrl { get; public set; }
    [OutputAttribute]
public string OutputUrl { get; public set; }
    public string get_InputUrl();
    public void set_InputUrl(string value);
    public string get_OutputUrl();
    public void set_OutputUrl(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FormatVersion : TaskExtension {
    [OutputAttribute]
public string OutputVersion { get; public set; }
    public string FormatType { get; public set; }
    public int Revision { get; public set; }
    public string Version { get; public set; }
    public string get_OutputVersion();
    public void set_OutputVersion(string value);
    public string get_FormatType();
    public void set_FormatType(string value);
    public int get_Revision();
    public void set_Revision(int value);
    public string get_Version();
    public void set_Version(string value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.FrameworkPathResolver : Resolver {
    public FrameworkPathResolver(String[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssemblies installedAssemblies, AssemblyNameExtension assemblyName);
}
internal class Microsoft.Build.Tasks.GacResolver : Resolver {
    public GacResolver(ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, IBuildEngine buildEngine);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
public class Microsoft.Build.Tasks.GenerateApplicationManifest : GenerateManifestBase {
    public string ClrVersion { get; public set; }
    public ITaskItem ConfigFile { get; public set; }
    public ITaskItem[] Dependencies { get; public set; }
    public string ErrorReportUrl { get; public set; }
    public ITaskItem[] FileAssociations { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool HostInBrowser { get; public set; }
    public ITaskItem IconFile { get; public set; }
    public ITaskItem[] IsolatedComReferences { get; public set; }
    public string ManifestType { get; public set; }
    public string OSVersion { get; public set; }
    public string Product { get; public set; }
    public string Publisher { get; public set; }
    public bool RequiresMinimumFramework35SP1 { get; public set; }
    public string SuiteName { get; public set; }
    public string SupportUrl { get; public set; }
    public string TargetFrameworkSubset { get; public set; }
    public string TargetFrameworkProfile { get; public set; }
    public ITaskItem TrustInfoFile { get; public set; }
    public bool UseApplicationTrust { get; public set; }
    public string get_ClrVersion();
    public void set_ClrVersion(string value);
    public ITaskItem get_ConfigFile();
    public void set_ConfigFile(ITaskItem value);
    public ITaskItem[] get_Dependencies();
    public void set_Dependencies(ITaskItem[] value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public ITaskItem[] get_FileAssociations();
    public void set_FileAssociations(ITaskItem[] value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public bool get_HostInBrowser();
    public void set_HostInBrowser(bool value);
    public ITaskItem get_IconFile();
    public void set_IconFile(ITaskItem value);
    public ITaskItem[] get_IsolatedComReferences();
    public void set_IsolatedComReferences(ITaskItem[] value);
    public string get_ManifestType();
    public void set_ManifestType(string value);
    public string get_OSVersion();
    public void set_OSVersion(string value);
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public bool get_RequiresMinimumFramework35SP1();
    public void set_RequiresMinimumFramework35SP1(bool value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public string get_TargetFrameworkSubset();
    public void set_TargetFrameworkSubset(string value);
    public string get_TargetFrameworkProfile();
    public void set_TargetFrameworkProfile(string value);
    public ITaskItem get_TrustInfoFile();
    public void set_TrustInfoFile(ITaskItem value);
    public bool get_UseApplicationTrust();
    public void set_UseApplicationTrust(bool value);
    protected virtual Type GetObjectType();
    protected virtual bool OnManifestLoaded(Manifest manifest);
    protected virtual bool OnManifestResolved(Manifest manifest);
    protected internal virtual bool ValidateInputs();
}
public class Microsoft.Build.Tasks.GenerateBootstrapper : TaskExtension {
    public string ApplicationName { get; public set; }
    public string ApplicationFile { get; public set; }
    public bool ApplicationRequiresElevation { get; public set; }
    public string ApplicationUrl { get; public set; }
    public ITaskItem[] BootstrapperItems { get; public set; }
    public string ComponentsLocation { get; public set; }
    public string ComponentsUrl { get; public set; }
    public bool CopyComponents { get; public set; }
    public string Culture { get; public set; }
    public string FallbackCulture { get; public set; }
    public string OutputPath { get; public set; }
    public string Path { get; public set; }
    public string SupportUrl { get; public set; }
    public string VisualStudioVersion { get; public set; }
    public bool Validate { get; public set; }
    [OutputAttribute]
public string BootstrapperKeyFile { get; public set; }
    [OutputAttribute]
public String[] BootstrapperComponentFiles { get; public set; }
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_ApplicationFile();
    public void set_ApplicationFile(string value);
    public bool get_ApplicationRequiresElevation();
    public void set_ApplicationRequiresElevation(bool value);
    public string get_ApplicationUrl();
    public void set_ApplicationUrl(string value);
    public ITaskItem[] get_BootstrapperItems();
    public void set_BootstrapperItems(ITaskItem[] value);
    public string get_ComponentsLocation();
    public void set_ComponentsLocation(string value);
    public string get_ComponentsUrl();
    public void set_ComponentsUrl(string value);
    public bool get_CopyComponents();
    public void set_CopyComponents(bool value);
    public string get_Culture();
    public void set_Culture(string value);
    public string get_FallbackCulture();
    public void set_FallbackCulture(string value);
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public string get_VisualStudioVersion();
    public void set_VisualStudioVersion(string value);
    public bool get_Validate();
    public void set_Validate(bool value);
    public string get_BootstrapperKeyFile();
    public void set_BootstrapperKeyFile(string value);
    public String[] get_BootstrapperComponentFiles();
    public void set_BootstrapperComponentFiles(String[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GenerateDeploymentManifest : GenerateManifestBase {
    public bool CreateDesktopShortcut { get; public set; }
    public string DeploymentUrl { get; public set; }
    public bool DisallowUrlActivation { get; public set; }
    public string ErrorReportUrl { get; public set; }
    public bool Install { get; public set; }
    public string MinimumRequiredVersion { get; public set; }
    public bool MapFileExtensions { get; public set; }
    public string Product { get; public set; }
    public string Publisher { get; public set; }
    public string SuiteName { get; public set; }
    public string SupportUrl { get; public set; }
    public bool TrustUrlParameters { get; public set; }
    public bool UpdateEnabled { get; public set; }
    public int UpdateInterval { get; public set; }
    public string UpdateMode { get; public set; }
    public string UpdateUnit { get; public set; }
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    public string get_DeploymentUrl();
    public void set_DeploymentUrl(string value);
    public bool get_DisallowUrlActivation();
    public void set_DisallowUrlActivation(bool value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public bool get_Install();
    public void set_Install(bool value);
    public string get_MinimumRequiredVersion();
    public void set_MinimumRequiredVersion(string value);
    public bool get_MapFileExtensions();
    public void set_MapFileExtensions(bool value);
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public bool get_TrustUrlParameters();
    public void set_TrustUrlParameters(bool value);
    public bool get_UpdateEnabled();
    public void set_UpdateEnabled(bool value);
    public int get_UpdateInterval();
    public void set_UpdateInterval(int value);
    public string get_UpdateMode();
    public void set_UpdateMode(string value);
    public string get_UpdateUnit();
    public void set_UpdateUnit(string value);
    protected virtual Type GetObjectType();
    protected virtual bool OnManifestLoaded(Manifest manifest);
    protected virtual bool OnManifestResolved(Manifest manifest);
    protected internal virtual bool ValidateInputs();
}
public abstract class Microsoft.Build.Tasks.GenerateManifestBase : Task {
    public string AssemblyName { get; public set; }
    public string AssemblyVersion { get; public set; }
    public string Description { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem InputManifest { get; public set; }
    public int MaxTargetPath { get; public set; }
    [OutputAttribute]
public ITaskItem OutputManifest { get; public set; }
    public string Platform { get; public set; }
    public string TargetCulture { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    protected abstract virtual bool OnManifestLoaded(Manifest manifest);
    protected abstract virtual bool OnManifestResolved(Manifest manifest);
    protected abstract virtual Type GetObjectType();
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_AssemblyVersion();
    public void set_AssemblyVersion(string value);
    public string get_Description();
    public void set_Description(string value);
    public ITaskItem get_EntryPoint();
    public void set_EntryPoint(ITaskItem value);
    public ITaskItem get_InputManifest();
    public void set_InputManifest(ITaskItem value);
    public int get_MaxTargetPath();
    public void set_MaxTargetPath(int value);
    public ITaskItem get_OutputManifest();
    public void set_OutputManifest(ITaskItem value);
    public string get_Platform();
    public void set_Platform(string value);
    public string get_TargetCulture();
    public void set_TargetCulture(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    protected internal AssemblyReference AddAssemblyNameFromItem(ITaskItem item, AssemblyReferenceType referenceType);
    protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item);
    protected internal AssemblyReference AddEntryPointFromItem(ITaskItem item, AssemblyReferenceType referenceType);
    protected internal FileReference AddFileFromItem(ITaskItem item);
    public virtual bool Execute();
    protected internal FileReference FindFileFromItem(ITaskItem item);
    protected internal virtual bool ValidateInputs();
    protected internal virtual bool ValidateOutput();
}
[RequiredRuntimeAttribute("v2.0")]
public class Microsoft.Build.Tasks.GenerateResource : TaskExtension {
    [RequiredAttribute]
[OutputAttribute]
public ITaskItem[] Sources { get; public set; }
    public bool UseSourcePath { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] AdditionalInputs { get; public set; }
    public ITaskItem StateFile { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputResources { get; public set; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; }
    public string StronglyTypedLanguage { get; public set; }
    public string StronglyTypedNamespace { get; public set; }
    public string StronglyTypedManifestPrefix { get; public set; }
    [OutputAttribute]
public string StronglyTypedClassName { get; public set; }
    [OutputAttribute]
public string StronglyTypedFileName { get; public set; }
    public bool PublicClass { get; public set; }
    public bool ExtractResWFiles { get; public set; }
    public bool NeverLockTypeAssemblies { get; public set; }
    public string SdkToolsPath { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public ITaskItem[] ExcludedInputPaths { get; public set; }
    public bool MinimalRebuildFromTracking { get; public set; }
    public bool TrackFileAccess { get; public set; }
    public ITaskItem[] TLogReadFiles { get; }
    public ITaskItem[] TLogWriteFiles { get; }
    public string TrackerLogDirectory { get; public set; }
    public string ToolArchitecture { get; public set; }
    public string TrackerFrameworkPath { get; public set; }
    public string TrackerSdkPath { get; public set; }
    public string OutputDirectory { get; public set; }
    private static GenerateResource();
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_UseSourcePath(bool value);
    public bool get_UseSourcePath();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    public void set_AdditionalInputs(ITaskItem[] value);
    public ITaskItem[] get_AdditionalInputs();
    public void set_StateFile(ITaskItem value);
    public ITaskItem get_StateFile();
    public void set_OutputResources(ITaskItem[] value);
    public ITaskItem[] get_OutputResources();
    public ITaskItem[] get_FilesWritten();
    public void set_StronglyTypedLanguage(string value);
    public string get_StronglyTypedLanguage();
    public void set_StronglyTypedNamespace(string value);
    public string get_StronglyTypedNamespace();
    public void set_StronglyTypedManifestPrefix(string value);
    public string get_StronglyTypedManifestPrefix();
    public void set_StronglyTypedClassName(string value);
    public string get_StronglyTypedClassName();
    public void set_StronglyTypedFileName(string value);
    public string get_StronglyTypedFileName();
    public void set_PublicClass(bool value);
    public bool get_PublicClass();
    [CompilerGeneratedAttribute]
public bool get_ExtractResWFiles();
    [CompilerGeneratedAttribute]
public void set_ExtractResWFiles(bool value);
    public void set_NeverLockTypeAssemblies(bool value);
    public bool get_NeverLockTypeAssemblies();
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public void set_ExecuteAsTool(bool value);
    public bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    public ITaskItem[] get_ExcludedInputPaths();
    public void set_ExcludedInputPaths(ITaskItem[] value);
    public bool get_MinimalRebuildFromTracking();
    public void set_MinimalRebuildFromTracking(bool value);
    public bool get_TrackFileAccess();
    public void set_TrackFileAccess(bool value);
    public ITaskItem[] get_TLogReadFiles();
    public ITaskItem[] get_TLogWriteFiles();
    public string get_TrackerLogDirectory();
    public void set_TrackerLogDirectory(string value);
    public string get_ToolArchitecture();
    public void set_ToolArchitecture(string value);
    public string get_TrackerFrameworkPath();
    public void set_TrackerFrameworkPath(string value);
    public string get_TrackerSdkPath();
    public void set_TrackerSdkPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GenerateTrustInfo : TaskExtension {
    public ITaskItem BaseManifest { get; public set; }
    public string ExcludedPermissions { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetZone { get; public set; }
    public ITaskItem[] ApplicationDependencies { get; public set; }
    [OutputAttribute]
[RequiredAttribute]
public ITaskItem TrustInfoFile { get; public set; }
    public ITaskItem get_BaseManifest();
    public void set_BaseManifest(ITaskItem value);
    public string get_ExcludedPermissions();
    public void set_ExcludedPermissions(string value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    public string get_TargetZone();
    public void set_TargetZone(string value);
    public ITaskItem[] get_ApplicationDependencies();
    public void set_ApplicationDependencies(ITaskItem[] value);
    public ITaskItem get_TrustInfoFile();
    public void set_TrustInfoFile(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GetAssemblyIdentity : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] AssemblyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetAssemblyMetadata : MulticastDelegate {
    public GetAssemblyMetadata(object object, IntPtr method);
    public virtual void Invoke(string path, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute);
    public virtual IAsyncResult BeginInvoke(string path, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, AsyncCallback callback, object object);
    public virtual void EndInvoke(AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyName : MulticastDelegate {
    public GetAssemblyName(object object, IntPtr method);
    public virtual AssemblyNameExtension Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual AssemblyNameExtension EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyRuntimeVersion : MulticastDelegate {
    public GetAssemblyRuntimeVersion(object object, IntPtr method);
    public virtual string Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAttributes : MulticastDelegate {
    public GetAttributes(object object, IntPtr method);
    public virtual FileAttributes Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileAttributes EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetFrameworkPath : TaskExtension {
    [OutputAttribute]
public string Path { get; public set; }
    [OutputAttribute]
public string FrameworkVersion11Path { get; }
    [OutputAttribute]
public string FrameworkVersion20Path { get; }
    [OutputAttribute]
public string FrameworkVersion30Path { get; }
    [OutputAttribute]
public string FrameworkVersion35Path { get; }
    [OutputAttribute]
public string FrameworkVersion40Path { get; }
    [OutputAttribute]
public string FrameworkVersion45Path { get; }
    public string get_Path();
    public void set_Path(string value);
    public string get_FrameworkVersion11Path();
    public string get_FrameworkVersion20Path();
    public string get_FrameworkVersion30Path();
    public string get_FrameworkVersion35Path();
    public string get_FrameworkVersion40Path();
    public string get_FrameworkVersion45Path();
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GetFrameworkSdkPath : TaskExtension {
    [OutputAttribute]
public string Path { get; public set; }
    [OutputAttribute]
public string FrameworkSdkVersion20Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion35Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion40Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion45Path { get; }
    public string get_Path();
    public void set_Path(string value);
    public string get_FrameworkSdkVersion20Path();
    public string get_FrameworkSdkVersion35Path();
    public string get_FrameworkSdkVersion40Path();
    public string get_FrameworkSdkVersion45Path();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetGacEnumerator : MulticastDelegate {
    public GetGacEnumerator(object object, IntPtr method);
    public virtual IEnumerable`1<AssemblyNameExtension> Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual IEnumerable`1<AssemblyNameExtension> EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetInstalledSDKLocations : TaskExtension {
    [RequiredAttribute]
public string TargetPlatformVersion { get; public set; }
    [RequiredAttribute]
public string TargetPlatformIdentifier { get; public set; }
    public string SDKRegistryRoot { get; public set; }
    public String[] SDKDirectoryRoots { get; public set; }
    [OutputAttribute]
public ITaskItem[] InstalledSDKs { get; public set; }
    public string get_TargetPlatformVersion();
    public void set_TargetPlatformVersion(string value);
    public string get_TargetPlatformIdentifier();
    public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_SDKRegistryRoot();
    [CompilerGeneratedAttribute]
public void set_SDKRegistryRoot(string value);
    [CompilerGeneratedAttribute]
public String[] get_SDKDirectoryRoots();
    [CompilerGeneratedAttribute]
public void set_SDKDirectoryRoots(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InstalledSDKs();
    [CompilerGeneratedAttribute]
public void set_InstalledSDKs(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetLastWriteTime : MulticastDelegate {
    public GetLastWriteTime(object object, IntPtr method);
    public virtual DateTime Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetPathFromFusionName : MulticastDelegate {
    public GetPathFromFusionName(object object, IntPtr method);
    public virtual string Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetReferenceAssemblyPaths : TaskExtension {
    [OutputAttribute]
public String[] ReferenceAssemblyPaths { get; }
    [OutputAttribute]
public String[] FullFrameworkReferenceAssemblyPaths { get; }
    public string TargetFrameworkMoniker { get; public set; }
    public string RootPath { get; public set; }
    public bool BypassFrameworkInstallChecks { get; public set; }
    [OutputAttribute]
public string TargetFrameworkMonikerDisplayName { get; public set; }
    private static GetReferenceAssemblyPaths();
    public String[] get_ReferenceAssemblyPaths();
    public String[] get_FullFrameworkReferenceAssemblyPaths();
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    public string get_RootPath();
    public void set_RootPath(string value);
    public bool get_BypassFrameworkInstallChecks();
    public void set_BypassFrameworkInstallChecks(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GetSDKReferenceFiles : TaskExtension {
    public string CacheFileFolderPath { get; public set; }
    public ITaskItem[] ResolvedSDKReferences { get; public set; }
    public String[] ReferenceExtensions { get; public set; }
    public bool LogReferencesList { get; public set; }
    public bool LogRedistFilesList { get; public set; }
    [OutputAttribute]
public ITaskItem[] References { get; }
    [OutputAttribute]
public ITaskItem[] RedistFiles { get; }
    [OutputAttribute]
public ITaskItem[] CopyLocalFiles { get; }
    public bool LogRedistConflictWithinSDKAsWarning { get; public set; }
    public bool LogRedistConflictBetweenSDKsAsWarning { get; public set; }
    public bool LogReferenceConflictWithinSDKAsWarning { get; public set; }
    public bool LogReferenceConflictBetweenSDKsAsWarning { get; public set; }
    public bool LogCacheFileExceptions { get; public set; }
    public string get_CacheFileFolderPath();
    public void set_CacheFileFolderPath(string value);
    public ITaskItem[] get_ResolvedSDKReferences();
    public void set_ResolvedSDKReferences(ITaskItem[] value);
    public String[] get_ReferenceExtensions();
    public void set_ReferenceExtensions(String[] value);
    [CompilerGeneratedAttribute]
public bool get_LogReferencesList();
    [CompilerGeneratedAttribute]
public void set_LogReferencesList(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogRedistFilesList();
    [CompilerGeneratedAttribute]
public void set_LogRedistFilesList(bool value);
    public ITaskItem[] get_References();
    public ITaskItem[] get_RedistFiles();
    public ITaskItem[] get_CopyLocalFiles();
    [CompilerGeneratedAttribute]
public bool get_LogRedistConflictWithinSDKAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogRedistConflictWithinSDKAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogRedistConflictBetweenSDKsAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogRedistConflictBetweenSDKsAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogReferenceConflictWithinSDKAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogReferenceConflictWithinSDKAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogReferenceConflictBetweenSDKsAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogReferenceConflictBetweenSDKsAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogCacheFileExceptions();
    [CompilerGeneratedAttribute]
public void set_LogCacheFileExceptions(bool value);
    public virtual bool Execute();
    internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion getRuntimeVersion, FileExists fileExists);
}
internal static class Microsoft.Build.Tasks.GlobalAssemblyCache : object {
    internal static GetPathFromFusionName pathFromFusionName;
    internal static GetGacEnumerator gacEnumerator;
    private static GlobalAssemblyCache();
    internal static IEnumerable`1<AssemblyNameExtension> GetGacNativeEnumerator(string strongName);
    internal static string RetreivePathFromFusionName(string strongName);
    internal static string GetLocation(AssemblyNameExtension strongName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, bool fullFusionName, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    internal static string GetLocation(IBuildEngine4 buildEngine, AssemblyNameExtension strongName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, bool fullFusionName, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    internal static string GetGacPath();
}
internal class Microsoft.Build.Tasks.HintPathResolver : Resolver {
    public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject {
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual void BeginInitialization();
    public abstract virtual bool EndInitialization(String& errorMessage, Int32& errorCode);
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetAllowUnsafeBlocks(bool allowUnsafeBlocks);
    public abstract virtual bool SetBaseAddress(string baseAddress);
    public abstract virtual bool SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySignExplicitlySet, bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetEmitDebugInformation(bool emitDebugInformation);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateFullPaths(bool generateFullPaths);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLangVersion(string langVersion);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string targetType, string mainEntryPoint);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetPdbFile(string pdbFile);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningLevel(int warningLevel);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject2 {
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject3 {
    public abstract virtual bool SetApplicationConfiguration(string applicationConfiguration);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject4 {
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject {
    public abstract virtual void BeginInitialization();
    public abstract virtual void EndInitialization();
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetBaseAddress(string targetType, string baseAddress);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(bool emitDebugInformation, string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateDocumentation(bool generateDocumentation);
    public abstract virtual bool SetImports(ITaskItem[] importsList);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string mainEntryPoint);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetNoWarnings(bool noWarnings);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOptionCompare(string optionCompare);
    public abstract virtual bool SetOptionExplicit(bool optionExplicit);
    public abstract virtual bool SetOptionStrict(bool optionStrict);
    public abstract virtual bool SetOptionStrictType(string optionStrictType);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetRemoveIntegerChecks(bool removeIntegerChecks);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetRootNamespace(string rootNamespace);
    public abstract virtual bool SetSdkPath(string sdkPath);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetCompactFramework(bool targetCompactFramework);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject2 {
    public abstract virtual bool SetOptionInfer(bool optionInfer);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject3 {
    public abstract virtual bool SetLanguageVersion(string languageVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject4 {
    public abstract virtual bool SetVBRuntime(string VBRuntime);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject5 {
    public abstract virtual IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
    public abstract virtual int CompileAsync(IntPtr& buildSucceededEvent, IntPtr& buildFailedEvent);
    public abstract virtual int EndCompile(bool buildSuccess);
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded {
    public abstract virtual bool Compile();
}
[GuidAttribute("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IAssemblyCache {
    public abstract virtual int UninstallAssembly();
    public abstract virtual UInt32 QueryAssemblyInfo(UInt32 dwFlags, string pszAssemblyName, ASSEMBLY_INFO& pAsmInfo);
    public abstract virtual int CreateAssemblyCacheItem();
    public abstract virtual int CreateAssemblyScavenger();
    public abstract virtual int InstallAssembly();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("21b8916c-f28e-11d2-a473-00c04f8ef448")]
internal interface Microsoft.Build.Tasks.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IntPtr pvReserved, IAssemblyName& ppName, int flags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
internal interface Microsoft.Build.Tasks.IAssemblyName {
    public abstract virtual int SetProperty(int PropertyId, IntPtr pvProperty, int cbProperty);
    public abstract virtual int GetProperty(int PropertyId, IntPtr pvProperty, Int32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(StringBuilder pDisplayName, Int32& pccDisplayName, int displayFlags);
    public abstract virtual int Reserved(Guid& guid, object obj1, object obj2, string string1, long llFlags, IntPtr pvReserved, int cbReserved, IntPtr& ppv);
    public abstract virtual int GetName(Int32& pccBuffer, StringBuilder pwzName);
    public abstract virtual int GetVersion(Int32& versionHi, Int32& versionLow);
    public abstract virtual int IsEqual(IAssemblyName pAsmName, int cmpFlags);
    public abstract virtual int Clone(IAssemblyName& pAsmName);
}
[GuidAttribute("00000001-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IClassFactory {
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObject);
    public abstract virtual void LockServer(bool fLock);
}
internal interface Microsoft.Build.Tasks.IComReferenceResolver {
    public abstract virtual bool ResolveComClassicReference(TYPELIBATTR typeLibAttr, string outputDirectory, string wrapperType, string refName, ComReferenceWrapperInfo& wrapperInfo);
    public abstract virtual bool ResolveNetAssemblyReference(string assemblyName, String& assemblyPath);
    public abstract virtual bool ResolveComAssemblyReference(string assemblyName, String& assemblyPath);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.Build.Tasks.IFixedTypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, IntPtr& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(IntPtr hRef, IFixedTypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataAssemblyImport {
    public abstract virtual void GetAssemblyProps(UInt32 mdAsm, IntPtr& pPublicKeyPtr, UInt32& ucbPublicKeyPtr, UInt32& uHashAlg, Char[] strName, UInt32 cchNameIn, UInt32& cchNameRequired, IntPtr amdInfo, UInt32& dwFlags);
    public abstract virtual void GetAssemblyRefProps(UInt32 mdAsmRef, IntPtr& ppbPublicKeyOrToken, UInt32& pcbPublicKeyOrToken, Char[] strName, UInt32 cchNameIn, UInt32& pchNameOut, IntPtr amdInfo, IntPtr& ppbHashValue, UInt32& pcbHashValue, UInt32& pdwAssemblyRefFlags);
    public abstract virtual void GetFileProps(UInt32 mdFile, Char[] strName, UInt32 cchName, UInt32& cchNameRequired, IntPtr& bHashData, UInt32& cchHashBytes, UInt32& dwFileFlags);
    public abstract virtual void GetExportedTypeProps();
    public abstract virtual void GetManifestResourceProps();
    public abstract virtual void EnumAssemblyRefs(IntPtr& phEnum, UInt32[] asmRefs, UInt32 asmRefCount, UInt32& iFetched);
    public abstract virtual void EnumFiles(IntPtr& phEnum, UInt32[] fileRefs, UInt32 fileRefCount, UInt32& iFetched);
    public abstract virtual void EnumExportedTypes();
    public abstract virtual void EnumManifestResources();
    public abstract virtual void GetAssemblyFromScope(UInt32& mdAsm);
    public abstract virtual void FindExportedTypeByName();
    public abstract virtual void FindManifestResourceByName();
    public abstract virtual void CloseEnum(IntPtr phEnum);
    public abstract virtual void FindAssembliesByName();
}
[GuidAttribute("809c652e-7396-11d2-9771-00a0c9b4d50c")]
[InterfaceTypeAttribute("1")]
[TypeLibTypeAttribute("512")]
internal interface Microsoft.Build.Tasks.IMetaDataDispenser {
    public abstract virtual object DefineScope(Guid& rclsid, UInt32 dwCreateFlags, Guid& riid);
    public abstract virtual object OpenScope(string szScope, UInt32 dwOpenFlags, Guid& riid);
    public abstract virtual object OpenScopeOnMemory(IntPtr pData, UInt32 cbData, UInt32 dwOpenFlags, Guid& riid);
}
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataImport {
    public abstract virtual void CloseEnum();
    public abstract virtual void CountEnum(IntPtr iRef, UInt32& ulCount);
    public abstract virtual void ResetEnum();
    public abstract virtual void EnumTypeDefs();
    public abstract virtual void EnumInterfaceImpls();
    public abstract virtual void EnumTypeRefs();
    public abstract virtual void FindTypeDefByName();
    public abstract virtual void GetScopeProps();
    public abstract virtual void GetModuleFromScope();
    public abstract virtual void GetTypeDefProps();
    public abstract virtual void GetInterfaceImplProps();
    public abstract virtual void GetTypeRefProps();
    public abstract virtual void ResolveTypeRef();
    public abstract virtual void EnumMembers();
    public abstract virtual void EnumMembersWithName();
    public abstract virtual void EnumMethods();
    public abstract virtual void EnumMethodsWithName();
    public abstract virtual void EnumFields();
    public abstract virtual void EnumFieldsWithName();
    public abstract virtual void EnumParams();
    public abstract virtual void EnumMemberRefs();
    public abstract virtual void EnumMethodImpls();
    public abstract virtual void EnumPermissionSets();
    public abstract virtual void FindMember();
    public abstract virtual void FindMethod();
    public abstract virtual void FindField();
    public abstract virtual void FindMemberRef();
    public abstract virtual void GetMethodProps();
    public abstract virtual void GetMemberRefProps();
    public abstract virtual void EnumProperties();
    public abstract virtual void EnumEvents();
    public abstract virtual void GetEventProps();
    public abstract virtual void EnumMethodSemantics();
    public abstract virtual void GetMethodSemantics();
    public abstract virtual void GetClassLayout();
    public abstract virtual void GetFieldMarshal();
    public abstract virtual void GetRVA();
    public abstract virtual void GetPermissionSetProps();
    public abstract virtual void GetSigFromToken();
    public abstract virtual void GetModuleRefProps();
    public abstract virtual void EnumModuleRefs();
    public abstract virtual void GetTypeSpecFromToken();
    public abstract virtual void GetNameFromToken();
    public abstract virtual void EnumUnresolvedMethods();
    public abstract virtual void GetUserString();
    public abstract virtual void GetPinvokeMap();
    public abstract virtual void EnumSignatures();
    public abstract virtual void EnumTypeSpecs();
    public abstract virtual void EnumUserStrings();
    public abstract virtual void GetParamForMethodIndex();
    public abstract virtual void EnumCustomAttributes();
    public abstract virtual void GetCustomAttributeProps();
    public abstract virtual void FindTypeRef();
    public abstract virtual void GetMemberProps();
    public abstract virtual void GetFieldProps();
    public abstract virtual void GetPropertyProps();
    public abstract virtual void GetParamProps();
    public abstract virtual void GetCustomAttributeByName();
    public abstract virtual void IsValidToken();
    public abstract virtual void GetNestedClassProps();
    public abstract virtual void GetNativeCallConvFromSig();
    public abstract virtual void IsGlobal();
}
[GuidAttribute("FCE5EFA0-8BBA-4f8e-A036-8F2022B08466")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataImport2 {
    public abstract virtual void CloseEnum();
    public abstract virtual void CountEnum();
    public abstract virtual void ResetEnum();
    public abstract virtual void EnumTypeDefs();
    public abstract virtual void EnumInterfaceImpls();
    public abstract virtual void EnumTypeRefs();
    public abstract virtual void FindTypeDefByName();
    public abstract virtual void GetScopeProps();
    public abstract virtual void GetModuleFromScope();
    public abstract virtual void GetTypeDefProps();
    public abstract virtual void GetInterfaceImplProps();
    public abstract virtual void GetTypeRefProps();
    public abstract virtual void ResolveTypeRef();
    public abstract virtual void EnumMembers();
    public abstract virtual void EnumMembersWithName();
    public abstract virtual void EnumMethods();
    public abstract virtual void EnumMethodsWithName();
    public abstract virtual void EnumFields();
    public abstract virtual void EnumFieldsWithName();
    public abstract virtual void EnumParams();
    public abstract virtual void EnumMemberRefs();
    public abstract virtual void EnumMethodImpls();
    public abstract virtual void EnumPermissionSets();
    public abstract virtual void FindMember();
    public abstract virtual void FindMethod();
    public abstract virtual void FindField();
    public abstract virtual void FindMemberRef();
    public abstract virtual void GetMethodProps();
    public abstract virtual void GetMemberRefProps();
    public abstract virtual void EnumProperties();
    public abstract virtual void EnumEvents();
    public abstract virtual void GetEventProps();
    public abstract virtual void EnumMethodSemantics();
    public abstract virtual void GetMethodSemantics();
    public abstract virtual void GetClassLayout();
    public abstract virtual void GetFieldMarshal();
    public abstract virtual void GetRVA();
    public abstract virtual void GetPermissionSetProps();
    public abstract virtual void GetSigFromToken();
    public abstract virtual void GetModuleRefProps();
    public abstract virtual void EnumModuleRefs();
    public abstract virtual void GetTypeSpecFromToken();
    public abstract virtual void GetNameFromToken();
    public abstract virtual void EnumUnresolvedMethods();
    public abstract virtual void GetUserString();
    public abstract virtual void GetPinvokeMap();
    public abstract virtual void EnumSignatures();
    public abstract virtual void EnumTypeSpecs();
    public abstract virtual void EnumUserStrings();
    public abstract virtual void GetParamForMethodIndex();
    public abstract virtual void EnumCustomAttributes();
    public abstract virtual void GetCustomAttributeProps();
    public abstract virtual void FindTypeRef();
    public abstract virtual void GetMemberProps();
    public abstract virtual void GetFieldProps();
    public abstract virtual void GetPropertyProps();
    public abstract virtual void GetParamProps();
    public abstract virtual int GetCustomAttributeByName(UInt32 mdTokenObj, string szName, IntPtr& ppData, UInt32& pDataSize);
    public abstract virtual void IsValidToken();
    public abstract virtual void GetNestedClassProps();
    public abstract virtual void GetNativeCallConvFromSig();
    public abstract virtual void IsGlobal();
    public abstract virtual void EnumGenericParams();
    public abstract virtual void GetGenericParamProps();
    public abstract virtual void GetMethodSpecProps();
    public abstract virtual void EnumGenericParamConstraints();
    public abstract virtual void GetGenericParamConstraintProps();
    public abstract virtual void GetPEKind(UInt32& pdwPEKind, UInt32& pdwMachine);
    public abstract virtual void GetVersionString(Char[] pwzBuf, UInt32 ccBufSize, UInt32& pccBufSize);
}
internal class Microsoft.Build.Tasks.InstalledAssemblies : object {
    internal InstalledAssemblies(RedistList redistList);
    internal void GetInfo(AssemblyNameExtension assemblyName, Version& unifiedVersion, Boolean& isPrerequisite, Nullable`1& isRedistRoot, String& redistName);
    internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension assemblyName);
    internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension assemblyName);
    internal bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    internal AssemblyEntry[] FindAssemblyNameFromSimpleName(string simpleName);
}
internal class Microsoft.Build.Tasks.InstalledSDKResolver : Resolver {
    public InstalledSDKResolver(Dictionary`2<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1 : object {
    public T RCW { get; }
    public RCWForCurrentContext`1(T rcw);
    protected virtual override void Finalize();
    public T get_RCW();
    public sealed virtual void Dispose();
}
internal class Microsoft.Build.Tasks.InvalidParameterValueException : Exception {
    public string ParamName { get; public set; }
    public string ActualValue { get; public set; }
    internal InvalidParameterValueException(string paramName, string actualValue, string message);
    internal InvalidParameterValueException(string paramName, string actualValue, string message, Exception innerException);
    private InvalidParameterValueException(SerializationInfo info, StreamingContext context);
    public string get_ParamName();
    public void set_ParamName(string value);
    public string get_ActualValue();
    public void set_ActualValue(string value);
}
internal class Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException : Exception {
    internal string SourceItemSpec { get; }
    internal InvalidReferenceAssemblyNameException(string sourceItemSpec);
    private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingContext context);
    internal string get_SourceItemSpec();
}
internal class Microsoft.Build.Tasks.IsWinMDFile : MulticastDelegate {
    public IsWinMDFile(object object, IntPtr method);
    public virtual bool Invoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    public virtual IAsyncResult BeginInvoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& imageRuntimeVersion, Boolean& isManagedWinmd, IAsyncResult result);
}
public class Microsoft.Build.Tasks.LC : ToolTaskExtension {
    [RequiredAttribute]
public ITaskItem[] Sources { get; public set; }
    [OutputAttribute]
public ITaskItem OutputLicense { get; public set; }
    [RequiredAttribute]
public ITaskItem LicenseTarget { get; public set; }
    public string OutputDirectory { get; public set; }
    public ITaskItem[] ReferencedAssemblies { get; public set; }
    public bool NoLogo { get; public set; }
    public string SdkToolsPath { get; public set; }
    protected string ToolName { get; }
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_OutputLicense(ITaskItem value);
    public ITaskItem get_OutputLicense();
    public void set_LicenseTarget(ITaskItem value);
    public ITaskItem get_LicenseTarget();
    public void set_OutputDirectory(string value);
    public string get_OutputDirectory();
    public void set_ReferencedAssemblies(ITaskItem[] value);
    public ITaskItem[] get_ReferencedAssemblies();
    public void set_NoLogo(bool value);
    public bool get_NoLogo();
    public void set_SdkToolsPath(string value);
    public string get_SdkToolsPath();
    protected virtual string get_ToolName();
    protected virtual bool ValidateParameters();
    protected virtual string GenerateFullPathToTool();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
public class Microsoft.Build.Tasks.MakeDir : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] DirectoriesCreated { get; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    public ITaskItem[] get_DirectoriesCreated();
    public virtual bool Execute();
}
public abstract class Microsoft.Build.Tasks.ManagedCompiler : ToolTaskExtension {
    public String[] AdditionalLibPaths { get; public set; }
    public String[] AddModules { get; public set; }
    public int CodePage { get; public set; }
    public string DebugType { get; public set; }
    public string DefineConstants { get; public set; }
    public bool DelaySign { get; public set; }
    public bool EmitDebugInformation { get; public set; }
    public int FileAlignment { get; public set; }
    public bool HighEntropyVA { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public ITaskItem[] LinkResources { get; public set; }
    public string MainEntryPoint { get; public set; }
    public bool NoConfig { get; public set; }
    public bool NoLogo { get; public set; }
    public bool NoWin32Manifest { get; public set; }
    public bool Optimize { get; public set; }
    [OutputAttribute]
public ITaskItem OutputAssembly { get; public set; }
    public string Platform { get; public set; }
    public bool Prefer32Bit { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] Resources { get; public set; }
    public ITaskItem[] ResponseFiles { get; public set; }
    public ITaskItem[] Sources { get; public set; }
    public string SubsystemVersion { get; public set; }
    public string TargetType { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    public bool Utf8Output { get; public set; }
    public string Win32Icon { get; public set; }
    public string Win32Manifest { get; public set; }
    public string Win32Resource { get; public set; }
    internal string PlatformWith32BitPreference { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected bool UsedCommandLineTool { get; protected set; }
    protected bool HostCompilerSupportsAllParameters { get; protected set; }
    public void set_AdditionalLibPaths(String[] value);
    public String[] get_AdditionalLibPaths();
    public void set_AddModules(String[] value);
    public String[] get_AddModules();
    public void set_CodePage(int value);
    public int get_CodePage();
    public void set_DebugType(string value);
    public string get_DebugType();
    public void set_DefineConstants(string value);
    public string get_DefineConstants();
    public void set_DelaySign(bool value);
    public bool get_DelaySign();
    public void set_EmitDebugInformation(bool value);
    public bool get_EmitDebugInformation();
    public void set_FileAlignment(int value);
    public int get_FileAlignment();
    public void set_HighEntropyVA(bool value);
    public bool get_HighEntropyVA();
    public void set_KeyContainer(string value);
    public string get_KeyContainer();
    public void set_KeyFile(string value);
    public string get_KeyFile();
    public void set_LinkResources(ITaskItem[] value);
    public ITaskItem[] get_LinkResources();
    public void set_MainEntryPoint(string value);
    public string get_MainEntryPoint();
    public void set_NoConfig(bool value);
    public bool get_NoConfig();
    public void set_NoLogo(bool value);
    public bool get_NoLogo();
    public void set_NoWin32Manifest(bool value);
    public bool get_NoWin32Manifest();
    public void set_Optimize(bool value);
    public bool get_Optimize();
    public void set_OutputAssembly(ITaskItem value);
    public ITaskItem get_OutputAssembly();
    public void set_Platform(string value);
    public string get_Platform();
    public void set_Prefer32Bit(bool value);
    public bool get_Prefer32Bit();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    public void set_Resources(ITaskItem[] value);
    public ITaskItem[] get_Resources();
    public void set_ResponseFiles(ITaskItem[] value);
    public ITaskItem[] get_ResponseFiles();
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_SubsystemVersion(string value);
    public string get_SubsystemVersion();
    public void set_TargetType(string value);
    public string get_TargetType();
    public void set_TreatWarningsAsErrors(bool value);
    public bool get_TreatWarningsAsErrors();
    public void set_Utf8Output(bool value);
    public bool get_Utf8Output();
    public void set_Win32Icon(string value);
    public string get_Win32Icon();
    public void set_Win32Manifest(string value);
    public string get_Win32Manifest();
    public void set_Win32Resource(string value);
    public string get_Win32Resource();
    internal string get_PlatformWith32BitPreference();
    protected virtual Encoding get_StandardOutputEncoding();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual bool UseAlternateCommandLineToolToExecute();
    protected virtual bool ValidateParameters();
    protected bool ListHasNoDuplicateItems(ITaskItem[] itemList, string parameterName);
    protected virtual bool HandleTaskExecutionErrors();
    [CompilerGeneratedAttribute]
protected bool get_UsedCommandLineTool();
    [CompilerGeneratedAttribute]
protected void set_UsedCommandLineTool(bool value);
    protected bool get_HostCompilerSupportsAllParameters();
    protected void set_HostCompilerSupportsAllParameters(bool value);
    protected void CheckHostObjectSupport(string parameterName, bool resultFromHostObjectSetOperation);
    protected bool CheckAllReferencesExistOnDisk();
    internal string GetWin32ManifestSwitch(bool noDefaultWin32Manifest, string win32Manifest);
}
internal class Microsoft.Build.Tasks.MarshalReleaseComObject : MulticastDelegate {
    public MarshalReleaseComObject(object object, IntPtr method);
    public virtual int Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.Message : TaskExtension {
    public string Text { get; public set; }
    public string Importance { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public bool IsCritical { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    public string get_Importance();
    public void set_Importance(string value);
    public string get_Code();
    public void set_Code(string value);
    public string get_File();
    public void set_File(string value);
    public string get_HelpKeyword();
    public void set_HelpKeyword(string value);
    public bool get_IsCritical();
    public void set_IsCritical(bool value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Move : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] MovedFiles { get; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DestinationFiles();
    [CompilerGeneratedAttribute]
public void set_DestinationFiles(ITaskItem[] value);
    public ITaskItem[] get_MovedFiles();
    public sealed virtual void Cancel();
    public virtual bool Execute();
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.MSBuild : TaskExtension {
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    public String[] get_Properties();
    public void set_Properties(String[] value);
    public string get_RemoveProperties();
    public void set_RemoveProperties(string value);
    public String[] get_Targets();
    public void set_Targets(String[] value);
    public ITaskItem[] get_Projects();
    public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    public bool get_RebaseOutputs();
    public void set_RebaseOutputs(bool value);
    public bool get_StopOnFirstFailure();
    public void set_StopOnFirstFailure(bool value);
    public bool get_RunEachTargetSeparately();
    public void set_RunEachTargetSeparately(bool value);
    public string get_ToolsVersion();
    public void set_ToolsVersion(string value);
    public bool get_BuildInParallel();
    public void set_BuildInParallel(bool value);
    public bool get_UnloadProjectsOnCompletion();
    public void set_UnloadProjectsOnCompletion(bool value);
    public bool get_UseResultsCache();
    public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    public String[] get_TargetAndPropertyListSeparators();
    public void set_TargetAndPropertyListSeparators(String[] value);
    public virtual bool Execute();
    internal static ArrayList CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    internal static bool ExecuteTargets(ITaskItem[] projects, Hashtable propertiesTable, String[] undefineProperties, ArrayList targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, ArrayList targetOutputs, bool useResultsCache, bool unloadProjectsOnCompletion, string toolsVersion);
}
internal enum Microsoft.Build.Tasks.MultipleVersionSupport : Enum {
    public int value__;
    public static MultipleVersionSupport Allow;
    public static MultipleVersionSupport Warning;
    public static MultipleVersionSupport Error;
}
internal static class Microsoft.Build.Tasks.NativeMethods : object {
    internal static IntPtr InvalidIntPtr;
    internal static int TYPE_E_REGISTRYACCESS;
    internal static int TYPE_E_CANTLOADLIBRARY;
    internal static int HRESULT_E_CLASSNOTREGISTERED;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_SHARING_VIOLATION;
    internal static Guid GUID_TYPELIB_NAMESPACE;
    internal static Guid GUID_ExportedFromComPlus;
    internal static Guid IID_IUnknown;
    internal static Guid IID_IDispatch;
    internal static Guid IID_ITypeInfo;
    internal static Guid IID_IEnumVariant;
    internal static Guid IID_IDispatchEx;
    internal static Guid IID_StdOle;
    internal static ushort IMAGE_FILE_MACHINE_UNKNOWN;
    internal static ushort IMAGE_FILE_MACHINE_INVALID;
    internal static ushort IMAGE_FILE_MACHINE_AMD64;
    internal static ushort IMAGE_FILE_MACHINE_ARM;
    internal static ushort IMAGE_FILE_MACHINE_ARMV7;
    internal static ushort IMAGE_FILE_MACHINE_I386;
    internal static ushort IMAGE_FILE_MACHINE_IA64;
    internal static ushort IMAGE_FILE_MACHINE_R4000;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 PAGE_READONLY;
    internal static UInt32 FILE_MAP_READ;
    internal static UInt32 FILE_TYPE_DISK;
    internal static int SE_ERR_ACCESSDENIED;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    internal static UInt32 IMAGE_DIRECTORY_ENTRY_COMHEADER;
    internal static UInt32 COMIMAGE_FLAGS_STRONGNAMESIGNED;
    private static NativeMethods();
    internal static bool CreateHardLink(string newFileName, string exitingFileName, IntPtr securityAttributes);
    internal static bool MoveFileEx(string existingFileName, string newFileName, MoveFileFlags flags);
    internal static void RegisterTypeLib(object pTypeLib, string szFullPath, string szHelpDir);
    internal static void UnregisterTypeLib(Guid& guid, short wMajorVerNum, short wMinorVerNum, int lcid, SYSKIND syskind);
    internal static object LoadTypeLibEx(string szFullPath, int regKind);
    internal static object LoadRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static string QueryPathOfRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static IntPtr CreateFile(string lpFileName, UInt32 dwDesiredAccess, FileShare dwShareMode, IntPtr lpSecurityAttributes, FileMode dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static bool CloseHandle(IntPtr hObject);
    internal static IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, UInt32 flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    internal static IntPtr MapViewOfFile(IntPtr hFileMapping, UInt32 dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
    internal static IntPtr ImageNtHeader(IntPtr imageBase);
    internal static IntPtr ImageRvaToVa(IntPtr ntHeaders, IntPtr imageBase, UInt32 Rva, IntPtr& LastRvaSection);
    internal static UInt32 CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    internal static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IntPtr pUnkReserved, IAssemblyName pName, AssemblyCacheFlags flags, IntPtr pvReserved);
    internal static int CreateAssemblyNameObject(IAssemblyName& ppAssemblyNameObj, string szAssemblyName, CreateAssemblyNameObjectFlags flags, IntPtr pvReserved);
    internal static int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, Int32& pcchPath);
    internal static int CompareAssemblyIdentity(string pwzAssemblyIdentity1, bool fUnified1, string pwzAssemblyIdentity2, bool fUnified2, Boolean& pfEquivalent, AssemblyComparisonResult& pResult);
    internal static IntPtr PFXImportCertStore(IntPtr blob, string password, CryptFlags flags);
    internal static bool CertCloseStore(IntPtr CertStore, CertStoreClose Flags);
    internal static IntPtr CertEnumCertificatesInStore(IntPtr CertStore, IntPtr PrevCertContext);
    internal static bool CryptAcquireCertificatePrivateKey(IntPtr CertContext, UInt32 flags, IntPtr reserved, IntPtr& CryptProv, KeySpec& KeySpec, Boolean& CallerFreeProv);
    internal static bool CryptGetUserKey(IntPtr CryptProv, KeySpec KeySpec, IntPtr& Key);
    internal static bool CryptExportKey(IntPtr Key, IntPtr ExpKey, BlobType type, UInt32 Flags, IntPtr Data, UInt32& DataLen);
    internal static bool CryptDestroyKey(IntPtr hKey);
    internal static bool CryptReleaseContext(IntPtr Prov, UInt32 Flags);
    internal static bool CertFreeCertificateContext(IntPtr CertContext);
    internal static UInt32 GetFileVersion(string szFullPath, StringBuilder szBuffer, int cchBuffer, UInt32& dwLength);
    [HandleProcessCorruptedStateExceptionsAttribute]
internal static bool TryReadMetadataString(string fullPath, IntPtr attrData, UInt32 attrDataSize, String& strValue);
    internal static int CorSigUncompressData(IntPtr data, Int32& uncompressedDataLength);
}
internal enum Microsoft.Build.Tasks.NoMatchReason : Enum {
    public int value__;
    public static NoMatchReason Unknown;
    public static NoMatchReason FileNotFound;
    public static NoMatchReason FusionNamesDidNotMatch;
    public static NoMatchReason TargetHadNoFusionName;
    public static NoMatchReason NotInGac;
    public static NoMatchReason NotAFileNameOnDisk;
    public static NoMatchReason ProcessorArchitectureDoesNotMatch;
}
internal class Microsoft.Build.Tasks.ParseState : object {
    internal bool ResolvingNamespace { get; internal set; }
    internal bool ResolvingClass { get; internal set; }
    internal bool InsideConditionalDirective { get; }
    internal string Namespace { get; internal set; }
    internal bool get_ResolvingNamespace();
    internal void set_ResolvingNamespace(bool value);
    internal bool get_ResolvingClass();
    internal void set_ResolvingClass(bool value);
    internal bool get_InsideConditionalDirective();
    internal string get_Namespace();
    internal void set_Namespace(string value);
    internal void Reset();
    internal void OpenConditionalDirective();
    internal void CloseConditionalDirective();
    internal void PushNamespacePart(string namespacePart);
    internal string PopNamespacePart();
    internal string ComposeQualifiedClassName(string className);
}
internal class Microsoft.Build.Tasks.PiaReference : ComReference {
    internal PiaReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
}
internal class Microsoft.Build.Tasks.ProcessResourceFiles : MarshalByRefObject {
    internal string StronglyTypedFilename { get; }
    internal string StronglyTypedClassName { get; }
    internal List`1<ITaskItem> ExtractedResWFiles { get; }
    internal List`1<PortableLibraryFile> PortableLibraryCacheInfo { get; }
    internal ArrayList UnsuccessfullyCreatedOutFiles { get; }
    internal bool StronglyTypedResourceSuccessfullyCreated { get; }
    internal string get_StronglyTypedFilename();
    internal string get_StronglyTypedClassName();
    internal List`1<ITaskItem> get_ExtractedResWFiles();
    internal List`1<PortableLibraryFile> get_PortableLibraryCacheInfo();
    internal ArrayList get_UnsuccessfullyCreatedOutFiles();
    internal bool get_StronglyTypedResourceSuccessfullyCreated();
    internal void Run(TaskLoggingHelper log, ITaskItem[] assemblyFilesList, List`1<ITaskItem> inputs, List`1<ITaskItem> outputs, bool sourcePath, string language, string namespacename, string resourcesNamespace, string filename, string classname, bool publicClass, bool extractingResWFiles, string resWOutputDirectory);
    internal Assembly ResolveAssembly(object sender, ResolveEventArgs args);
    internal void ReadAssemblyResources(string name);
    public static string GenerateDefaultStronglyTypedFilename(CodeDomProvider provider, string outputResourcesFile);
    public static bool TryCreateCodeDomProvider(TaskLoggingHelper logger, string stronglyTypedLanguage, CodeDomProvider& provider);
}
internal static class Microsoft.Build.Tasks.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Hashtable& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Hashtable& finalPropertiesTable);
}
internal class Microsoft.Build.Tasks.RawFilenameResolver : Resolver {
    public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
public class Microsoft.Build.Tasks.ReadLinesFromFile : TaskExtension {
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    [OutputAttribute]
public ITaskItem[] Lines { get; public set; }
    public ITaskItem get_File();
    public void set_File(ITaskItem value);
    public ITaskItem[] get_Lines();
    public void set_Lines(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader : MulticastDelegate {
    public ReadMachineTypeFromPEHeader(object object, IntPtr method);
    public virtual ushort Invoke(string dllPath);
    public virtual IAsyncResult BeginInvoke(string dllPath, AsyncCallback callback, object object);
    public virtual ushort EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.RedistList : object {
    internal static string RedistListFolder;
    internal Exception[] Errors { get; }
    internal String[] ErrorFileNames { get; }
    internal int Count { get; }
    private static RedistList();
    internal Exception[] get_Errors();
    internal String[] get_ErrorFileNames();
    internal int get_Count();
    public bool IsFrameworkAssembly(string assemblyName);
    public bool IsPrerequisiteAssembly(string assemblyName);
    public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap);
    internal Nullable`1<bool> IsRedistRoot(string assemblyName);
    public static RedistList GetFrameworkList20();
    public static RedistList GetFrameworkList30();
    public static RedistList GetFrameworkList35();
    public static RedistList GetRedistListFromPath(string path);
    public static String[] GetRedistListPathsFromDisk(string frameworkDirectory);
    internal string RedistName(string assemblyName);
    public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables);
    public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    public string GetUnifiedAssemblyName(string assemblyName);
    internal AssemblyEntry[] FindAssemblyNameFromSimpleName(string simpleName);
    internal Hashtable GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List`1<Exception> whiteListErrors, List`1<string> whiteListErrorFileNames);
    internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List`1<AssemblyEntry> assembliesList, List`1<Exception> errorsList, List`1<string> errorFilenamesList, List`1<AssemblyRemapping> remapEntries);
}
internal class Microsoft.Build.Tasks.Reference : object {
    internal bool WantSpecificVersion { get; }
    internal bool EmbedInteropTypes { get; internal set; }
    internal bool UserRequestedSpecificFile { get; internal set; }
    internal Version ReferenceVersion { get; internal set; }
    internal Nullable`1<bool> FoundInGac { get; private set; }
    internal ExclusionListProperties ExclusionListLoggingProperties { get; }
    internal string FullPath { get; internal set; }
    internal string DirectoryName { get; }
    internal string FileNameWithoutExtension { get; }
    internal string FullPathWithoutExtension { get; }
    internal string HintPath { get; internal set; }
    internal string AssemblyFolderKey { get; internal set; }
    internal bool IsPrimary { get; }
    internal bool IsPrerequisite { get; internal set; }
    internal Nullable`1<bool> IsRedistRoot { get; internal set; }
    internal string RedistName { get; internal set; }
    internal ITaskItem PrimarySourceItem { get; }
    internal bool IsBadImage { get; }
    internal bool IsConflictVictim { get; }
    internal AssemblyNameExtension ConflictVictorName { get; internal set; }
    internal ConflictLossReason ConflictLossExplanation { get; internal set; }
    internal bool IsWinMDFile { get; internal set; }
    internal bool IsManagedWinMDFile { get; internal set; }
    public string ImplementationAssembly { get; public set; }
    internal string ImageRuntime { get; internal set; }
    internal bool IsUnified { get; }
    internal CopyLocalState CopyLocal { get; }
    internal bool IsCopyLocal { get; }
    internal bool IsResolved { get; }
    internal bool IsUnresolvable { get; }
    internal bool DependenciesFound { get; internal set; }
    internal string SDKName { get; }
    internal ArrayList AssembliesConsideredAndRejected { get; }
    internal string ResolvedSearchPath { get; internal set; }
    internal FrameworkName FrameworkNameAttribute { get; internal set; }
    internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion);
    internal void AddSourceItem(ITaskItem sourceItem);
    internal void AddSourceItems(IEnumerable sourceItemsToAdd);
    internal void PropagateSourceItems(ITaskItem sourceItem);
    internal ICollection GetSourceItems();
    internal void AddDependency(Reference dependency);
    internal void AddDependee(Reference dependee);
    internal void RemoveDependee(Reference dependeeToRemove);
    internal void RemoveDependency(Reference dependencyToRemove);
    internal ICollection GetDependees();
    internal void AttachScatterFiles(String[] scatterFilesToAttach);
    internal String[] GetScatterFiles();
    internal void SetExecutableExtension(string extension);
    internal String[] GetExecutableExtensions(String[] allowedAssemblyExtensions);
    internal bool get_WantSpecificVersion();
    internal bool get_EmbedInteropTypes();
    internal void set_EmbedInteropTypes(bool value);
    internal bool get_UserRequestedSpecificFile();
    internal void set_UserRequestedSpecificFile(bool value);
    internal Version get_ReferenceVersion();
    internal void set_ReferenceVersion(Version value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_FoundInGac();
    [CompilerGeneratedAttribute]
private void set_FoundInGac(Nullable`1<bool> value);
    internal ExclusionListProperties get_ExclusionListLoggingProperties();
    internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHasMetadata);
    internal void AddError(Exception e);
    internal ICollection GetErrors();
    internal void AddRelatedFileExtension(string filenameExtension);
    internal ICollection GetRelatedFileExtensions();
    internal void AddSatelliteFile(string filename);
    internal void AddSerializationAssemblyFile(string filename);
    internal ICollection GetSatelliteFiles();
    internal ICollection GetSerializationAssemblyFiles();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal string get_DirectoryName();
    internal string get_FileNameWithoutExtension();
    internal string get_FullPathWithoutExtension();
    internal string get_HintPath();
    internal void set_HintPath(string value);
    internal string get_AssemblyFolderKey();
    internal void set_AssemblyFolderKey(string value);
    internal bool get_IsPrimary();
    internal void set_IsPrerequisite(bool value);
    internal bool get_IsPrerequisite();
    internal void set_IsRedistRoot(Nullable`1<bool> value);
    internal Nullable`1<bool> get_IsRedistRoot();
    internal void set_RedistName(string value);
    internal string get_RedistName();
    internal ITaskItem get_PrimarySourceItem();
    internal bool get_IsBadImage();
    internal bool get_IsConflictVictim();
    internal void AddConflictVictim(AssemblyNameExtension victim);
    internal AssemblyNameExtension[] GetConflictVictims();
    internal AssemblyNameExtension get_ConflictVictorName();
    internal void set_ConflictVictorName(AssemblyNameExtension value);
    internal ConflictLossReason get_ConflictLossExplanation();
    internal void set_ConflictLossExplanation(ConflictLossReason value);
    internal bool get_IsWinMDFile();
    internal void set_IsWinMDFile(bool value);
    internal bool get_IsManagedWinMDFile();
    internal void set_IsManagedWinMDFile(bool value);
    [CompilerGeneratedAttribute]
public string get_ImplementationAssembly();
    [CompilerGeneratedAttribute]
public void set_ImplementationAssembly(string value);
    internal string get_ImageRuntime();
    internal void set_ImageRuntime(string value);
    internal List`1<UnificationVersion> GetPreUnificationVersions();
    internal HashSet`1<AssemblyRemapping> RemappedAssemblyNames();
    internal void AddPreUnificationVersion(string referencePath, Version version, UnificationReason reason);
    internal void AddRemapping(AssemblyNameExtension remappedFrom, AssemblyNameExtension remappedTo);
    internal bool get_IsUnified();
    internal CopyLocalState get_CopyLocal();
    internal bool get_IsCopyLocal();
    internal bool get_IsResolved();
    internal bool get_IsUnresolvable();
    internal bool get_DependenciesFound();
    internal void set_DependenciesFound(bool value);
    internal string get_SDKName();
    internal void AddAssembliesConsideredAndRejected(ArrayList assembliesConsideredAndRejectedToAdd);
    internal ArrayList get_AssembliesConsideredAndRejected();
    internal string get_ResolvedSearchPath();
    internal void set_ResolvedSearchPath(string value);
    internal FrameworkName get_FrameworkNameAttribute();
    internal void set_FrameworkNameAttribute(FrameworkName value);
    internal void MakeDependentAssemblyReference(Reference sourceReference);
    internal void MakePrimaryAssemblyReference(ITaskItem sourceItem, bool wantSpecificVersionValue, string executableExtension);
    internal static bool IsFrameworkFile(string fullPath, String[] frameworkPaths);
    internal void SetFinalCopyLocalState(AssemblyNameExtension assemblyName, String[] frameworkPaths, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool copyLocalDependenciesWhenParentReferenceInGac, ReferenceTable referenceTable, CheckIfAssemblyInGac checkIfAssemblyInGac);
    public virtual string ToString();
}
internal class Microsoft.Build.Tasks.ReferenceResolutionException : Exception {
    internal ReferenceResolutionException(string message, Exception innerException);
    private ReferenceResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.ReferenceTable : object {
    internal Resolver[] Resolvers { get; }
    internal Dictionary`2<AssemblyNameExtension, Reference> References { get; }
    internal List`1<string> ListOfExcludedAssemblies { get; }
    internal ReferenceTable(IBuildEngine buildEngine, bool findDependencies, bool findSatellites, bool findSerializationAssemblies, bool findRelatedFiles, String[] searchPaths, String[] allowedAssemblyExtensions, String[] relatedFileExtensions, String[] candidateAssemblyFiles, ITaskItem[] resolvedSDKItems, String[] frameworkPaths, InstalledAssemblies installedAssemblies, ProcessorArchitecture targetProcessorArchitecture, FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, Version projectTargetFramework, FrameworkName targetFrameworkMoniker, TaskLoggingHelper log, String[] latestTargetFrameworkDirectories, bool copyLocalDependenciesWhenParentReferenceInGac, CheckIfAssemblyInGac checkIfAssemblyIsInGac, IsWinMDFile isWinMDFile, bool ignoreVersionForFrameworkReferences, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader, WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch, bool ignoreFrameworkAttributeVersionMismatch);
    private static ReferenceTable();
    internal Resolver[] get_Resolvers();
    internal Dictionary`2<AssemblyNameExtension, Reference> get_References();
    internal List`1<string> get_ListOfExcludedAssemblies();
    internal void AddReference(AssemblyNameExtension assemblyName, Reference reference);
    internal Reference GetReference(AssemblyNameExtension assemblyName);
    internal static void CalcuateParentAssemblyDirectories(Hashtable parentReferenceFolderHash, List`1<string> parentReferenceFolders, Reference parentReference);
    internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, string subsetName);
    internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec);
    internal void ComputeClosure(DependentAssembly[] remappedAssembliesValue, ITaskItem[] referenceAssemblyFiles, ITaskItem[] referenceAssemblyNames, ArrayList exceptions);
    internal void ResolveConflicts(DependentAssembly[]& idealRemappings, AssemblyNameReference[]& conflictingReferences);
    internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension assemblyName, Reference reference);
    internal void MarkReferenceWithHighestVersionInCurrentRedistList(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(AssemblyNameExtension assemblyName, Reference reference);
    internal void GetReferenceItems(ITaskItem[]& primaryFiles, ITaskItem[]& dependencyFiles, ITaskItem[]& relatedFiles, ITaskItem[]& satelliteFiles, ITaskItem[]& serializationAssemblyFiles, ITaskItem[]& scatterFiles, ITaskItem[]& copyLocalFiles);
    internal static ushort ReadMachineTypeFromPEHeader(string dllPath);
    internal void LogHigherVersionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogHigherVersionUnresolveDueToAttribute(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogAnotherFrameworkUnResolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogProfileExclusionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal bool MarkReferencesForExclusion(Hashtable exclusionList);
}
public class Microsoft.Build.Tasks.RegisterAssembly : AppDomainIsolatedTaskExtension {
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] TypeLibFiles { get; public set; }
    public bool CreateCodeBase { get; public set; }
    public ITaskItem AssemblyListFile { get; public set; }
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public ITaskItem[] get_TypeLibFiles();
    public void set_TypeLibFiles(ITaskItem[] value);
    public bool get_CreateCodeBase();
    public void set_CreateCodeBase(bool value);
    public ITaskItem get_AssemblyListFile();
    public void set_AssemblyListFile(ITaskItem value);
    public virtual bool Execute();
    public sealed virtual void ReportEvent(ExporterEventKind kind, int code, string msg);
    public sealed virtual object ResolveRef(Assembly assemblyToResolve);
}
public class Microsoft.Build.Tasks.RemoveDir : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] RemovedDirectories { get; public set; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    public ITaskItem[] get_RemovedDirectories();
    public void set_RemovedDirectories(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.RemoveDuplicates : TaskExtension {
    public ITaskItem[] Inputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] Filtered { get; public set; }
    public ITaskItem[] get_Inputs();
    public void set_Inputs(ITaskItem[] value);
    public ITaskItem[] get_Filtered();
    public void set_Filtered(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.RequiresFramework35SP1Assembly : TaskExtension {
    public string ErrorReportUrl { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public bool CreateDesktopShortcut { get; public set; }
    public bool SigningManifests { get; public set; }
    public ITaskItem[] ReferencedAssemblies { get; public set; }
    public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem DeploymentManifestEntryPoint { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public string SuiteName { get; public set; }
    [OutputAttribute]
public bool RequiresMinimumFramework35SP1 { get; public set; }
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    public bool get_SigningManifests();
    public void set_SigningManifests(bool value);
    public ITaskItem[] get_ReferencedAssemblies();
    public void set_ReferencedAssemblies(ITaskItem[] value);
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public ITaskItem get_DeploymentManifestEntryPoint();
    public void set_DeploymentManifestEntryPoint(ITaskItem value);
    public ITaskItem get_EntryPoint();
    public void set_EntryPoint(ITaskItem value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public bool get_RequiresMinimumFramework35SP1();
    public void set_RequiresMinimumFramework35SP1(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ResGenDependencies : StateFileBase {
    internal string BaseLinkedFileDirectory { get; internal set; }
    unknown bool UseSourcePath {internal set; }
    internal bool IsDirty { get; }
    internal string get_BaseLinkedFileDirectory();
    internal void set_BaseLinkedFileDirectory(string value);
    internal void set_UseSourcePath(bool value);
    internal ResXFile GetResXFileInfo(string resxFile);
    internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath);
    internal void UpdatePortableLibrary(PortableLibraryFile library);
    internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log);
    internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log);
    internal bool get_IsDirty();
}
internal class Microsoft.Build.Tasks.ResolutionSearchLocation : object {
    internal string FileNameAttempted { get; internal set; }
    internal string SearchPath { get; internal set; }
    internal AssemblyNameExtension AssemblyName { get; internal set; }
    internal NoMatchReason Reason { get; internal set; }
    internal string get_FileNameAttempted();
    internal void set_FileNameAttempted(string value);
    internal string get_SearchPath();
    internal void set_SearchPath(string value);
    internal AssemblyNameExtension get_AssemblyName();
    internal void set_AssemblyName(AssemblyNameExtension value);
    internal NoMatchReason get_Reason();
    internal void set_Reason(NoMatchReason value);
}
public class Microsoft.Build.Tasks.ResolveAssemblyReference : TaskExtension {
    public string WarnOrErrorOnTargetArchitectureMismatch { get; public set; }
    public ITaskItem[] AssemblyFiles { get; public set; }
    public String[] LatestTargetFrameworkDirectories { get; public set; }
    public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; public set; }
    public String[] TargetFrameworkSubsets { get; public set; }
    public ITaskItem[] Assemblies { get; public set; }
    public String[] CandidateAssemblyFiles { get; public set; }
    public ITaskItem[] ResolvedSDKReferences { get; public set; }
    public String[] TargetFrameworkDirectories { get; public set; }
    public ITaskItem[] InstalledAssemblyTables { get; public set; }
    public ITaskItem[] InstalledAssemblySubsetTables { get; public set; }
    public ITaskItem[] FullFrameworkAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblySubsetTables { get; public set; }
    public bool IgnoreVersionForFrameworkReferences { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public string TargetedRuntimeVersion { get; public set; }
    [RequiredAttribute]
public String[] SearchPaths { get; public set; }
    public String[] AllowedAssemblyExtensions { get; public set; }
    public String[] AllowedRelatedFileExtensions { get; public set; }
    public string AppConfigFile { get; public set; }
    public bool AutoUnify { get; public set; }
    public bool CopyLocalDependenciesWhenParentReferenceInGac { get; public set; }
    public string StateFile { get; public set; }
    public bool FindDependencies { get; public set; }
    public bool FindSatellites { get; public set; }
    public bool FindSerializationAssemblies { get; public set; }
    public bool FindRelatedFiles { get; public set; }
    public bool Silent { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetFrameworkMonikerDisplayName { get; public set; }
    public String[] FullTargetFrameworkSubsetNames { get; public set; }
    public string ProfileName { get; public set; }
    public String[] FullFrameworkFolders { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; }
    [OutputAttribute]
public ITaskItem[] ResolvedDependencyFiles { get; }
    [OutputAttribute]
public ITaskItem[] RelatedFiles { get; }
    [OutputAttribute]
public ITaskItem[] SatelliteFiles { get; }
    [OutputAttribute]
public ITaskItem[] SerializationAssemblyFiles { get; }
    [OutputAttribute]
public ITaskItem[] ScatterFiles { get; }
    [OutputAttribute]
public ITaskItem[] CopyLocalFiles { get; }
    [OutputAttribute]
public ITaskItem[] SuggestedRedirects { get; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; public set; }
    public string get_WarnOrErrorOnTargetArchitectureMismatch();
    public void set_WarnOrErrorOnTargetArchitectureMismatch(string value);
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    public String[] get_LatestTargetFrameworkDirectories();
    public void set_LatestTargetFrameworkDirectories(String[] value);
    public bool get_IgnoreTargetFrameworkAttributeVersionMismatch();
    public void set_IgnoreTargetFrameworkAttributeVersionMismatch(bool value);
    public String[] get_TargetFrameworkSubsets();
    public void set_TargetFrameworkSubsets(String[] value);
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public String[] get_CandidateAssemblyFiles();
    public void set_CandidateAssemblyFiles(String[] value);
    public ITaskItem[] get_ResolvedSDKReferences();
    public void set_ResolvedSDKReferences(ITaskItem[] value);
    public String[] get_TargetFrameworkDirectories();
    public void set_TargetFrameworkDirectories(String[] value);
    public ITaskItem[] get_InstalledAssemblyTables();
    public void set_InstalledAssemblyTables(ITaskItem[] value);
    public ITaskItem[] get_InstalledAssemblySubsetTables();
    public void set_InstalledAssemblySubsetTables(ITaskItem[] value);
    public ITaskItem[] get_FullFrameworkAssemblyTables();
    public void set_FullFrameworkAssemblyTables(ITaskItem[] value);
    public bool get_IgnoreDefaultInstalledAssemblyTables();
    public void set_IgnoreDefaultInstalledAssemblyTables(bool value);
    public bool get_IgnoreDefaultInstalledAssemblySubsetTables();
    public void set_IgnoreDefaultInstalledAssemblySubsetTables(bool value);
    public bool get_IgnoreVersionForFrameworkReferences();
    public void set_IgnoreVersionForFrameworkReferences(bool value);
    public string get_TargetProcessorArchitecture();
    public void set_TargetProcessorArchitecture(string value);
    public string get_TargetedRuntimeVersion();
    public void set_TargetedRuntimeVersion(string value);
    public String[] get_SearchPaths();
    public void set_SearchPaths(String[] value);
    public String[] get_AllowedAssemblyExtensions();
    public void set_AllowedAssemblyExtensions(String[] value);
    public String[] get_AllowedRelatedFileExtensions();
    public void set_AllowedRelatedFileExtensions(String[] value);
    public string get_AppConfigFile();
    public void set_AppConfigFile(string value);
    public bool get_AutoUnify();
    public void set_AutoUnify(bool value);
    public bool get_CopyLocalDependenciesWhenParentReferenceInGac();
    public void set_CopyLocalDependenciesWhenParentReferenceInGac(bool value);
    public string get_StateFile();
    public void set_StateFile(string value);
    public bool get_FindDependencies();
    public void set_FindDependencies(bool value);
    public bool get_FindSatellites();
    public void set_FindSatellites(bool value);
    public bool get_FindSerializationAssemblies();
    public void set_FindSerializationAssemblies(bool value);
    public bool get_FindRelatedFiles();
    public void set_FindRelatedFiles(bool value);
    public bool get_Silent();
    public void set_Silent(bool value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    public String[] get_FullTargetFrameworkSubsetNames();
    public void set_FullTargetFrameworkSubsetNames(String[] value);
    public string get_ProfileName();
    public void set_ProfileName(string value);
    public String[] get_FullFrameworkFolders();
    public void set_FullFrameworkFolders(String[] value);
    public ITaskItem[] get_ResolvedFiles();
    public ITaskItem[] get_ResolvedDependencyFiles();
    public ITaskItem[] get_RelatedFiles();
    public ITaskItem[] get_SatelliteFiles();
    public ITaskItem[] get_SerializationAssemblyFiles();
    public ITaskItem[] get_ScatterFiles();
    public ITaskItem[] get_CopyLocalFiles();
    public ITaskItem[] get_SuggestedRedirects();
    public void set_FilesWritten(ITaskItem[] value);
    public ITaskItem[] get_FilesWritten();
    internal bool Execute(FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetLastWriteTime getLastWriteTime, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, CheckIfAssemblyInGac checkIfAssemblyIsInGac, IsWinMDFile isWinMDFile, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader);
    internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionRawValue);
    internal static string GenerateSubSetName(String[] frameworkSubSetNames, ITaskItem[] installedSubSetNames);
    internal static string ProcessorArchitectureToString(ProcessorArchitecture processorArchitecture);
    internal static ProcessorArchitecture TargetProcessorArchitectureToEnumeration(string targetedProcessorArchitecture);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ResolveComReference : AppDomainIsolatedTaskExtension {
    internal List`1<ComReferenceInfo> allProjectRefs;
    internal List`1<ComReferenceInfo> allDependencyRefs;
    public ITaskItem[] TypeLibNames { get; public set; }
    public ITaskItem[] TypeLibFiles { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public string WrapperOutputDirectory { get; public set; }
    public bool IncludeVersionInInteropName { get; public set; }
    public ITaskItem[] ResolvedAssemblyReferences { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    public bool NoClassMembers { get; public set; }
    public bool Silent { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedModules { get; public set; }
    public string SdkToolsPath { get; public set; }
    public string StateFile { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    private static ResolveComReference();
    public ITaskItem[] get_TypeLibNames();
    public void set_TypeLibNames(ITaskItem[] value);
    public ITaskItem[] get_TypeLibFiles();
    public void set_TypeLibFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    public string get_WrapperOutputDirectory();
    public void set_WrapperOutputDirectory(string value);
    public bool get_IncludeVersionInInteropName();
    public void set_IncludeVersionInInteropName(bool value);
    public ITaskItem[] get_ResolvedAssemblyReferences();
    public void set_ResolvedAssemblyReferences(ITaskItem[] value);
    public string get_KeyContainer();
    public void set_KeyContainer(string value);
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public bool get_DelaySign();
    public void set_DelaySign(bool value);
    public bool get_NoClassMembers();
    public void set_NoClassMembers(bool value);
    public bool get_Silent();
    public void set_Silent(bool value);
    public string get_TargetProcessorArchitecture();
    public void set_TargetProcessorArchitecture(string value);
    public bool get_ExecuteAsTool();
    public void set_ExecuteAsTool(bool value);
    public ITaskItem[] get_ResolvedFiles();
    public void set_ResolvedFiles(ITaskItem[] value);
    public ITaskItem[] get_ResolvedModules();
    public void set_ResolvedModules(ITaskItem[] value);
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public string get_StateFile();
    public void set_StateFile(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public virtual bool Execute();
    internal void SetFrameworkVersionFromString(string version);
    internal void AddMissingTlbReferences();
    internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenceInfo referenceInfo, string outputDirectory, ITaskItem& referencePathItem);
    internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededRefType, ComReferenceInfo& referenceInfo);
    internal bool IsExistingDependencyReference(TYPELIBATTR typeLibAttr, ComReferenceInfo& referenceInfo);
    internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string outputDirectory, string wrapperType, string refName, bool topLevelRef, List`1<string> dependencyPaths, ComReferenceWrapperInfo& wrapperInfo);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, string outputDirectory, string wrapperType, string refName, ComReferenceWrapperInfo& wrapperInfo);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, String& assemblyPath);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName, String& assemblyPath);
    internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refName, ComReferenceWrapperInfo& wrapperInfo);
    internal IEnumerable`1<string> GetResolvedAssemblyReferenceItemSpecs();
    internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List`1<string> dependencyPaths, ComReferenceWrapperInfo& wrapperInfo);
    internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outputDirectory, string refName, ComReferenceWrapperInfo& wrapperInfo);
    internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, String& missingOrInvalidMetadata);
    internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference);
    internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference);
    internal bool CheckForConflictingReferences();
    internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(ArrayList outputTaskItems, string gacPath);
    internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Tasks.ResolveComReferenceCache : StateFileBase {
    internal bool Dirty { get; }
    internal DateTime Item { get; internal set; }
    internal ResolveComReferenceCache(string tlbImpPath, string axImpPath);
    internal bool get_Dirty();
    internal bool ToolPathsMatchCachePaths(string tlbImpPath, string axImpPath);
    internal DateTime get_Item(string componentPath);
    internal void set_Item(string componentPath, DateTime value);
}
public class Microsoft.Build.Tasks.ResolveKeySource : TaskExtension {
    public string KeyFile { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public string CertificateFile { get; public set; }
    public bool SuppressAutoClosePasswordPrompt { get; public set; }
    public bool ShowImportDialogDespitePreviousFailures { get; public set; }
    public int AutoClosePasswordPromptTimeout { get; public set; }
    public int AutoClosePasswordPromptShow { get; public set; }
    [OutputAttribute]
public string ResolvedThumbprint { get; public set; }
    [OutputAttribute]
public string ResolvedKeyContainer { get; public set; }
    [OutputAttribute]
public string ResolvedKeyFile { get; public set; }
    private static ResolveKeySource();
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_CertificateThumbprint();
    public void set_CertificateThumbprint(string value);
    public string get_CertificateFile();
    public void set_CertificateFile(string value);
    public bool get_SuppressAutoClosePasswordPrompt();
    public void set_SuppressAutoClosePasswordPrompt(bool value);
    public bool get_ShowImportDialogDespitePreviousFailures();
    public void set_ShowImportDialogDespitePreviousFailures(bool value);
    public int get_AutoClosePasswordPromptTimeout();
    public void set_AutoClosePasswordPromptTimeout(int value);
    public int get_AutoClosePasswordPromptShow();
    public void set_AutoClosePasswordPromptShow(int value);
    public string get_ResolvedThumbprint();
    public void set_ResolvedThumbprint(string value);
    public string get_ResolvedKeyContainer();
    public void set_ResolvedKeyContainer(string value);
    public string get_ResolvedKeyFile();
    public void set_ResolvedKeyFile(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ResolveManifestFiles : TaskExtension {
    public ITaskItem DeploymentManifestEntryPoint { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem[] ExtraFiles { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public ITaskItem[] ManagedAssemblies { get; public set; }
    public ITaskItem[] NativeAssemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputAssemblies { get; public set; }
    [OutputAttribute]
public ITaskItem OutputDeploymentManifestEntryPoint { get; public set; }
    [OutputAttribute]
public ITaskItem OutputEntryPoint { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputFiles { get; public set; }
    public ITaskItem[] PublishFiles { get; public set; }
    public ITaskItem[] SatelliteAssemblies { get; public set; }
    public string TargetCulture { get; public set; }
    public bool SigningManifests { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public ITaskItem get_DeploymentManifestEntryPoint();
    public void set_DeploymentManifestEntryPoint(ITaskItem value);
    public ITaskItem get_EntryPoint();
    public void set_EntryPoint(ITaskItem value);
    public ITaskItem[] get_ExtraFiles();
    public void set_ExtraFiles(ITaskItem[] value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_ManagedAssemblies();
    public void set_ManagedAssemblies(ITaskItem[] value);
    public ITaskItem[] get_NativeAssemblies();
    public void set_NativeAssemblies(ITaskItem[] value);
    public ITaskItem[] get_OutputAssemblies();
    public void set_OutputAssemblies(ITaskItem[] value);
    public ITaskItem get_OutputDeploymentManifestEntryPoint();
    public void set_OutputDeploymentManifestEntryPoint(ITaskItem value);
    public ITaskItem get_OutputEntryPoint();
    public void set_OutputEntryPoint(ITaskItem value);
    public ITaskItem[] get_OutputFiles();
    public void set_OutputFiles(ITaskItem[] value);
    public ITaskItem[] get_PublishFiles();
    public void set_PublishFiles(ITaskItem[] value);
    public ITaskItem[] get_SatelliteAssemblies();
    public void set_SatelliteAssemblies(ITaskItem[] value);
    public string get_TargetCulture();
    public void set_TargetCulture(string value);
    public bool get_SigningManifests();
    public void set_SigningManifests(bool value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ResolveNativeReference : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] NativeReferences { get; public set; }
    [RequiredAttribute]
public String[] AdditionalSearchPaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainingReferenceFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedPrerequisiteAssemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedComComponents { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedTypeLibraries { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedLooseTlbFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedLooseEtcFiles { get; public set; }
    public ITaskItem[] get_NativeReferences();
    public void set_NativeReferences(ITaskItem[] value);
    public String[] get_AdditionalSearchPaths();
    public void set_AdditionalSearchPaths(String[] value);
    public ITaskItem[] get_ContainingReferenceFiles();
    public void set_ContainingReferenceFiles(ITaskItem[] value);
    public ITaskItem[] get_ContainedPrerequisiteAssemblies();
    public void set_ContainedPrerequisiteAssemblies(ITaskItem[] value);
    public ITaskItem[] get_ContainedComComponents();
    public void set_ContainedComComponents(ITaskItem[] value);
    public ITaskItem[] get_ContainedTypeLibraries();
    public void set_ContainedTypeLibraries(ITaskItem[] value);
    public ITaskItem[] get_ContainedLooseTlbFiles();
    public void set_ContainedLooseTlbFiles(ITaskItem[] value);
    public ITaskItem[] get_ContainedLooseEtcFiles();
    public void set_ContainedLooseEtcFiles(ITaskItem[] value);
    public virtual bool Execute();
    internal bool ExtractFromManifest(ITaskItem taskItem, string path, Hashtable containingReferenceFilesTable, Hashtable containedPrerequisiteAssembliesTable, Hashtable containedComComponentsTable, Hashtable containedTypeLibrariesTable, Hashtable containedLooseTlbFilesTable, Hashtable containedLooseEtcFilesTable);
}
public class Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput : ResolveProjectBase {
    public string PreresolvedProjectOutputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedOutputPaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] UnresolvedProjectReferences { get; public set; }
    internal GetAssemblyNameDelegate GetAssemblyName { get; internal set; }
    public string get_PreresolvedProjectOutputs();
    public void set_PreresolvedProjectOutputs(string value);
    public ITaskItem[] get_ResolvedOutputPaths();
    public void set_ResolvedOutputPaths(ITaskItem[] value);
    public ITaskItem[] get_UnresolvedProjectReferences();
    public void set_UnresolvedProjectReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
internal GetAssemblyNameDelegate get_GetAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_GetAssemblyName(GetAssemblyNameDelegate value);
    public virtual bool Execute();
    internal bool ResolveProject(ITaskItem projectRef, ITaskItem& resolvedPath);
}
public abstract class Microsoft.Build.Tasks.ResolveProjectBase : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] ProjectReferences { get; public set; }
    public ITaskItem[] get_ProjectReferences();
    public void set_ProjectReferences(ITaskItem[] value);
    internal bool VerifyReferenceAttributes(ITaskItem reference, String& missingAttribute);
    internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsError);
    internal void CacheProjectElementsFromXml(string xmlString);
    protected string GetProjectItem(ITaskItem projectRef);
    protected XmlElement GetProjectElement(ITaskItem projectRef);
    protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath);
}
internal abstract class Microsoft.Build.Tasks.Resolver : object {
    protected string searchPathElement;
    protected GetAssemblyName getAssemblyName;
    protected FileExists fileExists;
    protected GetAssemblyRuntimeVersion getRuntimeVersion;
    protected Version targetedRuntimeVersion;
    protected ProcessorArchitecture targetProcessorArchitecture;
    protected bool compareProcessorArchitecture;
    public string SearchPath { get; }
    protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture);
    public abstract virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, ArrayList assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    public string get_SearchPath();
    protected bool ResolveAsFile(string fullPath, AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, ArrayList assembliesConsideredAndRejected);
    protected bool FileMatchesAssemblyName(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, string pathToCandidateAssembly, ResolutionSearchLocation searchLocation);
    protected string ResolveFromDirectory(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string directory, ArrayList assembliesConsideredAndRejected);
}
public class Microsoft.Build.Tasks.ResolveSDKReference : TaskExtension {
    [RequiredAttribute]
public ITaskItem[] SDKReferences { get; public set; }
    [RequiredAttribute]
public ITaskItem[] InstalledSDKs { get; public set; }
    public ITaskItem[] References { get; public set; }
    public string TargetedSDKConfiguration { get; public set; }
    public string TargetedSDKArchitecture { get; public set; }
    public bool LogResolutionErrorsAsWarnings { get; public set; }
    public bool Prefer32Bit { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedSDKReferences { get; private set; }
    private static ResolveSDKReference();
    public ITaskItem[] get_SDKReferences();
    public void set_SDKReferences(ITaskItem[] value);
    public ITaskItem[] get_InstalledSDKs();
    public void set_InstalledSDKs(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetedSDKConfiguration();
    [CompilerGeneratedAttribute]
public void set_TargetedSDKConfiguration(string value);
    [CompilerGeneratedAttribute]
public string get_TargetedSDKArchitecture();
    [CompilerGeneratedAttribute]
public void set_TargetedSDKArchitecture(string value);
    public bool get_LogResolutionErrorsAsWarnings();
    public void set_LogResolutionErrorsAsWarnings(bool value);
    public bool get_Prefer32Bit();
    public void set_Prefer32Bit(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ResolvedSDKReferences();
    [CompilerGeneratedAttribute]
private void set_ResolvedSDKReferences(ITaskItem[] value);
    public virtual bool Execute();
    internal static void VerifySDKDependsOn(TaskLoggingHelper log, HashSet`1<SDKReference> sdkReferenceItems);
    internal static String[] GetUnresolvedDependentSDKs(HashSet`1<SDKReference> sdkReferenceItems, List`1<string> dependentSDKs);
    internal static List`1<string> ParseDependsOnSDK(string dependsOnSDK);
    internal SDKReference ParseSDKReference(ITaskItem referenceItem);
}
internal class Microsoft.Build.Tasks.RuntimeSection : object {
    internal DependentAssembly[] DependentAssemblies { get; }
    internal void Read(XmlTextReader reader);
    internal DependentAssembly[] get_DependentAssemblies();
}
internal static class Microsoft.Build.Tasks.SdkToolsPathUtility : object {
    internal static FileExists FileInfoExists { get; }
    internal static FileExists get_FileInfoExists();
    internal static string GeneratePathToTool(FileExists fileExists, string currentArchitecture, string sdkToolsPath, string toolName, TaskLoggingHelper log, bool logErrorsAndWarnings);
    internal static string FindSDKToolUsingToolsLocationHelper(string toolName);
}
internal class Microsoft.Build.Tasks.SetAttributes : MulticastDelegate {
    public SetAttributes(object object, IntPtr method);
    public virtual void Invoke(string path, FileAttributes attributes);
    public virtual IAsyncResult BeginInvoke(string path, FileAttributes attributes, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastAccessTime : MulticastDelegate {
    public SetLastAccessTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastWriteTime : MulticastDelegate {
    public SetLastWriteTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.SGen : ToolTaskExtension {
    [RequiredAttribute]
public string BuildAssemblyName { get; public set; }
    [RequiredAttribute]
public string BuildAssemblyPath { get; public set; }
    [RequiredAttribute]
public bool ShouldGenerateSerializer { get; public set; }
    [RequiredAttribute]
public bool UseProxyTypes { get; public set; }
    public String[] References { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    [OutputAttribute]
public ITaskItem[] SerializationAssembly { get; public set; }
    public string SerializationAssemblyName { get; }
    public string SdkToolsPath { get; public set; }
    public string Platform { get; public set; }
    public String[] Types { get; public set; }
    protected string ToolName { get; }
    public void set_BuildAssemblyName(string value);
    public string get_BuildAssemblyName();
    public void set_BuildAssemblyPath(string value);
    public string get_BuildAssemblyPath();
    public void set_ShouldGenerateSerializer(bool value);
    public bool get_ShouldGenerateSerializer();
    public void set_UseProxyTypes(bool value);
    public bool get_UseProxyTypes();
    public void set_References(String[] value);
    public String[] get_References();
    public void set_KeyContainer(string value);
    public string get_KeyContainer();
    public void set_KeyFile(string value);
    public string get_KeyFile();
    public void set_DelaySign(bool value);
    public bool get_DelaySign();
    public void set_SerializationAssembly(ITaskItem[] value);
    public ITaskItem[] get_SerializationAssembly();
    public string get_SerializationAssemblyName();
    public void set_SdkToolsPath(string value);
    public string get_SdkToolsPath();
    public void set_Platform(string value);
    public string get_Platform();
    public void set_Types(String[] value);
    public String[] get_Types();
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
    protected virtual string GenerateCommandLineCommands();
}
public class Microsoft.Build.Tasks.SignFile : Task {
    [RequiredAttribute]
public string CertificateThumbprint { get; public set; }
    [RequiredAttribute]
public ITaskItem SigningTarget { get; public set; }
    public string TimestampUrl { get; public set; }
    public string get_CertificateThumbprint();
    public void set_CertificateThumbprint(string value);
    public ITaskItem get_SigningTarget();
    public void set_SigningTarget(ITaskItem value);
    public string get_TimestampUrl();
    public void set_TimestampUrl(string value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.SR : object {
    internal static string ClassDocComment;
    internal static string ClassComments1;
    internal static string ClassComments3;
    internal static string StringPropertyComment;
    internal static string StringPropertyTruncatedComment;
    internal static string NonStringPropertyComment;
    internal static string NonStringPropertyDetailedComment;
    internal static string CulturePropertyComment1;
    internal static string CulturePropertyComment2;
    internal static string ResMgrPropertyComment;
    internal static string MismatchedResourceName;
    internal static string InvalidIdentifier;
    public static ResourceManager Resources { get; }
    private static SR();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Build.Tasks.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Build.Tasks.SRDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class Microsoft.Build.Tasks.StateFileBase : object {
    internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log);
    internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType);
    internal static void DeleteFile(string stateFile, TaskLoggingHelper log);
}
internal static class Microsoft.Build.Tasks.StronglyTypedResourceBuilder : object {
    private static StronglyTypedResourceBuilder();
    internal static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static CodeCompileUnit Create(IDictionary resourceList, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static string VerifyResourceName(string key, CodeDomProvider provider);
}
internal class Microsoft.Build.Tasks.StrongNameException : Exception {
    internal StrongNameException(Exception innerException);
    protected StrongNameException(SerializationInfo info, StreamingContext context);
}
internal enum Microsoft.Build.Tasks.StrongNameLevel : Enum {
    public int value__;
    public static StrongNameLevel None;
    public static StrongNameLevel DelaySigned;
    public static StrongNameLevel FullySigned;
    public static StrongNameLevel Unknown;
}
internal static class Microsoft.Build.Tasks.StrongNameUtils : object {
    internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, StrongNameKeyPair& keyPair, Byte[]& publicKey);
    internal static void GetStrongNameKey(TaskLoggingHelper log, string keyFile, string keyContainer, StrongNameKeyPair& keyPair, Byte[]& publicKey);
    internal static StrongNameLevel GetAssemblyStrongNameLevel(string assemblyPath);
}
internal class Microsoft.Build.Tasks.SubsetListFinder : object {
    public static string SubsetListFolder { get; }
    internal SubsetListFinder(String[] subsetToSearchFor);
    private static SubsetListFinder();
    public static string get_SubsetListFolder();
    public String[] GetSubsetListPathsFromDisk(string frameworkDirectory);
}
internal class Microsoft.Build.Tasks.SystemState : StateFileBase {
    internal bool IsDirty { get; }
    internal SystemState(SerializationInfo info, StreamingContext context);
    private static SystemState();
    internal void SetInstalledAssemblyInformation(AssemblyTableInfo[] installedAssemblyTableInfos);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal bool get_IsDirty();
    internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue);
    internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue);
    internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetadataValue);
    internal FileExists CacheDelegate(FileExists fileExistsValue);
    internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue);
    internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAssemblyRuntimeVersion);
}
public abstract class Microsoft.Build.Tasks.TaskExtension : Task {
    public TaskLoggingHelper Log { get; }
    public TaskLoggingHelper get_Log();
}
internal class Microsoft.Build.Tasks.TaskItemSpecFilenameComparer : object {
    internal static IComparer comparer;
    internal static IComparer`1<ITaskItem> genericComparer;
    private static TaskItemSpecFilenameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual int Compare(ITaskItem x, ITaskItem y);
}
public class Microsoft.Build.Tasks.TaskLoggingHelperExtension : TaskLoggingHelper {
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
internal class Microsoft.Build.Tasks.TlbReference : AxTlbBaseReference {
    protected string OutputDirectory { get; }
    internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, IEnumerable`1<string> referenceFiles, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool hasTemporaryWrapper, bool delaySign, string keyFile, string keyContainer, bool noClassMembers, string targetProcessorArchitecture, bool includeTypeLibVersionInName, bool executeAsTool, string sdkToolsPath, IBuildEngine buildEngine, String[] environmentVariables);
    protected virtual string get_OutputDirectory();
    protected virtual string GetWrapperFileNameInternal(string typeLibName);
    internal static string GetWrapperFileName(string typeLibName);
    internal static string GetWrapperFileName(string typeLibName, bool includeTypeLibVersionInName, short majorVerNum, short minorVerNum);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
    internal bool GenerateWrapper(ComReferenceWrapperInfo& wrapperInfo);
    private sealed virtual override Assembly System.Runtime.InteropServices.ITypeLibImporterNotifySink.ResolveRef(object objTypeLib);
    private sealed virtual override void System.Runtime.InteropServices.ITypeLibImporterNotifySink.ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg);
}
public abstract class Microsoft.Build.Tasks.ToolTaskExtension : ToolTask {
    public TaskLoggingHelper Log { get; }
    protected bool HasLoggedErrors { get; }
    protected internal Hashtable Bag { get; }
    public TaskLoggingHelper get_Log();
    protected virtual bool get_HasLoggedErrors();
    protected internal Hashtable get_Bag();
    protected internal bool GetBoolParameterWithDefault(string parameterName, bool defaultValue);
    protected internal int GetIntParameterWithDefault(string parameterName, int defaultValue);
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
public class Microsoft.Build.Tasks.Touch : TaskExtension {
    public bool ForceTouch { get; public set; }
    public bool AlwaysCreate { get; public set; }
    public string Time { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] TouchedFiles { get; public set; }
    public bool get_ForceTouch();
    public void set_ForceTouch(bool value);
    public bool get_AlwaysCreate();
    public void set_AlwaysCreate(bool value);
    public string get_Time();
    public void set_Time(string value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_TouchedFiles();
    public void set_TouchedFiles(ITaskItem[] value);
    internal bool ExecuteImpl(FileExists fileExists, FileCreate fileCreate, GetAttributes fileGetAttributes, SetAttributes fileSetAttributes, SetLastAccessTime fileSetLastAccessTime, SetLastWriteTime fileSetLastWriteTime);
    public virtual bool Execute();
}
[GuidAttribute("00020406-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.UCOMICreateITypeLib {
    public abstract virtual void CreateTypeInfo();
    public abstract virtual void SetName();
    public abstract virtual void SetVersion();
    public abstract virtual void SetGuid();
    public abstract virtual void SetDocString();
    public abstract virtual void SetHelpFileName();
    public abstract virtual void SetHelpContext();
    public abstract virtual void SetLcid();
    public abstract virtual void SetLibFlags();
    public abstract virtual void SaveAllChanges();
}
internal enum Microsoft.Build.Tasks.UnificationReason : Enum {
    public int value__;
    public static UnificationReason DidntUnify;
    public static UnificationReason FrameworkRetarget;
    public static UnificationReason BecauseOfBindingRedirect;
}
internal class Microsoft.Build.Tasks.UnificationVersion : ValueType {
    internal string referenceFullPath;
    internal Version version;
    internal UnificationReason reason;
}
internal class Microsoft.Build.Tasks.UnifiedAssemblyName : object {
    public AssemblyNameExtension PreUnified { get; }
    public AssemblyNameExtension PostUnified { get; }
    public bool IsUnified { get; }
    public UnificationReason UnificationReason { get; }
    public bool IsPrerequisite { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public UnifiedAssemblyName(AssemblyNameExtension preUnified, AssemblyNameExtension postUnified, bool isUnified, UnificationReason unificationReason, bool isPrerequisite, Nullable`1<bool> isRedistRoot, string redistName);
    public AssemblyNameExtension get_PreUnified();
    public AssemblyNameExtension get_PostUnified();
    public bool get_IsUnified();
    public UnificationReason get_UnificationReason();
    public bool get_IsPrerequisite();
    public Nullable`1<bool> get_IsRedistRoot();
    public string get_RedistName();
}
public class Microsoft.Build.Tasks.UnregisterAssembly : AppDomainIsolatedTaskExtension {
    public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem[] TypeLibFiles { get; public set; }
    public ITaskItem AssemblyListFile { get; public set; }
    private static UnregisterAssembly();
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public ITaskItem[] get_TypeLibFiles();
    public void set_TypeLibFiles(ITaskItem[] value);
    public ITaskItem get_AssemblyListFile();
    public void set_AssemblyListFile(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.UpdateManifest : Task {
    [RequiredAttribute]
public string ApplicationPath { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    [RequiredAttribute]
public ITaskItem ApplicationManifest { get; public set; }
    [RequiredAttribute]
public ITaskItem InputManifest { get; public set; }
    [OutputAttribute]
public ITaskItem OutputManifest { get; public set; }
    public string get_ApplicationPath();
    public void set_ApplicationPath(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public ITaskItem get_ApplicationManifest();
    public void set_ApplicationManifest(ITaskItem value);
    public ITaskItem get_InputManifest();
    public void set_InputManifest(ITaskItem value);
    public ITaskItem get_OutputManifest();
    public void set_OutputManifest(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Vbc : ManagedCompiler {
    public string BaseAddress { get; public set; }
    public string DisabledWarnings { get; public set; }
    public string DocumentationFile { get; public set; }
    public string ErrorReport { get; public set; }
    public bool GenerateDocumentation { get; public set; }
    public ITaskItem[] Imports { get; public set; }
    public string LangVersion { get; public set; }
    public string ModuleAssemblyName { get; public set; }
    public bool NoStandardLib { get; public set; }
    public bool NoVBRuntimeReference { get; public set; }
    public bool NoWarnings { get; public set; }
    public string OptionCompare { get; public set; }
    public bool OptionExplicit { get; public set; }
    public bool OptionStrict { get; public set; }
    public bool OptionInfer { get; public set; }
    public string OptionStrictType { get; public set; }
    public bool RemoveIntegerChecks { get; public set; }
    public string RootNamespace { get; public set; }
    public string SdkPath { get; public set; }
    public bool TargetCompactFramework { get; public set; }
    public bool UseHostCompilerIfAvailable { get; public set; }
    public string VBRuntimePath { get; public set; }
    public string Verbosity { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    public string VBRuntime { get; public set; }
    public string PdbFile { get; public set; }
    protected string ToolName { get; }
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_DisabledWarnings(string value);
    public string get_DisabledWarnings();
    public void set_DocumentationFile(string value);
    public string get_DocumentationFile();
    public void set_ErrorReport(string value);
    public string get_ErrorReport();
    public void set_GenerateDocumentation(bool value);
    public bool get_GenerateDocumentation();
    public void set_Imports(ITaskItem[] value);
    public ITaskItem[] get_Imports();
    public void set_LangVersion(string value);
    public string get_LangVersion();
    public void set_ModuleAssemblyName(string value);
    public string get_ModuleAssemblyName();
    public void set_NoStandardLib(bool value);
    public bool get_NoStandardLib();
    public void set_NoVBRuntimeReference(bool value);
    public bool get_NoVBRuntimeReference();
    public void set_NoWarnings(bool value);
    public bool get_NoWarnings();
    public void set_OptionCompare(string value);
    public string get_OptionCompare();
    public void set_OptionExplicit(bool value);
    public bool get_OptionExplicit();
    public void set_OptionStrict(bool value);
    public bool get_OptionStrict();
    public void set_OptionInfer(bool value);
    public bool get_OptionInfer();
    public void set_OptionStrictType(string value);
    public string get_OptionStrictType();
    public void set_RemoveIntegerChecks(bool value);
    public bool get_RemoveIntegerChecks();
    public void set_RootNamespace(string value);
    public string get_RootNamespace();
    public void set_SdkPath(string value);
    public string get_SdkPath();
    public void set_TargetCompactFramework(bool value);
    public bool get_TargetCompactFramework();
    public void set_UseHostCompilerIfAvailable(bool value);
    public bool get_UseHostCompilerIfAvailable();
    public void set_VBRuntimePath(string value);
    public string get_VBRuntimePath();
    public void set_Verbosity(string value);
    public string get_Verbosity();
    public void set_WarningsAsErrors(string value);
    public string get_WarningsAsErrors();
    public void set_WarningsNotAsErrors(string value);
    public string get_WarningsNotAsErrors();
    public void set_VBRuntime(string value);
    public string get_VBRuntime();
    public void set_PdbFile(string value);
    public string get_PdbFile();
    protected virtual string get_ToolName();
    public virtual bool Execute();
    internal void MovePdbFileIfNecessary(string outputAssembly);
    protected virtual string GenerateFullPathToTool();
    internal string GetBaseAddressInHex();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected virtual bool ValidateParameters();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    internal void ParseVBErrorOrWarning(string singleLine, MessageImportance messageImportance);
    internal static string GetDefineConstantsSwitch(string originalDefineConstants);
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual bool CallHostObjectToExecute();
}
internal static class Microsoft.Build.Tasks.VisualBasicParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
}
public class Microsoft.Build.Tasks.Warning : TaskExtension {
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public string get_Text();
    public void set_Text(string value);
    public string get_Code();
    public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    public string get_HelpKeyword();
    public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
internal enum Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior : Enum {
    public int value__;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Error;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Warning;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior None;
}
public class Microsoft.Build.Tasks.WinMDExp : ToolTaskExtension {
    [RequiredAttribute]
public ITaskItem[] References { get; public set; }
    public string DisabledWarnings { get; public set; }
    public string InputDocumentationFile { get; public set; }
    public string OutputDocumentationFile { get; public set; }
    public string InputPDBFile { get; public set; }
    public string OutputPDBFile { get; public set; }
    [RequiredAttribute]
public string WinMDModule { get; public set; }
    [OutputAttribute]
public string OutputWindowsMetadataFile { get; public set; }
    public string SdkToolsPath { get; public set; }
    public bool UTF8Output { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    protected string ToolName { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    public ITaskItem[] get_References();
    public void set_References(ITaskItem[] value);
    public string get_DisabledWarnings();
    public void set_DisabledWarnings(string value);
    public string get_InputDocumentationFile();
    public void set_InputDocumentationFile(string value);
    public string get_OutputDocumentationFile();
    public void set_OutputDocumentationFile(string value);
    public string get_InputPDBFile();
    public void set_InputPDBFile(string value);
    public string get_OutputPDBFile();
    public void set_OutputPDBFile(string value);
    public string get_WinMDModule();
    public void set_WinMDModule(string value);
    public string get_OutputWindowsMetadataFile();
    public void set_OutputWindowsMetadataFile(string value);
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public bool get_UTF8Output();
    public void set_UTF8Output(bool value);
    public bool get_TreatWarningsAsErrors();
    public void set_TreatWarningsAsErrors(bool value);
    protected virtual string get_ToolName();
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
}
public class Microsoft.Build.Tasks.WriteCodeFragment : TaskExtension {
    [RequiredAttribute]
public string Language { get; public set; }
    public ITaskItem[] AssemblyAttributes { get; public set; }
    public ITaskItem OutputDirectory { get; public set; }
    [OutputAttribute]
public ITaskItem OutputFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssemblyAttributes();
    [CompilerGeneratedAttribute]
public void set_AssemblyAttributes(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.WriteLinesToFile : TaskExtension {
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    public ITaskItem[] Lines { get; public set; }
    public bool Overwrite { get; public set; }
    public string Encoding { get; public set; }
    public ITaskItem get_File();
    public void set_File(ITaskItem value);
    public ITaskItem[] get_Lines();
    public void set_Lines(ITaskItem[] value);
    public bool get_Overwrite();
    public void set_Overwrite(bool value);
    public string get_Encoding();
    public void set_Encoding(string value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.Xaml.Argument : object {
    public string Parameter { get; public set; }
    public string Separator { get; public set; }
    public bool Required { get; public set; }
    public string get_Parameter();
    public void set_Parameter(string value);
    public string get_Separator();
    public void set_Separator(string value);
    public bool get_Required();
    public void set_Required(bool value);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation : PropertyRelation {
    public string Separator { get; public set; }
    public CommandLineArgumentRelation(string argument, string value, bool required, string separator);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineGenerator : object {
    public string AdditionalOptions { get; public set; }
    public string CommandLineTemplate { get; public set; }
    public string AlwaysAppend { get; public set; }
    public CommandLineGenerator(Rule rule, Dictionary`2<string, object> parameterValues);
    internal CommandLineGenerator(Dictionary`2<string, CommandLineToolSwitch> activeCommandLineToolSwitches, IEnumerable`1<string> switchOrderList);
    public string get_AdditionalOptions();
    public void set_AdditionalOptions(string value);
    [CompilerGeneratedAttribute]
public string get_CommandLineTemplate();
    [CompilerGeneratedAttribute]
public void set_CommandLineTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_AlwaysAppend();
    [CompilerGeneratedAttribute]
public void set_AlwaysAppend(string value);
    public string GenerateCommandLine();
    internal void BuildAdditionalArgs(CommandLineBuilder cmdLine);
    internal void GenerateCommandsAccordingToType(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, bool recursive);
    internal bool VerifyRequiredArgumentsArePresent(CommandLineToolSwitch property, bool throwOnError);
    internal bool VerifyDependenciesArePresent(CommandLineToolSwitch property);
    internal bool IsPropertySet(string propertyName);
    internal bool HasSwitch(string propertyName);
    internal bool PropertyExists(string propertyName);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch : object {
    public string Name { get; public set; }
    public bool IncludeInCommandLine { get; public set; }
    public string Value { get; public set; }
    public bool IsValid { get; public set; }
    public string SwitchValue { get; public set; }
    public string ReverseSwitchValue { get; public set; }
    public ICollection`1<Tuple`2<string, bool>> Arguments { get; public set; }
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public CommandLineToolSwitchType Type { get; public set; }
    public bool Reversible { get; public set; }
    public bool AllowMultipleValues { get; public set; }
    public string FalseSuffix { get; public set; }
    public string TrueSuffix { get; public set; }
    public string Separator { get; public set; }
    public string FallbackArgumentParameter { get; public set; }
    public bool ArgumentRequired { get; public set; }
    public bool Required { get; public set; }
    public LinkedList`1<string> Parents { get; }
    public LinkedList`1<KeyValuePair`2<string, string>> Overrides { get; }
    public bool BooleanValue { get; public set; }
    public int Number { get; public set; }
    public String[] StringList { get; public set; }
    public ITaskItem[] TaskItemArray { get; public set; }
    public CommandLineToolSwitch(CommandLineToolSwitchType toolType);
    public string get_Name();
    public void set_Name(string value);
    public bool get_IncludeInCommandLine();
    public void set_IncludeInCommandLine(bool value);
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsValid();
    public void set_IsValid(bool value);
    public string get_SwitchValue();
    public void set_SwitchValue(string value);
    public string get_ReverseSwitchValue();
    public void set_ReverseSwitchValue(string value);
    public ICollection`1<Tuple`2<string, bool>> get_Arguments();
    public void set_Arguments(ICollection`1<Tuple`2<string, bool>> value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Description();
    public void set_Description(string value);
    public CommandLineToolSwitchType get_Type();
    public void set_Type(CommandLineToolSwitchType value);
    public bool get_Reversible();
    public void set_Reversible(bool value);
    public bool get_AllowMultipleValues();
    public void set_AllowMultipleValues(bool value);
    public string get_FalseSuffix();
    public void set_FalseSuffix(string value);
    public string get_TrueSuffix();
    public void set_TrueSuffix(string value);
    public string get_Separator();
    public void set_Separator(string value);
    public string get_FallbackArgumentParameter();
    public void set_FallbackArgumentParameter(string value);
    [CompilerGeneratedAttribute]
public bool get_ArgumentRequired();
    [CompilerGeneratedAttribute]
public void set_ArgumentRequired(bool value);
    public bool get_Required();
    public void set_Required(bool value);
    public LinkedList`1<string> get_Parents();
    public LinkedList`1<KeyValuePair`2<string, string>> get_Overrides();
    public bool get_BooleanValue();
    public void set_BooleanValue(bool value);
    public int get_Number();
    public void set_Number(int value);
    public String[] get_StringList();
    public void set_StringList(String[] value);
    public ITaskItem[] get_TaskItemArray();
    public void set_TaskItemArray(ITaskItem[] value);
}
public enum Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType : Enum {
    public int value__;
    public static CommandLineToolSwitchType Boolean;
    public static CommandLineToolSwitchType Integer;
    public static CommandLineToolSwitchType String;
    public static CommandLineToolSwitchType StringArray;
    public static CommandLineToolSwitchType ITaskItemArray;
}
internal class Microsoft.Build.Tasks.Xaml.Property : object {
    public PropertyType Type { get; public set; }
    public bool IncludeInCommandLine { get; public set; }
    public string Reversible { get; public set; }
    public string SwitchName { get; public set; }
    public string ReverseSwitchName { get; public set; }
    public string FalseSuffix { get; public set; }
    public string TrueSuffix { get; public set; }
    public string Max { get; public set; }
    public string Min { get; public set; }
    public string Separator { get; public set; }
    public string DefaultValue { get; public set; }
    public string Argument { get; public set; }
    public string Fallback { get; public set; }
    public string Required { get; public set; }
    public bool Output { get; public set; }
    public LinkedList`1<string> Parents { get; }
    public string Name { get; public set; }
    public LinkedList`1<Property> DependentArgumentProperties { get; }
    public List`1<Value> Values { get; }
    public string Prefix { get; public set; }
    public string Category { get; public set; }
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    public PropertyType get_Type();
    public void set_Type(PropertyType value);
    public bool get_IncludeInCommandLine();
    public void set_IncludeInCommandLine(bool value);
    public string get_Reversible();
    public void set_Reversible(string value);
    public string get_SwitchName();
    public void set_SwitchName(string value);
    public string get_ReverseSwitchName();
    public void set_ReverseSwitchName(string value);
    public string get_FalseSuffix();
    public void set_FalseSuffix(string value);
    public string get_TrueSuffix();
    public void set_TrueSuffix(string value);
    public string get_Max();
    public void set_Max(string value);
    public string get_Min();
    public void set_Min(string value);
    public string get_Separator();
    public void set_Separator(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_Argument();
    public void set_Argument(string value);
    public string get_Fallback();
    public void set_Fallback(string value);
    public string get_Required();
    public void set_Required(string value);
    public bool get_Output();
    public void set_Output(bool value);
    public LinkedList`1<string> get_Parents();
    public string get_Name();
    public void set_Name(string value);
    public LinkedList`1<Property> get_DependentArgumentProperties();
    public List`1<Value> get_Values();
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Category();
    public void set_Category(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Description();
    public void set_Description(string value);
    public List`1<Argument> get_Arguments();
    public void set_Arguments(List`1<Argument> value);
    public Property Clone();
}
public class Microsoft.Build.Tasks.Xaml.PropertyRelation : object {
    public string Argument { get; public set; }
    public string Value { get; public set; }
    public bool Required { get; public set; }
    public PropertyRelation(string argument, string value, bool required);
    [CompilerGeneratedAttribute]
public string get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
internal enum Microsoft.Build.Tasks.Xaml.PropertyType : Enum {
    public int value__;
    public static PropertyType None;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Integer;
    public static PropertyType StringArray;
    public static PropertyType ItemArray;
}
internal class Microsoft.Build.Tasks.Xaml.RelationsParser : object {
    public string GeneratedTaskName { get; public set; }
    public string BaseClass { get; }
    public string Namespace { get; }
    public string ResourceNamespace { get; }
    public string ToolName { get; }
    public string DefaultPrefix { get; }
    public LinkedList`1<Property> Properties { get; }
    public LinkedList`1<Property> DefaultSet { get; }
    public Dictionary`2<string, string> FallbackSet { get; }
    public int ErrorCount { get; }
    public LinkedList`1<string> ErrorLog { get; }
    public Dictionary`2<string, SwitchRelations> SwitchRelationsList { get; }
    public string get_GeneratedTaskName();
    public void set_GeneratedTaskName(string value);
    public string get_BaseClass();
    public string get_Namespace();
    public string get_ResourceNamespace();
    public string get_ToolName();
    public string get_DefaultPrefix();
    public LinkedList`1<Property> get_Properties();
    public LinkedList`1<Property> get_DefaultSet();
    public Dictionary`2<string, string> get_FallbackSet();
    public int get_ErrorCount();
    public LinkedList`1<string> get_ErrorLog();
    public Dictionary`2<string, SwitchRelations> get_SwitchRelationsList();
    internal XmlDocument LoadXml(string xml);
    public bool ParseXmlDocument(string fileName);
    internal bool ParseXmlDocument(XmlDocument xmlDocument);
}
internal class Microsoft.Build.Tasks.Xaml.SwitchRelations : object {
    public string SwitchValue { get; public set; }
    public string Status { get; public set; }
    public List`1<string> Conflicts { get; public set; }
    public List`1<string> IncludedPlatforms { get; public set; }
    public List`1<string> ExcludedPlatforms { get; public set; }
    public List`1<string> Overrides { get; public set; }
    public List`1<string> Requires { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalOverrides { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalConflicts { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalRequires { get; public set; }
    public SwitchRelations Clone();
    public string get_SwitchValue();
    public void set_SwitchValue(string value);
    public string get_Status();
    public void set_Status(string value);
    public List`1<string> get_Conflicts();
    public void set_Conflicts(List`1<string> value);
    public List`1<string> get_IncludedPlatforms();
    public void set_IncludedPlatforms(List`1<string> value);
    public List`1<string> get_ExcludedPlatforms();
    public void set_ExcludedPlatforms(List`1<string> value);
    public List`1<string> get_Overrides();
    public void set_Overrides(List`1<string> value);
    public List`1<string> get_Requires();
    public void set_Requires(List`1<string> value);
    public Dictionary`2<string, List`1<string>> get_ExternalOverrides();
    public void set_ExternalOverrides(Dictionary`2<string, List`1<string>> value);
    public Dictionary`2<string, List`1<string>> get_ExternalConflicts();
    public void set_ExternalConflicts(Dictionary`2<string, List`1<string>> value);
    public Dictionary`2<string, List`1<string>> get_ExternalRequires();
    public void set_ExternalRequires(Dictionary`2<string, List`1<string>> value);
}
internal class Microsoft.Build.Tasks.Xaml.TaskGenerator : object {
    public bool GenerateComments { get; public set; }
    internal int ErrorCount { get; }
    internal LinkedList`1<string> ErrorLog { get; }
    internal TaskGenerator(TaskParser parser);
    [CompilerGeneratedAttribute]
public bool get_GenerateComments();
    [CompilerGeneratedAttribute]
public void set_GenerateComments(bool value);
    internal void RemovePropertiesWithIgnoredTypes(LinkedList`1<Property> propertyList);
    internal CodeCompileUnit GenerateCode();
    internal int get_ErrorCount();
    internal LinkedList`1<string> get_ErrorLog();
}
internal class Microsoft.Build.Tasks.Xaml.TaskParser : object {
    public string GeneratedTaskName { get; public set; }
    public string BaseClass { get; }
    public string Namespace { get; }
    public string ResourceNamespace { get; }
    public string ToolName { get; }
    public string DefaultPrefix { get; }
    public LinkedList`1<Property> Properties { get; }
    public LinkedList`1<Property> DefaultSet { get; }
    public Dictionary`2<string, string> FallbackSet { get; }
    public IEnumerable`1<string> SwitchOrderList { get; }
    public LinkedList`1<string> ErrorLog { get; }
    public string get_GeneratedTaskName();
    public void set_GeneratedTaskName(string value);
    public string get_BaseClass();
    public string get_Namespace();
    public string get_ResourceNamespace();
    public string get_ToolName();
    public string get_DefaultPrefix();
    public LinkedList`1<Property> get_Properties();
    public LinkedList`1<Property> get_DefaultSet();
    public Dictionary`2<string, string> get_FallbackSet();
    public IEnumerable`1<string> get_SwitchOrderList();
    public LinkedList`1<string> get_ErrorLog();
    public bool Parse(string contentOrFile, string desiredRule);
    internal bool ParseXamlDocument(TextReader reader, string desiredRule);
    internal bool ParseXamlDocument(Rule rule);
}
internal class Microsoft.Build.Tasks.Xaml.Value : object {
    public string Name { get; public set; }
    public string SwitchName { get; public set; }
    public string ReverseSwitchName { get; public set; }
    public string Description { get; public set; }
    public string DisplayName { get; public set; }
    public string Prefix { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_SwitchName();
    public void set_SwitchName(string value);
    public string get_ReverseSwitchName();
    public void set_ReverseSwitchName(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public List`1<Argument> get_Arguments();
    public void set_Arguments(List`1<Argument> value);
}
public abstract class Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask : ToolTask {
    public string CommandLineTemplate { get; public set; }
    public string AdditionalOptions { get; public set; }
    public String[] AcceptableNonZeroExitCodes { get; public set; }
    public Dictionary`2<string, CommandLineToolSwitch> ActiveToolSwitchesValues { get; public set; }
    internal IEnumerable`1<string> SwitchOrderList { get; }
    protected internal Dictionary`2<string, CommandLineToolSwitch> ActiveToolSwitches { get; }
    protected Encoding ResponseFileEncoding { get; }
    protected XamlDataDrivenToolTask(String[] switchOrderList, ResourceManager taskResources);
    [CompilerGeneratedAttribute]
public string get_CommandLineTemplate();
    [CompilerGeneratedAttribute]
public void set_CommandLineTemplate(string value);
    public string get_AdditionalOptions();
    public void set_AdditionalOptions(string value);
    public virtual String[] get_AcceptableNonZeroExitCodes();
    public virtual void set_AcceptableNonZeroExitCodes(String[] value);
    public Dictionary`2<string, CommandLineToolSwitch> get_ActiveToolSwitchesValues();
    public void set_ActiveToolSwitchesValues(Dictionary`2<string, CommandLineToolSwitch> value);
    internal virtual IEnumerable`1<string> get_SwitchOrderList();
    protected internal Dictionary`2<string, CommandLineToolSwitch> get_ActiveToolSwitches();
    protected virtual Encoding get_ResponseFileEncoding();
    public bool IsPropertySet(string propertyName);
    public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd);
    public void AddActiveSwitchToolValue(CommandLineToolSwitch switchToAdd);
    public virtual bool Execute();
    internal string GetCommandLine_ForUnitTestsOnly();
    internal bool HasSwitch(string propertyName);
    internal bool IsAcceptableReturnValue();
    internal void PostProcessSwitchList();
    internal void ValidateRelations();
    internal void ValidateOverrides();
    protected virtual string GenerateResponseFileCommands();
    protected virtual bool HandleTaskExecutionErrors();
    public bool ValidateInteger(string switchName, int min, int max, int value);
    public string ReadSwitchMap(string propertyName, String[][] switchMap, string value);
    public int ReadSwitchMap2(string propertyName, Tuple`3[] switchMap, string value);
    public string CreateSwitchValue(string propertyName, string baseSwitch, string separator, Tuple`2[] arguments);
    internal void InitializeLogger(ResourceManager taskResources);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual string GenerateCommandLineCommands();
}
public class Microsoft.Build.Tasks.XamlTaskFactory : object {
    public string TaskName { get; private set; }
    public string TaskNamespace { get; private set; }
    public string TaskElementContents { get; private set; }
    public string FactoryName { get; }
    public Type TaskType { get; }
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
private void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public string get_TaskNamespace();
    [CompilerGeneratedAttribute]
private void set_TaskNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_TaskElementContents();
    [CompilerGeneratedAttribute]
private void set_TaskElementContents(string value);
    public sealed virtual string get_FactoryName();
    public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
}
public class Microsoft.Build.Tasks.XmlPeek : TaskExtension {
    public ITaskItem XmlInputPath { get; public set; }
    public string XmlContent { get; public set; }
    public string Query { get; public set; }
    [OutputAttribute]
public ITaskItem[] Result { get; }
    public string Namespaces { get; public set; }
    public ITaskItem get_XmlInputPath();
    public void set_XmlInputPath(ITaskItem value);
    public string get_XmlContent();
    public void set_XmlContent(string value);
    public string get_Query();
    public void set_Query(string value);
    public ITaskItem[] get_Result();
    public string get_Namespaces();
    public void set_Namespaces(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.XmlPoke : TaskExtension {
    public ITaskItem XmlInputPath { get; public set; }
    public string Query { get; public set; }
    [RequiredAttribute]
public ITaskItem Value { get; public set; }
    public string Namespaces { get; public set; }
    public ITaskItem get_XmlInputPath();
    public void set_XmlInputPath(ITaskItem value);
    public string get_Query();
    public void set_Query(string value);
    public ITaskItem get_Value();
    public void set_Value(ITaskItem value);
    public string get_Namespaces();
    public void set_Namespaces(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.XslTransformation : TaskExtension {
    public ITaskItem[] XmlInputPaths { get; public set; }
    public string XmlContent { get; public set; }
    public ITaskItem XslInputPath { get; public set; }
    public string XslContent { get; public set; }
    public ITaskItem XslCompiledDllPath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] OutputPaths { get; public set; }
    public string Parameters { get; public set; }
    public ITaskItem[] get_XmlInputPaths();
    public void set_XmlInputPaths(ITaskItem[] value);
    public string get_XmlContent();
    public void set_XmlContent(string value);
    public ITaskItem get_XslInputPath();
    public void set_XslInputPath(ITaskItem value);
    public string get_XslContent();
    public void set_XslContent(string value);
    public ITaskItem get_XslCompiledDllPath();
    public void set_XslCompiledDllPath(ITaskItem value);
    public ITaskItem[] get_OutputPaths();
    public void set_OutputPaths(ITaskItem[] value);
    public string get_Parameters();
    public void set_Parameters(string value);
    public virtual bool Execute();
}
internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData);
    internal CodeMarkerExStartEnd(int begin, int end, UInt32 uintData);
    internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    public bool IsEnabled { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    internal CodeMarkerStartEnd(int begin, int end);
    public sealed virtual void Dispose();
}
[SecurityCriticalAttribute]
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
internal interface Microsoft.Runtime.Hosting.IClrStrongName {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
[SecurityCriticalAttribute]
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
internal interface Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
internal static class Microsoft.Runtime.Hosting.StrongNameHelpers : object {
    [SecurityCriticalAttribute]
public static int StrongNameErrorInfo();
    [SecurityCriticalAttribute]
public static void StrongNameFreeBuffer(IntPtr pbMemory);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyDelete(string pwzKeyContainer);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& pdwOutFlags);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& pfWasVerified);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
}
internal class System.Deployment.Internal.CodeSigning.BLOBHEADER : ValueType {
    internal byte bType;
    internal byte bVersion;
    internal short reserved;
    internal UInt32 aiKeyAlg;
}
internal class System.Deployment.Internal.CodeSigning.CmiAuthenticodeSignerInfo : object {
    internal int ErrorCode { get; internal set; }
    internal UInt32 HashAlgId { get; internal set; }
    internal string Hash { get; internal set; }
    internal string Description { get; internal set; }
    internal string DescriptionUrl { get; internal set; }
    internal CmiAuthenticodeTimestamperInfo TimestamperInfo { get; }
    internal X509Chain SignerChain { get; internal set; }
    internal CmiAuthenticodeSignerInfo(int errorCode);
    internal CmiAuthenticodeSignerInfo(AXL_SIGNER_INFO signerInfo, AXL_TIMESTAMPER_INFO timestamperInfo);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    internal UInt32 get_HashAlgId();
    internal void set_HashAlgId(UInt32 value);
    internal string get_Hash();
    internal void set_Hash(string value);
    internal string get_Description();
    internal void set_Description(string value);
    internal string get_DescriptionUrl();
    internal void set_DescriptionUrl(string value);
    internal CmiAuthenticodeTimestamperInfo get_TimestamperInfo();
    internal X509Chain get_SignerChain();
    internal void set_SignerChain(X509Chain value);
}
internal class System.Deployment.Internal.CodeSigning.CmiAuthenticodeTimestamperInfo : object {
    internal int ErrorCode { get; }
    internal UInt32 HashAlgId { get; }
    internal DateTime TimestampTime { get; }
    internal X509Chain TimestamperChain { get; }
    internal CmiAuthenticodeTimestamperInfo(AXL_TIMESTAMPER_INFO timestamperInfo);
    internal int get_ErrorCode();
    internal UInt32 get_HashAlgId();
    internal DateTime get_TimestampTime();
    internal X509Chain get_TimestamperChain();
}
internal class System.Deployment.Internal.CodeSigning.CmiManifestSigner : object {
    internal static UInt32 CimManifestSignerFlagMask;
    internal AsymmetricAlgorithm StrongNameKey { get; }
    internal X509Certificate2 Certificate { get; }
    internal string Description { get; internal set; }
    internal string DescriptionUrl { get; internal set; }
    internal X509Certificate2Collection ExtraStore { get; }
    internal X509IncludeOption IncludeOption { get; internal set; }
    internal CmiManifestSignerFlag Flag { get; internal set; }
    internal CmiManifestSigner(AsymmetricAlgorithm strongNameKey);
    internal CmiManifestSigner(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate);
    internal AsymmetricAlgorithm get_StrongNameKey();
    internal X509Certificate2 get_Certificate();
    internal string get_Description();
    internal void set_Description(string value);
    internal string get_DescriptionUrl();
    internal void set_DescriptionUrl(string value);
    internal X509Certificate2Collection get_ExtraStore();
    internal X509IncludeOption get_IncludeOption();
    internal void set_IncludeOption(X509IncludeOption value);
    internal CmiManifestSignerFlag get_Flag();
    internal void set_Flag(CmiManifestSignerFlag value);
}
internal class System.Deployment.Internal.CodeSigning.CmiManifestSigner2 : object {
    internal static UInt32 CimManifestSignerFlagMask;
    internal bool UseSha256 { get; }
    internal AsymmetricAlgorithm StrongNameKey { get; }
    internal X509Certificate2 Certificate { get; }
    internal string Description { get; internal set; }
    internal string DescriptionUrl { get; internal set; }
    internal X509Certificate2Collection ExtraStore { get; }
    internal X509IncludeOption IncludeOption { get; internal set; }
    internal CmiManifestSignerFlag Flag { get; internal set; }
    internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey);
    internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256);
    internal bool get_UseSha256();
    internal AsymmetricAlgorithm get_StrongNameKey();
    internal X509Certificate2 get_Certificate();
    internal string get_Description();
    internal void set_Description(string value);
    internal string get_DescriptionUrl();
    internal void set_DescriptionUrl(string value);
    internal X509Certificate2Collection get_ExtraStore();
    internal X509IncludeOption get_IncludeOption();
    internal void set_IncludeOption(X509IncludeOption value);
    internal CmiManifestSignerFlag get_Flag();
    internal void set_Flag(CmiManifestSignerFlag value);
}
[FlagsAttribute]
internal enum System.Deployment.Internal.CodeSigning.CmiManifestSignerFlag : Enum {
    public int value__;
    public static CmiManifestSignerFlag None;
    public static CmiManifestSignerFlag DontReplacePublicKeyToken;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags : Enum {
    public int value__;
    public static CmiManifestVerifyFlags None;
    public static CmiManifestVerifyFlags RevocationNoCheck;
    public static CmiManifestVerifyFlags RevocationCheckEndCertOnly;
    public static CmiManifestVerifyFlags RevocationCheckEntireChain;
    public static CmiManifestVerifyFlags UrlCacheOnlyRetrieval;
    public static CmiManifestVerifyFlags LifetimeSigning;
    public static CmiManifestVerifyFlags TrustMicrosoftRootOnly;
    public static CmiManifestVerifyFlags StrongNameOnly;
}
internal class System.Deployment.Internal.CodeSigning.CmiStrongNameSignerInfo : object {
    internal int ErrorCode { get; internal set; }
    internal string PublicKeyToken { get; internal set; }
    internal AsymmetricAlgorithm PublicKey { get; internal set; }
    internal CmiStrongNameSignerInfo(int errorCode, string publicKeyToken);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    internal string get_PublicKeyToken();
    internal void set_PublicKeyToken(string value);
    internal AsymmetricAlgorithm get_PublicKey();
    internal void set_PublicKey(AsymmetricAlgorithm value);
}
internal class System.Deployment.Internal.CodeSigning.ManifestSignedXml : SignedXml {
    internal ManifestSignedXml(XmlElement elem);
    internal ManifestSignedXml(XmlDocument document);
    internal ManifestSignedXml(XmlDocument document, bool verify);
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
}
internal class System.Deployment.Internal.CodeSigning.ManifestSignedXml2 : SignedXml {
    internal ManifestSignedXml2(XmlElement elem);
    internal ManifestSignedXml2(XmlDocument document);
    internal ManifestSignedXml2(XmlDocument document, bool verify);
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
}
public class System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription : SignatureDescription {
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
internal class System.Deployment.Internal.CodeSigning.SignedCmiManifest : object {
    internal CmiStrongNameSignerInfo StrongNameSignerInfo { get; }
    internal CmiAuthenticodeSignerInfo AuthenticodeSignerInfo { get; }
    internal SignedCmiManifest(XmlDocument manifestDom);
    private static SignedCmiManifest();
    internal void Sign(CmiManifestSigner signer);
    internal void Sign(CmiManifestSigner signer, string timeStampUrl);
    internal void Verify(CmiManifestVerifyFlags verifyFlags);
    internal CmiStrongNameSignerInfo get_StrongNameSignerInfo();
    internal CmiAuthenticodeSignerInfo get_AuthenticodeSignerInfo();
}
internal class System.Deployment.Internal.CodeSigning.SignedCmiManifest2 : object {
    internal CmiStrongNameSignerInfo StrongNameSignerInfo { get; }
    internal CmiAuthenticodeSignerInfo AuthenticodeSignerInfo { get; }
    internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256);
    private static SignedCmiManifest2();
    internal void Sign(CmiManifestSigner2 signer);
    internal void Sign(CmiManifestSigner2 signer, string timeStampUrl);
    internal void Verify(CmiManifestVerifyFlags verifyFlags);
    internal CmiStrongNameSignerInfo get_StrongNameSignerInfo();
    internal CmiAuthenticodeSignerInfo get_AuthenticodeSignerInfo();
    internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256);
}
internal static class System.Deployment.Internal.CodeSigning.Win32 : object {
    internal static string CRYPT32;
    internal static string KERNEL32;
    internal static string MSCORWKS;
    internal static int S_OK;
    internal static int NTE_BAD_HASH;
    internal static int NTE_BAD_KEY;
    internal static int TRUST_E_SYSTEM_ERROR;
    internal static int TRUST_E_NO_SIGNER_CERT;
    internal static int TRUST_E_COUNTER_SIGNER;
    internal static int TRUST_E_CERT_SIGNATURE;
    internal static int TRUST_E_TIME_STAMP;
    internal static int TRUST_E_BAD_DIGEST;
    internal static int TRUST_E_BASIC_CONSTRAINTS;
    internal static int TRUST_E_FINANCIAL_CRITERIA;
    internal static int TRUST_E_PROVIDER_UNKNOWN;
    internal static int TRUST_E_ACTION_UNKNOWN;
    internal static int TRUST_E_SUBJECT_FORM_UNKNOWN;
    internal static int TRUST_E_SUBJECT_NOT_TRUSTED;
    internal static int TRUST_E_NOSIGNATURE;
    internal static int CERT_E_UNTRUSTEDROOT;
    internal static int TRUST_E_FAIL;
    internal static int TRUST_E_EXPLICIT_DISTRUST;
    internal static int CERT_E_CHAINING;
    internal static int AXL_REVOCATION_NO_CHECK;
    internal static int AXL_REVOCATION_CHECK_END_CERT_ONLY;
    internal static int AXL_REVOCATION_CHECK_ENTIRE_CHAIN;
    internal static int AXL_URL_CACHE_ONLY_RETRIEVAL;
    internal static int AXL_LIFETIME_SIGNING;
    internal static int AXL_TRUST_MICROSOFT_ROOT_ONLY;
    internal static int WTPF_IGNOREREVOKATION;
    internal static string szOID_KP_LIFETIME_SIGNING;
    internal static string szOID_RSA_signingTime;
    internal static string szOID_OIWSEC_sha1;
    internal static string szOID_NIST_sha256;
    internal static string szOID_RSA_messageDigest;
    internal static string szOID_PKIX_KP_TIMESTAMP_SIGNING;
    internal static IntPtr GetProcessHeap();
    internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
    internal static int CertTimestampAuthenticodeLicense(CRYPT_DATA_BLOB& pSignedLicenseBlob, string pwszTimestampURI, CRYPT_DATA_BLOB& pTimestampSignatureBlob);
    internal static int CertVerifyAuthenticodeLicense(CRYPT_DATA_BLOB& pLicenseBlob, UInt32 dwFlags, AXL_SIGNER_INFO& pSignerInfo, AXL_TIMESTAMPER_INFO& pTimestamperInfo);
    internal static int CertFreeAuthenticodeSignerInfo(AXL_SIGNER_INFO& pSignerInfo);
    internal static int CertFreeAuthenticodeTimestamperInfo(AXL_TIMESTAMPER_INFO& pTimestamperInfo);
    internal static int _AxlGetIssuerPublicKeyHash(IntPtr pCertContext, IntPtr& ppwszPublicKeyHash);
    internal static int _AxlRSAKeyValueToPublicKeyToken(CRYPT_DATA_BLOB& pModulusBlob, CRYPT_DATA_BLOB& pExponentBlob, IntPtr& ppwszPublicKeyToken);
    internal static int _AxlPublicKeyBlobToPublicKeyToken(CRYPT_DATA_BLOB& pCspPublicKeyBlob, IntPtr& ppwszPublicKeyToken);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, UInt32 dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptVerifyTimeStampSignature(Byte[] pbTSContentInfo, int cbTSContentInfo, Byte[] pbData, int cbData, IntPtr hAdditionalStore, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
}
internal static class System.Security.Cryptography.CngLightup : object {
    private static CngLightup();
    internal static RSA GetRSAPublicKey(X509Certificate2 cert);
    internal static RSA GetRSAPrivateKey(X509Certificate2 cert);
    internal static DSA GetDSAPublicKey(X509Certificate2 cert);
    internal static DSA GetDSAPrivateKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPrivateKey(X509Certificate2 cert);
    internal static Byte[] Pkcs1SignData(RSA rsa, Byte[] data, string hashAlgorithmName);
    internal static bool Pkcs1VerifyData(RSA rsa, Byte[] data, Byte[] signature, string hashAlgorithmName);
    internal static Byte[] Pkcs1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] Pkcs1Decrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Decrypt(RSA rsa, Byte[] data);
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
