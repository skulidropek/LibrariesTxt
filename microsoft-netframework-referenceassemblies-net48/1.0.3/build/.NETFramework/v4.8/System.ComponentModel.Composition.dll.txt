internal static class Microsoft.Internal.Assumes : object {
    [DebuggerStepThroughAttribute]
internal static void NotNull(T value);
    [DebuggerStepThroughAttribute]
internal static void NotNull(T1 value1, T2 value2);
    [DebuggerStepThroughAttribute]
internal static void NotNull(T1 value1, T2 value2, T3 value3);
    [DebuggerStepThroughAttribute]
internal static void NotNullOrEmpty(string value);
    [DebuggerStepThroughAttribute]
internal static void IsTrue(bool condition);
    [DebuggerStepThroughAttribute]
internal static void IsTrue(bool condition, string message);
    [DebuggerStepThroughAttribute]
internal static T NotReachable();
}
[ExtensionAttribute]
internal static class Microsoft.Internal.AttributeServices : object {
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static T GetFirstAttribute(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static T GetFirstAttribute(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static bool IsAttributeDefined(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static bool IsAttributeDefined(ICustomAttributeProvider attributeProvider, bool inherit);
}
internal class Microsoft.Internal.BinaryCompatibility : object {
    public static bool TargetsAtLeast_Desktop_V4_5 { get; private set; }
    private static BinaryCompatibility();
    [CompilerGeneratedAttribute]
public static bool get_TargetsAtLeast_Desktop_V4_5();
    [CompilerGeneratedAttribute]
private static void set_TargetsAtLeast_Desktop_V4_5(bool value);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.Collections.CollectionServices : object {
    private static CollectionServices();
    public static bool IsEnumerableOfT(Type type);
    public static Type GetEnumerableElementType(Type type);
    public static Type GetCollectionElementType(Type type);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> ConcatAllowingNull(IEnumerable`1<T> source, IEnumerable`1<T> second);
    [ExtensionAttribute]
public static ICollection`1<T> ConcatAllowingNull(ICollection`1<T> source, ICollection`1<T> second);
    [ExtensionAttribute]
public static List`1<T> FastAppendToListAllowNulls(List`1<T> source, IEnumerable`1<T> second);
    [ExtensionAttribute]
public static List`1<T> FastAppendToListAllowNulls(List`1<T> source, T value, IEnumerable`1<T> second);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static EnumerableCardinality GetCardinality(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool FastAny(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Stack`1<T> Copy(Stack`1<T> stack);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool IsArrayEqual(T[] thisArray, T[] thatArray);
    [ExtensionAttribute]
public static bool IsCollectionEqual(IList`1<T> thisList, IList`1<T> thatList);
    public static ICollection`1<object> GetCollectionWrapper(Type itemType, object collectionObject);
}
internal enum Microsoft.Internal.Collections.EnumerableCardinality : Enum {
    public int value__;
    public static EnumerableCardinality Zero;
    public static EnumerableCardinality One;
    public static EnumerableCardinality TwoOrMore;
}
internal class Microsoft.Internal.Collections.WeakReferenceCollection`1 : object {
    public void Add(T item);
    public void Remove(T item);
    public bool Contains(T item);
    public void Clear();
    public List`1<T> AliveItemsToList();
}
internal static class Microsoft.Internal.ContractServices : object {
    public static bool TryCast(Type contractType, object value, Object& result);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.GenerationServices : object {
    private static GenerationServices();
    [ExtensionAttribute]
public static ILGenerator CreateGeneratorForPublicConstructor(TypeBuilder typeBuilder, Type[] ctrArgumentTypes);
    [ExtensionAttribute]
public static void LoadValue(ILGenerator ilGenerator, object value);
    [ExtensionAttribute]
public static void AddItemToLocalDictionary(ILGenerator ilGenerator, LocalBuilder dictionary, object key, object value);
    [ExtensionAttribute]
public static void AddLocalToLocalDictionary(ILGenerator ilGenerator, LocalBuilder dictionary, object key, LocalBuilder value);
    [ExtensionAttribute]
public static void GetExceptionDataAndStoreInLocal(ILGenerator ilGenerator, LocalBuilder exception, LocalBuilder dataStore);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.LazyServices : object {
    [ExtensionAttribute]
public static T GetNotNullValue(Lazy`1<T> lazy, string argument);
}
internal class Microsoft.Internal.Lock : object {
    public void EnterReadLock();
    public void EnterWriteLock();
    public void ExitReadLock();
    public void ExitWriteLock();
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.ReadLock : ValueType {
    private Lock _lock;
    private int _isDisposed;
    public ReadLock(Lock lock);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.Internal.ReflectionInvoke : object {
    private static ReflectionInvoke();
    [ExtensionAttribute]
public static object SafeCreateInstance(Type type, Object[] arguments);
    [ExtensionAttribute]
public static object SafeInvoke(ConstructorInfo constructor, Object[] arguments);
    [ExtensionAttribute]
public static object SafeInvoke(MethodInfo method, object instance, Object[] arguments);
    [ExtensionAttribute]
public static object SafeGetValue(FieldInfo field, object instance);
    [ExtensionAttribute]
public static void SafeSetValue(FieldInfo field, object instance, object value);
    public static void DemandMemberAccessIfNeeded(MethodInfo method);
    public static void DemandMemberAccessIfNeeded(Type type);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.ReflectionServices : object {
    [ExtensionAttribute]
public static Assembly Assembly(MemberInfo member);
    [ExtensionAttribute]
public static bool IsVisible(ConstructorInfo constructor);
    [ExtensionAttribute]
public static bool IsVisible(FieldInfo field);
    [ExtensionAttribute]
public static bool IsVisible(MethodInfo method);
    public static string GetDisplayName(Type declaringType, string name);
    [ExtensionAttribute]
public static string GetDisplayName(MemberInfo member);
    internal static bool TryGetGenericInterfaceType(Type instanceType, Type targetOpenInterfaceType, Type& targetClosedInterfaceType);
    [ExtensionAttribute]
internal static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    [ExtensionAttribute]
internal static IEnumerable`1<MethodInfo> GetAllMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetAllFields(Type type);
    [ExtensionAttribute]
internal static bool HasBaseclassOf(Type type, Type baseClass);
}
internal static class Microsoft.Internal.Requires : object {
    [DebuggerStepThroughAttribute]
public static void NotNull(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NotNullOrEmpty(string value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NotNullOrNullElements(IEnumerable`1<T> values, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NullOrNotNullElements(IEnumerable`1<KeyValuePair`2<TKey, TValue>> values, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NullOrNotNullElements(IEnumerable`1<T> values, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NullOrNotNullElements(T[] values, string parameterName);
    [DebuggerStepThroughAttribute]
public static void IsInMembertypeSet(MemberTypes value, string parameterName, MemberTypes enumFlagSet);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.Runtime.Serialization.SerializationServices : object {
    [ExtensionAttribute]
public static T GetValue(SerializationInfo info, string name);
}
internal static class Microsoft.Internal.StringComparers : object {
    public static StringComparer ContractName { get; }
    public static StringComparer MetadataKeyNames { get; }
    public static StringComparer get_ContractName();
    public static StringComparer get_MetadataKeyNames();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Internal.Strings : object {
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_AssemblyReflectionOnly { get; }
    internal static string Argument_ElementReflectionOnlyType { get; }
    internal static string Argument_ExportsEmpty { get; }
    internal static string Argument_ExportsTooMany { get; }
    internal static string Argument_NullElement { get; }
    internal static string Argument_ReflectionContextReturnsReflectionOnlyType { get; }
    internal static string ArgumentException_EmptyString { get; }
    internal static string ArgumentOutOfRange_InvalidEnum { get; }
    internal static string ArgumentOutOfRange_InvalidEnumInSet { get; }
    internal static string ArgumentValueType { get; }
    internal static string AssemblyFileNotFoundOrWrongType { get; }
    internal static string AtomicComposition_AlreadyCompleted { get; }
    internal static string AtomicComposition_AlreadyNested { get; }
    internal static string AtomicComposition_PartOfAnotherAtomicComposition { get; }
    internal static string CardinalityMismatch_NoExports { get; }
    internal static string CardinalityMismatch_TooManyExports { get; }
    internal static string CatalogMutation_Invalid { get; }
    internal static string CompositionElement_UnknownOrigin { get; }
    internal static string CompositionException_ChangesRejected { get; }
    internal static string CompositionException_ElementPrefix { get; }
    internal static string CompositionException_ErrorPrefix { get; }
    internal static string CompositionException_MetadataViewInvalidConstructor { get; }
    internal static string CompositionException_MultipleErrorsWithMultiplePaths { get; }
    internal static string CompositionException_OriginFormat { get; }
    internal static string CompositionException_OriginSeparator { get; }
    internal static string CompositionException_PathsCountSeparator { get; }
    internal static string CompositionException_ReviewErrorProperty { get; }
    internal static string CompositionException_SingleErrorWithMultiplePaths { get; }
    internal static string CompositionException_SingleErrorWithSinglePath { get; }
    internal static string CompositionTrace_Discovery_AssemblyLoadFailed { get; }
    internal static string CompositionTrace_Discovery_DefinitionContainsNoExports { get; }
    internal static string CompositionTrace_Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute { get; }
    internal static string CompositionTrace_Discovery_DefinitionMismatchedExportArity { get; }
    internal static string CompositionTrace_Discovery_MemberMarkedWithMultipleImportAndImportMany { get; }
    internal static string CompositionTrace_Rejection_DefinitionRejected { get; }
    internal static string CompositionTrace_Rejection_DefinitionResurrected { get; }
    internal static string ContractMismatch_ExportedValueCannotBeCastToT { get; }
    internal static string ContractMismatch_InvalidCastOnMetadataField { get; }
    internal static string ContractMismatch_MetadataViewImplementationCanNotBeNull { get; }
    internal static string ContractMismatch_MetadataViewImplementationDoesNotImplementViewInterface { get; }
    internal static string ContractMismatch_NullReferenceOnMetadataField { get; }
    internal static string DirectoryNotFound { get; }
    internal static string Discovery_DuplicateMetadataNameValues { get; }
    internal static string Discovery_MetadataContainsValueWithInvalidType { get; }
    internal static string Discovery_ReservedMetadataNameUsed { get; }
    internal static string ExportDefinitionNotOnThisComposablePart { get; }
    internal static string ExportFactory_TooManyGenericParameters { get; }
    internal static string ExportNotValidOnIndexers { get; }
    internal static string ImportDefinitionNotOnThisComposablePart { get; }
    internal static string ImportEngine_ComposeTookTooManyIterations { get; }
    internal static string ImportEngine_InvalidStateForRecomposition { get; }
    internal static string ImportEngine_PartCannotActivate { get; }
    internal static string ImportEngine_PartCannotGetExportedValue { get; }
    internal static string ImportEngine_PartCannotSetImport { get; }
    internal static string ImportEngine_PartCycle { get; }
    internal static string ImportEngine_PreventedByExistingImport { get; }
    internal static string ImportNotSetOnPart { get; }
    internal static string ImportNotValidOnIndexers { get; }
    internal static string InternalExceptionMessage { get; }
    internal static string InvalidArgument_ReflectionContext { get; }
    internal static string InvalidMetadataValue { get; }
    internal static string InvalidMetadataView { get; }
    internal static string InvalidOperation_DefinitionCannotBeRecomposed { get; }
    internal static string InvalidOperation_GetExportedValueBeforePrereqImportSet { get; }
    internal static string InvalidOperationReentrantCompose { get; }
    internal static string InvalidSetterOnMetadataField { get; }
    internal static string LazyMemberInfo_AccessorsNull { get; }
    internal static string LazyMemberInfo_InvalidAccessorOnSimpleMember { get; }
    internal static string LazyMemberinfo_InvalidEventAccessors_AccessorType { get; }
    internal static string LazyMemberInfo_InvalidEventAccessors_Cardinality { get; }
    internal static string LazyMemberinfo_InvalidPropertyAccessors_AccessorType { get; }
    internal static string LazyMemberInfo_InvalidPropertyAccessors_Cardinality { get; }
    internal static string LazyMemberInfo_NoAccessors { get; }
    internal static string LazyServices_LazyResolvesToNull { get; }
    internal static string MetadataItemNotSupported { get; }
    internal static string NotImplemented_NotOverriddenByDerived { get; }
    internal static string NotSupportedCatalogChanges { get; }
    internal static string NotSupportedInterfaceMetadataView { get; }
    internal static string NotSupportedReadOnlyDictionary { get; }
    internal static string ObjectAlreadyInitialized { get; }
    internal static string ObjectMustBeInitialized { get; }
    internal static string ReentrantCompose { get; }
    internal static string ReflectionContext_Requires_DefaultConstructor { get; }
    internal static string ReflectionContext_Type_Required { get; }
    internal static string ReflectionModel_ExportNotReadable { get; }
    internal static string ReflectionModel_ExportThrewException { get; }
    internal static string ReflectionModel_ImportCollectionAddThrewException { get; }
    internal static string ReflectionModel_ImportCollectionClearThrewException { get; }
    internal static string ReflectionModel_ImportCollectionConstructionThrewException { get; }
    internal static string ReflectionModel_ImportCollectionGetThrewException { get; }
    internal static string ReflectionModel_ImportCollectionIsReadOnlyThrewException { get; }
    internal static string ReflectionModel_ImportCollectionNotWritable { get; }
    internal static string ReflectionModel_ImportCollectionNull { get; }
    internal static string ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned { get; }
    internal static string ReflectionModel_ImportNotAssignableFromExport { get; }
    internal static string ReflectionModel_ImportNotWritable { get; }
    internal static string ReflectionModel_ImportThrewException { get; }
    internal static string ReflectionModel_InvalidExportDefinition { get; }
    internal static string ReflectionModel_InvalidImportDefinition { get; }
    internal static string ReflectionModel_InvalidMemberImportDefinition { get; }
    internal static string ReflectionModel_InvalidParameterImportDefinition { get; }
    internal static string ReflectionModel_InvalidPartDefinition { get; }
    internal static string ReflectionModel_PartConstructorMissing { get; }
    internal static string ReflectionModel_PartConstructorThrewException { get; }
    internal static string ReflectionModel_PartOnImportsSatisfiedThrewException { get; }
    internal static string TypeCatalog_DisplayNameFormat { get; }
    internal static string TypeCatalog_Empty { get; }
    internal static string InvalidOperation_RevertAndCompleteActionsMustNotThrow { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_AssemblyReflectionOnly();
    internal static string get_Argument_ElementReflectionOnlyType();
    internal static string get_Argument_ExportsEmpty();
    internal static string get_Argument_ExportsTooMany();
    internal static string get_Argument_NullElement();
    internal static string get_Argument_ReflectionContextReturnsReflectionOnlyType();
    internal static string get_ArgumentException_EmptyString();
    internal static string get_ArgumentOutOfRange_InvalidEnum();
    internal static string get_ArgumentOutOfRange_InvalidEnumInSet();
    internal static string get_ArgumentValueType();
    internal static string get_AssemblyFileNotFoundOrWrongType();
    internal static string get_AtomicComposition_AlreadyCompleted();
    internal static string get_AtomicComposition_AlreadyNested();
    internal static string get_AtomicComposition_PartOfAnotherAtomicComposition();
    internal static string get_CardinalityMismatch_NoExports();
    internal static string get_CardinalityMismatch_TooManyExports();
    internal static string get_CatalogMutation_Invalid();
    internal static string get_CompositionElement_UnknownOrigin();
    internal static string get_CompositionException_ChangesRejected();
    internal static string get_CompositionException_ElementPrefix();
    internal static string get_CompositionException_ErrorPrefix();
    internal static string get_CompositionException_MetadataViewInvalidConstructor();
    internal static string get_CompositionException_MultipleErrorsWithMultiplePaths();
    internal static string get_CompositionException_OriginFormat();
    internal static string get_CompositionException_OriginSeparator();
    internal static string get_CompositionException_PathsCountSeparator();
    internal static string get_CompositionException_ReviewErrorProperty();
    internal static string get_CompositionException_SingleErrorWithMultiplePaths();
    internal static string get_CompositionException_SingleErrorWithSinglePath();
    internal static string get_CompositionTrace_Discovery_AssemblyLoadFailed();
    internal static string get_CompositionTrace_Discovery_DefinitionContainsNoExports();
    internal static string get_CompositionTrace_Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute();
    internal static string get_CompositionTrace_Discovery_DefinitionMismatchedExportArity();
    internal static string get_CompositionTrace_Discovery_MemberMarkedWithMultipleImportAndImportMany();
    internal static string get_CompositionTrace_Rejection_DefinitionRejected();
    internal static string get_CompositionTrace_Rejection_DefinitionResurrected();
    internal static string get_ContractMismatch_ExportedValueCannotBeCastToT();
    internal static string get_ContractMismatch_InvalidCastOnMetadataField();
    internal static string get_ContractMismatch_MetadataViewImplementationCanNotBeNull();
    internal static string get_ContractMismatch_MetadataViewImplementationDoesNotImplementViewInterface();
    internal static string get_ContractMismatch_NullReferenceOnMetadataField();
    internal static string get_DirectoryNotFound();
    internal static string get_Discovery_DuplicateMetadataNameValues();
    internal static string get_Discovery_MetadataContainsValueWithInvalidType();
    internal static string get_Discovery_ReservedMetadataNameUsed();
    internal static string get_ExportDefinitionNotOnThisComposablePart();
    internal static string get_ExportFactory_TooManyGenericParameters();
    internal static string get_ExportNotValidOnIndexers();
    internal static string get_ImportDefinitionNotOnThisComposablePart();
    internal static string get_ImportEngine_ComposeTookTooManyIterations();
    internal static string get_ImportEngine_InvalidStateForRecomposition();
    internal static string get_ImportEngine_PartCannotActivate();
    internal static string get_ImportEngine_PartCannotGetExportedValue();
    internal static string get_ImportEngine_PartCannotSetImport();
    internal static string get_ImportEngine_PartCycle();
    internal static string get_ImportEngine_PreventedByExistingImport();
    internal static string get_ImportNotSetOnPart();
    internal static string get_ImportNotValidOnIndexers();
    internal static string get_InternalExceptionMessage();
    internal static string get_InvalidArgument_ReflectionContext();
    internal static string get_InvalidMetadataValue();
    internal static string get_InvalidMetadataView();
    internal static string get_InvalidOperation_DefinitionCannotBeRecomposed();
    internal static string get_InvalidOperation_GetExportedValueBeforePrereqImportSet();
    internal static string get_InvalidOperationReentrantCompose();
    internal static string get_InvalidSetterOnMetadataField();
    internal static string get_LazyMemberInfo_AccessorsNull();
    internal static string get_LazyMemberInfo_InvalidAccessorOnSimpleMember();
    internal static string get_LazyMemberinfo_InvalidEventAccessors_AccessorType();
    internal static string get_LazyMemberInfo_InvalidEventAccessors_Cardinality();
    internal static string get_LazyMemberinfo_InvalidPropertyAccessors_AccessorType();
    internal static string get_LazyMemberInfo_InvalidPropertyAccessors_Cardinality();
    internal static string get_LazyMemberInfo_NoAccessors();
    internal static string get_LazyServices_LazyResolvesToNull();
    internal static string get_MetadataItemNotSupported();
    internal static string get_NotImplemented_NotOverriddenByDerived();
    internal static string get_NotSupportedCatalogChanges();
    internal static string get_NotSupportedInterfaceMetadataView();
    internal static string get_NotSupportedReadOnlyDictionary();
    internal static string get_ObjectAlreadyInitialized();
    internal static string get_ObjectMustBeInitialized();
    internal static string get_ReentrantCompose();
    internal static string get_ReflectionContext_Requires_DefaultConstructor();
    internal static string get_ReflectionContext_Type_Required();
    internal static string get_ReflectionModel_ExportNotReadable();
    internal static string get_ReflectionModel_ExportThrewException();
    internal static string get_ReflectionModel_ImportCollectionAddThrewException();
    internal static string get_ReflectionModel_ImportCollectionClearThrewException();
    internal static string get_ReflectionModel_ImportCollectionConstructionThrewException();
    internal static string get_ReflectionModel_ImportCollectionGetThrewException();
    internal static string get_ReflectionModel_ImportCollectionIsReadOnlyThrewException();
    internal static string get_ReflectionModel_ImportCollectionNotWritable();
    internal static string get_ReflectionModel_ImportCollectionNull();
    internal static string get_ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned();
    internal static string get_ReflectionModel_ImportNotAssignableFromExport();
    internal static string get_ReflectionModel_ImportNotWritable();
    internal static string get_ReflectionModel_ImportThrewException();
    internal static string get_ReflectionModel_InvalidExportDefinition();
    internal static string get_ReflectionModel_InvalidImportDefinition();
    internal static string get_ReflectionModel_InvalidMemberImportDefinition();
    internal static string get_ReflectionModel_InvalidParameterImportDefinition();
    internal static string get_ReflectionModel_InvalidPartDefinition();
    internal static string get_ReflectionModel_PartConstructorMissing();
    internal static string get_ReflectionModel_PartConstructorThrewException();
    internal static string get_ReflectionModel_PartOnImportsSatisfiedThrewException();
    internal static string get_TypeCatalog_DisplayNameFormat();
    internal static string get_TypeCatalog_Empty();
    internal static string get_InvalidOperation_RevertAndCompleteActionsMustNotThrow();
}
internal class Microsoft.Internal.WriteLock : ValueType {
    private Lock _lock;
    private int _isDisposed;
    public WriteLock(Lock lock);
    public sealed virtual void Dispose();
}
internal class System.ComponentModel.Composition.AttributedModel.AttributedExportDefinition : ExportDefinition {
    public IDictionary`2<string, object> Metadata { get; }
    public AttributedExportDefinition(AttributedPartCreationInfo partCreationInfo, MemberInfo member, ExportAttribute exportAttribute, Type typeIdentityType, string contractName);
    public virtual IDictionary`2<string, object> get_Metadata();
}
internal static class System.ComponentModel.Composition.AttributedModel.AttributedModelDiscovery : object {
    public static ComposablePartDefinition CreatePartDefinitionIfDiscoverable(Type type, ICompositionElement origin);
    public static ReflectionComposablePartDefinition CreatePartDefinition(Type type, PartCreationPolicyAttribute partCreationPolicy, bool ignoreConstructorImports, ICompositionElement origin);
    public static ReflectionComposablePart CreatePart(object attributedPart);
    public static ReflectionComposablePart CreatePart(object attributedPart, ReflectionContext reflectionContext);
    public static ReflectionComposablePart CreatePart(ComposablePartDefinition partDefinition, object attributedPart);
    public static ReflectionParameterImportDefinition CreateParameterImportDefinition(ParameterInfo parameter, ICompositionElement origin);
    public static ReflectionMemberImportDefinition CreateMemberImportDefinition(MemberInfo member, ICompositionElement origin);
}
internal class System.ComponentModel.Composition.AttributedModel.AttributedPartCreationInfo : object {
    public bool IsDisposalRequired { get; }
    public bool IsIdentityComparison { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public AttributedPartCreationInfo(Type type, PartCreationPolicyAttribute partCreationPolicy, bool ignoreConstructorImports, ICompositionElement origin);
    public sealed virtual Type GetPartType();
    public sealed virtual Lazy`1<Type> GetLazyPartType();
    public sealed virtual ConstructorInfo GetConstructor();
    public sealed virtual IDictionary`2<string, object> GetMetadata();
    public sealed virtual IEnumerable`1<ExportDefinition> GetExports();
    public sealed virtual IEnumerable`1<ImportDefinition> GetImports();
    public sealed virtual bool get_IsDisposalRequired();
    public sealed virtual bool get_IsIdentityComparison();
    public bool IsPartDiscoverable();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.ComponentModel.Composition.AttributedModelServices : object {
    public static TMetadataView GetMetadataView(IDictionary`2<string, object> metadata);
    public static ComposablePart CreatePart(object attributedPart);
    public static ComposablePart CreatePart(object attributedPart, ReflectionContext reflectionContext);
    public static ComposablePart CreatePart(ComposablePartDefinition partDefinition, object attributedPart);
    public static ComposablePartDefinition CreatePartDefinition(Type type, ICompositionElement origin);
    public static ComposablePartDefinition CreatePartDefinition(Type type, ICompositionElement origin, bool ensureIsDiscoverable);
    public static string GetTypeIdentity(Type type);
    public static string GetTypeIdentity(MethodInfo method);
    public static string GetContractName(Type type);
    [ExtensionAttribute]
public static ComposablePart AddExportedValue(CompositionBatch batch, T exportedValue);
    [ExtensionAttribute]
public static void ComposeExportedValue(CompositionContainer container, T exportedValue);
    [ExtensionAttribute]
public static ComposablePart AddExportedValue(CompositionBatch batch, string contractName, T exportedValue);
    [ExtensionAttribute]
public static void ComposeExportedValue(CompositionContainer container, string contractName, T exportedValue);
    [ExtensionAttribute]
public static ComposablePart AddPart(CompositionBatch batch, object attributedPart);
    [ExtensionAttribute]
public static void ComposeParts(CompositionContainer container, Object[] attributedParts);
    [ExtensionAttribute]
public static ComposablePart SatisfyImportsOnce(ICompositionService compositionService, object attributedPart);
    [ExtensionAttribute]
public static ComposablePart SatisfyImportsOnce(ICompositionService compositionService, object attributedPart, ReflectionContext reflectionContext);
    [ExtensionAttribute]
public static bool Exports(ComposablePartDefinition part, Type contractType);
    [ExtensionAttribute]
public static bool Exports(ComposablePartDefinition part);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part, Type contractType);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part, Type contractType, ImportCardinality importCardinality);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part, ImportCardinality importCardinality);
}
[AttributeUsageAttribute("1")]
public class System.ComponentModel.Composition.CatalogReflectionContextAttribute : Attribute {
    public CatalogReflectionContextAttribute(Type reflectionContextType);
    public ReflectionContext CreateReflectionContext();
}
public class System.ComponentModel.Composition.ChangeRejectedException : CompositionException {
    public string Message { get; }
    public ChangeRejectedException(string message);
    public ChangeRejectedException(string message, Exception innerException);
    public ChangeRejectedException(IEnumerable`1<CompositionError> errors);
    public virtual string get_Message();
}
public class System.ComponentModel.Composition.CompositionContractMismatchException : Exception {
    public CompositionContractMismatchException(string message);
    public CompositionContractMismatchException(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected CompositionContractMismatchException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.CompositionErrorDebuggerProxy")]
public class System.ComponentModel.Composition.CompositionError : object {
    public ICompositionElement Element { get; }
    public string Description { get; }
    public Exception Exception { get; }
    internal CompositionErrorId Id { get; }
    internal Exception InnerException { get; }
    public CompositionError(string message);
    public CompositionError(string message, ICompositionElement element);
    public CompositionError(string message, Exception exception);
    public CompositionError(string message, ICompositionElement element, Exception exception);
    internal CompositionError(CompositionErrorId id, string description, ICompositionElement element, Exception exception);
    public ICompositionElement get_Element();
    public string get_Description();
    public Exception get_Exception();
    internal CompositionErrorId get_Id();
    internal Exception get_InnerException();
    public virtual string ToString();
    internal static CompositionError Create(CompositionErrorId id, string format, Object[] parameters);
    internal static CompositionError Create(CompositionErrorId id, ICompositionElement element, string format, Object[] parameters);
    internal static CompositionError Create(CompositionErrorId id, ICompositionElement element, Exception exception, string format, Object[] parameters);
}
internal class System.ComponentModel.Composition.CompositionErrorDebuggerProxy : object {
    public string Description { get; }
    public Exception Exception { get; }
    public ICompositionElement Element { get; }
    public CompositionErrorDebuggerProxy(CompositionError error);
    public string get_Description();
    public Exception get_Exception();
    public ICompositionElement get_Element();
}
internal enum System.ComponentModel.Composition.CompositionErrorId : Enum {
    public int value__;
    public static CompositionErrorId Unknown;
    public static CompositionErrorId InvalidExportMetadata;
    public static CompositionErrorId ImportNotSetOnPart;
    public static CompositionErrorId ImportEngine_ComposeTookTooManyIterations;
    public static CompositionErrorId ImportEngine_ImportCardinalityMismatch;
    public static CompositionErrorId ImportEngine_PartCycle;
    public static CompositionErrorId ImportEngine_PartCannotSetImport;
    public static CompositionErrorId ImportEngine_PartCannotGetExportedValue;
    public static CompositionErrorId ImportEngine_PartCannotActivate;
    public static CompositionErrorId ImportEngine_PreventedByExistingImport;
    public static CompositionErrorId ImportEngine_InvalidStateForRecomposition;
    public static CompositionErrorId ReflectionModel_ImportThrewException;
    public static CompositionErrorId ReflectionModel_ImportNotAssignableFromExport;
    public static CompositionErrorId ReflectionModel_ImportCollectionNull;
    public static CompositionErrorId ReflectionModel_ImportCollectionNotWritable;
    public static CompositionErrorId ReflectionModel_ImportCollectionConstructionThrewException;
    public static CompositionErrorId ReflectionModel_ImportCollectionGetThrewException;
    public static CompositionErrorId ReflectionModel_ImportCollectionIsReadOnlyThrewException;
    public static CompositionErrorId ReflectionModel_ImportCollectionClearThrewException;
    public static CompositionErrorId ReflectionModel_ImportCollectionAddThrewException;
    public static CompositionErrorId ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned;
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.CompositionExceptionDebuggerProxy")]
[DebuggerDisplayAttribute("{Message}")]
public class System.ComponentModel.Composition.CompositionException : Exception {
    public ReadOnlyCollection`1<CompositionError> Errors { get; }
    public string Message { get; }
    public ReadOnlyCollection`1<Exception> RootCauses { get; }
    public CompositionException(string message);
    public CompositionException(string message, Exception innerException);
    internal CompositionException(CompositionError error);
    public CompositionException(IEnumerable`1<CompositionError> errors);
    internal CompositionException(string message, Exception innerException, IEnumerable`1<CompositionError> errors);
    public ReadOnlyCollection`1<CompositionError> get_Errors();
    public virtual string get_Message();
    public ReadOnlyCollection`1<Exception> get_RootCauses();
}
internal class System.ComponentModel.Composition.CompositionExceptionDebuggerProxy : object {
    public ReadOnlyCollection`1<Exception> Exceptions { get; }
    public string Message { get; }
    public ReadOnlyCollection`1<Exception> RootCauses { get; }
    public CompositionExceptionDebuggerProxy(CompositionException exception);
    public ReadOnlyCollection`1<Exception> get_Exceptions();
    public string get_Message();
    public ReadOnlyCollection`1<Exception> get_RootCauses();
}
internal class System.ComponentModel.Composition.CompositionResult : ValueType {
    public static CompositionResult SucceededResult;
    private IEnumerable`1<CompositionError> _errors;
    public bool Succeeded { get; }
    public IEnumerable`1<CompositionError> Errors { get; }
    public CompositionResult(CompositionError[] errors);
    public CompositionResult(IEnumerable`1<CompositionError> errors);
    private static CompositionResult();
    public bool get_Succeeded();
    public IEnumerable`1<CompositionError> get_Errors();
    public CompositionResult MergeResult(CompositionResult result);
    public CompositionResult MergeError(CompositionError error);
    public CompositionResult MergeErrors(IEnumerable`1<CompositionError> errors);
    public CompositionResult`1<T> ToResult(T value);
    public void ThrowOnErrors();
    public void ThrowOnErrors(AtomicComposition atomicComposition);
}
internal class System.ComponentModel.Composition.CompositionResult`1 : ValueType {
    private IEnumerable`1<CompositionError> _errors;
    private T _value;
    public bool Succeeded { get; }
    public IEnumerable`1<CompositionError> Errors { get; }
    public T Value { get; }
    public CompositionResult`1(T value);
    public CompositionResult`1(CompositionError[] errors);
    public CompositionResult`1(IEnumerable`1<CompositionError> errors);
    internal CompositionResult`1(T value, IEnumerable`1<CompositionError> errors);
    public bool get_Succeeded();
    public IEnumerable`1<CompositionError> get_Errors();
    public T get_Value();
    internal CompositionResult`1<TValue> ToResult();
    internal CompositionResult ToResult();
}
internal static class System.ComponentModel.Composition.ConstraintServices : object {
    private static ConstraintServices();
    public static Expression`1<Func`2<ExportDefinition, bool>> CreateConstraint(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, CreationPolicy requiredCreationPolicy);
    public static Expression`1<Func`2<ExportDefinition, bool>> CreatePartCreatorConstraint(Expression`1<Func`2<ExportDefinition, bool>> baseConstraint, ImportDefinition productImportDefinition);
}
internal static class System.ComponentModel.Composition.ContractNameServices : object {
    internal static string GetTypeIdentity(Type type);
    internal static string GetTypeIdentity(Type type, bool formatGenericName);
    internal static string GetTypeIdentityFromMethod(MethodInfo method);
    internal static string GetTypeIdentityFromMethod(MethodInfo method, bool formatGenericName);
    internal static void WriteCustomModifiers(StringBuilder typeName, string customKeyword, Type[] types, bool formatGenericName);
}
public enum System.ComponentModel.Composition.CreationPolicy : Enum {
    public int value__;
    public static CreationPolicy Any;
    public static CreationPolicy Shared;
    public static CreationPolicy NonShared;
}
internal static class System.ComponentModel.Composition.Diagnostics.CompositionTrace : object {
    internal static void PartDefinitionResurrected(ComposablePartDefinition definition);
    internal static void PartDefinitionRejected(ComposablePartDefinition definition, ChangeRejectedException exception);
    internal static void AssemblyLoadFailed(DirectoryCatalog catalog, string fileName, Exception exception);
    internal static void DefinitionMarkedWithPartNotDiscoverableAttribute(Type type);
    internal static void DefinitionMismatchedExportArity(Type type, MemberInfo member);
    internal static void DefinitionContainsNoExports(Type type);
    internal static void MemberMarkedWithMultipleImportAndImportMany(ReflectionItem item);
}
internal enum System.ComponentModel.Composition.Diagnostics.CompositionTraceId : Enum {
    public ushort value__;
    public static CompositionTraceId Rejection_DefinitionRejected;
    public static CompositionTraceId Rejection_DefinitionResurrected;
    public static CompositionTraceId Discovery_AssemblyLoadFailed;
    public static CompositionTraceId Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute;
    public static CompositionTraceId Discovery_DefinitionMismatchedExportArity;
    public static CompositionTraceId Discovery_DefinitionContainsNoExports;
    public static CompositionTraceId Discovery_MemberMarkedWithMultipleImportAndImportMany;
}
internal static class System.ComponentModel.Composition.Diagnostics.CompositionTraceSource : object {
    public static bool CanWriteInformation { get; }
    public static bool CanWriteWarning { get; }
    public static bool CanWriteError { get; }
    private static CompositionTraceSource();
    public static bool get_CanWriteInformation();
    public static bool get_CanWriteWarning();
    public static bool get_CanWriteError();
    public static void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments);
    public static void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments);
    public static void WriteError(CompositionTraceId traceId, string format, Object[] arguments);
}
internal class System.ComponentModel.Composition.Diagnostics.TraceSourceTraceWriter : TraceWriter {
    internal static TraceSource Source;
    public bool CanWriteInformation { get; }
    public bool CanWriteWarning { get; }
    public bool CanWriteError { get; }
    private static TraceSourceTraceWriter();
    public virtual bool get_CanWriteInformation();
    public virtual bool get_CanWriteWarning();
    public virtual bool get_CanWriteError();
    public virtual void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments);
    public virtual void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments);
    public virtual void WriteError(CompositionTraceId traceId, string format, Object[] arguments);
}
internal abstract class System.ComponentModel.Composition.Diagnostics.TraceWriter : object {
    public bool CanWriteInformation { get; }
    public bool CanWriteWarning { get; }
    public bool CanWriteError { get; }
    public abstract virtual bool get_CanWriteInformation();
    public abstract virtual bool get_CanWriteWarning();
    public abstract virtual bool get_CanWriteError();
    public abstract virtual void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments);
    public abstract virtual void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments);
    public abstract virtual void WriteError(CompositionTraceId traceId, string format, Object[] arguments);
}
internal static class System.ComponentModel.Composition.ErrorBuilder : object {
    public static CompositionError PreventedByExistingImport(ComposablePart part, ImportDefinition import);
    public static CompositionError InvalidStateForRecompposition(ComposablePart part);
    public static CompositionError ComposeTookTooManyIterations(int maximumNumberOfCompositionIterations);
    public static CompositionError CreateImportCardinalityMismatch(ImportCardinalityMismatchException exception, ImportDefinition definition);
    public static CompositionError CreatePartCannotActivate(ComposablePart part, Exception innerException);
    public static CompositionError CreatePartCannotSetImport(ComposablePart part, ImportDefinition definition, Exception innerException);
    public static CompositionError CreateCannotGetExportedValue(ComposablePart part, ExportDefinition definition, Exception innerException);
    public static CompositionError CreatePartCycle(ComposablePart part);
}
internal static class System.ComponentModel.Composition.ExceptionBuilder : object {
    public static Exception CreateDiscoveryException(string messageFormat, String[] arguments);
    public static ArgumentException CreateContainsNullElement(string parameterName);
    public static ObjectDisposedException CreateObjectDisposed(object instance);
    public static NotImplementedException CreateNotOverriddenByDerived(string memberName);
    public static ArgumentException CreateExportDefinitionNotOnThisComposablePart(string parameterName);
    public static ArgumentException CreateImportDefinitionNotOnThisComposablePart(string parameterName);
    public static CompositionException CreateCannotGetExportedValue(ComposablePart part, ExportDefinition definition, Exception innerException);
    public static ArgumentException CreateReflectionModelInvalidPartDefinition(string parameterName, Type partDefinitionType);
    public static ArgumentException ExportFactory_TooManyGenericParameters(string typeName);
}
[AttributeUsageAttribute("452")]
public class System.ComponentModel.Composition.ExportAttribute : Attribute {
    public string ContractName { get; private set; }
    public Type ContractType { get; private set; }
    public ExportAttribute(Type contractType);
    public ExportAttribute(string contractName);
    public ExportAttribute(string contractName, Type contractType);
    [CompilerGeneratedAttribute]
public string get_ContractName();
    [CompilerGeneratedAttribute]
private void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public Type get_ContractType();
    [CompilerGeneratedAttribute]
private void set_ContractType(Type value);
}
internal enum System.ComponentModel.Composition.ExportCardinalityCheckResult : Enum {
    public int value__;
    public static ExportCardinalityCheckResult Match;
    public static ExportCardinalityCheckResult NoExports;
    public static ExportCardinalityCheckResult TooManyExports;
}
public class System.ComponentModel.Composition.ExportFactory`1 : object {
    public ExportFactory`1(Func`1<Tuple`2<T, Action>> exportLifetimeContextCreator);
    public ExportLifetimeContext`1<T> CreateExport();
}
public class System.ComponentModel.Composition.ExportFactory`2 : ExportFactory`1<T> {
    public TMetadata Metadata { get; }
    public ExportFactory`2(Func`1<Tuple`2<T, Action>> exportLifetimeContextCreator, TMetadata metadata);
    public TMetadata get_Metadata();
}
public class System.ComponentModel.Composition.ExportLifetimeContext`1 : object {
    public T Value { get; }
    public ExportLifetimeContext`1(T value, Action disposeAction);
    public T get_Value();
    public sealed virtual void Dispose();
}
[AttributeUsageAttribute("1476")]
public class System.ComponentModel.Composition.ExportMetadataAttribute : Attribute {
    public string Name { get; private set; }
    public object Value { get; private set; }
    public bool IsMultiple { get; public set; }
    public ExportMetadataAttribute(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_IsMultiple();
    [CompilerGeneratedAttribute]
public void set_IsMultiple(bool value);
}
internal static class System.ComponentModel.Composition.ExportServices : object {
    internal static Type DefaultMetadataViewType;
    internal static Type DefaultExportedValueType;
    private static ExportServices();
    internal static bool IsDefaultMetadataViewType(Type metadataViewType);
    internal static bool IsDictionaryConstructorViewType(Type metadataViewType);
    internal static Func`2<Export, object> CreateStronglyTypedLazyFactory(Type exportType, Type metadataViewType);
    internal static Func`2<Export, Lazy`2<object, object>> CreateSemiStronglyTypedLazyFactory(Type exportType, Type metadataViewType);
    internal static Lazy`2<T, M> CreateStronglyTypedLazyOfTM(Export export);
    internal static Lazy`1<T> CreateStronglyTypedLazyOfT(Export export);
    internal static Lazy`2<object, object> CreateSemiStronglyTypedLazy(Export export);
    internal static T GetCastedExportedValue(Export export);
    internal static T CastExportedValue(ICompositionElement element, object exportedValue);
    internal static ExportCardinalityCheckResult CheckCardinality(ImportDefinition definition, IEnumerable`1<T> enumerable);
}
public class System.ComponentModel.Composition.Hosting.AggregateCatalog : ComposablePartCatalog {
    public ICollection`1<ComposablePartCatalog> Catalogs { get; }
    public AggregateCatalog(ComposablePartCatalog[] catalogs);
    public AggregateCatalog(IEnumerable`1<ComposablePartCatalog> catalogs);
    public sealed virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    public sealed virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    public sealed virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    public sealed virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    public ICollection`1<ComposablePartCatalog> get_Catalogs();
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    protected virtual void OnChanged(ComposablePartCatalogChangeEventArgs e);
    protected virtual void OnChanging(ComposablePartCatalogChangeEventArgs e);
}
public class System.ComponentModel.Composition.Hosting.AggregateExportProvider : ExportProvider {
    public ReadOnlyCollection`1<ExportProvider> Providers { get; }
    public AggregateExportProvider(ExportProvider[] providers);
    public AggregateExportProvider(IEnumerable`1<ExportProvider> providers);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public ReadOnlyCollection`1<ExportProvider> get_Providers();
    protected virtual IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition);
}
public class System.ComponentModel.Composition.Hosting.ApplicationCatalog : ComposablePartCatalog {
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public ApplicationCatalog(ICompositionElement definitionOrigin);
    public ApplicationCatalog(ReflectionContext reflectionContext);
    public ApplicationCatalog(ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    internal ComposablePartCatalog CreateCatalog(string location, string pattern);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    public virtual string ToString();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Hosting.AssemblyCatalogDebuggerProxy")]
public class System.ComponentModel.Composition.Hosting.AssemblyCatalog : ComposablePartCatalog {
    public Assembly Assembly { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public AssemblyCatalog(string codeBase);
    public AssemblyCatalog(string codeBase, ReflectionContext reflectionContext);
    public AssemblyCatalog(string codeBase, ICompositionElement definitionOrigin);
    public AssemblyCatalog(string codeBase, ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    public AssemblyCatalog(Assembly assembly, ReflectionContext reflectionContext);
    public AssemblyCatalog(Assembly assembly, ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    public AssemblyCatalog(Assembly assembly);
    public AssemblyCatalog(Assembly assembly, ICompositionElement definitionOrigin);
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    public Assembly get_Assembly();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
}
internal class System.ComponentModel.Composition.Hosting.AssemblyCatalogDebuggerProxy : object {
    public Assembly Assembly { get; }
    public ReadOnlyCollection`1<ComposablePartDefinition> Parts { get; }
    public AssemblyCatalogDebuggerProxy(AssemblyCatalog catalog);
    public Assembly get_Assembly();
    public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts();
}
public class System.ComponentModel.Composition.Hosting.AtomicComposition : object {
    public AtomicComposition(AtomicComposition outerAtomicComposition);
    public void SetValue(object key, object value);
    public bool TryGetValue(object key, T& value);
    public bool TryGetValue(object key, bool localAtomicCompositionOnly, T& value);
    public void AddCompleteAction(Action completeAction);
    public void AddRevertAction(Action revertAction);
    public void Complete();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.Hosting.AtomicCompositionExtensions : object {
    [ExtensionAttribute]
internal static T GetValueAllowNull(AtomicComposition atomicComposition, T defaultResultAndKey);
    [ExtensionAttribute]
internal static T GetValueAllowNull(AtomicComposition atomicComposition, object key, T defaultResult);
    [ExtensionAttribute]
internal static void AddRevertActionAllowNull(AtomicComposition atomicComposition, Action action);
    [ExtensionAttribute]
internal static void AddCompleteActionAllowNull(AtomicComposition atomicComposition, Action action);
}
public class System.ComponentModel.Composition.Hosting.CatalogExportProvider : ExportProvider {
    public ComposablePartCatalog Catalog { get; }
    public ExportProvider SourceProvider { get; public set; }
    public CatalogExportProvider(ComposablePartCatalog catalog);
    public CatalogExportProvider(ComposablePartCatalog catalog, bool isThreadSafe);
    public CatalogExportProvider(ComposablePartCatalog catalog, CompositionOptions compositionOptions);
    public ComposablePartCatalog get_Catalog();
    public ExportProvider get_SourceProvider();
    public void set_SourceProvider(ExportProvider value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition);
}
[ExtensionAttribute]
public static class System.ComponentModel.Composition.Hosting.CatalogExtensions : object {
    [ExtensionAttribute]
public static CompositionService CreateCompositionService(ComposablePartCatalog composablePartCatalog);
}
public class System.ComponentModel.Composition.Hosting.ComposablePartCatalogChangeEventArgs : EventArgs {
    public IEnumerable`1<ComposablePartDefinition> AddedDefinitions { get; }
    public IEnumerable`1<ComposablePartDefinition> RemovedDefinitions { get; }
    public AtomicComposition AtomicComposition { get; private set; }
    public ComposablePartCatalogChangeEventArgs(IEnumerable`1<ComposablePartDefinition> addedDefinitions, IEnumerable`1<ComposablePartDefinition> removedDefinitions, AtomicComposition atomicComposition);
    public IEnumerable`1<ComposablePartDefinition> get_AddedDefinitions();
    public IEnumerable`1<ComposablePartDefinition> get_RemovedDefinitions();
    [CompilerGeneratedAttribute]
public AtomicComposition get_AtomicComposition();
    [CompilerGeneratedAttribute]
private void set_AtomicComposition(AtomicComposition value);
}
internal class System.ComponentModel.Composition.Hosting.ComposablePartCatalogCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal bool HasChanged { get; }
    public ComposablePartCatalogCollection(IEnumerable`1<ComposablePartCatalog> catalogs, Action`1<ComposablePartCatalogChangeEventArgs> onChanged, Action`1<ComposablePartCatalogChangeEventArgs> onChanging);
    public sealed virtual void Add(ComposablePartCatalog item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ComposablePartCatalog item);
    public sealed virtual void CopyTo(ComposablePartCatalog[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(ComposablePartCatalog item);
    internal bool get_HasChanged();
    public sealed virtual IEnumerator`1<ComposablePartCatalog> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void OnChanged(object sender, ComposablePartCatalogChangeEventArgs e);
    public void OnChanging(object sender, ComposablePartCatalogChangeEventArgs e);
}
public class System.ComponentModel.Composition.Hosting.ComposablePartExportProvider : ExportProvider {
    public ExportProvider SourceProvider { get; public set; }
    public ComposablePartExportProvider(bool isThreadSafe);
    public ComposablePartExportProvider(CompositionOptions compositionOptions);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public ExportProvider get_SourceProvider();
    public void set_SourceProvider(ExportProvider value);
    protected virtual IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition);
    public void Compose(CompositionBatch batch);
}
public class System.ComponentModel.Composition.Hosting.CompositionBatch : object {
    public ReadOnlyCollection`1<ComposablePart> PartsToAdd { get; }
    public ReadOnlyCollection`1<ComposablePart> PartsToRemove { get; }
    public CompositionBatch(IEnumerable`1<ComposablePart> partsToAdd, IEnumerable`1<ComposablePart> partsToRemove);
    public ReadOnlyCollection`1<ComposablePart> get_PartsToAdd();
    public ReadOnlyCollection`1<ComposablePart> get_PartsToRemove();
    public void AddPart(ComposablePart part);
    public void RemovePart(ComposablePart part);
    public ComposablePart AddExport(Export export);
}
public static class System.ComponentModel.Composition.Hosting.CompositionConstants : object {
    public static string PartCreationPolicyMetadataName;
    public static string ImportSourceMetadataName;
    public static string IsGenericPartMetadataName;
    public static string GenericContractMetadataName;
    public static string GenericParametersMetadataName;
    public static string ExportTypeIdentityMetadataName;
    internal static string GenericImportParametersOrderMetadataName;
    internal static string GenericExportParametersOrderMetadataName;
    internal static string GenericPartArityMetadataName;
    internal static string GenericParameterConstraintsMetadataName;
    internal static string GenericParameterAttributesMetadataName;
    internal static string ProductDefinitionMetadataName;
    internal static string PartCreatorContractName;
    internal static string PartCreatorTypeIdentity;
    private static CompositionConstants();
}
public class System.ComponentModel.Composition.Hosting.CompositionContainer : ExportProvider {
    internal CompositionOptions CompositionOptions { get; }
    public ComposablePartCatalog Catalog { get; }
    internal CatalogExportProvider CatalogExportProvider { get; }
    public ReadOnlyCollection`1<ExportProvider> Providers { get; }
    public CompositionContainer(ExportProvider[] providers);
    public CompositionContainer(CompositionOptions compositionOptions, ExportProvider[] providers);
    public CompositionContainer(ComposablePartCatalog catalog, ExportProvider[] providers);
    public CompositionContainer(ComposablePartCatalog catalog, bool isThreadSafe, ExportProvider[] providers);
    public CompositionContainer(ComposablePartCatalog catalog, CompositionOptions compositionOptions, ExportProvider[] providers);
    private static CompositionContainer();
    internal CompositionOptions get_CompositionOptions();
    public ComposablePartCatalog get_Catalog();
    internal CatalogExportProvider get_CatalogExportProvider();
    public ReadOnlyCollection`1<ExportProvider> get_Providers();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Compose(CompositionBatch batch);
    public void ReleaseExport(Export export);
    public void ReleaseExport(Lazy`1<T> export);
    public void ReleaseExports(IEnumerable`1<Export> exports);
    public void ReleaseExports(IEnumerable`1<Lazy`1<T>> exports);
    public void ReleaseExports(IEnumerable`1<Lazy`2<T, TMetadataView>> exports);
    public sealed virtual void SatisfyImportsOnce(ComposablePart part);
    internal void OnExportsChangedInternal(object sender, ExportsChangeEventArgs e);
    internal void OnExportsChangingInternal(object sender, ExportsChangeEventArgs e);
    protected virtual IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition);
}
internal class System.ComponentModel.Composition.Hosting.CompositionLock : object {
    public bool IsThreadSafe { get; }
    public CompositionLock(bool isThreadSafe);
    private static CompositionLock();
    public sealed virtual void Dispose();
    public bool get_IsThreadSafe();
    public IDisposable LockComposition();
    public IDisposable LockStateForRead();
    public IDisposable LockStateForWrite();
}
[FlagsAttribute]
public enum System.ComponentModel.Composition.Hosting.CompositionOptions : Enum {
    public int value__;
    public static CompositionOptions Default;
    public static CompositionOptions DisableSilentRejection;
    public static CompositionOptions IsThreadSafe;
    public static CompositionOptions ExportCompositionService;
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Hosting.CompositionScopeDefinitionDebuggerProxy")]
public class System.ComponentModel.Composition.Hosting.CompositionScopeDefinition : ComposablePartCatalog {
    public IEnumerable`1<CompositionScopeDefinition> Children { get; }
    public IEnumerable`1<ExportDefinition> PublicSurface { get; }
    public CompositionScopeDefinition(ComposablePartCatalog catalog, IEnumerable`1<CompositionScopeDefinition> children);
    public CompositionScopeDefinition(ComposablePartCatalog catalog, IEnumerable`1<CompositionScopeDefinition> children, IEnumerable`1<ExportDefinition> publicSurface);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<CompositionScopeDefinition> get_Children();
    public virtual IEnumerable`1<ExportDefinition> get_PublicSurface();
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    internal IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExportsFromPublicSurface(ImportDefinition definition);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    protected virtual void OnChanged(ComposablePartCatalogChangeEventArgs e);
    protected virtual void OnChanging(ComposablePartCatalogChangeEventArgs e);
}
internal class System.ComponentModel.Composition.Hosting.CompositionScopeDefinitionDebuggerProxy : object {
    public ReadOnlyCollection`1<ComposablePartDefinition> Parts { get; }
    public IEnumerable`1<ExportDefinition> PublicSurface { get; }
    public IEnumerable`1<CompositionScopeDefinition> Children { get; }
    public CompositionScopeDefinitionDebuggerProxy(CompositionScopeDefinition compositionScopeDefinition);
    public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts();
    public IEnumerable`1<ExportDefinition> get_PublicSurface();
    public virtual IEnumerable`1<CompositionScopeDefinition> get_Children();
}
public class System.ComponentModel.Composition.Hosting.CompositionService : object {
    internal CompositionService(ComposablePartCatalog composablePartCatalog);
    public sealed virtual void SatisfyImportsOnce(ComposablePart part);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.Hosting.CompositionServices : object {
    internal static Type InheritedExportAttributeType;
    internal static Type ExportAttributeType;
    internal static Type AttributeType;
    internal static Type ObjectType;
    private static CompositionServices();
    [ExtensionAttribute]
internal static Type GetDefaultTypeFromMember(MemberInfo member);
    [ExtensionAttribute]
internal static Type AdjustSpecifiedTypeIdentityType(Type specifiedContractType, MemberInfo member);
    [ExtensionAttribute]
internal static Type AdjustSpecifiedTypeIdentityType(Type specifiedContractType, Type memberType);
    [ExtensionAttribute]
internal static void GetContractInfoFromExport(MemberInfo member, ExportAttribute export, Type& typeIdentityType, String& contractName);
    [ExtensionAttribute]
internal static string GetTypeIdentityFromExport(MemberInfo member, Type typeIdentityType);
    [ExtensionAttribute]
internal static bool IsContractNameSameAsTypeIdentity(ExportAttribute export);
    [ExtensionAttribute]
internal static Type GetContractTypeFromImport(IAttributedImport import, ImportType importType);
    [ExtensionAttribute]
internal static string GetContractNameFromImport(IAttributedImport import, ImportType importType);
    [ExtensionAttribute]
internal static string GetTypeIdentityFromImport(IAttributedImport import, ImportType importType);
    [ExtensionAttribute]
internal static IDictionary`2<string, object> GetPartMetadataForType(Type type, CreationPolicy creationPolicy);
    [ExtensionAttribute]
internal static void TryExportMetadataForMember(MemberInfo member, IDictionary`2& dictionary);
    internal static IEnumerable`1<KeyValuePair`2<string, Type>> GetRequiredMetadata(Type metadataViewType);
    internal static IDictionary`2<string, object> GetImportMetadata(ImportType importType, IAttributedImport attributedImport);
    internal static IDictionary`2<string, object> GetImportMetadata(Type type, IAttributedImport attributedImport);
    internal static object GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition);
    [ExtensionAttribute]
internal static bool IsRecomposable(ComposablePart part);
    internal static CompositionResult TryInvoke(Action action);
    internal static CompositionResult TryFire(EventHandler`1<TEventArgs> _delegate, object sender, TEventArgs e);
    [ExtensionAttribute]
internal static CreationPolicy GetRequiredCreationPolicy(ImportDefinition definition);
    [ExtensionAttribute]
internal static bool IsAtMostOne(ImportCardinality cardinality);
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Hosting.DirectoryCatalog/DirectoryCatalogDebuggerProxy")]
public class System.ComponentModel.Composition.Hosting.DirectoryCatalog : ComposablePartCatalog {
    public string FullPath { get; }
    public ReadOnlyCollection`1<string> LoadedFiles { get; }
    public string Path { get; }
    public string SearchPattern { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public DirectoryCatalog(string path);
    public DirectoryCatalog(string path, ReflectionContext reflectionContext);
    public DirectoryCatalog(string path, ICompositionElement definitionOrigin);
    public DirectoryCatalog(string path, ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    public DirectoryCatalog(string path, string searchPattern);
    public DirectoryCatalog(string path, string searchPattern, ICompositionElement definitionOrigin);
    public DirectoryCatalog(string path, string searchPattern, ReflectionContext reflectionContext);
    public DirectoryCatalog(string path, string searchPattern, ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    public string get_FullPath();
    public ReadOnlyCollection`1<string> get_LoadedFiles();
    public string get_Path();
    public string get_SearchPattern();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    protected virtual void OnChanged(ComposablePartCatalogChangeEventArgs e);
    protected virtual void OnChanging(ComposablePartCatalogChangeEventArgs e);
    public void Refresh();
    public virtual string ToString();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
}
public abstract class System.ComponentModel.Composition.Hosting.ExportProvider : object {
    private static ExportProvider();
    [CompilerGeneratedAttribute]
public void add_ExportsChanged(EventHandler`1<ExportsChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExportsChanged(EventHandler`1<ExportsChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ExportsChanging(EventHandler`1<ExportsChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExportsChanging(EventHandler`1<ExportsChangeEventArgs> value);
    public IEnumerable`1<Export> GetExports(ImportDefinition definition);
    public IEnumerable`1<Export> GetExports(ImportDefinition definition, AtomicComposition atomicComposition);
    public bool TryGetExports(ImportDefinition definition, AtomicComposition atomicComposition, IEnumerable`1& exports);
    protected abstract virtual IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition);
    protected virtual void OnExportsChanged(ExportsChangeEventArgs e);
    protected virtual void OnExportsChanging(ExportsChangeEventArgs e);
    public Lazy`1<T> GetExport();
    public Lazy`1<T> GetExport(string contractName);
    public Lazy`2<T, TMetadataView> GetExport();
    public Lazy`2<T, TMetadataView> GetExport(string contractName);
    public IEnumerable`1<Lazy`2<object, object>> GetExports(Type type, Type metadataViewType, string contractName);
    public IEnumerable`1<Lazy`1<T>> GetExports();
    public IEnumerable`1<Lazy`1<T>> GetExports(string contractName);
    public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports();
    public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports(string contractName);
    public T GetExportedValue();
    public T GetExportedValue(string contractName);
    public T GetExportedValueOrDefault();
    public T GetExportedValueOrDefault(string contractName);
    public IEnumerable`1<T> GetExportedValues();
    public IEnumerable`1<T> GetExportedValues(string contractName);
}
public class System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs : EventArgs {
    public IEnumerable`1<ExportDefinition> AddedExports { get; }
    public IEnumerable`1<ExportDefinition> RemovedExports { get; }
    public IEnumerable`1<string> ChangedContractNames { get; }
    public AtomicComposition AtomicComposition { get; private set; }
    public ExportsChangeEventArgs(IEnumerable`1<ExportDefinition> addedExports, IEnumerable`1<ExportDefinition> removedExports, AtomicComposition atomicComposition);
    public IEnumerable`1<ExportDefinition> get_AddedExports();
    public IEnumerable`1<ExportDefinition> get_RemovedExports();
    public IEnumerable`1<string> get_ChangedContractNames();
    [CompilerGeneratedAttribute]
public AtomicComposition get_AtomicComposition();
    [CompilerGeneratedAttribute]
private void set_AtomicComposition(AtomicComposition value);
}
public class System.ComponentModel.Composition.Hosting.FilteredCatalog : ComposablePartCatalog {
    public FilteredCatalog Complement { get; }
    public FilteredCatalog(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter);
    internal FilteredCatalog(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter, FilteredCatalog complement);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    public FilteredCatalog get_Complement();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    protected virtual void OnChanged(ComposablePartCatalogChangeEventArgs e);
    protected virtual void OnChanging(ComposablePartCatalogChangeEventArgs e);
    public FilteredCatalog IncludeDependencies();
    public FilteredCatalog IncludeDependencies(Func`2<ImportDefinition, bool> importFilter);
    public FilteredCatalog IncludeDependents();
    public FilteredCatalog IncludeDependents(Func`2<ImportDefinition, bool> importFilter);
}
public class System.ComponentModel.Composition.Hosting.ImportEngine : object {
    public ImportEngine(ExportProvider sourceProvider);
    public ImportEngine(ExportProvider sourceProvider, bool isThreadSafe);
    public ImportEngine(ExportProvider sourceProvider, CompositionOptions compositionOptions);
    public void PreviewImports(ComposablePart part, AtomicComposition atomicComposition);
    public void SatisfyImports(ComposablePart part);
    public sealed virtual void SatisfyImportsOnce(ComposablePart part);
    public void ReleaseImports(ComposablePart part, AtomicComposition atomicComposition);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal static bool IsRequiredImportForPreview(ImportDefinition import);
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.Hosting.ImportSourceImportDefinitionHelpers : object {
    [ExtensionAttribute]
public static ImportDefinition RemoveImportSource(ImportDefinition definition);
}
public interface System.ComponentModel.Composition.Hosting.INotifyComposablePartCatalogChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value);
}
[ExtensionAttribute]
public static class System.ComponentModel.Composition.Hosting.ScopingExtensions : object {
    [ExtensionAttribute]
public static bool Exports(ComposablePartDefinition part, string contractName);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part, string contractName);
    [ExtensionAttribute]
public static bool Imports(ComposablePartDefinition part, string contractName, ImportCardinality importCardinality);
    [ExtensionAttribute]
public static bool ContainsPartMetadataWithKey(ComposablePartDefinition part, string key);
    [ExtensionAttribute]
public static bool ContainsPartMetadata(ComposablePartDefinition part, string key, T value);
    [ExtensionAttribute]
public static FilteredCatalog Filter(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter);
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Primitives.ComposablePartCatalogDebuggerProxy")]
public class System.ComponentModel.Composition.Hosting.TypeCatalog : ComposablePartCatalog {
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public TypeCatalog(Type[] types);
    public TypeCatalog(IEnumerable`1<Type> types);
    public TypeCatalog(IEnumerable`1<Type> types, ICompositionElement definitionOrigin);
    public TypeCatalog(IEnumerable`1<Type> types, ReflectionContext reflectionContext);
    public TypeCatalog(IEnumerable`1<Type> types, ReflectionContext reflectionContext, ICompositionElement definitionOrigin);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    internal virtual IEnumerable`1<ComposablePartDefinition> GetCandidateParts(ImportDefinition definition);
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
internal interface System.ComponentModel.Composition.IAttributedImport {
    public string ContractName { get; }
    public Type ContractType { get; }
    public bool AllowRecomposition { get; }
    public CreationPolicy RequiredCreationPolicy { get; }
    public ImportCardinality Cardinality { get; }
    public ImportSource Source { get; }
    public abstract virtual string get_ContractName();
    public abstract virtual Type get_ContractType();
    public abstract virtual bool get_AllowRecomposition();
    public abstract virtual CreationPolicy get_RequiredCreationPolicy();
    public abstract virtual ImportCardinality get_Cardinality();
    public abstract virtual ImportSource get_Source();
}
public interface System.ComponentModel.Composition.ICompositionService {
    public abstract virtual void SatisfyImportsOnce(ComposablePart part);
}
[AttributeUsageAttribute("2432")]
public class System.ComponentModel.Composition.ImportAttribute : Attribute {
    public string ContractName { get; private set; }
    public Type ContractType { get; private set; }
    public bool AllowDefault { get; public set; }
    public bool AllowRecomposition { get; public set; }
    public CreationPolicy RequiredCreationPolicy { get; public set; }
    public ImportSource Source { get; public set; }
    private ImportCardinality System.ComponentModel.Composition.IAttributedImport.Cardinality { get; }
    public ImportAttribute(Type contractType);
    public ImportAttribute(string contractName);
    public ImportAttribute(string contractName, Type contractType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContractName();
    [CompilerGeneratedAttribute]
private void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ContractType();
    [CompilerGeneratedAttribute]
private void set_ContractType(Type value);
    [CompilerGeneratedAttribute]
public bool get_AllowDefault();
    [CompilerGeneratedAttribute]
public void set_AllowDefault(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowRecomposition();
    [CompilerGeneratedAttribute]
public void set_AllowRecomposition(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CreationPolicy get_RequiredCreationPolicy();
    [CompilerGeneratedAttribute]
public void set_RequiredCreationPolicy(CreationPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual ImportSource get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ImportSource value);
    private sealed virtual override ImportCardinality System.ComponentModel.Composition.IAttributedImport.get_Cardinality();
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.ImportCardinalityMismatchExceptionDebuggerProxy")]
[DebuggerDisplayAttribute("{Message}")]
public class System.ComponentModel.Composition.ImportCardinalityMismatchException : Exception {
    public ImportCardinalityMismatchException(string message);
    public ImportCardinalityMismatchException(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected ImportCardinalityMismatchException(SerializationInfo info, StreamingContext context);
}
internal class System.ComponentModel.Composition.ImportCardinalityMismatchExceptionDebuggerProxy : object {
    public Exception InnerException { get; }
    public string Message { get; }
    public ImportCardinalityMismatchExceptionDebuggerProxy(ImportCardinalityMismatchException exception);
    public Exception get_InnerException();
    public string get_Message();
}
[AttributeUsageAttribute("32")]
public class System.ComponentModel.Composition.ImportingConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.ComponentModel.Composition.ImportManyAttribute : Attribute {
    public string ContractName { get; private set; }
    public Type ContractType { get; private set; }
    public bool AllowRecomposition { get; public set; }
    public CreationPolicy RequiredCreationPolicy { get; public set; }
    public ImportSource Source { get; public set; }
    private ImportCardinality System.ComponentModel.Composition.IAttributedImport.Cardinality { get; }
    public ImportManyAttribute(Type contractType);
    public ImportManyAttribute(string contractName);
    public ImportManyAttribute(string contractName, Type contractType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContractName();
    [CompilerGeneratedAttribute]
private void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ContractType();
    [CompilerGeneratedAttribute]
private void set_ContractType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowRecomposition();
    [CompilerGeneratedAttribute]
public void set_AllowRecomposition(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual CreationPolicy get_RequiredCreationPolicy();
    [CompilerGeneratedAttribute]
public void set_RequiredCreationPolicy(CreationPolicy value);
    [CompilerGeneratedAttribute]
public sealed virtual ImportSource get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(ImportSource value);
    private sealed virtual override ImportCardinality System.ComponentModel.Composition.IAttributedImport.get_Cardinality();
}
public enum System.ComponentModel.Composition.ImportSource : Enum {
    public int value__;
    public static ImportSource Any;
    public static ImportSource Local;
    public static ImportSource NonLocal;
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.Composition.InheritedExportAttribute : ExportAttribute {
    public InheritedExportAttribute(Type contractType);
    public InheritedExportAttribute(string contractName);
    public InheritedExportAttribute(string contractName, Type contractType);
}
public interface System.ComponentModel.Composition.IPartImportsSatisfiedNotification {
    public abstract virtual void OnImportsSatisfied();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Composition.MetadataAttributeAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.MetadataServices : object {
    public static IDictionary`2<string, object> EmptyMetadata;
    private static MetadataServices();
    [ExtensionAttribute]
public static IDictionary`2<string, object> AsReadOnly(IDictionary`2<string, object> metadata);
    [ExtensionAttribute]
public static T GetValue(IDictionary`2<string, object> metadata, string key);
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.MetadataViewGenerator : object {
    public static string MetadataViewType;
    public static string MetadataItemKey;
    public static string MetadataItemTargetType;
    public static string MetadataItemSourceType;
    public static string MetadataItemValue;
    public static string MetadataViewFactoryName;
    private static MetadataViewGenerator();
    public static MetadataViewFactory GetMetadataViewFactory(Type viewType);
    public static TMetadataView CreateMetadataView(MetadataViewFactory metadataViewFactory, IDictionary`2<string, object> metadata);
}
[AttributeUsageAttribute("1024")]
public class System.ComponentModel.Composition.MetadataViewImplementationAttribute : Attribute {
    public Type ImplementationType { get; private set; }
    public MetadataViewImplementationAttribute(Type implementationType);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
private void set_ImplementationType(Type value);
}
internal static class System.ComponentModel.Composition.MetadataViewProvider : object {
    public static TMetadataView GetMetadataView(IDictionary`2<string, object> metadata);
    public static bool IsViewTypeValid(Type metadataViewType);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Composition.PartCreationPolicyAttribute : Attribute {
    internal static PartCreationPolicyAttribute Default;
    internal static PartCreationPolicyAttribute Shared;
    public CreationPolicy CreationPolicy { get; private set; }
    public PartCreationPolicyAttribute(CreationPolicy creationPolicy);
    private static PartCreationPolicyAttribute();
    [CompilerGeneratedAttribute]
public CreationPolicy get_CreationPolicy();
    [CompilerGeneratedAttribute]
private void set_CreationPolicy(CreationPolicy value);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Composition.PartMetadataAttribute : Attribute {
    public string Name { get; private set; }
    public object Value { get; private set; }
    public PartMetadataAttribute(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Composition.PartNotDiscoverableAttribute : Attribute {
}
public abstract class System.ComponentModel.Composition.Primitives.ComposablePart : object {
    public IEnumerable`1<ExportDefinition> ExportDefinitions { get; }
    public IEnumerable`1<ImportDefinition> ImportDefinitions { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public abstract virtual IEnumerable`1<ExportDefinition> get_ExportDefinitions();
    public abstract virtual IEnumerable`1<ImportDefinition> get_ImportDefinitions();
    public virtual IDictionary`2<string, object> get_Metadata();
    public virtual void Activate();
    public abstract virtual object GetExportedValue(ExportDefinition definition);
    public abstract virtual void SetImport(ImportDefinition definition, IEnumerable`1<Export> exports);
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Primitives.ComposablePartCatalogDebuggerProxy")]
public abstract class System.ComponentModel.Composition.Primitives.ComposablePartCatalog : object {
    internal static List`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> _EmptyExportsList;
    [EditorBrowsableAttribute("1")]
public IQueryable`1<ComposablePartDefinition> Parts { get; }
    private static ComposablePartCatalog();
    public virtual IQueryable`1<ComposablePartDefinition> get_Parts();
    public virtual IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition);
    internal virtual IEnumerable`1<ComposablePartDefinition> GetCandidateParts(ImportDefinition definition);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<ComposablePartDefinition> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.ComponentModel.Composition.Primitives.ComposablePartCatalogDebuggerProxy : object {
    public ReadOnlyCollection`1<ComposablePartDefinition> Parts { get; }
    public ComposablePartCatalogDebuggerProxy(ComposablePartCatalog catalog);
    public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts();
}
public abstract class System.ComponentModel.Composition.Primitives.ComposablePartDefinition : object {
    internal static IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> _EmptyExports;
    public IEnumerable`1<ExportDefinition> ExportDefinitions { get; }
    public IEnumerable`1<ImportDefinition> ImportDefinitions { get; }
    public IDictionary`2<string, object> Metadata { get; }
    private static ComposablePartDefinition();
    public abstract virtual IEnumerable`1<ExportDefinition> get_ExportDefinitions();
    public abstract virtual IEnumerable`1<ImportDefinition> get_ImportDefinitions();
    public virtual IDictionary`2<string, object> get_Metadata();
    public abstract virtual ComposablePart CreatePart();
    internal virtual bool TryGetExports(ImportDefinition definition, Tuple`2& singleMatch, IEnumerable`1& multipleMatches);
    internal virtual ComposablePartDefinition GetGenericPartDefinition();
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Primitives.ComposablePartExceptionDebuggerProxy")]
[DebuggerDisplayAttribute("{Message}")]
public class System.ComponentModel.Composition.Primitives.ComposablePartException : Exception {
    public ICompositionElement Element { get; }
    public ComposablePartException(string message);
    public ComposablePartException(string message, ICompositionElement element);
    public ComposablePartException(string message, Exception innerException);
    public ComposablePartException(string message, ICompositionElement element, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected ComposablePartException(SerializationInfo info, StreamingContext context);
    public ICompositionElement get_Element();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.ComponentModel.Composition.Primitives.ComposablePartExceptionDebuggerProxy : object {
    public ICompositionElement Element { get; }
    public Exception InnerException { get; }
    public string Message { get; }
    public ComposablePartExceptionDebuggerProxy(ComposablePartException exception);
    public ICompositionElement get_Element();
    public Exception get_InnerException();
    public string get_Message();
}
[DebuggerTypeProxyAttribute("System.ComponentModel.Composition.Primitives.CompositionElementDebuggerProxy")]
internal class System.ComponentModel.Composition.Primitives.CompositionElement : SerializableCompositionElement {
    public object UnderlyingObject { get; }
    public CompositionElement(object underlyingObject);
    private static CompositionElement();
    public object get_UnderlyingObject();
}
internal class System.ComponentModel.Composition.Primitives.CompositionElementDebuggerProxy : object {
    public string DisplayName { get; }
    public ICompositionElement Origin { get; }
    public object UnderlyingObject { get; }
    public CompositionElementDebuggerProxy(CompositionElement element);
    public string get_DisplayName();
    public ICompositionElement get_Origin();
    public object get_UnderlyingObject();
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.Primitives.CompositionElementExtensions : object {
    [ExtensionAttribute]
public static ICompositionElement ToSerializableElement(ICompositionElement element);
    [ExtensionAttribute]
public static ICompositionElement ToElement(Export export);
    [ExtensionAttribute]
public static ICompositionElement ToElement(ExportDefinition definition);
    [ExtensionAttribute]
public static ICompositionElement ToElement(ImportDefinition definition);
    [ExtensionAttribute]
public static ICompositionElement ToElement(ComposablePart part);
    [ExtensionAttribute]
public static ICompositionElement ToElement(ComposablePartDefinition definition);
    [ExtensionAttribute]
public static string GetDisplayName(ComposablePartDefinition definition);
    [ExtensionAttribute]
public static string GetDisplayName(ComposablePartCatalog catalog);
}
public class System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : ImportDefinition {
    public string RequiredTypeIdentity { get; }
    public IEnumerable`1<KeyValuePair`2<string, Type>> RequiredMetadata { get; }
    public CreationPolicy RequiredCreationPolicy { get; }
    public Expression`1<Func`2<ExportDefinition, bool>> Constraint { get; }
    public ContractBasedImportDefinition(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy);
    public ContractBasedImportDefinition(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata);
    public virtual string get_RequiredTypeIdentity();
    public virtual IEnumerable`1<KeyValuePair`2<string, Type>> get_RequiredMetadata();
    public virtual CreationPolicy get_RequiredCreationPolicy();
    public virtual Expression`1<Func`2<ExportDefinition, bool>> get_Constraint();
    public virtual bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition);
    public virtual string ToString();
}
public class System.ComponentModel.Composition.Primitives.Export : object {
    public ExportDefinition Definition { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public object Value { get; }
    public Export(string contractName, Func`1<object> exportedValueGetter);
    public Export(string contractName, IDictionary`2<string, object> metadata, Func`1<object> exportedValueGetter);
    public Export(ExportDefinition definition, Func`1<object> exportedValueGetter);
    private static Export();
    public virtual ExportDefinition get_Definition();
    public IDictionary`2<string, object> get_Metadata();
    public object get_Value();
    protected virtual object GetExportedValueCore();
}
public class System.ComponentModel.Composition.Primitives.ExportDefinition : object {
    public string ContractName { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public ExportDefinition(string contractName, IDictionary`2<string, object> metadata);
    public virtual string get_ContractName();
    public virtual IDictionary`2<string, object> get_Metadata();
    public virtual string ToString();
}
public class System.ComponentModel.Composition.Primitives.ExportedDelegate : object {
    [SecurityCriticalAttribute]
public ExportedDelegate(object instance, MethodInfo method);
    public virtual Delegate CreateDelegate(Type delegateType);
}
public interface System.ComponentModel.Composition.Primitives.ICompositionElement {
    public string DisplayName { get; }
    public ICompositionElement Origin { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual ICompositionElement get_Origin();
}
public enum System.ComponentModel.Composition.Primitives.ImportCardinality : Enum {
    public int value__;
    public static ImportCardinality ZeroOrOne;
    public static ImportCardinality ExactlyOne;
    public static ImportCardinality ZeroOrMore;
}
public class System.ComponentModel.Composition.Primitives.ImportDefinition : object {
    internal static string EmptyContractName;
    public string ContractName { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public ImportCardinality Cardinality { get; }
    public Expression`1<Func`2<ExportDefinition, bool>> Constraint { get; }
    public bool IsPrerequisite { get; }
    public bool IsRecomposable { get; }
    public ImportDefinition(Expression`1<Func`2<ExportDefinition, bool>> constraint, string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite);
    public ImportDefinition(Expression`1<Func`2<ExportDefinition, bool>> constraint, string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, IDictionary`2<string, object> metadata);
    internal ImportDefinition(string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, IDictionary`2<string, object> metadata);
    private static ImportDefinition();
    public virtual string get_ContractName();
    public virtual IDictionary`2<string, object> get_Metadata();
    public virtual ImportCardinality get_Cardinality();
    public virtual Expression`1<Func`2<ExportDefinition, bool>> get_Constraint();
    public virtual bool get_IsPrerequisite();
    public virtual bool get_IsRecomposable();
    public virtual bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition);
    public virtual string ToString();
}
internal interface System.ComponentModel.Composition.Primitives.IPartCreatorImportDefinition {
    public ContractBasedImportDefinition ProductImportDefinition { get; }
    public abstract virtual ContractBasedImportDefinition get_ProductImportDefinition();
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.Primitives.PrimitivesServices : object {
    [ExtensionAttribute]
public static bool IsGeneric(ComposablePartDefinition part);
    [ExtensionAttribute]
public static ImportDefinition GetProductImportDefinition(ImportDefinition import);
    [IteratorStateMachineAttribute("System.ComponentModel.Composition.Primitives.PrimitivesServices/<GetCandidateContractNames>d__2")]
[ExtensionAttribute]
internal static IEnumerable`1<string> GetCandidateContractNames(ImportDefinition import, ComposablePartDefinition part);
    [ExtensionAttribute]
internal static bool IsImportDependentOnPart(ImportDefinition import, ComposablePartDefinition part, ExportDefinition export, bool expandGenerics);
}
internal class System.ComponentModel.Composition.Primitives.SerializableCompositionElement : object {
    public string DisplayName { get; }
    public ICompositionElement Origin { get; }
    public SerializableCompositionElement(string displayName, ICompositionElement origin);
    public sealed virtual string get_DisplayName();
    public sealed virtual ICompositionElement get_Origin();
    public virtual string ToString();
    public static ICompositionElement FromICompositionElement(ICompositionElement element);
}
internal class System.ComponentModel.Composition.ReflectionModel.DisposableReflectionComposablePart : ReflectionComposablePart {
    public DisposableReflectionComposablePart(ReflectionComposablePartDefinition definition);
    protected virtual void ReleaseInstanceIfNecessary(object instance);
    protected virtual void EnsureRunning();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class System.ComponentModel.Composition.ReflectionModel.ExportFactoryCreator : object {
    public ExportFactoryCreator(Type exportFactoryType);
    private static ExportFactoryCreator();
    public Func`2<Export, object> CreateStronglyTypedExportFactoryFactory(Type exportType, Type metadataViewType);
}
internal class System.ComponentModel.Composition.ReflectionModel.ExportingMember : object {
    public bool RequiresInstance { get; }
    public ExportDefinition Definition { get; }
    public ExportingMember(ExportDefinition definition, ReflectionMember member);
    public bool get_RequiresInstance();
    public ExportDefinition get_Definition();
    public object GetExportedValue(object instance, object lock);
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.ReflectionModel.GenericServices : object {
    [ExtensionAttribute]
internal static IList`1<Type> GetPureGenericParameters(Type type);
    [ExtensionAttribute]
internal static int GetPureGenericArity(Type type);
    public static Int32[] GetGenericParametersOrder(Type type);
    public static string GetGenericName(string originalGenericName, Int32[] genericParametersOrder, int genericArity);
    public static T[] Reorder(T[] original, Int32[] genericParametersOrder);
    [ExtensionAttribute]
public static IEnumerable`1<Type> CreateTypeSpecializations(Type[] types, Type[] specializationTypes);
    [ExtensionAttribute]
public static Type CreateTypeSpecialization(Type type, Type[] specializationTypes);
    public static bool CanSpecialize(Type type, IEnumerable`1<Type> constraints, GenericParameterAttributes attributes);
    public static bool CanSpecialize(Type type, IEnumerable`1<Type> constraintTypes);
    public static bool CanSpecialize(Type type, GenericParameterAttributes attributes);
}
internal class System.ComponentModel.Composition.ReflectionModel.GenericSpecializationPartCreationInfo : object {
    public ReflectionComposablePartDefinition OriginalPart { get; }
    public bool IsDisposalRequired { get; }
    public bool IsIdentityComparison { get; }
    public string DisplayName { get; }
    public ICompositionElement Origin { get; }
    public GenericSpecializationPartCreationInfo(IReflectionPartCreationInfo originalPartCreationInfo, ReflectionComposablePartDefinition originalPart, Type[] specialization);
    public ReflectionComposablePartDefinition get_OriginalPart();
    public sealed virtual Type GetPartType();
    public sealed virtual Lazy`1<Type> GetLazyPartType();
    public sealed virtual ConstructorInfo GetConstructor();
    public sealed virtual IDictionary`2<string, object> GetMetadata();
    public ExportDefinition TranslateExpot(ReflectionMemberExportDefinition reflectionExport, List`1<LazyMemberInfo> members);
    public sealed virtual IEnumerable`1<ExportDefinition> GetExports();
    public sealed virtual IEnumerable`1<ImportDefinition> GetImports();
    public sealed virtual bool get_IsDisposalRequired();
    public sealed virtual bool get_IsIdentityComparison();
    public sealed virtual string get_DisplayName();
    public sealed virtual ICompositionElement get_Origin();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool CanSpecialize(IDictionary`2<string, object> partMetadata, Type[] specialization);
}
internal abstract class System.ComponentModel.Composition.ReflectionModel.ImportingItem : object {
    public ContractBasedImportDefinition Definition { get; }
    public ImportType ImportType { get; }
    protected ImportingItem(ContractBasedImportDefinition definition, ImportType importType);
    public ContractBasedImportDefinition get_Definition();
    public ImportType get_ImportType();
    public object CastExportsToImportType(Export[] exports);
}
internal class System.ComponentModel.Composition.ReflectionModel.ImportingMember : ImportingItem {
    public ImportingMember(ContractBasedImportDefinition definition, ReflectionWritableMember member, ImportType importType);
    public void SetExportedValue(object instance, object value);
}
internal class System.ComponentModel.Composition.ReflectionModel.ImportingParameter : ImportingItem {
    public ImportingParameter(ContractBasedImportDefinition definition, ImportType importType);
}
internal class System.ComponentModel.Composition.ReflectionModel.ImportType : object {
    [ThreadStaticAttribute]
internal static Dictionary`2<Type, Func`2<Export, object>> _castSingleValueCache;
    public bool IsAssignableCollectionType { get; }
    public Type ElementType { get; private set; }
    public Type ActualType { get; }
    public bool IsPartCreator { get; private set; }
    public Type ContractType { get; }
    public Func`2<Export, object> CastExport { get; }
    public Type MetadataViewType { get; private set; }
    public ImportType(Type type, ImportCardinality cardinality);
    private static ImportType();
    public bool get_IsAssignableCollectionType();
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    public Type get_ActualType();
    [CompilerGeneratedAttribute]
public bool get_IsPartCreator();
    [CompilerGeneratedAttribute]
private void set_IsPartCreator(bool value);
    public Type get_ContractType();
    public Func`2<Export, object> get_CastExport();
    [CompilerGeneratedAttribute]
public Type get_MetadataViewType();
    [CompilerGeneratedAttribute]
private void set_MetadataViewType(Type value);
    public static bool IsDescendentOf(Type type, Type baseType);
}
internal interface System.ComponentModel.Composition.ReflectionModel.IReflectionPartCreationInfo {
    public bool IsDisposalRequired { get; }
    public bool IsIdentityComparison { get; }
    public abstract virtual Type GetPartType();
    public abstract virtual Lazy`1<Type> GetLazyPartType();
    public abstract virtual ConstructorInfo GetConstructor();
    public abstract virtual IDictionary`2<string, object> GetMetadata();
    public abstract virtual IEnumerable`1<ExportDefinition> GetExports();
    public abstract virtual IEnumerable`1<ImportDefinition> GetImports();
    public abstract virtual bool get_IsDisposalRequired();
    public abstract virtual bool get_IsIdentityComparison();
}
internal class System.ComponentModel.Composition.ReflectionModel.LazyExportDefinition : ExportDefinition {
    public IDictionary`2<string, object> Metadata { get; }
    public LazyExportDefinition(string contractName, Lazy`1<IDictionary`2<string, object>> metadata);
    public virtual IDictionary`2<string, object> get_Metadata();
}
public class System.ComponentModel.Composition.ReflectionModel.LazyMemberInfo : ValueType {
    private MemberTypes _memberType;
    private MemberInfo[] _accessors;
    private Func`1<MemberInfo[]> _accessorsCreator;
    public MemberTypes MemberType { get; }
    public LazyMemberInfo(MemberInfo member);
    public LazyMemberInfo(MemberTypes memberType, MemberInfo[] accessors);
    public LazyMemberInfo(MemberTypes memberType, Func`1<MemberInfo[]> accessorsCreator);
    public MemberTypes get_MemberType();
    public MemberInfo[] GetAccessors();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LazyMemberInfo left, LazyMemberInfo right);
    public static bool op_Inequality(LazyMemberInfo left, LazyMemberInfo right);
}
internal class System.ComponentModel.Composition.ReflectionModel.PartCreatorExportDefinition : ExportDefinition {
    public string ContractName { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public PartCreatorExportDefinition(ExportDefinition productDefinition);
    public virtual string get_ContractName();
    public virtual IDictionary`2<string, object> get_Metadata();
    internal static bool IsProductConstraintSatisfiedBy(ImportDefinition productImportDefinition, ExportDefinition exportDefinition);
}
internal class System.ComponentModel.Composition.ReflectionModel.PartCreatorMemberImportDefinition : ReflectionMemberImportDefinition {
    public ContractBasedImportDefinition ProductImportDefinition { get; }
    public Expression`1<Func`2<ExportDefinition, bool>> Constraint { get; }
    public PartCreatorMemberImportDefinition(LazyMemberInfo importingLazyMember, ICompositionElement origin, ContractBasedImportDefinition productImportDefinition);
    public sealed virtual ContractBasedImportDefinition get_ProductImportDefinition();
    public virtual bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition);
    public virtual Expression`1<Func`2<ExportDefinition, bool>> get_Constraint();
    public virtual string ToString();
}
internal class System.ComponentModel.Composition.ReflectionModel.PartCreatorParameterImportDefinition : ReflectionParameterImportDefinition {
    public ContractBasedImportDefinition ProductImportDefinition { get; }
    public Expression`1<Func`2<ExportDefinition, bool>> Constraint { get; }
    public PartCreatorParameterImportDefinition(Lazy`1<ParameterInfo> importingLazyParameter, ICompositionElement origin, ContractBasedImportDefinition productImportDefinition);
    public sealed virtual ContractBasedImportDefinition get_ProductImportDefinition();
    public virtual bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition);
    public virtual Expression`1<Func`2<ExportDefinition, bool>> get_Constraint();
    public virtual string ToString();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionComposablePart : ComposablePart {
    protected object CachedInstance { get; }
    public ReflectionComposablePartDefinition Definition { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IEnumerable`1<ImportDefinition> ImportDefinitions { get; }
    public IEnumerable`1<ExportDefinition> ExportDefinitions { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public ReflectionComposablePart(ReflectionComposablePartDefinition definition);
    public ReflectionComposablePart(ReflectionComposablePartDefinition definition, object attributedPart);
    protected virtual void EnsureRunning();
    protected void RequiresRunning();
    protected virtual void ReleaseInstanceIfNecessary(object instance);
    protected object get_CachedInstance();
    public ReflectionComposablePartDefinition get_Definition();
    public virtual IDictionary`2<string, object> get_Metadata();
    public sealed virtual IEnumerable`1<ImportDefinition> get_ImportDefinitions();
    public sealed virtual IEnumerable`1<ExportDefinition> get_ExportDefinitions();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public virtual object GetExportedValue(ExportDefinition definition);
    public virtual void SetImport(ImportDefinition definition, IEnumerable`1<Export> exports);
    public virtual void Activate();
    public virtual string ToString();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionComposablePartDefinition : ComposablePartDefinition {
    public IEnumerable`1<ExportDefinition> ExportDefinitions { get; }
    public IEnumerable`1<ImportDefinition> ImportDefinitions { get; }
    public IDictionary`2<string, object> Metadata { get; }
    internal bool IsDisposalRequired { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public ReflectionComposablePartDefinition(IReflectionPartCreationInfo creationInfo);
    public Type GetPartType();
    public Lazy`1<Type> GetLazyPartType();
    public ConstructorInfo GetConstructor();
    public virtual IEnumerable`1<ExportDefinition> get_ExportDefinitions();
    public virtual IEnumerable`1<ImportDefinition> get_ImportDefinitions();
    public virtual IDictionary`2<string, object> get_Metadata();
    internal bool get_IsDisposalRequired();
    public virtual ComposablePart CreatePart();
    internal virtual ComposablePartDefinition GetGenericPartDefinition();
    internal virtual bool TryGetExports(ImportDefinition definition, Tuple`2& singleMatch, IEnumerable`1& multipleMatches);
    internal bool TryMakeGenericPartDefinition(Type[] genericTypeParameters, ComposablePartDefinition& genericPartDefinition);
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class System.ComponentModel.Composition.ReflectionModel.ReflectionExtensions : object {
    [ExtensionAttribute]
public static ReflectionMember ToReflectionMember(LazyMemberInfo lazyMember);
    [ExtensionAttribute]
public static LazyMemberInfo ToLazyMember(MemberInfo member);
    [ExtensionAttribute]
public static ReflectionWritableMember ToReflectionWriteableMember(LazyMemberInfo lazyMember);
    [ExtensionAttribute]
public static ReflectionProperty ToReflectionProperty(PropertyInfo property);
    public static ReflectionProperty CreateReflectionProperty(MethodInfo getMethod, MethodInfo setMethod);
    [ExtensionAttribute]
public static ReflectionParameter ToReflectionParameter(ParameterInfo parameter);
    [ExtensionAttribute]
public static ReflectionMethod ToReflectionMethod(MethodInfo method);
    [ExtensionAttribute]
public static ReflectionField ToReflectionField(FieldInfo field);
    [ExtensionAttribute]
public static ReflectionType ToReflectionType(Type type);
    [ExtensionAttribute]
public static ReflectionWritableMember ToReflectionWritableMember(MemberInfo member);
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionField : ReflectionWritableMember {
    public FieldInfo UndelyingField { get; }
    public MemberInfo UnderlyingMember { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool RequiresInstance { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public ReflectionField(FieldInfo field);
    public FieldInfo get_UndelyingField();
    public virtual MemberInfo get_UnderlyingMember();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_RequiresInstance();
    public virtual Type get_ReturnType();
    public virtual ReflectionItemType get_ItemType();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
internal abstract class System.ComponentModel.Composition.ReflectionModel.ReflectionImportDefinition : ContractBasedImportDefinition {
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public ReflectionImportDefinition(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin);
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public abstract virtual ImportingItem ToImportingItem();
    protected abstract virtual string GetDisplayName();
}
internal abstract class System.ComponentModel.Composition.ReflectionModel.ReflectionItem : object {
    public string Name { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public abstract virtual string get_Name();
    public abstract virtual string GetDisplayName();
    public abstract virtual Type get_ReturnType();
    public abstract virtual ReflectionItemType get_ItemType();
}
internal enum System.ComponentModel.Composition.ReflectionModel.ReflectionItemType : Enum {
    public int value__;
    public static ReflectionItemType Parameter;
    public static ReflectionItemType Field;
    public static ReflectionItemType Property;
    public static ReflectionItemType Method;
    public static ReflectionItemType Type;
}
internal abstract class System.ComponentModel.Composition.ReflectionModel.ReflectionMember : ReflectionItem {
    public bool CanRead { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool RequiresInstance { get; }
    public MemberInfo UnderlyingMember { get; }
    public abstract virtual bool get_CanRead();
    public Type get_DeclaringType();
    public virtual string get_Name();
    public virtual string GetDisplayName();
    public abstract virtual bool get_RequiresInstance();
    public abstract virtual MemberInfo get_UnderlyingMember();
    public abstract virtual object GetValue(object instance);
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionMemberExportDefinition : ExportDefinition {
    public string ContractName { get; }
    public LazyMemberInfo ExportingLazyMember { get; }
    public IDictionary`2<string, object> Metadata { get; }
    private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName { get; }
    private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin { get; }
    public ReflectionMemberExportDefinition(LazyMemberInfo member, ExportDefinition exportDefinition, ICompositionElement origin);
    public virtual string get_ContractName();
    public LazyMemberInfo get_ExportingLazyMember();
    public virtual IDictionary`2<string, object> get_Metadata();
    private sealed virtual override string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName();
    private sealed virtual override ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin();
    public virtual string ToString();
    public int GetIndex();
    public ExportingMember ToExportingMember();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionMemberImportDefinition : ReflectionImportDefinition {
    public LazyMemberInfo ImportingLazyMember { get; }
    public ReflectionMemberImportDefinition(LazyMemberInfo importingLazyMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin);
    public virtual ImportingItem ToImportingItem();
    public LazyMemberInfo get_ImportingLazyMember();
    protected virtual string GetDisplayName();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionMethod : ReflectionMember {
    public MethodInfo UnderlyingMethod { get; }
    public MemberInfo UnderlyingMember { get; }
    public bool CanRead { get; }
    public bool RequiresInstance { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public ReflectionMethod(MethodInfo method);
    public MethodInfo get_UnderlyingMethod();
    public virtual MemberInfo get_UnderlyingMember();
    public virtual bool get_CanRead();
    public virtual bool get_RequiresInstance();
    public virtual Type get_ReturnType();
    public virtual ReflectionItemType get_ItemType();
    public virtual object GetValue(object instance);
}
[SecurityCriticalAttribute]
public static class System.ComponentModel.Composition.ReflectionModel.ReflectionModelServices : object {
    public static Lazy`1<Type> GetPartType(ComposablePartDefinition partDefinition);
    public static bool IsDisposalRequired(ComposablePartDefinition partDefinition);
    public static LazyMemberInfo GetExportingMember(ExportDefinition exportDefinition);
    public static LazyMemberInfo GetImportingMember(ImportDefinition importDefinition);
    public static Lazy`1<ParameterInfo> GetImportingParameter(ImportDefinition importDefinition);
    public static bool IsImportingParameter(ImportDefinition importDefinition);
    public static bool IsExportFactoryImportDefinition(ImportDefinition importDefinition);
    public static ContractBasedImportDefinition GetExportFactoryProductImportDefinition(ImportDefinition importDefinition);
    public static ComposablePartDefinition CreatePartDefinition(Lazy`1<Type> partType, bool isDisposalRequired, Lazy`1<IEnumerable`1<ImportDefinition>> imports, Lazy`1<IEnumerable`1<ExportDefinition>> exports, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin);
    public static ExportDefinition CreateExportDefinition(LazyMemberInfo exportingMember, string contractName, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin);
    public static ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, CreationPolicy requiredCreationPolicy, ICompositionElement origin);
    public static ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin);
    public static ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPreRequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin);
    public static ContractBasedImportDefinition CreateImportDefinition(Lazy`1<ParameterInfo> parameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, ICompositionElement origin);
    public static ContractBasedImportDefinition CreateImportDefinition(Lazy`1<ParameterInfo> parameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin);
    public static bool TryMakeGenericPartDefinition(ComposablePartDefinition partDefinition, IEnumerable`1<Type> genericParameters, ComposablePartDefinition& specialization);
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionParameter : ReflectionItem {
    public ParameterInfo UnderlyingParameter { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public ReflectionParameter(ParameterInfo parameter);
    public ParameterInfo get_UnderlyingParameter();
    public virtual string get_Name();
    public virtual string GetDisplayName();
    public virtual Type get_ReturnType();
    public virtual ReflectionItemType get_ItemType();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionParameterImportDefinition : ReflectionImportDefinition {
    public Lazy`1<ParameterInfo> ImportingLazyParameter { get; }
    public ReflectionParameterImportDefinition(Lazy`1<ParameterInfo> importingLazyParameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin);
    public virtual ImportingItem ToImportingItem();
    public Lazy`1<ParameterInfo> get_ImportingLazyParameter();
    protected virtual string GetDisplayName();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionPartCreationInfo : object {
    public bool IsDisposalRequired { get; }
    public bool IsIdentityComparison { get; }
    public string DisplayName { get; }
    public ICompositionElement Origin { get; }
    public ReflectionPartCreationInfo(Lazy`1<Type> partType, bool isDisposalRequired, Lazy`1<IEnumerable`1<ImportDefinition>> imports, Lazy`1<IEnumerable`1<ExportDefinition>> exports, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin);
    public sealed virtual Type GetPartType();
    public sealed virtual Lazy`1<Type> GetLazyPartType();
    public sealed virtual ConstructorInfo GetConstructor();
    public sealed virtual bool get_IsDisposalRequired();
    public sealed virtual bool get_IsIdentityComparison();
    public sealed virtual IDictionary`2<string, object> GetMetadata();
    [IteratorStateMachineAttribute("System.ComponentModel.Composition.ReflectionModel.ReflectionPartCreationInfo/<GetExports>d__16")]
public sealed virtual IEnumerable`1<ExportDefinition> GetExports();
    [IteratorStateMachineAttribute("System.ComponentModel.Composition.ReflectionModel.ReflectionPartCreationInfo/<GetImports>d__17")]
public sealed virtual IEnumerable`1<ImportDefinition> GetImports();
    public sealed virtual string get_DisplayName();
    public sealed virtual ICompositionElement get_Origin();
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionProperty : ReflectionWritableMember {
    public MemberInfo UnderlyingMember { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo UnderlyingGetMethod { get; }
    public MethodInfo UnderlyingSetMethod { get; }
    public string Name { get; }
    public bool RequiresInstance { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public ReflectionProperty(MethodInfo getMethod, MethodInfo setMethod);
    public virtual MemberInfo get_UnderlyingMember();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public MethodInfo get_UnderlyingGetMethod();
    public MethodInfo get_UnderlyingSetMethod();
    public virtual string get_Name();
    public virtual string GetDisplayName();
    public virtual bool get_RequiresInstance();
    public virtual Type get_ReturnType();
    public virtual ReflectionItemType get_ItemType();
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
}
internal class System.ComponentModel.Composition.ReflectionModel.ReflectionType : ReflectionMember {
    public MemberInfo UnderlyingMember { get; }
    public bool CanRead { get; }
    public bool RequiresInstance { get; }
    public Type ReturnType { get; }
    public ReflectionItemType ItemType { get; }
    public ReflectionType(Type type);
    public virtual MemberInfo get_UnderlyingMember();
    public virtual bool get_CanRead();
    public virtual bool get_RequiresInstance();
    public virtual Type get_ReturnType();
    public virtual ReflectionItemType get_ItemType();
    public virtual object GetValue(object instance);
}
internal abstract class System.ComponentModel.Composition.ReflectionModel.ReflectionWritableMember : ReflectionMember {
    public bool CanWrite { get; }
    public abstract virtual bool get_CanWrite();
    public abstract virtual void SetValue(object instance, object value);
}
public class System.Lazy`2 : Lazy`1<T> {
    public TMetadata Metadata { get; }
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
