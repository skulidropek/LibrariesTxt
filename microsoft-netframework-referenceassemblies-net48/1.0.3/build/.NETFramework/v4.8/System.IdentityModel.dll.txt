internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string EcmaPublicKeyFull;
    internal static string SilverlightPublicKey;
    internal static string SilverlightPublicKeyToken;
    internal static string SilverlightPublicKeyFull;
    internal static string SilverlightPlatformPublicKey;
    internal static string SilverlightPlatformPublicKeyToken;
    internal static string SilverlightPlatformPublicKeyFull;
    internal static string PlatformPublicKey;
    internal static string PlatformPublicKeyToken;
    internal static string PlatformPublicKeyFull;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string SystemDataOracleClient;
    internal static string System;
    internal static string SystemCore;
    internal static string SystemNumerics;
    internal static string SystemRuntimeRemoting;
    internal static string SystemThreadingTasksDataflow;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string MicrosoftPublicKeyToken;
    internal static string MicrosoftPublicKeyFull;
    internal static string SharedLibPublicKey;
    internal static string SharedLibPublicKeyToken;
    internal static string SharedLibPublicKeyFull;
    internal static string SystemComponentModelDataAnnotations;
    internal static string SystemConfiguration;
    internal static string SystemConfigurationInstall;
    internal static string SystemDeployment;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemNetHttp;
    internal static string SystemNetHttpWebRequest;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemRuntimeWindowsRuntime;
    internal static string SystemRuntimeWindowsRuntimeUIXaml;
    internal static string SystemSecurity;
    internal static string SystemServiceModelWeb;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebAbstractions;
    internal static string SystemWebDynamicData;
    internal static string SystemWebDynamicDataDesign;
    internal static string SystemWebEntityDesign;
    internal static string SystemWebExtensions;
    internal static string SystemWebExtensionsDesign;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebRouting;
    internal static string SystemWebServices;
    internal static string WindowsBase;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVisualStudioWindowsForms;
    internal static string VJSharpCodeProvider;
    internal static string ASPBrowserCapsPublicKey;
    internal static string ASPBrowserCapsFactory;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftVisualStudioWeb;
    internal static string MicrosoftWebDesign;
    internal static string MicrosoftVSDesignerMobile;
    internal static string MicrosoftJScript;
}
internal static class FXAssembly : object {
    internal static string Version;
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
}
internal enum System.IdentityModel.Alg : Enum {
    public int value__;
    public static Alg Any;
    public static Alg ClassSignture;
    public static Alg ClassEncrypt;
    public static Alg ClassHash;
    public static Alg ClassKeyXch;
    public static Alg TypeRSA;
    public static Alg TypeBlock;
    public static Alg TypeStream;
    public static Alg TypeDH;
    public static Alg NameDES;
    public static Alg NameRC2;
    public static Alg NameRC4;
    public static Alg NameSkipJack;
    public static Alg NameSHA;
    public static Alg NameDH_Ephem;
    public static Alg Fortezza;
}
internal static class System.IdentityModel.Asn1IntegerConverter : object {
    private static Asn1IntegerConverter();
    public static string Asn1IntegerToDecimalString(Byte[] asn1);
}
public class System.IdentityModel.AsynchronousOperationException : Exception {
    public AsynchronousOperationException(string message);
    public AsynchronousOperationException(string message, Exception innerException);
    public AsynchronousOperationException(Exception innerException);
    protected AsynchronousOperationException(SerializationInfo info, StreamingContext context);
}
public abstract class System.IdentityModel.AsyncResult : object {
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    protected AsyncResult(object state);
    protected AsyncResult(AsyncCallback callback, object state);
    public static void End(IAsyncResult result);
    protected virtual override void Finalize();
    protected void Complete(bool completedSynchronously);
    protected void Complete(bool completedSynchronously, Exception exception);
    protected virtual void Dispose(bool isExplicitDispose);
    public sealed virtual object get_AsyncState();
    public virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    public sealed virtual void Dispose();
}
internal class System.IdentityModel.AuthIdentityEx : ValueType {
    internal int Version;
    internal int Length;
    internal string UserName;
    internal int UserNameLength;
    internal string Domain;
    internal int DomainLength;
    internal string Password;
    internal int PasswordLength;
    internal int Flags;
    internal string PackageList;
    internal int PackageListLength;
    internal AuthIdentityEx(string userName, string password, string domain, String[] additionalPackages);
    private static AuthIdentityEx();
}
public class System.IdentityModel.BadRequestException : RequestException {
    public BadRequestException(string message);
    public BadRequestException(string message, Exception innerException);
    protected BadRequestException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.Bindings : ValueType {
    internal int BindingsLength;
    internal IntPtr pBindings;
}
internal class System.IdentityModel.BoundedCache`1 : object {
    protected ReaderWriterLock CacheLock { get; }
    public int Capacity { get; public set; }
    protected Dictionary`2<string, ExpirableItem`1<T, T>> Items { get; }
    public TimeSpan PurgeInterval { get; public set; }
    public BoundedCache`1(int capacity, TimeSpan purgeInterval);
    public BoundedCache`1(int capacity, TimeSpan purgeInterval, IEqualityComparer`1<string> keyComparer);
    protected ReaderWriterLock get_CacheLock();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual void Clear();
    public virtual int IncreaseCapacity(int size);
    protected Dictionary`2<string, ExpirableItem`1<T, T>> get_Items();
    public TimeSpan get_PurgeInterval();
    public void set_PurgeInterval(TimeSpan value);
    public virtual bool TryAdd(string key, T item, DateTime expirationTime);
    public virtual bool TryFind(string key);
    public virtual bool TryGet(string key, T& item);
    public virtual bool TryRemove(string key);
}
internal abstract class System.IdentityModel.BufferManager : object {
    public abstract virtual Byte[] TakeBuffer(int bufferSize);
    public abstract virtual void ReturnBuffer(Byte[] buffer);
    public abstract virtual void Clear();
    public static BufferManager CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);
    internal static InternalBufferManager GetInternalBufferManager(BufferManager bufferManager);
}
internal class System.IdentityModel.BufferManagerOutputStream : BufferedOutputStream {
    public BufferManagerOutputStream(string quotaExceededString);
    public BufferManagerOutputStream(string quotaExceededString, int maxSize);
    public BufferManagerOutputStream(string quotaExceededString, int initialSize, int maxSize, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, BufferManager bufferManager);
    public void Init(int initialSize, int maxSizeQuota, int effectiveMaxSize, BufferManager bufferManager);
    protected virtual Exception CreateQuotaExceededException(int maxSizeQuota);
}
internal enum System.IdentityModel.BufferType : Enum {
    public int value__;
    public static BufferType Empty;
    public static BufferType Data;
    public static BufferType Token;
    public static BufferType Parameters;
    public static BufferType Missing;
    public static BufferType Extra;
    public static BufferType Trailer;
    public static BufferType Header;
    public static BufferType Padding;
    public static BufferType Stream;
    public static BufferType ChannelBindings;
}
internal abstract class System.IdentityModel.CanonicalFormWriter : object {
    internal static UTF8Encoding Utf8WithoutPreamble;
    private static CanonicalFormWriter();
    protected static void Base64EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] base64WorkBuffer, Byte[] data);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, string s);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars);
    protected static void EncodeAndWrite(Stream stream, Byte[] workBuffer, Char[] chars, int count);
}
internal class System.IdentityModel.CanonicalizationDriver : object {
    public bool CloseReadersAfterProcessing { get; public set; }
    public bool IncludeComments { get; public set; }
    public bool get_CloseReadersAfterProcessing();
    public void set_CloseReadersAfterProcessing(bool value);
    public bool get_IncludeComments();
    public void set_IncludeComments(bool value);
    public String[] GetInclusivePrefixes();
    public void Reset();
    public void SetInclusivePrefixes(String[] inclusivePrefixes);
    public void SetInput(Stream stream);
    public void SetInput(XmlReader reader);
    public Byte[] GetBytes();
    public MemoryStream GetMemoryStream();
    public void WriteTo(HashAlgorithm hashAlgorithm);
    public void WriteTo(Stream canonicalStream);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.IdentityModel.CAPI : object {
    internal static string CRYPT32;
    internal static string BCRYPT;
    internal static string SubjectKeyIdentifierOid;
    internal static int S_OK;
    internal static int S_FALSE;
    internal static string szOID_CRL_DIST_POINTS;
    internal static string szOID_AUTHORITY_INFO_ACCESS;
    internal static UInt32 CERT_STORE_ENUM_ARCHIVED_FLAG;
    internal static UInt32 CERT_STORE_READONLY_FLAG;
    internal static UInt32 CERT_STORE_OPEN_EXISTING_FLAG;
    internal static UInt32 CERT_STORE_CREATE_NEW_FLAG;
    internal static UInt32 CERT_STORE_MAXIMUM_ALLOWED_FLAG;
    internal static UInt32 CERT_STORE_ADD_ALWAYS;
    internal static UInt32 CERT_CHAIN_POLICY_BASE;
    internal static UInt32 CERT_CHAIN_POLICY_NT_AUTH;
    internal static UInt32 X509_ASN_ENCODING;
    internal static UInt32 PKCS_7_ASN_ENCODING;
    internal static UInt32 CERT_STORE_PROV_MEMORY;
    internal static UInt32 CERT_STORE_PROV_SYSTEM;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID;
    internal static UInt32 CERT_SYSTEM_STORE_LOCATION_SHIFT;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE;
    internal static UInt32 CERT_INFO_ISSUER_FLAG;
    internal static UInt32 CERT_INFO_SUBJECT_FLAG;
    internal static UInt32 CERT_COMPARE_SHIFT;
    internal static UInt32 CERT_COMPARE_ANY;
    internal static UInt32 CERT_COMPARE_SHA1_HASH;
    internal static UInt32 CERT_COMPARE_NAME_STR_A;
    internal static UInt32 CERT_COMPARE_NAME_STR_W;
    internal static UInt32 CERT_FIND_ANY;
    internal static UInt32 CERT_FIND_SHA1_HASH;
    internal static UInt32 CERT_FIND_HASH;
    internal static UInt32 CERT_FIND_SUBJECT_STR_A;
    internal static UInt32 CERT_FIND_SUBJECT_STR_W;
    internal static UInt32 CERT_FIND_SUBJECT_STR;
    internal static UInt32 CERT_FIND_ISSUER_STR_A;
    internal static UInt32 CERT_FIND_ISSUER_STR_W;
    internal static UInt32 CERT_FIND_ISSUER_STR;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    internal static UInt32 CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG;
    internal static UInt32 USAGE_MATCH_TYPE_AND;
    internal static UInt32 USAGE_MATCH_TYPE_OR;
    internal static UInt32 HCCE_CURRENT_USER;
    internal static UInt32 HCCE_LOCAL_MACHINE;
    internal static UInt32 CERT_TRUST_IS_PEER_TRUSTED;
    internal static SafeCertContextHandle CertCreateCertificateContext(UInt32 dwCertEncodingType, IntPtr pbCertEncoded, UInt32 cbCertEncoded);
    internal static SafeCertStoreHandle CertOpenStore(IntPtr lpszStoreProvider, UInt32 dwMsgAndCertEncodingType, IntPtr hCryptProv, UInt32 dwFlags, string pvPara);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CertCloseStore(IntPtr hCertStore, UInt32 dwFlags);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [ReliabilityContractAttribute("3", "2")]
internal static SafeCertContextHandle CertFindCertificateInStore(SafeCertStoreHandle hCertStore, UInt32 dwCertEncodingType, UInt32 dwFindFlags, UInt32 dwFindType, SafeHGlobalHandle pvFindPara, SafeCertContextHandle pPrevCertContext);
    internal static bool CertAddCertificateLinkToStore(SafeCertStoreHandle hCertStore, IntPtr pCertContext, UInt32 dwAddDisposition, SafeCertContextHandle ppStoreContext);
    internal static bool CertGetCertificateChain(IntPtr hChainEngine, IntPtr pCertContext, FILETIME& pTime, SafeCertStoreHandle hAdditionalStore, CERT_CHAIN_PARA& pChainPara, UInt32 dwFlags, IntPtr pvReserved, SafeCertChainHandle& ppChainContext);
    internal static bool CertVerifyCertificateChainPolicy(IntPtr pszPolicyOID, SafeCertChainHandle pChainContext, CERT_CHAIN_POLICY_PARA& pPolicyPara, CERT_CHAIN_POLICY_STATUS& pPolicyStatus);
    [ReliabilityContractAttribute("3", "2")]
internal static void CertFreeCertificateChain(IntPtr handle);
    internal static int BCryptGetFipsAlgorithmMode(Boolean& pfEnabled);
}
internal enum System.IdentityModel.CertificateEncoding : Enum {
    public int value__;
    public static CertificateEncoding Zero;
    public static CertificateEncoding X509AsnEncoding;
    public static CertificateEncoding X509NdrEncoding;
    public static CertificateEncoding Pkcs7AsnEncoding;
    public static CertificateEncoding Pkcs7NdrEncoding;
    public static CertificateEncoding AnyAsnEncoding;
}
internal class System.IdentityModel.CipherDataElement : object {
    public Byte[] CipherValue { get; public set; }
    public Byte[] get_CipherValue();
    public void set_CipherValue(Byte[] value);
    public void ReadXml(XmlDictionaryReader reader);
    public void SetCipherValueFragments(Byte[] iv, Byte[] cipherText);
    public void WriteXml(XmlWriter writer);
}
[DataContractAttribute]
public class System.IdentityModel.Claims.Claim : object {
    public static IEqualityComparer`1<Claim> DefaultComparer { get; }
    public static Claim System { get; }
    public object Resource { get; }
    public string ClaimType { get; }
    public string Right { get; }
    public Claim(string claimType, object resource, string right);
    public static IEqualityComparer`1<Claim> get_DefaultComparer();
    public static Claim get_System();
    public object get_Resource();
    public string get_ClaimType();
    public string get_Right();
    public static Claim CreateDnsClaim(string dns);
    public static Claim CreateDenyOnlyWindowsSidClaim(SecurityIdentifier sid);
    public static Claim CreateHashClaim(Byte[] hash);
    public static Claim CreateMailAddressClaim(MailAddress mailAddress);
    public static Claim CreateNameClaim(string name);
    public static Claim CreateRsaClaim(RSA rsa);
    public static Claim CreateSpnClaim(string spn);
    public static Claim CreateThumbprintClaim(Byte[] thumbprint);
    public static Claim CreateUpnClaim(string upn);
    public static Claim CreateUriClaim(Uri uri);
    public static Claim CreateWindowsSidClaim(SecurityIdentifier sid);
    public static Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.IdentityModel.Claims.ClaimComparer : object {
    public static IEqualityComparer`1<Claim> Default { get; }
    public static IEqualityComparer`1<Claim> Dns { get; }
    public static IEqualityComparer`1<Claim> Hash { get; }
    public static IEqualityComparer`1<Claim> Rsa { get; }
    public static IEqualityComparer`1<Claim> Thumbprint { get; }
    public static IEqualityComparer`1<Claim> Upn { get; }
    public static IEqualityComparer`1<Claim> X500DistinguishedName { get; }
    public static IEqualityComparer`1<Claim> GetComparer(string claimType);
    public static IEqualityComparer`1<Claim> get_Default();
    public static IEqualityComparer`1<Claim> get_Dns();
    public static IEqualityComparer`1<Claim> get_Hash();
    public static IEqualityComparer`1<Claim> get_Rsa();
    public static IEqualityComparer`1<Claim> get_Thumbprint();
    public static IEqualityComparer`1<Claim> get_Upn();
    public static IEqualityComparer`1<Claim> get_X500DistinguishedName();
    public sealed virtual bool Equals(Claim claim1, Claim claim2);
    public sealed virtual int GetHashCode(Claim claim);
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public abstract class System.IdentityModel.Claims.ClaimSet : object {
    public static ClaimSet System { get; }
    public static ClaimSet Windows { get; }
    internal static ClaimSet Anonymous { get; }
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public static ClaimSet get_System();
    public static ClaimSet get_Windows();
    internal static ClaimSet get_Anonymous();
    internal static bool SupportedRight(string right);
    public virtual bool ContainsClaim(Claim claim, IEqualityComparer`1<Claim> comparer);
    public virtual bool ContainsClaim(Claim claim);
    public abstract virtual Claim get_Item(int index);
    public abstract virtual int get_Count();
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public abstract virtual IEnumerator`1<Claim> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.IdentityModel.Claims.ClaimTypes : object {
    public static string Anonymous { get; }
    public static string DenyOnlySid { get; }
    public static string Dns { get; }
    public static string Email { get; }
    public static string Hash { get; }
    public static string Name { get; }
    public static string Rsa { get; }
    public static string Sid { get; }
    public static string Spn { get; }
    public static string System { get; }
    public static string Thumbprint { get; }
    public static string Upn { get; }
    public static string Uri { get; }
    public static string X500DistinguishedName { get; }
    public static string NameIdentifier { get; }
    public static string Authentication { get; }
    public static string AuthorizationDecision { get; }
    public static string GivenName { get; }
    public static string Surname { get; }
    public static string StreetAddress { get; }
    public static string Locality { get; }
    public static string StateOrProvince { get; }
    public static string PostalCode { get; }
    public static string Country { get; }
    public static string HomePhone { get; }
    public static string OtherPhone { get; }
    public static string MobilePhone { get; }
    public static string DateOfBirth { get; }
    public static string Gender { get; }
    public static string PPID { get; }
    public static string Webpage { get; }
    public static string get_Anonymous();
    public static string get_DenyOnlySid();
    public static string get_Dns();
    public static string get_Email();
    public static string get_Hash();
    public static string get_Name();
    public static string get_Rsa();
    public static string get_Sid();
    public static string get_Spn();
    public static string get_System();
    public static string get_Thumbprint();
    public static string get_Upn();
    public static string get_Uri();
    public static string get_X500DistinguishedName();
    public static string get_NameIdentifier();
    public static string get_Authentication();
    public static string get_AuthorizationDecision();
    public static string get_GivenName();
    public static string get_Surname();
    public static string get_StreetAddress();
    public static string get_Locality();
    public static string get_StateOrProvince();
    public static string get_PostalCode();
    public static string get_Country();
    public static string get_HomePhone();
    public static string get_OtherPhone();
    public static string get_MobilePhone();
    public static string get_DateOfBirth();
    public static string get_Gender();
    public static string get_PPID();
    public static string get_Webpage();
}
[DefaultMemberAttribute("Item")]
[DataContractAttribute]
public class System.IdentityModel.Claims.DefaultClaimSet : ClaimSet {
    public Claim Item { get; }
    public int Count { get; }
    public ClaimSet Issuer { get; }
    public DefaultClaimSet(Claim[] claims);
    public DefaultClaimSet(IList`1<Claim> claims);
    public DefaultClaimSet(ClaimSet issuer, Claim[] claims);
    public DefaultClaimSet(ClaimSet issuer, IList`1<Claim> claims);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    public virtual ClaimSet get_Issuer();
    public virtual bool ContainsClaim(Claim claim);
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.DefaultClaimSet/<FindClaims>d__13")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    protected void Initialize(ClaimSet issuer, IList`1<Claim> claims);
    public virtual string ToString();
}
public static class System.IdentityModel.Claims.Rights : object {
    public static string Identity { get; }
    public static string PossessProperty { get; }
    public static string get_Identity();
    public static string get_PossessProperty();
}
internal class System.IdentityModel.Claims.SessionDictionary : XmlDictionary {
    public static SessionDictionary Instance { get; }
    public XmlDictionaryString PersistentTrue { get; }
    public XmlDictionaryString WindowsLogonName { get; }
    public XmlDictionaryString ClaimsPrincipal { get; }
    public XmlDictionaryString WindowsPrincipal { get; }
    public XmlDictionaryString WindowsIdentity { get; }
    public XmlDictionaryString Identity { get; }
    public XmlDictionaryString Identities { get; }
    public XmlDictionaryString SessionId { get; }
    public XmlDictionaryString ReferenceModeTrue { get; }
    public XmlDictionaryString ValidFrom { get; }
    public XmlDictionaryString ValidTo { get; }
    public XmlDictionaryString EffectiveTime { get; }
    public XmlDictionaryString ExpiryTime { get; }
    public XmlDictionaryString KeyEffectiveTime { get; }
    public XmlDictionaryString KeyExpiryTime { get; }
    public XmlDictionaryString Claim { get; }
    public XmlDictionaryString Issuer { get; }
    public XmlDictionaryString OriginalIssuer { get; }
    public XmlDictionaryString IssuerRef { get; }
    public XmlDictionaryString ClaimCollection { get; }
    public XmlDictionaryString Actor { get; }
    public XmlDictionaryString ClaimProperties { get; }
    public XmlDictionaryString ClaimProperty { get; }
    public XmlDictionaryString Value { get; }
    public XmlDictionaryString ValueType { get; }
    public XmlDictionaryString Label { get; }
    public XmlDictionaryString Type { get; }
    public XmlDictionaryString SubjectId { get; }
    public XmlDictionaryString ClaimPropertyName { get; }
    public XmlDictionaryString ClaimPropertyValue { get; }
    public XmlDictionaryString AuthenticationType { get; }
    public XmlDictionaryString NameClaimType { get; }
    public XmlDictionaryString RoleClaimType { get; }
    public XmlDictionaryString NullValue { get; }
    public XmlDictionaryString SecurityContextToken { get; }
    public XmlDictionaryString Version { get; }
    public XmlDictionaryString SecureConversationVersion { get; }
    public XmlDictionaryString EmptyString { get; }
    public XmlDictionaryString Key { get; }
    public XmlDictionaryString KeyGeneration { get; }
    public XmlDictionaryString Id { get; }
    public XmlDictionaryString ContextId { get; }
    public XmlDictionaryString SessionToken { get; }
    public XmlDictionaryString SessionTokenCookie { get; }
    public XmlDictionaryString BootstrapToken { get; }
    public XmlDictionaryString Context { get; }
    public XmlDictionaryString SctAuthorizationPolicy { get; }
    public XmlDictionaryString Right { get; }
    public XmlDictionaryString EndpointId { get; }
    public XmlDictionaryString WindowsSidClaim { get; }
    public XmlDictionaryString DenyOnlySidClaim { get; }
    public XmlDictionaryString X500DistinguishedNameClaim { get; }
    public XmlDictionaryString X509ThumbprintClaim { get; }
    public XmlDictionaryString NameClaim { get; }
    public XmlDictionaryString DnsClaim { get; }
    public XmlDictionaryString RsaClaim { get; }
    public XmlDictionaryString MailAddressClaim { get; }
    public XmlDictionaryString SystemClaim { get; }
    public XmlDictionaryString HashClaim { get; }
    public XmlDictionaryString SpnClaim { get; }
    public XmlDictionaryString UpnClaim { get; }
    public XmlDictionaryString UrlClaim { get; }
    public XmlDictionaryString Sid { get; }
    private static SessionDictionary();
    public static SessionDictionary get_Instance();
    public XmlDictionaryString get_PersistentTrue();
    public XmlDictionaryString get_WindowsLogonName();
    public XmlDictionaryString get_ClaimsPrincipal();
    public XmlDictionaryString get_WindowsPrincipal();
    public XmlDictionaryString get_WindowsIdentity();
    public XmlDictionaryString get_Identity();
    public XmlDictionaryString get_Identities();
    public XmlDictionaryString get_SessionId();
    public XmlDictionaryString get_ReferenceModeTrue();
    public XmlDictionaryString get_ValidFrom();
    public XmlDictionaryString get_ValidTo();
    public XmlDictionaryString get_EffectiveTime();
    public XmlDictionaryString get_ExpiryTime();
    public XmlDictionaryString get_KeyEffectiveTime();
    public XmlDictionaryString get_KeyExpiryTime();
    public XmlDictionaryString get_Claim();
    public XmlDictionaryString get_Issuer();
    public XmlDictionaryString get_OriginalIssuer();
    public XmlDictionaryString get_IssuerRef();
    public XmlDictionaryString get_ClaimCollection();
    public XmlDictionaryString get_Actor();
    public XmlDictionaryString get_ClaimProperties();
    public XmlDictionaryString get_ClaimProperty();
    public XmlDictionaryString get_Value();
    public XmlDictionaryString get_ValueType();
    public XmlDictionaryString get_Label();
    public XmlDictionaryString get_Type();
    public XmlDictionaryString get_SubjectId();
    public XmlDictionaryString get_ClaimPropertyName();
    public XmlDictionaryString get_ClaimPropertyValue();
    public XmlDictionaryString get_AuthenticationType();
    public XmlDictionaryString get_NameClaimType();
    public XmlDictionaryString get_RoleClaimType();
    public XmlDictionaryString get_NullValue();
    public XmlDictionaryString get_SecurityContextToken();
    public XmlDictionaryString get_Version();
    public XmlDictionaryString get_SecureConversationVersion();
    public XmlDictionaryString get_EmptyString();
    public XmlDictionaryString get_Key();
    public XmlDictionaryString get_KeyGeneration();
    public XmlDictionaryString get_Id();
    public XmlDictionaryString get_ContextId();
    public XmlDictionaryString get_SessionToken();
    public XmlDictionaryString get_SessionTokenCookie();
    public XmlDictionaryString get_BootstrapToken();
    public XmlDictionaryString get_Context();
    public XmlDictionaryString get_SctAuthorizationPolicy();
    public XmlDictionaryString get_Right();
    public XmlDictionaryString get_EndpointId();
    public XmlDictionaryString get_WindowsSidClaim();
    public XmlDictionaryString get_DenyOnlySidClaim();
    public XmlDictionaryString get_X500DistinguishedNameClaim();
    public XmlDictionaryString get_X509ThumbprintClaim();
    public XmlDictionaryString get_NameClaim();
    public XmlDictionaryString get_DnsClaim();
    public XmlDictionaryString get_RsaClaim();
    public XmlDictionaryString get_MailAddressClaim();
    public XmlDictionaryString get_SystemClaim();
    public XmlDictionaryString get_HashClaim();
    public XmlDictionaryString get_SpnClaim();
    public XmlDictionaryString get_UpnClaim();
    public XmlDictionaryString get_UrlClaim();
    public XmlDictionaryString get_Sid();
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Claims.WindowsClaimSet : ClaimSet {
    internal static bool DefaultIncludeWindowsGroups;
    public Claim Item { get; }
    public int Count { get; }
    private IIdentity System.IdentityModel.Policy.IIdentityInfo.Identity { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public ClaimSet Issuer { get; }
    public DateTime ExpirationTime { get; }
    public WindowsClaimSet(WindowsIdentity windowsIdentity);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, DateTime expirationTime);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups, DateTime expirationTime);
    public WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime);
    internal WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, bool clone);
    internal WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime, bool clone);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    private sealed virtual override IIdentity System.IdentityModel.Policy.IIdentityInfo.get_Identity();
    public WindowsIdentity get_WindowsIdentity();
    public virtual ClaimSet get_Issuer();
    public DateTime get_ExpirationTime();
    internal WindowsClaimSet Clone();
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.WindowsClaimSet/<FindClaims>d__36")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Claims.X509CertificateClaimSet : ClaimSet {
    public Claim Item { get; }
    public int Count { get; }
    private IIdentity System.IdentityModel.Policy.IIdentityInfo.Identity { get; }
    public DateTime ExpirationTime { get; }
    public ClaimSet Issuer { get; }
    public X509Certificate2 X509Certificate { get; }
    public X509CertificateClaimSet(X509Certificate2 certificate);
    internal X509CertificateClaimSet(X509Certificate2 certificate, bool clone);
    public virtual Claim get_Item(int index);
    public virtual int get_Count();
    private sealed virtual override IIdentity System.IdentityModel.Policy.IIdentityInfo.get_Identity();
    public DateTime get_ExpirationTime();
    public virtual ClaimSet get_Issuer();
    public X509Certificate2 get_X509Certificate();
    internal X509CertificateClaimSet Clone();
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("System.IdentityModel.Claims.X509CertificateClaimSet/<FindClaims>d__29")]
public virtual IEnumerable`1<Claim> FindClaims(string claimType, string right);
    public virtual IEnumerator`1<Claim> GetEnumerator();
    public virtual string ToString();
}
internal class System.IdentityModel.Claims.X509Identity : GenericIdentity {
    public string Name { get; }
    public X509Identity(X509Certificate2 certificate);
    public X509Identity(X500DistinguishedName x500DistinguishedName);
    internal X509Identity(X509Certificate2 certificate, bool clone, bool disposable);
    public virtual string get_Name();
    public virtual ClaimsIdentity Clone();
    public sealed virtual void Dispose();
}
internal static class System.IdentityModel.Claims.XsiConstants : object {
    public static string Namespace;
    public static string System;
}
internal class System.IdentityModel.Configuration.ApplicationServiceConfigurationElement : ConfigurationElementInterceptor {
}
public class System.IdentityModel.Configuration.AudienceUriElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("value")]
[StringValidatorAttribute]
public string Value { get; public set; }
    internal bool IsConfigured { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public string get_Value();
    public void set_Value(string value);
    internal bool get_IsConfigured();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[ConfigurationCollectionAttribute("System.IdentityModel.Configuration.AudienceUriElement")]
public class System.IdentityModel.Configuration.AudienceUriElementCollection : ConfigurationElementCollection {
    [ConfigurationPropertyAttribute("mode")]
[StandardRuntimeEnumValidatorAttribute("System.IdentityModel.Selectors.AudienceUriMode")]
public AudienceUriMode Mode { get; public set; }
    internal bool IsConfigured { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual void Init();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public AudienceUriMode get_Mode();
    public void set_Mode(AudienceUriMode value);
    internal bool get_IsConfigured();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.IdentityModel.Configuration.ConfigurationElementInterceptor : ConfigurationElement {
    public XmlElement ElementAsXml { get; }
    public XmlNodeList ChildNodes { get; }
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
    protected virtual void Reset(ConfigurationElement parentElement);
    public XmlElement get_ElementAsXml();
    public XmlNodeList get_ChildNodes();
}
internal static class System.IdentityModel.Configuration.ConfigurationStrings : object {
    public static string Add;
    public static string ApplicationService;
    public static string AudienceUris;
    public static string AudienceUriMode;
    public static string Caches;
    public static string Capacity;
    public static string CertificateReference;
    public static string ClaimsAuthenticationManager;
    public static string ClaimsAuthorizationManager;
    public static string Clear;
    public static string Compression;
    public static string CookieTransforms;
    public static string DefaultCollectionName;
    public static string DefaultConfigurationElementName;
    public static string DefaultServiceName;
    public static string DetectReplayedTokens;
    public static string Enabled;
    public static string ExpirationPeriod;
    public static string FederatedAuthentication;
    public static string FindValue;
    public static string IsChainIncluded;
    public static string IssuerNameRegistry;
    public static string IssuerTokenResolver;
    public static string IssuerCertificateRevocationMode;
    public static string IssuerCertificateTrustedStoreLocation;
    public static string IssuerCertificateValidationMode;
    public static string IssuerCertificateValidator;
    public static string KerberosTokenHandlerRequirement;
    public static string Lifetime;
    public static string MapToWindows;
    public static string MaximumClockSkew;
    public static string MembershipProviderName;
    public static string Mode;
    public static string IdentityConfiguration;
    public static string SystemIdentityModel;
    public static string Name;
    public static string NameClaimType;
    public static string PersistentSessionLifetime;
    public static string Protection;
    public static string PurgeInterval;
    public static string Remove;
    public static string RoleClaimType;
    public static string ServiceCertificate;
    public static string SamlSecurityTokenRequirement;
    public static string SaveBootstrapContext;
    public static string ServiceTokenResolver;
    public static string SecurityTokenHandlerConfiguration;
    public static string SecurityTokenHandlers;
    public static string SessionSecurityTokenCache;
    public static string SessionTokenRequirement;
    public static string SecurityTokenCacheType;
    public static string SecurityTokenCacheSize;
    public static string StoreLocation;
    public static string StoreName;
    public static string Thumbprint;
    public static string TimeSpanZero;
    public static string TimeSpanMaxValue;
    public static string TokenReplayCache;
    public static string TokenReplayDetection;
    public static string TransientSessionLifetime;
    public static string TrustedIssuers;
    public static string Type;
    public static string UserNameSecurityTokenHandlerRequirement;
    public static string UseWindowsTokenService;
    public static string Value;
    public static string WindowsClaimsIdentity;
    public static string X509CertificateRevocationMode;
    public static string X509CertificateValidation;
    public static string X509CertificateValidationMode;
    public static string X509CertificateValidationModeChainTrust;
    public static string X509CertificateValidationModeCustom;
    public static string X509CertificateValidationModeNone;
    public static string X509CertificateValidationModePeerTrust;
    public static string X509CertificateValidationModePeerOrChainTrust;
    public static string X509CertificateValidator;
    public static string X509FindType;
    public static string X509RevocationModeNoCheck;
    public static string X509RevocationModeOnline;
    public static string X509RevocationModeOffline;
    public static string X509SecurityTokenHandlerRequirement;
    public static string X509TrustedStoreLocation;
    public static string X509TrustedStoreLocationCurrentUser;
    public static string X509TrustedStoreLocationLocalMachine;
}
public class System.IdentityModel.Configuration.CustomTypeElement : ConfigurationElementInterceptor {
    public bool IsConfigured { get; }
    [ConfigurationPropertyAttribute("type")]
[TypeConverterAttribute("System.Configuration.TypeNameConverter")]
public Type Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal CustomTypeElement(Type typeName);
    public static T Resolve(CustomTypeElement customTypeElement);
    public bool get_IsConfigured();
    public Type get_Type();
    public void set_Type(Type value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public interface System.IdentityModel.Configuration.ICustomIdentityConfiguration {
    public abstract virtual void LoadCustomConfiguration(XmlNodeList nodeList);
}
public class System.IdentityModel.Configuration.IdentityConfiguration : object {
    public static string DefaultServiceName;
    public static TimeSpan DefaultMaxClockSkew;
    internal static string DefaultMaxClockSkewString;
    public static X509CertificateValidationMode DefaultCertificateValidationMode;
    public static Type DefaultIssuerNameRegistryType;
    public static X509RevocationMode DefaultRevocationMode;
    public static StoreLocation DefaultTrustedStoreLocation;
    public AudienceRestriction AudienceRestriction { get; public set; }
    public IdentityModelCaches Caches { get; public set; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public ClaimsAuthenticationManager ClaimsAuthenticationManager { get; public set; }
    public ClaimsAuthorizationManager ClaimsAuthorizationManager { get; public set; }
    public bool DetectReplayedTokens { get; public set; }
    public bool IsInitialized { get; protected set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public string Name { get; }
    public IssuerNameRegistry IssuerNameRegistry { get; public set; }
    public X509Certificate2 ServiceCertificate { get; public set; }
    internal List`1<X509Certificate2> KnownIssuerCertificates { get; internal set; }
    public SecurityTokenResolver IssuerTokenResolver { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public SecurityTokenResolver ServiceTokenResolver { get; public set; }
    public bool SaveBootstrapContext { get; public set; }
    public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager { get; }
    public SecurityTokenHandlerCollection SecurityTokenHandlers { get; }
    public TimeSpan TokenReplayCacheExpirationPeriod { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public IdentityConfiguration(X509Certificate2 serviceCertificate);
    public IdentityConfiguration(bool loadConfig);
    public IdentityConfiguration(bool loadConfig, X509Certificate2 serviceCertificate);
    public IdentityConfiguration(string identityConfigurationName);
    public IdentityConfiguration(string identityConfigurationName, X509Certificate2 serviceCertificate);
    private static IdentityConfiguration();
    public AudienceRestriction get_AudienceRestriction();
    public void set_AudienceRestriction(AudienceRestriction value);
    public IdentityModelCaches get_Caches();
    public void set_Caches(IdentityModelCaches value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    public ClaimsAuthenticationManager get_ClaimsAuthenticationManager();
    public void set_ClaimsAuthenticationManager(ClaimsAuthenticationManager value);
    public ClaimsAuthorizationManager get_ClaimsAuthorizationManager();
    public void set_ClaimsAuthorizationManager(ClaimsAuthorizationManager value);
    public bool get_DetectReplayedTokens();
    public void set_DetectReplayedTokens(bool value);
    public virtual bool get_IsInitialized();
    protected virtual void set_IsInitialized(bool value);
    public virtual void Initialize();
    protected void LoadConfiguration(IdentityConfigurationElement element);
    protected SecurityTokenHandlerCollectionManager LoadHandlers(IdentityConfigurationElement serviceElement);
    protected SecurityTokenHandlerConfiguration LoadHandlerConfiguration(IdentityConfigurationElement element);
    protected SecurityTokenHandlerConfiguration LoadHandlerConfiguration(SecurityTokenHandlerConfiguration baseConfiguration, SecurityTokenHandlerConfigurationElement element);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public string get_Name();
    public IssuerNameRegistry get_IssuerNameRegistry();
    public void set_IssuerNameRegistry(IssuerNameRegistry value);
    public X509Certificate2 get_ServiceCertificate();
    public void set_ServiceCertificate(X509Certificate2 value);
    internal List`1<X509Certificate2> get_KnownIssuerCertificates();
    internal void set_KnownIssuerCertificates(List`1<X509Certificate2> value);
    public SecurityTokenResolver get_IssuerTokenResolver();
    public void set_IssuerTokenResolver(SecurityTokenResolver value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public SecurityTokenResolver get_ServiceTokenResolver();
    public void set_ServiceTokenResolver(SecurityTokenResolver value);
    public bool get_SaveBootstrapContext();
    public void set_SaveBootstrapContext(bool value);
    public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager();
    public SecurityTokenHandlerCollection get_SecurityTokenHandlers();
    public TimeSpan get_TokenReplayCacheExpirationPeriod();
    public void set_TokenReplayCacheExpirationPeriod(TimeSpan value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
}
public class System.IdentityModel.Configuration.IdentityConfigurationElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("audienceUris")]
public AudienceUriElementCollection AudienceUris { get; }
    [ConfigurationPropertyAttribute("caches")]
public IdentityModelCachesElement Caches { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidation")]
public X509CertificateValidationElement CertificateValidation { get; public set; }
    [ConfigurationPropertyAttribute("claimsAuthenticationManager")]
public CustomTypeElement ClaimsAuthenticationManager { get; public set; }
    [ConfigurationPropertyAttribute("claimsAuthorizationManager")]
public CustomTypeElement ClaimsAuthorizationManager { get; public set; }
    [ConfigurationPropertyAttribute("issuerNameRegistry")]
public IssuerNameRegistryElement IssuerNameRegistry { get; public set; }
    [ConfigurationPropertyAttribute("issuerTokenResolver")]
public CustomTypeElement IssuerTokenResolver { get; public set; }
    [ConfigurationPropertyAttribute("maximumClockSkew")]
[TypeConverterAttribute("System.IdentityModel.Configuration.TimeSpanOrInfiniteConverter")]
[IdentityModelTimeSpanValidatorAttribute]
public TimeSpan MaximumClockSkew { get; public set; }
    [ConfigurationPropertyAttribute("saveBootstrapContext")]
public bool SaveBootstrapContext { get; public set; }
    [ConfigurationPropertyAttribute("serviceTokenResolver")]
public CustomTypeElement ServiceTokenResolver { get; public set; }
    [ConfigurationPropertyAttribute("tokenReplayDetection")]
public TokenReplayDetectionElement TokenReplayDetection { get; public set; }
    [ConfigurationPropertyAttribute("")]
public SecurityTokenHandlerSetElementCollection SecurityTokenHandlerSets { get; }
    [ConfigurationPropertyAttribute("applicationService")]
internal ApplicationServiceConfigurationElement ApplicationService { get; internal set; }
    internal bool IsConfigured { get; }
    public string get_Name();
    public void set_Name(string value);
    public AudienceUriElementCollection get_AudienceUris();
    public IdentityModelCachesElement get_Caches();
    public void set_Caches(IdentityModelCachesElement value);
    public X509CertificateValidationElement get_CertificateValidation();
    public void set_CertificateValidation(X509CertificateValidationElement value);
    public CustomTypeElement get_ClaimsAuthenticationManager();
    public void set_ClaimsAuthenticationManager(CustomTypeElement value);
    public CustomTypeElement get_ClaimsAuthorizationManager();
    public void set_ClaimsAuthorizationManager(CustomTypeElement value);
    public IssuerNameRegistryElement get_IssuerNameRegistry();
    public void set_IssuerNameRegistry(IssuerNameRegistryElement value);
    public CustomTypeElement get_IssuerTokenResolver();
    public void set_IssuerTokenResolver(CustomTypeElement value);
    public TimeSpan get_MaximumClockSkew();
    public void set_MaximumClockSkew(TimeSpan value);
    public bool get_SaveBootstrapContext();
    public void set_SaveBootstrapContext(bool value);
    public CustomTypeElement get_ServiceTokenResolver();
    public void set_ServiceTokenResolver(CustomTypeElement value);
    public TokenReplayDetectionElement get_TokenReplayDetection();
    public void set_TokenReplayDetection(TokenReplayDetectionElement value);
    public SecurityTokenHandlerSetElementCollection get_SecurityTokenHandlerSets();
    internal ApplicationServiceConfigurationElement get_ApplicationService();
    internal void set_ApplicationService(ApplicationServiceConfigurationElement value);
    internal bool get_IsConfigured();
}
[ConfigurationCollectionAttribute("System.IdentityModel.Configuration.IdentityConfigurationElement")]
public class System.IdentityModel.Configuration.IdentityConfigurationElementCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    internal bool IsConfigured { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public IdentityConfigurationElement GetElement(string name);
    protected virtual void BaseAdd(ConfigurationElement element);
    internal bool get_IsConfigured();
}
public class System.IdentityModel.Configuration.IdentityModelCaches : object {
    public TokenReplayCache TokenReplayCache { get; public set; }
    public SessionSecurityTokenCache SessionSecurityTokenCache { get; public set; }
    public TokenReplayCache get_TokenReplayCache();
    public void set_TokenReplayCache(TokenReplayCache value);
    public SessionSecurityTokenCache get_SessionSecurityTokenCache();
    public void set_SessionSecurityTokenCache(SessionSecurityTokenCache value);
}
public class System.IdentityModel.Configuration.IdentityModelCachesElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("tokenReplayCache")]
public CustomTypeElement TokenReplayCache { get; public set; }
    [ConfigurationPropertyAttribute("sessionSecurityTokenCache")]
public CustomTypeElement SessionSecurityTokenCache { get; public set; }
    public bool IsConfigured { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public CustomTypeElement get_TokenReplayCache();
    public void set_TokenReplayCache(CustomTypeElement value);
    public CustomTypeElement get_SessionSecurityTokenCache();
    public void set_SessionSecurityTokenCache(CustomTypeElement value);
    public bool get_IsConfigured();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[AttributeUsageAttribute("128")]
internal class System.IdentityModel.Configuration.IdentityModelTimeSpanValidatorAttribute : ConfigurationValidatorAttribute {
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public TimeSpan MinValue { get; }
    public string MinValueString { get; public set; }
    public TimeSpan MaxValue { get; }
    public string MaxValueString { get; public set; }
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
    public TimeSpan get_MinValue();
    public string get_MinValueString();
    public void set_MinValueString(string value);
    public TimeSpan get_MaxValue();
    public string get_MaxValueString();
    public void set_MaxValueString(string value);
}
public class System.IdentityModel.Configuration.IssuerNameRegistryElement : ConfigurationElementInterceptor {
    internal bool IsConfigured { get; }
    [ConfigurationPropertyAttribute("type")]
[StringValidatorAttribute]
public string Type { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal IssuerNameRegistryElement(string type);
    internal bool get_IsConfigured();
    public string get_Type();
    public void set_Type(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.IdentityModel.Configuration.SecurityTokenHandlerConfigurationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("audienceUris")]
public AudienceUriElementCollection AudienceUris { get; }
    [ConfigurationPropertyAttribute("caches")]
public IdentityModelCachesElement Caches { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidation")]
public X509CertificateValidationElement CertificateValidation { get; public set; }
    [ConfigurationPropertyAttribute("issuerNameRegistry")]
public IssuerNameRegistryElement IssuerNameRegistry { get; public set; }
    [ConfigurationPropertyAttribute("issuerTokenResolver")]
public CustomTypeElement IssuerTokenResolver { get; public set; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("saveBootstrapContext")]
public bool SaveBootstrapContext { get; public set; }
    [ConfigurationPropertyAttribute("maximumClockSkew")]
[TypeConverterAttribute("System.IdentityModel.Configuration.TimeSpanOrInfiniteConverter")]
[IdentityModelTimeSpanValidatorAttribute]
public TimeSpan MaximumClockSkew { get; public set; }
    [ConfigurationPropertyAttribute("serviceTokenResolver")]
public CustomTypeElement ServiceTokenResolver { get; public set; }
    [ConfigurationPropertyAttribute("tokenReplayDetection")]
public TokenReplayDetectionElement TokenReplayDetection { get; public set; }
    internal bool IsConfigured { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual void Init();
    public AudienceUriElementCollection get_AudienceUris();
    public IdentityModelCachesElement get_Caches();
    public void set_Caches(IdentityModelCachesElement value);
    public X509CertificateValidationElement get_CertificateValidation();
    public void set_CertificateValidation(X509CertificateValidationElement value);
    public IssuerNameRegistryElement get_IssuerNameRegistry();
    public void set_IssuerNameRegistry(IssuerNameRegistryElement value);
    public CustomTypeElement get_IssuerTokenResolver();
    public void set_IssuerTokenResolver(CustomTypeElement value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_SaveBootstrapContext();
    public void set_SaveBootstrapContext(bool value);
    public TimeSpan get_MaximumClockSkew();
    public void set_MaximumClockSkew(TimeSpan value);
    public CustomTypeElement get_ServiceTokenResolver();
    public void set_ServiceTokenResolver(CustomTypeElement value);
    public TokenReplayDetectionElement get_TokenReplayDetection();
    public void set_TokenReplayDetection(TokenReplayDetectionElement value);
    internal bool get_IsConfigured();
}
[ConfigurationCollectionAttribute("System.IdentityModel.Configuration.CustomTypeElement")]
public class System.IdentityModel.Configuration.SecurityTokenHandlerElementCollection : ConfigurationElementCollection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
[StringValidatorAttribute]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("securityTokenHandlerConfiguration")]
public SecurityTokenHandlerConfigurationElement SecurityTokenHandlerConfiguration { get; public set; }
    internal bool IsConfigured { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void Init();
    public string get_Name();
    public void set_Name(string value);
    public SecurityTokenHandlerConfigurationElement get_SecurityTokenHandlerConfiguration();
    public void set_SecurityTokenHandlerConfiguration(SecurityTokenHandlerConfigurationElement value);
    internal bool get_IsConfigured();
}
[ConfigurationCollectionAttribute("System.IdentityModel.Configuration.SecurityTokenHandlerElementCollection")]
public class System.IdentityModel.Configuration.SecurityTokenHandlerSetElementCollection : ConfigurationElementCollection {
    protected bool ThrowOnDuplicate { get; }
    public bool IsConfigured { get; }
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
    public bool get_IsConfigured();
}
public class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration : IdentityConfiguration {
    internal static int DefaultKeySizeInBitsConstant;
    public Type SecurityTokenService { get; public set; }
    public int DefaultSymmetricKeySizeInBits { get; public set; }
    public int DefaultMaxSymmetricKeySizeInBits { get; public set; }
    public TimeSpan DefaultTokenLifetime { get; public set; }
    public string DefaultTokenType { get; public set; }
    public bool DisableWsdl { get; public set; }
    public TimeSpan MaximumTokenLifetime { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public string TokenIssuerName { get; public set; }
    public WSTrust13RequestSerializer WSTrust13RequestSerializer { get; public set; }
    public WSTrust13ResponseSerializer WSTrust13ResponseSerializer { get; public set; }
    public WSTrustFeb2005RequestSerializer WSTrustFeb2005RequestSerializer { get; public set; }
    public WSTrustFeb2005ResponseSerializer WSTrustFeb2005ResponseSerializer { get; public set; }
    public SecurityTokenServiceConfiguration(bool loadConfig);
    public SecurityTokenServiceConfiguration(string issuerName);
    public SecurityTokenServiceConfiguration(string issuerName, bool loadConfig);
    public SecurityTokenServiceConfiguration(string issuerName, SigningCredentials signingCredentials);
    public SecurityTokenServiceConfiguration(string issuerName, SigningCredentials signingCredentials, bool loadConfig);
    public SecurityTokenServiceConfiguration(string issuerName, SigningCredentials signingCredentials, string serviceName);
    public Type get_SecurityTokenService();
    public void set_SecurityTokenService(Type value);
    public virtual SecurityTokenService CreateSecurityTokenService();
    public int get_DefaultSymmetricKeySizeInBits();
    public void set_DefaultSymmetricKeySizeInBits(int value);
    public int get_DefaultMaxSymmetricKeySizeInBits();
    public void set_DefaultMaxSymmetricKeySizeInBits(int value);
    public TimeSpan get_DefaultTokenLifetime();
    public void set_DefaultTokenLifetime(TimeSpan value);
    public string get_DefaultTokenType();
    public void set_DefaultTokenType(string value);
    public bool get_DisableWsdl();
    public void set_DisableWsdl(bool value);
    public TimeSpan get_MaximumTokenLifetime();
    public void set_MaximumTokenLifetime(TimeSpan value);
    public SigningCredentials get_SigningCredentials();
    public void set_SigningCredentials(SigningCredentials value);
    public string get_TokenIssuerName();
    public void set_TokenIssuerName(string value);
    public WSTrust13RequestSerializer get_WSTrust13RequestSerializer();
    public void set_WSTrust13RequestSerializer(WSTrust13RequestSerializer value);
    public WSTrust13ResponseSerializer get_WSTrust13ResponseSerializer();
    public void set_WSTrust13ResponseSerializer(WSTrust13ResponseSerializer value);
    public WSTrustFeb2005RequestSerializer get_WSTrustFeb2005RequestSerializer();
    public void set_WSTrustFeb2005RequestSerializer(WSTrustFeb2005RequestSerializer value);
    public WSTrustFeb2005ResponseSerializer get_WSTrustFeb2005ResponseSerializer();
    public void set_WSTrustFeb2005ResponseSerializer(WSTrustFeb2005ResponseSerializer value);
}
internal class System.IdentityModel.Configuration.StandardRuntimeEnumValidator : ConfigurationValidatorBase {
    public StandardRuntimeEnumValidator(Type enumType);
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
[AttributeUsageAttribute("128")]
internal class System.IdentityModel.Configuration.StandardRuntimeEnumValidatorAttribute : ConfigurationValidatorAttribute {
    public Type EnumType { get; public set; }
    public ConfigurationValidatorBase ValidatorInstance { get; }
    public StandardRuntimeEnumValidatorAttribute(Type enumType);
    public Type get_EnumType();
    public void set_EnumType(Type value);
    public virtual ConfigurationValidatorBase get_ValidatorInstance();
}
public class System.IdentityModel.Configuration.SystemIdentityModelSection : ConfigurationSection {
    public static string SectionName;
    public static SystemIdentityModelSection Current { get; }
    public static IdentityConfigurationElement DefaultIdentityConfigurationElement { get; }
    [ConfigurationPropertyAttribute("")]
public IdentityConfigurationElementCollection IdentityConfigurationElements { get; }
    internal bool IsConfigured { get; }
    public static SystemIdentityModelSection get_Current();
    public static IdentityConfigurationElement get_DefaultIdentityConfigurationElement();
    public IdentityConfigurationElementCollection get_IdentityConfigurationElements();
    internal bool get_IsConfigured();
}
internal class System.IdentityModel.Configuration.TimeSpanOrInfiniteConverter : TimeSpanConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object data);
}
internal class System.IdentityModel.Configuration.TimeSpanOrInfiniteValidator : TimeSpanValidator {
    public TimeSpanOrInfiniteValidator(TimeSpan minValue, TimeSpan maxValue);
    public virtual void Validate(object value);
}
public class System.IdentityModel.Configuration.TokenReplayDetectionElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [ConfigurationPropertyAttribute("expirationPeriod")]
[TypeConverterAttribute("System.IdentityModel.Configuration.TimeSpanOrInfiniteConverter")]
[IdentityModelTimeSpanValidatorAttribute]
public TimeSpan ExpirationPeriod { get; public set; }
    internal bool IsConfigured { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public TimeSpan get_ExpirationPeriod();
    public void set_ExpirationPeriod(TimeSpan value);
    internal bool get_IsConfigured();
}
internal class System.IdentityModel.Configuration.TypeResolveHelper : object {
    public static T Resolve(ConfigurationElementInterceptor customTypeElement, Type customType);
}
public class System.IdentityModel.Configuration.X509CertificateValidationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("certificateValidationMode")]
[StandardRuntimeEnumValidatorAttribute("System.ServiceModel.Security.X509CertificateValidationMode")]
public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    [ConfigurationPropertyAttribute("revocationMode")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.X509RevocationMode")]
public X509RevocationMode RevocationMode { get; public set; }
    [ConfigurationPropertyAttribute("trustedStoreLocation")]
[StandardRuntimeEnumValidatorAttribute("System.Security.Cryptography.X509Certificates.StoreLocation")]
public StoreLocation TrustedStoreLocation { get; public set; }
    [ConfigurationPropertyAttribute("certificateValidator")]
public CustomTypeElement CertificateValidator { get; public set; }
    internal bool IsConfigured { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public CustomTypeElement get_CertificateValidator();
    public void set_CertificateValidator(CustomTypeElement value);
    internal bool get_IsConfigured();
}
internal enum System.IdentityModel.ContextAttribute : Enum {
    public int value__;
    public static ContextAttribute Sizes;
    public static ContextAttribute Names;
    public static ContextAttribute Lifespan;
    public static ContextAttribute DceInfo;
    public static ContextAttribute StreamSizes;
    public static ContextAttribute Authority;
    public static ContextAttribute SessionKey;
    public static ContextAttribute PackageInfo;
    public static ContextAttribute NegotiationInfo;
    public static ContextAttribute Flags;
    public static ContextAttribute SpecifiedTarget;
    public static ContextAttribute RemoteCertificate;
    public static ContextAttribute LocalCertificate;
    public static ContextAttribute RootStore;
    public static ContextAttribute IssuerListInfoEx;
    public static ContextAttribute ConnectionInfo;
    public static ContextAttribute EapKey;
}
public abstract class System.IdentityModel.CookieTransform : object {
    public abstract virtual Byte[] Decode(Byte[] encoded);
    public abstract virtual Byte[] Encode(Byte[] value);
}
internal enum System.IdentityModel.CredentialStatus : Enum {
    public int value__;
    public static CredentialStatus InValidParameter;
    public static CredentialStatus NoSuchPackage;
    public static CredentialStatus NotSupported;
    public static CredentialStatus Cancelled;
    public static CredentialStatus Success;
}
internal enum System.IdentityModel.CredentialUse : Enum {
    public int value__;
    public static CredentialUse Inbound;
    public static CredentialUse Outbound;
    public static CredentialUse Both;
}
internal class System.IdentityModel.CREDUI_INFO : ValueType {
    public int cbSize;
    public IntPtr hwndParent;
    public string pszMessageText;
    public string pszCaptionText;
    public IntPtr hbmBanner;
}
internal static class System.IdentityModel.CryptoHelper : object {
    public static int WindowsVistaMajorNumber;
    internal static Byte[] EmptyBuffer { get; }
    internal static Rijndael Rijndael { get; }
    internal static TripleDES TripleDES { get; }
    internal static RandomNumberGenerator RandomNumberGenerator { get; }
    private static CryptoHelper();
    public static int CeilingDivide(int dividend, int divisor);
    internal static Byte[] get_EmptyBuffer();
    internal static Rijndael get_Rijndael();
    internal static TripleDES get_TripleDES();
    internal static RandomNumberGenerator get_RandomNumberGenerator();
    internal static SymmetricAlgorithm NewDefaultEncryption();
    internal static HashAlgorithm NewSha1HashAlgorithm();
    internal static HashAlgorithm NewSha256HashAlgorithm();
    internal static KeyedHashAlgorithm NewHmacSha1KeyedHashAlgorithm();
    internal static KeyedHashAlgorithm NewHmacSha1KeyedHashAlgorithm(Byte[] key);
    internal static KeyedHashAlgorithm NewHmacSha256KeyedHashAlgorithm(Byte[] key);
    internal static Rijndael NewRijndaelSymmetricAlgorithm();
    internal static ICryptoTransform CreateDecryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static ICryptoTransform CreateEncryptor(Byte[] key, Byte[] iv, string algorithm);
    internal static HashAlgorithm CreateHashAlgorithm(string algorithm);
    internal static KeyedHashAlgorithm CreateKeyedHashAlgorithm(Byte[] key, string algorithm);
    internal static Byte[] ComputeHash(Byte[] buffer);
    internal static Byte[] GenerateDerivedKey(Byte[] key, string algorithm, Byte[] label, Byte[] nonce, int derivedKeySize, int position);
    internal static int GetIVSize(string algorithm);
    internal static void FillRandomBytes(Byte[] buffer);
    public static void GenerateRandomBytes(Byte[] data);
    public static Byte[] GenerateRandomBytes(int sizeInBits);
    internal static SymmetricAlgorithm GetSymmetricAlgorithm(Byte[] key, string algorithm);
    internal static Byte[] CreateSignatureForSha256(AsymmetricSignatureFormatter formatter, HashAlgorithm hash);
    internal static bool VerifySignatureForSha256(AsymmetricSignatureDeformatter deformatter, HashAlgorithm hash, Byte[] signatureValue);
    internal static AsymmetricSignatureFormatter GetSignatureFormatterForSha256(AsymmetricSecurityKey key);
    internal static AsymmetricSignatureFormatter GetSignatureFormatterForSha256(RSACryptoServiceProvider rsaProvider);
    internal static AsymmetricSignatureDeformatter GetSignatureDeFormatterForSha256(AsymmetricSecurityKey key);
    internal static AsymmetricSignatureDeformatter GetSignatureDeFormatterForSha256(RSACryptoServiceProvider rsaProvider);
    internal static bool IsAsymmetricAlgorithm(string algorithm);
    internal static bool IsSymmetricAlgorithm(string algorithm);
    internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize);
    internal static Byte[] UnwrapKey(Byte[] wrappingKey, Byte[] wrappedKey, string algorithm);
    internal static Byte[] WrapKey(Byte[] wrappingKey, Byte[] keyToBeWrapped, string algorithm);
    internal static void ValidateBufferBounds(Array buffer, int offset, int count);
    internal static bool IsEqual(Byte[] a, Byte[] b);
    public static bool FixedTimeEquals(Byte[] a, Byte[] b);
    internal static object GetAlgorithmFromConfig(string algorithm);
    public static void ResetAllCertificates(X509Certificate2Collection certificates);
}
internal class System.IdentityModel.DateTimeFormats : object {
    internal static String[] Accepted;
    internal static string Generated;
    private static DateTimeFormats();
}
internal static class System.IdentityModel.DateTimeUtil : object {
    public static DateTime Add(DateTime time, TimeSpan timespan);
    public static DateTime AddNonNegative(DateTime time, TimeSpan timespan);
    public static DateTime GetMaxValue(DateTimeKind kind);
    public static DateTime GetMinValue(DateTimeKind kind);
    public static Nullable`1<DateTime> ToUniversalTime(Nullable`1<DateTime> value);
    public static DateTime ToUniversalTime(DateTime value);
}
public class System.IdentityModel.DeflateCookieTransform : CookieTransform {
    public int MaxDecompressedSize { get; public set; }
    public int get_MaxDecompressedSize();
    public void set_MaxDecompressedSize(int value);
    public virtual Byte[] Decode(Byte[] encoded);
    public virtual Byte[] Encode(Byte[] value);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.DelegatingXmlDictionaryReader : XmlDictionaryReader {
    protected XmlDictionaryReader InnerReader { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public Type ValueType { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    protected void InitializeInnerReader(XmlDictionaryReader innerReader);
    protected XmlDictionaryReader get_InnerReader();
    public virtual string get_Item(int i);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceURI);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual ReadState get_ReadState();
    public virtual string get_Value();
    public virtual Type get_ValueType();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual void Close();
    public virtual string GetAttribute(int i);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceURI);
    public virtual string LookupNamespace(string prefix);
    public virtual void MoveToAttribute(int i);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public virtual int ReadContentAsBase64(Byte[] buffer, int index, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int index, int count);
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual int ReadValueChunk(Char[] buffer, int index, int count);
    public virtual void ResolveEntity();
}
public class System.IdentityModel.DelegatingXmlDictionaryWriter : XmlDictionaryWriter {
    protected XmlDictionaryWriter InnerWriter { get; }
    public WriteState WriteState { get; }
    public bool CanCanonicalize { get; }
    protected void InitializeInnerWriter(XmlDictionaryWriter innerWriter);
    protected void InitializeTracingWriter(XmlWriter tracingWriter);
    protected XmlDictionaryWriter get_InnerWriter();
    public virtual void Close();
    public virtual void Flush();
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual string LookupPrefix(string ns);
    public virtual bool get_CanCanonicalize();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void EndCanonicalization();
}
internal static class System.IdentityModel.Diagnostics.Application.FxTrace : object {
    public static bool ShouldTraceCritical { get; }
    public static bool TracingEnabled { get; }
    public static bool ShouldTraceError { get; }
    public static bool ShouldTraceInformation { get; }
    public static bool ShouldTraceVerbose { get; }
    public static bool ShouldTraceWarning { get; }
    public static bool ShouldTraceCriticalToTraceSource { get; }
    public static bool ShouldTraceErrorToTraceSource { get; }
    public static bool ShouldTraceInformationToTraceSource { get; }
    public static bool ShouldTraceVerboseToTraceSource { get; }
    public static bool ShouldTraceWarningToTraceSource { get; }
    public static ExceptionTrace Exception { get; }
    public static EtwDiagnosticTrace Trace { get; }
    public static EventLogger EventLog { get; }
    private static FxTrace();
    [SecuritySafeCriticalAttribute]
public static void UpdateEventDefinitions(EventDescriptor[] eventDescriptors, UInt16[] end2EndEvents);
    public static bool IsEventEnabled(int index);
    public static bool get_ShouldTraceCritical();
    public static bool get_TracingEnabled();
    public static bool get_ShouldTraceError();
    public static bool get_ShouldTraceInformation();
    public static bool get_ShouldTraceVerbose();
    public static bool get_ShouldTraceWarning();
    public static bool get_ShouldTraceCriticalToTraceSource();
    public static bool get_ShouldTraceErrorToTraceSource();
    public static bool get_ShouldTraceInformationToTraceSource();
    public static bool get_ShouldTraceVerboseToTraceSource();
    public static bool get_ShouldTraceWarningToTraceSource();
    public static ExceptionTrace get_Exception();
    public static EtwDiagnosticTrace get_Trace();
    public static EventLogger get_EventLog();
}
internal class System.IdentityModel.Diagnostics.Application.TD : object {
    internal static CultureInfo Culture { get; internal set; }
    private static TD();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static bool GetIssuerNameFailureIsEnabled();
    internal static void GetIssuerNameFailure(EventTraceActivity eventTraceActivity, string tokenID);
    internal static bool GetIssuerNameSuccessIsEnabled();
    internal static void GetIssuerNameSuccess(EventTraceActivity eventTraceActivity, string issuerName, string tokenID);
    internal static bool TokenValidationFailureIsEnabled();
    internal static void TokenValidationFailure(EventTraceActivity eventTraceActivity, string tokenType, string tokenID, string errorMessage);
    internal static bool TokenValidationStartedIsEnabled();
    internal static void TokenValidationStarted(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
    internal static bool TokenValidationSuccessIsEnabled();
    internal static void TokenValidationSuccess(EventTraceActivity eventTraceActivity, string tokenType, string tokenID);
}
internal class System.IdentityModel.Diagnostics.AuthorizeTraceRecord : TraceRecord {
    internal string EventId { get; }
    public AuthorizeTraceRecord(ClaimsPrincipal claimsPrincipal, string url, string action);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.IdentityModel.Diagnostics.ClaimsPrincipalTraceRecord : TraceRecord {
    internal static string ElementName;
    internal static string _eventId;
    internal string EventId { get; }
    public ClaimsPrincipalTraceRecord(ClaimsPrincipal claimsPrincipal);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.IdentityModel.Diagnostics.DeflateCookieTraceRecord : TraceRecord {
    internal string EventId { get; }
    public DeflateCookieTraceRecord(int originalSize, int deflatedSize);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal class System.IdentityModel.Diagnostics.DigestTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal DigestTraceRecord(string traceName, MemoryStream logStream, HashAlgorithm hash);
    internal virtual string get_EventId();
    internal virtual void WriteTo(XmlWriter writer);
}
internal static class System.IdentityModel.Diagnostics.DigestTraceRecordHelper : object {
    internal static bool ShouldTraceDigest { get; }
    private static DigestTraceRecordHelper();
    internal static bool get_ShouldTraceDigest();
    internal static void TraceDigest(MemoryStream logStream, HashAlgorithm hash);
}
internal class System.IdentityModel.Diagnostics.SecurityTraceRecord : TraceRecord {
    internal string EventId { get; }
    internal SecurityTraceRecord(string traceName);
    internal virtual string get_EventId();
}
internal static class System.IdentityModel.Diagnostics.SecurityTraceRecordHelper : object {
    internal static void TraceServiceNameBindingOnServer(string serviceBindingNameSentByClient, string defaultServiceBindingNameOfServer, ServiceNameCollection serviceNameCollectionConfiguredOnServer);
    internal static void TraceChannelBindingInformation(ExtendedProtectionPolicyHelper policyHelper, bool isServer, ChannelBinding channelBinding);
}
internal static class System.IdentityModel.Diagnostics.TraceCode : object {
    public static int IdentityModel;
    public static int AuthorizationContextCreated;
    public static int AuthorizationPolicyEvaluated;
    public static int ServiceBindingCheck;
    public static int ChannelBindingCheck;
    public static int Diagnostics;
}
internal static class System.IdentityModel.Diagnostics.TraceUtility : object {
    private static TraceUtility();
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription);
    internal static void TraceEvent(TraceEventType severity, int traceCode, string traceDescription, TraceRecord extendedData, object source, Exception exception);
    internal static void TraceString(TraceEventType eventType, string formatString, Object[] args);
}
internal static class System.IdentityModel.DiagnosticUtility : object {
    internal static string EventSourceName;
    internal static string DefaultTraceListenerName;
    internal static LegacyDiagnosticTrace DiagnosticTrace { get; }
    internal static ExceptionUtility ExceptionUtility { get; }
    internal static Utility Utility { get; }
    internal static bool TracingEnabled { get; }
    internal static bool ShouldTraceCritical { get; }
    internal static bool ShouldUseActivity { get; }
    internal static bool ShouldTraceError { get; }
    internal static bool ShouldTraceWarning { get; }
    internal static bool ShouldTraceInformation { get; }
    internal static bool ShouldTraceVerbose { get; }
    private static DiagnosticUtility();
    internal static LegacyDiagnosticTrace get_DiagnosticTrace();
    internal static ExceptionUtility get_ExceptionUtility();
    internal static Utility get_Utility();
    [SecuritySafeCriticalAttribute]
internal static void InitDiagnosticTraceImpl(TraceSourceKind sourceType, string traceSourceName);
    internal static bool get_TracingEnabled();
    internal static bool ShouldTrace(TraceEventType type);
    internal static void TraceHandledException(Exception exception, TraceEventType traceEventType);
    internal static bool get_ShouldTraceCritical();
    internal static bool get_ShouldUseActivity();
    internal static bool get_ShouldTraceError();
    internal static bool get_ShouldTraceWarning();
    internal static bool get_ShouldTraceInformation();
    internal static bool get_ShouldTraceVerbose();
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
internal static void DebugAssert(string message);
    internal static Exception FailFast(string message);
    internal static Exception InvokeFinalHandler(Exception exception);
    public static Exception ThrowHelperArgumentNullOrEmptyString(string arg);
    public static Exception ThrowHelperArgumentOutOfRange(string arg);
    public static Exception ThrowHelperArgumentOutOfRange(string arg, string message);
    public static Exception ThrowHelperArgumentOutOfRange(string arg, object actualValue, string message);
    public static Exception ThrowHelperConfigurationError(ConfigurationElement configElement, string propertyName, Exception inner);
    public static Exception ThrowHelperConfigurationError(ConfigurationElement configElement, string propertyName, string message);
    public static Exception ThrowHelperXml(XmlReader reader, string message);
    public static Exception ThrowHelperXml(XmlReader reader, string message, Exception inner);
    public static Exception ThrowHelperInvalidOperation(string message);
}
internal class System.IdentityModel.DictionaryManager : object {
    public SamlDictionary SamlDictionary { get; public set; }
    public XmlSignatureDictionary XmlSignatureDictionary { get; public set; }
    public UtilityDictionary UtilityDictionary { get; public set; }
    public ExclusiveC14NDictionary ExclusiveC14NDictionary { get; public set; }
    public SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; public set; }
    public SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; public set; }
    public SecurityJan2004Dictionary SecurityJan2004Dictionary { get; public set; }
    public SecurityXXX2005Dictionary SecurityJanXXX2005Dictionary { get; public set; }
    public SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; public set; }
    public SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; public set; }
    public TrustDec2005Dictionary TrustDec2005Dictionary { get; public set; }
    public TrustFeb2005Dictionary TrustFeb2005Dictionary { get; public set; }
    public XmlEncryptionDictionary XmlEncryptionDictionary { get; public set; }
    public IXmlDictionary ParentDictionary { get; public set; }
    public DictionaryManager(IXmlDictionary parentDictionary);
    public SamlDictionary get_SamlDictionary();
    public void set_SamlDictionary(SamlDictionary value);
    public XmlSignatureDictionary get_XmlSignatureDictionary();
    public void set_XmlSignatureDictionary(XmlSignatureDictionary value);
    public UtilityDictionary get_UtilityDictionary();
    public void set_UtilityDictionary(UtilityDictionary value);
    public ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public void set_ExclusiveC14NDictionary(ExclusiveC14NDictionary value);
    public SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public void set_SecurityAlgorithmDec2005Dictionary(SecurityAlgorithmDec2005Dictionary value);
    public SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public void set_SecurityAlgorithmDictionary(SecurityAlgorithmDictionary value);
    public SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public void set_SecurityJan2004Dictionary(SecurityJan2004Dictionary value);
    public SecurityXXX2005Dictionary get_SecurityJanXXX2005Dictionary();
    public void set_SecurityJanXXX2005Dictionary(SecurityXXX2005Dictionary value);
    public SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public void set_SecureConversationDec2005Dictionary(SecureConversationDec2005Dictionary value);
    public SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public void set_SecureConversationFeb2005Dictionary(SecureConversationFeb2005Dictionary value);
    public TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public void set_TrustDec2005Dictionary(TrustDec2005Dictionary value);
    public TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public void set_TrustFeb2005Dictionary(TrustFeb2005Dictionary value);
    public XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public void set_XmlEncryptionDictionary(XmlEncryptionDictionary value);
    public IXmlDictionary get_ParentDictionary();
    public void set_ParentDictionary(IXmlDictionary value);
}
internal class System.IdentityModel.ElementWithAlgorithmAttribute : ValueType {
    private XmlDictionaryString elementName;
    private string algorithm;
    private XmlDictionaryString algorithmDictionaryString;
    private string prefix;
    public string Algorithm { get; public set; }
    public XmlDictionaryString AlgorithmDictionaryString { get; public set; }
    public ElementWithAlgorithmAttribute(XmlDictionaryString elementName);
    public string get_Algorithm();
    public void set_Algorithm(string value);
    public XmlDictionaryString get_AlgorithmDictionaryString();
    public void set_AlgorithmDictionaryString(XmlDictionaryString value);
    public void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager);
    public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal static class System.IdentityModel.EmptyReadOnlyCollection`1 : object {
    public static ReadOnlyCollection`1<T> Instance;
    private static EmptyReadOnlyCollection`1();
}
internal class System.IdentityModel.EncryptedDataElement : EncryptedTypeElement {
    public EncryptedDataElement(SecurityTokenSerializer tokenSerializer);
    public static bool CanReadFrom(XmlReader reader);
    public Byte[] Decrypt(SymmetricAlgorithm algorithm);
    public void Encrypt(SymmetricAlgorithm algorithm, Byte[] buffer, int offset, int length);
    public virtual void ReadExtensions(XmlDictionaryReader reader);
    public virtual void ReadXml(XmlDictionaryReader reader);
    public virtual void WriteXml(XmlWriter writer, SecurityTokenSerializer securityTokenSerializer);
}
internal class System.IdentityModel.EncryptedKeyElement : EncryptedTypeElement {
    public string CarriedName { get; }
    public IList`1<string> DataReferences { get; }
    public IList`1<string> KeyReferences { get; }
    public EncryptedKeyElement(SecurityTokenSerializer keyInfoSerializer);
    public string get_CarriedName();
    public IList`1<string> get_DataReferences();
    public IList`1<string> get_KeyReferences();
    public virtual void ReadExtensions(XmlDictionaryReader reader);
    public virtual void ReadXml(XmlDictionaryReader reader);
    public EncryptedKeyIdentifierClause GetClause();
}
internal abstract class System.IdentityModel.EncryptedTypeElement : object {
    public string Algorithm { get; public set; }
    public string Id { get; public set; }
    public EncryptionMethodElement EncryptionMethod { get; public set; }
    public CipherDataElement CipherData { get; public set; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public SecurityTokenSerializer TokenSerializer { get; }
    public string Type { get; public set; }
    public EncryptedTypeElement(SecurityTokenSerializer keyInfoSerializer);
    public string get_Algorithm();
    public void set_Algorithm(string value);
    public string get_Id();
    public void set_Id(string value);
    public EncryptionMethodElement get_EncryptionMethod();
    public void set_EncryptionMethod(EncryptionMethodElement value);
    public CipherDataElement get_CipherData();
    public void set_CipherData(CipherDataElement value);
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public abstract virtual void ReadExtensions(XmlDictionaryReader reader);
    public SecurityTokenSerializer get_TokenSerializer();
    public string get_Type();
    public void set_Type(string value);
    public virtual void ReadXml(XmlDictionaryReader reader);
}
internal class System.IdentityModel.EncryptionMethodElement : object {
    public string Algorithm { get; public set; }
    public string Parameters { get; public set; }
    public string get_Algorithm();
    public void set_Algorithm(string value);
    public string get_Parameters();
    public void set_Parameters(string value);
    public void ReadXml(XmlDictionaryReader reader);
    public void WriteXml(XmlWriter writer);
}
internal enum System.IdentityModel.Endianness : Enum {
    public int value__;
    public static Endianness Network;
    public static Endianness Native;
}
public class System.IdentityModel.EnvelopedSignatureReader : DelegatingXmlDictionaryReader {
    public SigningCredentials SigningCredentials { get; }
    internal XmlTokenStream XmlTokens { get; }
    public EnvelopedSignatureReader(XmlReader reader, SecurityTokenSerializer securityTokenSerializer);
    public EnvelopedSignatureReader(XmlReader reader, SecurityTokenSerializer securityTokenSerializer, SecurityTokenResolver signingTokenResolver);
    public EnvelopedSignatureReader(XmlReader reader, SecurityTokenSerializer securityTokenSerializer, SecurityTokenResolver signingTokenResolver, bool requireSignature, bool automaticallyReadSignature, bool resolveIntrinsicSigningKeys);
    public SigningCredentials get_SigningCredentials();
    internal XmlTokenStream get_XmlTokens();
    public virtual bool Read();
    public bool TryReadSignature();
    protected virtual void Dispose(bool disposing);
}
internal class System.IdentityModel.EnvelopedSignatureTransform : Transform {
    public string Algorithm { get; }
    public virtual string get_Algorithm();
    public virtual object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager);
    public virtual Byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager);
    public virtual void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments);
    public virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
public class System.IdentityModel.EnvelopedSignatureWriter : DelegatingXmlDictionaryWriter {
    public EnvelopedSignatureWriter(XmlWriter innerWriter, SigningCredentials signingCredentials, string referenceId, SecurityTokenSerializer securityTokenSerializer);
    public void WriteSignature();
    public virtual void WriteEndElement();
    public virtual void WriteFullEndElement();
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    protected virtual void Dispose(bool disposing);
}
internal class System.IdentityModel.ExclusiveC14NDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString PrefixList;
    public XmlDictionaryString InclusiveNamespaces;
    public XmlDictionaryString Prefix;
    public ExclusiveC14NDictionary(IdentityModelDictionary dictionary);
    public ExclusiveC14NDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.ExclusiveC14NStrings : object {
    public static string Namespace;
    public static string PrefixList;
    public static string InclusiveNamespaces;
    public static string Prefix;
}
internal class System.IdentityModel.ExclusiveCanonicalizationTransform : Transform {
    public string Algorithm { get; }
    public bool IncludeComments { get; }
    public string InclusiveNamespacesPrefixList { get; public set; }
    public bool NeedsInclusiveContext { get; }
    public ExclusiveCanonicalizationTransform(bool isCanonicalizationMethod);
    public ExclusiveCanonicalizationTransform(bool isCanonicalizationMethod, bool includeComments);
    public virtual string get_Algorithm();
    public bool get_IncludeComments();
    public string get_InclusiveNamespacesPrefixList();
    public void set_InclusiveNamespacesPrefixList(string value);
    public virtual bool get_NeedsInclusiveContext();
    public String[] GetInclusivePrefixes();
    public virtual object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager);
    public virtual Byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager);
    public void ProcessAndDigest(object input, SignatureResourcePool resourcePool, HashAlgorithm hash, DictionaryManager dictionaryManger);
    public virtual void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments);
    public virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal enum System.IdentityModel.EXTENDED_NAME_FORMAT : Enum {
    public int value__;
    public static EXTENDED_NAME_FORMAT NameUnknown;
    public static EXTENDED_NAME_FORMAT NameFullyQualifiedDN;
    public static EXTENDED_NAME_FORMAT NameSamCompatible;
    public static EXTENDED_NAME_FORMAT NameDisplay;
    public static EXTENDED_NAME_FORMAT NameUniqueId;
    public static EXTENDED_NAME_FORMAT NameCanonical;
    public static EXTENDED_NAME_FORMAT NameUserPrincipalName;
    public static EXTENDED_NAME_FORMAT NameCanonicalEx;
    public static EXTENDED_NAME_FORMAT NameServicePrincipalName;
    public static EXTENDED_NAME_FORMAT NameDnsDomainName;
}
internal class System.IdentityModel.ExtendedProtectionPolicyHelper : object {
    public ChannelBinding ChannelBinding { get; }
    public bool ShouldCheckServiceBinding { get; }
    public ServiceNameCollection ServiceNameCollection { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public static ExtendedProtectionPolicy DefaultPolicy { get; }
    public ExtendedProtectionPolicyHelper(ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy);
    private static ExtendedProtectionPolicyHelper();
    public bool ShouldAddChannelBindingToASC();
    public ChannelBinding get_ChannelBinding();
    public bool get_ShouldCheckServiceBinding();
    public ServiceNameCollection get_ServiceNameCollection();
    public ProtectionScenario get_ProtectionScenario();
    public PolicyEnforcement get_PolicyEnforcement();
    public void CheckServiceBinding(SafeDeleteContext securityContext, string defaultServiceBinding);
    public static ExtendedProtectionPolicy get_DefaultPolicy();
}
internal class System.IdentityModel.ExtendedTransformFactory : StandardTransformFactory {
    internal static ExtendedTransformFactory Instance { get; }
    private static ExtendedTransformFactory();
    internal static ExtendedTransformFactory get_Instance();
    public virtual Transform CreateTransform(string transformAlgorithmUri);
}
internal class System.IdentityModel.HashStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public HashAlgorithm Hash { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public HashStream(HashAlgorithm hash);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public HashAlgorithm get_Hash();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public void FlushHash();
    public void FlushHash(MemoryStream preCanonicalBytes);
    public Byte[] FlushHashAndGetValue();
    public Byte[] FlushHashAndGetValue(MemoryStream preCanonicalBytes);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Reset();
    public void Reset(HashAlgorithm hash);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long length);
    protected virtual void Dispose(bool disposing);
}
internal interface System.IdentityModel.ICanonicalWriterEndRootElementCallback {
    public abstract virtual void OnEndOfRootElement(XmlDictionaryWriter writer);
}
internal class System.IdentityModel.IdentityModelDictionary : object {
    public static IdentityModelDictionary Version1;
    public static IdentityModelDictionary CurrentVersion { get; }
    public IdentityModelDictionary(IdentityModelStrings strings);
    private static IdentityModelDictionary();
    public static IdentityModelDictionary get_CurrentVersion();
    public XmlDictionaryString CreateString(string value, int key);
    public sealed virtual bool TryLookup(string key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(int key, XmlDictionaryString& value);
    public sealed virtual bool TryLookup(XmlDictionaryString key, XmlDictionaryString& value);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.IdentityModel.IdentityModelStrings : object {
    public int Count { get; }
    public string Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.IdentityModelStringsVersion1 : IdentityModelStrings {
    public static string String0;
    public static string String1;
    public static string String2;
    public static string String3;
    public static string String4;
    public static string String5;
    public static string String6;
    public static string String7;
    public static string String8;
    public static string String9;
    public static string String10;
    public static string String11;
    public static string String12;
    public static string String13;
    public static string String14;
    public static string String15;
    public static string String16;
    public static string String17;
    public static string String18;
    public static string String19;
    public static string String20;
    public static string String21;
    public static string String22;
    public static string String23;
    public static string String24;
    public static string String25;
    public static string String26;
    public static string String27;
    public static string String28;
    public static string String29;
    public static string String30;
    public static string String31;
    public static string String32;
    public static string String33;
    public static string String34;
    public static string String35;
    public static string String36;
    public static string String37;
    public static string String38;
    public static string String39;
    public static string String40;
    public static string String41;
    public static string String42;
    public static string String43;
    public static string String44;
    public static string String45;
    public static string String46;
    public static string String47;
    public static string String48;
    public static string String49;
    public static string String50;
    public static string String51;
    public static string String52;
    public static string String53;
    public static string String54;
    public static string String55;
    public static string String56;
    public static string String57;
    public static string String58;
    public static string String59;
    public static string String60;
    public static string String61;
    public static string String62;
    public static string String63;
    public static string String64;
    public static string String65;
    public static string String66;
    public static string String67;
    public static string String68;
    public static string String69;
    public static string String70;
    public static string String71;
    public static string String72;
    public static string String73;
    public static string String74;
    public static string String75;
    public static string String76;
    public static string String77;
    public static string String78;
    public static string String79;
    public static string String80;
    public static string String81;
    public static string String82;
    public static string String83;
    public static string String84;
    public static string String85;
    public static string String86;
    public static string String87;
    public static string String88;
    public static string String89;
    public static string String90;
    public static string String91;
    public static string String92;
    public static string String93;
    public static string String94;
    public static string String95;
    public static string String96;
    public static string String97;
    public static string String98;
    public static string String99;
    public static string String100;
    public static string String101;
    public static string String102;
    public static string String103;
    public static string String104;
    public static string String105;
    public static string String106;
    public static string String107;
    public static string String108;
    public static string String109;
    public static string String110;
    public static string String111;
    public static string String112;
    public static string String113;
    public static string String114;
    public static string String115;
    public static string String116;
    public static string String117;
    public static string String118;
    public static string String119;
    public static string String120;
    public static string String121;
    public static string String122;
    public static string String123;
    public static string String124;
    public static string String125;
    public static string String126;
    public static string String127;
    public static string String128;
    public static string String129;
    public static string String130;
    public static string String131;
    public static string String132;
    public static string String133;
    public static string String134;
    public static string String135;
    public static string String136;
    public static string String137;
    public static string String138;
    public static string String139;
    public static string String140;
    public static string String141;
    public static string String142;
    public static string String143;
    public static string String144;
    public static string String145;
    public static string String146;
    public static string String147;
    public static string String148;
    public static string String149;
    public static string String150;
    public static string String151;
    public static string String152;
    public static string String153;
    public static string String154;
    public static string String155;
    public static string String156;
    public static string String157;
    public static string String158;
    public static string String159;
    public static string String160;
    public static string String161;
    public static string String162;
    public static string String163;
    public static string String164;
    public static string String165;
    public static string String166;
    public static string String167;
    public static string String168;
    public static string String169;
    public static string String170;
    public static string String171;
    public static string String172;
    public static string String173;
    public static string String174;
    public static string String175;
    public static string String176;
    public static string String177;
    public static string String178;
    public static string String179;
    public static string String180;
    public static string String181;
    public static string String182;
    public static string String183;
    public static string String184;
    public static string String185;
    public static string String186;
    public static string String187;
    public static string String188;
    public static string String189;
    public static string String190;
    public static string String191;
    public static string String192;
    public static string String193;
    public static string String194;
    public static string String195;
    public static string String196;
    public static string String197;
    public static string String198;
    public static string String199;
    public static string String200;
    public static string String201;
    public static string String202;
    public static string String203;
    public static string String204;
    public static string String205;
    public static string String206;
    public static string String207;
    public static string String208;
    public static string String209;
    public static string String210;
    public static string String211;
    public static string String212;
    public static string String213;
    public static string String214;
    public static string String215;
    public static string String216;
    public static string String217;
    public static string String218;
    public static string String219;
    public static string String220;
    public static string String221;
    public static string String222;
    public static string String223;
    public static string String224;
    public static string String225;
    public static string String226;
    public static string String227;
    public static string String228;
    public static string String229;
    public static string String230;
    public static string String231;
    public static string String232;
    public static string String233;
    public static string String234;
    public static string String235;
    public static string String236;
    public static string String237;
    public static string String238;
    public static string String239;
    public static string String240;
    public static string String241;
    public static string String242;
    public static string String243;
    public static string String244;
    public static string String245;
    public static string String246;
    public static string String247;
    public static string String248;
    public static string String249;
    public static string String250;
    public static string String251;
    public static string String252;
    public static string String253;
    public static string String254;
    public static string String255;
    public static string String256;
    public static string String257;
    public static string String258;
    public static string String259;
    public static string String260;
    public static string String261;
    public static string String262;
    public static string String263;
    public static string String264;
    public static string String265;
    public static string String266;
    public static string String267;
    public static string String268;
    public static string String269;
    public static string String270;
    public static string String271;
    public static string String272;
    public static string String273;
    public static string String274;
    public static string String275;
    public static string String276;
    public static string String277;
    public static string String278;
    public int Count { get; }
    public string Item { get; }
    public virtual int get_Count();
    public virtual string get_Item(int index);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.IdentityModelWrappedXmlDictionaryReader : XmlDictionaryReader {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public string Value { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public Type ValueType { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public IdentityModelWrappedXmlDictionaryReader(XmlReader reader, XmlDictionaryReaderQuotas xmlDictionaryReaderQuotas);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual void Close();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceUri);
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localName, string namespaceUri);
    public virtual string get_LocalName();
    public virtual string LookupNamespace(string namespaceUri);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string namespaceUri);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public virtual string ReadElementString(string name);
    public virtual string ReadElementString(string localName, string namespaceUri);
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localName, string namespaceUri);
    public virtual void ReadEndElement();
    public virtual string ReadString();
    public virtual ReadState get_ReadState();
    public virtual void ResolveEntity();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceUri);
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public virtual Type get_ValueType();
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual float ReadContentAsFloat();
    public virtual string ReadContentAsString();
    public virtual object ReadContentAs(Type valueType, IXmlNamespaceResolver namespaceResolver);
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
}
internal class System.IdentityModel.ImmutableCollection`1 : Collection`1<T> {
    public bool IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public void MakeReadOnly();
    public bool get_IsReadOnly();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
}
internal static class System.IdentityModel.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
}
internal interface System.IdentityModel.IPrefixGenerator {
    public abstract virtual string GetPrefix(string namespaceUri, int depth, bool isForAttribute);
}
internal interface System.IdentityModel.ISecurityElement {
    public bool HasId { get; }
    public string Id { get; }
    public abstract virtual bool get_HasId();
    public abstract virtual string get_Id();
    public abstract virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal interface System.IdentityModel.ISignatureReaderProvider {
    public abstract virtual XmlDictionaryReader GetReader(object callbackContext);
}
internal interface System.IdentityModel.ISignatureValueSecurityElement {
    public abstract virtual Byte[] GetSignatureValue();
}
internal interface System.IdentityModel.IWrappedTokenKeyResolver {
    public SecurityToken ExpectedWrapper { get; public set; }
    public abstract virtual SecurityToken get_ExpectedWrapper();
    public abstract virtual void set_ExpectedWrapper(SecurityToken value);
    public abstract virtual bool CheckExternalWrapperMatch(SecurityKeyIdentifier keyIdentifier);
}
internal class System.IdentityModel.KERB_CERTIFICATE_S4U_LOGON : ValueType {
    internal KERB_LOGON_SUBMIT_TYPE MessageType;
    internal UInt32 Flags;
    internal UNICODE_INTPTR_STRING UserPrincipalName;
    internal UNICODE_INTPTR_STRING DomainName;
    internal UInt32 CertificateLength;
    internal IntPtr Certificate;
    internal static int Size;
    private static KERB_CERTIFICATE_S4U_LOGON();
}
internal enum System.IdentityModel.KERB_LOGON_SUBMIT_TYPE : Enum {
    public int value__;
    public static KERB_LOGON_SUBMIT_TYPE KerbInteractiveLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbSmartCardLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbWorkstationUnlockLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbSmartCardUnlockLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbProxyLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbTicketLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbTicketUnlockLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbS4ULogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbCertificateLogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbCertificateS4ULogon;
    public static KERB_LOGON_SUBMIT_TYPE KerbCertificateUnlockLogon;
}
internal class System.IdentityModel.KeyInfo : object {
    public string RetrievalMethod { get; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public KeyInfo(SecurityTokenSerializer keyInfoSerializer);
    public string get_RetrievalMethod();
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public virtual void ReadXml(XmlDictionaryReader reader);
}
internal class System.IdentityModel.LifeSpan : object {
    internal DateTime EffectiveTimeUtc { get; }
    internal DateTime ExpiryTimeUtc { get; }
    internal LifeSpan(Byte[] buffer);
    internal DateTime get_EffectiveTimeUtc();
    internal DateTime get_ExpiryTimeUtc();
}
internal class System.IdentityModel.LifeSpan_Struct : ValueType {
    internal long start;
    internal long end;
    internal static int Size;
    private static LifeSpan_Struct();
}
public class System.IdentityModel.LimitExceededException : SystemException {
    public LimitExceededException(string message);
    public LimitExceededException(string message, Exception innerException);
    protected LimitExceededException(SerializationInfo info, StreamingContext context);
}
internal static class System.IdentityModel.LocalAppContextSwitches : object {
    public static bool EnableCachedEmptyDefaultAuthorizationContext { get; }
    public static bool DisableMultipleDNSEntriesInSANCertificate { get; }
    public static bool DisableUpdatingRsaProviderType { get; }
    public static bool DisableCngCertificates { get; }
    public static bool get_EnableCachedEmptyDefaultAuthorizationContext();
    public static bool get_DisableMultipleDNSEntriesInSANCertificate();
    public static bool get_DisableUpdatingRsaProviderType();
    public static bool get_DisableCngCertificates();
    public static void SetDefaultsLessOrEqual_452();
    public static void SetDefaultsLessOrEqual_46();
    public static void SetDefaultsLessOrEqual_462();
}
internal class System.IdentityModel.LUID : ValueType {
    internal UInt32 LowPart;
    internal UInt32 HighPart;
}
internal class System.IdentityModel.LUID_AND_ATTRIBUTES : ValueType {
    internal LUID Luid;
    internal UInt32 Attributes;
}
public class System.IdentityModel.Metadata.ApplicationServiceDescriptor : WebServiceDescriptor {
    public ICollection`1<EndpointReference> Endpoints { get; }
    public ICollection`1<EndpointReference> PassiveRequestorEndpoints { get; }
    public ICollection`1<EndpointReference> get_Endpoints();
    public ICollection`1<EndpointReference> get_PassiveRequestorEndpoints();
}
public class System.IdentityModel.Metadata.ContactPerson : object {
    public string Company { get; public set; }
    public ICollection`1<string> EmailAddresses { get; }
    public string GivenName { get; public set; }
    public string Surname { get; public set; }
    public ICollection`1<string> TelephoneNumbers { get; }
    public ContactType Type { get; public set; }
    public ContactPerson(ContactType contactType);
    public string get_Company();
    public void set_Company(string value);
    public ICollection`1<string> get_EmailAddresses();
    public string get_GivenName();
    public void set_GivenName(string value);
    public string get_Surname();
    public void set_Surname(string value);
    public ICollection`1<string> get_TelephoneNumbers();
    public ContactType get_Type();
    public void set_Type(ContactType value);
}
public enum System.IdentityModel.Metadata.ContactType : Enum {
    public int value__;
    public static ContactType Unspecified;
    public static ContactType Technical;
    public static ContactType Support;
    public static ContactType Administrative;
    public static ContactType Billing;
    public static ContactType Other;
}
public class System.IdentityModel.Metadata.DisplayClaim : object {
    public string ClaimType { get; }
    public string DisplayTag { get; public set; }
    public string DisplayValue { get; public set; }
    public string Description { get; public set; }
    public bool Optional { get; public set; }
    public bool WriteOptionalAttribute { get; public set; }
    public DisplayClaim(string claimType);
    public DisplayClaim(string claimType, string displayTag, string description);
    public DisplayClaim(string claimType, string displayTag, string description, string displayValue);
    public DisplayClaim(string claimType, string displayTag, string description, string displayValue, bool optional);
    private static DisplayClaim();
    public static DisplayClaim CreateDisplayClaimFromClaimType(string claimType);
    public string get_ClaimType();
    public string get_DisplayTag();
    public void set_DisplayTag(string value);
    public string get_DisplayValue();
    public void set_DisplayValue(string value);
    public string get_Description();
    public void set_Description(string value);
    public bool get_Optional();
    public void set_Optional(bool value);
    [CompilerGeneratedAttribute]
public bool get_WriteOptionalAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteOptionalAttribute(bool value);
}
public class System.IdentityModel.Metadata.EncryptionMethod : object {
    public Uri Algorithm { get; public set; }
    public EncryptionMethod(Uri algorithm);
    public Uri get_Algorithm();
    public void set_Algorithm(Uri value);
}
public class System.IdentityModel.Metadata.EntitiesDescriptor : MetadataBase {
    public ICollection`1<EntityDescriptor> ChildEntities { get; }
    public ICollection`1<EntitiesDescriptor> ChildEntityGroups { get; }
    public string Name { get; public set; }
    public EntitiesDescriptor(Collection`1<EntitiesDescriptor> entityGroupList);
    public EntitiesDescriptor(Collection`1<EntityDescriptor> entityList);
    public EntitiesDescriptor(Collection`1<EntityDescriptor> entityList, Collection`1<EntitiesDescriptor> entityGroupList);
    public ICollection`1<EntityDescriptor> get_ChildEntities();
    public ICollection`1<EntitiesDescriptor> get_ChildEntityGroups();
    public string get_Name();
    public void set_Name(string value);
}
public class System.IdentityModel.Metadata.EntityDescriptor : MetadataBase {
    public ICollection`1<ContactPerson> Contacts { get; }
    public EntityId EntityId { get; public set; }
    public string FederationId { get; public set; }
    public Organization Organization { get; public set; }
    public ICollection`1<RoleDescriptor> RoleDescriptors { get; }
    public EntityDescriptor(EntityId entityId);
    public ICollection`1<ContactPerson> get_Contacts();
    public EntityId get_EntityId();
    public void set_EntityId(EntityId value);
    public string get_FederationId();
    public void set_FederationId(string value);
    public Organization get_Organization();
    public void set_Organization(Organization value);
    public ICollection`1<RoleDescriptor> get_RoleDescriptors();
}
public class System.IdentityModel.Metadata.EntityId : object {
    public string Id { get; public set; }
    public EntityId(string id);
    public string get_Id();
    public void set_Id(string value);
}
internal static class System.IdentityModel.Metadata.FederationMetadataConstants : object {
    public static string Namespace;
    public static string Prefix;
}
public class System.IdentityModel.Metadata.IdentityProviderSingleSignOnDescriptor : SingleSignOnDescriptor {
    public ICollection`1<ProtocolEndpoint> SingleSignOnServices { get; }
    public ICollection`1<Saml2Attribute> SupportedAttributes { get; }
    public bool WantAuthenticationRequestsSigned { get; public set; }
    public ICollection`1<ProtocolEndpoint> get_SingleSignOnServices();
    public ICollection`1<Saml2Attribute> get_SupportedAttributes();
    public bool get_WantAuthenticationRequestsSigned();
    public void set_WantAuthenticationRequestsSigned(bool value);
}
public class System.IdentityModel.Metadata.IndexedProtocolEndpoint : ProtocolEndpoint {
    public int Index { get; public set; }
    public Nullable`1<bool> IsDefault { get; public set; }
    public IndexedProtocolEndpoint(int index, Uri binding, Uri location);
    public int get_Index();
    public void set_Index(int value);
    public Nullable`1<bool> get_IsDefault();
    public void set_IsDefault(Nullable`1<bool> value);
}
public class System.IdentityModel.Metadata.IndexedProtocolEndpointDictionary : SortedList`2<int, IndexedProtocolEndpoint> {
    public IndexedProtocolEndpoint Default { get; }
    public IndexedProtocolEndpoint get_Default();
}
public class System.IdentityModel.Metadata.KeyDescriptor : object {
    public SecurityKeyIdentifier KeyInfo { get; public set; }
    public KeyType Use { get; public set; }
    public ICollection`1<EncryptionMethod> EncryptionMethods { get; }
    public KeyDescriptor(SecurityKeyIdentifier ski);
    public SecurityKeyIdentifier get_KeyInfo();
    public void set_KeyInfo(SecurityKeyIdentifier value);
    public KeyType get_Use();
    public void set_Use(KeyType value);
    public ICollection`1<EncryptionMethod> get_EncryptionMethods();
}
public enum System.IdentityModel.Metadata.KeyType : Enum {
    public int value__;
    public static KeyType Unspecified;
    public static KeyType Signing;
    public static KeyType Encryption;
}
public abstract class System.IdentityModel.Metadata.LocalizedEntry : object {
    public CultureInfo Language { get; public set; }
    protected LocalizedEntry(CultureInfo language);
    public CultureInfo get_Language();
    public void set_Language(CultureInfo value);
}
public class System.IdentityModel.Metadata.LocalizedEntryCollection`1 : KeyedCollection`2<CultureInfo, T> {
    protected virtual CultureInfo GetKeyForItem(T item);
}
public class System.IdentityModel.Metadata.LocalizedName : LocalizedEntry {
    public string Name { get; public set; }
    public LocalizedName(string name, CultureInfo language);
    public string get_Name();
    public void set_Name(string value);
}
public class System.IdentityModel.Metadata.LocalizedUri : LocalizedEntry {
    public Uri Uri { get; public set; }
    public LocalizedUri(Uri uri, CultureInfo language);
    public Uri get_Uri();
    public void set_Uri(Uri value);
}
public abstract class System.IdentityModel.Metadata.MetadataBase : object {
    public SigningCredentials SigningCredentials { get; public set; }
    public SigningCredentials get_SigningCredentials();
    public void set_SigningCredentials(SigningCredentials value);
}
public class System.IdentityModel.Metadata.MetadataSerializationException : Exception {
    public MetadataSerializationException(string message);
    public MetadataSerializationException(string message, Exception innerException);
    protected MetadataSerializationException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Metadata.MetadataSerializer : object {
    public static string LanguagePrefix;
    public static string LanguageLocalName;
    public static string LanguageAttribute;
    public static string LanguageNamespaceUri;
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public List`1<string> TrustedIssuers { get; }
    public SecurityTokenSerializer SecurityTokenSerializer { get; }
    public MetadataSerializer(SecurityTokenSerializer tokenSerializer);
    protected virtual ApplicationServiceDescriptor CreateApplicationServiceInstance();
    protected virtual ContactPerson CreateContactPersonInstance();
    protected virtual ProtocolEndpoint CreateProtocolEndpointInstance();
    protected virtual EntitiesDescriptor CreateEntitiesDescriptorInstance();
    protected virtual EntityDescriptor CreateEntityDescriptorInstance();
    protected virtual IdentityProviderSingleSignOnDescriptor CreateIdentityProviderSingleSignOnDescriptorInstance();
    protected virtual IndexedProtocolEndpoint CreateIndexedProtocolEndpointInstance();
    protected virtual KeyDescriptor CreateKeyDescriptorInstance();
    protected virtual LocalizedName CreateLocalizedNameInstance();
    protected virtual LocalizedUri CreateLocalizedUriInstance();
    protected virtual Organization CreateOrganizationInstance();
    protected virtual SecurityTokenServiceDescriptor CreateSecurityTokenServiceDescriptorInstance();
    protected virtual ServiceProviderSingleSignOnDescriptor CreateServiceProviderSingleSignOnDescriptorInstance();
    protected virtual ApplicationServiceDescriptor ReadApplicationServiceDescriptor(XmlReader reader);
    protected virtual ContactPerson ReadContactPerson(XmlReader reader);
    protected virtual void ReadCustomAttributes(XmlReader reader, T target);
    protected virtual bool ReadCustomElement(XmlReader reader, T target);
    protected virtual void ReadCustomRoleDescriptor(string xsiType, XmlReader reader, EntityDescriptor entityDescriptor);
    protected virtual DisplayClaim ReadDisplayClaim(XmlReader reader);
    protected virtual EntitiesDescriptor ReadEntitiesDescriptor(XmlReader reader, SecurityTokenResolver tokenResolver);
    [CompilerGeneratedAttribute]
public X509CertificateValidationMode get_CertificateValidationMode();
    [CompilerGeneratedAttribute]
public void set_CertificateValidationMode(X509CertificateValidationMode value);
    [CompilerGeneratedAttribute]
public X509RevocationMode get_RevocationMode();
    [CompilerGeneratedAttribute]
public void set_RevocationMode(X509RevocationMode value);
    [CompilerGeneratedAttribute]
public StoreLocation get_TrustedStoreLocation();
    [CompilerGeneratedAttribute]
public void set_TrustedStoreLocation(StoreLocation value);
    [CompilerGeneratedAttribute]
public X509CertificateValidator get_CertificateValidator();
    [CompilerGeneratedAttribute]
public void set_CertificateValidator(X509CertificateValidator value);
    public List`1<string> get_TrustedIssuers();
    protected virtual void ValidateSigningCredential(SigningCredentials signingCredentials);
    protected virtual void ValidateIssuer(X509Certificate2 signingCertificate);
    protected virtual X509Certificate2 GetMetadataSigningCertificate(SecurityKeyIdentifier ski);
    protected virtual EntityDescriptor ReadEntityDescriptor(XmlReader inputReader, SecurityTokenResolver tokenResolver);
    protected virtual IdentityProviderSingleSignOnDescriptor ReadIdentityProviderSingleSignOnDescriptor(XmlReader reader);
    protected virtual IndexedProtocolEndpoint ReadIndexedProtocolEndpoint(XmlReader reader);
    protected virtual KeyDescriptor ReadKeyDescriptor(XmlReader reader);
    protected virtual LocalizedName ReadLocalizedName(XmlReader reader);
    protected virtual LocalizedUri ReadLocalizedUri(XmlReader reader);
    public MetadataBase ReadMetadata(Stream stream);
    public MetadataBase ReadMetadata(XmlReader reader);
    public MetadataBase ReadMetadata(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual MetadataBase ReadMetadataCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual Organization ReadOrganization(XmlReader reader);
    protected virtual ProtocolEndpoint ReadProtocolEndpoint(XmlReader reader);
    protected virtual void ReadRoleDescriptorAttributes(XmlReader reader, RoleDescriptor roleDescriptor);
    protected virtual bool ReadRoleDescriptorElement(XmlReader reader, RoleDescriptor roleDescriptor);
    protected virtual SecurityTokenServiceDescriptor ReadSecurityTokenServiceDescriptor(XmlReader reader);
    protected virtual ServiceProviderSingleSignOnDescriptor ReadServiceProviderSingleSignOnDescriptor(XmlReader reader);
    protected virtual void ReadSingleSignOnDescriptorAttributes(XmlReader reader, SingleSignOnDescriptor roleDescriptor);
    protected virtual bool ReadSingleSignOnDescriptorElement(XmlReader reader, SingleSignOnDescriptor singleSignOnDescriptor);
    protected virtual void ReadWebServiceDescriptorAttributes(XmlReader reader, WebServiceDescriptor roleDescriptor);
    public virtual bool ReadWebServiceDescriptorElement(XmlReader reader, WebServiceDescriptor roleDescriptor);
    public SecurityTokenSerializer get_SecurityTokenSerializer();
    protected virtual void WriteApplicationServiceDescriptor(XmlWriter writer, ApplicationServiceDescriptor appService);
    protected virtual void WriteContactPerson(XmlWriter writer, ContactPerson contactPerson);
    protected virtual void WriteCustomAttributes(XmlWriter writer, T source);
    protected virtual void WriteCustomElements(XmlWriter writer, T source);
    protected virtual void WriteProtocolEndpoint(XmlWriter writer, ProtocolEndpoint endpoint, XmlQualifiedName element);
    protected virtual void WriteDisplayClaim(XmlWriter writer, DisplayClaim claim);
    protected virtual void WriteEntitiesDescriptor(XmlWriter inputWriter, EntitiesDescriptor entitiesDescriptor);
    protected virtual void WriteEntityDescriptor(XmlWriter inputWriter, EntityDescriptor entityDescriptor);
    protected virtual void WriteIdentityProviderSingleSignOnDescriptor(XmlWriter writer, IdentityProviderSingleSignOnDescriptor identityProviderSingleSignOnDescriptor);
    protected virtual void WriteIndexedProtocolEndpoint(XmlWriter writer, IndexedProtocolEndpoint indexedEP, XmlQualifiedName element);
    protected virtual void WriteKeyDescriptor(XmlWriter writer, KeyDescriptor keyDescriptor);
    protected virtual void WriteLocalizedName(XmlWriter writer, LocalizedName name, XmlQualifiedName element);
    protected virtual void WriteLocalizedUri(XmlWriter writer, LocalizedUri uri, XmlQualifiedName element);
    public void WriteMetadata(Stream stream, MetadataBase metadata);
    public void WriteMetadata(XmlWriter writer, MetadataBase metadata);
    protected virtual void WriteMetadataCore(XmlWriter writer, MetadataBase metadataBase);
    protected virtual void WriteOrganization(XmlWriter writer, Organization organization);
    protected virtual void WriteRoleDescriptorAttributes(XmlWriter writer, RoleDescriptor roleDescriptor);
    protected virtual void WriteRoleDescriptorElements(XmlWriter writer, RoleDescriptor roleDescriptor);
    protected virtual void WriteSecurityTokenServiceDescriptor(XmlWriter writer, SecurityTokenServiceDescriptor securityTokenServiceDescriptor);
    protected virtual void WriteServiceProviderSingleSignOnDescriptor(XmlWriter writer, ServiceProviderSingleSignOnDescriptor serviceProviderSingleSignOnDescriptor);
    protected virtual void WriteSingleSignOnDescriptorAttributes(XmlWriter writer, SingleSignOnDescriptor singleSignOnDescriptor);
    protected virtual void WriteSingleSignOnDescriptorElements(XmlWriter writer, SingleSignOnDescriptor singleSignOnDescriptor);
    protected virtual void WriteWebServiceDescriptorAttributes(XmlWriter writer, WebServiceDescriptor wsDescriptor);
    protected virtual void WriteWebServiceDescriptorElements(XmlWriter writer, WebServiceDescriptor wsDescriptor);
    protected virtual Saml2Attribute ReadAttribute(XmlReader reader);
    protected virtual void WriteAttribute(XmlWriter writer, Saml2Attribute data);
}
public class System.IdentityModel.Metadata.Organization : object {
    public LocalizedEntryCollection`1<LocalizedName> DisplayNames { get; }
    public LocalizedEntryCollection`1<LocalizedName> Names { get; }
    public LocalizedEntryCollection`1<LocalizedUri> Urls { get; }
    public Organization(LocalizedEntryCollection`1<LocalizedName> names, LocalizedEntryCollection`1<LocalizedName> displayNames, LocalizedEntryCollection`1<LocalizedUri> urls);
    public LocalizedEntryCollection`1<LocalizedName> get_DisplayNames();
    public LocalizedEntryCollection`1<LocalizedName> get_Names();
    public LocalizedEntryCollection`1<LocalizedUri> get_Urls();
}
public class System.IdentityModel.Metadata.ProtocolEndpoint : object {
    public Uri Binding { get; public set; }
    public Uri Location { get; public set; }
    public Uri ResponseLocation { get; public set; }
    public ProtocolEndpoint(Uri binding, Uri location);
    public Uri get_Binding();
    public void set_Binding(Uri value);
    public Uri get_Location();
    public void set_Location(Uri value);
    public Uri get_ResponseLocation();
    public void set_ResponseLocation(Uri value);
}
public abstract class System.IdentityModel.Metadata.RoleDescriptor : object {
    public ICollection`1<ContactPerson> Contacts { get; }
    public Uri ErrorUrl { get; public set; }
    public ICollection`1<KeyDescriptor> Keys { get; }
    public Organization Organization { get; public set; }
    public ICollection`1<Uri> ProtocolsSupported { get; }
    public DateTime ValidUntil { get; public set; }
    protected RoleDescriptor(Collection`1<Uri> protocolsSupported);
    public ICollection`1<ContactPerson> get_Contacts();
    public Uri get_ErrorUrl();
    public void set_ErrorUrl(Uri value);
    public ICollection`1<KeyDescriptor> get_Keys();
    public Organization get_Organization();
    public void set_Organization(Organization value);
    public ICollection`1<Uri> get_ProtocolsSupported();
    public DateTime get_ValidUntil();
    public void set_ValidUntil(DateTime value);
}
internal static class System.IdentityModel.Metadata.Saml2MetadataConstants : object {
    public static string Namespace;
}
public class System.IdentityModel.Metadata.SecurityTokenServiceDescriptor : WebServiceDescriptor {
    public Collection`1<EndpointReference> SecurityTokenServiceEndpoints { get; }
    public Collection`1<EndpointReference> PassiveRequestorEndpoints { get; }
    public Collection`1<EndpointReference> get_SecurityTokenServiceEndpoints();
    public Collection`1<EndpointReference> get_PassiveRequestorEndpoints();
}
public class System.IdentityModel.Metadata.ServiceProviderSingleSignOnDescriptor : SingleSignOnDescriptor {
    public IndexedProtocolEndpointDictionary AssertionConsumerServices { get; }
    public bool AuthenticationRequestsSigned { get; public set; }
    public bool WantAssertionsSigned { get; public set; }
    public ServiceProviderSingleSignOnDescriptor(IndexedProtocolEndpointDictionary collection);
    public IndexedProtocolEndpointDictionary get_AssertionConsumerServices();
    public bool get_AuthenticationRequestsSigned();
    public void set_AuthenticationRequestsSigned(bool value);
    public bool get_WantAssertionsSigned();
    public void set_WantAssertionsSigned(bool value);
}
public class System.IdentityModel.Metadata.SingleSignOnDescriptor : RoleDescriptor {
    public ICollection`1<Uri> NameIdentifierFormats { get; }
    public IndexedProtocolEndpointDictionary ArtifactResolutionServices { get; }
    public Collection`1<ProtocolEndpoint> SingleLogoutServices { get; }
    public ICollection`1<Uri> get_NameIdentifierFormats();
    public IndexedProtocolEndpointDictionary get_ArtifactResolutionServices();
    public Collection`1<ProtocolEndpoint> get_SingleLogoutServices();
}
public abstract class System.IdentityModel.Metadata.WebServiceDescriptor : RoleDescriptor {
    public ICollection`1<DisplayClaim> ClaimTypesOffered { get; }
    public ICollection`1<DisplayClaim> ClaimTypesRequested { get; }
    public string ServiceDescription { get; public set; }
    public string ServiceDisplayName { get; public set; }
    public ICollection`1<EndpointReference> TargetScopes { get; }
    public ICollection`1<Uri> TokenTypesOffered { get; }
    public ICollection`1<DisplayClaim> get_ClaimTypesOffered();
    public ICollection`1<DisplayClaim> get_ClaimTypesRequested();
    public string get_ServiceDescription();
    public void set_ServiceDescription(string value);
    public string get_ServiceDisplayName();
    public void set_ServiceDisplayName(string value);
    public ICollection`1<EndpointReference> get_TargetScopes();
    public ICollection`1<Uri> get_TokenTypesOffered();
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.MostlySingletonList`1 : ValueType {
    private int count;
    private T singleton;
    private List`1<T> list;
    public T Item { get; }
    public int Count { get; }
    public T get_Item(int index);
    public int get_Count();
    public void Add(T item);
    public bool Contains(T item);
    public int IndexOf(T item);
    public bool Remove(T item);
    public void RemoveAt(int index);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.IdentityModel.NativeMethods : object {
    internal static UInt32 STATUS_NO_MEMORY;
    internal static UInt32 STATUS_INSUFFICIENT_RESOURCES;
    internal static UInt32 STATUS_ACCESS_DENIED;
    internal static UInt32 STATUS_ACCOUNT_RESTRICTION;
    internal static Byte[] LsaSourceName;
    internal static Byte[] LsaKerberosName;
    internal static UInt32 KERB_CERTIFICATE_S4U_LOGON_FLAG_CHECK_DUPLICATES;
    internal static UInt32 KERB_CERTIFICATE_S4U_LOGON_FLAG_CHECK_LOGONHOURS;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_BAD_LENGTH;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 SE_GROUP_ENABLED;
    internal static UInt32 SE_GROUP_USE_FOR_DENY_ONLY;
    internal static UInt32 SE_GROUP_LOGON_ID;
    internal static int PROV_RSA_AES;
    internal static int KP_IV;
    internal static UInt32 CRYPT_DELETEKEYSET;
    internal static UInt32 CRYPT_VERIFYCONTEXT;
    internal static byte PLAINTEXTKEYBLOB;
    internal static byte CUR_BLOB_VERSION;
    internal static int ALG_CLASS_DATA_ENCRYPT;
    internal static int ALG_TYPE_BLOCK;
    internal static int CALG_AES_128;
    internal static int CALG_AES_192;
    internal static int CALG_AES_256;
    private static NativeMethods();
    internal static bool LogonUser(string lpszUserName, string lpszDomain, string lpszPassword, UInt32 dwLogonType, UInt32 dwLogonProvider, SafeCloseHandle& phToken);
    internal static bool GetTokenInformation(IntPtr tokenHandle, UInt32 tokenInformationClass, SafeHGlobalHandle tokenInformation, UInt32 tokenInformationLength, UInt32& returnLength);
    internal static bool CryptAcquireContextW(SafeProvHandle& phProv, string pszContainer, string pszProvider, UInt32 dwProvType, UInt32 dwFlags);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CryptImportKey(SafeProvHandle hProv, Void* pbData, UInt32 dwDataLen, IntPtr hPubKey, UInt32 dwFlags, SafeKeyHandle& phKey);
    internal static bool CryptGetKeyParam(SafeKeyHandle phKey, UInt32 dwParam, IntPtr pbData, UInt32& dwDataLen, UInt32 dwFlags);
    internal static bool CryptSetKeyParam(SafeKeyHandle phKey, UInt32 dwParam, Void* pbData, UInt32 dwFlags);
    internal static bool CryptEncrypt(SafeKeyHandle phKey, IntPtr hHash, bool final, UInt32 dwFlags, Void* pbData, Int32& dwDataLen, int dwBufLen);
    internal static bool CryptDecrypt(SafeKeyHandle phKey, IntPtr hHash, bool final, UInt32 dwFlags, Void* pbData, Int32& dwDataLen);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CryptDestroyKey(IntPtr phKey);
    [ReliabilityContractAttribute("3", "2")]
internal static bool CryptReleaseContext(IntPtr hProv, UInt32 dwFlags);
    internal static bool LookupPrivilegeValueW(string lpSystemName, string lpName, LUID& Luid);
    [ReliabilityContractAttribute("3", "2")]
internal static bool AdjustTokenPrivileges(SafeCloseHandle tokenHandle, bool disableAllPrivileges, TOKEN_PRIVILEGE& newState, UInt32 bufferLength, TOKEN_PRIVILEGE& previousState, UInt32& returnLength);
    [ReliabilityContractAttribute("3", "2")]
internal static bool RevertToSelf();
    internal static bool OpenProcessToken(IntPtr processToken, TokenAccessLevels desiredAccess, SafeCloseHandle& tokenHandle);
    internal static bool OpenThreadToken(IntPtr threadHandle, TokenAccessLevels desiredAccess, bool openAsSelf, SafeCloseHandle& tokenHandle);
    internal static IntPtr GetCurrentProcess();
    internal static IntPtr GetCurrentThread();
    internal static bool DuplicateTokenEx(SafeCloseHandle existingTokenHandle, TokenAccessLevels desiredAccess, IntPtr tokenAttributes, SECURITY_IMPERSONATION_LEVEL impersonationLevel, TokenType tokenType, SafeCloseHandle& duplicateTokenHandle);
    [ReliabilityContractAttribute("3", "2")]
internal static bool SetThreadToken(IntPtr threadHandle, SafeCloseHandle threadToken);
    internal static int LsaRegisterLogonProcess(UNICODE_INTPTR_STRING& logonProcessName, SafeLsaLogonProcessHandle& lsaHandle, IntPtr& securityMode);
    internal static int LsaConnectUntrusted(SafeLsaLogonProcessHandle& lsaHandle);
    internal static int LsaNtStatusToWinError(int status);
    internal static int LsaLookupAuthenticationPackage(SafeLsaLogonProcessHandle lsaHandle, UNICODE_INTPTR_STRING& packageName, UInt32& authenticationPackage);
    internal static bool AllocateLocallyUniqueId(LUID& Luid);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaFreeReturnBuffer(IntPtr handle);
    internal static int LsaLogonUser(SafeLsaLogonProcessHandle LsaHandle, UNICODE_INTPTR_STRING& OriginName, SecurityLogonType LogonType, UInt32 AuthenticationPackage, IntPtr AuthenticationInformation, UInt32 AuthenticationInformationLength, IntPtr LocalGroups, TOKEN_SOURCE& SourceContext, SafeLsaReturnBufferHandle& ProfileBuffer, UInt32& ProfileBufferLength, LUID& LogonId, SafeCloseHandle& Token, QUOTA_LIMITS& Quotas, Int32& SubStatus);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaDeregisterLogonProcess(IntPtr handle);
    internal static UInt32 SspiPromptForCredentials(string pszTargetName, CREDUI_INFO& pUiInfo, UInt32 dwAuthError, string pszPackage, IntPtr authIdentity, IntPtr& ppAuthIdentity, Boolean& pfSave, UInt32 dwFlags);
    internal static bool SspiIsPromptingNeeded(UInt32 ErrorOrNtStatus);
    internal static bool TranslateName(string input, EXTENDED_NAME_FORMAT inputFormat, EXTENDED_NAME_FORMAT outputFormat, StringBuilder outputString, UInt32& size);
}
internal class System.IdentityModel.NegotiationInfo : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
    internal static int Size;
    internal static int NegotiationStateOffset;
    private static NegotiationInfo();
}
internal class System.IdentityModel.NegotiationInfoClass : object {
    internal static string NTLM;
    internal static string Kerberos;
    internal string AuthenticationPackage;
    internal NegotiationInfoClass(SafeHandle safeHandle, int negotiationState);
}
public abstract class System.IdentityModel.OpenObject : object {
    public Dictionary`2<string, object> Properties { get; }
    public Dictionary`2<string, object> get_Properties();
}
internal class System.IdentityModel.PLAINTEXTKEYBLOBHEADER : ValueType {
    internal byte bType;
    internal byte bVersion;
    internal short reserved;
    internal int aiKeyAlg;
    internal int keyLength;
    internal static int SizeOf;
    private static PLAINTEXTKEYBLOBHEADER();
}
public abstract class System.IdentityModel.Policy.AuthorizationContext : object {
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual DateTime get_ExpirationTime();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
}
internal class System.IdentityModel.Policy.DefaultAuthorizationContext : AuthorizationContext {
    public static DefaultAuthorizationContext Empty { get; }
    public string Id { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public DateTime ExpirationTime { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DefaultAuthorizationContext(DefaultEvaluationContext evaluationContext);
    public static DefaultAuthorizationContext get_Empty();
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual DateTime get_ExpirationTime();
    public virtual IDictionary`2<string, object> get_Properties();
}
internal class System.IdentityModel.Policy.DefaultEvaluationContext : EvaluationContext {
    public int Generation { get; }
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public DateTime ExpirationTime { get; }
    public virtual int get_Generation();
    public virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public virtual IDictionary`2<string, object> get_Properties();
    public DateTime get_ExpirationTime();
    public virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public virtual void RecordExpirationTime(DateTime expirationTime);
}
public abstract class System.IdentityModel.Policy.EvaluationContext : object {
    public ReadOnlyCollection`1<ClaimSet> ClaimSets { get; }
    public IDictionary`2<string, object> Properties { get; }
    public int Generation { get; }
    public abstract virtual ReadOnlyCollection`1<ClaimSet> get_ClaimSets();
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual int get_Generation();
    public abstract virtual void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
    public abstract virtual void RecordExpirationTime(DateTime expirationTime);
}
public interface System.IdentityModel.Policy.IAuthorizationComponent {
    public string Id { get; }
    public abstract virtual string get_Id();
}
public interface System.IdentityModel.Policy.IAuthorizationPolicy {
    public ClaimSet Issuer { get; }
    public abstract virtual ClaimSet get_Issuer();
    public abstract virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal interface System.IdentityModel.Policy.IIdentityInfo {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
}
internal class System.IdentityModel.Policy.UnconditionalPolicy : object {
    public string Id { get; }
    public ClaimSet Issuer { get; }
    internal IIdentity PrimaryIdentity { get; }
    internal ReadOnlyCollection`1<ClaimSet> Issuances { get; }
    public DateTime ExpirationTime { get; }
    internal bool IsDisposable { get; }
    public UnconditionalPolicy(ClaimSet issuance);
    public UnconditionalPolicy(ClaimSet issuance, DateTime expirationTime);
    public UnconditionalPolicy(ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ClaimSet issuance, DateTime expirationTime);
    internal UnconditionalPolicy(IIdentity primaryIdentity, ReadOnlyCollection`1<ClaimSet> issuances, DateTime expirationTime);
    public sealed virtual string get_Id();
    public sealed virtual ClaimSet get_Issuer();
    internal IIdentity get_PrimaryIdentity();
    internal ReadOnlyCollection`1<ClaimSet> get_Issuances();
    public DateTime get_ExpirationTime();
    internal bool get_IsDisposable();
    internal UnconditionalPolicy Clone();
    public virtual void Dispose();
    public virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
}
internal class System.IdentityModel.Pool`1 : object {
    public int Count { get; }
    public Pool`1(int maxCount);
    public int get_Count();
    public T Take();
    public bool Return(T item);
    public void Clear();
}
internal class System.IdentityModel.PreDigestedSignedInfo : SignedInfo {
    public bool AddEnvelopedSignatureTransform { get; public set; }
    public string DigestMethod { get; public set; }
    public int ReferenceCount { get; }
    public PreDigestedSignedInfo(DictionaryManager dictionaryManager);
    public PreDigestedSignedInfo(DictionaryManager dictionaryManager, string canonicalizationMethod, XmlDictionaryString canonicalizationMethodDictionaryString, string digestMethod, XmlDictionaryString digestMethodDictionaryString, string signatureMethod, XmlDictionaryString signatureMethodDictionaryString);
    public bool get_AddEnvelopedSignatureTransform();
    public void set_AddEnvelopedSignatureTransform(bool value);
    public string get_DigestMethod();
    public void set_DigestMethod(string value);
    public virtual int get_ReferenceCount();
    public void AddReference(string id, Byte[] digest);
    public void AddReference(string id, Byte[] digest, bool useStrTransform);
    protected virtual void ComputeHash(HashStream hashStream);
    public virtual void ComputeReferenceDigests();
    public virtual void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager);
    public virtual void EnsureAllReferencesVerified();
    public virtual bool EnsureDigestValidityIfIdMatches(string id, object resolvedXmlSource);
    public virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.Privilege : object {
    public static string SeAuditPrivilege;
    public static string SeTcbPrivilege;
    public Privilege(string privilege);
    private static Privilege();
    public void Enable();
    [ReliabilityContractAttribute("3", "2")]
public int Revert();
}
internal static class System.IdentityModel.ProductConstants : object {
    public static string NamespaceUri;
    public static string ClaimValueTypeSerializationPrefix;
    public static string ClaimValueTypeSerializationPrefixWithColon;
}
public class System.IdentityModel.ProtectedDataCookieTransform : CookieTransform {
    public virtual Byte[] Decode(Byte[] encoded);
    public virtual Byte[] Encode(Byte[] value);
}
internal static class System.IdentityModel.Protocols.WSFederation.WSAuthorizationConstants : object {
    public static string Prefix;
    public static string Namespace;
    public static string Dialect;
    public static string Action;
}
internal static class System.IdentityModel.Protocols.WSFederation.WSFederationMetadataConstants : object {
    public static string Namespace;
    public static string Prefix;
    public static string WSTransferAction;
    public static string WSTransferResponseAction;
    public static string FederationMetadataHandler;
}
internal static class System.IdentityModel.Protocols.WSMetadataExchangeConstants : object {
    public static string Namespace;
}
public class System.IdentityModel.Protocols.WSTrust.AdditionalContext : object {
    public IList`1<ContextItem> Items { get; }
    public AdditionalContext(IEnumerable`1<ContextItem> items);
    public IList`1<ContextItem> get_Items();
}
public class System.IdentityModel.Protocols.WSTrust.BinaryExchange : object {
    public Byte[] BinaryData { get; }
    public Uri ValueType { get; }
    public Uri EncodingType { get; }
    public BinaryExchange(Byte[] binaryData, Uri valueType);
    public BinaryExchange(Byte[] binaryData, Uri valueType, Uri encodingType);
    public Byte[] get_BinaryData();
    public Uri get_ValueType();
    public Uri get_EncodingType();
}
public class System.IdentityModel.Protocols.WSTrust.ContextItem : object {
    public Uri Name { get; public set; }
    public Uri Scope { get; public set; }
    public string Value { get; public set; }
    public ContextItem(Uri name);
    public ContextItem(Uri name, string value);
    public ContextItem(Uri name, string value, Uri scope);
    public Uri get_Name();
    public void set_Name(Uri value);
    public Uri get_Scope();
    public void set_Scope(Uri value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.IdentityModel.Protocols.WSTrust.EndpointReference : object {
    public Collection`1<XmlElement> Details { get; }
    public Uri Uri { get; }
    public EndpointReference(string uri);
    public Collection`1<XmlElement> get_Details();
    public Uri get_Uri();
    public void WriteTo(XmlWriter writer);
    public static EndpointReference ReadFrom(XmlReader reader);
    public static EndpointReference ReadFrom(XmlDictionaryReader reader);
}
public class System.IdentityModel.Protocols.WSTrust.Entropy : ProtectedKey {
    public Entropy(int entropySizeInBits);
    public Entropy(Byte[] secret);
    public Entropy(Byte[] secret, EncryptingCredentials wrappingCredentials);
    public Entropy(ProtectedKey protectedKey);
}
internal class System.IdentityModel.Protocols.WSTrust.FederatedClientCredentialsParameters : object {
    public SecurityToken ActAs { get; public set; }
    public SecurityToken OnBehalfOf { get; public set; }
    public SecurityToken IssuedSecurityToken { get; public set; }
    public SecurityToken get_ActAs();
    public void set_ActAs(SecurityToken value);
    public SecurityToken get_OnBehalfOf();
    public void set_OnBehalfOf(SecurityToken value);
    public SecurityToken get_IssuedSecurityToken();
    public void set_IssuedSecurityToken(SecurityToken value);
}
public class System.IdentityModel.Protocols.WSTrust.InvalidRequestException : RequestException {
    public InvalidRequestException(string message);
    public InvalidRequestException(string message, Exception innerException);
    protected InvalidRequestException(SerializationInfo info, StreamingContext context);
}
public static class System.IdentityModel.Protocols.WSTrust.KeyTypes : object {
    public static string Symmetric;
    public static string Asymmetric;
    public static string Bearer;
}
public class System.IdentityModel.Protocols.WSTrust.Lifetime : object {
    public Nullable`1<DateTime> Created { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public Lifetime(DateTime created, DateTime expires);
    public Lifetime(Nullable`1<DateTime> created, Nullable`1<DateTime> expires);
    public Nullable`1<DateTime> get_Created();
    public void set_Created(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_Expires();
    public void set_Expires(Nullable`1<DateTime> value);
}
public class System.IdentityModel.Protocols.WSTrust.Participants : object {
    public EndpointReference Primary { get; public set; }
    public List`1<EndpointReference> Participant { get; }
    public EndpointReference get_Primary();
    public void set_Primary(EndpointReference value);
    public List`1<EndpointReference> get_Participant();
}
public class System.IdentityModel.Protocols.WSTrust.ProtectedKey : object {
    public EncryptingCredentials WrappingCredentials { get; }
    public ProtectedKey(Byte[] secret);
    public ProtectedKey(Byte[] secret, EncryptingCredentials wrappingCredentials);
    public Byte[] GetKeyBytes();
    public EncryptingCredentials get_WrappingCredentials();
}
public class System.IdentityModel.Protocols.WSTrust.Renewing : object {
    public bool AllowRenewal { get; public set; }
    public bool OkForRenewalAfterExpiration { get; public set; }
    public Renewing(bool allowRenewal, bool okForRenewalAfterExpiration);
    public bool get_AllowRenewal();
    public void set_AllowRenewal(bool value);
    public bool get_OkForRenewalAfterExpiration();
    public void set_OkForRenewalAfterExpiration(bool value);
}
public class System.IdentityModel.Protocols.WSTrust.RequestClaim : object {
    public string ClaimType { get; }
    public bool IsOptional { get; public set; }
    public string Value { get; public set; }
    public RequestClaim(string claimType);
    public RequestClaim(string claimType, bool isOptional);
    public RequestClaim(string claimType, bool isOptional, string value);
    public string get_ClaimType();
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.IdentityModel.Protocols.WSTrust.RequestClaimCollection : Collection`1<RequestClaim> {
    public string Dialect { get; public set; }
    public string get_Dialect();
    public void set_Dialect(string value);
}
public class System.IdentityModel.Protocols.WSTrust.RequestedProofToken : object {
    public string ComputedKeyAlgorithm { get; }
    public ProtectedKey ProtectedKey { get; }
    public RequestedProofToken(string computedKeyAlgorithm);
    public RequestedProofToken(Byte[] secret);
    public RequestedProofToken(Byte[] secret, EncryptingCredentials wrappingCredentials);
    public RequestedProofToken(ProtectedKey protectedKey);
    public string get_ComputedKeyAlgorithm();
    public ProtectedKey get_ProtectedKey();
}
public class System.IdentityModel.Protocols.WSTrust.RequestedSecurityToken : object {
    public XmlElement SecurityTokenXml { get; }
    public SecurityToken SecurityToken { get; }
    public RequestedSecurityToken(SecurityToken token);
    public RequestedSecurityToken(XmlElement tokenAsXml);
    public virtual XmlElement get_SecurityTokenXml();
    public SecurityToken get_SecurityToken();
}
public class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken : WSTrustMessage {
    public RequestClaimCollection Claims { get; }
    public SecurityTokenElement Encryption { get; public set; }
    public string ComputedKeyAlgorithm { get; public set; }
    public Nullable`1<bool> Delegatable { get; public set; }
    public SecurityTokenElement DelegateTo { get; public set; }
    public Nullable`1<bool> Forwardable { get; public set; }
    public SecurityTokenElement OnBehalfOf { get; public set; }
    public Participants Participants { get; public set; }
    public EndpointReference Issuer { get; public set; }
    public AdditionalContext AdditionalContext { get; public set; }
    public SecurityTokenElement ActAs { get; public set; }
    public SecurityTokenElement CancelTarget { get; public set; }
    public SecurityTokenElement ProofEncryption { get; public set; }
    public Renewing Renewing { get; public set; }
    public SecurityTokenElement RenewTarget { get; public set; }
    public RequestSecurityToken SecondaryParameters { get; public set; }
    public SecurityTokenElement ValidateTarget { get; public set; }
    public RequestSecurityToken(string requestType);
    public RequestSecurityToken(string requestType, string keyType);
    public RequestClaimCollection get_Claims();
    public SecurityTokenElement get_Encryption();
    public void set_Encryption(SecurityTokenElement value);
    public string get_ComputedKeyAlgorithm();
    public void set_ComputedKeyAlgorithm(string value);
    public Nullable`1<bool> get_Delegatable();
    public void set_Delegatable(Nullable`1<bool> value);
    public SecurityTokenElement get_DelegateTo();
    public void set_DelegateTo(SecurityTokenElement value);
    public Nullable`1<bool> get_Forwardable();
    public void set_Forwardable(Nullable`1<bool> value);
    public SecurityTokenElement get_OnBehalfOf();
    public void set_OnBehalfOf(SecurityTokenElement value);
    public Participants get_Participants();
    public void set_Participants(Participants value);
    public EndpointReference get_Issuer();
    public void set_Issuer(EndpointReference value);
    public AdditionalContext get_AdditionalContext();
    public void set_AdditionalContext(AdditionalContext value);
    public SecurityTokenElement get_ActAs();
    public void set_ActAs(SecurityTokenElement value);
    public SecurityTokenElement get_CancelTarget();
    public void set_CancelTarget(SecurityTokenElement value);
    public SecurityTokenElement get_ProofEncryption();
    public void set_ProofEncryption(SecurityTokenElement value);
    public Renewing get_Renewing();
    public void set_Renewing(Renewing value);
    public SecurityTokenElement get_RenewTarget();
    public void set_RenewTarget(SecurityTokenElement value);
    public RequestSecurityToken get_SecondaryParameters();
    public void set_SecondaryParameters(RequestSecurityToken value);
    public SecurityTokenElement get_ValidateTarget();
    public void set_ValidateTarget(SecurityTokenElement value);
}
public class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse : WSTrustMessage {
    public bool IsFinal { get; public set; }
    public SecurityKeyIdentifierClause RequestedAttachedReference { get; public set; }
    public RequestedSecurityToken RequestedSecurityToken { get; public set; }
    public RequestedProofToken RequestedProofToken { get; public set; }
    public SecurityKeyIdentifierClause RequestedUnattachedReference { get; public set; }
    public bool RequestedTokenCancelled { get; public set; }
    public Status Status { get; public set; }
    public RequestSecurityTokenResponse(WSTrustMessage message);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public SecurityKeyIdentifierClause get_RequestedAttachedReference();
    public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value);
    public RequestedSecurityToken get_RequestedSecurityToken();
    public void set_RequestedSecurityToken(RequestedSecurityToken value);
    public RequestedProofToken get_RequestedProofToken();
    public void set_RequestedProofToken(RequestedProofToken value);
    public SecurityKeyIdentifierClause get_RequestedUnattachedReference();
    public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value);
    public bool get_RequestedTokenCancelled();
    public void set_RequestedTokenCancelled(bool value);
    public Status get_Status();
    public void set_Status(Status value);
}
public static class System.IdentityModel.Protocols.WSTrust.RequestTypes : object {
    public static string Cancel;
    public static string Issue;
    public static string Renew;
    public static string Validate;
    public static string IssueCard;
    public static string GetMetadata;
}
public class System.IdentityModel.Protocols.WSTrust.Status : object {
    public string Code { get; public set; }
    public string Reason { get; public set; }
    public Status(string code, string reason);
    public string get_Code();
    public void set_Code(string value);
    public string get_Reason();
    public void set_Reason(string value);
}
public class System.IdentityModel.Protocols.WSTrust.UseKey : object {
    public SecurityToken Token { get; }
    public SecurityKeyIdentifier SecurityKeyIdentifier { get; }
    public UseKey(SecurityKeyIdentifier ski);
    public UseKey(SecurityToken token);
    public UseKey(SecurityKeyIdentifier ski, SecurityToken token);
    public SecurityToken get_Token();
    public SecurityKeyIdentifier get_SecurityKeyIdentifier();
}
internal static class System.IdentityModel.Protocols.WSTrust.WSIdentityConstants : object {
    public static string Namespace;
    public static string Prefix;
    public static string Dialect;
}
internal static class System.IdentityModel.Protocols.WSTrust.WSPolicyConstants : object {
    public static string NamespaceURI;
    public static string Prefix;
}
internal static class System.IdentityModel.Protocols.WSTrust.WSTrust13Constants : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string SchemaLocation;
    public static string Schema;
}
internal class System.IdentityModel.Protocols.WSTrust.WSTrust13ConstantsAdapter : WSTrustConstantsAdapter {
    internal static WSTrust13ConstantsAdapter Instance { get; }
    internal WSTrustActions Actions { get; }
    internal WSTrustComputedKeyAlgorithm ComputedKeyAlgorithm { get; }
    internal WSTrustElementNames Elements { get; }
    internal WSTrustKeyTypes KeyTypes { get; }
    internal WSTrustRequestTypes RequestTypes { get; }
    internal static WSTrust13ConstantsAdapter get_Instance();
    internal virtual WSTrustActions get_Actions();
    internal virtual WSTrustComputedKeyAlgorithm get_ComputedKeyAlgorithm();
    internal virtual WSTrustElementNames get_Elements();
    internal virtual WSTrustKeyTypes get_KeyTypes();
    internal virtual WSTrustRequestTypes get_RequestTypes();
}
public class System.IdentityModel.Protocols.WSTrust.WSTrust13RequestSerializer : WSTrustRequestSerializer {
    public virtual RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public virtual void ReadXmlElement(XmlReader reader, RequestSecurityToken rst, WSTrustSerializationContext context);
    public virtual void WriteKnownRequestElement(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken rst, WSTrustSerializationContext context);
    public virtual bool CanRead(XmlReader reader);
    protected virtual RequestSecurityToken ReadSecondaryParameters(XmlReader reader, WSTrustSerializationContext context);
}
public class System.IdentityModel.Protocols.WSTrust.WSTrust13ResponseSerializer : WSTrustResponseSerializer {
    public virtual RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public virtual void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context);
    public virtual void WriteKnownResponseElement(RequestSecurityTokenResponse rstr, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context);
    public virtual bool CanRead(XmlReader reader);
}
internal static class System.IdentityModel.Protocols.WSTrust.WSTrust14Constants : object {
    public static string NamespaceURI;
    public static string Prefix;
}
internal abstract class System.IdentityModel.Protocols.WSTrust.WSTrustConstantsAdapter : object {
    internal static WSTrustFeb2005ConstantsAdapter TrustFeb2005 { get; }
    internal static WSTrust13ConstantsAdapter Trust13 { get; }
    internal string NamespaceURI { get; internal set; }
    internal string Prefix { get; internal set; }
    internal WSTrustActions Actions { get; }
    internal WSTrustAttributeNames Attributes { get; }
    internal WSTrustComputedKeyAlgorithm ComputedKeyAlgorithm { get; }
    internal WSTrustElementNames Elements { get; }
    internal FaultCodeValues FaultCodes { get; }
    internal WSTrustRequestTypes RequestTypes { get; }
    internal WSTrustKeyTypes KeyTypes { get; }
    internal static WSTrustFeb2005ConstantsAdapter get_TrustFeb2005();
    internal static WSTrust13ConstantsAdapter get_Trust13();
    internal string get_NamespaceURI();
    internal void set_NamespaceURI(string value);
    internal string get_Prefix();
    internal void set_Prefix(string value);
    internal abstract virtual WSTrustActions get_Actions();
    internal virtual WSTrustAttributeNames get_Attributes();
    internal abstract virtual WSTrustComputedKeyAlgorithm get_ComputedKeyAlgorithm();
    internal virtual WSTrustElementNames get_Elements();
    internal virtual FaultCodeValues get_FaultCodes();
    internal abstract virtual WSTrustRequestTypes get_RequestTypes();
    internal abstract virtual WSTrustKeyTypes get_KeyTypes();
    internal static WSTrustConstantsAdapter GetConstantsAdapter(string ns);
}
internal static class System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005Constants : object {
    public static string NamespaceURI;
    public static string Prefix;
    public static string SchemaLocation;
    public static string Schema;
}
internal class System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005ConstantsAdapter : WSTrustConstantsAdapter {
    internal static WSTrustFeb2005ConstantsAdapter Instance { get; }
    internal WSTrustActions Actions { get; }
    internal WSTrustComputedKeyAlgorithm ComputedKeyAlgorithm { get; }
    internal WSTrustKeyTypes KeyTypes { get; }
    internal WSTrustRequestTypes RequestTypes { get; }
    internal static WSTrustFeb2005ConstantsAdapter get_Instance();
    internal virtual WSTrustActions get_Actions();
    internal virtual WSTrustComputedKeyAlgorithm get_ComputedKeyAlgorithm();
    internal virtual WSTrustKeyTypes get_KeyTypes();
    internal virtual WSTrustRequestTypes get_RequestTypes();
}
public class System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005RequestSerializer : WSTrustRequestSerializer {
    public virtual RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public virtual void ReadXmlElement(XmlReader reader, RequestSecurityToken rst, WSTrustSerializationContext context);
    public virtual void WriteKnownRequestElement(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken rst, WSTrustSerializationContext context);
    public virtual bool CanRead(XmlReader reader);
}
public class System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005ResponseSerializer : WSTrustResponseSerializer {
    public virtual RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public virtual void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context);
    public virtual void WriteKnownResponseElement(RequestSecurityTokenResponse rstr, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context);
    public virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context);
    public virtual bool CanRead(XmlReader reader);
}
public abstract class System.IdentityModel.Protocols.WSTrust.WSTrustMessage : OpenObject {
    public bool AllowPostdating { get; public set; }
    public EndpointReference AppliesTo { get; public set; }
    public BinaryExchange BinaryExchange { get; public set; }
    public string ReplyTo { get; public set; }
    public string AuthenticationType { get; public set; }
    public string CanonicalizationAlgorithm { get; public set; }
    public string Context { get; public set; }
    public string EncryptionAlgorithm { get; public set; }
    public Entropy Entropy { get; public set; }
    public string EncryptWith { get; public set; }
    public string SignWith { get; public set; }
    public Nullable`1<int> KeySizeInBits { get; public set; }
    public string KeyType { get; public set; }
    public string KeyWrapAlgorithm { get; public set; }
    public Lifetime Lifetime { get; public set; }
    public string RequestType { get; public set; }
    public string SignatureAlgorithm { get; public set; }
    public string TokenType { get; public set; }
    public UseKey UseKey { get; public set; }
    public bool get_AllowPostdating();
    public void set_AllowPostdating(bool value);
    public EndpointReference get_AppliesTo();
    public void set_AppliesTo(EndpointReference value);
    public BinaryExchange get_BinaryExchange();
    public void set_BinaryExchange(BinaryExchange value);
    public string get_ReplyTo();
    public void set_ReplyTo(string value);
    public string get_AuthenticationType();
    public void set_AuthenticationType(string value);
    public string get_CanonicalizationAlgorithm();
    public void set_CanonicalizationAlgorithm(string value);
    public string get_Context();
    public void set_Context(string value);
    public string get_EncryptionAlgorithm();
    public void set_EncryptionAlgorithm(string value);
    public Entropy get_Entropy();
    public void set_Entropy(Entropy value);
    public string get_EncryptWith();
    public void set_EncryptWith(string value);
    public string get_SignWith();
    public void set_SignWith(string value);
    public Nullable`1<int> get_KeySizeInBits();
    public void set_KeySizeInBits(Nullable`1<int> value);
    public string get_KeyType();
    public void set_KeyType(string value);
    public string get_KeyWrapAlgorithm();
    public void set_KeyWrapAlgorithm(string value);
    public Lifetime get_Lifetime();
    public void set_Lifetime(Lifetime value);
    public string get_RequestType();
    public void set_RequestType(string value);
    public string get_SignatureAlgorithm();
    public void set_SignatureAlgorithm(string value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public UseKey get_UseKey();
    public void set_UseKey(UseKey value);
}
public abstract class System.IdentityModel.Protocols.WSTrust.WSTrustRequestSerializer : object {
    public abstract virtual RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public abstract virtual void ReadXmlElement(XmlReader reader, RequestSecurityToken requestSecurityToken, WSTrustSerializationContext context);
    public abstract virtual void WriteKnownRequestElement(RequestSecurityToken requestSecurityToken, XmlWriter writer, WSTrustSerializationContext context);
    public abstract virtual void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context);
    public abstract virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken requestSecurityToken, WSTrustSerializationContext context);
    public virtual RequestSecurityToken CreateRequestSecurityToken();
    public virtual void Validate(RequestSecurityToken requestSecurityToken);
    public abstract virtual bool CanRead(XmlReader reader);
    protected virtual void ReadCustomElement(XmlReader reader, WSTrustSerializationContext context);
}
public abstract class System.IdentityModel.Protocols.WSTrust.WSTrustResponseSerializer : object {
    public abstract virtual RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context);
    public abstract virtual void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse requestSecurityTokenResponse, WSTrustSerializationContext context);
    public abstract virtual void WriteKnownResponseElement(RequestSecurityTokenResponse requestSecurityTokenResponse, XmlWriter writer, WSTrustSerializationContext context);
    public abstract virtual void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context);
    public abstract virtual void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse requestSecurityTokenResponse, WSTrustSerializationContext context);
    public virtual RequestSecurityTokenResponse CreateInstance();
    public virtual void Validate(RequestSecurityTokenResponse requestSecurityTokenResponse);
    public abstract virtual bool CanRead(XmlReader reader);
}
public class System.IdentityModel.Protocols.WSTrust.WSTrustSerializationContext : object {
    public SecurityTokenResolver TokenResolver { get; public set; }
    public SecurityTokenResolver UseKeyTokenResolver { get; public set; }
    public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager { get; public set; }
    public SecurityTokenHandlerCollection SecurityTokenHandlers { get; }
    public WSTrustSerializationContext(SecurityTokenHandlerCollectionManager securityTokenHandlerCollectionManager);
    public WSTrustSerializationContext(SecurityTokenHandlerCollectionManager securityTokenHandlerCollectionManager, SecurityTokenResolver securityTokenResolver, SecurityTokenResolver useKeyTokenResolver);
    public SecurityTokenResolver get_TokenResolver();
    public void set_TokenResolver(SecurityTokenResolver value);
    public SecurityTokenResolver get_UseKeyTokenResolver();
    public void set_UseKeyTokenResolver(SecurityTokenResolver value);
    public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager();
    public void set_SecurityTokenHandlerCollectionManager(SecurityTokenHandlerCollectionManager value);
    public SecurityTokenHandlerCollection get_SecurityTokenHandlers();
}
public class System.IdentityModel.Protocols.WSTrust.WSTrustSerializationException : Exception {
    public WSTrustSerializationException(string message);
    public WSTrustSerializationException(string message, Exception inner);
    protected WSTrustSerializationException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.Protocols.WSTrust.WSTrustSerializationHelper : object {
    public static RequestSecurityToken CreateRequest(XmlReader reader, WSTrustSerializationContext context, WSTrustRequestSerializer requestSerializer, WSTrustConstantsAdapter trustConstants);
    public static void ReadRSTXml(XmlReader reader, RequestSecurityToken rst, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static void WriteRequest(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context, WSTrustRequestSerializer requestSerializer, WSTrustConstantsAdapter trustConstants);
    public static void WriteKnownRequestElement(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context, WSTrustRequestSerializer requestSerializer, WSTrustConstantsAdapter trustConstants);
    public static void WriteRSTXml(XmlWriter writer, string elementName, object elementValue, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static RequestSecurityTokenResponse CreateResponse(XmlReader reader, WSTrustSerializationContext context, WSTrustResponseSerializer responseSerializer, WSTrustConstantsAdapter trustConstants);
    public static void ReadRSTRXml(XmlReader reader, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static void WriteResponse(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context, WSTrustResponseSerializer responseSerializer, WSTrustConstantsAdapter trustConstants);
    public static void WriteKnownResponseElement(RequestSecurityTokenResponse rstr, XmlWriter writer, WSTrustSerializationContext context, WSTrustResponseSerializer responseSerializer, WSTrustConstantsAdapter trustConstants);
    public static void WriteRSTRXml(XmlWriter writer, string elementName, object elementValue, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static string ReadComputedKeyAlgorithm(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteComputedKeyAlgorithm(XmlWriter writer, string elementName, string computedKeyAlgorithm, WSTrustConstantsAdapter trustConstants);
    public static Status ReadStatus(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static BinaryExchange ReadBinaryExchange(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteBinaryExchange(XmlWriter writer, BinaryExchange binaryExchange, WSTrustConstantsAdapter trustConstants);
    public static void WriteStatus(XmlWriter writer, Status status, WSTrustConstantsAdapter trustConstants);
    public static ProtectedKey ReadProtectedKey(XmlReader reader, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static void WriteProtectedKey(XmlWriter writer, ProtectedKey protectedKey, WSTrustSerializationContext context, WSTrustConstantsAdapter trustConstants);
    public static string ReadRequestType(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteRequestType(XmlWriter writer, string requestType, WSTrustConstantsAdapter trustConstants);
    public static Lifetime ReadLifetime(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteLifetime(XmlWriter writer, Lifetime lifetime, WSTrustConstantsAdapter trustConstants);
    public static EndpointReference ReadOnBehalfOfIssuer(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteOnBehalfOfIssuer(XmlWriter writer, EndpointReference issuer, WSTrustConstantsAdapter trustConstants);
    public static EndpointReference ReadAppliesTo(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteAppliesTo(XmlWriter writer, EndpointReference appliesTo, WSTrustConstantsAdapter trustConstants);
    public static string ReadKeyType(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteKeyType(XmlWriter writer, string keyType, WSTrustConstantsAdapter trustConstants);
    public static XmlElement ReadInnerXml(XmlReader reader);
    public static XmlElement ReadInnerXml(XmlReader reader, bool onStartElement);
    public static BinarySecretSecurityToken ReadBinarySecretSecurityToken(XmlReader reader, WSTrustConstantsAdapter trustConstants);
    public static void WriteBinarySecretSecurityToken(XmlWriter writer, BinarySecretSecurityToken token, WSTrustConstantsAdapter trustConstants);
}
internal class System.IdentityModel.Psha1DerivedKeyGenerator : object {
    public Psha1DerivedKeyGenerator(Byte[] key);
    public Byte[] GenerateDerivedKey(Byte[] label, Byte[] nonce, int derivedKeySize, int position);
}
internal class System.IdentityModel.QUOTA_LIMITS : ValueType {
    internal IntPtr PagedPoolLimit;
    internal IntPtr NonPagedPoolLimit;
    internal IntPtr MinimumWorkingSetSize;
    internal IntPtr MaximumWorkingSetSize;
    internal IntPtr PagefileLimit;
    internal IntPtr TimeLimit;
}
internal class System.IdentityModel.Reference : object {
    public string DigestMethod { get; public set; }
    public XmlDictionaryString DigestMethodDictionaryString { get; public set; }
    public string Id { get; public set; }
    public SignatureResourcePool ResourcePool { get; public set; }
    public TransformChain TransformChain { get; }
    public int TransformCount { get; }
    public string Type { get; public set; }
    public string Uri { get; public set; }
    public bool Verified { get; }
    public Reference(DictionaryManager dictionaryManager);
    public Reference(DictionaryManager dictionaryManager, string uri);
    public Reference(DictionaryManager dictionaryManager, string uri, object resolvedXmlSource);
    public string get_DigestMethod();
    public void set_DigestMethod(string value);
    public XmlDictionaryString get_DigestMethodDictionaryString();
    public void set_DigestMethodDictionaryString(XmlDictionaryString value);
    public string get_Id();
    public void set_Id(string value);
    public SignatureResourcePool get_ResourcePool();
    public void set_ResourcePool(SignatureResourcePool value);
    public TransformChain get_TransformChain();
    public int get_TransformCount();
    public string get_Type();
    public void set_Type(string value);
    public string get_Uri();
    public void set_Uri(string value);
    public bool get_Verified();
    public void AddTransform(Transform transform);
    public void EnsureDigestValidity(string id, Byte[] computedDigest);
    public void EnsureDigestValidity(string id, object resolvedXmlSource);
    public bool EnsureDigestValidityIfIdMatches(string id, Byte[] computedDigest);
    public bool EnsureDigestValidityIfIdMatches(string id, object resolvedXmlSource);
    public bool IsStrTranform();
    public string ExtractReferredId();
    public bool CheckDigest();
    public void ComputeAndSetDigest();
    public Byte[] ComputeDigest();
    public Byte[] GetDigestValue();
    public void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager);
    public void SetResolvedXmlSource(object resolvedXmlSource);
    public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
public abstract class System.IdentityModel.RequestException : Exception {
    protected RequestException(string message);
    protected RequestException(string message, Exception innerException);
    protected RequestException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.RequestFailedException : RequestException {
    public RequestFailedException(string message);
    public RequestFailedException(string message, Exception innerException);
    protected RequestFailedException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.RijndaelCryptoServiceProvider : Rijndael {
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
public class System.IdentityModel.RsaEncryptionCookieTransform : CookieTransform {
    public RSA EncryptionKey { get; public set; }
    protected ReadOnlyCollection`1<RSA> DecryptionKeys { get; }
    public string HashName { get; public set; }
    public RsaEncryptionCookieTransform(RSA key);
    public RsaEncryptionCookieTransform(X509Certificate2 certificate);
    public virtual RSA get_EncryptionKey();
    public virtual void set_EncryptionKey(RSA value);
    protected virtual ReadOnlyCollection`1<RSA> get_DecryptionKeys();
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] Decode(Byte[] encoded);
    public virtual Byte[] Encode(Byte[] value);
}
public class System.IdentityModel.RsaSignatureCookieTransform : CookieTransform {
    public string HashName { get; public set; }
    public RSA SigningKey { get; public set; }
    protected ReadOnlyCollection`1<RSA> VerificationKeys { get; }
    public RsaSignatureCookieTransform(RSA key);
    public RsaSignatureCookieTransform(X509Certificate2 certificate);
    public string get_HashName();
    public void set_HashName(string value);
    public virtual RSA get_SigningKey();
    public virtual void set_SigningKey(RSA value);
    protected virtual ReadOnlyCollection`1<RSA> get_VerificationKeys();
    public virtual Byte[] Decode(Byte[] encoded);
    public virtual Byte[] Encode(Byte[] value);
}
[SecurityCriticalAttribute("1")]
internal class System.IdentityModel.SafeCertChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertChainHandle InvalidHandle { get; }
    internal static SafeCertChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute("1")]
internal class System.IdentityModel.SafeCertContextHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertContextHandle InvalidHandle { get; }
    internal static SafeCertContextHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute("1")]
internal class System.IdentityModel.SafeCertStoreHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeCertStoreHandle InvalidHandle { get; }
    public static SafeCertStoreHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SafeCloseHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeCloseHandle(IntPtr handle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SafeDeleteContext : SafeHandle {
    internal SSPIHandle _handle;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    internal static int InitializeSecurityContext(SafeFreeCredentials inCredentials, SafeDeleteContext& refContext, string targetName, SspiContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, SspiContextFlags& outFlags);
    internal static int AcceptSecurityContext(SafeFreeCredentials inCredentials, SafeDeleteContext& refContext, SspiContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, SspiContextFlags& outFlags);
    public static int ImpersonateSecurityContext(SafeDeleteContext context);
    public static int EncryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public static int DecryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    internal int GetSecurityContextToken(SafeCloseHandle& safeHandle);
    protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "1")]
internal static int InitializeSecurityContextW(SSPIHandle& credentialHandle, Void* inContextPtr, Byte* targetName, SspiContextFlags inFlags, int reservedI, Endianness endianness, SecurityBufferDescriptor inputBuffer, int reservedII, SSPIHandle& outContextPtr, SecurityBufferDescriptor outputBuffer, SspiContextFlags& attributes, Int64& timestamp);
    [ReliabilityContractAttribute("3", "1")]
internal static int AcceptSecurityContext(SSPIHandle& credentialHandle, Void* inContextPtr, SecurityBufferDescriptor inputBuffer, SspiContextFlags inFlags, Endianness endianness, SSPIHandle& outContextPtr, SecurityBufferDescriptor outputBuffer, SspiContextFlags& attributes, Int64& timestamp);
    [SuppressUnmanagedCodeSecurityAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static int DeleteSecurityContext(SSPIHandle& handlePtr);
    internal static int ImpersonateSecurityContext(SSPIHandle& handlePtr);
    [ReliabilityContractAttribute("3", "1")]
internal static int EncryptMessage(SSPIHandle& contextHandle, UInt32 qualityOfProtection, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    [ReliabilityContractAttribute("3", "1")]
internal static int DecryptMessage(SSPIHandle& contextHandle, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber, UInt32* qualityOfProtection);
}
internal class System.IdentityModel.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "2")]
internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "2")]
internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
    protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "1")]
internal static int QueryContextAttributesW(SSPIHandle& contextHandle, ContextAttribute attribute, Void* buffer);
    internal static int EnumerateSecurityPackagesW(Int32& pkgnum, SafeFreeContextBuffer& handle);
}
internal class System.IdentityModel.SafeFreeCredentials : SafeHandle {
    internal SSPIHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, AuthIdentityEx& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireDefaultCredential(string package, CredentialUse intent, AuthIdentityEx& authIdentity, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SecureCredential& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, IntPtr& ppAuthIdentity, SafeFreeCredentials& outCredential);
    protected virtual bool ReleaseHandle();
    internal static int AcquireCredentialsHandleW(string principal, string moduleName, int usage, Void* logonID, AuthIdentityEx& authdata, Void* keyCallback, Void* keyArgument, SSPIHandle& handlePtr, Int64& timeStamp);
    internal static int AcquireCredentialsHandleW(string principal, string moduleName, int usage, Void* logonID, IntPtr zero, Void* keyCallback, Void* keyArgument, SSPIHandle& handlePtr, Int64& timeStamp);
    internal static int AcquireCredentialsHandleW(string principal, string moduleName, int usage, Void* logonID, SecureCredential& authData, Void* keyCallback, Void* keyArgument, SSPIHandle& handlePtr, Int64& timeStamp);
    [SuppressUnmanagedCodeSecurityAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static int FreeCredentialsHandle(SSPIHandle& handlePtr);
}
[SecurityCriticalAttribute("1")]
internal class System.IdentityModel.SafeHGlobalHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeHGlobalHandle InvalidHandle { get; }
    protected virtual bool ReleaseHandle();
    public static SafeHGlobalHandle get_InvalidHandle();
    public static SafeHGlobalHandle AllocHGlobal(string s);
    public static SafeHGlobalHandle AllocHGlobal(Byte[] bytes);
    public static SafeHGlobalHandle AllocHGlobal(UInt32 cb);
    public static SafeHGlobalHandle AllocHGlobal(int cb);
}
internal class System.IdentityModel.SafeKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeKeyHandle InvalidHandle { get; }
    internal static SafeKeyHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    internal static SafeKeyHandle SafeCryptImportKey(SafeProvHandle provHandle, Void* pbDataPtr, int cbData);
}
internal class System.IdentityModel.SafeLsaLogonProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLsaLogonProcessHandle InvalidHandle { get; }
    internal SafeLsaLogonProcessHandle(IntPtr handle);
    internal static SafeLsaLogonProcessHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SafeLsaReturnBufferHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLsaReturnBufferHandle InvalidHandle { get; }
    internal SafeLsaReturnBufferHandle(IntPtr handle);
    internal static SafeLsaReturnBufferHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeProvHandle InvalidHandle { get; }
    internal static SafeProvHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.IdentityModel.SamlDelegatingWriter : XmlDictionaryWriter {
    public WriteState WriteState { get; }
    public SamlDelegatingWriter(XmlDictionaryWriter innerWriter, Stream canonicalStream, ICanonicalWriterEndRootElementCallback callback, IXmlDictionary dictionary);
    public virtual void Close();
    public virtual void Flush();
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteAttributes(XmlReader reader, bool defattr);
    public virtual void WriteBase64(Byte[] buffer, int index, int count);
    public virtual void WriteBinHex(Byte[] buffer, int index, int count);
    public virtual void WriteCData(string text);
    public virtual void WriteCharEntity(char ch);
    public virtual void WriteChars(Char[] buffer, int index, int count);
    public virtual void WriteComment(string text);
    public virtual void WriteDocType(string name, string pubid, string sysid, string subset);
    public virtual void WriteEndAttribute();
    public virtual void WriteEndDocument();
    public virtual void WriteEndElement();
    public virtual void WriteEntityRef(string name);
    public virtual void WriteFullEndElement();
    public virtual void WriteName(string name);
    public virtual void WriteNmToken(string name);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteNode(XPathNavigator navigator, bool defattr);
    public virtual void WriteProcessingInstruction(string name, string text);
    public virtual void WriteQualifiedName(string localName, string ns);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteRaw(Char[] buffer, int index, int count);
    public virtual void WriteRaw(string data);
    public virtual void WriteStartAttribute(string prefix, string localName, string ns);
    public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void WriteStartDocument();
    public virtual void WriteStartDocument(bool standalone);
    public virtual void WriteStartElement(string prefix, string localName, string ns);
    public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual WriteState get_WriteState();
    public virtual void WriteString(string text);
    public virtual void WriteString(XmlDictionaryString value);
    public virtual void WriteSurrogateCharEntity(char lowChar, char highChar);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(object value);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual void WriteValue(UniqueId value);
    public virtual void WriteValue(XmlDictionaryString value);
    public virtual void WriteWhitespace(string ws);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
    public virtual string LookupPrefix(string ns);
}
internal class System.IdentityModel.SamlDictionary : object {
    public XmlDictionaryString Access;
    public XmlDictionaryString AccessDecision;
    public XmlDictionaryString Action;
    public XmlDictionaryString Advice;
    public XmlDictionaryString Assertion;
    public XmlDictionaryString AssertionId;
    public XmlDictionaryString AssertionIdReference;
    public XmlDictionaryString Attribute;
    public XmlDictionaryString AttributeName;
    public XmlDictionaryString AttributeNamespace;
    public XmlDictionaryString AttributeStatement;
    public XmlDictionaryString AttributeValue;
    public XmlDictionaryString Audience;
    public XmlDictionaryString AudienceRestrictionCondition;
    public XmlDictionaryString AuthenticationInstant;
    public XmlDictionaryString AuthenticationMethod;
    public XmlDictionaryString AuthenticationStatement;
    public XmlDictionaryString AuthorityBinding;
    public XmlDictionaryString AuthorityKind;
    public XmlDictionaryString AuthorizationDecisionStatement;
    public XmlDictionaryString Binding;
    public XmlDictionaryString Condition;
    public XmlDictionaryString Conditions;
    public XmlDictionaryString Decision;
    public XmlDictionaryString DoNotCacheCondition;
    public XmlDictionaryString Evidence;
    public XmlDictionaryString IssueInstant;
    public XmlDictionaryString Issuer;
    public XmlDictionaryString Location;
    public XmlDictionaryString MajorVersion;
    public XmlDictionaryString MinorVersion;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString NameIdentifier;
    public XmlDictionaryString NameIdentifierFormat;
    public XmlDictionaryString NameIdentifierNameQualifier;
    public XmlDictionaryString ActionNamespaceAttribute;
    public XmlDictionaryString NotBefore;
    public XmlDictionaryString NotOnOrAfter;
    public XmlDictionaryString PreferredPrefix;
    public XmlDictionaryString Statement;
    public XmlDictionaryString Subject;
    public XmlDictionaryString SubjectConfirmation;
    public XmlDictionaryString SubjectConfirmationData;
    public XmlDictionaryString SubjectConfirmationMethod;
    public XmlDictionaryString HolderOfKey;
    public XmlDictionaryString SenderVouches;
    public XmlDictionaryString SubjectLocality;
    public XmlDictionaryString SubjectLocalityDNSAddress;
    public XmlDictionaryString SubjectLocalityIPAddress;
    public XmlDictionaryString SubjectStatement;
    public XmlDictionaryString UnspecifiedAuthenticationMethod;
    public XmlDictionaryString NamespaceAttributePrefix;
    public XmlDictionaryString Resource;
    public XmlDictionaryString UserName;
    public XmlDictionaryString UserNameNamespace;
    public XmlDictionaryString EmailName;
    public XmlDictionaryString EmailNamespace;
    public SamlDictionary(IdentityModelDictionary dictionary);
    public SamlDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SamlStrings : object {
    public static string Access;
    public static string AccessDecision;
    public static string Action;
    public static string Advice;
    public static string Assertion;
    public static string AssertionId;
    public static string AssertionIdReference;
    public static string Attribute;
    public static string AttributeName;
    public static string AttributeNamespace;
    public static string AttributeStatement;
    public static string AttributeValue;
    public static string Audience;
    public static string AudienceRestrictionCondition;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string AuthenticationStatement;
    public static string AuthorityBinding;
    public static string AuthorityKind;
    public static string AuthorizationDecisionStatement;
    public static string Binding;
    public static string Condition;
    public static string Conditions;
    public static string Decision;
    public static string DoNotCacheCondition;
    public static string Evidence;
    public static string IssueInstant;
    public static string Issuer;
    public static string Location;
    public static string MajorVersion;
    public static string MinorVersion;
    public static string Namespace;
    public static string NameIdentifier;
    public static string NameIdentifierFormat;
    public static string NameIdentifierNameQualifier;
    public static string ActionNamespaceAttribute;
    public static string NotBefore;
    public static string NotOnOrAfter;
    public static string PreferredPrefix;
    public static string Statement;
    public static string Subject;
    public static string SubjectConfirmation;
    public static string SubjectConfirmationData;
    public static string SubjectConfirmationMethod;
    public static string HolderOfKey;
    public static string SenderVouches;
    public static string SubjectLocality;
    public static string SubjectLocalityDNSAddress;
    public static string SubjectLocalityIPAddress;
    public static string SubjectStatement;
    public static string UnspecifiedAuthenticationMethod;
    public static string NamespaceAttributePrefix;
    public static string Resource;
    public static string UserName;
    public static string UserNameNamespace;
    public static string EmailName;
    public static string EmailNamespace;
}
internal enum System.IdentityModel.SchProtocols : Enum {
    public int value__;
    public static SchProtocols Zero;
    public static SchProtocols PctClient;
    public static SchProtocols PctServer;
    public static SchProtocols Pct;
    public static SchProtocols Ssl2Client;
    public static SchProtocols Ssl2Server;
    public static SchProtocols Ssl2;
    public static SchProtocols Ssl3Client;
    public static SchProtocols Ssl3Server;
    public static SchProtocols Ssl3;
    public static SchProtocols TlsClient;
    public static SchProtocols TlsServer;
    public static SchProtocols Tls;
    public static SchProtocols Ssl3Tls;
    public static SchProtocols Tls11Client;
    public static SchProtocols Tls11Server;
    public static SchProtocols Tls11;
    public static SchProtocols Tls12Client;
    public static SchProtocols Tls12Server;
    public static SchProtocols Tls12;
    public static SchProtocols Tls13Client;
    public static SchProtocols Tls13Server;
    public static SchProtocols Tls13;
    public static SchProtocols UniClient;
    public static SchProtocols UniServer;
    public static SchProtocols Unified;
    public static SchProtocols ClientMask;
    public static SchProtocols ServerMask;
}
public class System.IdentityModel.Scope : object {
    public string AppliesToAddress { get; public set; }
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public string ReplyToAddress { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public bool SymmetricKeyEncryptionRequired { get; public set; }
    public bool TokenEncryptionRequired { get; public set; }
    public Dictionary`2<string, object> Properties { get; }
    public Scope(string appliesToAddress);
    public Scope(string appliesToAddress, SigningCredentials signingCredentials);
    public Scope(string appliesToAddress, EncryptingCredentials encryptingCredentials);
    public Scope(string appliesToAddress, SigningCredentials signingCredentials, EncryptingCredentials encryptingCredentials);
    public virtual string get_AppliesToAddress();
    public virtual void set_AppliesToAddress(string value);
    public virtual EncryptingCredentials get_EncryptingCredentials();
    public virtual void set_EncryptingCredentials(EncryptingCredentials value);
    public virtual string get_ReplyToAddress();
    public virtual void set_ReplyToAddress(string value);
    public virtual SigningCredentials get_SigningCredentials();
    public virtual void set_SigningCredentials(SigningCredentials value);
    public virtual bool get_SymmetricKeyEncryptionRequired();
    public virtual void set_SymmetricKeyEncryptionRequired(bool value);
    public virtual bool get_TokenEncryptionRequired();
    public virtual void set_TokenEncryptionRequired(bool value);
    public virtual Dictionary`2<string, object> get_Properties();
}
internal class System.IdentityModel.SEC_WINNT_AUTH_IDENTITY_EX : object {
    public UInt32 Version;
    public UInt32 Length;
    public string User;
    public UInt32 UserLength;
    public string Domain;
    public UInt32 DomainLength;
    public string Password;
    public UInt32 PasswordLength;
    public UInt32 Flags;
    public string PackageList;
    public UInt32 PackageListLength;
}
internal class System.IdentityModel.SecPkgContext_SessionKey : ValueType {
    internal UInt32 SessionKeyLength;
    internal IntPtr Sessionkey;
    internal static int Size;
    internal static int SessionkeyOffset;
    private static SecPkgContext_SessionKey();
}
internal class System.IdentityModel.SecSizes : object {
    public int MaxToken;
    public int MaxSignature;
    public int BlockSize;
    public int SecurityTrailer;
    public static int SizeOf;
    internal SecSizes(Byte[] memory);
    private static SecSizes();
}
internal class System.IdentityModel.SecureConversationDec2005Dictionary : SecureConversationDictionary {
    public SecureConversationDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationDec2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecureConversationDec2005Strings : object {
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string Instance;
}
internal class System.IdentityModel.SecureConversationDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DerivedKeyToken;
    public XmlDictionaryString Nonce;
    public XmlDictionaryString Length;
    public XmlDictionaryString SecurityContextToken;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlDictionaryString Generation;
    public XmlDictionaryString Label;
    public XmlDictionaryString Offset;
    public XmlDictionaryString Properties;
    public XmlDictionaryString Identifier;
    public XmlDictionaryString Cookie;
    public XmlDictionaryString RenewNeededFaultCode;
    public XmlDictionaryString BadContextTokenFaultCode;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString DerivedKeyTokenType;
    public XmlDictionaryString SecurityContextTokenType;
    public XmlDictionaryString SecurityContextTokenReferenceValueType;
    public XmlDictionaryString RequestSecurityContextIssuance;
    public XmlDictionaryString RequestSecurityContextIssuanceResponse;
    public XmlDictionaryString RequestSecurityContextRenew;
    public XmlDictionaryString RequestSecurityContextRenewResponse;
    public XmlDictionaryString RequestSecurityContextClose;
    public XmlDictionaryString RequestSecurityContextCloseResponse;
    public XmlDictionaryString Instance;
    public SecureConversationDictionary(IdentityModelDictionary dictionary);
    public SecureConversationDictionary(IXmlDictionary dictionary);
}
internal class System.IdentityModel.SecureConversationFeb2005Dictionary : SecureConversationDictionary {
    public SecureConversationFeb2005Dictionary(IdentityModelDictionary dictionary);
    public SecureConversationFeb2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecureConversationFeb2005Strings : object {
    public static string Namespace;
    public static string DerivedKeyToken;
    public static string Nonce;
    public static string Length;
    public static string SecurityContextToken;
    public static string AlgorithmAttribute;
    public static string Generation;
    public static string Label;
    public static string Offset;
    public static string Properties;
    public static string Identifier;
    public static string Cookie;
    public static string RenewNeededFaultCode;
    public static string BadContextTokenFaultCode;
    public static string Prefix;
    public static string DerivedKeyTokenType;
    public static string SecurityContextTokenType;
    public static string SecurityContextTokenReferenceValueType;
    public static string RequestSecurityContextIssuance;
    public static string RequestSecurityContextIssuanceResponse;
    public static string RequestSecurityContextRenew;
    public static string RequestSecurityContextRenewResponse;
    public static string RequestSecurityContextClose;
    public static string RequestSecurityContextCloseResponse;
}
internal static class System.IdentityModel.SecureConversationStrings : object {
}
internal class System.IdentityModel.SecureCredential : ValueType {
    public static int CurrentVersion;
    public int version;
    public int cCreds;
    public IntPtr certContextArray;
    private IntPtr rootStore;
    public int cMappers;
    private IntPtr phMappers;
    public int cSupportedAlgs;
    private IntPtr palgSupportedAlgs;
    public SchProtocols grbitEnabledProtocols;
    public int dwMinimumCipherStrength;
    public int dwMaximumCipherStrength;
    public int dwSessionLifespan;
    public Flags dwFlags;
    public int reserved;
    public SecureCredential(int version, X509Certificate2 certificate, Flags flags, SchProtocols protocols);
}
internal enum System.IdentityModel.SECURITY_IMPERSONATION_LEVEL : Enum {
    public int value__;
    public static SECURITY_IMPERSONATION_LEVEL Anonymous;
    public static SECURITY_IMPERSONATION_LEVEL Identification;
    public static SECURITY_IMPERSONATION_LEVEL Impersonation;
    public static SECURITY_IMPERSONATION_LEVEL Delegation;
}
internal class System.IdentityModel.Security.WSTrust : SerializerEntries {
    public TrustDictionary SerializerDictionary { get; }
    public WSTrust(KeyInfoSerializer securityTokenSerializer, TrustDictionary serializerDictionary);
    public TrustDictionary get_SerializerDictionary();
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> keyIdentifierClauseEntries);
    protected static bool CheckElement(XmlElement element, string name, string ns, String& value);
}
internal class System.IdentityModel.SecurityAlgorithmDec2005Dictionary : object {
    public XmlDictionaryString Psha1KeyDerivationDec2005;
    public SecurityAlgorithmDec2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDec2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecurityAlgorithmDec2005Strings : object {
    public static string Psha1KeyDerivationDec2005;
}
internal class System.IdentityModel.SecurityAlgorithmDictionary : object {
    public XmlDictionaryString Aes128Encryption;
    public XmlDictionaryString Aes128KeyWrap;
    public XmlDictionaryString Aes192Encryption;
    public XmlDictionaryString Aes192KeyWrap;
    public XmlDictionaryString Aes256Encryption;
    public XmlDictionaryString Aes256KeyWrap;
    public XmlDictionaryString DesEncryption;
    public XmlDictionaryString DsaSha1Signature;
    public XmlDictionaryString ExclusiveC14n;
    public XmlDictionaryString ExclusiveC14nWithComments;
    public XmlDictionaryString HmacSha1Signature;
    public XmlDictionaryString HmacSha256Signature;
    public XmlDictionaryString Psha1KeyDerivation;
    public XmlDictionaryString Ripemd160Digest;
    public XmlDictionaryString RsaOaepKeyWrap;
    public XmlDictionaryString RsaSha1Signature;
    public XmlDictionaryString RsaSha256Signature;
    public XmlDictionaryString RsaV15KeyWrap;
    public XmlDictionaryString Sha1Digest;
    public XmlDictionaryString Sha256Digest;
    public XmlDictionaryString Sha512Digest;
    public XmlDictionaryString TripleDesEncryption;
    public XmlDictionaryString TripleDesKeyWrap;
    public XmlDictionaryString TlsSspiKeyWrap;
    public XmlDictionaryString WindowsSspiKeyWrap;
    public SecurityAlgorithmDictionary(IdentityModelDictionary dictionary);
    public SecurityAlgorithmDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecurityAlgorithmStrings : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    public static string StrTransform;
}
internal class System.IdentityModel.SecurityBuffer : object {
    public int size;
    public BufferType type;
    public Byte[] token;
    public int offset;
    public SafeHandle unmanagedToken;
    public SecurityBuffer(Byte[] data, int offset, int size, BufferType tokentype);
    public SecurityBuffer(Byte[] data, BufferType tokentype);
    public SecurityBuffer(int size, BufferType tokentype);
    public SecurityBuffer(ChannelBinding channelBinding);
}
internal class System.IdentityModel.SecurityBufferDescriptor : object {
    public int Version;
    public int Count;
    public Void* UnmanagedPointer;
    public SecurityBufferDescriptor(int count);
}
internal class System.IdentityModel.SecurityBufferStruct : ValueType {
    public int count;
    public BufferType type;
    public IntPtr token;
    public static int Size;
    private static SecurityBufferStruct();
}
internal class System.IdentityModel.SecurityJan2004Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString NonceElement;
    public XmlDictionaryString PasswordElement;
    public XmlDictionaryString PasswordTextName;
    public XmlDictionaryString UserNameElement;
    public XmlDictionaryString UserNameTokenElement;
    public XmlDictionaryString BinarySecurityToken;
    public XmlDictionaryString EncodingType;
    public XmlDictionaryString Reference;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyIdentifier;
    public XmlDictionaryString EncodingTypeValueBase64Binary;
    public XmlDictionaryString EncodingTypeValueHexBinary;
    public XmlDictionaryString EncodingTypeValueText;
    public XmlDictionaryString X509SKIValueType;
    public XmlDictionaryString KerberosTokenTypeGSS;
    public XmlDictionaryString KerberosTokenType1510;
    public XmlDictionaryString SamlAssertionIdValueType;
    public XmlDictionaryString SamlAssertion;
    public XmlDictionaryString SamlUri;
    public XmlDictionaryString RelAssertionValueType;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString InvalidSecurityTokenFaultCode;
    public XmlDictionaryString InvalidSecurityFaultCode;
    public XmlDictionaryString SecurityTokenReference;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Security;
    public XmlDictionaryString ValueType;
    public XmlDictionaryString TypeAttribute;
    public XmlDictionaryString KerberosHashValueType;
    public SecurityJan2004Dictionary(IdentityModelDictionary dictionary);
    public SecurityJan2004Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecurityJan2004Strings : object {
    public static string Prefix;
    public static string NonceElement;
    public static string PasswordElement;
    public static string PasswordTextName;
    public static string UserNameElement;
    public static string UserNameTokenElement;
    public static string BinarySecurityToken;
    public static string EncodingType;
    public static string Reference;
    public static string URI;
    public static string KeyIdentifier;
    public static string EncodingTypeValueBase64Binary;
    public static string EncodingTypeValueHexBinary;
    public static string EncodingTypeValueText;
    public static string X509SKIValueType;
    public static string KerberosTokenTypeGSS;
    public static string KerberosTokenType1510;
    public static string SamlAssertionIdValueType;
    public static string SamlAssertion;
    public static string SamlUri;
    public static string RelAssertionValueType;
    public static string FailedAuthenticationFaultCode;
    public static string InvalidSecurityTokenFaultCode;
    public static string InvalidSecurityFaultCode;
    public static string SecurityTokenReference;
    public static string Namespace;
    public static string Security;
    public static string ValueType;
    public static string TypeAttribute;
    public static string KerberosHashValueType;
    public static string SecurityProfileNamespace;
    public static string X509TokenProfileNamespace;
    public static string UPTokenProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string KerberosTokenProfileNamespace;
    public static string UPTokenType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
internal enum System.IdentityModel.SecurityLogonType : Enum {
    public int value__;
    public static SecurityLogonType Interactive;
    public static SecurityLogonType Network;
    public static SecurityLogonType Batch;
    public static SecurityLogonType Service;
    public static SecurityLogonType Proxy;
    public static SecurityLogonType Unlock;
}
public class System.IdentityModel.SecurityMessageSerializationException : SystemException {
    public SecurityMessageSerializationException(string message);
    public SecurityMessageSerializationException(string message, Exception innerException);
    protected SecurityMessageSerializationException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
    internal static int Size;
    internal static int NameOffest;
    private static SecurityPackageInfo();
}
internal class System.IdentityModel.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
}
internal class System.IdentityModel.SecuritySessionKeyClass : object {
    internal Byte[] SessionKey { get; }
    internal SecuritySessionKeyClass(SafeHandle safeHandle, int sessionKeyLength);
    internal Byte[] get_SessionKey();
}
internal enum System.IdentityModel.SecurityStatus : Enum {
    public int value__;
    public static SecurityStatus OK;
    public static SecurityStatus OutOfMemory;
    public static SecurityStatus InvalidHandle;
    public static SecurityStatus Unsupported;
    public static SecurityStatus TargetUnknown;
    public static SecurityStatus InternalError;
    public static SecurityStatus PackageNotFound;
    public static SecurityStatus NotOwner;
    public static SecurityStatus CannotInstall;
    public static SecurityStatus InvalidToken;
    public static SecurityStatus LogonDenied;
    public static SecurityStatus UnknownCredential;
    public static SecurityStatus NoCredentials;
    public static SecurityStatus MessageAltered;
    public static SecurityStatus ContinueNeeded;
    public static SecurityStatus CompleteNeeded;
    public static SecurityStatus CompAndContinue;
    public static SecurityStatus ContextExpired;
    public static SecurityStatus IncompleteMessage;
    public static SecurityStatus IncompleteCred;
    public static SecurityStatus BufferNotEnough;
    public static SecurityStatus WrongPrincipal;
    public static SecurityStatus UntrustedRoot;
    public static SecurityStatus UnknownCertificate;
    public static SecurityStatus CredentialsNeeded;
    public static SecurityStatus Renegotiate;
}
public abstract class System.IdentityModel.SecurityTokenService : object {
    public SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }
    public ClaimsPrincipal Principal { get; public set; }
    public RequestSecurityToken Request { get; public set; }
    public Scope Scope { get; public set; }
    protected SecurityTokenDescriptor SecurityTokenDescriptor { get; protected set; }
    protected SecurityTokenService(SecurityTokenServiceConfiguration securityTokenServiceConfiguration);
    public virtual IAsyncResult BeginCancel(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state);
    protected virtual IAsyncResult BeginGetScope(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginIssue(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginRenew(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginValidate(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state);
    public virtual RequestSecurityTokenResponse Cancel(ClaimsPrincipal principal, RequestSecurityToken request);
    protected virtual SecurityTokenDescriptor CreateSecurityTokenDescriptor(RequestSecurityToken request, Scope scope);
    protected virtual string GetIssuerName();
    protected virtual ProofDescriptor GetProofToken(RequestSecurityToken request, Scope scope);
    protected virtual EncryptingCredentials GetRequestorProofEncryptingCredentials(RequestSecurityToken request);
    protected virtual Lifetime GetTokenLifetime(Lifetime requestLifetime);
    protected virtual RequestSecurityTokenResponse GetResponse(RequestSecurityToken request, SecurityTokenDescriptor tokenDescriptor);
    public virtual RequestSecurityTokenResponse EndCancel(IAsyncResult result);
    protected virtual Scope EndGetScope(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndIssue(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndRenew(IAsyncResult result);
    public virtual RequestSecurityTokenResponse EndValidate(IAsyncResult result);
    protected abstract virtual Scope GetScope(ClaimsPrincipal principal, RequestSecurityToken request);
    protected abstract virtual ClaimsIdentity GetOutputClaimsIdentity(ClaimsPrincipal principal, RequestSecurityToken request, Scope scope);
    protected virtual IAsyncResult BeginGetOutputClaimsIdentity(ClaimsPrincipal principal, RequestSecurityToken request, Scope scope, AsyncCallback callback, object state);
    protected virtual ClaimsIdentity EndGetOutputClaimsIdentity(IAsyncResult result);
    public virtual RequestSecurityTokenResponse Issue(ClaimsPrincipal principal, RequestSecurityToken request);
    protected virtual SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType);
    public SecurityTokenServiceConfiguration get_SecurityTokenServiceConfiguration();
    public ClaimsPrincipal get_Principal();
    public void set_Principal(ClaimsPrincipal value);
    public RequestSecurityToken get_Request();
    public void set_Request(RequestSecurityToken value);
    [CompilerGeneratedAttribute]
public Scope get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(Scope value);
    protected SecurityTokenDescriptor get_SecurityTokenDescriptor();
    protected void set_SecurityTokenDescriptor(SecurityTokenDescriptor value);
    public virtual RequestSecurityTokenResponse Renew(ClaimsPrincipal principal, RequestSecurityToken request);
    public virtual RequestSecurityTokenResponse Validate(ClaimsPrincipal principal, RequestSecurityToken request);
    protected virtual void ValidateRequest(RequestSecurityToken request);
}
internal class System.IdentityModel.SecurityUniqueId : object {
    public string Value { get; }
    private static SecurityUniqueId();
    public static SecurityUniqueId Create();
    public static SecurityUniqueId Create(string prefix);
    public string get_Value();
}
internal static class System.IdentityModel.SecurityUtils : object {
    public static string Identities;
    public static int WindowsVistaMajorNumber;
    public static string AuthTypeNTLM;
    public static string AuthTypeNegotiate;
    public static string AuthTypeKerberos;
    public static string AuthTypeAnonymous;
    public static string AuthTypeCertMap;
    public static string AuthTypeBasic;
    internal static IIdentity AnonymousIdentity { get; }
    public static DateTime MaxUtcDateTime { get; }
    public static DateTime MinUtcDateTime { get; }
    internal static bool RequiresFipsCompliance { get; }
    private static SecurityUtils();
    internal static IIdentity get_AnonymousIdentity();
    public static DateTime get_MaxUtcDateTime();
    public static DateTime get_MinUtcDateTime();
    internal static IIdentity CreateIdentity(string name, string authenticationType);
    internal static IIdentity CreateIdentity(string name);
    internal static Byte[] CloneBuffer(Byte[] buffer);
    internal static Byte[] CloneBuffer(Byte[] buffer, int offset, int len);
    internal static ReadOnlyCollection`1<SecurityKey> CreateSymmetricSecurityKeys(Byte[] key);
    internal static Byte[] EncryptKey(SecurityToken wrappingToken, string encryptionMethod, Byte[] keyToWrap);
    internal static bool MatchesBuffer(Byte[] src, Byte[] dst);
    internal static bool MatchesBuffer(Byte[] src, int srcOffset, Byte[] dst, int dstOffset);
    internal static string GetCertificateId(X509Certificate2 certificate);
    [SecuritySafeCriticalAttribute]
internal static void ResetCertificate(X509Certificate2 certificate);
    internal static bool IsCurrentlyTimeEffective(DateTime effectiveTime, DateTime expirationTime, TimeSpan maxClockSkew);
    [SecuritySafeCriticalAttribute]
internal static bool get_RequiresFipsCompliance();
    internal static bool CollectionContainsCertificate(X509Certificate2Collection collection, X509Certificate2 certificate);
    internal static AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies);
    internal static string ClaimSetToString(ClaimSet claimSet);
    internal static void ResetAllCertificates(X509Certificate2Collection certificates);
    internal static Byte[] ReadContentAsBase64(XmlDictionaryReader reader, long maxBufferSize);
    internal static Byte[] DecryptKey(SecurityToken unwrappingToken, string encryptionMethod, Byte[] wrappedKey, SecurityKey& unwrappingSecurityKey);
    public static bool TryCreateX509CertificateFromRawData(Byte[] rawData, X509Certificate2& certificate);
    internal static Byte[] DecodeHexString(string hexString);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet, DateTime expirationTime);
    internal static string GenerateId();
    internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token);
    internal static IIdentity CloneIdentityIfNecessary(IIdentity identity);
    [SecuritySafeCriticalAttribute]
internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid);
    [SecuritySafeCriticalAttribute]
internal static WindowsIdentity CloneWindowsIdentityIfNecessary(WindowsIdentity wid, string authenticationType);
    internal static ClaimSet CloneClaimSetIfNecessary(ClaimSet claimSet);
    internal static ReadOnlyCollection`1<ClaimSet> CloneClaimSetsIfNecessary(ReadOnlyCollection`1<ClaimSet> claimSets);
    internal static void DisposeClaimSetIfNecessary(ClaimSet claimSet);
    internal static void DisposeClaimSetsIfNecessary(ReadOnlyCollection`1<ClaimSet> claimSets);
    internal static ReadOnlyCollection`1<IAuthorizationPolicy> CloneAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static void DisposeAuthorizationPoliciesIfNecessary(ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public static void DisposeIfNecessary(IDisposable obj);
}
internal class System.IdentityModel.SecurityXXX2005Dictionary : object {
    public XmlDictionaryString Prefix;
    public XmlDictionaryString SignatureConfirmation;
    public XmlDictionaryString ValueAttribute;
    public XmlDictionaryString TokenTypeAttribute;
    public XmlDictionaryString ThumbprintSha1ValueType;
    public XmlDictionaryString EncryptedKeyTokenType;
    public XmlDictionaryString EncryptedKeyHashValueType;
    public XmlDictionaryString SamlTokenType;
    public XmlDictionaryString Saml20TokenType;
    public XmlDictionaryString Saml11AssertionValueType;
    public XmlDictionaryString EncryptedHeader;
    public XmlDictionaryString Namespace;
    public SecurityXXX2005Dictionary(IdentityModelDictionary dictionary);
    public SecurityXXX2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.SecurityXXX2005Strings : object {
    public static string Prefix;
    public static string SignatureConfirmation;
    public static string ValueAttribute;
    public static string TokenTypeAttribute;
    public static string ThumbprintSha1ValueType;
    public static string EncryptedKeyTokenType;
    public static string EncryptedKeyHashValueType;
    public static string SamlTokenType;
    public static string Saml20TokenType;
    public static string Saml11AssertionValueType;
    public static string EncryptedHeader;
    public static string Namespace;
    public static string SecurityProfileNamespace;
    public static string SamlTokenProfileNamespace;
    public static string X509TokenProfileNamespace;
}
public enum System.IdentityModel.Selectors.AudienceUriMode : Enum {
    public int value__;
    public static AudienceUriMode Never;
    public static AudienceUriMode Always;
    public static AudienceUriMode BearerKeyOnly;
}
public static class System.IdentityModel.Selectors.AudienceUriModeValidationHelper : object {
    public static bool IsDefined(AudienceUriMode validationMode);
    internal static void Validate(AudienceUriMode value);
}
public class System.IdentityModel.Selectors.CustomUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
    public CustomUserNameSecurityTokenAuthenticator(UserNamePasswordValidator validator);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password);
}
internal static class System.IdentityModel.Selectors.EmptySecurityTokenResolver : object {
    public static SecurityTokenResolver Instance { get; }
    private static EmptySecurityTokenResolver();
    public static SecurityTokenResolver get_Instance();
}
public class System.IdentityModel.Selectors.KerberosSecurityTokenAuthenticator : WindowsSecurityTokenAuthenticator {
    public KerberosSecurityTokenAuthenticator(bool includeWindowsGroups);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
}
public class System.IdentityModel.Selectors.KerberosSecurityTokenProvider : SecurityTokenProvider {
    public string ServicePrincipalName { get; }
    public TokenImpersonationLevel TokenImpersonationLevel { get; }
    public NetworkCredential NetworkCredential { get; }
    public KerberosSecurityTokenProvider(string servicePrincipalName);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel);
    public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential);
    public string get_ServicePrincipalName();
    public TokenImpersonationLevel get_TokenImpersonationLevel();
    public NetworkCredential get_NetworkCredential();
    internal SecurityToken GetToken(TimeSpan timeout, ChannelBinding channelbinding);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
public class System.IdentityModel.Selectors.RsaSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public AudienceUriMode AudienceUriMode { get; public set; }
    public IList`1<string> AllowedAudienceUris { get; }
    public SamlSecurityTokenAuthenticator(IList`1<SecurityTokenAuthenticator> supportingAuthenticators);
    public SamlSecurityTokenAuthenticator(IList`1<SecurityTokenAuthenticator> supportingAuthenticators, TimeSpan maxClockSkew);
    public AudienceUriMode get_AudienceUriMode();
    public void set_AudienceUriMode(AudienceUriMode value);
    public IList`1<string> get_AllowedAudienceUris();
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    protected virtual bool ValidateAudienceRestriction(SamlAudienceRestrictionCondition audienceRestrictionCondition);
    public virtual ClaimSet ResolveClaimSet(SecurityToken token);
    public virtual ClaimSet ResolveClaimSet(SecurityKeyIdentifier keyIdentifier);
    public virtual IIdentity ResolveIdentity(SecurityToken token);
    public virtual IIdentity ResolveIdentity(SecurityKeyIdentifier keyIdentifier);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenAuthenticator : object {
    public bool CanValidateToken(SecurityToken token);
    public ReadOnlyCollection`1<IAuthorizationPolicy> ValidateToken(SecurityToken token);
    protected abstract virtual bool CanValidateTokenCore(SecurityToken token);
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenManager : object {
    public abstract virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public abstract virtual SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
    public abstract virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenProvider : object {
    public bool SupportsTokenRenewal { get; }
    public bool SupportsTokenCancellation { get; }
    public virtual bool get_SupportsTokenRenewal();
    public virtual bool get_SupportsTokenCancellation();
    public SecurityToken GetToken(TimeSpan timeout);
    public IAsyncResult BeginGetToken(TimeSpan timeout, AsyncCallback callback, object state);
    public SecurityToken EndGetToken(IAsyncResult result);
    public SecurityToken RenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    public IAsyncResult BeginRenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state);
    public SecurityToken EndRenewToken(IAsyncResult result);
    public void CancelToken(TimeSpan timeout, SecurityToken token);
    public IAsyncResult BeginCancelToken(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state);
    public void EndCancelToken(IAsyncResult result);
    protected abstract virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual SecurityToken RenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed);
    protected virtual void CancelTokenCore(TimeSpan timeout, SecurityToken token);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    protected virtual IAsyncResult BeginRenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state);
    protected virtual SecurityToken EndRenewTokenCore(IAsyncResult result);
    protected virtual IAsyncResult BeginCancelTokenCore(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state);
    protected virtual void EndCancelTokenCore(IAsyncResult result);
}
public class System.IdentityModel.Selectors.SecurityTokenRequirement : object {
    public static string TokenTypeProperty { get; }
    public static string KeyUsageProperty { get; }
    public static string KeyTypeProperty { get; }
    public static string KeySizeProperty { get; }
    public static string RequireCryptographicTokenProperty { get; }
    public static string PeerAuthenticationMode { get; }
    public static string IsOptionalTokenProperty { get; }
    public string TokenType { get; public set; }
    internal bool IsOptionalToken { get; internal set; }
    public bool RequireCryptographicToken { get; public set; }
    public SecurityKeyUsage KeyUsage { get; public set; }
    public SecurityKeyType KeyType { get; public set; }
    public int KeySize { get; public set; }
    public IDictionary`2<string, object> Properties { get; }
    public static string get_TokenTypeProperty();
    public static string get_KeyUsageProperty();
    public static string get_KeyTypeProperty();
    public static string get_KeySizeProperty();
    public static string get_RequireCryptographicTokenProperty();
    public static string get_PeerAuthenticationMode();
    public static string get_IsOptionalTokenProperty();
    public string get_TokenType();
    public void set_TokenType(string value);
    internal bool get_IsOptionalToken();
    internal void set_IsOptionalToken(bool value);
    public bool get_RequireCryptographicToken();
    public void set_RequireCryptographicToken(bool value);
    public SecurityKeyUsage get_KeyUsage();
    public void set_KeyUsage(SecurityKeyUsage value);
    public SecurityKeyType get_KeyType();
    public void set_KeyType(SecurityKeyType value);
    public int get_KeySize();
    public void set_KeySize(int value);
    public IDictionary`2<string, object> get_Properties();
    public TValue GetProperty(string propertyName);
    public bool TryGetProperty(string propertyName, TValue& result);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenResolver : object {
    public SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier);
    public bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    public SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    public SecurityKey ResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
    protected abstract virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected abstract virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
    protected abstract virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    public static SecurityTokenResolver CreateDefaultSecurityTokenResolver(ReadOnlyCollection`1<SecurityToken> tokens, bool canMatchLocalId);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenSerializer : object {
    public bool CanReadToken(XmlReader reader);
    public bool CanWriteToken(SecurityToken token);
    public bool CanReadKeyIdentifier(XmlReader reader);
    public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier);
    public bool CanReadKeyIdentifierClause(XmlReader reader);
    public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
    public void WriteToken(XmlWriter writer, SecurityToken token);
    public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader);
    public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual bool CanReadTokenCore(XmlReader reader);
    protected abstract virtual bool CanWriteTokenCore(SecurityToken token);
    protected abstract virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected abstract virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected abstract virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected abstract virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected abstract virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected abstract virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
public abstract class System.IdentityModel.Selectors.SecurityTokenVersion : object {
    public abstract virtual ReadOnlyCollection`1<string> GetSecuritySpecifications();
}
public abstract class System.IdentityModel.Selectors.UserNamePasswordValidator : object {
    public static UserNamePasswordValidator None { get; }
    public static UserNamePasswordValidator get_None();
    public static UserNamePasswordValidator CreateMembershipProviderValidator(MembershipProvider provider);
    public abstract virtual void Validate(string userName, string password);
}
public abstract class System.IdentityModel.Selectors.UserNameSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    protected abstract virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password);
}
public class System.IdentityModel.Selectors.UserNameSecurityTokenProvider : SecurityTokenProvider {
    public UserNameSecurityTokenProvider(string userName, string password);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
}
public class System.IdentityModel.Selectors.WindowsSecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public WindowsSecurityTokenAuthenticator(bool includeWindowsGroups);
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
}
public class System.IdentityModel.Selectors.WindowsUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
    public WindowsUserNameSecurityTokenAuthenticator(bool includeWindowsGroups);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password);
}
internal class System.IdentityModel.Selectors.X509CertificateChain : object {
    public static UInt32 DefaultChainPolicyOID;
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public X509CertificateChain(bool useMachineContext);
    public X509CertificateChain(bool useMachineContext, UInt32 chainPolicyOID);
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    [SecuritySafeCriticalAttribute]
public bool Build(X509Certificate2 certificate);
}
internal class System.IdentityModel.Selectors.X509CertificateStore : object {
    [SecuritySafeCriticalAttribute]
public X509CertificateStore(StoreName storeName, StoreLocation storeLocation);
    [SecuritySafeCriticalAttribute]
public void Close();
    [SecuritySafeCriticalAttribute]
public void Open(OpenFlags openFlags);
    [SecuritySafeCriticalAttribute]
public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
}
public abstract class System.IdentityModel.Selectors.X509CertificateValidator : object {
    public static X509CertificateValidator None { get; }
    public static X509CertificateValidator PeerTrust { get; }
    public static X509CertificateValidator ChainTrust { get; }
    internal static X509CertificateValidator NTAuthChainTrust { get; }
    public static X509CertificateValidator PeerOrChainTrust { get; }
    public static X509CertificateValidator get_None();
    public static X509CertificateValidator get_PeerTrust();
    public static X509CertificateValidator get_ChainTrust();
    internal static X509CertificateValidator get_NTAuthChainTrust();
    public static X509CertificateValidator get_PeerOrChainTrust();
    public static X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public static X509CertificateValidator CreatePeerOrChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public abstract virtual void Validate(X509Certificate2 certificate);
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
}
public class System.IdentityModel.Selectors.X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
    public bool MapCertificateToWindowsAccount { get; }
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator);
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows);
    public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups);
    internal X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups, bool cloneHandle);
    public bool get_MapCertificateToWindowsAccount();
    protected virtual bool CanValidateTokenCore(SecurityToken token);
    protected virtual ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
    [SecuritySafeCriticalAttribute]
internal static WindowsIdentity KerberosCertificateLogon(X509Certificate2 certificate);
}
public class System.IdentityModel.Selectors.X509SecurityTokenProvider : SecurityTokenProvider {
    public X509Certificate2 Certificate { get; }
    public X509SecurityTokenProvider(X509Certificate2 certificate);
    public X509SecurityTokenProvider(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
    public X509Certificate2 get_Certificate();
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    public sealed virtual void Dispose();
}
internal class System.IdentityModel.SID_AND_ATTRIBUTES : ValueType {
    internal IntPtr Sid;
    internal UInt32 Attributes;
    internal static long SizeOf;
    private static SID_AND_ATTRIBUTES();
}
internal class System.IdentityModel.Signature : object {
    public string Id { get; public set; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public SignedInfo SignedInfo { get; }
    public ISignatureValueSecurityElement SignatureValue { get; }
    public Signature(SignedXml signedXml, SignedInfo signedInfo);
    public string get_Id();
    public void set_Id(string value);
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public SignedInfo get_SignedInfo();
    public ISignatureValueSecurityElement get_SignatureValue();
    public Byte[] GetSignatureBytes();
    public void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager);
    public void SetSignatureValue(Byte[] signatureValue);
    public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.SignatureResourcePool : object {
    public Char[] TakeBase64Buffer();
    public CanonicalizationDriver TakeCanonicalizationDriver();
    public Byte[] TakeEncodingBuffer();
    public HashAlgorithm TakeHashAlgorithm(string algorithm);
    public HashStream TakeHashStream(HashAlgorithm hash);
    public HashStream TakeHashStream(string algorithm);
    public XmlDictionaryWriter TakeUtf8Writer();
}
internal abstract class System.IdentityModel.SignatureTargetIdManager : object {
    public string DefaultIdNamespacePrefix { get; }
    public string DefaultIdNamespaceUri { get; }
    public abstract virtual string get_DefaultIdNamespacePrefix();
    public abstract virtual string get_DefaultIdNamespaceUri();
    public abstract virtual string ExtractId(XmlDictionaryReader reader);
    public abstract virtual void WriteIdAttribute(XmlDictionaryWriter writer, string id);
}
public class System.IdentityModel.SignatureVerificationFailedException : SecurityTokenException {
    public SignatureVerificationFailedException(string message);
    public SignatureVerificationFailedException(string message, Exception inner);
    protected SignatureVerificationFailedException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.IdentityModel.SignedInfo : object {
    protected DictionaryManager DictionaryManager { get; }
    protected MemoryStream CanonicalStream { get; protected set; }
    protected bool SendSide { get; protected set; }
    public ISignatureReaderProvider ReaderProvider { get; public set; }
    public object SignatureReaderProviderCallbackContext { get; public set; }
    public string CanonicalizationMethod { get; public set; }
    unknown XmlDictionaryString CanonicalizationMethodDictionaryString {public set; }
    public bool HasId { get; }
    public string Id { get; public set; }
    public int ReferenceCount { get; }
    public string SignatureMethod { get; public set; }
    public XmlDictionaryString SignatureMethodDictionaryString { get; public set; }
    public SignatureResourcePool ResourcePool { get; public set; }
    protected SignedInfo(DictionaryManager dictionaryManager);
    protected DictionaryManager get_DictionaryManager();
    protected MemoryStream get_CanonicalStream();
    protected void set_CanonicalStream(MemoryStream value);
    protected bool get_SendSide();
    protected void set_SendSide(bool value);
    public ISignatureReaderProvider get_ReaderProvider();
    public void set_ReaderProvider(ISignatureReaderProvider value);
    public object get_SignatureReaderProviderCallbackContext();
    public void set_SignatureReaderProviderCallbackContext(object value);
    public string get_CanonicalizationMethod();
    public void set_CanonicalizationMethod(string value);
    public void set_CanonicalizationMethodDictionaryString(XmlDictionaryString value);
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public void set_Id(string value);
    public abstract virtual int get_ReferenceCount();
    public string get_SignatureMethod();
    public void set_SignatureMethod(string value);
    public XmlDictionaryString get_SignatureMethodDictionaryString();
    public void set_SignatureMethodDictionaryString(XmlDictionaryString value);
    public SignatureResourcePool get_ResourcePool();
    public void set_ResourcePool(SignatureResourcePool value);
    public void ComputeHash(HashAlgorithm algorithm);
    protected virtual void ComputeHash(HashStream hashStream);
    public abstract virtual void ComputeReferenceDigests();
    protected String[] GetInclusivePrefixes();
    protected virtual string GetNamespaceForInclusivePrefix(string prefix);
    public abstract virtual void EnsureAllReferencesVerified();
    public void EnsureDigestValidity(string id, object resolvedXmlSource);
    public abstract virtual bool EnsureDigestValidityIfIdMatches(string id, object resolvedXmlSource);
    public virtual bool HasUnverifiedReference(string id);
    protected void ReadCanonicalizationMethod(XmlDictionaryReader reader, DictionaryManager dictionaryManager);
    public abstract virtual void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager);
    protected void ReadSignatureMethod(XmlDictionaryReader reader, DictionaryManager dictionaryManager);
    protected void WriteCanonicalizationMethod(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected void WriteSignatureMethod(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    public abstract virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.SignedXml : object {
    internal static string DefaultPrefix;
    public bool HasId { get; }
    public string Id { get; public set; }
    public SecurityTokenSerializer SecurityTokenSerializer { get; }
    public Signature Signature { get; }
    public TransformFactory TransformFactory { get; public set; }
    public SignedXml(DictionaryManager dictionaryManager, SecurityTokenSerializer tokenSerializer);
    internal SignedXml(SignedInfo signedInfo, DictionaryManager dictionaryManager, SecurityTokenSerializer tokenSerializer);
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public void set_Id(string value);
    public SecurityTokenSerializer get_SecurityTokenSerializer();
    public Signature get_Signature();
    public TransformFactory get_TransformFactory();
    public void set_TransformFactory(TransformFactory value);
    public void ComputeSignature(SecurityKey signingKey);
    public void CompleteSignatureVerification();
    public void EnsureDigestValidity(string id, object resolvedXmlSource);
    public bool EnsureDigestValidityIfIdMatches(string id, object resolvedXmlSource);
    public sealed virtual Byte[] GetSignatureValue();
    public void ReadFrom(XmlReader reader);
    public void ReadFrom(XmlDictionaryReader reader);
    public void StartSignatureVerification(SecurityKey verificationKey);
    public void WriteTo(XmlDictionaryWriter writer);
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.SR : object {
    internal static string SspiLoginPromptHeaderMessage;
    internal static string ValueMustBeNonNegative;
    internal static string ValueMustBeInRange;
    internal static string ValueMustBeOne;
    internal static string ValueMustBeZero;
    internal static string ValueMustBeGreaterThanZero;
    internal static string ValueMustBeOf2Types;
    internal static string LengthOfArrayToConvertMustGreaterThanZero;
    internal static string LengthMustBeGreaterThanZero;
    internal static string ArgumentCannotBeEmptyString;
    internal static string AuthorizationContextCreated;
    internal static string AuthorizationPolicyEvaluated;
    internal static string RequiredAttributeMissing;
    internal static string UnsupportedCryptoAlgorithm;
    internal static string CustomCryptoAlgorithmIsNotValidSymmetricAlgorithm;
    internal static string CustomCryptoAlgorithmIsNotValidHashAlgorithm;
    internal static string CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm;
    internal static string CryptoAlgorithmIsNotFipsCompliant;
    internal static string InvalidCustomKeyWrapAlgorithm;
    internal static string AlgorithmMismatchForTransform;
    internal static string SecurityTokenRequirementDoesNotContainProperty;
    internal static string SecurityTokenRequirementHasInvalidTypeForProperty;
    internal static string UnableToResolveKeyReference;
    internal static string UnableToResolveTokenReference;
    internal static string NoInputIsSetForCanonicalization;
    internal static string RequiredTargetNotSigned;
    internal static string XmlBufferQuotaExceeded;
    internal static string XmlLangAttributeMissing;
    internal static string InvalidXmlQualifiedName;
    internal static string UnboundPrefixInQName;
    internal static string ExpectedElementMissing;
    internal static string UnexpectedXmlChildNode;
    internal static string TokenCancellationNotSupported;
    internal static string TokenRenewalNotSupported;
    internal static string TokenProviderUnableToGetToken;
    internal static string TokenProviderUnableToRenewToken;
    internal static string CannotValidateSecurityTokenType;
    internal static string UserNameCannotBeEmpty;
    internal static string LocalIdCannotBeEmpty;
    internal static string ProvidedNetworkCredentialsForKerberosHasInvalidUserName;
    internal static string UnableToCreateKerberosCredentials;
    internal static string UnsupportedTransformAlgorithm;
    internal static string AtLeastOneReferenceRequired;
    internal static string DigestVerificationFailedForReference;
    internal static string SignatureVerificationFailed;
    internal static string AtLeastOneTransformRequired;
    internal static string AsyncCallbackException;
    internal static string UserNameAuthenticationFailed;
    internal static string ObjectIsReadOnly;
    internal static string UnsupportedKeyDerivationAlgorithm;
    internal static string UnsupportedNodeTypeInReader;
    internal static string UnknownICryptoType;
    internal static string NoPrivateKeyAvailable;
    internal static string UnsupportedAlgorithmForCryptoOperation;
    internal static string KeyIdentifierCannotCreateKey;
    internal static string KeyIdentifierClauseDoesNotSupportKeyCreation;
    internal static string TokenDoesNotSupportKeyIdentifierClauseCreation;
    internal static string XmlTokenBufferIsEmpty;
    internal static string NoKeyIdentifierClauseFound;
    internal static string UnableToCreateKeyedHashAlgorithm;
    internal static string UnableToCreateKeyedHashAlgorithmFromSymmetricCrypto;
    internal static string UnableToCreateHashAlgorithmFromAsymmetricCrypto;
    internal static string UnableToCreateSignatureDeformatterFromAsymmetricCrypto;
    internal static string UnableToCreateSignatureFormatterFromAsymmetricCrypto;
    internal static string InnerReaderMustBeAtElement;
    internal static string CannotFindCert;
    internal static string FoundMultipleCerts;
    internal static string X509FindValueMismatch;
    internal static string X509FindValueMismatchMulti;
    internal static string X509CertStoreLocationNotValid;
    internal static string EmptyTransformChainNotSupported;
    internal static string UnsupportedInputTypeForTransform;
    internal static string UnsupportedLastTransform;
    internal static string UnableToResolveReferenceUriForSignature;
    internal static string UnsupportedEncryptionAlgorithm;
    internal static string UnsupportedKeyWrapAlgorithm;
    internal static string InvalidAsyncResult;
    internal static string UnableToCreateTokenReference;
    internal static string BadEncryptionState;
    internal static string XmlBufferInInvalidState;
    internal static string ReferenceListCannotBeEmpty;
    internal static string InvalidDataReferenceInReferenceList;
    internal static string InvalidX509RawData;
    internal static string CannotReadKeyIdentifierClause;
    internal static string StandardsManagerCannotWriteObject;
    internal static string UnknownEncodingInKeyIdentifier;
    internal static string MultipleSamlAuthorityBindingsInReference;
    internal static string MultipleKeyIdentifiersInReference;
    internal static string DidNotFindKeyIdentifierInReference;
    internal static string SamlUriCannotBeNullOrEmpty;
    internal static string CannotFindMatchingCrypto;
    internal static string AssertionIdCannotBeNullOrEmpty;
    internal static string BufferQuotaExceededReadingBase64;
    internal static string CannotReadToken;
    internal static string ErrorDeserializingKeyIdentifierClause;
    internal static string ErrorSerializingKeyIdentifier;
    internal static string ErrorSerializingKeyIdentifierClause;
    internal static string NoKeyInfoClausesToWrite;
    internal static string CollectionWasModified;
    internal static string XDCannotFindValueInDictionaryString;
    internal static string AlgorithmAndKeyMisMatch;
    internal static string AlgorithmAndPrivateKeyMisMatch;
    internal static string AlgorithmAndPublicKeyMisMatch;
    internal static string ArgumentInvalidCertificate;
    internal static string X509ChainBuildFail;
    internal static string X509IsInUntrustedStore;
    internal static string X509IsNotInTrustedStore;
    internal static string X509InvalidUsageTime;
    internal static string IncorrectUserNameFormat;
    internal static string InvalidNtMapping;
    internal static string ImpersonationLevelNotSupported;
    internal static string MissingPrivateKey;
    internal static string PrivateKeyExchangeNotSupported;
    internal static string PrivateKeyNotDSA;
    internal static string PrivateKeyNotRSA;
    internal static string PublicKeyNotDSA;
    internal static string PublicKeyNotRSA;
    internal static string InclusiveNamespacePrefixRequiresSignatureReader;
    internal static string FailedToDeleteKeyContainerFile;
    internal static string EmptyOrNullArgumentString;
    internal static string SecurityChannelBindingMissing;
    internal static string ServiceNameFromClient;
    internal static string ServiceNameOnService;
    internal static string SamlSerializerRequiresExternalSerializers;
    internal static string SamlSerializerUnableToWriteSecurityKeyIdentifier;
    internal static string SamlSerializerUnableToReadSecurityKeyIdentifier;
    internal static string SamlAssertionMissingSigningCredentials;
    internal static string SamlTokenMissingSignature;
    internal static string SamlInvalidSigningToken;
    internal static string SamlSigningTokenNotFound;
    internal static string SamlSigningTokenMissing;
    internal static string SamlTokenAuthenticatorCanOnlyProcessSamlTokens;
    internal static string SamlUnableToExtractSubjectKey;
    internal static string SamlAttributeClaimResourceShouldBeAString;
    internal static string SamlAttributeClaimRightShouldBePossessProperty;
    internal static string SAMLAssertionIDIsInvalid;
    internal static string SAMLAssertionIdRequired;
    internal static string SAMLAssertionMissingMajorVersionAttributeOnRead;
    internal static string SAMLAssertionMissingMinorVersionAttributeOnRead;
    internal static string SAMLAssertionIssuerRequired;
    internal static string SAMLAssertionMissingIssuerAttributeOnRead;
    internal static string SAMLAssertionRequireOneStatement;
    internal static string SAMLAssertionRequireOneStatementOnRead;
    internal static string SAMLAttributeValueCannotBeNull;
    internal static string SAMLAttributeShouldHaveOneValue;
    internal static string SAMLAttributeNameAttributeRequired;
    internal static string SAMLAttributeMissingNameAttributeOnRead;
    internal static string SAMLAttributeNamespaceAttributeRequired;
    internal static string SAMLAttributeMissingNamespaceAttributeOnRead;
    internal static string SAMLAudienceRestrictionShouldHaveOneAudience;
    internal static string SAMLAudienceRestrictionShouldHaveOneAudienceOnRead;
    internal static string SAMLAudienceRestrictionInvalidAudienceValueOnRead;
    internal static string SAMLAudienceUrisNotFound;
    internal static string SAMLAudienceUriValidationFailed;
    internal static string SAMLAuthorizationDecisionShouldHaveOneAction;
    internal static string SAMLAuthorizationDecisionShouldHaveOneActionOnRead;
    internal static string SAMLActionNameRequired;
    internal static string SAMLActionNameRequiredOnRead;
    internal static string SAMLAuthorizationDecisionHasMoreThanOneEvidence;
    internal static string SAMLAuthorizationDecisionResourceRequired;
    internal static string SAMLAuthenticationStatementMissingAuthenticationInstanceOnRead;
    internal static string SAMLAuthenticationStatementMissingAuthenticationMethod;
    internal static string SAMLAuthenticationStatementMissingAuthenticationMethodOnRead;
    internal static string SAMLAuthenticationStatementMissingSubject;
    internal static string SAMLAuthorityBindingInvalidAuthorityKind;
    internal static string SAMLAuthorityBindingMissingAuthorityKind;
    internal static string SAMLAuthorityBindingMissingAuthorityKindOnRead;
    internal static string SAMLAuthorityKindMissingName;
    internal static string SAMLAuthorityBindingRequiresBinding;
    internal static string SAMLAuthorityBindingMissingBindingOnRead;
    internal static string SAMLAuthorityBindingRequiresLocation;
    internal static string SAMLAuthorityBindingMissingLocationOnRead;
    internal static string SAMLAuthorizationDecisionStatementMissingResourceAttributeOnRead;
    internal static string SAMLAuthorizationDecisionStatementMissingDecisionAttributeOnRead;
    internal static string SAMLAuthorizationDecisionStatementMissingSubjectOnRead;
    internal static string SAMLAttributeStatementMissingSubjectOnRead;
    internal static string SAMLSubjectStatementRequiresSubject;
    internal static string SAMLAttributeStatementMissingAttributeOnRead;
    internal static string SAMLBadSchema;
    internal static string SAMLElementNotRecognized;
    internal static string SAMLEntityCannotBeNullOrEmpty;
    internal static string SAMLEvidenceShouldHaveOneAssertion;
    internal static string SAMLEvidenceShouldHaveOneAssertionOnRead;
    internal static string SAMLNameIdentifierMissingIdentifierValueOnRead;
    internal static string SAMLSubjectNameIdentifierRequiresNameValue;
    internal static string SAMLSubjectRequiresNameIdentifierOrConfirmationMethod;
    internal static string SAMLSubjectRequiresNameIdentifierOrConfirmationMethodOnRead;
    internal static string SAMLSubjectRequiresConfirmationMethodWhenConfirmationDataOrKeyInfoIsSpecified;
    internal static string SAMLSubjectConfirmationClauseMissingConfirmationMethodOnRead;
    internal static string SAMLTokenNotSerialized;
    internal static string SAMLTokenTimeInvalid;
    internal static string SAMLTokenVersionNotSupported;
    internal static string SAMLSignatureAlreadyRead;
    internal static string SAMLUnableToLoadUnknownElement;
    internal static string SAMLUnableToResolveSignatureKey;
    internal static string SAMLUnableToLoadAssertion;
    internal static string SAMLUnableToLoadCondtion;
    internal static string SAMLUnableToLoadCondtions;
    internal static string SAMLUnableToLoadAdvice;
    internal static string SAMLUnableToLoadStatement;
    internal static string SAMLUnableToLoadAttribute;
    internal static string SymmetricKeyLengthTooShort;
    internal static string InvalidHexString;
    internal static string FailInitializeSecurityContext;
    internal static string FailAcceptSecurityContext;
    internal static string FailLogonUser;
    internal static string KerberosMultilegsNotSupported;
    internal static string KerberosApReqInvalidOrOutOfMemory;
    internal static string SspiPayloadNotEncrypted;
    internal static string SSPIPackageNotSupported;
    internal static string SspiWrapperEncryptDecryptAssert1;
    internal static string SspiWrapperEncryptDecryptAssert2;
    internal static string RevertingPrivilegeFailed;
    internal static string InvalidServiceBindingInSspiNegotiationServiceBindingNotMatched;
    internal static string InvalidServiceBindingInSspiNegotiationNoServiceBinding;
    internal static string AESCipherModeNotSupported;
    internal static string AESKeyLengthNotSupported;
    internal static string AESIVLengthNotSupported;
    internal static string AESPaddingModeNotSupported;
    internal static string AESCryptAcquireContextFailed;
    internal static string AESCryptImportKeyFailed;
    internal static string AESCryptGetKeyParamFailed;
    internal static string AESCryptSetKeyParamFailed;
    internal static string AESCryptEncryptFailed;
    internal static string AESCryptDecryptFailed;
    internal static string AESInvalidInputBlockSize;
    internal static string AESInsufficientOutputBuffer;
    internal static string ID0001;
    internal static string ID0002;
    internal static string ID0003;
    internal static string ID0005;
    internal static string ID0006;
    internal static string ID0008;
    internal static string ID0009;
    internal static string ID0011;
    internal static string ID0012;
    internal static string ID0013;
    internal static string ID0014;
    internal static string ID0016;
    internal static string ID0018;
    internal static string ID0019;
    internal static string ID0021;
    internal static string ID0022;
    internal static string ID0023;
    internal static string ID1001;
    internal static string ID1002;
    internal static string ID1005;
    internal static string ID1006;
    internal static string ID1007;
    internal static string ID1008;
    internal static string ID1009;
    internal static string ID1012;
    internal static string ID1013;
    internal static string ID1014;
    internal static string ID1024;
    internal static string ID1025;
    internal static string ID1029;
    internal static string ID1032;
    internal static string ID1033;
    internal static string ID1034;
    internal static string ID1035;
    internal static string ID1036;
    internal static string ID1037;
    internal static string ID1038;
    internal static string ID1039;
    internal static string ID1043;
    internal static string ID1053;
    internal static string ID1054;
    internal static string ID1062;
    internal static string ID1063;
    internal static string ID1064;
    internal static string ID1065;
    internal static string ID1066;
    internal static string ID1067;
    internal static string ID1068;
    internal static string ID1069;
    internal static string ID1070;
    internal static string ID1072;
    internal static string ID1073;
    internal static string ID1074;
    internal static string ID2000;
    internal static string ID2001;
    internal static string ID2002;
    internal static string ID2003;
    internal static string ID2004;
    internal static string ID2005;
    internal static string ID2008;
    internal static string ID2009;
    internal static string ID2011;
    internal static string ID2012;
    internal static string ID2013;
    internal static string ID2014;
    internal static string ID2015;
    internal static string ID2016;
    internal static string ID2050;
    internal static string ID2051;
    internal static string ID2052;
    internal static string ID2053;
    internal static string ID2055;
    internal static string ID2056;
    internal static string ID2057;
    internal static string ID2058;
    internal static string ID2059;
    internal static string ID2064;
    internal static string ID2069;
    internal static string ID2070;
    internal static string ID2073;
    internal static string ID2074;
    internal static string ID2079;
    internal static string ID2080;
    internal static string ID2072;
    internal static string ID2075;
    internal static string ID2076;
    internal static string ID2077;
    internal static string ID2078;
    internal static string ID2081;
    internal static string ID2082;
    internal static string ID2083;
    internal static string ID2084;
    internal static string ID2100;
    internal static string ID3006;
    internal static string ID3007;
    internal static string ID3009;
    internal static string ID3010;
    internal static string ID3011;
    internal static string ID3012;
    internal static string ID3013;
    internal static string ID3017;
    internal static string ID3020;
    internal static string ID3021;
    internal static string ID3025;
    internal static string ID3026;
    internal static string ID3027;
    internal static string ID3032;
    internal static string ID3057;
    internal static string ID3061;
    internal static string ID3063;
    internal static string ID3064;
    internal static string ID3089;
    internal static string ID3091;
    internal static string ID3092;
    internal static string ID3130;
    internal static string ID3135;
    internal static string ID3136;
    internal static string ID3141;
    internal static string ID3151;
    internal static string ID3152;
    internal static string ID3153;
    internal static string ID3154;
    internal static string ID3155;
    internal static string ID3158;
    internal static string ID3159;
    internal static string ID3160;
    internal static string ID3161;
    internal static string ID3162;
    internal static string ID3164;
    internal static string ID3165;
    internal static string ID3166;
    internal static string ID3198;
    internal static string ID3199;
    internal static string ID3200;
    internal static string ID3201;
    internal static string ID3202;
    internal static string ID3203;
    internal static string ID3207;
    internal static string ID3215;
    internal static string ID3216;
    internal static string ID3217;
    internal static string ID3218;
    internal static string ID3219;
    internal static string ID3220;
    internal static string ID3221;
    internal static string ID3222;
    internal static string ID3223;
    internal static string ID3249;
    internal static string ID3257;
    internal static string ID3258;
    internal static string ID3260;
    internal static string ID3264;
    internal static string ID3265;
    internal static string ID3268;
    internal static string ID3274;
    internal static string ID3275;
    internal static string ID3276;
    internal static string ID3284;
    internal static string ID4001;
    internal static string ID4002;
    internal static string ID4003;
    internal static string ID4004;
    internal static string ID4005;
    internal static string ID4007;
    internal static string ID4008;
    internal static string ID4010;
    internal static string ID4011;
    internal static string ID4013;
    internal static string ID4014;
    internal static string ID4020;
    internal static string ID4022;
    internal static string ID4023;
    internal static string ID4024;
    internal static string ID4025;
    internal static string ID4026;
    internal static string ID4034;
    internal static string ID4036;
    internal static string ID4037;
    internal static string ID4038;
    internal static string ID4046;
    internal static string ID4050;
    internal static string ID4051;
    internal static string ID4052;
    internal static string ID4059;
    internal static string ID4060;
    internal static string ID4061;
    internal static string ID4062;
    internal static string ID4063;
    internal static string ID4065;
    internal static string ID4066;
    internal static string ID4067;
    internal static string ID4068;
    internal static string ID4070;
    internal static string ID4073;
    internal static string ID4075;
    internal static string ID4076;
    internal static string ID4077;
    internal static string ID4078;
    internal static string ID4079;
    internal static string ID4080;
    internal static string ID4081;
    internal static string ID4082;
    internal static string ID4083;
    internal static string ID4084;
    internal static string ID4085;
    internal static string ID4086;
    internal static string ID4087;
    internal static string ID4088;
    internal static string ID4089;
    internal static string ID4090;
    internal static string ID4091;
    internal static string ID4092;
    internal static string ID4093;
    internal static string ID4094;
    internal static string ID4095;
    internal static string ID4096;
    internal static string ID4097;
    internal static string ID4098;
    internal static string ID4099;
    internal static string ID4100;
    internal static string ID4102;
    internal static string ID4104;
    internal static string ID4105;
    internal static string ID4106;
    internal static string ID4107;
    internal static string ID4108;
    internal static string ID4110;
    internal static string ID4111;
    internal static string ID4112;
    internal static string ID4113;
    internal static string ID4114;
    internal static string ID4115;
    internal static string ID4116;
    internal static string ID4117;
    internal static string ID4118;
    internal static string ID4119;
    internal static string ID4120;
    internal static string ID4121;
    internal static string ID4122;
    internal static string ID4123;
    internal static string ID4124;
    internal static string ID4125;
    internal static string ID4126;
    internal static string ID4127;
    internal static string ID4128;
    internal static string ID4129;
    internal static string ID4130;
    internal static string ID4131;
    internal static string ID4132;
    internal static string ID4133;
    internal static string ID4134;
    internal static string ID4136;
    internal static string ID4138;
    internal static string ID4139;
    internal static string ID4140;
    internal static string ID4141;
    internal static string ID4142;
    internal static string ID4147;
    internal static string ID4148;
    internal static string ID4149;
    internal static string ID4150;
    internal static string ID4151;
    internal static string ID4152;
    internal static string ID4153;
    internal static string ID4154;
    internal static string ID4157;
    internal static string ID4158;
    internal static string ID4159;
    internal static string ID4160;
    internal static string ID4161;
    internal static string ID4162;
    internal static string ID4172;
    internal static string ID4173;
    internal static string ID4175;
    internal static string ID4176;
    internal static string ID4177;
    internal static string ID4178;
    internal static string ID4179;
    internal static string ID4180;
    internal static string ID4181;
    internal static string ID4182;
    internal static string ID4183;
    internal static string ID4184;
    internal static string ID4185;
    internal static string ID4187;
    internal static string ID4188;
    internal static string ID4189;
    internal static string ID4190;
    internal static string ID4191;
    internal static string ID4192;
    internal static string ID4193;
    internal static string ID4200;
    internal static string ID4201;
    internal static string ID4202;
    internal static string ID4203;
    internal static string ID4204;
    internal static string ID4205;
    internal static string ID4206;
    internal static string ID4207;
    internal static string ID4208;
    internal static string ID4209;
    internal static string ID4210;
    internal static string ID4211;
    internal static string ID4212;
    internal static string ID4213;
    internal static string ID4216;
    internal static string ID4217;
    internal static string ID4218;
    internal static string ID4220;
    internal static string ID4221;
    internal static string ID4222;
    internal static string ID4223;
    internal static string ID4224;
    internal static string ID4225;
    internal static string ID4227;
    internal static string ID4229;
    internal static string ID4230;
    internal static string ID4232;
    internal static string ID4237;
    internal static string ID4239;
    internal static string ID4242;
    internal static string ID4243;
    internal static string ID4248;
    internal static string ID4249;
    internal static string ID4250;
    internal static string ID4251;
    internal static string ID4252;
    internal static string ID4254;
    internal static string ID4255;
    internal static string ID4256;
    internal static string ID4257;
    internal static string ID4258;
    internal static string ID4259;
    internal static string ID4261;
    internal static string ID4262;
    internal static string ID4263;
    internal static string ID4264;
    internal static string ID4265;
    internal static string ID4269;
    internal static string ID4270;
    internal static string ID4272;
    internal static string ID4274;
    internal static string ID4275;
    internal static string ID4276;
    internal static string ID4277;
    internal static string ID4278;
    internal static string ID4279;
    internal static string ID4280;
    internal static string ID4283;
    internal static string ID4289;
    internal static string ID4290;
    internal static string ID4291;
    internal static string ID4292;
    internal static string ID4294;
    internal static string ID4296;
    internal static string ID6000;
    internal static string ID6001;
    internal static string ID6002;
    internal static string ID6005;
    internal static string ID6019;
    internal static string ID6029;
    internal static string ID6030;
    internal static string ID6031;
    internal static string ID6033;
    internal static string ID6034;
    internal static string ID6035;
    internal static string ID6036;
    internal static string ID6037;
    internal static string ID6039;
    internal static string ID6040;
    internal static string ID6041;
    internal static string ID6042;
    internal static string ID6043;
    internal static string ID6044;
    internal static string ID6045;
    internal static string ID6046;
    internal static string ID6047;
    internal static string ID6048;
    internal static string ID7000;
    internal static string ID7001;
    internal static string ID7002;
    internal static string ID7004;
    internal static string ID7007;
    internal static string ID7009;
    internal static string ID7010;
    internal static string ID7011;
    internal static string ID7012;
    internal static string ID7013;
    internal static string ID7017;
    internal static string ID7018;
    internal static string ID7019;
    internal static string ID7022;
    internal static string ID7026;
    internal static string ID7027;
    internal static string ID7028;
    internal static string ID7029;
    internal static string ID8003;
    internal static string ID8004;
    internal static string ID8005;
    internal static string ID8006;
    internal static string ID8007;
    internal static string ID8023;
    internal static string ID8024;
    internal static string ID8025;
    internal static string ID8026;
    internal static string ID8027;
    internal static string ID8028;
    internal static string ID8029;
    internal static string ID8030;
    internal static string KeyLengthMustBeMultipleOfEight;
    internal static string GivenNameText;
    internal static string SurnameText;
    internal static string EmailAddressText;
    internal static string StreetAddressText;
    internal static string LocalityText;
    internal static string StateOrProvinceText;
    internal static string PostalCodeText;
    internal static string CountryText;
    internal static string HomePhoneText;
    internal static string OtherPhoneText;
    internal static string MobilePhoneText;
    internal static string DateOfBirthText;
    internal static string GenderText;
    internal static string PPIDText;
    internal static string WebPageText;
    internal static string NameText;
    internal static string RoleText;
    internal static string GivenNameDescription;
    internal static string SurnameDescription;
    internal static string EmailAddressDescription;
    internal static string StreetAddressDescription;
    internal static string LocalityDescription;
    internal static string StateOrProvinceDescription;
    internal static string PostalCodeDescription;
    internal static string CountryDescription;
    internal static string HomePhoneDescription;
    internal static string OtherPhoneDescription;
    internal static string MobilePhoneDescription;
    internal static string DateOfBirthDescription;
    internal static string GenderDescription;
    internal static string PPIDDescription;
    internal static string WebPageDescription;
    internal static string NameDescription;
    internal static string RoleDescription;
    internal static string TraceCodeIdentityModel;
    internal static string TraceCodeDiagnostics;
    internal static string TraceCodeServiceBindingCheck;
    internal static string TraceCodeChannelBindingCheck;
    internal static string TraceSetPrincipalOnEvaluationContext;
    internal static string TraceUnableToWriteToken;
    internal static string TraceValidateToken;
    internal static string TraceDeflateCookieEncode;
    internal static string PrivateKeyNotSupported;
    internal static string PublicKeyNotSupported;
    public static ResourceManager Resources { get; }
    private static SR();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class System.IdentityModel.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.IdentityModel.SRDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.IdentityModel.SslConnectionInfo : object {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
    internal SslConnectionInfo(Byte[] nativeBuffer);
}
[FlagsAttribute]
internal enum System.IdentityModel.SspiContextFlags : Enum {
    public int value__;
    public static SspiContextFlags Zero;
    public static SspiContextFlags Delegate;
    public static SspiContextFlags MutualAuth;
    public static SspiContextFlags ReplayDetect;
    public static SspiContextFlags SequenceDetect;
    public static SspiContextFlags Confidentiality;
    public static SspiContextFlags UseSessionKey;
    public static SspiContextFlags AllocateMemory;
    public static SspiContextFlags InitStream;
    public static SspiContextFlags AcceptStream;
    public static SspiContextFlags InitExtendedError;
    public static SspiContextFlags AcceptExtendedError;
    public static SspiContextFlags InitIdentify;
    public static SspiContextFlags AcceptIdentify;
    public static SspiContextFlags InitManualCredValidation;
    public static SspiContextFlags InitAnonymous;
    public static SspiContextFlags AcceptAnonymous;
    public static SspiContextFlags ChannelBindingProxyBindings;
    public static SspiContextFlags ChannelBindingAllowMissingBindings;
}
internal class System.IdentityModel.SSPIHandle : ValueType {
    private IntPtr HandleHi;
    private IntPtr HandleLo;
    public bool IsZero { get; }
    public bool get_IsZero();
    [ReliabilityContractAttribute("3", "2")]
internal void SetToInvalid();
}
internal static class System.IdentityModel.SspiWrapper : object {
    public static SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public static SecurityPackageInfoClass[] get_SecurityPackages();
    public static void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public static SecurityPackageInfoClass GetVerifyPackageInfo(string packageName);
    public static bool IsNegotiateExPackagePresent();
    public static SafeFreeCredentials AcquireDefaultCredential(string package, CredentialUse intent, String[] additionalPackages);
    public static SafeFreeCredentials AcquireCredentialsHandle(string package, CredentialUse intent, AuthIdentityEx& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(string package, CredentialUse intent, SecureCredential scc);
    public static SafeFreeCredentials AcquireCredentialsHandle(string package, CredentialUse intent, IntPtr& ppAuthIdentity);
    internal static int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, SspiContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, SspiContextFlags& outFlags);
    internal static int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, SspiContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, SspiContextFlags& outFlags);
    internal static int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& refContext, SspiContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, SspiContextFlags& outFlags);
    internal static int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& refContext, SspiContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, SspiContextFlags& outFlags);
    public static int QuerySecurityContextToken(SafeDeleteContext context, SafeCloseHandle& token);
    public static object QueryContextAttributes(SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static int QuerySpecifiedTarget(SafeDeleteContext securityContext, String& specifiedTarget);
    public static void ImpersonateSecurityContext(SafeDeleteContext context);
    public static int EncryptDecryptHelper(SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber, bool encrypt, bool isGssBlob);
    public static int EncryptMessage(SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int DecryptMessage(SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber, bool isGssBlob);
    public static UInt32 SspiPromptForCredential(string targetName, string packageName, IntPtr& ppAuthIdentity, Boolean& saveCredentials);
    public static bool IsSspiPromptingNeeded(UInt32 ErrorOrNtStatus);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.StandardSignedInfo : SignedInfo {
    public int ReferenceCount { get; }
    public Reference Item { get; }
    protected string Prefix { get; protected set; }
    protected Dictionary`2<string, string> Context { get; protected set; }
    public StandardSignedInfo(DictionaryManager dictionaryManager);
    public virtual int get_ReferenceCount();
    public Reference get_Item(int index);
    public void AddReference(Reference reference);
    public virtual void EnsureAllReferencesVerified();
    public virtual bool EnsureDigestValidityIfIdMatches(string id, object resolvedXmlSource);
    public virtual bool HasUnverifiedReference(string id);
    public virtual void ComputeReferenceDigests();
    public virtual void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager);
    public virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected virtual string GetNamespaceForInclusivePrefix(string prefix);
    protected string get_Prefix();
    protected void set_Prefix(string value);
    protected Dictionary`2<string, string> get_Context();
    protected void set_Context(Dictionary`2<string, string> value);
}
internal class System.IdentityModel.StandardTransformFactory : TransformFactory {
    internal static StandardTransformFactory Instance { get; }
    private static StandardTransformFactory();
    internal static StandardTransformFactory get_Instance();
    public virtual Transform CreateTransform(string transformAlgorithmUri);
}
internal class System.IdentityModel.StreamSizes : object {
    public int header;
    public int trailer;
    public int maximumMessage;
    public int buffersCount;
    public int blockSize;
    public static int SizeOf;
    internal StreamSizes(Byte[] memory);
    private static StreamSizes();
}
internal static class System.IdentityModel.StringUtil : object {
    public static string OptimizeString(string value);
}
internal class System.IdentityModel.StrTransform : Transform {
    public string Algorithm { get; }
    public bool IncludeComments { get; }
    public string InclusiveNamespacesPrefixList { get; public set; }
    public bool NeedsInclusiveContext { get; }
    public virtual string get_Algorithm();
    public bool get_IncludeComments();
    public string get_InclusiveNamespacesPrefixList();
    public void set_InclusiveNamespacesPrefixList(string value);
    public virtual bool get_NeedsInclusiveContext();
    public String[] GetInclusivePrefixes();
    public virtual object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager);
    public virtual Byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager);
    public void ProcessAndDigest(object input, SignatureResourcePool resourcePool, HashAlgorithm hash, DictionaryManager dictionaryManger);
    public virtual void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments);
    public virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal class System.IdentityModel.TOKEN_GROUPS : ValueType {
    internal UInt32 GroupCount;
    internal SID_AND_ATTRIBUTES Groups;
}
internal class System.IdentityModel.TOKEN_PRIVILEGE : ValueType {
    internal UInt32 PrivilegeCount;
    internal LUID_AND_ATTRIBUTES Privilege;
    internal static UInt32 Size;
    private static TOKEN_PRIVILEGE();
}
internal class System.IdentityModel.TOKEN_SOURCE : ValueType {
    private static int TOKEN_SOURCE_LENGTH;
    internal Char[] Name;
    internal LUID SourceIdentifier;
}
internal enum System.IdentityModel.TokenInformationClass : Enum {
    public UInt32 value__;
    public static TokenInformationClass TokenUser;
    public static TokenInformationClass TokenGroups;
    public static TokenInformationClass TokenPrivileges;
    public static TokenInformationClass TokenOwner;
    public static TokenInformationClass TokenPrimaryGroup;
    public static TokenInformationClass TokenDefaultDacl;
    public static TokenInformationClass TokenSource;
    public static TokenInformationClass TokenType;
    public static TokenInformationClass TokenImpersonationLevel;
    public static TokenInformationClass TokenStatistics;
    public static TokenInformationClass TokenRestrictedSids;
    public static TokenInformationClass TokenSessionId;
    public static TokenInformationClass TokenGroupsAndPrivileges;
    public static TokenInformationClass TokenSessionReference;
    public static TokenInformationClass TokenSandBoxInert;
}
internal class System.IdentityModel.Tokens.AbsoluteUriCollection : Collection`1<Uri> {
    protected virtual void InsertItem(int index, Uri item);
    protected virtual void SetItem(int index, Uri item);
}
public class System.IdentityModel.Tokens.AggregateTokenResolver : SecurityTokenResolver {
    public ReadOnlyCollection`1<SecurityTokenResolver> TokenResolvers { get; }
    public AggregateTokenResolver(IEnumerable`1<SecurityTokenResolver> tokenResolvers);
    public ReadOnlyCollection`1<SecurityTokenResolver> get_TokenResolvers();
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
}
public class System.IdentityModel.Tokens.AsymmetricProofDescriptor : ProofDescriptor {
    public SecurityKeyIdentifier KeyIdentifier { get; }
    public AsymmetricProofDescriptor(RSA rsaAlgorithm);
    public AsymmetricProofDescriptor(SecurityKeyIdentifier keyIdentifier);
    public virtual void ApplyTo(RequestSecurityTokenResponse response);
    public virtual SecurityKeyIdentifier get_KeyIdentifier();
}
public abstract class System.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
    public abstract virtual AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey);
    public abstract virtual HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
    public abstract virtual AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
    public abstract virtual AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
    public abstract virtual bool HasPrivateKey();
}
public class System.IdentityModel.Tokens.AudienceRestriction : object {
    public AudienceUriMode AudienceMode { get; public set; }
    public Collection`1<Uri> AllowedAudienceUris { get; }
    public AudienceRestriction(AudienceUriMode audienceMode);
    public AudienceUriMode get_AudienceMode();
    public void set_AudienceMode(AudienceUriMode value);
    public Collection`1<Uri> get_AllowedAudienceUris();
}
public class System.IdentityModel.Tokens.AudienceUriValidationFailedException : SecurityTokenValidationException {
    public AudienceUriValidationFailedException(string message);
    public AudienceUriValidationFailedException(string message, Exception inner);
    protected AudienceUriValidationFailedException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Tokens.AuthenticationContext : object {
    public Collection`1<string> Authorities { get; }
    public string ContextClass { get; public set; }
    public string ContextDeclaration { get; public set; }
    public Collection`1<string> get_Authorities();
    public string get_ContextClass();
    public void set_ContextClass(string value);
    public string get_ContextDeclaration();
    public void set_ContextDeclaration(string value);
}
public static class System.IdentityModel.Tokens.AuthenticationMethods : object {
    public static string Namespace;
    public static string HardwareToken;
    public static string Kerberos;
    public static string Password;
    public static string Pgp;
    public static string SecureRemotePassword;
    public static string Signature;
    public static string Smartcard;
    public static string SmartcardPki;
    public static string Spki;
    public static string TlsClient;
    public static string Unspecified;
    public static string Windows;
    public static string Xkms;
    public static string X509;
}
internal class System.IdentityModel.Tokens.AuthorizationPolicy : object {
    public static string ClaimsPrincipalKey;
    public static string IdentitiesKey;
    public ReadOnlyCollection`1<ClaimsIdentity> IdentityCollection { get; }
    public ClaimSet Issuer { get; }
    public string Id { get; }
    public AuthorizationPolicy(ClaimsIdentity identity);
    public AuthorizationPolicy(IEnumerable`1<ClaimsIdentity> identityCollection);
    public ReadOnlyCollection`1<ClaimsIdentity> get_IdentityCollection();
    public sealed virtual bool Evaluate(EvaluationContext evaluationContext, Object& state);
    public sealed virtual ClaimSet get_Issuer();
    public sealed virtual string get_Id();
}
public abstract class System.IdentityModel.Tokens.BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer);
    protected BinaryKeyIdentifierClause(string clauseType, Byte[] identificationData, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetBuffer();
    protected Byte[] GetRawBuffer();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] data);
    public bool Matches(Byte[] data, int offset);
    internal string ToBase64String();
    internal string ToHexString();
}
public class System.IdentityModel.Tokens.BootstrapContext : object {
    public Byte[] TokenBytes { get; }
    public string Token { get; }
    public SecurityToken SecurityToken { get; }
    public SecurityTokenHandler SecurityTokenHandler { get; }
    protected BootstrapContext(SerializationInfo info, StreamingContext context);
    public BootstrapContext(SecurityToken token, SecurityTokenHandler tokenHandler);
    public BootstrapContext(string token);
    public BootstrapContext(Byte[] token);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Byte[] get_TokenBytes();
    public string get_Token();
    public SecurityToken get_SecurityToken();
    public SecurityTokenHandler get_SecurityTokenHandler();
}
public static class System.IdentityModel.Tokens.ComputedKeyAlgorithms : object {
    public static string Psha1;
}
public class System.IdentityModel.Tokens.ConfigurationBasedIssuerNameRegistry : IssuerNameRegistry {
    public IDictionary`2<string, string> ConfiguredTrustedIssuers { get; }
    public virtual void LoadCustomConfiguration(XmlNodeList customConfiguration);
    public virtual string GetIssuerName(SecurityToken securityToken);
    public IDictionary`2<string, string> get_ConfiguredTrustedIssuers();
    public void AddTrustedIssuer(string certificateThumbprint, string name);
}
internal class System.IdentityModel.Tokens.DefaultTokenReplayCache : TokenReplayCache {
    public int Capacity { get; public set; }
    public TimeSpan PurgeInterval { get; public set; }
    public DefaultTokenReplayCache(int capacity, TimeSpan purgeInterval);
    private static DefaultTokenReplayCache();
    public int get_Capacity();
    public void set_Capacity(int value);
    public void Clear();
    public int IncreaseCapacity(int size);
    public TimeSpan get_PurgeInterval();
    public void set_PurgeInterval(TimeSpan value);
    public virtual void AddOrUpdate(string key, SecurityToken securityToken, DateTime expirationTime);
    public virtual bool Contains(string key);
    public virtual SecurityToken Get(string key);
    public virtual void Remove(string key);
}
internal static class System.IdentityModel.Tokens.DEREncoding : object {
    private static DEREncoding();
    public static int LengthSize(int length);
    public static void MakeTokenHeader(int bodySize, Byte[] buffer, Int32& offset, Int32& len);
    public static int ReadLength(Byte[] buffer, Int32& offset, Int32& length);
    public static int TokenSize(int bodySize);
    public static void VerifyTokenHeader(Byte[] buffer, Int32& offset, Int32& len);
    public static void WriteLength(Byte[] buffer, Int32& offset, Int32& bufferLength, int length);
}
public class System.IdentityModel.Tokens.EmptySecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
    public object Context { get; }
    public EmptySecurityKeyIdentifierClause(object context);
    public object get_Context();
}
public class System.IdentityModel.Tokens.EncryptedKeyEncryptingCredentials : EncryptingCredentials {
    public EncryptingCredentials WrappingCredentials { get; }
    public EncryptedKeyEncryptingCredentials(X509Certificate2 certificate);
    public EncryptedKeyEncryptingCredentials(X509Certificate2 certificate, string keyWrappingAlgorithm, int keySizeInBits, string encryptionAlgorithm);
    public EncryptedKeyEncryptingCredentials(EncryptingCredentials wrappingCredentials, int keySizeInBits, string encryptionAlgorithm);
    public EncryptingCredentials get_WrappingCredentials();
}
public class System.IdentityModel.Tokens.EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
    public string CarriedKeyName { get; }
    public SecurityKeyIdentifier EncryptingKeyIdentifier { get; }
    public string EncryptionMethod { get; }
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName);
    public EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, Byte[] derivationNonce, int derivationLength);
    internal EncryptedKeyIdentifierClause(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public string get_CarriedKeyName();
    public SecurityKeyIdentifier get_EncryptingKeyIdentifier();
    public string get_EncryptionMethod();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(Byte[] encryptedKey, string encryptionMethod, string carriedKeyName);
    public Byte[] GetEncryptedKey();
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.EncryptedSecurityToken : SecurityToken {
    public EncryptingCredentials EncryptingCredentials { get; }
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SecurityToken Token { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public EncryptedSecurityToken(SecurityToken token, EncryptingCredentials encryptingCredentials);
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public EncryptingCredentials get_EncryptingCredentials();
    public virtual string get_Id();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public SecurityToken get_Token();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
}
public class System.IdentityModel.Tokens.EncryptedSecurityTokenHandler : SecurityTokenHandler {
    public bool CanWriteToken { get; }
    public SecurityTokenSerializer KeyInfoSerializer { get; public set; }
    public Type TokenType { get; }
    private static EncryptedSecurityTokenHandler();
    public virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool get_CanWriteToken();
    public SecurityTokenSerializer get_KeyInfoSerializer();
    public void set_KeyInfoSerializer(SecurityTokenSerializer value);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public virtual Type get_TokenType();
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
}
public class System.IdentityModel.Tokens.EncryptedTokenDecryptionFailedException : SecurityTokenException {
    public EncryptedTokenDecryptionFailedException(string message);
    public EncryptedTokenDecryptionFailedException(string message, Exception inner);
    protected EncryptedTokenDecryptionFailedException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Tokens.EncryptingCredentials : object {
    public string Algorithm { get; public set; }
    public SecurityKey SecurityKey { get; public set; }
    public SecurityKeyIdentifier SecurityKeyIdentifier { get; public set; }
    public EncryptingCredentials(SecurityKey key, SecurityKeyIdentifier keyIdentifier, string algorithm);
    public string get_Algorithm();
    public void set_Algorithm(string value);
    public SecurityKey get_SecurityKey();
    public void set_SecurityKey(SecurityKey value);
    public SecurityKeyIdentifier get_SecurityKeyIdentifier();
    public void set_SecurityKeyIdentifier(SecurityKeyIdentifier value);
}
internal class System.IdentityModel.Tokens.EndpointAuthorizationPolicy : object {
    public string EndpointId { get; }
    private ClaimSet System.IdentityModel.Policy.IAuthorizationPolicy.Issuer { get; }
    private string System.IdentityModel.Policy.IAuthorizationComponent.Id { get; }
    public EndpointAuthorizationPolicy(string endpointId);
    public string get_EndpointId();
    private sealed virtual override bool System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate(EvaluationContext evaluationContext, Object& state);
    private sealed virtual override ClaimSet System.IdentityModel.Policy.IAuthorizationPolicy.get_Issuer();
    private sealed virtual override string System.IdentityModel.Policy.IAuthorizationComponent.get_Id();
}
public class System.IdentityModel.Tokens.GenericXmlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
    public XmlElement ReferenceXml { get; }
    public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml);
    public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml, Byte[] derivationNonce, int derivationLength);
    public XmlElement get_ReferenceXml();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.GenericXmlSecurityToken : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public SecurityKeyIdentifierClause InternalTokenReference { get; }
    public SecurityKeyIdentifierClause ExternalTokenReference { get; }
    public XmlElement TokenXml { get; }
    public SecurityToken ProofToken { get; }
    public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public GenericXmlSecurityToken(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public SecurityKeyIdentifierClause get_InternalTokenReference();
    public SecurityKeyIdentifierClause get_ExternalTokenReference();
    public XmlElement get_TokenXml();
    public SecurityToken get_ProofToken();
    public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual string ToString();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.InMemorySymmetricSecurityKey : SymmetricSecurityKey {
    public int KeySize { get; }
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey);
    public InMemorySymmetricSecurityKey(Byte[] symmetricKey, bool cloneBuffer);
    public virtual int get_KeySize();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public virtual int GetIVSize(string algorithm);
    public virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public virtual Byte[] GetSymmetricKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public abstract class System.IdentityModel.Tokens.IssuerNameRegistry : object {
    public abstract virtual string GetIssuerName(SecurityToken securityToken);
    public virtual string GetIssuerName(SecurityToken securityToken, string requestedIssuerName);
    public virtual string GetWindowsIssuerName();
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
}
public class System.IdentityModel.Tokens.IssuerTokenResolver : SecurityTokenResolver {
    public static StoreName DefaultStoreName;
    public static StoreLocation DefaultStoreLocation;
    internal static IssuerTokenResolver DefaultInstance;
    public SecurityTokenResolver WrappedTokenResolver { get; }
    public IssuerTokenResolver(SecurityTokenResolver wrappedTokenResolver);
    private static IssuerTokenResolver();
    public SecurityTokenResolver get_WrappedTokenResolver();
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
}
public class System.IdentityModel.Tokens.KerberosReceiverSecurityToken : WindowsSecurityToken {
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SymmetricSecurityKey SecurityKey { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public string ValueTypeUri { get; }
    public KerberosReceiverSecurityToken(Byte[] request);
    public KerberosReceiverSecurityToken(Byte[] request, string id);
    public KerberosReceiverSecurityToken(Byte[] request, string id, string valueTypeUri);
    internal KerberosReceiverSecurityToken(Byte[] request, string id, bool doAuthenticate, string valueTypeUri);
    internal KerberosReceiverSecurityToken(Byte[] request, string id, bool doAuthenticate, string valueTypeUri, ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy);
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public SymmetricSecurityKey get_SecurityKey();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual WindowsIdentity get_WindowsIdentity();
    public string get_ValueTypeUri();
    public Byte[] GetRequest();
    internal void Initialize(SafeFreeCredentials credentialsHandle, ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy);
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.KerberosRequestorSecurityToken : SecurityToken {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string ServicePrincipalName { get; }
    public SymmetricSecurityKey SecurityKey { get; }
    public KerberosRequestorSecurityToken(string servicePrincipalName);
    public KerberosRequestorSecurityToken(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id);
    internal KerberosRequestorSecurityToken(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id, ChannelBinding channelBinding);
    internal KerberosRequestorSecurityToken(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id, SafeFreeCredentials credentialsHandle, ChannelBinding channelBinding);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_ServicePrincipalName();
    public SymmetricSecurityKey get_SecurityKey();
    public Byte[] GetRequest();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.KerberosSecurityTokenHandler : SecurityTokenHandler {
    public bool CanValidateToken { get; }
    public Type TokenType { get; }
    private static KerberosSecurityTokenHandler();
    public virtual bool get_CanValidateToken();
    public virtual Type get_TokenType();
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
}
public class System.IdentityModel.Tokens.KerberosTicketHashKeyIdentifierClause : BinaryKeyIdentifierClause {
    public KerberosTicketHashKeyIdentifierClause(Byte[] ticketHash);
    public KerberosTicketHashKeyIdentifierClause(Byte[] ticketHash, Byte[] derivationNonce, int derivationLength);
    internal KerberosTicketHashKeyIdentifierClause(Byte[] ticketHash, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetKerberosTicketHash();
    public virtual string ToString();
}
internal class System.IdentityModel.Tokens.KeyInfoSerializer : SecurityTokenSerializer {
    public DictionaryManager DictionaryManager { get; }
    public bool EmitBspRequiredAttributes { get; }
    public SecurityTokenSerializer InnerSecurityTokenSerializer { get; public set; }
    public KeyInfoSerializer(bool emitBspRequiredAttributes);
    public KeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer);
    public KeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer, Func`2<KeyInfoSerializer, IEnumerable`1<SerializerEntries>> additionalEntries);
    public DictionaryManager get_DictionaryManager();
    public bool get_EmitBspRequiredAttributes();
    public SecurityTokenSerializer get_InnerSecurityTokenSerializer();
    public void set_InnerSecurityTokenSerializer(SecurityTokenSerializer value);
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    internal void PopulateStrEntries(IList`1<StrEntry> strEntries);
    internal Type[] GetTokenTypes(string tokenTypeUri);
    protected internal virtual string GetTokenTypeUri(Type tokenType);
}
public class System.IdentityModel.Tokens.LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
    public string LocalId { get; }
    public Type OwnerType { get; }
    public LocalIdKeyIdentifierClause(string localId);
    public LocalIdKeyIdentifierClause(string localId, Type ownerType);
    public LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type ownerType);
    internal LocalIdKeyIdentifierClause(string localId, Type[] ownerTypes);
    internal LocalIdKeyIdentifierClause(string localId, Byte[] derivationNonce, int derivationLength, Type[] ownerTypes);
    public string get_LocalId();
    public Type get_OwnerType();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(string localId, Type ownerType);
    public virtual string ToString();
}
internal class System.IdentityModel.Tokens.MruSessionSecurityTokenCache : SessionSecurityTokenCache {
    public static int DefaultTokenCacheSize;
    public static TimeSpan DefaultPurgeInterval;
    public int MaximumSize { get; }
    public MruSessionSecurityTokenCache(int maximumSize);
    public MruSessionSecurityTokenCache(int maximumSize, IEqualityComparer`1<SessionSecurityTokenCacheKey> comparer);
    public MruSessionSecurityTokenCache(int sizeAfterPurge, int maximumSize);
    public MruSessionSecurityTokenCache(int sizeAfterPurge, int maximumSize, IEqualityComparer`1<SessionSecurityTokenCacheKey> comparer);
    private static MruSessionSecurityTokenCache();
    public int get_MaximumSize();
    public virtual void Remove(SessionSecurityTokenCacheKey key);
    public virtual void AddOrUpdate(SessionSecurityTokenCacheKey key, SessionSecurityToken value, DateTime expirationTime);
    public virtual SessionSecurityToken Get(SessionSecurityTokenCacheKey key);
    public virtual void RemoveAll(string endpointId, UniqueId contextId);
    public virtual void RemoveAll(string endpointId);
    public virtual IEnumerable`1<SessionSecurityToken> GetAll(string endpointId, UniqueId contextId);
}
public abstract class System.IdentityModel.Tokens.ProofDescriptor : object {
    public SecurityKeyIdentifier KeyIdentifier { get; }
    public abstract virtual void ApplyTo(RequestSecurityTokenResponse response);
    public abstract virtual SecurityKeyIdentifier get_KeyIdentifier();
}
public class System.IdentityModel.Tokens.RsaKeyIdentifierClause : SecurityKeyIdentifierClause {
    public bool CanCreateKey { get; }
    public RSA Rsa { get; }
    public RsaKeyIdentifierClause(RSA rsa);
    private static RsaKeyIdentifierClause();
    public virtual bool get_CanCreateKey();
    public RSA get_Rsa();
    public virtual SecurityKey CreateKey();
    public Byte[] GetExponent();
    public Byte[] GetModulus();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(RSA rsa);
    public virtual string ToString();
    public void WriteExponentAsBase64(XmlWriter writer);
    public void WriteModulusAsBase64(XmlWriter writer);
}
public class System.IdentityModel.Tokens.RsaSecurityKey : AsymmetricSecurityKey {
    public int KeySize { get; }
    public RsaSecurityKey(RSA rsa);
    public virtual int get_KeySize();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool requiresPrivateKey);
    public virtual HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
    public virtual AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
    public virtual AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
    public virtual bool HasPrivateKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.RsaSecurityToken : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public RSA Rsa { get; }
    public RsaSecurityToken(RSA rsa);
    public RsaSecurityToken(RSA rsa, string id);
    protected virtual override void Finalize();
    internal void Dispose();
    internal static RsaSecurityToken CreateSafeRsaSecurityToken(int keySize);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public RSA get_Rsa();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.RsaSecurityTokenHandler : SecurityTokenHandler {
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public Type TokenType { get; }
    private static RsaSecurityTokenHandler();
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual Type get_TokenType();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
}
public class System.IdentityModel.Tokens.Saml2Action : object {
    public Uri Namespace { get; public set; }
    public string Value { get; public set; }
    public Saml2Action(string value, Uri actionNamespace);
    public Uri get_Namespace();
    public void set_Namespace(Uri value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.IdentityModel.Tokens.Saml2Advice : object {
    public Collection`1<Saml2Id> AssertionIdReferences { get; }
    public Collection`1<Saml2Assertion> Assertions { get; }
    public Collection`1<Uri> AssertionUriReferences { get; }
    public Collection`1<Saml2Id> get_AssertionIdReferences();
    public Collection`1<Saml2Assertion> get_Assertions();
    public Collection`1<Uri> get_AssertionUriReferences();
}
public class System.IdentityModel.Tokens.Saml2Assertion : object {
    public Saml2Advice Advice { get; public set; }
    public bool CanWriteSourceData { get; }
    public Saml2Conditions Conditions { get; public set; }
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public Collection`1<EncryptedKeyIdentifierClause> ExternalEncryptedKeys { get; }
    public Saml2Id Id { get; public set; }
    public DateTime IssueInstant { get; public set; }
    public Saml2NameIdentifier Issuer { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public Saml2Subject Subject { get; public set; }
    public Collection`1<Saml2Statement> Statements { get; }
    public string Version { get; }
    public Saml2Assertion(Saml2NameIdentifier issuer);
    public Saml2Advice get_Advice();
    public void set_Advice(Saml2Advice value);
    public virtual bool get_CanWriteSourceData();
    public Saml2Conditions get_Conditions();
    public void set_Conditions(Saml2Conditions value);
    public EncryptingCredentials get_EncryptingCredentials();
    public void set_EncryptingCredentials(EncryptingCredentials value);
    public Collection`1<EncryptedKeyIdentifierClause> get_ExternalEncryptedKeys();
    public Saml2Id get_Id();
    public void set_Id(Saml2Id value);
    public DateTime get_IssueInstant();
    public void set_IssueInstant(DateTime value);
    public Saml2NameIdentifier get_Issuer();
    public void set_Issuer(Saml2NameIdentifier value);
    public SigningCredentials get_SigningCredentials();
    public void set_SigningCredentials(SigningCredentials value);
    public Saml2Subject get_Subject();
    public void set_Subject(Saml2Subject value);
    public Collection`1<Saml2Statement> get_Statements();
    public string get_Version();
    public virtual void WriteSourceData(XmlWriter writer);
    internal virtual void CaptureSourceData(EnvelopedSignatureReader reader);
}
public class System.IdentityModel.Tokens.Saml2AssertionKeyIdentifierClause : SecurityKeyIdentifierClause {
    public Saml2AssertionKeyIdentifierClause(string id);
    public Saml2AssertionKeyIdentifierClause(string id, Byte[] derivationNonce, int derivationLength);
    public static bool Matches(string assertionId, SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.Saml2Attribute : object {
    public string FriendlyName { get; public set; }
    public string Name { get; public set; }
    public Uri NameFormat { get; public set; }
    public string OriginalIssuer { get; public set; }
    public string AttributeValueXsiType { get; public set; }
    public Collection`1<string> Values { get; }
    public Saml2Attribute(string name);
    public Saml2Attribute(string name, IEnumerable`1<string> values);
    public Saml2Attribute(string name, string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public string get_Name();
    public void set_Name(string value);
    public Uri get_NameFormat();
    public void set_NameFormat(Uri value);
    public string get_OriginalIssuer();
    public void set_OriginalIssuer(string value);
    public string get_AttributeValueXsiType();
    public void set_AttributeValueXsiType(string value);
    public Collection`1<string> get_Values();
}
public class System.IdentityModel.Tokens.Saml2AttributeStatement : Saml2Statement {
    public Collection`1<Saml2Attribute> Attributes { get; }
    public Saml2AttributeStatement(Saml2Attribute attribute);
    public Saml2AttributeStatement(IEnumerable`1<Saml2Attribute> attributes);
    public Collection`1<Saml2Attribute> get_Attributes();
}
public class System.IdentityModel.Tokens.Saml2AudienceRestriction : object {
    public Collection`1<Uri> Audiences { get; }
    public Saml2AudienceRestriction(Uri audience);
    public Saml2AudienceRestriction(IEnumerable`1<Uri> audiences);
    public Collection`1<Uri> get_Audiences();
}
public class System.IdentityModel.Tokens.Saml2AuthenticationContext : object {
    public Collection`1<Uri> AuthenticatingAuthorities { get; }
    public Uri ClassReference { get; public set; }
    public Uri DeclarationReference { get; public set; }
    public Saml2AuthenticationContext(Uri classReference);
    public Saml2AuthenticationContext(Uri classReference, Uri declarationReference);
    public Collection`1<Uri> get_AuthenticatingAuthorities();
    public Uri get_ClassReference();
    public void set_ClassReference(Uri value);
    public Uri get_DeclarationReference();
    public void set_DeclarationReference(Uri value);
}
public class System.IdentityModel.Tokens.Saml2AuthenticationStatement : Saml2Statement {
    public Saml2AuthenticationContext AuthenticationContext { get; public set; }
    public DateTime AuthenticationInstant { get; public set; }
    public string SessionIndex { get; public set; }
    public Nullable`1<DateTime> SessionNotOnOrAfter { get; public set; }
    public Saml2SubjectLocality SubjectLocality { get; public set; }
    public Saml2AuthenticationStatement(Saml2AuthenticationContext authenticationContext);
    public Saml2AuthenticationStatement(Saml2AuthenticationContext authenticationContext, DateTime authenticationInstant);
    public Saml2AuthenticationContext get_AuthenticationContext();
    public void set_AuthenticationContext(Saml2AuthenticationContext value);
    public DateTime get_AuthenticationInstant();
    public void set_AuthenticationInstant(DateTime value);
    public string get_SessionIndex();
    public void set_SessionIndex(string value);
    public Nullable`1<DateTime> get_SessionNotOnOrAfter();
    public void set_SessionNotOnOrAfter(Nullable`1<DateTime> value);
    public Saml2SubjectLocality get_SubjectLocality();
    public void set_SubjectLocality(Saml2SubjectLocality value);
}
public class System.IdentityModel.Tokens.Saml2AuthorizationDecisionStatement : Saml2Statement {
    public static Uri EmptyResource;
    public Collection`1<Saml2Action> Actions { get; }
    public SamlAccessDecision Decision { get; public set; }
    public Saml2Evidence Evidence { get; public set; }
    public Uri Resource { get; public set; }
    public Saml2AuthorizationDecisionStatement(Uri resource, SamlAccessDecision decision);
    public Saml2AuthorizationDecisionStatement(Uri resource, SamlAccessDecision decision, IEnumerable`1<Saml2Action> actions);
    private static Saml2AuthorizationDecisionStatement();
    public Collection`1<Saml2Action> get_Actions();
    public SamlAccessDecision get_Decision();
    public void set_Decision(SamlAccessDecision value);
    public Saml2Evidence get_Evidence();
    public void set_Evidence(Saml2Evidence value);
    public Uri get_Resource();
    public void set_Resource(Uri value);
}
public class System.IdentityModel.Tokens.Saml2Conditions : object {
    public Collection`1<Saml2AudienceRestriction> AudienceRestrictions { get; }
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public Nullable`1<DateTime> NotOnOrAfter { get; public set; }
    public bool OneTimeUse { get; public set; }
    public Saml2ProxyRestriction ProxyRestriction { get; public set; }
    public Collection`1<Saml2AudienceRestriction> get_AudienceRestrictions();
    public Nullable`1<DateTime> get_NotBefore();
    public void set_NotBefore(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_NotOnOrAfter();
    public void set_NotOnOrAfter(Nullable`1<DateTime> value);
    public bool get_OneTimeUse();
    public void set_OneTimeUse(bool value);
    public Saml2ProxyRestriction get_ProxyRestriction();
    public void set_ProxyRestriction(Saml2ProxyRestriction value);
}
internal static class System.IdentityModel.Tokens.Saml2Constants : object {
    public static string Prefix;
    public static string Namespace;
}
public class System.IdentityModel.Tokens.Saml2Evidence : object {
    public Collection`1<Saml2Id> AssertionIdReferences { get; }
    public Collection`1<Saml2Assertion> Assertions { get; }
    public Collection`1<Uri> AssertionUriReferences { get; }
    public Saml2Evidence(Saml2Assertion assertion);
    public Saml2Evidence(Saml2Id idReference);
    public Saml2Evidence(Uri uriReference);
    public Collection`1<Saml2Id> get_AssertionIdReferences();
    public Collection`1<Saml2Assertion> get_Assertions();
    public Collection`1<Uri> get_AssertionUriReferences();
}
public class System.IdentityModel.Tokens.Saml2Id : object {
    public string Value { get; }
    public Saml2Id(string value);
    public string get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.Saml2NameIdentifier : object {
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public Collection`1<EncryptedKeyIdentifierClause> ExternalEncryptedKeys { get; }
    public Uri Format { get; public set; }
    public string NameQualifier { get; public set; }
    public string SPNameQualifier { get; public set; }
    public string SPProvidedId { get; public set; }
    public string Value { get; public set; }
    public Saml2NameIdentifier(string name);
    public Saml2NameIdentifier(string name, Uri format);
    public EncryptingCredentials get_EncryptingCredentials();
    public void set_EncryptingCredentials(EncryptingCredentials value);
    public Collection`1<EncryptedKeyIdentifierClause> get_ExternalEncryptedKeys();
    public Uri get_Format();
    public void set_Format(Uri value);
    public string get_NameQualifier();
    public void set_NameQualifier(string value);
    public string get_SPNameQualifier();
    public void set_SPNameQualifier(string value);
    public string get_SPProvidedId();
    public void set_SPProvidedId(string value);
    public string get_Value();
    public void set_Value(string value);
}
public class System.IdentityModel.Tokens.Saml2ProxyRestriction : object {
    public Collection`1<Uri> Audiences { get; }
    public Nullable`1<int> Count { get; public set; }
    public Collection`1<Uri> get_Audiences();
    public Nullable`1<int> get_Count();
    public void set_Count(Nullable`1<int> value);
}
public class System.IdentityModel.Tokens.Saml2SecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
    public Saml2Assertion Assertion { get; }
    public Saml2SecurityKeyIdentifierClause(Saml2Assertion assertion);
    public Saml2Assertion get_Assertion();
}
public class System.IdentityModel.Tokens.Saml2SecurityToken : SecurityToken {
    public Saml2Assertion Assertion { get; }
    public string Id { get; }
    public SecurityToken IssuerToken { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public Saml2SecurityToken(Saml2Assertion assertion);
    public Saml2SecurityToken(Saml2Assertion assertion, ReadOnlyCollection`1<SecurityKey> keys, SecurityToken issuerToken);
    public Saml2Assertion get_Assertion();
    public virtual string get_Id();
    public SecurityToken get_IssuerToken();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
}
public class System.IdentityModel.Tokens.Saml2SecurityTokenHandler : SecurityTokenHandler {
    public static string TokenProfile11ValueType;
    public bool CanValidateToken { get; }
    public Type TokenType { get; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public SecurityTokenSerializer KeyInfoSerializer { get; public set; }
    public bool CanWriteToken { get; }
    public SamlSecurityTokenRequirement SamlSecurityTokenRequirement { get; public set; }
    public Saml2SecurityTokenHandler(SamlSecurityTokenRequirement samlSecurityTokenRequirement);
    private static Saml2SecurityTokenHandler();
    public virtual void LoadCustomConfiguration(XmlNodeList customConfigElements);
    public virtual bool get_CanValidateToken();
    public virtual Type get_TokenType();
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    public SecurityTokenSerializer get_KeyInfoSerializer();
    public void set_KeyInfoSerializer(SecurityTokenSerializer value);
    public virtual bool get_CanWriteToken();
    public SamlSecurityTokenRequirement get_SamlSecurityTokenRequirement();
    public void set_SamlSecurityTokenRequirement(SamlSecurityTokenRequirement value);
    public virtual SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached);
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    protected virtual WindowsIdentity CreateWindowsIdentity(string upn);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public virtual bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause);
    internal static XmlDictionaryReader CreatePlaintextReaderFromEncryptedData(XmlDictionaryReader reader, SecurityTokenResolver serviceTokenResolver, SecurityTokenSerializer keyInfoSerializer, Collection`1<EncryptedKeyIdentifierClause> clauses, EncryptingCredentials& encryptingCredentials);
    internal static Exception TryWrapReadException(XmlReader reader, Exception inner);
    internal static bool IsSaml2KeyIdentifierClause(XmlReader reader);
    internal static bool IsSaml2Assertion(XmlReader reader);
    internal static void ReadEmptyContentElement(XmlReader reader);
    internal static Saml2Id ReadSimpleNCNameElement(XmlReader reader);
    internal static Uri ReadSimpleUriElement(XmlReader reader);
    internal static Uri ReadSimpleUriElement(XmlReader reader, UriKind kind);
    internal static Uri ReadSimpleUriElement(XmlReader reader, UriKind kind, bool allowLaxReading);
    protected virtual Saml2Conditions CreateConditions(Lifetime tokenLifetime, string relyingPartyAddress, SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2Advice CreateAdvice(SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2NameIdentifier CreateIssuerNameIdentifier(SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2Attribute CreateAttribute(Claim claim, SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2AttributeStatement CreateAttributeStatement(ClaimsIdentity subject, SecurityTokenDescriptor tokenDescriptor);
    protected virtual ICollection`1<Saml2Attribute> CollectAttributeValues(ICollection`1<Saml2Attribute> attributes);
    protected virtual void AddDelegateToAttributes(ClaimsIdentity subject, ICollection`1<Saml2Attribute> attributes, SecurityTokenDescriptor tokenDescriptor);
    protected virtual string CreateXmlStringFromAttributes(IEnumerable`1<Saml2Attribute> attributes);
    protected virtual IEnumerable`1<Saml2Statement> CreateStatements(SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2AuthenticationStatement CreateAuthenticationStatement(AuthenticationInformation authInfo, SecurityTokenDescriptor tokenDescriptor);
    protected virtual Saml2Subject CreateSamlSubject(SecurityTokenDescriptor tokenDescriptor);
    protected virtual EncryptingCredentials GetEncryptingCredentials(SecurityTokenDescriptor tokenDescriptor);
    protected virtual SigningCredentials GetSigningCredentials(SecurityTokenDescriptor tokenDescriptor);
    protected virtual void ValidateConditions(Saml2Conditions conditions, bool enforceAudienceRestriction);
    protected virtual string FindUpn(ClaimsIdentity claimsIdentity);
    protected virtual string DenormalizeAuthenticationType(string normalizedAuthenticationType);
    protected virtual void DetectReplayedToken(SecurityToken token);
    protected virtual DateTime GetTokenReplayCacheEntryExpirationTime(Saml2SecurityToken token);
    protected virtual string NormalizeAuthenticationContextClassReference(string saml2AuthenticationContextClassReference);
    protected virtual void ProcessSamlSubject(Saml2Subject assertionSubject, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAttributeStatement(Saml2AttributeStatement statement, ClaimsIdentity subject, string issuer);
    protected virtual void SetDelegateFromAttribute(Saml2Attribute attribute, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAuthenticationStatement(Saml2AuthenticationStatement statement, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAuthorizationDecisionStatement(Saml2AuthorizationDecisionStatement statement, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessStatement(Collection`1<Saml2Statement> statements, ClaimsIdentity subject, string issuer);
    protected virtual ClaimsIdentity CreateClaims(Saml2SecurityToken samlToken);
    protected virtual void ValidateConfirmationData(Saml2SubjectConfirmationData confirmationData);
    protected virtual ReadOnlyCollection`1<SecurityKey> ResolveSecurityKeys(Saml2Assertion assertion, SecurityTokenResolver resolver);
    protected virtual SecurityToken ResolveIssuerToken(Saml2Assertion assertion, SecurityTokenResolver issuerResolver);
    protected virtual bool TryResolveIssuerToken(Saml2Assertion assertion, SecurityTokenResolver issuerResolver, SecurityToken& token);
    protected virtual Saml2NameIdentifier ReadSubjectId(XmlReader reader, string parentElement);
    protected virtual Saml2Action ReadAction(XmlReader reader);
    protected virtual void WriteAction(XmlWriter writer, Saml2Action data);
    protected virtual Saml2Advice ReadAdvice(XmlReader reader);
    protected virtual void WriteAdvice(XmlWriter writer, Saml2Advice data);
    protected virtual Saml2Assertion ReadAssertion(XmlReader reader);
    protected virtual void WriteAssertion(XmlWriter writer, Saml2Assertion data);
    protected virtual Saml2Attribute ReadAttribute(XmlReader reader);
    protected virtual string ReadAttributeValue(XmlReader reader, Saml2Attribute attribute);
    protected virtual void WriteAttribute(XmlWriter writer, Saml2Attribute data);
    protected virtual void WriteAttributeValue(XmlWriter writer, string value, Saml2Attribute attribute);
    protected virtual Saml2AttributeStatement ReadAttributeStatement(XmlReader reader);
    protected virtual void WriteAttributeStatement(XmlWriter writer, Saml2AttributeStatement data);
    protected virtual Saml2AudienceRestriction ReadAudienceRestriction(XmlReader reader);
    protected virtual void WriteAudienceRestriction(XmlWriter writer, Saml2AudienceRestriction data);
    protected virtual Saml2AuthenticationContext ReadAuthenticationContext(XmlReader reader);
    protected virtual void WriteAuthenticationContext(XmlWriter writer, Saml2AuthenticationContext data);
    protected virtual Saml2AuthenticationStatement ReadAuthenticationStatement(XmlReader reader);
    protected virtual void WriteAuthenticationStatement(XmlWriter writer, Saml2AuthenticationStatement data);
    protected virtual Saml2AuthorizationDecisionStatement ReadAuthorizationDecisionStatement(XmlReader reader);
    protected virtual void WriteAuthorizationDecisionStatement(XmlWriter writer, Saml2AuthorizationDecisionStatement data);
    protected virtual Saml2Conditions ReadConditions(XmlReader reader);
    protected virtual void WriteConditions(XmlWriter writer, Saml2Conditions data);
    protected virtual Saml2Evidence ReadEvidence(XmlReader reader);
    protected virtual void WriteEvidence(XmlWriter writer, Saml2Evidence data);
    protected virtual Saml2NameIdentifier ReadIssuer(XmlReader reader);
    protected virtual void WriteIssuer(XmlWriter writer, Saml2NameIdentifier data);
    protected virtual SecurityKeyIdentifier ReadSubjectKeyInfo(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadSigningKeyInfo(XmlReader reader, Saml2Assertion assertion);
    protected virtual void WriteSubjectKeyInfo(XmlWriter writer, SecurityKeyIdentifier data);
    protected virtual void WriteSigningKeyInfo(XmlWriter writer, SecurityKeyIdentifier data);
    protected virtual Saml2NameIdentifier ReadNameId(XmlReader reader);
    protected virtual void WriteNameId(XmlWriter writer, Saml2NameIdentifier data);
    protected virtual Saml2NameIdentifier ReadNameIdType(XmlReader reader);
    protected virtual Saml2NameIdentifier ReadEncryptedId(XmlReader reader);
    protected virtual void WriteNameIdType(XmlWriter writer, Saml2NameIdentifier data);
    protected virtual Saml2ProxyRestriction ReadProxyRestriction(XmlReader reader);
    protected virtual void WriteProxyRestriction(XmlWriter writer, Saml2ProxyRestriction data);
    protected virtual Saml2Statement ReadStatement(XmlReader reader);
    protected virtual void WriteStatement(XmlWriter writer, Saml2Statement data);
    protected virtual Saml2Subject ReadSubject(XmlReader reader);
    protected virtual void WriteSubject(XmlWriter writer, Saml2Subject data);
    protected virtual Saml2SubjectConfirmation ReadSubjectConfirmation(XmlReader reader);
    protected virtual void WriteSubjectConfirmation(XmlWriter writer, Saml2SubjectConfirmation data);
    protected virtual Saml2SubjectConfirmationData ReadSubjectConfirmationData(XmlReader reader);
    protected virtual void WriteSubjectConfirmationData(XmlWriter writer, Saml2SubjectConfirmationData data);
    protected virtual Saml2SubjectLocality ReadSubjectLocality(XmlReader reader);
    protected virtual void WriteSubjectLocality(XmlWriter writer, Saml2SubjectLocality data);
}
public abstract class System.IdentityModel.Tokens.Saml2Statement : object {
}
public class System.IdentityModel.Tokens.Saml2Subject : object {
    public Saml2NameIdentifier NameId { get; public set; }
    public Collection`1<Saml2SubjectConfirmation> SubjectConfirmations { get; }
    public Saml2Subject(Saml2NameIdentifier nameId);
    public Saml2Subject(Saml2SubjectConfirmation subjectConfirmation);
    public Saml2NameIdentifier get_NameId();
    public void set_NameId(Saml2NameIdentifier value);
    public Collection`1<Saml2SubjectConfirmation> get_SubjectConfirmations();
}
public class System.IdentityModel.Tokens.Saml2SubjectConfirmation : object {
    public Uri Method { get; public set; }
    public Saml2NameIdentifier NameIdentifier { get; public set; }
    public Saml2SubjectConfirmationData SubjectConfirmationData { get; public set; }
    public Saml2SubjectConfirmation(Uri method);
    public Saml2SubjectConfirmation(Uri method, Saml2SubjectConfirmationData data);
    public Uri get_Method();
    public void set_Method(Uri value);
    public Saml2NameIdentifier get_NameIdentifier();
    public void set_NameIdentifier(Saml2NameIdentifier value);
    public Saml2SubjectConfirmationData get_SubjectConfirmationData();
    public void set_SubjectConfirmationData(Saml2SubjectConfirmationData value);
}
public class System.IdentityModel.Tokens.Saml2SubjectConfirmationData : object {
    public string Address { get; public set; }
    public Saml2Id InResponseTo { get; public set; }
    public Collection`1<SecurityKeyIdentifier> KeyIdentifiers { get; }
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public Nullable`1<DateTime> NotOnOrAfter { get; public set; }
    public Uri Recipient { get; public set; }
    public string get_Address();
    public void set_Address(string value);
    public Saml2Id get_InResponseTo();
    public void set_InResponseTo(Saml2Id value);
    public Collection`1<SecurityKeyIdentifier> get_KeyIdentifiers();
    public Nullable`1<DateTime> get_NotBefore();
    public void set_NotBefore(Nullable`1<DateTime> value);
    public Nullable`1<DateTime> get_NotOnOrAfter();
    public void set_NotOnOrAfter(Nullable`1<DateTime> value);
    public Uri get_Recipient();
    public void set_Recipient(Uri value);
}
public class System.IdentityModel.Tokens.Saml2SubjectLocality : object {
    public string Address { get; public set; }
    public string DnsName { get; public set; }
    public Saml2SubjectLocality(string address, string dnsName);
    public string get_Address();
    public void set_Address(string value);
    public string get_DnsName();
    public void set_DnsName(string value);
}
[DataContractAttribute]
public enum System.IdentityModel.Tokens.SamlAccessDecision : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SamlAccessDecision Permit;
    [EnumMemberAttribute]
public static SamlAccessDecision Deny;
    [EnumMemberAttribute]
public static SamlAccessDecision Indeterminate;
}
public class System.IdentityModel.Tokens.SamlAction : object {
    public string Action { get; public set; }
    public string Namespace { get; public set; }
    public bool IsReadOnly { get; }
    public SamlAction(string action);
    public SamlAction(string action, string ns);
    public string get_Action();
    public void set_Action(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public class System.IdentityModel.Tokens.SamlAdvice : object {
    public IList`1<string> AssertionIdReferences { get; }
    public IList`1<SamlAssertion> Assertions { get; }
    public bool IsReadOnly { get; }
    public SamlAdvice(IEnumerable`1<string> references);
    public SamlAdvice(IEnumerable`1<SamlAssertion> assertions);
    public SamlAdvice(IEnumerable`1<string> references, IEnumerable`1<SamlAssertion> assertions);
    public IList`1<string> get_AssertionIdReferences();
    public IList`1<SamlAssertion> get_Assertions();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public class System.IdentityModel.Tokens.SamlAssertion : object {
    public int MinorVersion { get; }
    public int MajorVersion { get; }
    public string AssertionId { get; public set; }
    public bool CanWriteSourceData { get; }
    public string Issuer { get; public set; }
    public DateTime IssueInstant { get; public set; }
    public SamlConditions Conditions { get; public set; }
    public SamlAdvice Advice { get; public set; }
    public IList`1<SamlStatement> Statements { get; }
    public SigningCredentials SigningCredentials { get; public set; }
    internal SignedXml Signature { get; }
    internal SecurityKey SignatureVerificationKey { get; }
    public SecurityToken SigningToken { get; public set; }
    public bool IsReadOnly { get; }
    internal ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SamlAssertion(string assertionId, string issuer, DateTime issueInstant, SamlConditions samlConditions, SamlAdvice samlAdvice, IEnumerable`1<SamlStatement> samlStatements);
    public int get_MinorVersion();
    public int get_MajorVersion();
    public string get_AssertionId();
    public void set_AssertionId(string value);
    public virtual bool get_CanWriteSourceData();
    public string get_Issuer();
    public void set_Issuer(string value);
    public DateTime get_IssueInstant();
    public void set_IssueInstant(DateTime value);
    public SamlConditions get_Conditions();
    public void set_Conditions(SamlConditions value);
    public SamlAdvice get_Advice();
    public void set_Advice(SamlAdvice value);
    public IList`1<SamlStatement> get_Statements();
    public SigningCredentials get_SigningCredentials();
    public void set_SigningCredentials(SigningCredentials value);
    internal SignedXml get_Signature();
    internal SecurityKey get_SignatureVerificationKey();
    public SecurityToken get_SigningToken();
    public void set_SigningToken(SecurityToken value);
    public bool get_IsReadOnly();
    internal ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public void MakeReadOnly();
    internal virtual void CaptureSourceData(EnvelopedSignatureReader reader);
    protected void ReadSignature(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver, SamlSerializer samlSerializer);
    private sealed virtual override void System.IdentityModel.ICanonicalWriterEndRootElementCallback.OnEndOfRootElement(XmlDictionaryWriter dictionaryWriter);
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    internal void WriteTo(XmlWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
    public virtual void WriteSourceData(XmlWriter writer);
    internal static void AddSamlClaimTypes(ICollection`1<Type> knownClaimTypes);
}
public class System.IdentityModel.Tokens.SamlAssertionKeyIdentifierClause : SecurityKeyIdentifierClause {
    public string AssertionId { get; }
    internal string TokenTypeUri { get; }
    internal string ValueType { get; }
    internal string Binding { get; }
    internal string Location { get; }
    internal string AuthorityKind { get; }
    public SamlAssertionKeyIdentifierClause(string assertionId);
    public SamlAssertionKeyIdentifierClause(string assertionId, Byte[] derivationNonce, int derivationLength);
    internal SamlAssertionKeyIdentifierClause(string assertionId, Byte[] derivationNonce, int derivationLength, string valueType, string tokenTypeUri, string binding, string location, string authorityKind);
    public string get_AssertionId();
    internal string get_TokenTypeUri();
    internal string get_ValueType();
    internal string get_Binding();
    internal string get_Location();
    internal string get_AuthorityKind();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(string assertionId);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.SamlAttribute : object {
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IList`1<string> AttributeValues { get; }
    public string OriginalIssuer { get; public set; }
    public string AttributeValueXsiType { get; public set; }
    public bool IsReadOnly { get; }
    public SamlAttribute(string attributeNamespace, string attributeName, IEnumerable`1<string> attributeValues);
    public SamlAttribute(Claim claim);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public IList`1<string> get_AttributeValues();
    public string get_OriginalIssuer();
    public void set_OriginalIssuer(string value);
    public string get_AttributeValueXsiType();
    public void set_AttributeValueXsiType(string value);
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual ReadOnlyCollection`1<Claim> ExtractClaims();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
internal class System.IdentityModel.Tokens.SamlAttributeKeyComparer : object {
    public sealed virtual bool Equals(AttributeKey x, AttributeKey y);
    public sealed virtual int GetHashCode(AttributeKey obj);
}
public class System.IdentityModel.Tokens.SamlAttributeStatement : SamlSubjectStatement {
    public IList`1<SamlAttribute> Attributes { get; }
    public bool IsReadOnly { get; }
    public SamlAttributeStatement(SamlSubject samlSubject, IEnumerable`1<SamlAttribute> attributes);
    public IList`1<SamlAttribute> get_Attributes();
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
    protected virtual void AddClaimsToList(IList`1<Claim> claims);
}
public class System.IdentityModel.Tokens.SamlAudienceRestrictionCondition : SamlCondition {
    public IList`1<Uri> Audiences { get; }
    public bool IsReadOnly { get; }
    public SamlAudienceRestrictionCondition(IEnumerable`1<Uri> audiences);
    public IList`1<Uri> get_Audiences();
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
[DataContractAttribute]
public class System.IdentityModel.Tokens.SamlAuthenticationClaimResource : object {
    public DateTime AuthenticationInstant { get; }
    public string AuthenticationMethod { get; }
    public ReadOnlyCollection`1<SamlAuthorityBinding> AuthorityBindings { get; }
    public string IPAddress { get; }
    public string DnsAddress { get; }
    public SamlAuthenticationClaimResource(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress);
    public SamlAuthenticationClaimResource(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings);
    public SamlAuthenticationClaimResource(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, ReadOnlyCollection`1<SamlAuthorityBinding> authorityBindings);
    public DateTime get_AuthenticationInstant();
    public string get_AuthenticationMethod();
    public ReadOnlyCollection`1<SamlAuthorityBinding> get_AuthorityBindings();
    public string get_IPAddress();
    public string get_DnsAddress();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.IdentityModel.Tokens.SamlAuthenticationStatement : SamlSubjectStatement {
    public DateTime AuthenticationInstant { get; public set; }
    public string AuthenticationMethod { get; public set; }
    public static string ClaimType { get; }
    public IList`1<SamlAuthorityBinding> AuthorityBindings { get; }
    public string DnsAddress { get; public set; }
    public string IPAddress { get; public set; }
    public bool IsReadOnly { get; }
    public SamlAuthenticationStatement(SamlSubject samlSubject, string authenticationMethod, DateTime authenticationInstant, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings);
    public DateTime get_AuthenticationInstant();
    public void set_AuthenticationInstant(DateTime value);
    public string get_AuthenticationMethod();
    public void set_AuthenticationMethod(string value);
    public static string get_ClaimType();
    public IList`1<SamlAuthorityBinding> get_AuthorityBindings();
    public string get_DnsAddress();
    public void set_DnsAddress(string value);
    public string get_IPAddress();
    public void set_IPAddress(string value);
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    protected virtual void AddClaimsToList(IList`1<Claim> claims);
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
[DataContractAttribute]
public class System.IdentityModel.Tokens.SamlAuthorityBinding : object {
    [DataMemberAttribute]
public XmlQualifiedName AuthorityKind { get; public set; }
    [DataMemberAttribute]
public string Binding { get; public set; }
    [DataMemberAttribute]
public string Location { get; public set; }
    public bool IsReadOnly { get; }
    public SamlAuthorityBinding(XmlQualifiedName authorityKind, string binding, string location);
    public XmlQualifiedName get_AuthorityKind();
    public void set_AuthorityKind(XmlQualifiedName value);
    public string get_Binding();
    public void set_Binding(string value);
    public string get_Location();
    public void set_Location(string value);
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
[DataContractAttribute]
public class System.IdentityModel.Tokens.SamlAuthorizationDecisionClaimResource : object {
    public string Resource { get; }
    public SamlAccessDecision AccessDecision { get; }
    public string ActionNamespace { get; }
    public string ActionName { get; }
    public SamlAuthorizationDecisionClaimResource(string resource, SamlAccessDecision accessDecision, string actionNamespace, string actionName);
    public string get_Resource();
    public SamlAccessDecision get_AccessDecision();
    public string get_ActionNamespace();
    public string get_ActionName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.IdentityModel.Tokens.SamlAuthorizationDecisionStatement : SamlSubjectStatement {
    public static string ClaimType { get; }
    public IList`1<SamlAction> SamlActions { get; }
    public SamlAccessDecision AccessDecision { get; public set; }
    public SamlEvidence Evidence { get; public set; }
    public string Resource { get; public set; }
    public bool IsReadOnly { get; }
    public SamlAuthorizationDecisionStatement(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions);
    public SamlAuthorizationDecisionStatement(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions, SamlEvidence samlEvidence);
    public static string get_ClaimType();
    public IList`1<SamlAction> get_SamlActions();
    public SamlAccessDecision get_AccessDecision();
    public void set_AccessDecision(SamlAccessDecision value);
    public SamlEvidence get_Evidence();
    public void set_Evidence(SamlEvidence value);
    public string get_Resource();
    public void set_Resource(string value);
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    protected virtual void AddClaimsToList(IList`1<Claim> claims);
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public abstract class System.IdentityModel.Tokens.SamlCondition : object {
    public bool IsReadOnly { get; }
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void MakeReadOnly();
    public abstract virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public abstract virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public class System.IdentityModel.Tokens.SamlConditions : object {
    public IList`1<SamlCondition> Conditions { get; }
    public DateTime NotBefore { get; public set; }
    public DateTime NotOnOrAfter { get; public set; }
    public bool IsReadOnly { get; }
    public SamlConditions(DateTime notBefore, DateTime notOnOrAfter);
    public SamlConditions(DateTime notBefore, DateTime notOnOrAfter, IEnumerable`1<SamlCondition> conditions);
    public IList`1<SamlCondition> get_Conditions();
    public DateTime get_NotBefore();
    public void set_NotBefore(DateTime value);
    public DateTime get_NotOnOrAfter();
    public void set_NotOnOrAfter(DateTime value);
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public static class System.IdentityModel.Tokens.SamlConstants : object {
    public static string Prefix;
    internal static String[] AcceptedDateTimeFormats;
    internal static string AssertionIdPrefix;
    internal static string GeneratedDateTimeFormat;
    public static int MajorVersionValue { get; }
    public static int MinorVersionValue { get; }
    public static string Namespace { get; }
    public static string HolderOfKey { get; }
    public static string SenderVouches { get; }
    public static string UserName { get; }
    public static string UserNameNamespace { get; }
    public static string EmailName { get; }
    public static string EmailNamespace { get; }
    private static SamlConstants();
    public static int get_MajorVersionValue();
    public static int get_MinorVersionValue();
    public static string get_Namespace();
    public static string get_HolderOfKey();
    public static string get_SenderVouches();
    public static string get_UserName();
    public static string get_UserNameNamespace();
    public static string get_EmailName();
    public static string get_EmailNamespace();
}
public class System.IdentityModel.Tokens.SamlDoNotCacheCondition : SamlCondition {
    public bool IsReadOnly { get; }
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public class System.IdentityModel.Tokens.SamlEvidence : object {
    public IList`1<string> AssertionIdReferences { get; }
    public IList`1<SamlAssertion> Assertions { get; }
    public bool IsReadOnly { get; }
    public SamlEvidence(IEnumerable`1<string> assertionIdReferences);
    public SamlEvidence(IEnumerable`1<SamlAssertion> assertions);
    public SamlEvidence(IEnumerable`1<string> assertionIdReferences, IEnumerable`1<SamlAssertion> assertions);
    public IList`1<string> get_AssertionIdReferences();
    public IList`1<SamlAssertion> get_Assertions();
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
[DataContractAttribute]
public class System.IdentityModel.Tokens.SamlNameIdentifierClaimResource : object {
    public string NameQualifier { get; }
    public string Format { get; }
    public string Name { get; }
    public SamlNameIdentifierClaimResource(string name, string nameQualifier, string format);
    public string get_NameQualifier();
    public string get_Format();
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.IdentityModel.Tokens.SamlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
    public SamlAssertion Assertion { get; }
    public SamlSecurityKeyIdentifierClause(SamlAssertion assertion);
    public SamlAssertion get_Assertion();
}
public class System.IdentityModel.Tokens.SamlSecurityToken : SecurityToken {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public SamlAssertion Assertion { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public SamlSecurityToken(SamlAssertion assertion);
    protected void Initialize(SamlAssertion assertion);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public SamlAssertion get_Assertion();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.SamlSecurityTokenHandler : SecurityTokenHandler {
    public static string Namespace;
    public static string BearerConfirmationMethod;
    public static string UnspecifiedAuthenticationMethod;
    public static string Assertion;
    public bool CanValidateToken { get; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public bool CanWriteToken { get; }
    public SecurityTokenSerializer KeyInfoSerializer { get; public set; }
    public Type TokenType { get; }
    public SamlSecurityTokenRequirement SamlSecurityTokenRequirement { get; public set; }
    public SamlSecurityTokenHandler(SamlSecurityTokenRequirement samlSecurityTokenRequirement);
    private static SamlSecurityTokenHandler();
    public virtual void LoadCustomConfiguration(XmlNodeList customConfigElements);
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    protected virtual EncryptingCredentials GetEncryptingCredentials(SecurityTokenDescriptor tokenDescriptor);
    protected virtual SigningCredentials GetSigningCredentials(SecurityTokenDescriptor tokenDescriptor);
    protected virtual SamlAdvice CreateAdvice(SecurityTokenDescriptor tokenDescriptor);
    protected virtual SamlAssertion CreateAssertion(string issuer, SamlConditions conditions, SamlAdvice advice, IEnumerable`1<SamlStatement> statements);
    public virtual SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached);
    protected virtual SamlConditions CreateConditions(Lifetime tokenLifetime, string relyingPartyAddress, SecurityTokenDescriptor tokenDescriptor);
    protected virtual IEnumerable`1<SamlStatement> CreateStatements(SecurityTokenDescriptor tokenDescriptor);
    protected virtual SamlAuthenticationStatement CreateAuthenticationStatement(SamlSubject samlSubject, AuthenticationInformation authInfo, SecurityTokenDescriptor tokenDescriptor);
    protected virtual SamlAttributeStatement CreateAttributeStatement(SamlSubject samlSubject, ClaimsIdentity subject, SecurityTokenDescriptor tokenDescriptor);
    protected virtual ICollection`1<SamlAttribute> CollectAttributeValues(ICollection`1<SamlAttribute> attributes);
    protected virtual void AddDelegateToAttributes(ClaimsIdentity subject, ICollection`1<SamlAttribute> attributes, SecurityTokenDescriptor tokenDescriptor);
    protected virtual SamlSubject CreateSamlSubject(SecurityTokenDescriptor tokenDescriptor);
    protected virtual string CreateXmlStringFromAttributes(IEnumerable`1<SamlAttribute> attributes);
    protected virtual SamlAttribute CreateAttribute(Claim claim, SecurityTokenDescriptor tokenDescriptor);
    public virtual bool get_CanValidateToken();
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    protected virtual void DetectReplayedToken(SecurityToken token);
    protected virtual DateTime GetTokenReplayCacheEntryExpirationTime(SamlSecurityToken token);
    protected virtual void ValidateConditions(SamlConditions conditions, bool enforceAudienceRestriction);
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    protected virtual WindowsIdentity CreateWindowsIdentity(string upn);
    protected virtual string FindUpn(ClaimsIdentity claimsIdentity);
    protected virtual ClaimsIdentity CreateClaims(SamlSecurityToken samlSecurityToken);
    protected virtual string DenormalizeAuthenticationType(string normalizedAuthenticationType);
    protected virtual string NormalizeAuthenticationType(string saml11AuthenticationMethod);
    protected virtual void ProcessStatement(IList`1<SamlStatement> statements, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAttributeStatement(SamlAttributeStatement samlStatement, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessSamlSubject(SamlSubject samlSubject, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAuthenticationStatement(SamlAuthenticationStatement samlStatement, ClaimsIdentity subject, string issuer);
    protected virtual void ProcessAuthorizationDecisionStatement(SamlAuthorizationDecisionStatement samlStatement, ClaimsIdentity subject, string issuer);
    protected virtual void SetDelegateFromAttribute(SamlAttribute attribute, ClaimsIdentity subject, string issuer);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual SecurityToken ReadToken(XmlReader reader);
    protected virtual SamlAction ReadAction(XmlReader reader);
    protected virtual void WriteAction(XmlWriter writer, SamlAction action);
    protected virtual SamlAdvice ReadAdvice(XmlReader reader);
    protected virtual void WriteAdvice(XmlWriter writer, SamlAdvice advice);
    protected virtual SamlAssertion ReadAssertion(XmlReader reader);
    protected virtual void WriteAssertion(XmlWriter writer, SamlAssertion assertion);
    protected virtual SamlConditions ReadConditions(XmlReader reader);
    protected virtual void WriteConditions(XmlWriter writer, SamlConditions conditions);
    protected virtual SamlCondition ReadCondition(XmlReader reader);
    protected virtual void WriteCondition(XmlWriter writer, SamlCondition condition);
    protected virtual SamlAudienceRestrictionCondition ReadAudienceRestrictionCondition(XmlReader reader);
    protected virtual void WriteAudienceRestrictionCondition(XmlWriter writer, SamlAudienceRestrictionCondition condition);
    protected virtual SamlDoNotCacheCondition ReadDoNotCacheCondition(XmlReader reader);
    protected virtual void WriteDoNotCacheCondition(XmlWriter writer, SamlDoNotCacheCondition condition);
    protected virtual SamlStatement ReadStatement(XmlReader reader);
    protected virtual void WriteStatement(XmlWriter writer, SamlStatement statement);
    protected virtual SamlSubject ReadSubject(XmlReader reader);
    protected virtual void WriteSubject(XmlWriter writer, SamlSubject subject);
    protected virtual SecurityKeyIdentifier ReadSubjectKeyInfo(XmlReader reader);
    protected virtual void WriteSubjectKeyInfo(XmlWriter writer, SecurityKeyIdentifier subjectSki);
    protected virtual SamlAttributeStatement ReadAttributeStatement(XmlReader reader);
    protected virtual void WriteAttributeStatement(XmlWriter writer, SamlAttributeStatement statement);
    protected virtual SamlAttribute ReadAttribute(XmlReader reader);
    protected virtual string ReadAttributeValue(XmlReader reader, SamlAttribute attribute);
    protected virtual void WriteAttribute(XmlWriter writer, SamlAttribute attribute);
    protected virtual void WriteAttributeValue(XmlWriter writer, string value, SamlAttribute attribute);
    protected virtual SamlAuthenticationStatement ReadAuthenticationStatement(XmlReader reader);
    protected virtual void WriteAuthenticationStatement(XmlWriter writer, SamlAuthenticationStatement statement);
    protected virtual SamlAuthorityBinding ReadAuthorityBinding(XmlReader reader);
    protected virtual void WriteAuthorityBinding(XmlWriter writer, SamlAuthorityBinding authorityBinding);
    public virtual bool get_CanWriteToken();
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
    protected virtual SamlAuthorizationDecisionStatement ReadAuthorizationDecisionStatement(XmlReader reader);
    protected virtual void WriteAuthorizationDecisionStatement(XmlWriter writer, SamlAuthorizationDecisionStatement statement);
    protected virtual SamlEvidence ReadEvidence(XmlReader reader);
    protected virtual void WriteEvidence(XmlWriter writer, SamlEvidence evidence);
    protected virtual SecurityKey ResolveSubjectKeyIdentifier(SecurityKeyIdentifier subjectKeyIdentifier);
    protected virtual SecurityToken ResolveIssuerToken(SamlAssertion assertion, SecurityTokenResolver issuerResolver);
    protected virtual bool TryResolveIssuerToken(SamlAssertion assertion, SecurityTokenResolver issuerResolver, SecurityToken& token);
    protected virtual SecurityKeyIdentifier ReadSigningKeyInfo(XmlReader reader, SamlAssertion assertion);
    protected virtual void WriteSigningKeyInfo(XmlWriter writer, SecurityKeyIdentifier signingKeyIdentifier);
    public virtual String[] GetTokenTypeIdentifiers();
    public SecurityTokenSerializer get_KeyInfoSerializer();
    public void set_KeyInfoSerializer(SecurityTokenSerializer value);
    public virtual Type get_TokenType();
    public SamlSecurityTokenRequirement get_SamlSecurityTokenRequirement();
    public void set_SamlSecurityTokenRequirement(SamlSecurityTokenRequirement value);
}
public class System.IdentityModel.Tokens.SamlSecurityTokenRequirement : object {
    public X509CertificateValidator CertificateValidator { get; public set; }
    public string NameClaimType { get; public set; }
    public string RoleClaimType { get; public set; }
    public bool MapToWindows { get; public set; }
    public SamlSecurityTokenRequirement(XmlElement element);
    private static SamlSecurityTokenRequirement();
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    public string get_NameClaimType();
    public void set_NameClaimType(string value);
    public string get_RoleClaimType();
    public void set_RoleClaimType(string value);
    public bool get_MapToWindows();
    public void set_MapToWindows(bool value);
    public virtual bool ShouldEnforceAudienceRestriction(AudienceUriMode audienceUriMode, SecurityToken token);
    public virtual void ValidateAudienceRestriction(IList`1<Uri> allowedAudienceUris, IList`1<Uri> tokenAudiences);
}
public class System.IdentityModel.Tokens.SamlSerializer : object {
    internal DictionaryManager DictionaryManager { get; }
    public void PopulateDictionary(IXmlDictionary dictionary);
    internal DictionaryManager get_DictionaryManager();
    public virtual SamlSecurityToken ReadToken(XmlReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteToken(SamlSecurityToken token, XmlWriter writer, SecurityTokenSerializer keyInfoSerializer);
    public virtual SamlAssertion LoadAssertion(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual SamlCondition LoadCondition(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual SamlConditions LoadConditions(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual SamlAdvice LoadAdvice(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual SamlStatement LoadStatement(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual SamlAttribute LoadAttribute(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    internal static SecurityKeyIdentifier ReadSecurityKeyIdentifier(XmlReader reader, SecurityTokenSerializer tokenSerializer);
    internal static void WriteSecurityKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier ski, SecurityTokenSerializer tokenSerializer);
    internal static SecurityKey ResolveSecurityKey(SecurityKeyIdentifier ski, SecurityTokenResolver tokenResolver);
    internal static SecurityToken ResolveSecurityToken(SecurityKeyIdentifier ski, SecurityTokenResolver tokenResolver);
}
public abstract class System.IdentityModel.Tokens.SamlStatement : object {
    public bool IsReadOnly { get; }
    public abstract virtual IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void MakeReadOnly();
    public abstract virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public abstract virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public class System.IdentityModel.Tokens.SamlSubject : object {
    public string Name { get; public set; }
    public string NameFormat { get; public set; }
    public string NameQualifier { get; public set; }
    public static string NameClaimType { get; }
    public IList`1<string> ConfirmationMethods { get; }
    internal IIdentity Identity { get; }
    public string SubjectConfirmationData { get; public set; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public SecurityKey Crypto { get; public set; }
    public bool IsReadOnly { get; }
    public SamlSubject(string nameFormat, string nameQualifier, string name);
    public SamlSubject(string nameFormat, string nameQualifier, string name, IEnumerable`1<string> confirmations, string confirmationData, SecurityKeyIdentifier securityKeyIdentifier);
    public string get_Name();
    public void set_Name(string value);
    public string get_NameFormat();
    public void set_NameFormat(string value);
    public string get_NameQualifier();
    public void set_NameQualifier(string value);
    public static string get_NameClaimType();
    public IList`1<string> get_ConfirmationMethods();
    internal IIdentity get_Identity();
    public string get_SubjectConfirmationData();
    public void set_SubjectConfirmationData(string value);
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public SecurityKey get_Crypto();
    public void set_Crypto(SecurityKey value);
    public bool get_IsReadOnly();
    public void MakeReadOnly();
    public virtual ReadOnlyCollection`1<Claim> ExtractClaims();
    public virtual ClaimSet ExtractSubjectKeyClaimSet(SamlSecurityTokenAuthenticator samlAuthenticator);
    public virtual void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver);
    public virtual void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer);
}
public abstract class System.IdentityModel.Tokens.SamlSubjectStatement : SamlStatement {
    public SamlSubject SamlSubject { get; public set; }
    public bool IsReadOnly { get; }
    protected SamlSubjectStatement(SamlSubject samlSubject);
    public SamlSubject get_SamlSubject();
    public void set_SamlSubject(SamlSubject value);
    public virtual bool get_IsReadOnly();
    public virtual void MakeReadOnly();
    public virtual IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator);
    protected void SetSubject(SamlSubject samlSubject);
    protected abstract virtual void AddClaimsToList(IList`1<Claim> claims);
}
internal class System.IdentityModel.Tokens.SctAuthorizationPolicy : object {
    private ClaimSet System.IdentityModel.Policy.IAuthorizationPolicy.Issuer { get; }
    private string System.IdentityModel.Policy.IAuthorizationComponent.Id { get; }
    internal SctAuthorizationPolicy(Claim claim);
    private sealed virtual override bool System.IdentityModel.Policy.IAuthorizationPolicy.Evaluate(EvaluationContext evaluationContext, Object& state);
    private sealed virtual override ClaimSet System.IdentityModel.Policy.IAuthorizationPolicy.get_Issuer();
    private sealed virtual override string System.IdentityModel.Policy.IAuthorizationComponent.get_Id();
}
public static class System.IdentityModel.Tokens.SecurityAlgorithms : object {
    public static string Aes128Encryption;
    public static string Aes128KeyWrap;
    public static string Aes192Encryption;
    public static string Aes192KeyWrap;
    public static string Aes256Encryption;
    public static string Aes256KeyWrap;
    public static string DesEncryption;
    public static string DsaSha1Signature;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string HmacSha1Signature;
    public static string HmacSha256Signature;
    public static string Psha1KeyDerivation;
    public static string Psha1KeyDerivationDec2005;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string RsaSha1Signature;
    public static string RsaSha256Signature;
    public static string RsaV15KeyWrap;
    public static string Sha1Digest;
    public static string Sha256Digest;
    public static string Sha512Digest;
    public static string StrTransform;
    public static string TripleDesEncryption;
    public static string TripleDesKeyWrap;
    public static string TlsSspiKeyWrap;
    public static string WindowsSspiKeyWrap;
    internal static int DefaultSymmetricKeyLength;
    internal static string DefaultEncryptionAlgorithm;
    internal static string DefaultAsymmetricKeyWrapAlgorithm;
    internal static string DefaultAsymmetricSignatureAlgorithm;
    internal static string DefaultDigestAlgorithm;
}
public abstract class System.IdentityModel.Tokens.SecurityKey : object {
    public int KeySize { get; }
    public abstract virtual int get_KeySize();
    public abstract virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public abstract virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public abstract virtual bool IsAsymmetricAlgorithm(string algorithm);
    public abstract virtual bool IsSupportedAlgorithm(string algorithm);
    public abstract virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.SecurityKeyElement : SecurityKey {
    public int KeySize { get; }
    public SecurityKeyElement(SecurityKeyIdentifierClause securityKeyIdentifierClause, SecurityTokenResolver securityTokenResolver);
    public SecurityKeyElement(SecurityKeyIdentifier securityKeyIdentifier, SecurityTokenResolver securityTokenResolver);
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
    public virtual int get_KeySize();
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Tokens.SecurityKeyIdentifier : object {
    public SecurityKeyIdentifierClause Item { get; }
    public bool CanCreateKey { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SecurityKeyIdentifier(SecurityKeyIdentifierClause[] clauses);
    public SecurityKeyIdentifierClause get_Item(int index);
    public bool get_CanCreateKey();
    public int get_Count();
    public bool get_IsReadOnly();
    public void Add(SecurityKeyIdentifierClause clause);
    public SecurityKey CreateKey();
    public TClause Find();
    public sealed virtual IEnumerator`1<SecurityKeyIdentifierClause> GetEnumerator();
    public void MakeReadOnly();
    public virtual string ToString();
    public bool TryFind(TClause& clause);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
    public bool CanCreateKey { get; }
    public string ClauseType { get; }
    public string Id { get; public set; }
    public int DerivationLength { get; }
    protected SecurityKeyIdentifierClause(string clauseType);
    protected SecurityKeyIdentifierClause(string clauseType, Byte[] nonce, int length);
    public virtual bool get_CanCreateKey();
    public string get_ClauseType();
    public string get_Id();
    public void set_Id(string value);
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public Byte[] GetDerivationNonce();
    public int get_DerivationLength();
}
public abstract class System.IdentityModel.Tokens.SecurityKeyIdentifierClauseSerializer : object {
    public abstract virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public abstract virtual bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public abstract virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public abstract virtual void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause);
}
public enum System.IdentityModel.Tokens.SecurityKeyType : Enum {
    public int value__;
    public static SecurityKeyType SymmetricKey;
    public static SecurityKeyType AsymmetricKey;
    public static SecurityKeyType BearerKey;
}
internal static class System.IdentityModel.Tokens.SecurityKeyTypeHelper : object {
    internal static bool IsDefined(SecurityKeyType value);
    internal static void Validate(SecurityKeyType value);
}
public enum System.IdentityModel.Tokens.SecurityKeyUsage : Enum {
    public int value__;
    public static SecurityKeyUsage Exchange;
    public static SecurityKeyUsage Signature;
}
internal static class System.IdentityModel.Tokens.SecurityKeyUsageHelper : object {
    internal static bool IsDefined(SecurityKeyUsage value);
    internal static void Validate(SecurityKeyUsage value);
}
public abstract class System.IdentityModel.Tokens.SecurityToken : object {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public abstract virtual string get_Id();
    public abstract virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public abstract virtual DateTime get_ValidFrom();
    public abstract virtual DateTime get_ValidTo();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
public class System.IdentityModel.Tokens.SecurityTokenDescriptor : object {
    public string AppliesToAddress { get; public set; }
    public string ReplyToAddress { get; public set; }
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public SecurityKeyIdentifierClause AttachedReference { get; public set; }
    public string TokenIssuerName { get; public set; }
    public ProofDescriptor Proof { get; public set; }
    public Dictionary`2<string, object> Properties { get; }
    public SecurityToken Token { get; public set; }
    public string TokenType { get; public set; }
    public SecurityKeyIdentifierClause UnattachedReference { get; public set; }
    public Lifetime Lifetime { get; public set; }
    public ClaimsIdentity Subject { get; public set; }
    public AuthenticationInformation AuthenticationInfo { get; public set; }
    public string get_AppliesToAddress();
    public void set_AppliesToAddress(string value);
    public virtual void ApplyTo(RequestSecurityTokenResponse response);
    public string get_ReplyToAddress();
    public void set_ReplyToAddress(string value);
    public EncryptingCredentials get_EncryptingCredentials();
    public void set_EncryptingCredentials(EncryptingCredentials value);
    public SigningCredentials get_SigningCredentials();
    public void set_SigningCredentials(SigningCredentials value);
    public SecurityKeyIdentifierClause get_AttachedReference();
    public void set_AttachedReference(SecurityKeyIdentifierClause value);
    public string get_TokenIssuerName();
    public void set_TokenIssuerName(string value);
    public ProofDescriptor get_Proof();
    public void set_Proof(ProofDescriptor value);
    public Dictionary`2<string, object> get_Properties();
    public SecurityToken get_Token();
    public void set_Token(SecurityToken value);
    public string get_TokenType();
    public void set_TokenType(string value);
    public SecurityKeyIdentifierClause get_UnattachedReference();
    public void set_UnattachedReference(SecurityKeyIdentifierClause value);
    public Lifetime get_Lifetime();
    public void set_Lifetime(Lifetime value);
    public ClaimsIdentity get_Subject();
    public void set_Subject(ClaimsIdentity value);
    public AuthenticationInformation get_AuthenticationInfo();
    public void set_AuthenticationInfo(AuthenticationInformation value);
    public void AddAuthenticationClaims(string authType);
    public void AddAuthenticationClaims(string authType, DateTime time);
}
public class System.IdentityModel.Tokens.SecurityTokenElement : object {
    public XmlElement SecurityTokenXml { get; }
    public SecurityTokenElement(SecurityToken securityToken);
    public SecurityTokenElement(XmlElement securityTokenXml, SecurityTokenHandlerCollection securityTokenHandlers);
    public XmlElement get_SecurityTokenXml();
    public SecurityToken GetSecurityToken();
    public ReadOnlyCollection`1<ClaimsIdentity> GetIdentities();
    protected virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(XmlElement securityTokenXml, SecurityTokenHandlerCollection securityTokenHandlers);
    protected virtual SecurityToken ReadSecurityToken(XmlElement securityTokenXml, SecurityTokenHandlerCollection securityTokenHandlers);
}
public class System.IdentityModel.Tokens.SecurityTokenException : SystemException {
    public SecurityTokenException(string message);
    public SecurityTokenException(string message, Exception innerException);
    protected SecurityTokenException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Tokens.SecurityTokenExpiredException : SecurityTokenValidationException {
    public SecurityTokenExpiredException(string message);
    public SecurityTokenExpiredException(string message, Exception inner);
    protected SecurityTokenExpiredException(SerializationInfo info, StreamingContext context);
}
public abstract class System.IdentityModel.Tokens.SecurityTokenHandler : object {
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public SecurityTokenHandlerConfiguration Configuration { get; public set; }
    public SecurityTokenHandlerCollection ContainingCollection { get; internal set; }
    public Type TokenType { get; }
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public SecurityTokenHandlerConfiguration get_Configuration();
    public void set_Configuration(SecurityTokenHandlerConfiguration value);
    public SecurityTokenHandlerCollection get_ContainingCollection();
    internal void set_ContainingCollection(SecurityTokenHandlerCollection value);
    public abstract virtual Type get_TokenType();
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool CanReadToken(string tokenString);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
    public virtual SecurityToken ReadToken(string tokenString);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
    public virtual string WriteToken(SecurityToken token);
    public virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public virtual bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public virtual SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached);
    public abstract virtual String[] GetTokenTypeIdentifiers();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    protected virtual void DetectReplayedToken(SecurityToken token);
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
    protected void TraceTokenValidationSuccess(SecurityToken token);
    protected void TraceTokenValidationFailure(SecurityToken token, string errorMessage);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Tokens.SecurityTokenHandlerCollection : Collection`1<SecurityTokenHandler> {
    internal static int defaultHandlerCollectionCount;
    public SecurityTokenHandlerConfiguration Configuration { get; }
    public IEnumerable`1<Type> TokenTypes { get; }
    public IEnumerable`1<string> TokenTypeIdentifiers { get; }
    public SecurityTokenHandler Item { get; }
    public SecurityTokenHandler Item { get; }
    public SecurityTokenHandler Item { get; }
    internal SecurityTokenSerializer KeyInfoSerializer { get; }
    public SecurityTokenHandlerCollection(SecurityTokenHandlerConfiguration configuration);
    public SecurityTokenHandlerCollection(IEnumerable`1<SecurityTokenHandler> handlers);
    public SecurityTokenHandlerCollection(IEnumerable`1<SecurityTokenHandler> handlers, SecurityTokenHandlerConfiguration configuration);
    private static SecurityTokenHandlerCollection();
    public SecurityTokenHandlerConfiguration get_Configuration();
    public IEnumerable`1<Type> get_TokenTypes();
    public IEnumerable`1<string> get_TokenTypeIdentifiers();
    public SecurityTokenHandler get_Item(string tokenTypeIdentifier);
    public SecurityTokenHandler get_Item(SecurityToken token);
    public SecurityTokenHandler get_Item(Type tokenType);
    public static SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection();
    public static SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection(SecurityTokenHandlerConfiguration configuration);
    internal SecurityTokenSerializer get_KeyInfoSerializer();
    public void AddOrReplace(SecurityTokenHandler handler);
    public bool CanReadToken(XmlReader reader);
    public bool CanReadToken(string tokenString);
    public bool CanWriteToken(SecurityToken token);
    public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    public SecurityToken ReadToken(XmlReader reader);
    public SecurityToken ReadToken(string tokenString);
    public void WriteToken(XmlWriter writer, SecurityToken token);
    public string WriteToken(SecurityToken token);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SecurityTokenHandler item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SecurityTokenHandler item);
    public bool CanReadKeyIdentifierClause(XmlReader reader);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
[DefaultMemberAttribute("Item")]
public class System.IdentityModel.Tokens.SecurityTokenHandlerCollectionManager : object {
    public int Count { get; }
    public string ServiceName { get; }
    public IEnumerable`1<SecurityTokenHandlerCollection> SecurityTokenHandlerCollections { get; }
    public SecurityTokenHandlerCollection Item { get; public set; }
    public SecurityTokenHandlerCollectionManager(string serviceName);
    public int get_Count();
    public string get_ServiceName();
    public IEnumerable`1<SecurityTokenHandlerCollection> get_SecurityTokenHandlerCollections();
    public SecurityTokenHandlerCollection get_Item(string usage);
    public void set_Item(string usage, SecurityTokenHandlerCollection value);
    public static SecurityTokenHandlerCollectionManager CreateEmptySecurityTokenHandlerCollectionManager();
    public static SecurityTokenHandlerCollectionManager CreateDefaultSecurityTokenHandlerCollectionManager();
    public bool ContainsKey(string usage);
}
public class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration : object {
    public static bool DefaultDetectReplayedTokens;
    public static IssuerNameRegistry DefaultIssuerNameRegistry;
    public static SecurityTokenResolver DefaultIssuerTokenResolver;
    public static TimeSpan DefaultMaxClockSkew;
    public static bool DefaultSaveBootstrapContext;
    public static TimeSpan DefaultTokenReplayCacheExpirationPeriod;
    public static X509CertificateValidationMode DefaultCertificateValidationMode;
    public static X509RevocationMode DefaultRevocationMode;
    public static StoreLocation DefaultTrustedStoreLocation;
    public static X509CertificateValidator DefaultCertificateValidator;
    public AudienceRestriction AudienceRestriction { get; public set; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public X509RevocationMode RevocationMode { get; public set; }
    public StoreLocation TrustedStoreLocation { get; public set; }
    public X509CertificateValidationMode CertificateValidationMode { get; public set; }
    public bool DetectReplayedTokens { get; public set; }
    public IssuerNameRegistry IssuerNameRegistry { get; public set; }
    public SecurityTokenResolver IssuerTokenResolver { get; public set; }
    public TimeSpan MaxClockSkew { get; public set; }
    public bool SaveBootstrapContext { get; public set; }
    public SecurityTokenResolver ServiceTokenResolver { get; public set; }
    public IdentityModelCaches Caches { get; public set; }
    public TimeSpan TokenReplayCacheExpirationPeriod { get; public set; }
    private static SecurityTokenHandlerConfiguration();
    public AudienceRestriction get_AudienceRestriction();
    public void set_AudienceRestriction(AudienceRestriction value);
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public StoreLocation get_TrustedStoreLocation();
    public void set_TrustedStoreLocation(StoreLocation value);
    public X509CertificateValidationMode get_CertificateValidationMode();
    public void set_CertificateValidationMode(X509CertificateValidationMode value);
    public bool get_DetectReplayedTokens();
    public void set_DetectReplayedTokens(bool value);
    public IssuerNameRegistry get_IssuerNameRegistry();
    public void set_IssuerNameRegistry(IssuerNameRegistry value);
    public SecurityTokenResolver get_IssuerTokenResolver();
    public void set_IssuerTokenResolver(SecurityTokenResolver value);
    public TimeSpan get_MaxClockSkew();
    public void set_MaxClockSkew(TimeSpan value);
    public bool get_SaveBootstrapContext();
    public void set_SaveBootstrapContext(bool value);
    public SecurityTokenResolver get_ServiceTokenResolver();
    public void set_ServiceTokenResolver(SecurityTokenResolver value);
    public IdentityModelCaches get_Caches();
    public void set_Caches(IdentityModelCaches value);
    public TimeSpan get_TokenReplayCacheExpirationPeriod();
    public void set_TokenReplayCacheExpirationPeriod(TimeSpan value);
}
public class System.IdentityModel.Tokens.SecurityTokenNotYetValidException : SecurityTokenValidationException {
    public SecurityTokenNotYetValidException(string message);
    public SecurityTokenNotYetValidException(string message, Exception inner);
    protected SecurityTokenNotYetValidException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Tokens.SecurityTokenReplayDetectedException : SecurityTokenValidationException {
    public SecurityTokenReplayDetectedException(string message);
    public SecurityTokenReplayDetectedException(string message, Exception inner);
    protected SecurityTokenReplayDetectedException(SerializationInfo info, StreamingContext context);
}
internal class System.IdentityModel.Tokens.SecurityTokenSerializerAdapter : SecurityTokenSerializer {
    public SecurityTokenHandlerCollection SecurityTokenHandlers { get; }
    public SecurityTokenSerializerAdapter(SecurityTokenHandlerCollection securityTokenHandlerCollection);
    public SecurityTokenHandlerCollection get_SecurityTokenHandlers();
    protected virtual bool CanReadTokenCore(XmlReader reader);
    protected virtual bool CanWriteTokenCore(SecurityToken token);
    protected virtual SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
    protected virtual void WriteTokenCore(XmlWriter writer, SecurityToken token);
    protected virtual bool CanReadKeyIdentifierCore(XmlReader reader);
    protected virtual SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
    protected virtual void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
    protected virtual bool CanReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
    protected virtual SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
    protected virtual void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
}
public static class System.IdentityModel.Tokens.SecurityTokenTypes : object {
    internal static string SamlTokenProfile11;
    internal static string Saml2TokenProfile11;
    internal static string OasisWssSamlTokenProfile11;
    internal static string OasisWssSaml2TokenProfile11;
    public static string UserName { get; }
    public static string X509Certificate { get; }
    public static string Kerberos { get; }
    public static string Saml { get; }
    public static string Rsa { get; }
    public static string get_UserName();
    public static string get_X509Certificate();
    public static string get_Kerberos();
    public static string get_Saml();
    public static string get_Rsa();
}
public class System.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
    public SecurityTokenValidationException(string message);
    public SecurityTokenValidationException(string message, Exception innerException);
    protected SecurityTokenValidationException(SerializationInfo info, StreamingContext context);
}
public class System.IdentityModel.Tokens.SessionSecurityToken : SecurityToken {
    public ClaimsPrincipal ClaimsPrincipal { get; }
    public string Context { get; }
    public UniqueId ContextId { get; }
    public string EndpointId { get; }
    internal bool IsSecurityContextSecurityTokenWrapper { get; }
    public DateTime KeyEffectiveTime { get; }
    public DateTime KeyExpirationTime { get; }
    public UniqueId KeyGeneration { get; }
    public string Id { get; }
    public bool IsPersistent { get; public set; }
    public bool IsReferenceMode { get; public set; }
    internal SctAuthorizationPolicy SctAuthorizationPolicy { get; }
    public Uri SecureConversationVersion { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, TimeSpan lifetime);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, string context);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, string context, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, TimeSpan lifetime, SymmetricSecurityKey key);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, DateTime validFrom, TimeSpan lifetime, SymmetricSecurityKey key);
    public SessionSecurityToken(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo, SymmetricSecurityKey key);
    internal SessionSecurityToken(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string id, string context, Byte[] key, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo, UniqueId keyGeneration, Nullable`1<DateTime> keyEffectiveTime, Nullable`1<DateTime> keyExpirationTime, SctAuthorizationPolicy sctAuthorizationPolicy, Uri securityContextSecurityTokenWrapperSecureConversationVersion);
    protected SessionSecurityToken(SerializationInfo info, StreamingContext context);
    private static SessionSecurityToken();
    public ClaimsPrincipal get_ClaimsPrincipal();
    public string get_Context();
    public UniqueId get_ContextId();
    public string get_EndpointId();
    internal bool get_IsSecurityContextSecurityTokenWrapper();
    public DateTime get_KeyEffectiveTime();
    public DateTime get_KeyExpirationTime();
    public UniqueId get_KeyGeneration();
    public virtual string get_Id();
    public bool get_IsPersistent();
    public void set_IsPersistent(bool value);
    public bool get_IsReferenceMode();
    public void set_IsReferenceMode(bool value);
    internal SctAuthorizationPolicy get_SctAuthorizationPolicy();
    public Uri get_SecureConversationVersion();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.IdentityModel.Tokens.SessionSecurityTokenCache : object {
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
    public abstract virtual void AddOrUpdate(SessionSecurityTokenCacheKey key, SessionSecurityToken value, DateTime expiryTime);
    public abstract virtual IEnumerable`1<SessionSecurityToken> GetAll(string endpointId, UniqueId contextId);
    public abstract virtual SessionSecurityToken Get(SessionSecurityTokenCacheKey key);
    public abstract virtual void RemoveAll(string endpointId, UniqueId contextId);
    public abstract virtual void RemoveAll(string endpointId);
    public abstract virtual void Remove(SessionSecurityTokenCacheKey key);
}
public class System.IdentityModel.Tokens.SessionSecurityTokenCacheKey : object {
    public bool IgnoreKeyGeneration { get; public set; }
    public UniqueId ContextId { get; }
    public string EndpointId { get; }
    public UniqueId KeyGeneration { get; }
    public SessionSecurityTokenCacheKey(string endpointId, UniqueId contextId, UniqueId keyGeneration);
    public bool get_IgnoreKeyGeneration();
    public void set_IgnoreKeyGeneration(bool value);
    public UniqueId get_ContextId();
    public string get_EndpointId();
    public UniqueId get_KeyGeneration();
    public static bool op_Equality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second);
    public static bool op_Inequality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.SessionSecurityTokenHandler : SecurityTokenHandler {
    public static TimeSpan DefaultLifetime;
    public static ReadOnlyCollection`1<CookieTransform> DefaultCookieTransforms;
    public string CookieElementName { get; }
    public string CookieNamespace { get; }
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public static TimeSpan DefaultTokenLifetime { get; }
    public TimeSpan TokenLifetime { get; public set; }
    public Type TokenType { get; }
    public ReadOnlyCollection`1<CookieTransform> Transforms { get; }
    public SessionSecurityTokenHandler(ReadOnlyCollection`1<CookieTransform> transforms);
    public SessionSecurityTokenHandler(ReadOnlyCollection`1<CookieTransform> transforms, TimeSpan tokenLifetime);
    private static SessionSecurityTokenHandler();
    public virtual void LoadCustomConfiguration(XmlNodeList customConfigElements);
    public virtual string get_CookieElementName();
    public virtual string get_CookieNamespace();
    protected virtual Byte[] ApplyTransforms(Byte[] cookie, bool outbound);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public virtual SessionSecurityToken CreateSessionSecurityToken(ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);
    public static TimeSpan get_DefaultTokenLifetime();
    public virtual SecurityToken ReadToken(Byte[] token, SecurityTokenResolver tokenResolver);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
    public virtual TimeSpan get_TokenLifetime();
    public virtual void set_TokenLifetime(TimeSpan value);
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual Type get_TokenType();
    public ReadOnlyCollection`1<CookieTransform> get_Transforms();
    protected void SetTransforms(IEnumerable`1<CookieTransform> transforms);
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SessionSecurityToken token, string endpointId);
    protected virtual void ValidateSession(SessionSecurityToken securityToken);
    public virtual Byte[] WriteToken(SessionSecurityToken sessionToken);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
}
public class System.IdentityModel.Tokens.SigningCredentials : object {
    public string DigestAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public SecurityKey SigningKey { get; }
    public SecurityKeyIdentifier SigningKeyIdentifier { get; }
    public SigningCredentials(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm);
    public SigningCredentials(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm, SecurityKeyIdentifier signingKeyIdentifier);
    public string get_DigestAlgorithm();
    public string get_SignatureAlgorithm();
    public SecurityKey get_SigningKey();
    public SecurityKeyIdentifier get_SigningKeyIdentifier();
}
public class System.IdentityModel.Tokens.SymmetricProofDescriptor : ProofDescriptor {
    protected EncryptingCredentials RequestorEncryptingCredentials { get; }
    protected EncryptingCredentials TargetEncryptingCredentials { get; }
    public SecurityKeyIdentifier KeyIdentifier { get; }
    public SymmetricProofDescriptor(Byte[] key, EncryptingCredentials targetWrappingCredentials);
    public SymmetricProofDescriptor(EncryptingCredentials targetWrappingCredentials);
    public SymmetricProofDescriptor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials);
    public SymmetricProofDescriptor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials);
    public SymmetricProofDescriptor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, string encryptWith);
    public SymmetricProofDescriptor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, Byte[] sourceEntropy);
    public SymmetricProofDescriptor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, Byte[] sourceEntropy, string encryptWith);
    public Byte[] GetKeyBytes();
    protected EncryptingCredentials get_RequestorEncryptingCredentials();
    protected Byte[] GetSourceEntropy();
    protected Byte[] GetTargetEntropy();
    protected EncryptingCredentials get_TargetEncryptingCredentials();
    public virtual void ApplyTo(RequestSecurityTokenResponse response);
    public virtual SecurityKeyIdentifier get_KeyIdentifier();
}
public abstract class System.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
    public abstract virtual Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset);
    public abstract virtual ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv);
    public abstract virtual int GetIVSize(string algorithm);
    public abstract virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
    public abstract virtual SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
    public abstract virtual Byte[] GetSymmetricKey();
}
public abstract class System.IdentityModel.Tokens.TokenReplayCache : object {
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
    public abstract virtual void AddOrUpdate(string key, SecurityToken securityToken, DateTime expirationTime);
    public abstract virtual bool Contains(string key);
    public abstract virtual SecurityToken Get(string key);
    public abstract virtual void Remove(string key);
}
public class System.IdentityModel.Tokens.UserNameSecurityToken : SecurityToken {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public string UserName { get; }
    public string Password { get; }
    public UserNameSecurityToken(string userName, string password);
    public UserNameSecurityToken(string userName, string password, string id);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public string get_UserName();
    public string get_Password();
}
public abstract class System.IdentityModel.Tokens.UserNameSecurityTokenHandler : SecurityTokenHandler {
    public bool RetainPassword { get; public set; }
    public bool CanWriteToken { get; }
    public Type TokenType { get; }
    public virtual bool get_RetainPassword();
    public virtual void set_RetainPassword(bool value);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool get_CanWriteToken();
    public virtual Type get_TokenType();
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
}
public class System.IdentityModel.Tokens.WindowsSecurityToken : SecurityToken {
    public string Id { get; }
    public string AuthenticationType { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public WindowsIdentity WindowsIdentity { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public WindowsSecurityToken(WindowsIdentity windowsIdentity);
    public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id);
    public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id, string authenticationType);
    protected void Initialize(string id, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
    protected void Initialize(string id, string authenticationType, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
    public virtual string get_Id();
    public string get_AuthenticationType();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public virtual WindowsIdentity get_WindowsIdentity();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual void Dispose();
    protected void ThrowIfDisposed();
}
public class System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler : UserNameSecurityTokenHandler {
    public bool CanValidateToken { get; }
    public virtual bool get_CanValidateToken();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
}
internal class System.IdentityModel.Tokens.WrappedSaml2AssertionKeyIdentifierClause : SamlAssertionKeyIdentifierClause {
    public bool CanCreateKey { get; }
    public Saml2AssertionKeyIdentifierClause WrappedClause { get; }
    public WrappedSaml2AssertionKeyIdentifierClause(Saml2AssertionKeyIdentifierClause clause);
    public virtual bool get_CanCreateKey();
    public Saml2AssertionKeyIdentifierClause get_WrappedClause();
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
internal class System.IdentityModel.Tokens.WSSecurityJan2004 : SerializerEntries {
    public KeyInfoSerializer SecurityTokenSerializer { get; }
    public WSSecurityJan2004(KeyInfoSerializer securityTokenSerializer);
    public KeyInfoSerializer get_SecurityTokenSerializer();
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> clauseEntries);
    protected void PopulateJan2004StrEntries(IList`1<StrEntry> strEntries);
    public virtual void PopulateStrEntries(IList`1<StrEntry> strEntries);
    protected void PopulateJan2004TokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
}
internal class System.IdentityModel.Tokens.WSSecurityXXX2005 : WSSecurityJan2004 {
    public WSSecurityXXX2005(KeyInfoSerializer securityTokenSerializer);
    public virtual void PopulateStrEntries(IList`1<StrEntry> strEntries);
    public virtual void PopulateTokenEntries(IList`1<TokenEntry> tokenEntryList);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> clauseEntries);
}
public class System.IdentityModel.Tokens.X509AsymmetricSecurityKey : AsymmetricSecurityKey {
    public int KeySize { get; }
    public X509AsymmetricSecurityKey(X509Certificate2 certificate);
    public virtual int get_KeySize();
    public virtual Byte[] DecryptKey(string algorithm, Byte[] keyData);
    public virtual Byte[] EncryptKey(string algorithm, Byte[] keyData);
    public virtual AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey);
    public virtual HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
    public virtual AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
    public virtual AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
    public virtual bool HasPrivateKey();
    public virtual bool IsAsymmetricAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSymmetricAlgorithm(string algorithm);
}
public class System.IdentityModel.Tokens.X509CertificateStoreTokenResolver : SecurityTokenResolver {
    public string StoreName { get; }
    public StoreLocation StoreLocation { get; }
    public X509CertificateStoreTokenResolver(StoreName storeName, StoreLocation storeLocation);
    public X509CertificateStoreTokenResolver(string storeName, StoreLocation storeLocation);
    public string get_StoreName();
    public StoreLocation get_StoreLocation();
    protected virtual bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token);
    protected virtual bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token);
}
public class System.IdentityModel.Tokens.X509DataSecurityKeyIdentifierClauseSerializer : SecurityKeyIdentifierClauseSerializer {
    public virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public virtual bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public virtual void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause);
}
public class System.IdentityModel.Tokens.X509EncryptingCredentials : EncryptingCredentials {
    public X509Certificate2 Certificate { get; }
    public X509EncryptingCredentials(X509Certificate2 certificate);
    public X509EncryptingCredentials(X509Certificate2 certificate, string keyWrappingAlgorithm);
    public X509EncryptingCredentials(X509Certificate2 certificate, SecurityKeyIdentifier ski);
    public X509EncryptingCredentials(X509Certificate2 certificate, SecurityKeyIdentifier ski, string keyWrappingAlgorithm);
    internal X509EncryptingCredentials(X509SecurityToken token);
    internal X509EncryptingCredentials(X509SecurityToken token, string keyWrappingAlgorithm);
    internal X509EncryptingCredentials(X509SecurityToken token, SecurityKeyIdentifier ski, string keyWrappingAlgorithm);
    public X509Certificate2 get_Certificate();
}
public class System.IdentityModel.Tokens.X509IssuerSerialKeyIdentifierClause : SecurityKeyIdentifierClause {
    public string IssuerName { get; }
    public string IssuerSerialNumber { get; }
    public X509IssuerSerialKeyIdentifierClause(string issuerName, string issuerSerialNumber);
    public X509IssuerSerialKeyIdentifierClause(X509Certificate2 certificate);
    public string get_IssuerName();
    public string get_IssuerSerialNumber();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(X509Certificate2 certificate);
    public bool Matches(string issuerName, string issuerSerialNumber);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509NTAuthChainTrustValidator : X509CertificateValidator {
    public X509NTAuthChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
    public virtual void Validate(X509Certificate2 certificate);
}
public class System.IdentityModel.Tokens.X509RawDataKeyIdentifierClause : BinaryKeyIdentifierClause {
    public bool CanCreateKey { get; }
    public X509RawDataKeyIdentifierClause(X509Certificate2 certificate);
    public X509RawDataKeyIdentifierClause(Byte[] certificateRawData);
    internal X509RawDataKeyIdentifierClause(Byte[] certificateRawData, bool cloneBuffer);
    public virtual bool get_CanCreateKey();
    public virtual SecurityKey CreateKey();
    public Byte[] GetX509RawData();
    public bool Matches(X509Certificate2 certificate);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509SecurityToken : SecurityToken {
    public string Id { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public X509Certificate2 Certificate { get; }
    public X509SecurityToken(X509Certificate2 certificate);
    public X509SecurityToken(X509Certificate2 certificate, string id);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, bool clone, bool disposable);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone);
    internal X509SecurityToken(X509Certificate2 certificate, string id, bool clone, bool disposable);
    public virtual string get_Id();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public X509Certificate2 get_Certificate();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
    public virtual void Dispose();
    protected void ThrowIfDisposed();
}
public class System.IdentityModel.Tokens.X509SecurityTokenHandler : SecurityTokenHandler {
    public bool MapToWindows { get; public set; }
    public X509CertificateValidator CertificateValidator { get; public set; }
    public X509NTAuthChainTrustValidator X509NTAuthChainTrustValidator { get; public set; }
    public bool WriteXmlDSigDefinedClauseTypes { get; public set; }
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public Type TokenType { get; }
    public X509SecurityTokenHandler(X509CertificateValidator certificateValidator);
    public X509SecurityTokenHandler(bool mapToWindows);
    public X509SecurityTokenHandler(bool mapToWindows, X509CertificateValidator certificateValidator);
    private static X509SecurityTokenHandler();
    public virtual void LoadCustomConfiguration(XmlNodeList customConfigElements);
    public bool get_MapToWindows();
    public void set_MapToWindows(bool value);
    public X509CertificateValidator get_CertificateValidator();
    public void set_CertificateValidator(X509CertificateValidator value);
    public X509NTAuthChainTrustValidator get_X509NTAuthChainTrustValidator();
    public void set_X509NTAuthChainTrustValidator(X509NTAuthChainTrustValidator value);
    public bool get_WriteXmlDSigDefinedClauseTypes();
    public void set_WriteXmlDSigDefinedClauseTypes(bool value);
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public virtual bool CanReadKeyIdentifierClause(XmlReader reader);
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual Type get_TokenType();
    public virtual SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual String[] GetTokenTypeIdentifiers();
    public virtual ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token);
    public virtual void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause);
    public virtual void WriteToken(XmlWriter writer, SecurityToken token);
    internal static WindowsIdentity KerberosCertificateLogon(X509Certificate2 certificate);
}
public class System.IdentityModel.Tokens.X509SigningCredentials : SigningCredentials {
    public X509Certificate2 Certificate { get; }
    public X509SigningCredentials(X509Certificate2 certificate);
    public X509SigningCredentials(X509Certificate2 certificate, string signatureAlgorithm, string digestAlgorithm);
    public X509SigningCredentials(X509Certificate2 certificate, SecurityKeyIdentifier ski);
    public X509SigningCredentials(X509Certificate2 certificate, SecurityKeyIdentifier ski, string signatureAlgorithm, string digestAlgorithm);
    internal X509SigningCredentials(X509SecurityToken token, SecurityKeyIdentifier ski, string signatureAlgorithm, string digestAlgorithm);
    public X509Certificate2 get_Certificate();
}
public class System.IdentityModel.Tokens.X509SubjectKeyIdentifierClause : BinaryKeyIdentifierClause {
    public X509SubjectKeyIdentifierClause(Byte[] ski);
    internal X509SubjectKeyIdentifierClause(Byte[] ski, bool cloneBuffer);
    public Byte[] GetX509SubjectKeyIdentifier();
    public bool Matches(X509Certificate2 certificate);
    public static bool TryCreateFrom(X509Certificate2 certificate, X509SubjectKeyIdentifierClause& keyIdentifierClause);
    public static bool CanCreateFrom(X509Certificate2 certificate);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509ThumbprintKeyIdentifierClause : BinaryKeyIdentifierClause {
    public X509ThumbprintKeyIdentifierClause(X509Certificate2 certificate);
    public X509ThumbprintKeyIdentifierClause(Byte[] thumbprint);
    internal X509ThumbprintKeyIdentifierClause(Byte[] thumbprint, bool cloneBuffer);
    public Byte[] GetX509Thumbprint();
    public bool Matches(X509Certificate2 certificate);
    public virtual string ToString();
}
public class System.IdentityModel.Tokens.X509WindowsSecurityToken : X509SecurityToken {
    public WindowsIdentity WindowsIdentity { get; }
    public string AuthenticationType { get; }
    public X509WindowsSecurityToken(X509Certificate2 certificate, WindowsIdentity windowsIdentity);
    public X509WindowsSecurityToken(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string id);
    public X509WindowsSecurityToken(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string authenticationType, string id);
    internal X509WindowsSecurityToken(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string authenticationType, bool clone);
    internal X509WindowsSecurityToken(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string authenticationType, string id, bool clone);
    public WindowsIdentity get_WindowsIdentity();
    public string get_AuthenticationType();
    public virtual void Dispose();
}
internal class System.IdentityModel.Tokens.XmlDsigSep2000 : SerializerEntries {
    public XmlDsigSep2000(KeyInfoSerializer securityTokenSerializer);
    public virtual void PopulateKeyIdentifierEntries(IList`1<KeyIdentifierEntry> keyIdentifierEntries);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> keyIdentifierClauseEntries);
}
internal class System.IdentityModel.Tokens.XmlEncApr2001 : SerializerEntries {
    public XmlEncApr2001(KeyInfoSerializer securityTokenSerializer);
    public virtual void PopulateKeyIdentifierClauseEntries(IList`1<KeyIdentifierClauseEntry> keyIdentifierClauseEntries);
}
internal enum System.IdentityModel.TokenType : Enum {
    public int value__;
    public static TokenType TokenPrimary;
    public static TokenType TokenImpersonation;
}
internal class System.IdentityModel.TranformationParameters : object {
    public string CanonicalizationAlgorithm { get; }
    public string get_CanonicalizationAlgorithm();
    public void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager);
    public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal abstract class System.IdentityModel.Transform : object {
    public string Algorithm { get; }
    public bool NeedsInclusiveContext { get; }
    public abstract virtual string get_Algorithm();
    public virtual bool get_NeedsInclusiveContext();
    public abstract virtual object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager);
    public abstract virtual Byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager);
    public abstract virtual void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments);
    public abstract virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.TransformChain : object {
    public int TransformCount { get; }
    public Transform Item { get; }
    public bool NeedsInclusiveContext { get; }
    public int get_TransformCount();
    public Transform get_Item(int index);
    public bool get_NeedsInclusiveContext();
    public void Add(Transform transform);
    public void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager, bool preserveComments);
    public Byte[] TransformToDigest(object data, SignatureResourcePool resourcePool, string digestMethod, DictionaryManager dictionaryManager);
    public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
internal abstract class System.IdentityModel.TransformFactory : object {
    public abstract virtual Transform CreateTransform(string transformAlgorithmUri);
}
internal class System.IdentityModel.TrustDec2005Dictionary : TrustDictionary {
    public TrustDec2005Dictionary(IdentityModelDictionary dictionary);
    public TrustDec2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.TrustDec2005Strings : object {
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string AsymmetricKeyBinarySecret;
    public static string SymmetricKeyBinarySecret;
    public static string NonceBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string RequestSecurityTokenCollectionIssuanceFinalResponse;
    public static string RequestSecurityTokenRenewal;
    public static string RequestSecurityTokenRenewalResponse;
    public static string RequestSecurityTokenCollectionRenewalFinalResponse;
    public static string RequestSecurityTokenCancellation;
    public static string RequestSecurityTokenCancellationResponse;
    public static string RequestSecurityTokenCollectionCancellationFinalResponse;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string KeyWrapAlgorithm;
    public static string BearerKeyType;
    public static string SecondaryParameters;
    public static string Dialect;
    public static string DialectType;
}
internal class System.IdentityModel.TrustDictionary : object {
    public XmlDictionaryString RequestSecurityTokenResponseCollection;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString BinarySecretClauseType;
    public XmlDictionaryString CombinedHashLabel;
    public XmlDictionaryString RequestSecurityTokenResponse;
    public XmlDictionaryString TokenType;
    public XmlDictionaryString KeySize;
    public XmlDictionaryString RequestedTokenReference;
    public XmlDictionaryString AppliesTo;
    public XmlDictionaryString Authenticator;
    public XmlDictionaryString CombinedHash;
    public XmlDictionaryString BinaryExchange;
    public XmlDictionaryString Lifetime;
    public XmlDictionaryString RequestedSecurityToken;
    public XmlDictionaryString Entropy;
    public XmlDictionaryString RequestedProofToken;
    public XmlDictionaryString ComputedKey;
    public XmlDictionaryString RequestSecurityToken;
    public XmlDictionaryString RequestType;
    public XmlDictionaryString Context;
    public XmlDictionaryString BinarySecret;
    public XmlDictionaryString Type;
    public XmlDictionaryString SpnegoValueTypeUri;
    public XmlDictionaryString TlsnegoValueTypeUri;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString RequestSecurityTokenIssuance;
    public XmlDictionaryString RequestSecurityTokenIssuanceResponse;
    public XmlDictionaryString RequestTypeIssue;
    public XmlDictionaryString SymmetricKeyBinarySecret;
    public XmlDictionaryString Psha1ComputedKeyUri;
    public XmlDictionaryString NonceBinarySecret;
    public XmlDictionaryString RenewTarget;
    public XmlDictionaryString CloseTarget;
    public XmlDictionaryString RequestedTokenClosed;
    public XmlDictionaryString RequestedAttachedReference;
    public XmlDictionaryString RequestedUnattachedReference;
    public XmlDictionaryString IssuedTokensHeader;
    public XmlDictionaryString RequestTypeRenew;
    public XmlDictionaryString RequestTypeClose;
    public XmlDictionaryString KeyType;
    public XmlDictionaryString SymmetricKeyType;
    public XmlDictionaryString PublicKeyType;
    public XmlDictionaryString Claims;
    public XmlDictionaryString InvalidRequestFaultCode;
    public XmlDictionaryString FailedAuthenticationFaultCode;
    public XmlDictionaryString UseKey;
    public XmlDictionaryString SignWith;
    public XmlDictionaryString EncryptWith;
    public XmlDictionaryString EncryptionAlgorithm;
    public XmlDictionaryString CanonicalizationAlgorithm;
    public XmlDictionaryString ComputedKeyAlgorithm;
    public XmlDictionaryString AsymmetricKeyBinarySecret;
    public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
    public XmlDictionaryString RequestSecurityTokenRenewal;
    public XmlDictionaryString RequestSecurityTokenRenewalResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
    public XmlDictionaryString RequestSecurityTokenCancellation;
    public XmlDictionaryString RequestSecurityTokenCancellationResponse;
    public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
    public XmlDictionaryString KeyWrapAlgorithm;
    public XmlDictionaryString BearerKeyType;
    public XmlDictionaryString SecondaryParameters;
    public XmlDictionaryString Dialect;
    public XmlDictionaryString DialectType;
    public TrustDictionary(IdentityModelDictionary dictionary);
    public TrustDictionary(IXmlDictionary dictionary);
}
internal class System.IdentityModel.TrustFeb2005Dictionary : TrustDictionary {
    public TrustFeb2005Dictionary(IdentityModelDictionary dictionary);
    public TrustFeb2005Dictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.TrustFeb2005Strings : object {
    public static string RequestSecurityTokenResponseCollection;
    public static string Namespace;
    public static string BinarySecretClauseType;
    public static string CombinedHashLabel;
    public static string RequestSecurityTokenResponse;
    public static string TokenType;
    public static string KeySize;
    public static string RequestedTokenReference;
    public static string AppliesTo;
    public static string Authenticator;
    public static string CombinedHash;
    public static string BinaryExchange;
    public static string Lifetime;
    public static string RequestedSecurityToken;
    public static string Entropy;
    public static string RequestedProofToken;
    public static string ComputedKey;
    public static string RequestSecurityToken;
    public static string RequestType;
    public static string Context;
    public static string BinarySecret;
    public static string Type;
    public static string SpnegoValueTypeUri;
    public static string TlsnegoValueTypeUri;
    public static string Prefix;
    public static string RequestSecurityTokenIssuance;
    public static string RequestSecurityTokenIssuanceResponse;
    public static string RequestTypeIssue;
    public static string SymmetricKeyBinarySecret;
    public static string Psha1ComputedKeyUri;
    public static string NonceBinarySecret;
    public static string RenewTarget;
    public static string CloseTarget;
    public static string RequestedTokenClosed;
    public static string RequestedAttachedReference;
    public static string RequestedUnattachedReference;
    public static string IssuedTokensHeader;
    public static string RequestTypeRenew;
    public static string RequestTypeClose;
    public static string KeyType;
    public static string SymmetricKeyType;
    public static string PublicKeyType;
    public static string Claims;
    public static string InvalidRequestFaultCode;
    public static string FailedAuthenticationFaultCode;
    public static string UseKey;
    public static string SignWith;
    public static string EncryptWith;
    public static string EncryptionAlgorithm;
    public static string CanonicalizationAlgorithm;
    public static string ComputedKeyAlgorithm;
}
internal static class System.IdentityModel.TrustStrings : object {
}
public class System.IdentityModel.TypedAsyncResult`1 : AsyncResult {
    public T Result { get; }
    public TypedAsyncResult`1(object state);
    public TypedAsyncResult`1(AsyncCallback callback, object state);
    public void Complete(T result, bool completedSynchronously);
    public void Complete(T result, bool completedSynchronously, Exception exception);
    public static T End(IAsyncResult result);
    public T get_Result();
}
internal class System.IdentityModel.UNICODE_INTPTR_STRING : ValueType {
    internal ushort Length;
    internal ushort MaxLength;
    internal IntPtr Buffer;
    internal UNICODE_INTPTR_STRING(int length, int maximumLength, IntPtr buffer);
}
internal static class System.IdentityModel.UniqueId : object {
    private static UniqueId();
    public static string CreateUniqueId();
    public static string CreateUniqueId(string prefix);
    public static string CreateRandomId();
    public static string CreateRandomId(string prefix);
    public static Uri CreateRandomUri();
}
public class System.IdentityModel.UnsupportedTokenTypeBadRequestException : BadRequestException {
    public string TokenType { get; public set; }
    public UnsupportedTokenTypeBadRequestException(string tokenType);
    public UnsupportedTokenTypeBadRequestException(string message, Exception exception);
    protected UnsupportedTokenTypeBadRequestException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TokenType();
    public void set_TokenType(string value);
}
internal static class System.IdentityModel.UriUtil : object {
    public static bool CanCreateValidUri(string uriString, UriKind uriKind);
    public static bool TryCreateValidUri(string uriString, UriKind uriKind, Uri& result);
}
internal class System.IdentityModel.UtilityDictionary : object {
    public XmlDictionaryString IdAttribute;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString Timestamp;
    public XmlDictionaryString CreatedElement;
    public XmlDictionaryString ExpiresElement;
    public XmlDictionaryString Prefix;
    public UtilityDictionary(IdentityModelDictionary dictionary);
    public UtilityDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.UtilityStrings : object {
    public static string IdAttribute;
    public static string Namespace;
    public static string Timestamp;
    public static string CreatedElement;
    public static string ExpiresElement;
    public static string Prefix;
}
internal class System.IdentityModel.WifSignedInfo : StandardSignedInfo {
    public WifSignedInfo(DictionaryManager dictionaryManager);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void ComputeHash(HashStream hashStream);
    public virtual void ReadFrom(XmlDictionaryReader reader, TransformFactory transformFactory, DictionaryManager dictionaryManager);
}
internal enum System.IdentityModel.Win32Error : Enum {
    public int value__;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NO_TOKEN;
    public static Win32Error ERROR_NONE_MAPPED;
}
internal class System.IdentityModel.WrappedReader : DelegatingXmlDictionaryReader {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XmlTokenStream XmlTokens { get; }
    public WrappedReader(XmlDictionaryReader reader);
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public XmlTokenStream get_XmlTokens();
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string ns);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
internal class System.IdentityModel.WrappedXmlDictionaryReader : XmlDictionaryReader {
    public int AttributeCount { get; }
    public string BaseURI { get; }
    public bool CanReadBinaryContent { get; }
    public bool CanReadValueChunk { get; }
    public int Depth { get; }
    public bool EOF { get; }
    public bool HasValue { get; }
    public bool IsDefault { get; }
    public bool IsEmptyElement { get; }
    public string LocalName { get; }
    public string Name { get; }
    public string NamespaceURI { get; }
    public XmlNameTable NameTable { get; }
    public XmlNodeType NodeType { get; }
    public string Prefix { get; }
    public char QuoteChar { get; }
    public ReadState ReadState { get; }
    public string Value { get; }
    public string XmlLang { get; }
    public XmlSpace XmlSpace { get; }
    public Type ValueType { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    public WrappedXmlDictionaryReader(XmlReader reader, XmlDictionaryReaderQuotas xmlDictionaryReaderQuotas);
    public virtual int get_AttributeCount();
    public virtual string get_BaseURI();
    public virtual bool get_CanReadBinaryContent();
    public virtual bool get_CanReadValueChunk();
    public virtual int get_Depth();
    public virtual bool get_EOF();
    public virtual bool get_HasValue();
    public virtual bool get_IsDefault();
    public virtual bool get_IsEmptyElement();
    public virtual string get_LocalName();
    public virtual string get_Name();
    public virtual string get_NamespaceURI();
    public virtual XmlNameTable get_NameTable();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_Prefix();
    public virtual char get_QuoteChar();
    public virtual ReadState get_ReadState();
    public virtual string get_Value();
    public virtual string get_XmlLang();
    public virtual XmlSpace get_XmlSpace();
    public virtual Type get_ValueType();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public virtual string get_Item(int index);
    public virtual string get_Item(string name);
    public virtual string get_Item(string name, string namespaceUri);
    public virtual void Close();
    public virtual string GetAttribute(int index);
    public virtual string GetAttribute(string name);
    public virtual string GetAttribute(string name, string namespaceUri);
    public virtual bool IsStartElement(string name);
    public virtual bool IsStartElement(string localName, string namespaceUri);
    public virtual string LookupNamespace(string namespaceUri);
    public virtual void MoveToAttribute(int index);
    public virtual bool MoveToAttribute(string name);
    public virtual bool MoveToAttribute(string name, string namespaceUri);
    public virtual bool MoveToElement();
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    public virtual bool ReadAttributeValue();
    public virtual string ReadElementString(string name);
    public virtual string ReadElementString(string localName, string namespaceUri);
    public virtual string ReadInnerXml();
    public virtual string ReadOuterXml();
    public virtual void ReadStartElement(string name);
    public virtual void ReadStartElement(string localName, string namespaceUri);
    public virtual void ReadEndElement();
    public virtual string ReadString();
    public virtual void ResolveEntity();
    public virtual int ReadElementContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBase64(Byte[] buffer, int offset, int count);
    public virtual int ReadElementContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadContentAsBinHex(Byte[] buffer, int offset, int count);
    public virtual int ReadValueChunk(Char[] chars, int offset, int count);
    public virtual bool ReadContentAsBoolean();
    public virtual DateTime ReadContentAsDateTime();
    public virtual decimal ReadContentAsDecimal();
    public virtual double ReadContentAsDouble();
    public virtual int ReadContentAsInt();
    public virtual long ReadContentAsLong();
    public virtual float ReadContentAsFloat();
    public virtual string ReadContentAsString();
    public virtual object ReadContentAs(Type valueType, IXmlNamespaceResolver namespaceResolver);
    public sealed virtual bool HasLineInfo();
}
internal static class System.IdentityModel.WSAddressing10Constants : object {
    public static string Prefix;
    public static string NamespaceUri;
}
internal static class System.IdentityModel.WSAddressing200408Constants : object {
    public static string Prefix;
    public static string NamespaceUri;
}
internal static class System.IdentityModel.WSSecureConversation13Constants : object {
    public static string Namespace;
    public static Uri NamespaceUri;
    public static string Prefix;
    public static string TokenTypeURI;
    public static int DefaultDerivedKeyLength;
    private static WSSecureConversation13Constants();
}
internal static class System.IdentityModel.WSSecureConversationFeb2005Constants : object {
    public static string Namespace;
    public static Uri NamespaceUri;
    public static string Prefix;
    public static string TokenTypeURI;
    public static int DefaultDerivedKeyLength;
    private static WSSecureConversationFeb2005Constants();
}
internal static class System.IdentityModel.WSSecurity10Constants : object {
    public static string FragmentBaseAddress;
    public static string Namespace;
    public static string Prefix;
    public static string Base64EncodingType;
    public static string HexBinaryEncodingType;
    public static string KerberosTokenType1510;
    public static string KerberosTokenTypeGSS;
    public static string TextEncodingType;
    public static string X509TokenType;
    public static string UPTokenPasswordTextValue;
}
internal static class System.IdentityModel.WSSecurity11Constants : object {
    public static string FragmentBaseAddress;
    public static string Namespace;
    public static string Prefix;
}
internal static class System.IdentityModel.WSSecurityUtilityConstants : object {
    public static string Namespace;
    public static string Prefix;
}
internal static class System.IdentityModel.WSUtilityConstants : object {
    public static string NamespaceURI;
    public static string Prefix;
}
internal class System.IdentityModel.X509CertificateValidatorEx : X509CertificateValidator {
    public X509CertificateValidatorEx(X509CertificateValidationMode certificateValidationMode, X509RevocationMode revocationMode, StoreLocation trustedStoreLocation);
    public virtual void Validate(X509Certificate2 certificate);
}
internal static class System.IdentityModel.X509Util : object {
    internal static RSA EnsureAndGetPrivateRSAKey(X509Certificate2 certificate);
    internal static X509Certificate2 ResolveCertificate(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue);
    internal static bool TryResolveCertificate(StoreName storeName, StoreLocation storeLocation, X509FindType findType, object findValue, X509Certificate2& certificate);
    internal static string GetCertificateId(X509Certificate2 certificate);
    internal static string GetCertificateIssuerName(X509Certificate2 certificate, IssuerNameRegistry issuerNameRegistry);
    internal static X509CertificateValidator CreateCertificateValidator(X509CertificateValidationMode certificateValidationMode, X509RevocationMode revocationMode, StoreLocation trustedStoreLocation);
    public static IEnumerable`1<Claim> GetClaimsFromCertificate(X509Certificate2 certificate, string issuer);
}
internal static class System.IdentityModel.XD : object {
    public static IdentityModelDictionary Dictionary { get; }
    public static ExclusiveC14NDictionary ExclusiveC14NDictionary { get; }
    public static SamlDictionary SamlDictionary { get; }
    public static SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary { get; }
    public static SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary { get; }
    public static SecurityAlgorithmDictionary SecurityAlgorithmDictionary { get; }
    public static SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary { get; }
    public static SecurityJan2004Dictionary SecurityJan2004Dictionary { get; }
    public static SecurityXXX2005Dictionary SecurityXXX2005Dictionary { get; }
    public static TrustDec2005Dictionary TrustDec2005Dictionary { get; }
    public static TrustFeb2005Dictionary TrustFeb2005Dictionary { get; }
    public static UtilityDictionary UtilityDictionary { get; }
    public static XmlEncryptionDictionary XmlEncryptionDictionary { get; }
    public static XmlSignatureDictionary XmlSignatureDictionary { get; }
    public static IdentityModelDictionary get_Dictionary();
    public static ExclusiveC14NDictionary get_ExclusiveC14NDictionary();
    public static SamlDictionary get_SamlDictionary();
    public static SecureConversationDec2005Dictionary get_SecureConversationDec2005Dictionary();
    public static SecureConversationFeb2005Dictionary get_SecureConversationFeb2005Dictionary();
    public static SecurityAlgorithmDictionary get_SecurityAlgorithmDictionary();
    public static SecurityAlgorithmDec2005Dictionary get_SecurityAlgorithmDec2005Dictionary();
    public static SecurityJan2004Dictionary get_SecurityJan2004Dictionary();
    public static SecurityXXX2005Dictionary get_SecurityXXX2005Dictionary();
    public static TrustDec2005Dictionary get_TrustDec2005Dictionary();
    public static TrustFeb2005Dictionary get_TrustFeb2005Dictionary();
    public static UtilityDictionary get_UtilityDictionary();
    public static XmlEncryptionDictionary get_XmlEncryptionDictionary();
    public static XmlSignatureDictionary get_XmlSignatureDictionary();
}
internal class System.IdentityModel.XmlAttributeHolder : ValueType {
    private string prefix;
    private string ns;
    private string localName;
    private string value;
    public static XmlAttributeHolder[] emptyArray;
    public string Prefix { get; }
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    public XmlAttributeHolder(string prefix, string localName, string ns, string value);
    private static XmlAttributeHolder();
    public string get_Prefix();
    public string get_NamespaceUri();
    public string get_LocalName();
    public string get_Value();
    public void WriteTo(XmlWriter writer);
    public static void WriteAttributes(XmlAttributeHolder[] attributes, XmlWriter writer);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader);
    public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader, Int32& maxSizeOfHeaders);
    public static string GetAttribute(XmlAttributeHolder[] attributes, string localName, string ns);
}
internal class System.IdentityModel.XmlBuffer : object {
    public int BufferSize { get; }
    public int SectionCount { get; }
    public XmlBuffer(int maxBufferSize);
    public int get_BufferSize();
    public int get_SectionCount();
    public XmlDictionaryWriter OpenSection(XmlDictionaryReaderQuotas quotas);
    public void CloseSection();
    public void Close();
    public XmlDictionaryReader GetReader(int sectionIndex);
    public void WriteTo(int sectionIndex, XmlWriter writer);
}
internal static class System.IdentityModel.XmlEncryptionConstants : object {
    public static string Namespace;
    public static string Prefix;
}
internal class System.IdentityModel.XmlEncryptionDictionary : object {
    public XmlDictionaryString Namespace;
    public XmlDictionaryString DataReference;
    public XmlDictionaryString EncryptedData;
    public XmlDictionaryString EncryptionMethod;
    public XmlDictionaryString CipherData;
    public XmlDictionaryString CipherValue;
    public XmlDictionaryString ReferenceList;
    public XmlDictionaryString Encoding;
    public XmlDictionaryString MimeType;
    public XmlDictionaryString Type;
    public XmlDictionaryString Id;
    public XmlDictionaryString CarriedKeyName;
    public XmlDictionaryString Recipient;
    public XmlDictionaryString EncryptedKey;
    public XmlDictionaryString URI;
    public XmlDictionaryString KeyReference;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString ElementType;
    public XmlDictionaryString ContentType;
    public XmlDictionaryString AlgorithmAttribute;
    public XmlEncryptionDictionary(IdentityModelDictionary dictionary);
    public XmlEncryptionDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.XmlEncryptionStrings : object {
    public static string Namespace;
    public static string DataReference;
    public static string EncryptedData;
    public static string EncryptionMethod;
    public static string CipherData;
    public static string CipherValue;
    public static string ReferenceList;
    public static string Encoding;
    public static string MimeType;
    public static string Type;
    public static string Id;
    public static string CarriedKeyName;
    public static string Recipient;
    public static string EncryptedKey;
    public static string URI;
    public static string KeyReference;
    public static string Prefix;
    public static string ElementType;
    public static string ContentType;
    public static string AlgorithmAttribute;
}
internal static class System.IdentityModel.XmlHelper : object {
    internal static string GetWhiteSpace(XmlReader reader);
    internal static void OnRequiredAttributeMissing(string attrName, string elementName);
    internal static string ReadEmptyElementAndRequiredAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString namespaceUri, XmlDictionaryString attributeName, String& prefix);
    internal static string ReadTextElementAsTrimmedString(XmlElement element);
    internal static void OnRequiredElementMissing(string elementName, string elementNamespace);
    internal static void OnUnexpectedChildNodeError(string parentName, XmlReader r);
    internal static void OnUnexpectedChildNodeError(XmlElement parent, XmlNode n);
    internal static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns);
    public static void WriteAttributeStringAsUniqueId(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id);
    public static long ReadElementContentAsInt64(XmlDictionaryReader reader);
}
internal static class System.IdentityModel.XmlSignatureConstants : object {
    public static string Namespace;
    public static string Prefix;
}
internal class System.IdentityModel.XmlSignatureDictionary : object {
    public XmlDictionaryString Algorithm;
    public XmlDictionaryString URI;
    public XmlDictionaryString Reference;
    public XmlDictionaryString Transforms;
    public XmlDictionaryString Transform;
    public XmlDictionaryString DigestMethod;
    public XmlDictionaryString DigestValue;
    public XmlDictionaryString Namespace;
    public XmlDictionaryString EnvelopedSignature;
    public XmlDictionaryString KeyInfo;
    public XmlDictionaryString Signature;
    public XmlDictionaryString SignedInfo;
    public XmlDictionaryString CanonicalizationMethod;
    public XmlDictionaryString SignatureMethod;
    public XmlDictionaryString SignatureValue;
    public XmlDictionaryString KeyName;
    public XmlDictionaryString Type;
    public XmlDictionaryString MgmtData;
    public XmlDictionaryString Prefix;
    public XmlDictionaryString KeyValue;
    public XmlDictionaryString RsaKeyValue;
    public XmlDictionaryString Modulus;
    public XmlDictionaryString Exponent;
    public XmlDictionaryString X509Data;
    public XmlDictionaryString X509IssuerSerial;
    public XmlDictionaryString X509IssuerName;
    public XmlDictionaryString X509SerialNumber;
    public XmlDictionaryString X509Certificate;
    public XmlSignatureDictionary(IdentityModelDictionary dictionary);
    public XmlSignatureDictionary(IXmlDictionary dictionary);
}
internal static class System.IdentityModel.XmlSignatureStrings : object {
    public static string Algorithm;
    public static string URI;
    public static string Reference;
    public static string Transforms;
    public static string Transform;
    public static string DigestMethod;
    public static string DigestValue;
    public static string Namespace;
    public static string EnvelopedSignature;
    public static string KeyInfo;
    public static string Signature;
    public static string SignedInfo;
    public static string CanonicalizationMethod;
    public static string SignatureMethod;
    public static string SignatureValue;
    public static string KeyName;
    public static string Type;
    public static string MgmtData;
    public static string Prefix;
    public static string KeyValue;
    public static string RsaKeyValue;
    public static string Modulus;
    public static string Exponent;
    public static string X509Data;
    public static string X509IssuerSerial;
    public static string X509IssuerName;
    public static string X509SerialNumber;
    public static string X509Certificate;
    public static string SecurityJan2004Namespace;
    public static string SecurityJan2004Prefix;
    public static string X509Ski;
    public static string TransformationParameters;
}
internal class System.IdentityModel.XmlTokenStream : object {
    private bool System.IdentityModel.ISecurityElement.HasId { get; }
    private string System.IdentityModel.ISecurityElement.Id { get; }
    public XmlTokenStream(int initialSize);
    public XmlTokenStream(XmlTokenStream other);
    public void Add(XmlNodeType type, string value);
    public void AddAttribute(string prefix, string localName, string namespaceUri, string value);
    public void AddElement(string prefix, string localName, string namespaceUri, bool isEmptyElement);
    public void SetElementExclusion(string excludedElement, string excludedElementNamespace);
    public void SetElementExclusion(string excludedElement, string excludedElementNamespace, Nullable`1<int> excludedElementDepth);
    public XmlTokenStream Trim();
    public XmlTokenStreamWriter GetWriter();
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    private sealed virtual override bool System.IdentityModel.ISecurityElement.get_HasId();
    private sealed virtual override string System.IdentityModel.ISecurityElement.get_Id();
}
internal static class System.IdentityModel.XmlUtil : object {
    public static string XmlNs;
    public static string XmlNsNs;
    public static string LanguagePrefix;
    public static string LanguageLocalname;
    public static string LanguageAttribute;
    public static bool IsWhitespace(char ch);
    public static string TrimEnd(string s);
    public static string TrimStart(string s);
    public static string Trim(string s);
    public static XmlQualifiedName GetXsiType(XmlReader reader);
    public static bool EqualsQName(XmlQualifiedName qname, string localName, string namespaceUri);
    public static bool IsNil(XmlReader reader);
    public static string NormalizeEmptyString(string s);
    public static XmlQualifiedName ResolveQName(XmlReader reader, string qstring);
    public static void ValidateXsiType(XmlReader reader, string expectedTypeName, string expectedTypeNamespace);
    public static void ValidateXsiType(XmlReader reader, string expectedTypeName, string expectedTypeNamespace, bool requireDeclaration);
    public static string SerializeSecurityKeyIdentifier(SecurityKeyIdentifier ski, SecurityTokenSerializer tokenSerializer);
    public static bool IsValidXmlIDValue(string val);
    public static void WriteElementStringAsUniqueId(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, string id);
    public static void WriteElementContentAsInt64(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, long value);
    public static long ReadElementContentAsInt64(XmlDictionaryReader reader);
    public static List`1<XmlElement> GetXmlElements(XmlNodeList nodeList);
}
internal static class System.LocalAppContext : object {
    private static LocalAppContext();
    public static bool IsSwitchEnabled(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
public class System.Security.Claims.AuthenticationInformation : object {
    public string Address { get; public set; }
    public Collection`1<AuthenticationContext> AuthorizationContexts { get; }
    public string DnsName { get; public set; }
    public Nullable`1<DateTime> NotOnOrAfter { get; public set; }
    public string Session { get; public set; }
    public string get_Address();
    public void set_Address(string value);
    public Collection`1<AuthenticationContext> get_AuthorizationContexts();
    public string get_DnsName();
    public void set_DnsName(string value);
    public Nullable`1<DateTime> get_NotOnOrAfter();
    public void set_NotOnOrAfter(Nullable`1<DateTime> value);
    public string get_Session();
    public void set_Session(string value);
}
internal static class System.Security.Claims.AuthenticationTypeMaps : object {
    public static Mapping[] Saml;
    public static Mapping[] Saml2;
    private static AuthenticationTypeMaps();
    public static string Denormalize(string normalizedAuthenticationMethod, Mapping[] mappingTable);
    public static string Normalize(string unnormalizedAuthenticationMethod, Mapping[] mappingTable);
}
public static class System.Security.Claims.AuthenticationTypes : object {
    public static string Basic;
    public static string Federation;
    public static string Kerberos;
    public static string Negotiate;
    public static string Password;
    public static string Signature;
    public static string Windows;
    public static string X509;
}
public class System.Security.Claims.AuthorizationContext : object {
    public Collection`1<Claim> Action { get; }
    public Collection`1<Claim> Resource { get; }
    public ClaimsPrincipal Principal { get; }
    public AuthorizationContext(ClaimsPrincipal principal, string resource, string action);
    public AuthorizationContext(ClaimsPrincipal principal, Collection`1<Claim> resource, Collection`1<Claim> action);
    public Collection`1<Claim> get_Action();
    public Collection`1<Claim> get_Resource();
    public ClaimsPrincipal get_Principal();
}
public static class System.Security.Claims.ClaimProperties : object {
    public static string Namespace;
    public static string SamlAttributeDisplayName;
    public static string SamlAttributeNameFormat;
    public static string SamlNameIdentifierFormat;
    public static string SamlNameIdentifierNameQualifier;
    public static string SamlNameIdentifierSPNameQualifier;
    public static string SamlNameIdentifierSPProvidedId;
}
public class System.Security.Claims.ClaimsAuthenticationManager : object {
    public virtual ClaimsPrincipal Authenticate(string resourceName, ClaimsPrincipal incomingPrincipal);
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
}
public class System.Security.Claims.ClaimsAuthorizationManager : object {
    public virtual bool CheckAccess(AuthorizationContext context);
    public virtual void LoadCustomConfiguration(XmlNodeList nodelist);
}
internal static class System.Security.Claims.ClaimsConversionHelper : object {
    public static ClaimsIdentity CreateClaimsIdentityFromClaimSet(ClaimSet claimset, string authenticationType);
    public static ClaimsIdentity CreateClaimsIdentityFromClaimSet(ClaimSet claimset);
    public static Claim CreateClaimFromWcfClaim(Claim wcfClaim);
    public static Claim CreateClaimFromWcfClaim(Claim wcfClaim, string issuer);
}
internal static class System.Security.Claims.ClaimsHelper : object {
    public static WindowsIdentity CertificateLogon(X509Certificate2 x509Certificate);
    public static string FindUpn(ClaimsIdentity claimsIdentity);
}
internal static class System.Security.Cryptography.CngLightup : object {
    private static CngLightup();
    internal static RSA GetRSAPublicKey(X509Certificate2 cert);
    internal static RSA GetRSAPrivateKey(X509Certificate2 cert);
    internal static DSA GetDSAPublicKey(X509Certificate2 cert);
    internal static DSA GetDSAPrivateKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPrivateKey(X509Certificate2 cert);
    internal static Byte[] Pkcs1SignData(RSA rsa, Byte[] data, string hashAlgorithmName);
    internal static bool Pkcs1VerifyData(RSA rsa, Byte[] data, Byte[] signature, string hashAlgorithmName);
    internal static Byte[] Pkcs1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] Pkcs1Decrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Decrypt(RSA rsa, Byte[] data);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.BinarySecretKeyIdentifierClause : BinaryKeyIdentifierClause {
    public bool CanCreateKey { get; }
    public BinarySecretKeyIdentifierClause(Byte[] key);
    public BinarySecretKeyIdentifierClause(Byte[] key, bool cloneBuffer);
    public BinarySecretKeyIdentifierClause(Byte[] key, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetKeyBytes();
    public virtual bool get_CanCreateKey();
    public virtual SecurityKey CreateKey();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.EncryptedKey : EncryptedType {
    internal static XmlDictionaryString CarriedKeyElementName;
    internal static XmlDictionaryString ElementName;
    internal static XmlDictionaryString RecipientAttribute;
    public string CarriedKeyName { get; public set; }
    public string Recipient { get; public set; }
    public ReferenceList ReferenceList { get; public set; }
    protected XmlDictionaryString OpeningElementName { get; }
    private static EncryptedKey();
    public string get_CarriedKeyName();
    public void set_CarriedKeyName(string value);
    public string get_Recipient();
    public void set_Recipient(string value);
    public ReferenceList get_ReferenceList();
    public void set_ReferenceList(ReferenceList value);
    protected virtual XmlDictionaryString get_OpeningElementName();
    protected virtual void ForceEncryption();
    public Byte[] GetWrappedKey();
    public void SetUpKeyWrap(Byte[] wrappedKey);
    protected virtual void ReadAdditionalAttributes(XmlDictionaryReader reader);
    protected virtual void ReadAdditionalElements(XmlDictionaryReader reader);
    protected virtual void ReadCipherData(XmlDictionaryReader reader);
    protected virtual void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize);
    protected virtual void WriteAdditionalAttributes(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected virtual void WriteAdditionalElements(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected virtual void WriteCipherData(XmlDictionaryWriter writer);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.EncryptedKeyHashIdentifierClause : BinaryKeyIdentifierClause {
    public EncryptedKeyHashIdentifierClause(Byte[] encryptedKeyHash);
    internal EncryptedKeyHashIdentifierClause(Byte[] encryptedKeyHash, bool cloneBuffer);
    internal EncryptedKeyHashIdentifierClause(Byte[] encryptedKeyHash, bool cloneBuffer, Byte[] derivationNonce, int derivationLength);
    public Byte[] GetEncryptedKeyHash();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal abstract class System.ServiceModel.Security.EncryptedType : object {
    internal static XmlDictionaryString NamespaceUri;
    internal static XmlDictionaryString EncodingAttribute;
    internal static XmlDictionaryString MimeTypeAttribute;
    internal static XmlDictionaryString TypeAttribute;
    internal static XmlDictionaryString CipherDataElementName;
    internal static XmlDictionaryString CipherValueElementName;
    public string Encoding { get; public set; }
    public string EncryptionMethod { get; public set; }
    public XmlDictionaryString EncryptionMethodDictionaryString { get; public set; }
    public bool HasId { get; }
    public string Id { get; public set; }
    public bool ShouldReadXmlReferenceKeyInfoClause { get; public set; }
    public string WsuId { get; public set; }
    public SecurityKeyIdentifier KeyIdentifier { get; public set; }
    public string MimeType { get; public set; }
    public string Type { get; public set; }
    protected XmlDictionaryString OpeningElementName { get; }
    protected EncryptionState State { get; protected set; }
    public SecurityTokenSerializer SecurityTokenSerializer { get; public set; }
    private static EncryptedType();
    public string get_Encoding();
    public void set_Encoding(string value);
    public string get_EncryptionMethod();
    public void set_EncryptionMethod(string value);
    public XmlDictionaryString get_EncryptionMethodDictionaryString();
    public void set_EncryptionMethodDictionaryString(XmlDictionaryString value);
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public void set_Id(string value);
    public bool get_ShouldReadXmlReferenceKeyInfoClause();
    public void set_ShouldReadXmlReferenceKeyInfoClause(bool value);
    public string get_WsuId();
    public void set_WsuId(string value);
    public SecurityKeyIdentifier get_KeyIdentifier();
    public void set_KeyIdentifier(SecurityKeyIdentifier value);
    public string get_MimeType();
    public void set_MimeType(string value);
    public string get_Type();
    public void set_Type(string value);
    protected abstract virtual XmlDictionaryString get_OpeningElementName();
    protected EncryptionState get_State();
    protected void set_State(EncryptionState value);
    public SecurityTokenSerializer get_SecurityTokenSerializer();
    public void set_SecurityTokenSerializer(SecurityTokenSerializer value);
    protected abstract virtual void ForceEncryption();
    protected virtual void ReadAdditionalAttributes(XmlDictionaryReader reader);
    protected virtual void ReadAdditionalElements(XmlDictionaryReader reader);
    protected abstract virtual void ReadCipherData(XmlDictionaryReader reader);
    protected abstract virtual void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize);
    public void ReadFrom(XmlReader reader);
    public void ReadFrom(XmlDictionaryReader reader);
    public void ReadFrom(XmlReader reader, long maxBufferSize);
    public void ReadFrom(XmlDictionaryReader reader, long maxBufferSize);
    protected virtual void WriteAdditionalAttributes(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected virtual void WriteAdditionalElements(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
    protected abstract virtual void WriteCipherData(XmlDictionaryWriter writer);
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal interface System.ServiceModel.Security.ISspiNegotiation {
    public DateTime ExpirationTimeUtc { get; }
    public bool IsCompleted { get; }
    public bool IsValidContext { get; }
    public string KeyEncryptionAlgorithm { get; }
    public abstract virtual DateTime get_ExpirationTimeUtc();
    public abstract virtual bool get_IsCompleted();
    public abstract virtual bool get_IsValidContext();
    public abstract virtual string get_KeyEncryptionAlgorithm();
    public abstract virtual Byte[] Decrypt(Byte[] encryptedData);
    public abstract virtual Byte[] Encrypt(Byte[] data);
    public abstract virtual Byte[] GetOutgoingBlob(Byte[] incomingBlob, ChannelBinding channelbinding, ExtendedProtectionPolicy protectionPolicy);
    public abstract virtual string GetRemoteIdentityName();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal interface System.ServiceModel.Security.ISspiNegotiationInfo {
    public ISspiNegotiation SspiNegotiation { get; }
    public abstract virtual ISspiNegotiation get_SspiNegotiation();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.KeyNameIdentifierClause : SecurityKeyIdentifierClause {
    public string KeyName { get; }
    public KeyNameIdentifierClause(string keyName);
    public string get_KeyName();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(string keyName);
    public virtual string ToString();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.ReferenceList : object {
    internal static XmlDictionaryString ElementName;
    internal static XmlDictionaryString NamespaceUri;
    internal static XmlDictionaryString UriAttribute;
    public int DataReferenceCount { get; }
    public bool HasId { get; }
    public string Id { get; }
    private static ReferenceList();
    public int get_DataReferenceCount();
    public sealed virtual bool get_HasId();
    public sealed virtual string get_Id();
    public void AddReferredId(string id);
    public bool ContainsReferredId(string id);
    public string GetReferredId(int index);
    public void ReadFrom(XmlDictionaryReader reader);
    public bool TryRemoveReferredId(string id);
    public sealed virtual void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.RelAssertionDirectKeyIdentifierClause : SecurityKeyIdentifierClause {
    public string AssertionId { get; }
    public RelAssertionDirectKeyIdentifierClause(string assertionId, Byte[] derivationNonce, int derivationLength);
    public string get_AssertionId();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.SamlAssertionDirectKeyIdentifierClause : SecurityKeyIdentifierClause {
    public string SamlUri { get; }
    public SamlAssertionDirectKeyIdentifierClause(string samlUri, Byte[] derivationNonce, int derivationLength);
    public string get_SamlUri();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
    public UniqueId ContextId { get; }
    public UniqueId Generation { get; }
    public SecurityContextKeyIdentifierClause(UniqueId contextId);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation);
    public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation, Byte[] derivationNonce, int derivationLength);
    public UniqueId get_ContextId();
    public UniqueId get_Generation();
    public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
    public bool Matches(UniqueId contextId, UniqueId generation);
    public virtual string ToString();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.Tokens.BinarySecretSecurityToken : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public int KeySize { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    public BinarySecretSecurityToken(int keySizeInBits);
    public BinarySecretSecurityToken(string id, int keySizeInBits);
    public BinarySecretSecurityToken(Byte[] key);
    public BinarySecretSecurityToken(string id, Byte[] key);
    protected BinarySecretSecurityToken(string id, int keySizeInBits, bool allowCrypto);
    protected BinarySecretSecurityToken(string id, Byte[] key, bool allowCrypto);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    public int get_KeySize();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    public Byte[] GetKeyBytes();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.ServiceModel.Security.Tokens.BufferedGenericXmlSecurityToken : GenericXmlSecurityToken {
    public XmlBuffer TokenXmlBuffer { get; }
    public BufferedGenericXmlSecurityToken(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies, XmlBuffer tokenXmlBuffer);
    public XmlBuffer get_TokenXmlBuffer();
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ServiceModel.Security.Tokens.WrappedKeySecurityToken : SecurityToken {
    public string Id { get; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    internal EncryptedKey EncryptedKey { get; internal set; }
    internal ReferenceList ReferenceList { get; }
    public string WrappingAlgorithm { get; }
    internal SecurityKey WrappingSecurityKey { get; }
    public SecurityToken WrappingToken { get; }
    public SecurityKeyIdentifier WrappingTokenReference { get; }
    internal string CarriedKeyName { get; }
    public ReadOnlyCollection`1<SecurityKey> SecurityKeys { get; }
    internal WrappedKeySecurityToken(string id, Byte[] keyToWrap, ISspiNegotiation wrappingSspiContext);
    public WrappedKeySecurityToken(string id, Byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference);
    internal WrappedKeySecurityToken(string id, Byte[] keyToWrap, string wrappingAlgorithm, XmlDictionaryString wrappingAlgorithmDictionaryString, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference);
    internal WrappedKeySecurityToken(string id, Byte[] keyToWrap, string wrappingAlgorithm, ISspiNegotiation wrappingSspiContext, Byte[] wrappedKey);
    internal WrappedKeySecurityToken(string id, Byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference, Byte[] wrappedKey, SecurityKey wrappingSecurityKey);
    public virtual string get_Id();
    public virtual DateTime get_ValidFrom();
    public virtual DateTime get_ValidTo();
    internal EncryptedKey get_EncryptedKey();
    internal void set_EncryptedKey(EncryptedKey value);
    internal ReferenceList get_ReferenceList();
    public string get_WrappingAlgorithm();
    internal SecurityKey get_WrappingSecurityKey();
    public SecurityToken get_WrappingToken();
    public SecurityKeyIdentifier get_WrappingTokenReference();
    internal string get_CarriedKeyName();
    public virtual ReadOnlyCollection`1<SecurityKey> get_SecurityKeys();
    internal Byte[] GetHash();
    public Byte[] GetWrappedKey();
    internal void EnsureEncryptedKeySetUp();
    public virtual bool CanCreateKeyIdentifierClause();
    public virtual T CreateKeyIdentifierClause();
    public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
}
[TypeForwardedFromAttribute("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.ServiceModel.Security.X509CertificateValidationMode : Enum {
    public int value__;
    public static X509CertificateValidationMode None;
    public static X509CertificateValidationMode PeerTrust;
    public static X509CertificateValidationMode ChainTrust;
    public static X509CertificateValidationMode PeerOrChainTrust;
    public static X509CertificateValidationMode Custom;
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
