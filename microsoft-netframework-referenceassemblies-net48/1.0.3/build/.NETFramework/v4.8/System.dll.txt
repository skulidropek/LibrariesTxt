internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string EcmaPublicKeyFull;
    internal static string SilverlightPublicKey;
    internal static string SilverlightPublicKeyToken;
    internal static string SilverlightPublicKeyFull;
    internal static string SilverlightPlatformPublicKey;
    internal static string SilverlightPlatformPublicKeyToken;
    internal static string SilverlightPlatformPublicKeyFull;
    internal static string PlatformPublicKey;
    internal static string PlatformPublicKeyToken;
    internal static string PlatformPublicKeyFull;
    internal static string Mscorlib;
    internal static string SystemData;
    internal static string SystemDataOracleClient;
    internal static string System;
    internal static string SystemCore;
    internal static string SystemNumerics;
    internal static string SystemRuntimeRemoting;
    internal static string SystemThreadingTasksDataflow;
    internal static string SystemWindowsForms;
    internal static string SystemXml;
    internal static string MicrosoftPublicKey;
    internal static string MicrosoftPublicKeyToken;
    internal static string MicrosoftPublicKeyFull;
    internal static string SharedLibPublicKey;
    internal static string SharedLibPublicKeyToken;
    internal static string SharedLibPublicKeyFull;
    internal static string SystemComponentModelDataAnnotations;
    internal static string SystemConfiguration;
    internal static string SystemConfigurationInstall;
    internal static string SystemDeployment;
    internal static string SystemDesign;
    internal static string SystemDirectoryServices;
    internal static string SystemDrawingDesign;
    internal static string SystemDrawing;
    internal static string SystemEnterpriseServices;
    internal static string SystemManagement;
    internal static string SystemMessaging;
    internal static string SystemNetHttp;
    internal static string SystemNetHttpWebRequest;
    internal static string SystemRuntimeSerializationFormattersSoap;
    internal static string SystemRuntimeWindowsRuntime;
    internal static string SystemRuntimeWindowsRuntimeUIXaml;
    internal static string SystemSecurity;
    internal static string SystemServiceModelWeb;
    internal static string SystemServiceProcess;
    internal static string SystemWeb;
    internal static string SystemWebAbstractions;
    internal static string SystemWebDynamicData;
    internal static string SystemWebDynamicDataDesign;
    internal static string SystemWebEntityDesign;
    internal static string SystemWebExtensions;
    internal static string SystemWebExtensionsDesign;
    internal static string SystemWebMobile;
    internal static string SystemWebRegularExpressions;
    internal static string SystemWebRouting;
    internal static string SystemWebServices;
    internal static string WindowsBase;
    internal static string MicrosoftVisualStudio;
    internal static string MicrosoftVisualStudioWindowsForms;
    internal static string VJSharpCodeProvider;
    internal static string ASPBrowserCapsPublicKey;
    internal static string ASPBrowserCapsFactory;
    internal static string EnvDTE;
    internal static string MicrosoftVisualStudioConfiguration;
    internal static string MicrosoftVisualStudioDesign;
    internal static string MicrosoftVisualCCppCodeProvider;
    internal static string MicrosoftVisualBasic;
    internal static string MicrosoftVSDesigner;
    internal static string MicrosoftVisualStudioWeb;
    internal static string MicrosoftWebDesign;
    internal static string MicrosoftVSDesignerMobile;
    internal static string MicrosoftJScript;
}
internal static class FXAssembly : object {
    internal static string Version;
}
internal static class Interop : object {
}
internal enum MatchState : Enum {
    public int value__;
    public static MatchState HasSymbol;
    public static MatchState HasMatch;
    public static MatchState HasSymbolAndMatch;
}
internal class Microsoft.CSharp.CSharpCodeGenerator : object {
    internal CSharpCodeGenerator(IDictionary`2<string, string> providerOptions);
    private static CSharpCodeGenerator();
    public void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    public sealed virtual bool Supports(GeneratorSupport support);
    public sealed virtual bool IsValidIdentifier(string value);
    public sealed virtual void ValidateIdentifier(string value);
    public sealed virtual string CreateValidIdentifier(string name);
    public sealed virtual string CreateEscapedIdentifier(string name);
    public sealed virtual string GetTypeOutput(CodeTypeReference typeRef);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    internal void Compile(CompilerParameters options, string compilerDirectory, string compilerExe, string arguments, String& outputFile, Int32& nativeReturnValue, string trueArgs);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
}
public class Microsoft.CSharp.CSharpCodeProvider : CodeDomProvider {
    public string FileExtension { get; }
    public CSharpCodeProvider(IDictionary`2<string, string> providerOptions);
    public virtual string get_FileExtension();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeGenerator CreateGenerator();
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeCompiler CreateCompiler();
    public virtual TypeConverter GetConverter(Type type);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
}
internal class Microsoft.CSharp.CSharpMemberAttributeConverter : CSharpModifierAttributeConverter {
    public static CSharpMemberAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    public static CSharpMemberAttributeConverter get_Default();
    protected virtual String[] get_Names();
    protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal abstract class Microsoft.CSharp.CSharpModifierAttributeConverter : TypeConverter {
    protected Object[] Values { get; }
    protected String[] Names { get; }
    protected object DefaultValue { get; }
    protected abstract virtual Object[] get_Values();
    protected abstract virtual String[] get_Names();
    protected abstract virtual object get_DefaultValue();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class Microsoft.CSharp.CSharpTypeAttributeConverter : CSharpModifierAttributeConverter {
    public static CSharpTypeAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    public static CSharpTypeAttributeConverter get_Default();
    protected virtual String[] get_Names();
    protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal class Microsoft.VisualBasic.VBCodeGenerator : CodeCompiler {
    protected string FileExtension { get; }
    protected string CompilerName { get; }
    protected string NullToken { get; }
    internal VBCodeGenerator(IDictionary`2<string, string> providerOptions);
    private static VBCodeGenerator();
    protected virtual string get_FileExtension();
    protected virtual string get_CompilerName();
    protected virtual string get_NullToken();
    protected virtual string QuoteSnippetString(string value);
    protected virtual void ProcessCompilerOutputLine(CompilerResults results, string line);
    protected virtual string CmdArgsFromParameters(CompilerParameters options);
    protected virtual void OutputAttributeArgument(CodeAttributeArgument arg);
    protected virtual void OutputDirection(FieldDirection dir);
    protected virtual void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
    protected virtual void GenerateDirectionExpression(CodeDirectionExpression e);
    protected virtual void OutputFieldScopeModifier(MemberAttributes attributes);
    protected virtual void OutputMemberAccessModifier(MemberAttributes attributes);
    protected virtual void OutputMemberScopeModifier(MemberAttributes attributes);
    protected virtual void OutputOperator(CodeBinaryOperatorType op);
    protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs);
    protected virtual void OutputIdentifier(string ident);
    protected virtual void OutputType(CodeTypeReference typeRef);
    protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name);
    protected virtual void GenerateIterationStatement(CodeIterationStatement e);
    protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e);
    protected virtual void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
    protected virtual void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
    protected virtual void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
    protected virtual void GenerateCastExpression(CodeCastExpression e);
    protected virtual void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
    protected virtual void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
    protected virtual void GenerateSingleFloatValue(float s);
    protected virtual void GenerateDoubleValue(double d);
    protected virtual void GenerateDecimalValue(decimal d);
    protected virtual void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    protected virtual void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
    protected virtual void GenerateIndexerExpression(CodeIndexerExpression e);
    protected virtual void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
    protected virtual void GenerateSnippetExpression(CodeSnippetExpression e);
    protected virtual void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
    protected virtual void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
    protected virtual void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
    protected virtual void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    protected virtual void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
    protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    protected virtual void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    protected virtual void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
    protected virtual void GenerateExpressionStatement(CodeExpressionStatement e);
    protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e);
    protected virtual void GenerateComment(CodeComment e);
    protected virtual void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
    protected virtual void GenerateConditionStatement(CodeConditionStatement e);
    protected virtual void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    protected virtual void GenerateAssignStatement(CodeAssignStatement e);
    protected virtual void GenerateAttachEventStatement(CodeAttachEventStatement e);
    protected virtual void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
    protected virtual void GenerateSnippetStatement(CodeSnippetStatement e);
    protected virtual void GenerateGotoStatement(CodeGotoStatement e);
    protected virtual void GenerateLabeledStatement(CodeLabeledStatement e);
    protected virtual void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    protected virtual void GenerateLinePragmaStart(CodeLinePragma e);
    protected virtual void GenerateLinePragmaEnd(CodeLinePragma e);
    protected virtual void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
    protected virtual void GenerateField(CodeMemberField e);
    protected virtual void GenerateSnippetMember(CodeSnippetTypeMember e);
    protected virtual void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
    protected virtual void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
    protected virtual void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
    protected virtual void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
    protected virtual void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
    protected virtual void GenerateTypeConstructor(CodeTypeConstructor e);
    protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e);
    protected virtual void GenerateTypeStart(CodeTypeDeclaration e);
    protected virtual void GenerateTypeEnd(CodeTypeDeclaration e);
    protected virtual void GenerateNamespace(CodeNamespace e);
    protected bool AllowLateBound(CodeCompileUnit e);
    protected bool RequireVariableDeclaration(CodeCompileUnit e);
    protected virtual void GenerateCompileUnitStart(CodeCompileUnit e);
    protected virtual void GenerateCompileUnit(CodeCompileUnit e);
    protected virtual void GenerateDirectives(CodeDirectiveCollection directives);
    protected virtual void GenerateNamespaceStart(CodeNamespace e);
    protected virtual void GenerateNamespaceEnd(CodeNamespace e);
    protected virtual void GenerateNamespaceImport(CodeNamespaceImport e);
    protected virtual void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
    protected virtual void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
    public static bool IsKeyword(string value);
    protected virtual bool Supports(GeneratorSupport support);
    protected virtual bool IsValidIdentifier(string value);
    protected virtual string CreateValidIdentifier(string name);
    protected virtual string CreateEscapedIdentifier(string name);
    protected virtual string GetTypeOutput(CodeTypeReference typeRef);
    protected virtual void ContinueOnNewLine(string st);
    protected virtual CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames);
}
public class Microsoft.VisualBasic.VBCodeProvider : CodeDomProvider {
    public string FileExtension { get; }
    public LanguageOptions LanguageOptions { get; }
    public VBCodeProvider(IDictionary`2<string, string> providerOptions);
    public virtual string get_FileExtension();
    public virtual LanguageOptions get_LanguageOptions();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeGenerator CreateGenerator();
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class.")]
public virtual ICodeCompiler CreateCompiler();
    public virtual TypeConverter GetConverter(Type type);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
}
internal class Microsoft.VisualBasic.VBMemberAttributeConverter : VBModifierAttributeConverter {
    public static VBMemberAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    public static VBMemberAttributeConverter get_Default();
    protected virtual String[] get_Names();
    protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
internal abstract class Microsoft.VisualBasic.VBModifierAttributeConverter : TypeConverter {
    protected Object[] Values { get; }
    protected String[] Names { get; }
    protected object DefaultValue { get; }
    protected abstract virtual Object[] get_Values();
    protected abstract virtual String[] get_Names();
    protected abstract virtual object get_DefaultValue();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class Microsoft.VisualBasic.VBTypeAttributeConverter : VBModifierAttributeConverter {
    public static VBTypeAttributeConverter Default { get; }
    protected String[] Names { get; }
    protected Object[] Values { get; }
    protected object DefaultValue { get; }
    public static VBTypeAttributeConverter get_Default();
    protected virtual String[] get_Names();
    protected virtual Object[] get_Values();
    protected virtual object get_DefaultValue();
}
[ComVisibleAttribute("False")]
[GuidAttribute("79eac9ee-baf9-11ce-8c82-00aa004ba90b")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Win32.IInternetSecurityManager {
    public abstract virtual void SetSecuritySite(Void* pSite);
    public abstract virtual void GetSecuritySite(Void** ppSite);
    [SuppressUnmanagedCodeSecurityAttribute]
public abstract virtual void MapUrlToZone(string pwszUrl, Int32& pdwZone, int dwFlags);
    public abstract virtual void GetSecurityId(string pwszUrl, Byte* pbSecurityId, Int32* pcbSecurityId, int dwReserved);
    public abstract virtual void ProcessUrlAction(string pwszUrl, int dwAction, Byte* pPolicy, int cbPolicy, Byte* pContext, int cbContext, int dwFlags, int dwReserved);
    public abstract virtual void QueryCustomPolicy(string pwszUrl, Void* guidKey, Byte** ppPolicy, Int32* pcbPolicy, Byte* pContext, int cbContext, int dwReserved);
    public abstract virtual void SetZoneMapping(int dwZone, string lpszPattern, int dwFlags);
    public abstract virtual void GetZoneMappings(int dwZone, Void** ppenumString, int dwFlags);
}
[ComVisibleAttribute("False")]
[GuidAttribute("7b8a2d94-0ac9-11d1-896c-00c04Fb6bfc4")]
internal class Microsoft.Win32.InternetSecurityManager : object {
}
public class Microsoft.Win32.IntranetZoneCredentialPolicy : object {
    public virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authModule);
}
internal static class Microsoft.Win32.NativeMethods : object {
    public static int DEFAULT_GUI_FONT;
    public static int SM_CYSCREEN;
    public static HandleRef NullHandleRef;
    public static IntPtr INVALID_HANDLE_VALUE;
    public static int GENERIC_READ;
    public static int GENERIC_WRITE;
    public static int FILE_SHARE_READ;
    public static int FILE_SHARE_WRITE;
    public static int FILE_SHARE_DELETE;
    public static int S_OK;
    public static int E_ABORT;
    public static int E_NOTIMPL;
    public static int CREATE_ALWAYS;
    public static int FILE_ATTRIBUTE_NORMAL;
    public static int STARTF_USESTDHANDLES;
    public static int STD_INPUT_HANDLE;
    public static int STD_OUTPUT_HANDLE;
    public static int STD_ERROR_HANDLE;
    public static int STILL_ACTIVE;
    public static int SW_HIDE;
    public static int WAIT_OBJECT_0;
    public static int WAIT_FAILED;
    public static int WAIT_TIMEOUT;
    public static int WAIT_ABANDONED;
    public static int WAIT_ABANDONED_0;
    public static int MOVEFILE_REPLACE_EXISTING;
    public static int ERROR_CLASS_ALREADY_EXISTS;
    public static int ERROR_NONE_MAPPED;
    public static int ERROR_INSUFFICIENT_BUFFER;
    public static int ERROR_INVALID_NAME;
    public static int ERROR_PROC_NOT_FOUND;
    public static int ERROR_BAD_EXE_FORMAT;
    public static int ERROR_EXE_MACHINE_TYPE_MISMATCH;
    public static int MAX_PATH;
    public static int UIS_SET;
    public static int WSF_VISIBLE;
    public static int UIS_CLEAR;
    public static int UISF_HIDEFOCUS;
    public static int UISF_HIDEACCEL;
    public static int USERCLASSTYPE_FULL;
    public static int UOI_FLAGS;
    public static int COLOR_WINDOW;
    public static int WS_POPUP;
    public static int WS_VISIBLE;
    public static int WM_SETTINGCHANGE;
    public static int WM_SYSCOLORCHANGE;
    public static int WM_QUERYENDSESSION;
    public static int WM_QUIT;
    public static int WM_ENDSESSION;
    public static int WM_POWERBROADCAST;
    public static int WM_COMPACTING;
    public static int WM_DISPLAYCHANGE;
    public static int WM_FONTCHANGE;
    public static int WM_PALETTECHANGED;
    public static int WM_TIMECHANGE;
    public static int WM_THEMECHANGED;
    public static int WM_WTSSESSION_CHANGE;
    public static int ENDSESSION_LOGOFF;
    public static int WM_TIMER;
    public static int WM_USER;
    public static int WM_CREATETIMER;
    public static int WM_KILLTIMER;
    public static int WM_REFLECT;
    public static int WTS_CONSOLE_CONNECT;
    public static int WTS_CONSOLE_DISCONNECT;
    public static int WTS_REMOTE_CONNECT;
    public static int WTS_REMOTE_DISCONNECT;
    public static int WTS_SESSION_LOGON;
    public static int WTS_SESSION_LOGOFF;
    public static int WTS_SESSION_LOCK;
    public static int WTS_SESSION_UNLOCK;
    public static int WTS_SESSION_REMOTE_CONTROL;
    public static int NOTIFY_FOR_THIS_SESSION;
    public static int CTRL_C_EVENT;
    public static int CTRL_BREAK_EVENT;
    public static int CTRL_CLOSE_EVENT;
    public static int CTRL_LOGOFF_EVENT;
    public static int CTRL_SHUTDOWN_EVENT;
    public static int SPI_GETBEEP;
    public static int SPI_SETBEEP;
    public static int SPI_GETMOUSE;
    public static int SPI_SETMOUSE;
    public static int SPI_GETBORDER;
    public static int SPI_SETBORDER;
    public static int SPI_GETKEYBOARDSPEED;
    public static int SPI_SETKEYBOARDSPEED;
    public static int SPI_LANGDRIVER;
    public static int SPI_ICONHORIZONTALSPACING;
    public static int SPI_GETSCREENSAVETIMEOUT;
    public static int SPI_SETSCREENSAVETIMEOUT;
    public static int SPI_GETSCREENSAVEACTIVE;
    public static int SPI_SETSCREENSAVEACTIVE;
    public static int SPI_GETGRIDGRANULARITY;
    public static int SPI_SETGRIDGRANULARITY;
    public static int SPI_SETDESKWALLPAPER;
    public static int SPI_SETDESKPATTERN;
    public static int SPI_GETKEYBOARDDELAY;
    public static int SPI_SETKEYBOARDDELAY;
    public static int SPI_ICONVERTICALSPACING;
    public static int SPI_GETICONTITLEWRAP;
    public static int SPI_SETICONTITLEWRAP;
    public static int SPI_GETMENUDROPALIGNMENT;
    public static int SPI_SETMENUDROPALIGNMENT;
    public static int SPI_SETDOUBLECLKWIDTH;
    public static int SPI_SETDOUBLECLKHEIGHT;
    public static int SPI_GETICONTITLELOGFONT;
    public static int SPI_SETDOUBLECLICKTIME;
    public static int SPI_SETMOUSEBUTTONSWAP;
    public static int SPI_SETICONTITLELOGFONT;
    public static int SPI_GETFASTTASKSWITCH;
    public static int SPI_SETFASTTASKSWITCH;
    public static int SPI_SETDRAGFULLWINDOWS;
    public static int SPI_GETDRAGFULLWINDOWS;
    public static int SPI_GETNONCLIENTMETRICS;
    public static int SPI_SETNONCLIENTMETRICS;
    public static int SPI_GETMINIMIZEDMETRICS;
    public static int SPI_SETMINIMIZEDMETRICS;
    public static int SPI_GETICONMETRICS;
    public static int SPI_SETICONMETRICS;
    public static int SPI_SETWORKAREA;
    public static int SPI_GETWORKAREA;
    public static int SPI_SETPENWINDOWS;
    public static int SPI_GETHIGHCONTRAST;
    public static int SPI_SETHIGHCONTRAST;
    public static int SPI_GETKEYBOARDPREF;
    public static int SPI_SETKEYBOARDPREF;
    public static int SPI_GETSCREENREADER;
    public static int SPI_SETSCREENREADER;
    public static int SPI_GETANIMATION;
    public static int SPI_SETANIMATION;
    public static int SPI_GETFONTSMOOTHING;
    public static int SPI_SETFONTSMOOTHING;
    public static int SPI_SETDRAGWIDTH;
    public static int SPI_SETDRAGHEIGHT;
    public static int SPI_SETHANDHELD;
    public static int SPI_GETLOWPOWERTIMEOUT;
    public static int SPI_GETPOWEROFFTIMEOUT;
    public static int SPI_SETLOWPOWERTIMEOUT;
    public static int SPI_SETPOWEROFFTIMEOUT;
    public static int SPI_GETLOWPOWERACTIVE;
    public static int SPI_GETPOWEROFFACTIVE;
    public static int SPI_SETLOWPOWERACTIVE;
    public static int SPI_SETPOWEROFFACTIVE;
    public static int SPI_SETCURSORS;
    public static int SPI_SETICONS;
    public static int SPI_GETDEFAULTINPUTLANG;
    public static int SPI_SETDEFAULTINPUTLANG;
    public static int SPI_SETLANGTOGGLE;
    public static int SPI_GETWINDOWSEXTENSION;
    public static int SPI_SETMOUSETRAILS;
    public static int SPI_GETMOUSETRAILS;
    public static int SPI_SETSCREENSAVERRUNNING;
    public static int SPI_SCREENSAVERRUNNING;
    public static int SPI_GETFILTERKEYS;
    public static int SPI_SETFILTERKEYS;
    public static int SPI_GETTOGGLEKEYS;
    public static int SPI_SETTOGGLEKEYS;
    public static int SPI_GETMOUSEKEYS;
    public static int SPI_SETMOUSEKEYS;
    public static int SPI_GETSHOWSOUNDS;
    public static int SPI_SETSHOWSOUNDS;
    public static int SPI_GETSTICKYKEYS;
    public static int SPI_SETSTICKYKEYS;
    public static int SPI_GETACCESSTIMEOUT;
    public static int SPI_SETACCESSTIMEOUT;
    public static int SPI_GETSERIALKEYS;
    public static int SPI_SETSERIALKEYS;
    public static int SPI_GETSOUNDSENTRY;
    public static int SPI_SETSOUNDSENTRY;
    public static int SPI_GETSNAPTODEFBUTTON;
    public static int SPI_SETSNAPTODEFBUTTON;
    public static int SPI_GETMOUSEHOVERWIDTH;
    public static int SPI_SETMOUSEHOVERWIDTH;
    public static int SPI_GETMOUSEHOVERHEIGHT;
    public static int SPI_SETMOUSEHOVERHEIGHT;
    public static int SPI_GETMOUSEHOVERTIME;
    public static int SPI_SETMOUSEHOVERTIME;
    public static int SPI_GETWHEELSCROLLLINES;
    public static int SPI_SETWHEELSCROLLLINES;
    public static int SPI_GETMENUSHOWDELAY;
    public static int SPI_SETMENUSHOWDELAY;
    public static int SPI_GETSHOWIMEUI;
    public static int SPI_SETSHOWIMEUI;
    public static int SPI_GETMOUSESPEED;
    public static int SPI_SETMOUSESPEED;
    public static int SPI_GETSCREENSAVERRUNNING;
    public static int SPI_GETDESKWALLPAPER;
    public static int SPI_GETACTIVEWINDOWTRACKING;
    public static int SPI_SETACTIVEWINDOWTRACKING;
    public static int SPI_GETMENUANIMATION;
    public static int SPI_SETMENUANIMATION;
    public static int SPI_GETCOMBOBOXANIMATION;
    public static int SPI_SETCOMBOBOXANIMATION;
    public static int SPI_GETLISTBOXSMOOTHSCROLLING;
    public static int SPI_SETLISTBOXSMOOTHSCROLLING;
    public static int SPI_GETGRADIENTCAPTIONS;
    public static int SPI_SETGRADIENTCAPTIONS;
    public static int SPI_GETKEYBOARDCUES;
    public static int SPI_SETKEYBOARDCUES;
    public static int SPI_GETMENUUNDERLINES;
    public static int SPI_SETMENUUNDERLINES;
    public static int SPI_GETACTIVEWNDTRKZORDER;
    public static int SPI_SETACTIVEWNDTRKZORDER;
    public static int SPI_GETHOTTRACKING;
    public static int SPI_SETHOTTRACKING;
    public static int SPI_GETMENUFADE;
    public static int SPI_SETMENUFADE;
    public static int SPI_GETSELECTIONFADE;
    public static int SPI_SETSELECTIONFADE;
    public static int SPI_GETTOOLTIPANIMATION;
    public static int SPI_SETTOOLTIPANIMATION;
    public static int SPI_GETTOOLTIPFADE;
    public static int SPI_SETTOOLTIPFADE;
    public static int SPI_GETCURSORSHADOW;
    public static int SPI_SETCURSORSHADOW;
    public static int SPI_GETUIEFFECTS;
    public static int SPI_SETUIEFFECTS;
    public static int SPI_GETFOREGROUNDLOCKTIMEOUT;
    public static int SPI_SETFOREGROUNDLOCKTIMEOUT;
    public static int SPI_GETACTIVEWNDTRKTIMEOUT;
    public static int SPI_SETACTIVEWNDTRKTIMEOUT;
    public static int SPI_GETFOREGROUNDFLASHCOUNT;
    public static int SPI_SETFOREGROUNDFLASHCOUNT;
    public static int SPI_GETCARETWIDTH;
    public static int SPI_SETCARETWIDTH;
    public static UInt32 STATUS_INFO_LENGTH_MISMATCH;
    public static int PBT_APMQUERYSUSPEND;
    public static int PBT_APMQUERYSTANDBY;
    public static int PBT_APMQUERYSUSPENDFAILED;
    public static int PBT_APMQUERYSTANDBYFAILED;
    public static int PBT_APMSUSPEND;
    public static int PBT_APMSTANDBY;
    public static int PBT_APMRESUMECRITICAL;
    public static int PBT_APMRESUMESUSPEND;
    public static int PBT_APMRESUMESTANDBY;
    public static int PBT_APMBATTERYLOW;
    public static int PBT_APMPOWERSTATUSCHANGE;
    public static int PBT_APMOEMEVENT;
    public static int STARTF_USESHOWWINDOW;
    public static int FILE_MAP_WRITE;
    public static int FILE_MAP_READ;
    public static int PAGE_READWRITE;
    public static int GENERIC_EXECUTE;
    public static int GENERIC_ALL;
    public static int ERROR_NOT_READY;
    public static int ERROR_LOCK_FAILED;
    public static int ERROR_BUSY;
    public static int IMPERSONATION_LEVEL_SecurityAnonymous;
    public static int IMPERSONATION_LEVEL_SecurityIdentification;
    public static int IMPERSONATION_LEVEL_SecurityImpersonation;
    public static int IMPERSONATION_LEVEL_SecurityDelegation;
    public static int TOKEN_TYPE_TokenPrimary;
    public static int TOKEN_TYPE_TokenImpersonation;
    public static int TOKEN_ALL_ACCESS;
    public static int TOKEN_EXECUTE;
    public static int TOKEN_READ;
    public static int TOKEN_IMPERSONATE;
    public static int PIPE_ACCESS_INBOUND;
    public static int PIPE_ACCESS_OUTBOUND;
    public static int PIPE_ACCESS_DUPLEX;
    public static int PIPE_WAIT;
    public static int PIPE_NOWAIT;
    public static int PIPE_READMODE_BYTE;
    public static int PIPE_READMODE_MESSAGE;
    public static int PIPE_TYPE_BYTE;
    public static int PIPE_TYPE_MESSAGE;
    public static int PIPE_SINGLE_INSTANCES;
    public static int PIPE_UNLIMITED_INSTANCES;
    public static int FILE_FLAG_OVERLAPPED;
    public static int PM_REMOVE;
    public static int QS_KEY;
    public static int QS_MOUSEMOVE;
    public static int QS_MOUSEBUTTON;
    public static int QS_POSTMESSAGE;
    public static int QS_TIMER;
    public static int QS_PAINT;
    public static int QS_SENDMESSAGE;
    public static int QS_HOTKEY;
    public static int QS_ALLPOSTMESSAGE;
    public static int QS_MOUSE;
    public static int QS_INPUT;
    public static int QS_ALLEVENTS;
    public static int QS_ALLINPUT;
    public static int MWMO_INPUTAVAILABLE;
    internal static byte ONESTOPBIT;
    internal static byte ONE5STOPBITS;
    internal static byte TWOSTOPBITS;
    internal static int DTR_CONTROL_DISABLE;
    internal static int DTR_CONTROL_ENABLE;
    internal static int DTR_CONTROL_HANDSHAKE;
    internal static int RTS_CONTROL_DISABLE;
    internal static int RTS_CONTROL_ENABLE;
    internal static int RTS_CONTROL_HANDSHAKE;
    internal static int RTS_CONTROL_TOGGLE;
    internal static int MS_CTS_ON;
    internal static int MS_DSR_ON;
    internal static int MS_RING_ON;
    internal static int MS_RLSD_ON;
    internal static byte EOFCHAR;
    internal static int FBINARY;
    internal static int FPARITY;
    internal static int FOUTXCTSFLOW;
    internal static int FOUTXDSRFLOW;
    internal static int FDTRCONTROL;
    internal static int FDSRSENSITIVITY;
    internal static int FTXCONTINUEONXOFF;
    internal static int FOUTX;
    internal static int FINX;
    internal static int FERRORCHAR;
    internal static int FNULL;
    internal static int FRTSCONTROL;
    internal static int FABORTONOERROR;
    internal static int FDUMMY2;
    internal static int PURGE_TXABORT;
    internal static int PURGE_RXABORT;
    internal static int PURGE_TXCLEAR;
    internal static int PURGE_RXCLEAR;
    internal static byte DEFAULTXONCHAR;
    internal static byte DEFAULTXOFFCHAR;
    internal static int SETRTS;
    internal static int CLRRTS;
    internal static int SETDTR;
    internal static int CLRDTR;
    internal static int EV_RXCHAR;
    internal static int EV_RXFLAG;
    internal static int EV_CTS;
    internal static int EV_DSR;
    internal static int EV_RLSD;
    internal static int EV_BREAK;
    internal static int EV_ERR;
    internal static int EV_RING;
    internal static int ALL_EVENTS;
    internal static int CE_RXOVER;
    internal static int CE_OVERRUN;
    internal static int CE_PARITY;
    internal static int CE_FRAME;
    internal static int CE_BREAK;
    internal static int CE_TXFULL;
    internal static int MAXDWORD;
    internal static int NOPARITY;
    internal static int ODDPARITY;
    internal static int EVENPARITY;
    internal static int MARKPARITY;
    internal static int SPACEPARITY;
    internal static int SDDL_REVISION_1;
    public static int SECURITY_DESCRIPTOR_REVISION;
    public static int HKEY_PERFORMANCE_DATA;
    public static int DWORD_SIZE;
    public static int LARGE_INTEGER_SIZE;
    public static int PERF_NO_INSTANCES;
    public static int PERF_SIZE_DWORD;
    public static int PERF_SIZE_LARGE;
    public static int PERF_SIZE_ZERO;
    public static int PERF_SIZE_VARIABLE_LEN;
    public static int PERF_NO_UNIQUE_ID;
    public static int PERF_TYPE_NUMBER;
    public static int PERF_TYPE_COUNTER;
    public static int PERF_TYPE_TEXT;
    public static int PERF_TYPE_ZERO;
    public static int PERF_NUMBER_HEX;
    public static int PERF_NUMBER_DECIMAL;
    public static int PERF_NUMBER_DEC_1000;
    public static int PERF_COUNTER_VALUE;
    public static int PERF_COUNTER_RATE;
    public static int PERF_COUNTER_FRACTION;
    public static int PERF_COUNTER_BASE;
    public static int PERF_COUNTER_ELAPSED;
    public static int PERF_COUNTER_QUEUELEN;
    public static int PERF_COUNTER_HISTOGRAM;
    public static int PERF_COUNTER_PRECISION;
    public static int PERF_TEXT_UNICODE;
    public static int PERF_TEXT_ASCII;
    public static int PERF_TIMER_TICK;
    public static int PERF_TIMER_100NS;
    public static int PERF_OBJECT_TIMER;
    public static int PERF_DELTA_COUNTER;
    public static int PERF_DELTA_BASE;
    public static int PERF_INVERSE_COUNTER;
    public static int PERF_MULTI_COUNTER;
    public static int PERF_DISPLAY_NO_SUFFIX;
    public static int PERF_DISPLAY_PER_SEC;
    public static int PERF_DISPLAY_PERCENT;
    public static int PERF_DISPLAY_SECONDS;
    public static int PERF_DISPLAY_NOSHOW;
    public static int PERF_COUNTER_COUNTER;
    public static int PERF_COUNTER_TIMER;
    public static int PERF_COUNTER_QUEUELEN_TYPE;
    public static int PERF_COUNTER_LARGE_QUEUELEN_TYPE;
    public static int PERF_COUNTER_100NS_QUEUELEN_TYPE;
    public static int PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE;
    public static int PERF_COUNTER_BULK_COUNT;
    public static int PERF_COUNTER_TEXT;
    public static int PERF_COUNTER_RAWCOUNT;
    public static int PERF_COUNTER_LARGE_RAWCOUNT;
    public static int PERF_COUNTER_RAWCOUNT_HEX;
    public static int PERF_COUNTER_LARGE_RAWCOUNT_HEX;
    public static int PERF_SAMPLE_FRACTION;
    public static int PERF_SAMPLE_COUNTER;
    public static int PERF_COUNTER_NODATA;
    public static int PERF_COUNTER_TIMER_INV;
    public static int PERF_SAMPLE_BASE;
    public static int PERF_AVERAGE_TIMER;
    public static int PERF_AVERAGE_BASE;
    public static int PERF_OBJ_TIME_TIMER;
    public static int PERF_AVERAGE_BULK;
    public static int PERF_OBJ_TIME_TIME;
    public static int PERF_100NSEC_TIMER;
    public static int PERF_100NSEC_TIMER_INV;
    public static int PERF_COUNTER_MULTI_TIMER;
    public static int PERF_COUNTER_MULTI_TIMER_INV;
    public static int PERF_COUNTER_MULTI_BASE;
    public static int PERF_100NSEC_MULTI_TIMER;
    public static int PERF_100NSEC_MULTI_TIMER_INV;
    public static int PERF_RAW_FRACTION;
    public static int PERF_LARGE_RAW_FRACTION;
    public static int PERF_RAW_BASE;
    public static int PERF_LARGE_RAW_BASE;
    public static int PERF_ELAPSED_TIME;
    public static int PERF_COUNTER_DELTA;
    public static int PERF_COUNTER_LARGE_DELTA;
    public static int PERF_PRECISION_SYSTEM_TIMER;
    public static int PERF_PRECISION_100NS_TIMER;
    public static int PERF_PRECISION_OBJECT_TIMER;
    public static UInt32 PDH_FMT_DOUBLE;
    public static UInt32 PDH_FMT_NOSCALE;
    public static UInt32 PDH_FMT_NOCAP100;
    public static int PERF_DETAIL_NOVICE;
    public static int PERF_DETAIL_ADVANCED;
    public static int PERF_DETAIL_EXPERT;
    public static int PERF_DETAIL_WIZARD;
    public static int FORMAT_MESSAGE_ALLOCATE_BUFFER;
    public static int FORMAT_MESSAGE_IGNORE_INSERTS;
    public static int FORMAT_MESSAGE_FROM_STRING;
    public static int FORMAT_MESSAGE_FROM_HMODULE;
    public static int FORMAT_MESSAGE_FROM_SYSTEM;
    public static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    public static int FORMAT_MESSAGE_MAX_WIDTH_MASK;
    public static int LOAD_WITH_ALTERED_SEARCH_PATH;
    public static int LOAD_LIBRARY_AS_DATAFILE;
    public static int SEEK_READ;
    public static int FORWARDS_READ;
    public static int BACKWARDS_READ;
    public static int ERROR_EVENTLOG_FILE_CHANGED;
    public static int NtPerfCounterSizeDword;
    public static int NtPerfCounterSizeLarge;
    public static int SHGFI_USEFILEATTRIBUTES;
    public static int SHGFI_TYPENAME;
    public static int NtQueryProcessBasicInfo;
    public static int NtQuerySystemProcessInformation;
    public static int SEE_MASK_CLASSNAME;
    public static int SEE_MASK_CLASSKEY;
    public static int SEE_MASK_IDLIST;
    public static int SEE_MASK_INVOKEIDLIST;
    public static int SEE_MASK_ICON;
    public static int SEE_MASK_HOTKEY;
    public static int SEE_MASK_NOCLOSEPROCESS;
    public static int SEE_MASK_CONNECTNETDRV;
    public static int SEE_MASK_FLAG_DDEWAIT;
    public static int SEE_MASK_DOENVSUBST;
    public static int SEE_MASK_FLAG_NO_UI;
    public static int SEE_MASK_UNICODE;
    public static int SEE_MASK_NO_CONSOLE;
    public static int SEE_MASK_ASYNCOK;
    public static int TH32CS_SNAPHEAPLIST;
    public static int TH32CS_SNAPPROCESS;
    public static int TH32CS_SNAPTHREAD;
    public static int TH32CS_SNAPMODULE;
    public static int TH32CS_INHERIT;
    public static int PROCESS_TERMINATE;
    public static int PROCESS_CREATE_THREAD;
    public static int PROCESS_SET_SESSIONID;
    public static int PROCESS_VM_OPERATION;
    public static int PROCESS_VM_READ;
    public static int PROCESS_VM_WRITE;
    public static int PROCESS_DUP_HANDLE;
    public static int PROCESS_CREATE_PROCESS;
    public static int PROCESS_SET_QUOTA;
    public static int PROCESS_SET_INFORMATION;
    public static int PROCESS_QUERY_INFORMATION;
    public static int PROCESS_QUERY_LIMITED_INFORMATION;
    public static int STANDARD_RIGHTS_REQUIRED;
    public static int SYNCHRONIZE;
    public static int PROCESS_ALL_ACCESS;
    public static int THREAD_TERMINATE;
    public static int THREAD_SUSPEND_RESUME;
    public static int THREAD_GET_CONTEXT;
    public static int THREAD_SET_CONTEXT;
    public static int THREAD_SET_INFORMATION;
    public static int THREAD_QUERY_INFORMATION;
    public static int THREAD_SET_THREAD_TOKEN;
    public static int THREAD_IMPERSONATE;
    public static int THREAD_DIRECT_IMPERSONATION;
    public static IntPtr HKEY_LOCAL_MACHINE;
    public static int REG_BINARY;
    public static int REG_MULTI_SZ;
    public static int READ_CONTROL;
    public static int STANDARD_RIGHTS_READ;
    public static int KEY_QUERY_VALUE;
    public static int KEY_ENUMERATE_SUB_KEYS;
    public static int KEY_NOTIFY;
    public static int KEY_READ;
    public static int ERROR_BROKEN_PIPE;
    public static int ERROR_NO_DATA;
    public static int ERROR_HANDLE_EOF;
    public static int ERROR_IO_INCOMPLETE;
    public static int ERROR_IO_PENDING;
    public static int ERROR_FILE_EXISTS;
    public static int ERROR_FILENAME_EXCED_RANGE;
    public static int ERROR_MORE_DATA;
    public static int ERROR_CANCELLED;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_PATH_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_HANDLE;
    public static int ERROR_NOT_ENOUGH_MEMORY;
    public static int ERROR_BAD_COMMAND;
    public static int ERROR_SHARING_VIOLATION;
    public static int ERROR_OPERATION_ABORTED;
    public static int ERROR_NO_ASSOCIATION;
    public static int ERROR_DLL_NOT_FOUND;
    public static int ERROR_DDE_FAIL;
    public static int ERROR_INVALID_PARAMETER;
    public static int ERROR_PARTIAL_COPY;
    public static int ERROR_SUCCESS;
    public static int ERROR_ALREADY_EXISTS;
    public static int ERROR_COUNTER_TIMEOUT;
    public static int DUPLICATE_CLOSE_SOURCE;
    public static int DUPLICATE_SAME_ACCESS;
    public static int RPC_S_SERVER_UNAVAILABLE;
    public static int RPC_S_CALL_FAILED;
    public static int PDH_NO_DATA;
    public static int PDH_CALC_NEGATIVE_DENOMINATOR;
    public static int PDH_CALC_NEGATIVE_VALUE;
    public static int SE_ERR_FNF;
    public static int SE_ERR_PNF;
    public static int SE_ERR_ACCESSDENIED;
    public static int SE_ERR_OOM;
    public static int SE_ERR_DLLNOTFOUND;
    public static int SE_ERR_SHARE;
    public static int SE_ERR_ASSOCINCOMPLETE;
    public static int SE_ERR_DDETIMEOUT;
    public static int SE_ERR_DDEFAIL;
    public static int SE_ERR_DDEBUSY;
    public static int SE_ERR_NOASSOC;
    public static int SE_PRIVILEGE_ENABLED;
    public static int LOGON32_LOGON_BATCH;
    public static int LOGON32_PROVIDER_DEFAULT;
    public static int LOGON32_LOGON_INTERACTIVE;
    public static int TOKEN_ADJUST_PRIVILEGES;
    public static int TOKEN_QUERY;
    public static int CREATE_NO_WINDOW;
    public static int CREATE_SUSPENDED;
    public static int CREATE_UNICODE_ENVIRONMENT;
    public static int SMTO_ABORTIFHUNG;
    public static int GWL_STYLE;
    public static int GCL_WNDPROC;
    public static int GWL_WNDPROC;
    public static int WS_DISABLED;
    public static int WM_NULL;
    public static int WM_CLOSE;
    public static int SW_SHOWNORMAL;
    public static int SW_NORMAL;
    public static int SW_SHOWMINIMIZED;
    public static int SW_SHOWMAXIMIZED;
    public static int SW_MAXIMIZE;
    public static int SW_SHOWNOACTIVATE;
    public static int SW_SHOW;
    public static int SW_MINIMIZE;
    public static int SW_SHOWMINNOACTIVE;
    public static int SW_SHOWNA;
    public static int SW_RESTORE;
    public static int SW_SHOWDEFAULT;
    public static int SW_MAX;
    public static int GW_OWNER;
    public static int WHITENESS;
    public static int VS_FILE_INFO;
    public static int VS_VERSION_INFO;
    public static int VS_USER_DEFINED;
    public static int VS_FFI_SIGNATURE;
    public static int VS_FFI_STRUCVERSION;
    public static int VS_FFI_FILEFLAGSMASK;
    public static int VS_FF_DEBUG;
    public static int VS_FF_PRERELEASE;
    public static int VS_FF_PATCHED;
    public static int VS_FF_PRIVATEBUILD;
    public static int VS_FF_INFOINFERRED;
    public static int VS_FF_SPECIALBUILD;
    public static int VFT_UNKNOWN;
    public static int VFT_APP;
    public static int VFT_DLL;
    public static int VFT_DRV;
    public static int VFT_FONT;
    public static int VFT_VXD;
    public static int VFT_STATIC_LIB;
    public static int VFT2_UNKNOWN;
    public static int VFT2_DRV_PRINTER;
    public static int VFT2_DRV_KEYBOARD;
    public static int VFT2_DRV_LANGUAGE;
    public static int VFT2_DRV_DISPLAY;
    public static int VFT2_DRV_MOUSE;
    public static int VFT2_DRV_NETWORK;
    public static int VFT2_DRV_SYSTEM;
    public static int VFT2_DRV_INSTALLABLE;
    public static int VFT2_DRV_SOUND;
    public static int VFT2_DRV_COMM;
    public static int VFT2_DRV_INPUTMETHOD;
    public static int VFT2_FONT_RASTER;
    public static int VFT2_FONT_VECTOR;
    public static int VFT2_FONT_TRUETYPE;
    public static int GMEM_FIXED;
    public static int GMEM_MOVEABLE;
    public static int GMEM_NOCOMPACT;
    public static int GMEM_NODISCARD;
    public static int GMEM_ZEROINIT;
    public static int GMEM_MODIFY;
    public static int GMEM_DISCARDABLE;
    public static int GMEM_NOT_BANKED;
    public static int GMEM_SHARE;
    public static int GMEM_DDESHARE;
    public static int GMEM_NOTIFY;
    public static int GMEM_LOWER;
    public static int GMEM_VALID_FLAGS;
    public static int GMEM_INVALID_HANDLE;
    public static int GHND;
    public static int GPTR;
    public static int GMEM_DISCARDED;
    public static int GMEM_LOCKCOUNT;
    public static int UOI_NAME;
    public static int UOI_TYPE;
    public static int UOI_USER_SID;
    public static int VER_PLATFORM_WIN32_NT;
    private static NativeMethods();
    public static bool GetExitCodeProcess(SafeProcessHandle processHandle, Int32& exitCode);
    public static bool GetProcessTimes(SafeProcessHandle handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user);
    public static bool GetThreadTimes(SafeThreadHandle handle, Int64& creation, Int64& exit, Int64& kernel, Int64& user);
    public static IntPtr GetStdHandle(int whichHandle);
    public static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);
    public static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, SECURITY_ATTRIBUTES lpProcessAttributes, SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO lpStartupInfo, PROCESS_INFORMATION lpProcessInformation);
    public static bool TerminateProcess(SafeProcessHandle processHandle, int exitCode);
    public static int GetCurrentProcessId();
    public static IntPtr GetCurrentProcess();
    internal static UInt32 SetNamedSecurityInfo(string directory, SafeLocalMemHandle pDacl);
    internal static void CreateDirectory(string path, SafeLocalMemHandle acl);
    internal static string GetLocalPath(string fileName);
    [SuppressUnmanagedCodeSecurityAttribute]
public static bool CreateProcessAsUser(SafeHandle hToken, string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES lpProcessAttributes, SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, HandleRef lpEnvironment, string lpCurrentDirectory, STARTUPINFO lpStartupInfo, PROCESS_INFORMATION lpProcessInformation);
    internal static bool CreateProcessWithLogonW(string userName, string domain, IntPtr password, LogonFlags logonFlags, string appName, StringBuilder cmdLine, int creationFlags, IntPtr environmentBlock, string lpCurrentDirectory, STARTUPINFO lpStartupInfo, PROCESS_INFORMATION lpProcessInformation);
    internal static SafeFileMappingHandle CreateFileMapping(IntPtr hFile, SECURITY_ATTRIBUTES lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, string lpName);
    internal static SafeFileMappingHandle OpenFileMapping(int dwDesiredAccess, bool bInheritHandle, string lpName);
    public static int WaitForInputIdle(SafeProcessHandle handle, int milliseconds);
    public static SafeProcessHandle OpenProcess(int access, bool inherit, int processId);
    public static bool EnumProcessModules(SafeProcessHandle handle, IntPtr modules, int size, Int32& needed);
    public static bool EnumProcesses(Int32[] processIds, int size, Int32& needed);
    public static int GetModuleFileNameEx(HandleRef processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
    public static bool GetModuleInformation(SafeProcessHandle processHandle, HandleRef moduleHandle, NtModuleInfo ntModuleInfo, int size);
    public static int GetModuleBaseName(SafeProcessHandle processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
    public static int GetModuleFileNameEx(SafeProcessHandle processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
    public static bool SetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr min, IntPtr max);
    public static bool GetProcessWorkingSetSize(SafeProcessHandle handle, IntPtr& min, IntPtr& max);
    public static bool SetProcessAffinityMask(SafeProcessHandle handle, IntPtr mask);
    public static bool GetProcessAffinityMask(SafeProcessHandle handle, IntPtr& processMask, IntPtr& systemMask);
    public static bool GetThreadPriorityBoost(SafeThreadHandle handle, Boolean& disabled);
    public static bool SetThreadPriorityBoost(SafeThreadHandle handle, bool disabled);
    public static bool GetProcessPriorityBoost(SafeProcessHandle handle, Boolean& disabled);
    public static bool SetProcessPriorityBoost(SafeProcessHandle handle, bool disabled);
    public static SafeThreadHandle OpenThread(int access, bool inherit, int threadId);
    public static bool SetThreadPriority(SafeThreadHandle handle, int priority);
    public static int GetThreadPriority(SafeThreadHandle handle);
    public static IntPtr SetThreadAffinityMask(SafeThreadHandle handle, HandleRef mask);
    public static int SetThreadIdealProcessor(SafeThreadHandle handle, int processor);
    public static IntPtr CreateToolhelp32Snapshot(int flags, int processId);
    public static bool Process32First(HandleRef handle, IntPtr entry);
    public static bool Process32Next(HandleRef handle, IntPtr entry);
    public static bool Thread32First(HandleRef handle, WinThreadEntry entry);
    public static bool Thread32Next(HandleRef handle, WinThreadEntry entry);
    public static bool Module32First(HandleRef handle, IntPtr entry);
    public static bool Module32Next(HandleRef handle, IntPtr entry);
    public static int GetPriorityClass(SafeProcessHandle handle);
    public static bool SetPriorityClass(SafeProcessHandle handle, int priorityClass);
    public static bool EnumWindows(EnumThreadWindowsCallback callback, IntPtr extraData);
    public static int GetWindowThreadProcessId(HandleRef handle, Int32& processId);
    public static bool ShellExecuteEx(ShellExecuteInfo info);
    public static int NtQueryInformationProcess(SafeProcessHandle processHandle, int query, NtProcessBasicInfo info, int size, Int32[] returnedSize);
    public static int NtQuerySystemInformation(int query, IntPtr dataPtr, int size, Int32& returnedSize);
    public static SafeFileHandle CreateFile(string lpFileName, int dwDesiredAccess, int dwShareMode, SECURITY_ATTRIBUTES lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, SafeFileHandle hTemplateFile);
    public static bool DuplicateHandle(HandleRef hSourceProcessHandle, SafeHandle hSourceHandle, HandleRef hTargetProcess, SafeFileHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions);
    public static bool DuplicateHandle(HandleRef hSourceProcessHandle, SafeHandle hSourceHandle, HandleRef hTargetProcess, SafeWaitHandle& targetHandle, int dwDesiredAccess, bool bInheritHandle, int dwOptions);
    public static bool OpenProcessToken(HandleRef ProcessHandle, int DesiredAccess, IntPtr& TokenHandle);
    public static bool LookupPrivilegeValue(string lpSystemName, string lpName, LUID& lpLuid);
    public static bool AdjustTokenPrivileges(HandleRef TokenHandle, bool DisableAllPrivileges, TokenPrivileges NewState, int BufferLength, IntPtr PreviousState, IntPtr ReturnLength);
    public static int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
    public static int GetWindowTextLength(HandleRef hWnd);
    public static bool IsWindowVisible(HandleRef hWnd);
    public static IntPtr SendMessageTimeout(HandleRef hWnd, int msg, IntPtr wParam, IntPtr lParam, int flags, int timeout, IntPtr& pdwResult);
    public static int GetWindowLong(HandleRef hWnd, int nIndex);
    public static int PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);
    public static IntPtr GetWindow(HandleRef hWnd, int uCmd);
    internal static IntPtr VirtualQuery(SafeFileMapViewHandle address, MEMORY_BASIC_INFORMATION& buffer, IntPtr sizeOfBuffer);
}
public class Microsoft.Win32.PowerModeChangedEventArgs : EventArgs {
    public PowerModes Mode { get; }
    public PowerModeChangedEventArgs(PowerModes mode);
    public PowerModes get_Mode();
}
public class Microsoft.Win32.PowerModeChangedEventHandler : MulticastDelegate {
    public PowerModeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PowerModeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.PowerModes : Enum {
    public int value__;
    public static PowerModes Resume;
    public static PowerModes StatusChange;
    public static PowerModes Suspend;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeEventLogReadHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeEventLogReadHandle OpenEventLog(string UNCServerName, string sourceName);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeEventLogWriteHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeEventLogWriteHandle RegisterEventSource(string uncServerName, string sourceName);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFileMappingHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFileMapViewHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeFileMapViewHandle MapViewOfFile(SafeFileMappingHandle hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeLocalMemHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLocalMemHandle(IntPtr existingHandle, bool ownsHandle);
    internal static bool ConvertStringSecurityDescriptorToSecurityDescriptor(string StringSecurityDescriptor, int StringSDRevision, SafeLocalMemHandle& pSecurityDescriptor, IntPtr SecurityDescriptorSize);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
public class Microsoft.Win32.SafeHandles.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeProcessHandle InvalidHandle;
    internal SafeProcessHandle(IntPtr handle);
    public SafeProcessHandle(IntPtr existingHandle, bool ownsHandle);
    private static SafeProcessHandle();
    internal static SafeProcessHandle OpenProcess(int access, bool inherit, int processId);
    internal void InitialSetHandle(IntPtr h);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeThreadHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal void InitialSetHandle(IntPtr h);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeTimerHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Win32.SafeHandles.SafeUserTokenHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeUserTokenHandle(IntPtr existingHandle, bool ownsHandle);
    internal static bool DuplicateTokenEx(SafeHandle hToken, int access, SECURITY_ATTRIBUTES tokenAttributes, int impersonationLevel, int tokenType, SafeUserTokenHandle& hNewToken);
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeX509ChainHandle InvalidHandle { get; }
    internal SafeX509ChainHandle(IntPtr handle);
    internal static SafeX509ChainHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.SafeNativeMethods : object {
    public static int MB_RIGHT;
    public static int MB_RTLREADING;
    public static int FORMAT_MESSAGE_ALLOCATE_BUFFER;
    public static int FORMAT_MESSAGE_IGNORE_INSERTS;
    public static int FORMAT_MESSAGE_FROM_STRING;
    public static int FORMAT_MESSAGE_FROM_SYSTEM;
    public static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    public static int ERROR_INSUFFICIENT_BUFFER;
    public static int FORMAT_MESSAGE_MAX_WIDTH_MASK;
    public static int FORMAT_MESSAGE_FROM_HMODULE;
    public static bool GetTextMetrics(IntPtr hDC, TEXTMETRIC tm);
    public static IntPtr GetStockObject(int nIndex);
    public static void OutputDebugString(string message);
    [SecurityCriticalAttribute]
public static int MessageBox(IntPtr hWnd, string text, string caption, int type);
    public static int FormatMessage(int dwFlags, IntPtr lpSource_mustBeNull, UInt32 dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] arguments);
    public static int FormatMessage(int dwFlags, SafeLibraryHandle lpSource, UInt32 dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] arguments);
    [ReliabilityContractAttribute("3", "2")]
public static bool CloseHandle(IntPtr handle);
    public static bool QueryPerformanceCounter(Int64& value);
    public static bool QueryPerformanceFrequency(Int64& value);
    public static int RegisterWindowMessage(string msg);
    public static IntPtr LoadLibrary(string libFilename);
    public static bool FreeLibrary(HandleRef hModule);
    public static bool GetComputerName(StringBuilder lpBuffer, Int32[] nSize);
    public static int InterlockedCompareExchange(IntPtr pDestination, int exchange, int compare);
    public static int FormatFromRawValue(UInt32 dwCounterType, UInt32 dwFormat, Int64& pTimeBase, PDH_RAW_COUNTER pRawValue1, PDH_RAW_COUNTER pRawValue2, PDH_FMT_COUNTERVALUE pFmtValue);
    public static bool IsWow64Process(SafeProcessHandle hProcess, Boolean& Wow64Process);
    internal static SafeWaitHandle CreateSemaphore(SECURITY_ATTRIBUTES lpSecurityAttributes, int initialCount, int maximumCount, string name);
    internal static SafeWaitHandle OpenSemaphore(int desiredAccess, bool inheritHandle, string name);
    [ReliabilityContractAttribute("3", "2")]
internal static bool ReleaseSemaphore(SafeWaitHandle handle, int releaseCount, Int32& previousCount);
}
public class Microsoft.Win32.SessionEndedEventArgs : EventArgs {
    public SessionEndReasons Reason { get; }
    public SessionEndedEventArgs(SessionEndReasons reason);
    public SessionEndReasons get_Reason();
}
public class Microsoft.Win32.SessionEndedEventHandler : MulticastDelegate {
    public SessionEndedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Win32.SessionEndingEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public SessionEndReasons Reason { get; }
    public SessionEndingEventArgs(SessionEndReasons reason);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public SessionEndReasons get_Reason();
}
public class Microsoft.Win32.SessionEndingEventHandler : MulticastDelegate {
    public SessionEndingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.SessionEndReasons : Enum {
    public int value__;
    public static SessionEndReasons Logoff;
    public static SessionEndReasons SystemShutdown;
}
public class Microsoft.Win32.SessionSwitchEventArgs : EventArgs {
    public SessionSwitchReason Reason { get; }
    public SessionSwitchEventArgs(SessionSwitchReason reason);
    public SessionSwitchReason get_Reason();
}
public class Microsoft.Win32.SessionSwitchEventHandler : MulticastDelegate {
    public SessionSwitchEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionSwitchEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.Win32.SessionSwitchReason : Enum {
    public int value__;
    public static SessionSwitchReason ConsoleConnect;
    public static SessionSwitchReason ConsoleDisconnect;
    public static SessionSwitchReason RemoteConnect;
    public static SessionSwitchReason RemoteDisconnect;
    public static SessionSwitchReason SessionLogon;
    public static SessionSwitchReason SessionLogoff;
    public static SessionSwitchReason SessionLock;
    public static SessionSwitchReason SessionUnlock;
    public static SessionSwitchReason SessionRemoteControl;
}
public class Microsoft.Win32.SystemEvents : object {
    internal static bool UseEverettThreadAffinity { get; }
    private static SystemEvents();
    public static void add_DisplaySettingsChanging(EventHandler value);
    public static void remove_DisplaySettingsChanging(EventHandler value);
    public static void add_DisplaySettingsChanged(EventHandler value);
    public static void remove_DisplaySettingsChanged(EventHandler value);
    public static void add_EventsThreadShutdown(EventHandler value);
    public static void remove_EventsThreadShutdown(EventHandler value);
    public static void add_InstalledFontsChanged(EventHandler value);
    public static void remove_InstalledFontsChanged(EventHandler value);
    public static void add_LowMemory(EventHandler value);
    public static void remove_LowMemory(EventHandler value);
    public static void add_PaletteChanged(EventHandler value);
    public static void remove_PaletteChanged(EventHandler value);
    public static void add_PowerModeChanged(PowerModeChangedEventHandler value);
    public static void remove_PowerModeChanged(PowerModeChangedEventHandler value);
    public static void add_SessionEnded(SessionEndedEventHandler value);
    public static void remove_SessionEnded(SessionEndedEventHandler value);
    public static void add_SessionEnding(SessionEndingEventHandler value);
    public static void remove_SessionEnding(SessionEndingEventHandler value);
    public static void add_SessionSwitch(SessionSwitchEventHandler value);
    public static void remove_SessionSwitch(SessionSwitchEventHandler value);
    public static void add_TimeChanged(EventHandler value);
    public static void remove_TimeChanged(EventHandler value);
    public static void add_TimerElapsed(TimerElapsedEventHandler value);
    public static void remove_TimerElapsed(TimerElapsedEventHandler value);
    public static void add_UserPreferenceChanged(UserPreferenceChangedEventHandler value);
    public static void remove_UserPreferenceChanged(UserPreferenceChangedEventHandler value);
    public static void add_UserPreferenceChanging(UserPreferenceChangingEventHandler value);
    public static void remove_UserPreferenceChanging(UserPreferenceChangingEventHandler value);
    public static IntPtr CreateTimer(int interval);
    public static void InvokeOnEventsThread(Delegate method);
    public static void KillTimer(IntPtr timerId);
    internal static bool get_UseEverettThreadAffinity();
}
public class Microsoft.Win32.TimerElapsedEventArgs : EventArgs {
    public IntPtr TimerId { get; }
    public TimerElapsedEventArgs(IntPtr timerId);
    public IntPtr get_TimerId();
}
public class Microsoft.Win32.TimerElapsedEventHandler : MulticastDelegate {
    public TimerElapsedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TimerElapsedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    [SecuritySafeCriticalAttribute]
internal static Lazy`1<bool> IsPackagedProcess;
    public static int FILE_READ_DATA;
    public static int FILE_LIST_DIRECTORY;
    public static int FILE_WRITE_DATA;
    public static int FILE_ADD_FILE;
    public static int FILE_APPEND_DATA;
    public static int FILE_ADD_SUBDIRECTORY;
    public static int FILE_CREATE_PIPE_INSTANCE;
    public static int FILE_READ_EA;
    public static int FILE_WRITE_EA;
    public static int FILE_EXECUTE;
    public static int FILE_TRAVERSE;
    public static int FILE_DELETE_CHILD;
    public static int FILE_READ_ATTRIBUTES;
    public static int FILE_WRITE_ATTRIBUTES;
    public static int FILE_SHARE_READ;
    public static int FILE_SHARE_WRITE;
    public static int FILE_SHARE_DELETE;
    public static int FILE_ATTRIBUTE_READONLY;
    public static int FILE_ATTRIBUTE_HIDDEN;
    public static int FILE_ATTRIBUTE_SYSTEM;
    public static int FILE_ATTRIBUTE_DIRECTORY;
    public static int FILE_ATTRIBUTE_ARCHIVE;
    public static int FILE_ATTRIBUTE_NORMAL;
    public static int FILE_ATTRIBUTE_TEMPORARY;
    public static int FILE_ATTRIBUTE_COMPRESSED;
    public static int FILE_ATTRIBUTE_OFFLINE;
    public static int FILE_NOTIFY_CHANGE_FILE_NAME;
    public static int FILE_NOTIFY_CHANGE_DIR_NAME;
    public static int FILE_NOTIFY_CHANGE_ATTRIBUTES;
    public static int FILE_NOTIFY_CHANGE_SIZE;
    public static int FILE_NOTIFY_CHANGE_LAST_WRITE;
    public static int FILE_NOTIFY_CHANGE_LAST_ACCESS;
    public static int FILE_NOTIFY_CHANGE_CREATION;
    public static int FILE_NOTIFY_CHANGE_SECURITY;
    public static int FILE_ACTION_ADDED;
    public static int FILE_ACTION_REMOVED;
    public static int FILE_ACTION_MODIFIED;
    public static int FILE_ACTION_RENAMED_OLD_NAME;
    public static int FILE_ACTION_RENAMED_NEW_NAME;
    public static int FILE_CASE_SENSITIVE_SEARCH;
    public static int FILE_CASE_PRESERVED_NAMES;
    public static int FILE_UNICODE_ON_DISK;
    public static int FILE_PERSISTENT_ACLS;
    public static int FILE_FILE_COMPRESSION;
    public static int OPEN_EXISTING;
    public static int OPEN_ALWAYS;
    public static int FILE_FLAG_WRITE_THROUGH;
    public static int FILE_FLAG_OVERLAPPED;
    public static int FILE_FLAG_NO_BUFFERING;
    public static int FILE_FLAG_RANDOM_ACCESS;
    public static int FILE_FLAG_SEQUENTIAL_SCAN;
    public static int FILE_FLAG_DELETE_ON_CLOSE;
    public static int FILE_FLAG_BACKUP_SEMANTICS;
    public static int FILE_FLAG_POSIX_SEMANTICS;
    public static int FILE_TYPE_UNKNOWN;
    public static int FILE_TYPE_DISK;
    public static int FILE_TYPE_CHAR;
    public static int FILE_TYPE_PIPE;
    public static int FILE_TYPE_REMOTE;
    public static int FILE_VOLUME_IS_COMPRESSED;
    public static int GetFileExInfoStandard;
    internal static int TokenIsAppContainer;
    private static UnsafeNativeMethods();
    public static IntPtr GetStdHandle(int type);
    public static int ReleaseDC(IntPtr hWnd, IntPtr hDC);
    public static IntPtr GetDC(IntPtr hWnd);
    public static IntPtr SelectObject(IntPtr hDC, IntPtr hObject);
    public static int GetSystemMetrics(int nIndex);
    public static IntPtr GetProcessWindowStation();
    public static bool GetUserObjectInformation(HandleRef hObj, int nIndex, USEROBJECTFLAGS pvBuffer, int nLength, Int32& lpnLengthNeeded);
    public static IntPtr GetModuleHandle(string modName);
    public static IntPtr GetProcAddress(IntPtr hModule, string methodName);
    public static bool GetClassInfo(HandleRef hInst, string lpszClass, WNDCLASS_I wc);
    public static bool IsWindow(HandleRef hWnd);
    public static int WldpIsDynamicCodePolicyEnabled(Int32& enabled);
    public static int WldpSetDynamicCodeTrust(SafeFileHandle fileHandle);
    public static int WldpQueryDynamicCodeTrust(SafeFileHandle fileHandle, IntPtr image, UInt32 imageSize);
    public static IntPtr SetClassLong(HandleRef hWnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetClassLongPtr32(HandleRef hwnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetClassLongPtr64(HandleRef hwnd, int nIndex, IntPtr dwNewLong);
    public static IntPtr SetWindowLong(HandleRef hWnd, int nIndex, HandleRef dwNewLong);
    public static IntPtr SetWindowLongPtr32(HandleRef hWnd, int nIndex, HandleRef dwNewLong);
    public static IntPtr SetWindowLongPtr64(HandleRef hWnd, int nIndex, HandleRef dwNewLong);
    public static short RegisterClass(WNDCLASS wc);
    public static short UnregisterClass(string lpClassName, HandleRef hInstance);
    public static IntPtr CreateWindowEx(int exStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, object pvParam);
    public static IntPtr SendMessage(HandleRef hWnd, int msg, IntPtr wParam, IntPtr lParam);
    public static bool SetConsoleCtrlHandler(ConHndlr handler, int add);
    public static IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
    public static bool DestroyWindow(HandleRef hWnd);
    public static int MsgWaitForMultipleObjectsEx(int nCount, IntPtr pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags);
    public static int DispatchMessage(MSG& msg);
    public static bool PeekMessage(MSG& msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
    public static IntPtr SetTimer(HandleRef hWnd, HandleRef nIDEvent, int uElapse, HandleRef lpTimerProc);
    public static bool KillTimer(HandleRef hwnd, HandleRef idEvent);
    public static bool TranslateMessage(MSG& msg);
    public static IntPtr GetProcAddress(HandleRef hModule, string lpProcName);
    public static bool PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);
    public static bool WTSRegisterSessionNotification(HandleRef hWnd, int dwFlags);
    public static bool WTSUnRegisterSessionNotification(HandleRef hWnd);
    public static int LookupAccountSid(string systemName, Byte[] pSid, StringBuilder szUserName, Int32& userNameSize, StringBuilder szDomainName, Int32& domainNameSize, Int32& eUse);
    public static int GetFileVersionInfoSize(string lptstrFilename, Int32& handle);
    public static bool GetFileVersionInfo(string lptstrFilename, int dwHandle, int dwLen, HandleRef lpData);
    public static int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
    public static bool VerQueryValue(HandleRef pBlock, string lpSubBlock, IntPtr& lplpBuffer, Int32& len);
    public static int VerLanguageName(int langID, StringBuilder lpBuffer, int nSize);
    public static bool ReportEvent(SafeHandle hEventLog, short type, ushort category, UInt32 eventID, Byte[] userSID, short numStrings, int dataLen, HandleRef strings, Byte[] rawData);
    public static bool ClearEventLog(SafeHandle hEventLog, HandleRef lpctstrBackupFileName);
    public static bool GetNumberOfEventLogRecords(SafeHandle hEventLog, Int32& count);
    public static bool GetOldestEventLogRecord(SafeHandle hEventLog, Int32& number);
    public static bool ReadEventLog(SafeHandle hEventLog, int dwReadFlags, int dwRecordOffset, Byte[] buffer, int numberOfBytesToRead, Int32& bytesRead, Int32& minNumOfBytesNeeded);
    public static bool NotifyChangeEventLog(SafeHandle hEventLog, SafeWaitHandle hEvent);
    public static bool ReadDirectoryChangesW(SafeFileHandle hDirectory, HandleRef lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, Int32& lpBytesReturned, NativeOverlapped* overlappedPointer, HandleRef lpCompletionRoutine);
    internal static SafeFileHandle CreateFile(string lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr securityAttrs, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool GetCommState(SafeFileHandle hFile, DCB& lpDCB);
    internal static bool SetCommState(SafeFileHandle hFile, DCB& lpDCB);
    internal static bool GetCommModemStatus(SafeFileHandle hFile, Int32& lpModemStat);
    internal static bool SetupComm(SafeFileHandle hFile, int dwInQueue, int dwOutQueue);
    internal static bool SetCommTimeouts(SafeFileHandle hFile, COMMTIMEOUTS& lpCommTimeouts);
    internal static bool SetCommBreak(SafeFileHandle hFile);
    internal static bool ClearCommBreak(SafeFileHandle hFile);
    internal static bool ClearCommError(SafeFileHandle hFile, Int32& lpErrors, COMSTAT& lpStat);
    internal static bool ClearCommError(SafeFileHandle hFile, Int32& lpErrors, IntPtr lpStat);
    internal static bool PurgeComm(SafeFileHandle hFile, UInt32 dwFlags);
    internal static bool FlushFileBuffers(SafeFileHandle hFile);
    internal static bool GetCommProperties(SafeFileHandle hFile, COMMPROP& lpCommProp);
    internal static int ReadFile(SafeFileHandle handle, Byte* bytes, int numBytesToRead, IntPtr numBytesRead, NativeOverlapped* overlapped);
    internal static int ReadFile(SafeFileHandle handle, Byte* bytes, int numBytesToRead, Int32& numBytesRead, IntPtr overlapped);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, IntPtr numBytesWritten, NativeOverlapped* lpOverlapped);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, Int32& numBytesWritten, IntPtr lpOverlapped);
    internal static int GetFileType(SafeFileHandle hFile);
    internal static bool EscapeCommFunction(SafeFileHandle hFile, int dwFunc);
    internal static bool WaitCommEvent(SafeFileHandle hFile, Int32* lpEvtMask, NativeOverlapped* lpOverlapped);
    internal static bool SetCommMask(SafeFileHandle hFile, int dwEvtMask);
    internal static bool GetOverlappedResult(SafeFileHandle hFile, NativeOverlapped* lpOverlapped, Int32& lpNumberOfBytesTransferred, bool bWait);
    internal static bool GetTokenInformation(IntPtr TokenHandle, UInt32 TokenInformationClass, IntPtr TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    internal static int CoGetStandardMarshal(Guid& riid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr& ppMarshal);
}
public enum Microsoft.Win32.UserPreferenceCategory : Enum {
    public int value__;
    public static UserPreferenceCategory Accessibility;
    public static UserPreferenceCategory Color;
    public static UserPreferenceCategory Desktop;
    public static UserPreferenceCategory General;
    public static UserPreferenceCategory Icon;
    public static UserPreferenceCategory Keyboard;
    public static UserPreferenceCategory Menu;
    public static UserPreferenceCategory Mouse;
    public static UserPreferenceCategory Policy;
    public static UserPreferenceCategory Power;
    public static UserPreferenceCategory Screensaver;
    public static UserPreferenceCategory Window;
    public static UserPreferenceCategory Locale;
    public static UserPreferenceCategory VisualStyle;
}
public class Microsoft.Win32.UserPreferenceChangedEventArgs : EventArgs {
    public UserPreferenceCategory Category { get; }
    public UserPreferenceChangedEventArgs(UserPreferenceCategory category);
    public UserPreferenceCategory get_Category();
}
public class Microsoft.Win32.UserPreferenceChangedEventHandler : MulticastDelegate {
    public UserPreferenceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UserPreferenceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Win32.UserPreferenceChangingEventArgs : EventArgs {
    public UserPreferenceCategory Category { get; }
    public UserPreferenceChangingEventArgs(UserPreferenceCategory category);
    public UserPreferenceCategory get_Category();
}
public class Microsoft.Win32.UserPreferenceChangingEventHandler : MulticastDelegate {
    public UserPreferenceChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UserPreferenceChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Win32.WinInetCache : RequestCache {
    internal static string c_SPARSE_ENTRY_HACK;
    internal static TimeSpan s_MaxTimeSpanForInt32;
    internal WinInetCache(bool isPrivateCache, bool canWrite, bool async);
    private static WinInetCache();
    internal virtual Stream Retrieve(string key, RequestCacheEntry& cacheEntry);
    internal virtual bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream);
    internal virtual Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream);
    internal virtual void Remove(string key);
    internal virtual bool TryRemove(string key);
    internal bool TryRemove(string key, bool forceRemove);
    internal virtual void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual void UnlockEntry(Stream stream);
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
}
internal static class System.ClientUtils : object {
    public static bool IsCriticalException(Exception ex);
    public static bool IsSecurityOrCriticalException(Exception ex);
    public static int GetBitCount(UInt32 x);
    public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue);
    public static bool IsEnumValid(Enum enumValue, int value, int minValue, int maxValue, int maxNumberOfBitsOn);
    public static bool IsEnumValid_Masked(Enum enumValue, int value, UInt32 mask);
    public static bool IsEnumValid_NotSequential(Enum enumValue, int value, Int32[] enumValues);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeArgumentReferenceExpression : CodeExpression {
    public string ParameterName { get; public set; }
    public CodeArgumentReferenceExpression(string parameterName);
    public string get_ParameterName();
    public void set_ParameterName(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeArrayCreateExpression : CodeExpression {
    public CodeTypeReference CreateType { get; public set; }
    public CodeExpressionCollection Initializers { get; }
    public int Size { get; public set; }
    public CodeExpression SizeExpression { get; public set; }
    public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(string createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(Type createType, CodeExpression[] initializers);
    public CodeArrayCreateExpression(CodeTypeReference createType, int size);
    public CodeArrayCreateExpression(string createType, int size);
    public CodeArrayCreateExpression(Type createType, int size);
    public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression size);
    public CodeArrayCreateExpression(string createType, CodeExpression size);
    public CodeArrayCreateExpression(Type createType, CodeExpression size);
    public CodeTypeReference get_CreateType();
    public void set_CreateType(CodeTypeReference value);
    public CodeExpressionCollection get_Initializers();
    public int get_Size();
    public void set_Size(int value);
    public CodeExpression get_SizeExpression();
    public void set_SizeExpression(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeArrayIndexerExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Indices { get; }
    public CodeArrayIndexerExpression(CodeExpression targetObject, CodeExpression[] indices);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public CodeExpressionCollection get_Indices();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAssignStatement : CodeStatement {
    public CodeExpression Left { get; public set; }
    public CodeExpression Right { get; public set; }
    public CodeAssignStatement(CodeExpression left, CodeExpression right);
    public CodeExpression get_Left();
    public void set_Left(CodeExpression value);
    public CodeExpression get_Right();
    public void set_Right(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAttachEventStatement : CodeStatement {
    public CodeEventReferenceExpression Event { get; public set; }
    public CodeExpression Listener { get; public set; }
    public CodeAttachEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
    public CodeAttachEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
    public CodeEventReferenceExpression get_Event();
    public void set_Event(CodeEventReferenceExpression value);
    public CodeExpression get_Listener();
    public void set_Listener(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAttributeArgument : object {
    public string Name { get; public set; }
    public CodeExpression Value { get; public set; }
    public CodeAttributeArgument(CodeExpression value);
    public CodeAttributeArgument(string name, CodeExpression value);
    public string get_Name();
    public void set_Name(string value);
    public CodeExpression get_Value();
    public void set_Value(CodeExpression value);
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAttributeArgumentCollection : CollectionBase {
    public CodeAttributeArgument Item { get; public set; }
    public CodeAttributeArgumentCollection(CodeAttributeArgumentCollection value);
    public CodeAttributeArgumentCollection(CodeAttributeArgument[] value);
    public CodeAttributeArgument get_Item(int index);
    public void set_Item(int index, CodeAttributeArgument value);
    public int Add(CodeAttributeArgument value);
    public void AddRange(CodeAttributeArgument[] value);
    public void AddRange(CodeAttributeArgumentCollection value);
    public bool Contains(CodeAttributeArgument value);
    public void CopyTo(CodeAttributeArgument[] array, int index);
    public int IndexOf(CodeAttributeArgument value);
    public void Insert(int index, CodeAttributeArgument value);
    public void Remove(CodeAttributeArgument value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAttributeDeclaration : object {
    public string Name { get; public set; }
    public CodeAttributeArgumentCollection Arguments { get; }
    public CodeTypeReference AttributeType { get; }
    public CodeAttributeDeclaration(string name);
    public CodeAttributeDeclaration(string name, CodeAttributeArgument[] arguments);
    public CodeAttributeDeclaration(CodeTypeReference attributeType);
    public CodeAttributeDeclaration(CodeTypeReference attributeType, CodeAttributeArgument[] arguments);
    public string get_Name();
    public void set_Name(string value);
    public CodeAttributeArgumentCollection get_Arguments();
    public CodeTypeReference get_AttributeType();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeAttributeDeclarationCollection : CollectionBase {
    public CodeAttributeDeclaration Item { get; public set; }
    public CodeAttributeDeclarationCollection(CodeAttributeDeclarationCollection value);
    public CodeAttributeDeclarationCollection(CodeAttributeDeclaration[] value);
    public CodeAttributeDeclaration get_Item(int index);
    public void set_Item(int index, CodeAttributeDeclaration value);
    public int Add(CodeAttributeDeclaration value);
    public void AddRange(CodeAttributeDeclaration[] value);
    public void AddRange(CodeAttributeDeclarationCollection value);
    public bool Contains(CodeAttributeDeclaration value);
    public void CopyTo(CodeAttributeDeclaration[] array, int index);
    public int IndexOf(CodeAttributeDeclaration value);
    public void Insert(int index, CodeAttributeDeclaration value);
    public void Remove(CodeAttributeDeclaration value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeBaseReferenceExpression : CodeExpression {
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeBinaryOperatorExpression : CodeExpression {
    public CodeExpression Right { get; public set; }
    public CodeExpression Left { get; public set; }
    public CodeBinaryOperatorType Operator { get; public set; }
    public CodeBinaryOperatorExpression(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right);
    public CodeExpression get_Right();
    public void set_Right(CodeExpression value);
    public CodeExpression get_Left();
    public void set_Left(CodeExpression value);
    public CodeBinaryOperatorType get_Operator();
    public void set_Operator(CodeBinaryOperatorType value);
}
[ComVisibleAttribute("True")]
public enum System.CodeDom.CodeBinaryOperatorType : Enum {
    public int value__;
    public static CodeBinaryOperatorType Add;
    public static CodeBinaryOperatorType Subtract;
    public static CodeBinaryOperatorType Multiply;
    public static CodeBinaryOperatorType Divide;
    public static CodeBinaryOperatorType Modulus;
    public static CodeBinaryOperatorType Assign;
    public static CodeBinaryOperatorType IdentityInequality;
    public static CodeBinaryOperatorType IdentityEquality;
    public static CodeBinaryOperatorType ValueEquality;
    public static CodeBinaryOperatorType BitwiseOr;
    public static CodeBinaryOperatorType BitwiseAnd;
    public static CodeBinaryOperatorType BooleanOr;
    public static CodeBinaryOperatorType BooleanAnd;
    public static CodeBinaryOperatorType LessThan;
    public static CodeBinaryOperatorType LessThanOrEqual;
    public static CodeBinaryOperatorType GreaterThan;
    public static CodeBinaryOperatorType GreaterThanOrEqual;
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCastExpression : CodeExpression {
    public CodeTypeReference TargetType { get; public set; }
    public CodeExpression Expression { get; public set; }
    public CodeCastExpression(CodeTypeReference targetType, CodeExpression expression);
    public CodeCastExpression(string targetType, CodeExpression expression);
    public CodeCastExpression(Type targetType, CodeExpression expression);
    public CodeTypeReference get_TargetType();
    public void set_TargetType(CodeTypeReference value);
    public CodeExpression get_Expression();
    public void set_Expression(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCatchClause : object {
    public string LocalName { get; public set; }
    public CodeTypeReference CatchExceptionType { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeCatchClause(string localName);
    public CodeCatchClause(string localName, CodeTypeReference catchExceptionType);
    public CodeCatchClause(string localName, CodeTypeReference catchExceptionType, CodeStatement[] statements);
    public string get_LocalName();
    public void set_LocalName(string value);
    public CodeTypeReference get_CatchExceptionType();
    public void set_CatchExceptionType(CodeTypeReference value);
    public CodeStatementCollection get_Statements();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCatchClauseCollection : CollectionBase {
    public CodeCatchClause Item { get; public set; }
    public CodeCatchClauseCollection(CodeCatchClauseCollection value);
    public CodeCatchClauseCollection(CodeCatchClause[] value);
    public CodeCatchClause get_Item(int index);
    public void set_Item(int index, CodeCatchClause value);
    public int Add(CodeCatchClause value);
    public void AddRange(CodeCatchClause[] value);
    public void AddRange(CodeCatchClauseCollection value);
    public bool Contains(CodeCatchClause value);
    public void CopyTo(CodeCatchClause[] array, int index);
    public int IndexOf(CodeCatchClause value);
    public void Insert(int index, CodeCatchClause value);
    public void Remove(CodeCatchClause value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeChecksumPragma : CodeDirective {
    public string FileName { get; public set; }
    public Guid ChecksumAlgorithmId { get; public set; }
    public Byte[] ChecksumData { get; public set; }
    public CodeChecksumPragma(string fileName, Guid checksumAlgorithmId, Byte[] checksumData);
    public string get_FileName();
    public void set_FileName(string value);
    public Guid get_ChecksumAlgorithmId();
    public void set_ChecksumAlgorithmId(Guid value);
    public Byte[] get_ChecksumData();
    public void set_ChecksumData(Byte[] value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeComment : CodeObject {
    public bool DocComment { get; public set; }
    public string Text { get; public set; }
    public CodeComment(string text);
    public CodeComment(string text, bool docComment);
    public bool get_DocComment();
    public void set_DocComment(bool value);
    public string get_Text();
    public void set_Text(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCommentStatement : CodeStatement {
    public CodeComment Comment { get; public set; }
    public CodeCommentStatement(CodeComment comment);
    public CodeCommentStatement(string text);
    public CodeCommentStatement(string text, bool docComment);
    public CodeComment get_Comment();
    public void set_Comment(CodeComment value);
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCommentStatementCollection : CollectionBase {
    public CodeCommentStatement Item { get; public set; }
    public CodeCommentStatementCollection(CodeCommentStatementCollection value);
    public CodeCommentStatementCollection(CodeCommentStatement[] value);
    public CodeCommentStatement get_Item(int index);
    public void set_Item(int index, CodeCommentStatement value);
    public int Add(CodeCommentStatement value);
    public void AddRange(CodeCommentStatement[] value);
    public void AddRange(CodeCommentStatementCollection value);
    public bool Contains(CodeCommentStatement value);
    public void CopyTo(CodeCommentStatement[] array, int index);
    public int IndexOf(CodeCommentStatement value);
    public void Insert(int index, CodeCommentStatement value);
    public void Remove(CodeCommentStatement value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeCompileUnit : CodeObject {
    public CodeNamespaceCollection Namespaces { get; }
    public StringCollection ReferencedAssemblies { get; }
    public CodeAttributeDeclarationCollection AssemblyCustomAttributes { get; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    public CodeNamespaceCollection get_Namespaces();
    public StringCollection get_ReferencedAssemblies();
    public CodeAttributeDeclarationCollection get_AssemblyCustomAttributes();
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeConditionStatement : CodeStatement {
    public CodeExpression Condition { get; public set; }
    public CodeStatementCollection TrueStatements { get; }
    public CodeStatementCollection FalseStatements { get; }
    public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements);
    public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements);
    public CodeExpression get_Condition();
    public void set_Condition(CodeExpression value);
    public CodeStatementCollection get_TrueStatements();
    public CodeStatementCollection get_FalseStatements();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeConstructor : CodeMemberMethod {
    public CodeExpressionCollection BaseConstructorArgs { get; }
    public CodeExpressionCollection ChainedConstructorArgs { get; }
    public CodeExpressionCollection get_BaseConstructorArgs();
    public CodeExpressionCollection get_ChainedConstructorArgs();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDefaultValueExpression : CodeExpression {
    public CodeTypeReference Type { get; public set; }
    public CodeDefaultValueExpression(CodeTypeReference type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDelegateCreateExpression : CodeExpression {
    public CodeTypeReference DelegateType { get; public set; }
    public CodeExpression TargetObject { get; public set; }
    public string MethodName { get; public set; }
    public CodeDelegateCreateExpression(CodeTypeReference delegateType, CodeExpression targetObject, string methodName);
    public CodeTypeReference get_DelegateType();
    public void set_DelegateType(CodeTypeReference value);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public string get_MethodName();
    public void set_MethodName(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDelegateInvokeExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeDelegateInvokeExpression(CodeExpression targetObject);
    public CodeDelegateInvokeExpression(CodeExpression targetObject, CodeExpression[] parameters);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public CodeExpressionCollection get_Parameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDirectionExpression : CodeExpression {
    public CodeExpression Expression { get; public set; }
    public FieldDirection Direction { get; public set; }
    public CodeDirectionExpression(FieldDirection direction, CodeExpression expression);
    public CodeExpression get_Expression();
    public void set_Expression(CodeExpression value);
    public FieldDirection get_Direction();
    public void set_Direction(FieldDirection value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDirective : CodeObject {
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeDirectiveCollection : CollectionBase {
    public CodeDirective Item { get; public set; }
    public CodeDirectiveCollection(CodeDirectiveCollection value);
    public CodeDirectiveCollection(CodeDirective[] value);
    public CodeDirective get_Item(int index);
    public void set_Item(int index, CodeDirective value);
    public int Add(CodeDirective value);
    public void AddRange(CodeDirective[] value);
    public void AddRange(CodeDirectiveCollection value);
    public bool Contains(CodeDirective value);
    public void CopyTo(CodeDirective[] array, int index);
    public int IndexOf(CodeDirective value);
    public void Insert(int index, CodeDirective value);
    public void Remove(CodeDirective value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeEntryPointMethod : CodeMemberMethod {
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeEventReferenceExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public string EventName { get; public set; }
    public CodeEventReferenceExpression(CodeExpression targetObject, string eventName);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public string get_EventName();
    public void set_EventName(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeExpression : CodeObject {
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeExpressionCollection : CollectionBase {
    public CodeExpression Item { get; public set; }
    public CodeExpressionCollection(CodeExpressionCollection value);
    public CodeExpressionCollection(CodeExpression[] value);
    public CodeExpression get_Item(int index);
    public void set_Item(int index, CodeExpression value);
    public int Add(CodeExpression value);
    public void AddRange(CodeExpression[] value);
    public void AddRange(CodeExpressionCollection value);
    public bool Contains(CodeExpression value);
    public void CopyTo(CodeExpression[] array, int index);
    public int IndexOf(CodeExpression value);
    public void Insert(int index, CodeExpression value);
    public void Remove(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeExpressionStatement : CodeStatement {
    public CodeExpression Expression { get; public set; }
    public CodeExpressionStatement(CodeExpression expression);
    public CodeExpression get_Expression();
    public void set_Expression(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeFieldReferenceExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public string FieldName { get; public set; }
    public CodeFieldReferenceExpression(CodeExpression targetObject, string fieldName);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public string get_FieldName();
    public void set_FieldName(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeGotoStatement : CodeStatement {
    public string Label { get; public set; }
    public CodeGotoStatement(string label);
    public string get_Label();
    public void set_Label(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeIndexerExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public CodeExpressionCollection Indices { get; }
    public CodeIndexerExpression(CodeExpression targetObject, CodeExpression[] indices);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public CodeExpressionCollection get_Indices();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeIterationStatement : CodeStatement {
    public CodeStatement InitStatement { get; public set; }
    public CodeExpression TestExpression { get; public set; }
    public CodeStatement IncrementStatement { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeIterationStatement(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, CodeStatement[] statements);
    public CodeStatement get_InitStatement();
    public void set_InitStatement(CodeStatement value);
    public CodeExpression get_TestExpression();
    public void set_TestExpression(CodeExpression value);
    public CodeStatement get_IncrementStatement();
    public void set_IncrementStatement(CodeStatement value);
    public CodeStatementCollection get_Statements();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeLabeledStatement : CodeStatement {
    public string Label { get; public set; }
    public CodeStatement Statement { get; public set; }
    public CodeLabeledStatement(string label);
    public CodeLabeledStatement(string label, CodeStatement statement);
    public string get_Label();
    public void set_Label(string value);
    public CodeStatement get_Statement();
    public void set_Statement(CodeStatement value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeLinePragma : object {
    public string FileName { get; public set; }
    public int LineNumber { get; public set; }
    public CodeLinePragma(string fileName, int lineNumber);
    public string get_FileName();
    public void set_FileName(string value);
    public int get_LineNumber();
    public void set_LineNumber(int value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMemberEvent : CodeTypeMember {
    public CodeTypeReference Type { get; public set; }
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public CodeTypeReference get_PrivateImplementationType();
    public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMemberField : CodeTypeMember {
    public CodeTypeReference Type { get; public set; }
    public CodeExpression InitExpression { get; public set; }
    public CodeMemberField(CodeTypeReference type, string name);
    public CodeMemberField(string type, string name);
    public CodeMemberField(Type type, string name);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public CodeExpression get_InitExpression();
    public void set_InitExpression(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMemberMethod : CodeTypeMember {
    public CodeTypeReference ReturnType { get; public set; }
    public CodeStatementCollection Statements { get; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes { get; }
    [ComVisibleAttribute("False")]
public CodeTypeParameterCollection TypeParameters { get; }
    [CompilerGeneratedAttribute]
public void add_PopulateParameters(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateParameters(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateStatements(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateStatements(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateImplementationTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateImplementationTypes(EventHandler value);
    public CodeTypeReference get_ReturnType();
    public void set_ReturnType(CodeTypeReference value);
    public CodeStatementCollection get_Statements();
    public CodeParameterDeclarationExpressionCollection get_Parameters();
    public CodeTypeReference get_PrivateImplementationType();
    public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
    public CodeAttributeDeclarationCollection get_ReturnTypeCustomAttributes();
    public CodeTypeParameterCollection get_TypeParameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMemberProperty : CodeTypeMember {
    public CodeTypeReference PrivateImplementationType { get; public set; }
    public CodeTypeReferenceCollection ImplementationTypes { get; }
    public CodeTypeReference Type { get; public set; }
    public bool HasGet { get; public set; }
    public bool HasSet { get; public set; }
    public CodeStatementCollection GetStatements { get; }
    public CodeStatementCollection SetStatements { get; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    public CodeTypeReference get_PrivateImplementationType();
    public void set_PrivateImplementationType(CodeTypeReference value);
    public CodeTypeReferenceCollection get_ImplementationTypes();
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public bool get_HasGet();
    public void set_HasGet(bool value);
    public bool get_HasSet();
    public void set_HasSet(bool value);
    public CodeStatementCollection get_GetStatements();
    public CodeStatementCollection get_SetStatements();
    public CodeParameterDeclarationExpressionCollection get_Parameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMethodInvokeExpression : CodeExpression {
    public CodeMethodReferenceExpression Method { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeMethodInvokeExpression(CodeMethodReferenceExpression method, CodeExpression[] parameters);
    public CodeMethodInvokeExpression(CodeExpression targetObject, string methodName, CodeExpression[] parameters);
    public CodeMethodReferenceExpression get_Method();
    public void set_Method(CodeMethodReferenceExpression value);
    public CodeExpressionCollection get_Parameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMethodReferenceExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public string MethodName { get; public set; }
    [ComVisibleAttribute("False")]
public CodeTypeReferenceCollection TypeArguments { get; }
    public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName);
    public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName, CodeTypeReference[] typeParameters);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public string get_MethodName();
    public void set_MethodName(string value);
    public CodeTypeReferenceCollection get_TypeArguments();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeMethodReturnStatement : CodeStatement {
    public CodeExpression Expression { get; public set; }
    public CodeMethodReturnStatement(CodeExpression expression);
    public CodeExpression get_Expression();
    public void set_Expression(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeNamespace : CodeObject {
    public CodeTypeDeclarationCollection Types { get; }
    public CodeNamespaceImportCollection Imports { get; }
    public string Name { get; public set; }
    public CodeCommentStatementCollection Comments { get; }
    public CodeNamespace(string name);
    [CompilerGeneratedAttribute]
public void add_PopulateComments(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateComments(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateImports(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateImports(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateTypes(EventHandler value);
    public CodeTypeDeclarationCollection get_Types();
    public CodeNamespaceImportCollection get_Imports();
    public string get_Name();
    public void set_Name(string value);
    public CodeCommentStatementCollection get_Comments();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeNamespaceCollection : CollectionBase {
    public CodeNamespace Item { get; public set; }
    public CodeNamespaceCollection(CodeNamespaceCollection value);
    public CodeNamespaceCollection(CodeNamespace[] value);
    public CodeNamespace get_Item(int index);
    public void set_Item(int index, CodeNamespace value);
    public int Add(CodeNamespace value);
    public void AddRange(CodeNamespace[] value);
    public void AddRange(CodeNamespaceCollection value);
    public bool Contains(CodeNamespace value);
    public void CopyTo(CodeNamespace[] array, int index);
    public int IndexOf(CodeNamespace value);
    public void Insert(int index, CodeNamespace value);
    public void Remove(CodeNamespace value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeNamespaceImport : CodeObject {
    public CodeLinePragma LinePragma { get; public set; }
    public string Namespace { get; public set; }
    public CodeNamespaceImport(string nameSpace);
    public CodeLinePragma get_LinePragma();
    public void set_LinePragma(CodeLinePragma value);
    public string get_Namespace();
    public void set_Namespace(string value);
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeNamespaceImportCollection : object {
    public CodeNamespaceImport Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CodeNamespaceImport get_Item(int index);
    public void set_Item(int index, CodeNamespaceImport value);
    public int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public void Add(CodeNamespaceImport value);
    public void AddRange(CodeNamespaceImport[] value);
    public void Clear();
    public IEnumerator GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeObject : object {
    public IDictionary UserData { get; }
    public IDictionary get_UserData();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeObjectCreateExpression : CodeExpression {
    public CodeTypeReference CreateType { get; public set; }
    public CodeExpressionCollection Parameters { get; }
    public CodeObjectCreateExpression(CodeTypeReference createType, CodeExpression[] parameters);
    public CodeObjectCreateExpression(string createType, CodeExpression[] parameters);
    public CodeObjectCreateExpression(Type createType, CodeExpression[] parameters);
    public CodeTypeReference get_CreateType();
    public void set_CreateType(CodeTypeReference value);
    public CodeExpressionCollection get_Parameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeParameterDeclarationExpression : CodeExpression {
    public CodeAttributeDeclarationCollection CustomAttributes { get; public set; }
    public FieldDirection Direction { get; public set; }
    public CodeTypeReference Type { get; public set; }
    public string Name { get; public set; }
    public CodeParameterDeclarationExpression(CodeTypeReference type, string name);
    public CodeParameterDeclarationExpression(string type, string name);
    public CodeParameterDeclarationExpression(Type type, string name);
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    public void set_CustomAttributes(CodeAttributeDeclarationCollection value);
    public FieldDirection get_Direction();
    public void set_Direction(FieldDirection value);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
    public string get_Name();
    public void set_Name(string value);
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeParameterDeclarationExpressionCollection : CollectionBase {
    public CodeParameterDeclarationExpression Item { get; public set; }
    public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpressionCollection value);
    public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpression[] value);
    public CodeParameterDeclarationExpression get_Item(int index);
    public void set_Item(int index, CodeParameterDeclarationExpression value);
    public int Add(CodeParameterDeclarationExpression value);
    public void AddRange(CodeParameterDeclarationExpression[] value);
    public void AddRange(CodeParameterDeclarationExpressionCollection value);
    public bool Contains(CodeParameterDeclarationExpression value);
    public void CopyTo(CodeParameterDeclarationExpression[] array, int index);
    public int IndexOf(CodeParameterDeclarationExpression value);
    public void Insert(int index, CodeParameterDeclarationExpression value);
    public void Remove(CodeParameterDeclarationExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodePrimitiveExpression : CodeExpression {
    public object Value { get; public set; }
    public CodePrimitiveExpression(object value);
    public object get_Value();
    public void set_Value(object value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodePropertyReferenceExpression : CodeExpression {
    public CodeExpression TargetObject { get; public set; }
    public string PropertyName { get; public set; }
    public CodePropertyReferenceExpression(CodeExpression targetObject, string propertyName);
    public CodeExpression get_TargetObject();
    public void set_TargetObject(CodeExpression value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodePropertySetValueReferenceExpression : CodeExpression {
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeRegionDirective : CodeDirective {
    public string RegionText { get; public set; }
    public CodeRegionMode RegionMode { get; public set; }
    public CodeRegionDirective(CodeRegionMode regionMode, string regionText);
    public string get_RegionText();
    public void set_RegionText(string value);
    public CodeRegionMode get_RegionMode();
    public void set_RegionMode(CodeRegionMode value);
}
[ComVisibleAttribute("True")]
public enum System.CodeDom.CodeRegionMode : Enum {
    public int value__;
    public static CodeRegionMode None;
    public static CodeRegionMode Start;
    public static CodeRegionMode End;
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeRemoveEventStatement : CodeStatement {
    public CodeEventReferenceExpression Event { get; public set; }
    public CodeExpression Listener { get; public set; }
    public CodeRemoveEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
    public CodeRemoveEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
    public CodeEventReferenceExpression get_Event();
    public void set_Event(CodeEventReferenceExpression value);
    public CodeExpression get_Listener();
    public void set_Listener(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeSnippetCompileUnit : CodeCompileUnit {
    public string Value { get; public set; }
    public CodeLinePragma LinePragma { get; public set; }
    public CodeSnippetCompileUnit(string value);
    public string get_Value();
    public void set_Value(string value);
    public CodeLinePragma get_LinePragma();
    public void set_LinePragma(CodeLinePragma value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeSnippetExpression : CodeExpression {
    public string Value { get; public set; }
    public CodeSnippetExpression(string value);
    public string get_Value();
    public void set_Value(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeSnippetStatement : CodeStatement {
    public string Value { get; public set; }
    public CodeSnippetStatement(string value);
    public string get_Value();
    public void set_Value(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeSnippetTypeMember : CodeTypeMember {
    public string Text { get; public set; }
    public CodeSnippetTypeMember(string text);
    public string get_Text();
    public void set_Text(string value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeStatement : CodeObject {
    public CodeLinePragma LinePragma { get; public set; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    public CodeLinePragma get_LinePragma();
    public void set_LinePragma(CodeLinePragma value);
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeStatementCollection : CollectionBase {
    public CodeStatement Item { get; public set; }
    public CodeStatementCollection(CodeStatementCollection value);
    public CodeStatementCollection(CodeStatement[] value);
    public CodeStatement get_Item(int index);
    public void set_Item(int index, CodeStatement value);
    public int Add(CodeStatement value);
    public int Add(CodeExpression value);
    public void AddRange(CodeStatement[] value);
    public void AddRange(CodeStatementCollection value);
    public bool Contains(CodeStatement value);
    public void CopyTo(CodeStatement[] array, int index);
    public int IndexOf(CodeStatement value);
    public void Insert(int index, CodeStatement value);
    public void Remove(CodeStatement value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeThisReferenceExpression : CodeExpression {
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeThrowExceptionStatement : CodeStatement {
    public CodeExpression ToThrow { get; public set; }
    public CodeThrowExceptionStatement(CodeExpression toThrow);
    public CodeExpression get_ToThrow();
    public void set_ToThrow(CodeExpression value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTryCatchFinallyStatement : CodeStatement {
    public CodeStatementCollection TryStatements { get; }
    public CodeCatchClauseCollection CatchClauses { get; }
    public CodeStatementCollection FinallyStatements { get; }
    public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses);
    public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements);
    public CodeStatementCollection get_TryStatements();
    public CodeCatchClauseCollection get_CatchClauses();
    public CodeStatementCollection get_FinallyStatements();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeConstructor : CodeMemberMethod {
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeDeclaration : CodeTypeMember {
    public TypeAttributes TypeAttributes { get; public set; }
    public CodeTypeReferenceCollection BaseTypes { get; }
    public bool IsClass { get; public set; }
    public bool IsStruct { get; public set; }
    public bool IsEnum { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsPartial { get; public set; }
    public CodeTypeMemberCollection Members { get; }
    [ComVisibleAttribute("False")]
public CodeTypeParameterCollection TypeParameters { get; }
    public CodeTypeDeclaration(string name);
    [CompilerGeneratedAttribute]
public void add_PopulateBaseTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateBaseTypes(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PopulateMembers(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PopulateMembers(EventHandler value);
    public TypeAttributes get_TypeAttributes();
    public void set_TypeAttributes(TypeAttributes value);
    public CodeTypeReferenceCollection get_BaseTypes();
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsStruct();
    public void set_IsStruct(bool value);
    public bool get_IsEnum();
    public void set_IsEnum(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsPartial();
    public void set_IsPartial(bool value);
    public CodeTypeMemberCollection get_Members();
    public CodeTypeParameterCollection get_TypeParameters();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeDeclarationCollection : CollectionBase {
    public CodeTypeDeclaration Item { get; public set; }
    public CodeTypeDeclarationCollection(CodeTypeDeclarationCollection value);
    public CodeTypeDeclarationCollection(CodeTypeDeclaration[] value);
    public CodeTypeDeclaration get_Item(int index);
    public void set_Item(int index, CodeTypeDeclaration value);
    public int Add(CodeTypeDeclaration value);
    public void AddRange(CodeTypeDeclaration[] value);
    public void AddRange(CodeTypeDeclarationCollection value);
    public bool Contains(CodeTypeDeclaration value);
    public void CopyTo(CodeTypeDeclaration[] array, int index);
    public int IndexOf(CodeTypeDeclaration value);
    public void Insert(int index, CodeTypeDeclaration value);
    public void Remove(CodeTypeDeclaration value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeDelegate : CodeTypeDeclaration {
    public CodeTypeReference ReturnType { get; public set; }
    public CodeParameterDeclarationExpressionCollection Parameters { get; }
    public CodeTypeDelegate(string name);
    public CodeTypeReference get_ReturnType();
    public void set_ReturnType(CodeTypeReference value);
    public CodeParameterDeclarationExpressionCollection get_Parameters();
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeMember : CodeObject {
    public string Name { get; public set; }
    public MemberAttributes Attributes { get; public set; }
    public CodeAttributeDeclarationCollection CustomAttributes { get; public set; }
    public CodeLinePragma LinePragma { get; public set; }
    public CodeCommentStatementCollection Comments { get; }
    public CodeDirectiveCollection StartDirectives { get; }
    public CodeDirectiveCollection EndDirectives { get; }
    public string get_Name();
    public void set_Name(string value);
    public MemberAttributes get_Attributes();
    public void set_Attributes(MemberAttributes value);
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    public void set_CustomAttributes(CodeAttributeDeclarationCollection value);
    public CodeLinePragma get_LinePragma();
    public void set_LinePragma(CodeLinePragma value);
    public CodeCommentStatementCollection get_Comments();
    public CodeDirectiveCollection get_StartDirectives();
    public CodeDirectiveCollection get_EndDirectives();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeMemberCollection : CollectionBase {
    public CodeTypeMember Item { get; public set; }
    public CodeTypeMemberCollection(CodeTypeMemberCollection value);
    public CodeTypeMemberCollection(CodeTypeMember[] value);
    public CodeTypeMember get_Item(int index);
    public void set_Item(int index, CodeTypeMember value);
    public int Add(CodeTypeMember value);
    public void AddRange(CodeTypeMember[] value);
    public void AddRange(CodeTypeMemberCollection value);
    public bool Contains(CodeTypeMember value);
    public void CopyTo(CodeTypeMember[] array, int index);
    public int IndexOf(CodeTypeMember value);
    public void Insert(int index, CodeTypeMember value);
    public void Remove(CodeTypeMember value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeOfExpression : CodeExpression {
    public CodeTypeReference Type { get; public set; }
    public CodeTypeOfExpression(CodeTypeReference type);
    public CodeTypeOfExpression(string type);
    public CodeTypeOfExpression(Type type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeParameter : CodeObject {
    public string Name { get; public set; }
    public CodeTypeReferenceCollection Constraints { get; }
    public CodeAttributeDeclarationCollection CustomAttributes { get; }
    public bool HasConstructorConstraint { get; public set; }
    public CodeTypeParameter(string name);
    public string get_Name();
    public void set_Name(string value);
    public CodeTypeReferenceCollection get_Constraints();
    public CodeAttributeDeclarationCollection get_CustomAttributes();
    public bool get_HasConstructorConstraint();
    public void set_HasConstructorConstraint(bool value);
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeParameterCollection : CollectionBase {
    public CodeTypeParameter Item { get; public set; }
    public CodeTypeParameterCollection(CodeTypeParameterCollection value);
    public CodeTypeParameterCollection(CodeTypeParameter[] value);
    public CodeTypeParameter get_Item(int index);
    public void set_Item(int index, CodeTypeParameter value);
    public int Add(CodeTypeParameter value);
    public void Add(string value);
    public void AddRange(CodeTypeParameter[] value);
    public void AddRange(CodeTypeParameterCollection value);
    public bool Contains(CodeTypeParameter value);
    public void CopyTo(CodeTypeParameter[] array, int index);
    public int IndexOf(CodeTypeParameter value);
    public void Insert(int index, CodeTypeParameter value);
    public void Remove(CodeTypeParameter value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeReference : CodeObject {
    public CodeTypeReference ArrayElementType { get; public set; }
    public int ArrayRank { get; public set; }
    internal int NestedArrayDepth { get; }
    public string BaseType { get; public set; }
    [ComVisibleAttribute("False")]
public CodeTypeReferenceOptions Options { get; public set; }
    [ComVisibleAttribute("False")]
public CodeTypeReferenceCollection TypeArguments { get; }
    internal bool IsInterface { get; }
    public CodeTypeReference(Type type);
    public CodeTypeReference(Type type, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption);
    public CodeTypeReference(string typeName);
    public CodeTypeReference(string typeName, CodeTypeReference[] typeArguments);
    public CodeTypeReference(CodeTypeParameter typeParameter);
    public CodeTypeReference(string baseType, int rank);
    public CodeTypeReference(CodeTypeReference arrayType, int rank);
    public CodeTypeReference get_ArrayElementType();
    public void set_ArrayElementType(CodeTypeReference value);
    public int get_ArrayRank();
    public void set_ArrayRank(int value);
    internal int get_NestedArrayDepth();
    public string get_BaseType();
    public void set_BaseType(string value);
    public CodeTypeReferenceOptions get_Options();
    public void set_Options(CodeTypeReferenceOptions value);
    public CodeTypeReferenceCollection get_TypeArguments();
    internal bool get_IsInterface();
}
[DefaultMemberAttribute("Item")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeReferenceCollection : CollectionBase {
    public CodeTypeReference Item { get; public set; }
    public CodeTypeReferenceCollection(CodeTypeReferenceCollection value);
    public CodeTypeReferenceCollection(CodeTypeReference[] value);
    public CodeTypeReference get_Item(int index);
    public void set_Item(int index, CodeTypeReference value);
    public int Add(CodeTypeReference value);
    public void Add(string value);
    public void Add(Type value);
    public void AddRange(CodeTypeReference[] value);
    public void AddRange(CodeTypeReferenceCollection value);
    public bool Contains(CodeTypeReference value);
    public void CopyTo(CodeTypeReference[] array, int index);
    public int IndexOf(CodeTypeReference value);
    public void Insert(int index, CodeTypeReference value);
    public void Remove(CodeTypeReference value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeTypeReferenceExpression : CodeExpression {
    public CodeTypeReference Type { get; public set; }
    public CodeTypeReferenceExpression(CodeTypeReference type);
    public CodeTypeReferenceExpression(string type);
    public CodeTypeReferenceExpression(Type type);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.CodeDom.CodeTypeReferenceOptions : Enum {
    public int value__;
    public static CodeTypeReferenceOptions GlobalReference;
    public static CodeTypeReferenceOptions GenericTypeParameter;
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeVariableDeclarationStatement : CodeStatement {
    public CodeExpression InitExpression { get; public set; }
    public string Name { get; public set; }
    public CodeTypeReference Type { get; public set; }
    public CodeVariableDeclarationStatement(CodeTypeReference type, string name);
    public CodeVariableDeclarationStatement(string type, string name);
    public CodeVariableDeclarationStatement(Type type, string name);
    public CodeVariableDeclarationStatement(CodeTypeReference type, string name, CodeExpression initExpression);
    public CodeVariableDeclarationStatement(string type, string name, CodeExpression initExpression);
    public CodeVariableDeclarationStatement(Type type, string name, CodeExpression initExpression);
    public CodeExpression get_InitExpression();
    public void set_InitExpression(CodeExpression value);
    public string get_Name();
    public void set_Name(string value);
    public CodeTypeReference get_Type();
    public void set_Type(CodeTypeReference value);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public class System.CodeDom.CodeVariableReferenceExpression : CodeExpression {
    public string VariableName { get; public set; }
    public CodeVariableReferenceExpression(string variableName);
    public string get_VariableName();
    public void set_VariableName(string value);
}
public abstract class System.CodeDom.Compiler.CodeCompiler : CodeGenerator {
    protected string FileExtension { get; }
    protected string CompilerName { get; }
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    private sealed virtual override CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    protected abstract virtual string get_FileExtension();
    protected abstract virtual string get_CompilerName();
    internal void Compile(CompilerParameters options, string compilerDirectory, string compilerExe, string arguments, String& outputFile, Int32& nativeReturnValue, string trueArgs);
    protected virtual CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e);
    protected virtual CompilerResults FromFile(CompilerParameters options, string fileName);
    protected virtual CompilerResults FromSource(CompilerParameters options, string source);
    protected virtual CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
    protected virtual CompilerResults FromFileBatch(CompilerParameters options, String[] fileNames);
    protected abstract virtual void ProcessCompilerOutputLine(CompilerResults results, string line);
    protected abstract virtual string CmdArgsFromParameters(CompilerParameters options);
    protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs);
    protected virtual CompilerResults FromSourceBatch(CompilerParameters options, String[] sources);
    protected static string JoinStringArray(String[] sa, string separator);
    internal static Assembly LoadImageSkipIntegrityCheck(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
}
internal class System.CodeDom.Compiler.CodeDomCompilationConfiguration : object {
    internal static string sectionName;
    internal Hashtable _compilerLanguages;
    internal Hashtable _compilerExtensions;
    internal ArrayList _allCompilerInfo;
    internal static CodeDomCompilationConfiguration Default { get; }
    private static CodeDomCompilationConfiguration();
    internal static CodeDomCompilationConfiguration get_Default();
}
internal class System.CodeDom.Compiler.CodeDomConfigurationHandler : object {
    public virtual object Create(object inheritedObject, object configContextObj, XmlNode node);
}
[ToolboxItemAttribute("False")]
[ComVisibleAttribute("True")]
public abstract class System.CodeDom.Compiler.CodeDomProvider : Component {
    public string FileExtension { get; }
    public LanguageOptions LanguageOptions { get; }
    [ComVisibleAttribute("False")]
public static CodeDomProvider CreateProvider(string language, IDictionary`2<string, string> providerOptions);
    [ComVisibleAttribute("False")]
public static CodeDomProvider CreateProvider(string language);
    [ComVisibleAttribute("False")]
public static string GetLanguageFromExtension(string extension);
    [ComVisibleAttribute("False")]
public static bool IsDefinedLanguage(string language);
    [ComVisibleAttribute("False")]
public static bool IsDefinedExtension(string extension);
    [ComVisibleAttribute("False")]
public static CompilerInfo GetCompilerInfo(string language);
    [ComVisibleAttribute("False")]
public static CompilerInfo[] GetAllCompilerInfo();
    public virtual string get_FileExtension();
    public virtual LanguageOptions get_LanguageOptions();
    [ObsoleteAttribute("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public abstract virtual ICodeGenerator CreateGenerator();
    public virtual ICodeGenerator CreateGenerator(TextWriter output);
    public virtual ICodeGenerator CreateGenerator(string fileName);
    [ObsoleteAttribute("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public abstract virtual ICodeCompiler CreateCompiler();
    [ObsoleteAttribute("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")]
public virtual ICodeParser CreateParser();
    public virtual TypeConverter GetConverter(Type type);
    public virtual CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit[] compilationUnits);
    public virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, String[] fileNames);
    public virtual CompilerResults CompileAssemblyFromSource(CompilerParameters options, String[] sources);
    public virtual bool IsValidIdentifier(string value);
    public virtual string CreateEscapedIdentifier(string value);
    public virtual string CreateValidIdentifier(string value);
    public virtual string GetTypeOutput(CodeTypeReference type);
    public virtual bool Supports(GeneratorSupport generatorSupport);
    public virtual void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    public virtual CodeCompileUnit Parse(TextReader codeStream);
    internal static bool TryGetProbableCoreAssemblyFilePath(CompilerParameters parameters, String& coreAssemblyFilePath);
}
public abstract class System.CodeDom.Compiler.CodeGenerator : object {
    protected CodeTypeDeclaration CurrentClass { get; }
    protected string CurrentTypeName { get; }
    protected CodeTypeMember CurrentMember { get; }
    protected string CurrentMemberName { get; }
    protected bool IsCurrentInterface { get; }
    protected bool IsCurrentClass { get; }
    protected bool IsCurrentStruct { get; }
    protected bool IsCurrentEnum { get; }
    protected bool IsCurrentDelegate { get; }
    protected int Indent { get; protected set; }
    protected string NullToken { get; }
    protected TextWriter Output { get; }
    protected CodeGeneratorOptions Options { get; }
    protected CodeTypeDeclaration get_CurrentClass();
    protected string get_CurrentTypeName();
    protected CodeTypeMember get_CurrentMember();
    protected string get_CurrentMemberName();
    protected bool get_IsCurrentInterface();
    protected bool get_IsCurrentClass();
    protected bool get_IsCurrentStruct();
    protected bool get_IsCurrentEnum();
    protected bool get_IsCurrentDelegate();
    protected int get_Indent();
    protected void set_Indent(int value);
    protected abstract virtual string get_NullToken();
    protected TextWriter get_Output();
    protected CodeGeneratorOptions get_Options();
    protected virtual void GenerateDirectives(CodeDirectiveCollection directives);
    protected void GenerateNamespaces(CodeCompileUnit e);
    protected void GenerateTypes(CodeNamespace e);
    private sealed virtual override bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport support);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
    public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
    private sealed virtual override bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value);
    private sealed virtual override void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value);
    private sealed virtual override string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type);
    protected void GenerateExpression(CodeExpression e);
    protected virtual void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e);
    protected virtual void GenerateCompileUnit(CodeCompileUnit e);
    protected virtual void GenerateNamespace(CodeNamespace e);
    protected void GenerateNamespaceImports(CodeNamespace e);
    protected void GenerateStatement(CodeStatement e);
    protected void GenerateStatements(CodeStatementCollection stms);
    protected virtual void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes);
    protected virtual void OutputAttributeArgument(CodeAttributeArgument arg);
    protected virtual void OutputDirection(FieldDirection dir);
    protected virtual void OutputFieldScopeModifier(MemberAttributes attributes);
    protected virtual void OutputMemberAccessModifier(MemberAttributes attributes);
    protected virtual void OutputMemberScopeModifier(MemberAttributes attributes);
    protected abstract virtual void OutputType(CodeTypeReference typeRef);
    protected virtual void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum);
    protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name);
    protected virtual void OutputIdentifier(string ident);
    protected virtual void OutputExpressionList(CodeExpressionCollection expressions);
    protected virtual void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems);
    protected virtual void OutputOperator(CodeBinaryOperatorType op);
    protected virtual void OutputParameters(CodeParameterDeclarationExpressionCollection parameters);
    protected abstract virtual void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
    protected abstract virtual void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
    protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
    protected virtual void ContinueOnNewLine(string st);
    protected abstract virtual void GenerateCastExpression(CodeCastExpression e);
    protected abstract virtual void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
    protected abstract virtual void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
    protected abstract virtual void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
    protected abstract virtual void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
    protected abstract virtual void GenerateIndexerExpression(CodeIndexerExpression e);
    protected abstract virtual void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
    protected abstract virtual void GenerateSnippetExpression(CodeSnippetExpression e);
    protected abstract virtual void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
    protected abstract virtual void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
    protected abstract virtual void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
    protected abstract virtual void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
    protected abstract virtual void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
    protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
    protected virtual void GenerateDirectionExpression(CodeDirectionExpression e);
    protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e);
    protected virtual void GenerateSingleFloatValue(float s);
    protected virtual void GenerateDoubleValue(double d);
    protected virtual void GenerateDecimalValue(decimal d);
    protected virtual void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
    protected abstract virtual void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
    protected abstract virtual void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
    protected abstract virtual void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
    protected virtual void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e);
    protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e);
    protected abstract virtual void GenerateExpressionStatement(CodeExpressionStatement e);
    protected abstract virtual void GenerateIterationStatement(CodeIterationStatement e);
    protected abstract virtual void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
    protected virtual void GenerateCommentStatement(CodeCommentStatement e);
    protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e);
    protected abstract virtual void GenerateComment(CodeComment e);
    protected abstract virtual void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
    protected abstract virtual void GenerateConditionStatement(CodeConditionStatement e);
    protected abstract virtual void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
    protected abstract virtual void GenerateAssignStatement(CodeAssignStatement e);
    protected abstract virtual void GenerateAttachEventStatement(CodeAttachEventStatement e);
    protected abstract virtual void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
    protected abstract virtual void GenerateGotoStatement(CodeGotoStatement e);
    protected abstract virtual void GenerateLabeledStatement(CodeLabeledStatement e);
    protected virtual void GenerateSnippetStatement(CodeSnippetStatement e);
    protected abstract virtual void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
    protected abstract virtual void GenerateLinePragmaStart(CodeLinePragma e);
    protected abstract virtual void GenerateLinePragmaEnd(CodeLinePragma e);
    protected abstract virtual void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateField(CodeMemberField e);
    protected abstract virtual void GenerateSnippetMember(CodeSnippetTypeMember e);
    protected abstract virtual void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
    protected abstract virtual void GenerateTypeConstructor(CodeTypeConstructor e);
    protected abstract virtual void GenerateTypeStart(CodeTypeDeclaration e);
    protected abstract virtual void GenerateTypeEnd(CodeTypeDeclaration e);
    protected virtual void GenerateCompileUnitStart(CodeCompileUnit e);
    protected virtual void GenerateCompileUnitEnd(CodeCompileUnit e);
    protected abstract virtual void GenerateNamespaceStart(CodeNamespace e);
    protected abstract virtual void GenerateNamespaceEnd(CodeNamespace e);
    protected abstract virtual void GenerateNamespaceImport(CodeNamespaceImport e);
    protected abstract virtual void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
    protected abstract virtual void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
    protected abstract virtual bool Supports(GeneratorSupport support);
    protected abstract virtual bool IsValidIdentifier(string value);
    protected virtual void ValidateIdentifier(string value);
    protected abstract virtual string CreateEscapedIdentifier(string value);
    protected abstract virtual string CreateValidIdentifier(string value);
    protected abstract virtual string GetTypeOutput(CodeTypeReference value);
    protected abstract virtual string QuoteSnippetString(string value);
    public static bool IsValidLanguageIndependentIdentifier(string value);
    internal static bool IsValidLanguageIndependentTypeName(string value);
    public static void ValidateIdentifiers(CodeObject e);
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.Compiler.CodeGeneratorOptions : object {
    public object Item { get; public set; }
    public string IndentString { get; public set; }
    public string BracingStyle { get; public set; }
    public bool ElseOnClosing { get; public set; }
    public bool BlankLinesBetweenMembers { get; public set; }
    [ComVisibleAttribute("False")]
public bool VerbatimOrder { get; public set; }
    public object get_Item(string index);
    public void set_Item(string index, object value);
    public string get_IndentString();
    public void set_IndentString(string value);
    public string get_BracingStyle();
    public void set_BracingStyle(string value);
    public bool get_ElseOnClosing();
    public void set_ElseOnClosing(bool value);
    public bool get_BlankLinesBetweenMembers();
    public void set_BlankLinesBetweenMembers(bool value);
    public bool get_VerbatimOrder();
    public void set_VerbatimOrder(bool value);
}
public abstract class System.CodeDom.Compiler.CodeParser : object {
    public abstract virtual CodeCompileUnit Parse(TextReader codeStream);
}
internal class System.CodeDom.Compiler.CodeValidator : object {
    private static CodeValidator();
    internal void ValidateIdentifiers(CodeObject e);
}
public class System.CodeDom.Compiler.CompilerError : object {
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string ErrorNumber { get; public set; }
    public string ErrorText { get; public set; }
    public bool IsWarning { get; public set; }
    public string FileName { get; public set; }
    public CompilerError(string fileName, int line, int column, string errorNumber, string errorText);
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public string get_ErrorNumber();
    public void set_ErrorNumber(string value);
    public string get_ErrorText();
    public void set_ErrorText(string value);
    public bool get_IsWarning();
    public void set_IsWarning(bool value);
    public string get_FileName();
    public void set_FileName(string value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.CodeDom.Compiler.CompilerErrorCollection : CollectionBase {
    public CompilerError Item { get; public set; }
    public bool HasErrors { get; }
    public bool HasWarnings { get; }
    public CompilerErrorCollection(CompilerErrorCollection value);
    public CompilerErrorCollection(CompilerError[] value);
    public CompilerError get_Item(int index);
    public void set_Item(int index, CompilerError value);
    public int Add(CompilerError value);
    public void AddRange(CompilerError[] value);
    public void AddRange(CompilerErrorCollection value);
    public bool Contains(CompilerError value);
    public void CopyTo(CompilerError[] array, int index);
    public bool get_HasErrors();
    public bool get_HasWarnings();
    public int IndexOf(CompilerError value);
    public void Insert(int index, CompilerError value);
    public void Remove(CompilerError value);
}
public class System.CodeDom.Compiler.CompilerInfo : object {
    internal string _codeDomProviderTypeName;
    internal CompilerParameters _compilerParams;
    internal String[] _compilerLanguages;
    internal String[] _compilerExtensions;
    internal string configFileName;
    internal IDictionary`2<string, string> _providerOptions;
    internal int configFileLineNumber;
    internal bool _mapped;
    public Type CodeDomProviderType { get; }
    public bool IsCodeDomProviderTypeValid { get; }
    internal CompilerParameters CompilerParams { get; }
    internal IDictionary`2<string, string> ProviderOptions { get; }
    internal CompilerInfo(CompilerParameters compilerParams, string codeDomProviderTypeName, String[] compilerLanguages, String[] compilerExtensions);
    internal CompilerInfo(CompilerParameters compilerParams, string codeDomProviderTypeName);
    public String[] GetLanguages();
    public String[] GetExtensions();
    public Type get_CodeDomProviderType();
    public bool get_IsCodeDomProviderTypeValid();
    public CodeDomProvider CreateProvider();
    public CodeDomProvider CreateProvider(IDictionary`2<string, string> providerOptions);
    public CompilerParameters CreateDefaultCompilerParameters();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal CompilerParameters get_CompilerParams();
    internal IDictionary`2<string, string> get_ProviderOptions();
}
public class System.CodeDom.Compiler.CompilerParameters : object {
    public string CoreAssemblyFileName { get; public set; }
    public bool GenerateExecutable { get; public set; }
    public bool GenerateInMemory { get; public set; }
    public StringCollection ReferencedAssemblies { get; }
    public string MainClass { get; public set; }
    public string OutputAssembly { get; public set; }
    public TempFileCollection TempFiles { get; public set; }
    public bool IncludeDebugInformation { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    public int WarningLevel { get; public set; }
    public string CompilerOptions { get; public set; }
    public string Win32Resource { get; public set; }
    [ComVisibleAttribute("False")]
public StringCollection EmbeddedResources { get; }
    [ComVisibleAttribute("False")]
public StringCollection LinkedResources { get; }
    public IntPtr UserToken { get; public set; }
    internal SafeUserTokenHandle SafeUserToken { get; }
    [ObsoleteAttribute("CAS policy is obsolete and will be removed in a future release of the .NET Framework. Please see http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")]
public Evidence Evidence { get; public set; }
    public CompilerParameters(String[] assemblyNames);
    public CompilerParameters(String[] assemblyNames, string outputName);
    public CompilerParameters(String[] assemblyNames, string outputName, bool includeDebugInformation);
    public string get_CoreAssemblyFileName();
    public void set_CoreAssemblyFileName(string value);
    public bool get_GenerateExecutable();
    public void set_GenerateExecutable(bool value);
    public bool get_GenerateInMemory();
    public void set_GenerateInMemory(bool value);
    public StringCollection get_ReferencedAssemblies();
    public string get_MainClass();
    public void set_MainClass(string value);
    public string get_OutputAssembly();
    public void set_OutputAssembly(string value);
    public TempFileCollection get_TempFiles();
    public void set_TempFiles(TempFileCollection value);
    public bool get_IncludeDebugInformation();
    public void set_IncludeDebugInformation(bool value);
    public bool get_TreatWarningsAsErrors();
    public void set_TreatWarningsAsErrors(bool value);
    public int get_WarningLevel();
    public void set_WarningLevel(int value);
    public string get_CompilerOptions();
    public void set_CompilerOptions(string value);
    public string get_Win32Resource();
    public void set_Win32Resource(string value);
    public StringCollection get_EmbeddedResources();
    public StringCollection get_LinkedResources();
    public IntPtr get_UserToken();
    public void set_UserToken(IntPtr value);
    internal SafeUserTokenHandle get_SafeUserToken();
    public Evidence get_Evidence();
    public void set_Evidence(Evidence value);
}
public class System.CodeDom.Compiler.CompilerResults : object {
    public TempFileCollection TempFiles { get; public set; }
    [ObsoleteAttribute("CAS policy is obsolete and will be removed in a future release of the .NET Framework. Please see http://go2.microsoft.com/fwlink/?LinkId=131738 for more information.")]
public Evidence Evidence { get; public set; }
    public Assembly CompiledAssembly { get; public set; }
    public CompilerErrorCollection Errors { get; }
    public StringCollection Output { get; }
    public string PathToAssembly { get; public set; }
    public int NativeCompilerReturnValue { get; public set; }
    public CompilerResults(TempFileCollection tempFiles);
    public TempFileCollection get_TempFiles();
    public void set_TempFiles(TempFileCollection value);
    public Evidence get_Evidence();
    public void set_Evidence(Evidence value);
    public Assembly get_CompiledAssembly();
    public void set_CompiledAssembly(Assembly value);
    public CompilerErrorCollection get_Errors();
    public StringCollection get_Output();
    public string get_PathToAssembly();
    public void set_PathToAssembly(string value);
    public int get_NativeCompilerReturnValue();
    public void set_NativeCompilerReturnValue(int value);
}
public static class System.CodeDom.Compiler.Executor : object {
    internal static string GetRuntimeInstallDirectory();
    public static void ExecWait(string cmd, TempFileCollection tempFiles);
    public static int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, String& outputName, String& errorName);
    public static int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName);
    internal static int ExecWaitWithCapture(SafeUserTokenHandle userToken, string cmd, string currentDir, TempFileCollection tempFiles, String& outputName, String& errorName, string trueCmdLine);
    internal static WindowsImpersonationContext RevertImpersonation();
    internal static void ReImpersonate(WindowsImpersonationContext impersonation);
}
internal static class System.CodeDom.Compiler.FileIntegrity : object {
    public static bool IsEnabled { get; }
    private static FileIntegrity();
    public static bool get_IsEnabled();
    public static void MarkAsTrusted(SafeFileHandle safeFileHandle);
    public static bool IsTrusted(SafeFileHandle safeFileHandle);
}
[AttributeUsageAttribute("32767")]
public class System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
    public string Tool { get; }
    public string Version { get; }
    public GeneratedCodeAttribute(string tool, string version);
    public string get_Tool();
    public string get_Version();
}
[FlagsAttribute]
public enum System.CodeDom.Compiler.GeneratorSupport : Enum {
    public int value__;
    public static GeneratorSupport ArraysOfArrays;
    public static GeneratorSupport EntryPointMethod;
    public static GeneratorSupport GotoStatements;
    public static GeneratorSupport MultidimensionalArrays;
    public static GeneratorSupport StaticConstructors;
    public static GeneratorSupport TryCatchStatements;
    public static GeneratorSupport ReturnTypeAttributes;
    public static GeneratorSupport DeclareValueTypes;
    public static GeneratorSupport DeclareEnums;
    public static GeneratorSupport DeclareDelegates;
    public static GeneratorSupport DeclareInterfaces;
    public static GeneratorSupport DeclareEvents;
    public static GeneratorSupport AssemblyAttributes;
    public static GeneratorSupport ParameterAttributes;
    public static GeneratorSupport ReferenceParameters;
    public static GeneratorSupport ChainedConstructorArguments;
    public static GeneratorSupport NestedTypes;
    public static GeneratorSupport MultipleInterfaceMembers;
    public static GeneratorSupport PublicStaticMembers;
    public static GeneratorSupport ComplexExpressions;
    public static GeneratorSupport Win32Resources;
    public static GeneratorSupport Resources;
    public static GeneratorSupport PartialTypes;
    public static GeneratorSupport GenericTypeReference;
    public static GeneratorSupport GenericTypeDeclaration;
    public static GeneratorSupport DeclareIndexerProperties;
}
internal static class System.CodeDom.Compiler.HandlerBase : object {
    internal static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, String& val);
    internal static XmlNode GetAndRemoveRequiredNonEmptyStringAttribute(XmlNode node, string attrib, String& val);
    internal static XmlNode GetAndRemoveNonNegativeIntegerAttribute(XmlNode node, string attrib, Int32& val);
    internal static void CheckForUnrecognizedAttributes(XmlNode node);
    internal static void CheckForNonElement(XmlNode node);
    internal static bool IsIgnorableAlsoCheckForNonElement(XmlNode node);
    internal static void CheckForChildNodes(XmlNode node);
    internal static void ThrowUnrecognizedElement(XmlNode node);
}
public interface System.CodeDom.Compiler.ICodeCompiler {
    public abstract virtual CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit);
    public abstract virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName);
    public abstract virtual CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source);
    public abstract virtual CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits);
    public abstract virtual CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, String[] fileNames);
    public abstract virtual CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, String[] sources);
}
public interface System.CodeDom.Compiler.ICodeGenerator {
    public abstract virtual bool IsValidIdentifier(string value);
    public abstract virtual void ValidateIdentifier(string value);
    public abstract virtual string CreateEscapedIdentifier(string value);
    public abstract virtual string CreateValidIdentifier(string value);
    public abstract virtual string GetTypeOutput(CodeTypeReference type);
    public abstract virtual bool Supports(GeneratorSupport supports);
    public abstract virtual void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
    public abstract virtual void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
}
public interface System.CodeDom.Compiler.ICodeParser {
    public abstract virtual CodeCompileUnit Parse(TextReader codeStream);
}
internal class System.CodeDom.Compiler.Indentation : object {
    internal string IndentationString { get; }
    internal Indentation(IndentedTextWriter writer, int indent);
    internal string get_IndentationString();
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    internal string TabString { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    internal string get_TabString();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    internal void InternalOutputTabs();
}
[FlagsAttribute]
public enum System.CodeDom.Compiler.LanguageOptions : Enum {
    public int value__;
    public static LanguageOptions None;
    public static LanguageOptions CaseInsensitive;
}
internal static class System.CodeDom.Compiler.RedistVersionInfo : object {
    internal static string DirectoryPath;
    internal static string NameTag;
    internal static string DefaultVersion;
    internal static string InPlaceVersion;
    internal static string RedistVersion;
    internal static string RedistVersion20;
    public static string GetCompilerPath(IDictionary`2<string, string> provOptions, string compilerExecutable);
}
public class System.CodeDom.Compiler.TempFileCollection : object {
    public int Count { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public string TempDir { get; }
    public string BasePath { get; }
    public bool KeepFiles { get; public set; }
    public TempFileCollection(string tempDir);
    public TempFileCollection(string tempDir, bool keepFiles);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public string AddExtension(string fileExtension);
    public string AddExtension(string fileExtension, bool keepFile);
    public void AddFile(string fileName, bool keepFile);
    public IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int start);
    public void CopyTo(String[] fileNames, int start);
    public int get_Count();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public string get_TempDir();
    public string get_BasePath();
    public bool get_KeepFiles();
    public void set_KeepFiles(bool value);
    public void Delete();
    internal void SafeDelete();
}
[ComVisibleAttribute("True")]
public enum System.CodeDom.FieldDirection : Enum {
    public int value__;
    public static FieldDirection In;
    public static FieldDirection Out;
    public static FieldDirection Ref;
}
[ComVisibleAttribute("True")]
public enum System.CodeDom.MemberAttributes : Enum {
    public int value__;
    public static MemberAttributes Abstract;
    public static MemberAttributes Final;
    public static MemberAttributes Static;
    public static MemberAttributes Override;
    public static MemberAttributes Const;
    public static MemberAttributes New;
    public static MemberAttributes Overloaded;
    public static MemberAttributes Assembly;
    public static MemberAttributes FamilyAndAssembly;
    public static MemberAttributes Family;
    public static MemberAttributes FamilyOrAssembly;
    public static MemberAttributes Private;
    public static MemberAttributes Public;
    public static MemberAttributes AccessMask;
    public static MemberAttributes ScopeMask;
    public static MemberAttributes VTableMask;
}
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}, Type = {m_collection}")]
public class System.Collections.Concurrent.BlockingCollection`1 : object {
    public int BoundedCapacity { get; }
    public bool IsAddingCompleted { get; }
    public bool IsCompleted { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public BlockingCollection`1(int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection, int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection);
    public int get_BoundedCapacity();
    public bool get_IsAddingCompleted();
    public bool get_IsCompleted();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Add(T item);
    public void Add(T item, CancellationToken cancellationToken);
    public bool TryAdd(T item);
    public bool TryAdd(T item, TimeSpan timeout);
    public bool TryAdd(T item, int millisecondsTimeout);
    public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public T Take();
    public T Take(CancellationToken cancellationToken);
    public bool TryTake(T& item);
    public bool TryTake(T& item, TimeSpan timeout);
    public bool TryTake(T& item, int millisecondsTimeout);
    public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int AddToAny(BlockingCollection`1[] collections, T item);
    public static int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    public void CompleteAdding();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public IEnumerable`1<T> GetConsumingEnumerable();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.BlockingCollection`1/<GetConsumingEnumerable>d__68")]
public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemThreadingCollection_IProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentBag`1 : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentBag`1(IEnumerable`1<T> collection);
    public void Add(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public sealed virtual bool TryTake(T& result);
    public bool TryPeek(T& result);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
internal class System.Collections.Concurrent.SystemThreadingCollection_IProducerConsumerCollectionDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemThreadingCollection_IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemThreadingCollections_BlockingCollectionDebugView`1(BlockingCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.BitHelper : object {
    [SecurityCriticalAttribute]
internal BitHelper(Int32* bitArrayPtr, int length);
    internal BitHelper(Int32[] bitArray, int length);
    [SecurityCriticalAttribute]
internal void MarkBit(int bitPosition);
    [SecurityCriticalAttribute]
internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.System_CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.LinkedList`1 : object {
    internal LinkedListNode`1<T> head;
    internal int count;
    internal int version;
    public int Count { get; }
    public LinkedListNode`1<T> First { get; }
    public LinkedListNode`1<T> Last { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public LinkedList`1(IEnumerable`1<T> collection);
    protected LinkedList`1(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    public LinkedListNode`1<T> get_First();
    public LinkedListNode`1<T> get_Last();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value);
    public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value);
    public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    public LinkedListNode`1<T> AddFirst(T value);
    public void AddFirst(LinkedListNode`1<T> node);
    public LinkedListNode`1<T> AddLast(T value);
    public void AddLast(LinkedListNode`1<T> node);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public LinkedListNode`1<T> Find(T value);
    public LinkedListNode`1<T> FindLast(T value);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public sealed virtual bool Remove(T value);
    public void Remove(LinkedListNode`1<T> node);
    public void RemoveFirst();
    public void RemoveLast();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    internal void InternalRemoveNode(LinkedListNode`1<T> node);
    internal void ValidateNewNode(LinkedListNode`1<T> node);
    internal void ValidateNode(LinkedListNode`1<T> node);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ComVisibleAttribute("False")]
public class System.Collections.Generic.LinkedListNode`1 : object {
    internal LinkedList`1<T> list;
    internal LinkedListNode`1<T> next;
    internal LinkedListNode`1<T> prev;
    internal T item;
    public LinkedList`1<T> List { get; }
    public LinkedListNode`1<T> Next { get; }
    public LinkedListNode`1<T> Previous { get; }
    public T Value { get; public set; }
    public LinkedListNode`1(T value);
    internal LinkedListNode`1(LinkedList`1<T> list, T value);
    public LinkedList`1<T> get_List();
    public LinkedListNode`1<T> get_Next();
    public LinkedListNode`1<T> get_Previous();
    public T get_Value();
    public void set_Value(T value);
    internal void Invalidate();
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.System_QueueDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.Queue`1 : object {
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Queue`1(int capacity);
    public Queue`1(IEnumerable`1<T> collection);
    private static Queue`1();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void Enqueue(T item);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Dequeue();
    public T Peek();
    public bool Contains(T item);
    internal T GetElement(int i);
    public T[] ToArray();
    public void TrimExcess();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.System_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.SortedDictionary`2 : object {
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public IComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public IComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.System_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.SortedList`2 : object {
    public int Capacity { get; public set; }
    public IComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public IList`1<TKey> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public IList`1<TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TValue Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public SortedList`2(int capacity);
    public SortedList`2(IComparer`1<TKey> comparer);
    public SortedList`2(int capacity, IComparer`1<TKey> comparer);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedList`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    private static SortedList`2();
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public int get_Capacity();
    public void set_Capacity(int value);
    public IComparer`1<TKey> get_Comparer();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual int get_Count();
    public IList`1<TKey> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public IList`1<TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public int IndexOfKey(TKey key);
    public int IndexOfValue(TValue value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public void RemoveAt(int index);
    public sealed virtual bool Remove(TKey key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public void TrimExcess();
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.SortedSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.SortedSet`1 : object {
    internal static int StackAllocThreshold;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Min { get; }
    public T Max { get; }
    public SortedSet`1(IComparer`1<T> comparer);
    public SortedSet`1(IEnumerable`1<T> collection);
    public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    protected SortedSet`1(SerializationInfo info, StreamingContext context);
    internal bool InOrderTreeWalk(TreeWalkPredicate`1<T> action);
    internal virtual bool InOrderTreeWalk(TreeWalkPredicate`1<T> action, bool reverse);
    internal virtual bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal virtual void VersionCheck();
    internal virtual bool IsWithinRange(T item);
    public sealed virtual bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    internal virtual bool AddIfNotPresent(T item);
    public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int index);
    public void CopyTo(T[] array, int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal virtual Node<T> FindNode(T item);
    internal virtual int InternalIndexOf(T item);
    internal Node<T> FindRange(T from, T to);
    internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive);
    internal void UpdateVersion();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer();
    public static IEqualityComparer`1<SortedSet`1<T>> CreateSetComparer(IEqualityComparer`1<T> memberEqualityComparer);
    internal static bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer);
    internal T[] ToArray();
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public virtual void IntersectWith(IEnumerable`1<T> other);
    internal virtual void IntersectWithEnumerable(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    internal void SymmetricExceptWithSameEC(ISet`1<T> other);
    internal void SymmetricExceptWithSameEC(T[] other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public int RemoveWhere(Predicate`1<T> match);
    public T get_Min();
    public T get_Max();
    [IteratorStateMachineAttribute("System.Collections.Generic.SortedSet`1/<Reverse>d__104")]
public IEnumerable`1<T> Reverse();
    public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    protected virtual void OnDeserialization(object sender);
    public bool TryGetValue(T equalValue, T& actualValue);
}
internal class System.Collections.Generic.SortedSetDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SortedSetDebugView`1(SortedSet`1<T> set);
    public T[] get_Items();
}
internal class System.Collections.Generic.SortedSetEqualityComparer`1 : object {
    public SortedSetEqualityComparer`1(IComparer`1<T> comparer);
    public SortedSetEqualityComparer`1(IEqualityComparer`1<T> memberEqualityComparer);
    public SortedSetEqualityComparer`1(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual bool Equals(SortedSet`1<T> x, SortedSet`1<T> y);
    public sealed virtual int GetHashCode(SortedSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.System_StackDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
public class System.Collections.Generic.Stack`1 : object {
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Stack`1(int capacity);
    public Stack`1(IEnumerable`1<T> collection);
    private static Stack`1();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public T Peek();
    public T Pop();
    public void Push(T item);
    public T[] ToArray();
}
internal class System.Collections.Generic.System_CollectionDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public System_CollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.System_DictionaryDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public System_DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.System_DictionaryKeyCollectionDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public System_DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.System_DictionaryValueCollectionDebugView`2 : object {
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public System_DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.System_QueueDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public System_QueueDebugView`1(Queue`1<T> queue);
    public T[] get_Items();
}
internal class System.Collections.Generic.System_StackDebugView`1 : object {
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public System_StackDebugView`1(Stack`1<T> stack);
    public T[] get_Items();
}
internal enum System.Collections.Generic.TreeRotation : Enum {
    public int value__;
    public static TreeRotation LeftRotation;
    public static TreeRotation RightRotation;
    public static TreeRotation RightLeftRotation;
    public static TreeRotation LeftRightRotation;
}
internal class System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
    public TreeSet`1(IComparer`1<T> comparer);
    public TreeSet`1(ICollection`1<T> collection);
    public TreeSet`1(ICollection`1<T> collection, IComparer`1<T> comparer);
    public TreeSet`1(SerializationInfo siInfo, StreamingContext context);
    internal virtual bool AddIfNotPresent(T item);
}
internal class System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
    public TreeWalkPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(Node<T> node);
    public virtual IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Collections.ObjectModel.ObservableCollection`1 : Collection`1<T> {
    public ObservableCollection`1(List`1<T> list);
    public ObservableCollection`1(IEnumerable`1<T> collection);
    public void Move(int oldIndex, int newIndex);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected IDisposable BlockReentrancy();
    protected void CheckReentrancy();
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Collections.ObjectModel.ReadOnlyObservableCollection`1 : ReadOnlyCollection`1<T> {
    public ReadOnlyObservableCollection`1(ObservableCollection`1<T> list);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs args);
}
internal class System.Collections.Specialized.BackCompatibleStringComparer : object {
    internal static IEqualityComparer Default;
    private static BackCompatibleStringComparer();
    public static int GetHashCode(string obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object a, object b);
    public virtual int GetHashCode(object o);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.BitVector32 : ValueType {
    private UInt32 data;
    public bool Item { get; public set; }
    public int Item { get; public set; }
    public int Data { get; }
    public BitVector32(int data);
    public BitVector32(BitVector32 value);
    public bool get_Item(int bit);
    public void set_Item(int bit, bool value);
    public int get_Item(Section section);
    public void set_Item(Section section, int value);
    public int get_Data();
    public static int CreateMask();
    public static int CreateMask(int previous);
    public static Section CreateSection(short maxValue);
    public static Section CreateSection(short maxValue, Section previous);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static string ToString(BitVector32 value);
    public virtual string ToString();
}
public class System.Collections.Specialized.CollectionsUtil : object {
    public static Hashtable CreateCaseInsensitiveHashtable();
    public static Hashtable CreateCaseInsensitiveHashtable(int capacity);
    public static Hashtable CreateCaseInsensitiveHashtable(IDictionary d);
    public static SortedList CreateCaseInsensitiveSortedList();
}
internal class System.Collections.Specialized.CompatibleComparer : object {
    public IComparer Comparer { get; }
    public IHashCodeProvider HashCodeProvider { get; }
    public static IComparer DefaultComparer { get; }
    public static IHashCodeProvider DefaultHashCodeProvider { get; }
    internal CompatibleComparer(IComparer comparer, IHashCodeProvider hashCodeProvider);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
    public IComparer get_Comparer();
    public IHashCodeProvider get_HashCodeProvider();
    public static IComparer get_DefaultComparer();
    public static IHashCodeProvider get_DefaultHashCodeProvider();
}
internal static class System.Collections.Specialized.FixedStringLookup : object {
    internal static bool Contains(String[][] lookupTable, string value, bool ignoreCase);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.HybridDictionary : object {
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public HybridDictionary(int initialSize);
    public HybridDictionary(bool caseInsensitive);
    public HybridDictionary(int initialSize, bool caseInsensitive);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public interface System.Collections.Specialized.INotifyCollectionChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Specialized.IOrderedDictionary {
    public object Item { get; public set; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Insert(int index, object key, object value);
    public abstract virtual void RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.ListDictionary : object {
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public ListDictionary(IComparer comparer);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
public abstract class System.Collections.Specialized.NameObjectCollectionBase : object {
    internal IEqualityComparer Comparer { get; internal set; }
    protected bool IsReadOnly { get; protected set; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public KeysCollection Keys { get; }
    protected NameObjectCollectionBase(IEqualityComparer equalityComparer);
    protected NameObjectCollectionBase(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(IEqualityComparer) instead.")]
protected NameObjectCollectionBase(IHashCodeProvider hashProvider, IComparer comparer);
    [ObsoleteAttribute("Please use NameObjectCollectionBase(Int32, IEqualityComparer) instead.")]
protected NameObjectCollectionBase(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    protected NameObjectCollectionBase(int capacity);
    internal NameObjectCollectionBase(DBNull dummy);
    protected NameObjectCollectionBase(SerializationInfo info, StreamingContext context);
    private static NameObjectCollectionBase();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    internal IEqualityComparer get_Comparer();
    internal void set_Comparer(IEqualityComparer value);
    protected bool get_IsReadOnly();
    protected void set_IsReadOnly(bool value);
    protected bool BaseHasKeys();
    protected void BaseAdd(string name, object value);
    protected void BaseRemove(string name);
    protected void BaseRemoveAt(int index);
    protected void BaseClear();
    protected object BaseGet(string name);
    protected void BaseSet(string name, object value);
    protected object BaseGet(int index);
    protected string BaseGetKey(int index);
    protected void BaseSet(int index, object value);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    protected String[] BaseGetAllKeys();
    protected Object[] BaseGetAllValues();
    protected Object[] BaseGetAllValues(Type type);
    public virtual KeysCollection get_Keys();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.NameValueCollection : NameObjectCollectionBase {
    public string Item { get; public set; }
    public string Item { get; }
    public String[] AllKeys { get; }
    public NameValueCollection(NameValueCollection col);
    [ObsoleteAttribute("Please use NameValueCollection(IEqualityComparer) instead.")]
public NameValueCollection(IHashCodeProvider hashProvider, IComparer comparer);
    public NameValueCollection(int capacity);
    public NameValueCollection(IEqualityComparer equalityComparer);
    public NameValueCollection(int capacity, IEqualityComparer equalityComparer);
    public NameValueCollection(int capacity, NameValueCollection col);
    [ObsoleteAttribute("Please use NameValueCollection(Int32, IEqualityComparer) instead.")]
public NameValueCollection(int capacity, IHashCodeProvider hashProvider, IComparer comparer);
    internal NameValueCollection(DBNull dummy);
    protected NameValueCollection(SerializationInfo info, StreamingContext context);
    protected void InvalidateCachedArrays();
    public void Add(NameValueCollection c);
    public virtual void Clear();
    public void CopyTo(Array dest, int index);
    public bool HasKeys();
    internal virtual bool InternalHasKeys();
    public virtual void Add(string name, string value);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    public virtual void Set(string name, string value);
    public virtual void Remove(string name);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public virtual string Get(int index);
    public virtual String[] GetValues(int index);
    public virtual string GetKey(int index);
    public string get_Item(int index);
    public virtual String[] get_AllKeys();
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public enum System.Collections.Specialized.NotifyCollectionChangedAction : Enum {
    public int value__;
    public static NotifyCollectionChangedAction Add;
    public static NotifyCollectionChangedAction Remove;
    public static NotifyCollectionChangedAction Replace;
    public static NotifyCollectionChangedAction Move;
    public static NotifyCollectionChangedAction Reset;
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Collections.Specialized.NotifyCollectionChangedEventArgs : EventArgs {
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public IList OldItems { get; }
    public int NewStartingIndex { get; }
    public int OldStartingIndex { get; }
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
    public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
    internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex);
    public NotifyCollectionChangedAction get_Action();
    public IList get_NewItems();
    public IList get_OldItems();
    public int get_NewStartingIndex();
    public int get_OldStartingIndex();
}
[TypeForwardedFromAttribute("WindowsBase, Version=3.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Collections.Specialized.NotifyCollectionChangedEventHandler : MulticastDelegate {
    public NotifyCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.OrderedDictionary : object {
    public int Count { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ICollection Keys { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    public ICollection Values { get; }
    public OrderedDictionary(int capacity);
    public OrderedDictionary(IEqualityComparer comparer);
    public OrderedDictionary(int capacity, IEqualityComparer comparer);
    protected OrderedDictionary(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual ICollection get_Keys();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public OrderedDictionary AsReadOnly();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void Insert(int index, object key, object value);
    protected virtual void OnDeserialization(object sender);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object key);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Specialized.StringCollection : object {
    public string Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public string get_Item(int index);
    public void set_Item(int index, string value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public int Add(string value);
    public void AddRange(String[] value);
    public sealed virtual void Clear();
    public bool Contains(string value);
    public void CopyTo(String[] array, int index);
    public StringEnumerator GetEnumerator();
    public int IndexOf(string value);
    public void Insert(int index, string value);
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public void Remove(string value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DesignerSerializerAttribute("System.Diagnostics.Design.StringDictionaryCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Collections.Specialized.StringDictionary : object {
    internal Hashtable contents;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual bool ContainsKey(string key);
    public virtual bool ContainsValue(string value);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual void Remove(string key);
    internal void ReplaceHashtable(Hashtable useThisHashtableInstead);
    internal IDictionary`2<string, string> AsGenericDictionary();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Specialized.StringDictionaryWithComparer : StringDictionary {
    public string Item { get; public set; }
    public StringDictionaryWithComparer(IEqualityComparer comparer);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual bool ContainsKey(string key);
    public virtual void Remove(string key);
}
public class System.Collections.Specialized.StringEnumerator : object {
    public string Current { get; }
    internal StringEnumerator(StringCollection mappings);
    public string get_Current();
    public bool MoveNext();
    public void Reset();
}
public class System.ComponentModel.AddingNewEventArgs : EventArgs {
    public object NewObject { get; public set; }
    public AddingNewEventArgs(object newObject);
    public object get_NewObject();
    public void set_NewObject(object value);
}
public class System.ComponentModel.AddingNewEventHandler : MulticastDelegate {
    public AddingNewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AddingNewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AddingNewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.AmbientValueAttribute : Attribute {
    public object Value { get; }
    public AmbientValueAttribute(Type type, string value);
    public AmbientValueAttribute(char value);
    public AmbientValueAttribute(byte value);
    public AmbientValueAttribute(short value);
    public AmbientValueAttribute(int value);
    public AmbientValueAttribute(long value);
    public AmbientValueAttribute(float value);
    public AmbientValueAttribute(double value);
    public AmbientValueAttribute(bool value);
    public AmbientValueAttribute(string value);
    public AmbientValueAttribute(object value);
    public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.ArrayConverter : CollectionConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
internal class System.ComponentModel.ArraySubsetEnumerator : object {
    public object Current { get; }
    public ArraySubsetEnumerator(Array array, int count);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
public class System.ComponentModel.AsyncCompletedEventArgs : EventArgs {
    [SRDescriptionAttribute("Async_AsyncEventArgs_Cancelled")]
public bool Cancelled { get; }
    [SRDescriptionAttribute("Async_AsyncEventArgs_Error")]
public Exception Error { get; }
    [SRDescriptionAttribute("Async_AsyncEventArgs_UserState")]
public object UserState { get; }
    public AsyncCompletedEventArgs(Exception error, bool cancelled, object userState);
    public bool get_Cancelled();
    public Exception get_Error();
    public object get_UserState();
    protected void RaiseExceptionIfNecessary();
}
public class System.ComponentModel.AsyncCompletedEventHandler : MulticastDelegate {
    public AsyncCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.AsyncOperation : object {
    public object UserSuppliedState { get; }
    public SynchronizationContext SynchronizationContext { get; }
    protected virtual override void Finalize();
    public object get_UserSuppliedState();
    public SynchronizationContext get_SynchronizationContext();
    public void Post(SendOrPostCallback d, object arg);
    public void PostOperationCompleted(SendOrPostCallback d, object arg);
    public void OperationCompleted();
    internal static AsyncOperation CreateOperation(object userSuppliedState, SynchronizationContext syncContext);
}
public static class System.ComponentModel.AsyncOperationManager : object {
    [EditorBrowsableAttribute("2")]
public static SynchronizationContext SynchronizationContext { get; public set; }
    public static AsyncOperation CreateOperation(object userSuppliedState);
    public static SynchronizationContext get_SynchronizationContext();
    public static void set_SynchronizationContext(SynchronizationContext value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.ComponentModel.AttributeCollection : object {
    public static AttributeCollection Empty;
    protected Attribute[] Attributes { get; }
    public int Count { get; }
    public Attribute Item { get; }
    public Attribute Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public AttributeCollection(Attribute[] attributes);
    private static AttributeCollection();
    public static AttributeCollection FromExisting(AttributeCollection existing, Attribute[] newAttributes);
    protected virtual Attribute[] get_Attributes();
    public int get_Count();
    public virtual Attribute get_Item(int index);
    public virtual Attribute get_Item(Type attributeType);
    public bool Contains(Attribute attribute);
    public bool Contains(Attribute[] attributes);
    protected Attribute GetDefaultAttribute(Type attributeType);
    public IEnumerator GetEnumerator();
    public bool Matches(Attribute attribute);
    public bool Matches(Attribute[] attributes);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.AttributeProviderAttribute : Attribute {
    public string TypeName { get; }
    public string PropertyName { get; }
    public AttributeProviderAttribute(string typeName);
    public AttributeProviderAttribute(string typeName, string propertyName);
    public AttributeProviderAttribute(Type type);
    public string get_TypeName();
    public string get_PropertyName();
}
[SRDescriptionAttribute("BackgroundWorker_Desc")]
[DefaultEventAttribute("DoWork")]
public class System.ComponentModel.BackgroundWorker : Component {
    [BrowsableAttribute("False")]
[SRDescriptionAttribute("BackgroundWorker_CancellationPending")]
public bool CancellationPending { get; }
    [BrowsableAttribute("False")]
[SRDescriptionAttribute("BackgroundWorker_IsBusy")]
public bool IsBusy { get; }
    [SRCategoryAttribute("PropertyCategoryAsynchronous")]
[SRDescriptionAttribute("BackgroundWorker_WorkerReportsProgress")]
[DefaultValueAttribute("False")]
public bool WorkerReportsProgress { get; public set; }
    [SRCategoryAttribute("PropertyCategoryAsynchronous")]
[SRDescriptionAttribute("BackgroundWorker_WorkerSupportsCancellation")]
[DefaultValueAttribute("False")]
public bool WorkerSupportsCancellation { get; public set; }
    private static BackgroundWorker();
    public bool get_CancellationPending();
    public void CancelAsync();
    public void add_DoWork(DoWorkEventHandler value);
    public void remove_DoWork(DoWorkEventHandler value);
    public bool get_IsBusy();
    protected virtual void OnDoWork(DoWorkEventArgs e);
    protected virtual void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e);
    protected virtual void OnProgressChanged(ProgressChangedEventArgs e);
    public void add_ProgressChanged(ProgressChangedEventHandler value);
    public void remove_ProgressChanged(ProgressChangedEventHandler value);
    public void ReportProgress(int percentProgress);
    public void ReportProgress(int percentProgress, object userState);
    public void RunWorkerAsync();
    public void RunWorkerAsync(object argument);
    public void add_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    public void remove_RunWorkerCompleted(RunWorkerCompletedEventHandler value);
    public bool get_WorkerReportsProgress();
    public void set_WorkerReportsProgress(bool value);
    public bool get_WorkerSupportsCancellation();
    public void set_WorkerSupportsCancellation(bool value);
}
public abstract class System.ComponentModel.BaseNumberConverter : TypeConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal abstract virtual Type get_TargetType();
    internal abstract virtual object FromString(string value, int radix);
    internal abstract virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal abstract virtual object FromString(string value, CultureInfo culture);
    internal virtual Exception FromStringError(string failedText, Exception innerException);
    internal abstract virtual string ToString(object value, NumberFormatInfo formatInfo);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type t);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BindableAttribute : Attribute {
    public static BindableAttribute Yes;
    public static BindableAttribute No;
    public static BindableAttribute Default;
    public bool Bindable { get; }
    public BindingDirection Direction { get; }
    public BindableAttribute(bool bindable);
    public BindableAttribute(bool bindable, BindingDirection direction);
    public BindableAttribute(BindableSupport flags);
    public BindableAttribute(BindableSupport flags, BindingDirection direction);
    private static BindableAttribute();
    public bool get_Bindable();
    public BindingDirection get_Direction();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.BindableSupport : Enum {
    public int value__;
    public static BindableSupport No;
    public static BindableSupport Yes;
    public static BindableSupport Default;
}
public enum System.ComponentModel.BindingDirection : Enum {
    public int value__;
    public static BindingDirection OneWay;
    public static BindingDirection TwoWay;
}
public class System.ComponentModel.BindingList`1 : Collection`1<T> {
    public bool RaiseListChangedEvents { get; public set; }
    public bool AllowNew { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    public bool AllowEdit { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    public bool AllowRemove { get; public set; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    protected bool SupportsChangeNotificationCore { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    protected bool SupportsSearchingCore { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    protected bool SupportsSortingCore { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    protected bool IsSortedCore { get; }
    private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    protected PropertyDescriptor SortPropertyCore { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    protected ListSortDirection SortDirectionCore { get; }
    private bool System.ComponentModel.IRaiseItemChangedEvents.RaisesItemChangedEvents { get; }
    public BindingList`1(IList`1<T> list);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    public bool get_RaiseListChangedEvents();
    public void set_RaiseListChangedEvents(bool value);
    public void ResetBindings();
    public void ResetItem(int position);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    public virtual void CancelNew(int itemIndex);
    public virtual void EndNew(int itemIndex);
    public T AddNew();
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    protected virtual object AddNewCore();
    public bool get_AllowNew();
    public void set_AllowNew(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    public bool get_AllowEdit();
    public void set_AllowEdit(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    public bool get_AllowRemove();
    public void set_AllowRemove(bool value);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    protected virtual bool get_SupportsChangeNotificationCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    protected virtual bool get_SupportsSearchingCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    protected virtual bool get_SupportsSortingCore();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    protected virtual bool get_IsSortedCore();
    private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    protected virtual PropertyDescriptor get_SortPropertyCore();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    protected virtual ListSortDirection get_SortDirectionCore();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor prop, ListSortDirection direction);
    protected virtual void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    protected virtual void RemoveSortCore();
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor prop, object key);
    protected virtual int FindCore(PropertyDescriptor prop, object key);
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor prop);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor prop);
    private sealed virtual override bool System.ComponentModel.IRaiseItemChangedEvents.get_RaisesItemChangedEvents();
}
public class System.ComponentModel.BooleanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.BrowsableAttribute : Attribute {
    public static BrowsableAttribute Yes;
    public static BrowsableAttribute No;
    public static BrowsableAttribute Default;
    public bool Browsable { get; }
    public BrowsableAttribute(bool browsable);
    private static BrowsableAttribute();
    public bool get_Browsable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ByteConverter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.CancelEventArgs : EventArgs {
    public bool Cancel { get; public set; }
    public CancelEventArgs(bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.ComponentModel.CancelEventHandler : MulticastDelegate {
    public CancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.CategoryAttribute : Attribute {
    public static CategoryAttribute Action { get; }
    public static CategoryAttribute Appearance { get; }
    public static CategoryAttribute Asynchronous { get; }
    public static CategoryAttribute Behavior { get; }
    public static CategoryAttribute Data { get; }
    public static CategoryAttribute Default { get; }
    public static CategoryAttribute Design { get; }
    public static CategoryAttribute DragDrop { get; }
    public static CategoryAttribute Focus { get; }
    public static CategoryAttribute Format { get; }
    public static CategoryAttribute Key { get; }
    public static CategoryAttribute Layout { get; }
    public static CategoryAttribute Mouse { get; }
    public static CategoryAttribute WindowStyle { get; }
    public string Category { get; }
    public CategoryAttribute(string category);
    public static CategoryAttribute get_Action();
    public static CategoryAttribute get_Appearance();
    public static CategoryAttribute get_Asynchronous();
    public static CategoryAttribute get_Behavior();
    public static CategoryAttribute get_Data();
    public static CategoryAttribute get_Default();
    public static CategoryAttribute get_Design();
    public static CategoryAttribute get_DragDrop();
    public static CategoryAttribute get_Focus();
    public static CategoryAttribute get_Format();
    public static CategoryAttribute get_Key();
    public static CategoryAttribute get_Layout();
    public static CategoryAttribute get_Mouse();
    public static CategoryAttribute get_WindowStyle();
    public string get_Category();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual string GetLocalizedString(string value);
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.CharConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public enum System.ComponentModel.CollectionChangeAction : Enum {
    public int value__;
    public static CollectionChangeAction Add;
    public static CollectionChangeAction Remove;
    public static CollectionChangeAction Refresh;
}
public class System.ComponentModel.CollectionChangeEventArgs : EventArgs {
    public CollectionChangeAction Action { get; }
    public object Element { get; }
    public CollectionChangeEventArgs(CollectionChangeAction action, object element);
    public virtual CollectionChangeAction get_Action();
    public virtual object get_Element();
}
public class System.ComponentModel.CollectionChangeEventHandler : MulticastDelegate {
    public CollectionChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CollectionChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CollectionChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.CollectionConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ComplexBindingPropertiesAttribute : Attribute {
    public static ComplexBindingPropertiesAttribute Default;
    public string DataSource { get; }
    public string DataMember { get; }
    public ComplexBindingPropertiesAttribute(string dataSource);
    public ComplexBindingPropertiesAttribute(string dataSource, string dataMember);
    private static ComplexBindingPropertiesAttribute();
    public string get_DataSource();
    public string get_DataMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class System.ComponentModel.CompModSwitches : object {
    public static BooleanSwitch CommonDesignerServices { get; }
    public static TraceSwitch EventLog { get; }
    public static BooleanSwitch get_CommonDesignerServices();
    public static TraceSwitch get_EventLog();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
[DesignerCategoryAttribute("Component")]
public class System.ComponentModel.Component : MarshalByRefObject {
    protected bool CanRaiseEvents { get; }
    internal bool CanRaiseEventsInternal { get; }
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
protected bool DesignMode { get; }
    private static Component();
    protected virtual override void Finalize();
    protected virtual bool get_CanRaiseEvents();
    internal bool get_CanRaiseEventsInternal();
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public IContainer get_Container();
    protected virtual object GetService(Type service);
    protected bool get_DesignMode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.ComponentModel.ComponentCollection : ReadOnlyCollectionBase {
    public IComponent Item { get; }
    public IComponent Item { get; }
    public ComponentCollection(IComponent[] components);
    public virtual IComponent get_Item(string name);
    public virtual IComponent get_Item(int index);
    public void CopyTo(IComponent[] array, int index);
}
public class System.ComponentModel.ComponentConverter : ReferenceConverter {
    public ComponentConverter(Type type);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.ComponentEditor : object {
    public bool EditComponent(object component);
    public abstract virtual bool EditComponent(ITypeDescriptorContext context, object component);
}
public class System.ComponentModel.ComponentResourceManager : ResourceManager {
    public ComponentResourceManager(Type t);
    public void ApplyResources(object value, string objectName);
    public virtual void ApplyResources(object value, string objectName, CultureInfo culture);
}
public class System.ComponentModel.Container : object {
    public ComponentCollection Components { get; }
    protected virtual override void Finalize();
    public virtual void Add(IComponent component);
    public virtual void Add(IComponent component, string name);
    protected virtual ISite CreateSite(IComponent component, string name);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual object GetService(Type service);
    public virtual ComponentCollection get_Components();
    public virtual void Remove(IComponent component);
    protected void RemoveWithoutUnsiting(IComponent component);
    protected virtual void ValidateName(IComponent component, string name);
}
public abstract class System.ComponentModel.ContainerFilterService : object {
    public virtual ComponentCollection FilterComponents(ComponentCollection components);
}
public class System.ComponentModel.CultureInfoConverter : TypeConverter {
    protected virtual string GetCultureName(CultureInfo culture);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public abstract class System.ComponentModel.CustomTypeDescriptor : object {
    protected CustomTypeDescriptor(ICustomTypeDescriptor parent);
    public virtual AttributeCollection GetAttributes();
    public virtual string GetClassName();
    public virtual string GetComponentName();
    public virtual TypeConverter GetConverter();
    public virtual EventDescriptor GetDefaultEvent();
    public virtual PropertyDescriptor GetDefaultProperty();
    public virtual object GetEditor(Type editorBaseType);
    public virtual EventDescriptorCollection GetEvents();
    public virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public virtual PropertyDescriptorCollection GetProperties();
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public virtual object GetPropertyOwner(PropertyDescriptor pd);
}
public class System.ComponentModel.DataErrorsChangedEventArgs : EventArgs {
    public string PropertyName { get; }
    public DataErrorsChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DataObjectAttribute : Attribute {
    public static DataObjectAttribute DataObject;
    public static DataObjectAttribute NonDataObject;
    public static DataObjectAttribute Default;
    public bool IsDataObject { get; }
    public DataObjectAttribute(bool isDataObject);
    private static DataObjectAttribute();
    public bool get_IsDataObject();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.DataObjectFieldAttribute : Attribute {
    public bool IsIdentity { get; }
    public bool IsNullable { get; }
    public int Length { get; }
    public bool PrimaryKey { get; }
    public DataObjectFieldAttribute(bool primaryKey);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable);
    public DataObjectFieldAttribute(bool primaryKey, bool isIdentity, bool isNullable, int length);
    public bool get_IsIdentity();
    public bool get_IsNullable();
    public int get_Length();
    public bool get_PrimaryKey();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("64")]
public class System.ComponentModel.DataObjectMethodAttribute : Attribute {
    public bool IsDefault { get; }
    public DataObjectMethodType MethodType { get; }
    public DataObjectMethodAttribute(DataObjectMethodType methodType);
    public DataObjectMethodAttribute(DataObjectMethodType methodType, bool isDefault);
    public bool get_IsDefault();
    public DataObjectMethodType get_MethodType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
}
public enum System.ComponentModel.DataObjectMethodType : Enum {
    public int value__;
    public static DataObjectMethodType Fill;
    public static DataObjectMethodType Select;
    public static DataObjectMethodType Update;
    public static DataObjectMethodType Insert;
    public static DataObjectMethodType Delete;
}
public class System.ComponentModel.DateTimeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DateTimeOffsetConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.DecimalConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultBindingPropertyAttribute : Attribute {
    public static DefaultBindingPropertyAttribute Default;
    public string Name { get; }
    public DefaultBindingPropertyAttribute(string name);
    private static DefaultBindingPropertyAttribute();
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultEventAttribute : Attribute {
    public static DefaultEventAttribute Default;
    public string Name { get; }
    public DefaultEventAttribute(string name);
    private static DefaultEventAttribute();
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DefaultPropertyAttribute : Attribute {
    public static DefaultPropertyAttribute Default;
    public string Name { get; }
    public DefaultPropertyAttribute(string name);
    private static DefaultPropertyAttribute();
    public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    public object Value { get; }
    public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
internal class System.ComponentModel.DelegatingTypeDescriptionProvider : TypeDescriptionProvider {
    internal TypeDescriptionProvider Provider { get; }
    internal DelegatingTypeDescriptionProvider(Type type);
    internal TypeDescriptionProvider get_Provider();
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public virtual IDictionary GetCache(object instance);
    public virtual string GetFullComponentName(object component);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual Type GetRuntimeType(Type objectType);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual bool IsSupportedType(Type type);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DescriptionAttribute : Attribute {
    public static DescriptionAttribute Default;
    public string Description { get; }
    protected string DescriptionValue { get; protected set; }
    public DescriptionAttribute(string description);
    private static DescriptionAttribute();
    public virtual string get_Description();
    protected string get_DescriptionValue();
    protected void set_DescriptionValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.Design.ActiveDesignerEventArgs : EventArgs {
    public IDesignerHost OldDesigner { get; }
    public IDesignerHost NewDesigner { get; }
    public ActiveDesignerEventArgs(IDesignerHost oldDesigner, IDesignerHost newDesigner);
    public IDesignerHost get_OldDesigner();
    public IDesignerHost get_NewDesigner();
}
public class System.ComponentModel.Design.ActiveDesignerEventHandler : MulticastDelegate {
    public ActiveDesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ActiveDesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ActiveDesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.CheckoutException : ExternalException {
    public static CheckoutException Canceled;
    public CheckoutException(string message);
    public CheckoutException(string message, int errorCode);
    protected CheckoutException(SerializationInfo info, StreamingContext context);
    public CheckoutException(string message, Exception innerException);
    private static CheckoutException();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.CommandID : object {
    public int ID { get; }
    public Guid Guid { get; }
    public CommandID(Guid menuGroup, int commandID);
    public virtual int get_ID();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Guid get_Guid();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentChangedEventArgs : EventArgs {
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public object NewValue { get; }
    public object OldValue { get; }
    public ComponentChangedEventArgs(object component, MemberDescriptor member, object oldValue, object newValue);
    public object get_Component();
    public MemberDescriptor get_Member();
    public object get_NewValue();
    public object get_OldValue();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentChangedEventHandler : MulticastDelegate {
    public ComponentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentChangingEventArgs : EventArgs {
    public object Component { get; }
    public MemberDescriptor Member { get; }
    public ComponentChangingEventArgs(object component, MemberDescriptor member);
    public object get_Component();
    public MemberDescriptor get_Member();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentChangingEventHandler : MulticastDelegate {
    public ComponentChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentEventArgs : EventArgs {
    public IComponent Component { get; }
    public ComponentEventArgs(IComponent component);
    public virtual IComponent get_Component();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentEventHandler : MulticastDelegate {
    public ComponentEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentRenameEventArgs : EventArgs {
    public object Component { get; }
    public string OldName { get; }
    public string NewName { get; }
    public ComponentRenameEventArgs(object component, string oldName, string newName);
    public object get_Component();
    public virtual string get_OldName();
    public virtual string get_NewName();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ComponentRenameEventHandler : MulticastDelegate {
    public ComponentRenameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ComponentRenameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ComponentRenameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.DesignerCollection : object {
    public int Count { get; }
    public IDesignerHost Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public DesignerCollection(IDesignerHost[] designers);
    public DesignerCollection(IList designers);
    public int get_Count();
    public virtual IDesignerHost get_Item(int index);
    public IEnumerator GetEnumerator();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ComponentModel.Design.DesignerEventArgs : EventArgs {
    public IDesignerHost Designer { get; }
    public DesignerEventArgs(IDesignerHost host);
    public IDesignerHost get_Designer();
}
public class System.ComponentModel.Design.DesignerEventHandler : MulticastDelegate {
    public DesignerEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.ComponentModel.Design.DesignerOptionService : object {
    public DesignerOptionCollection Options { get; }
    public DesignerOptionCollection get_Options();
    protected DesignerOptionCollection CreateOptionCollection(DesignerOptionCollection parent, string name, object value);
    protected virtual void PopulateOptionCollection(DesignerOptionCollection options);
    protected virtual bool ShowDialog(DesignerOptionCollection options, object optionObject);
    private sealed virtual override object System.ComponentModel.Design.IDesignerOptionService.GetOptionValue(string pageName, string valueName);
    private sealed virtual override void System.ComponentModel.Design.IDesignerOptionService.SetOptionValue(string pageName, string valueName, object value);
}
public abstract class System.ComponentModel.Design.DesignerTransaction : object {
    public bool Canceled { get; }
    public bool Committed { get; }
    public string Description { get; }
    protected DesignerTransaction(string description);
    public bool get_Canceled();
    public bool get_Committed();
    public string get_Description();
    public void Cancel();
    public void Commit();
    protected abstract virtual void OnCancel();
    protected abstract virtual void OnCommit();
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.DesignerTransactionCloseEventArgs : EventArgs {
    public bool TransactionCommitted { get; }
    public bool LastTransaction { get; }
    [ObsoleteAttribute("This constructor is obsolete. Use DesignerTransactionCloseEventArgs(bool, bool) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public DesignerTransactionCloseEventArgs(bool commit);
    public DesignerTransactionCloseEventArgs(bool commit, bool lastTransaction);
    public bool get_TransactionCommitted();
    public bool get_LastTransaction();
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.DesignerTransactionCloseEventHandler : MulticastDelegate {
    public DesignerTransactionCloseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesignerTransactionCloseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesignerTransactionCloseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.DesignerVerb : MenuCommand {
    public string Description { get; public set; }
    public string Text { get; }
    public DesignerVerb(string text, EventHandler handler);
    public DesignerVerb(string text, EventHandler handler, CommandID startCommandID);
    public string get_Description();
    public void set_Description(string value);
    public string get_Text();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.DesignerVerbCollection : CollectionBase {
    public DesignerVerb Item { get; public set; }
    public DesignerVerbCollection(DesignerVerb[] value);
    public DesignerVerb get_Item(int index);
    public void set_Item(int index, DesignerVerb value);
    public int Add(DesignerVerb value);
    public void AddRange(DesignerVerb[] value);
    public void AddRange(DesignerVerbCollection value);
    public void Insert(int index, DesignerVerb value);
    public int IndexOf(DesignerVerb value);
    public bool Contains(DesignerVerb value);
    public void Remove(DesignerVerb value);
    public void CopyTo(DesignerVerb[] array, int index);
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnValidate(object value);
}
public class System.ComponentModel.Design.DesigntimeLicenseContext : LicenseContext {
    internal Hashtable savedLicenseKeys;
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.Design.DesigntimeLicenseContextSerializer : object {
    public static void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context);
    internal static void Deserialize(Stream o, string cryptoKey, RuntimeLicenseContext context);
}
public enum System.ComponentModel.Design.HelpContextType : Enum {
    public int value__;
    public static HelpContextType Ambient;
    public static HelpContextType Window;
    public static HelpContextType Selection;
    public static HelpContextType ToolWindowSelection;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.Design.HelpKeywordAttribute : Attribute {
    public static HelpKeywordAttribute Default;
    public string HelpKeyword { get; }
    public HelpKeywordAttribute(string keyword);
    public HelpKeywordAttribute(Type t);
    private static HelpKeywordAttribute();
    public string get_HelpKeyword();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public enum System.ComponentModel.Design.HelpKeywordType : Enum {
    public int value__;
    public static HelpKeywordType F1Keyword;
    public static HelpKeywordType GeneralKeyword;
    public static HelpKeywordType FilterKeyword;
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IComponentChangeService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdded(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentAdding(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanged(ComponentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentChanging(ComponentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoved(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRemoving(ComponentEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ComponentRename(ComponentRenameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ComponentRename(ComponentRenameEventHandler value);
    public abstract virtual void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue);
    public abstract virtual void OnComponentChanging(object component, MemberDescriptor member);
}
public interface System.ComponentModel.Design.IComponentDiscoveryService {
    public abstract virtual ICollection GetComponentTypes(IDesignerHost designerHost, Type baseType);
}
public interface System.ComponentModel.Design.IComponentInitializer {
    public abstract virtual void InitializeExistingComponent(IDictionary defaultValues);
    public abstract virtual void InitializeNewComponent(IDictionary defaultValues);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IDesigner {
    public IComponent Component { get; }
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual IComponent get_Component();
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void DoDefaultAction();
    public abstract virtual void Initialize(IComponent component);
}
public interface System.ComponentModel.Design.IDesignerEventService {
    public IDesignerHost ActiveDesigner { get; }
    public DesignerCollection Designers { get; }
    public abstract virtual IDesignerHost get_ActiveDesigner();
    public abstract virtual DesignerCollection get_Designers();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActiveDesignerChanged(ActiveDesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerCreated(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DesignerDisposed(DesignerEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
}
public interface System.ComponentModel.Design.IDesignerFilter {
    public abstract virtual void PostFilterAttributes(IDictionary attributes);
    public abstract virtual void PostFilterEvents(IDictionary events);
    public abstract virtual void PostFilterProperties(IDictionary properties);
    public abstract virtual void PreFilterAttributes(IDictionary attributes);
    public abstract virtual void PreFilterEvents(IDictionary events);
    public abstract virtual void PreFilterProperties(IDictionary properties);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IDesignerHost {
    public bool Loading { get; }
    public bool InTransaction { get; }
    public IContainer Container { get; }
    public IComponent RootComponent { get; }
    public string RootComponentClassName { get; }
    public string TransactionDescription { get; }
    public abstract virtual bool get_Loading();
    public abstract virtual bool get_InTransaction();
    public abstract virtual IContainer get_Container();
    public abstract virtual IComponent get_RootComponent();
    public abstract virtual string get_RootComponentClassName();
    public abstract virtual string get_TransactionDescription();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoadComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosed(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionClosing(DesignerTransactionCloseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TransactionOpening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TransactionOpening(EventHandler value);
    public abstract virtual void Activate();
    public abstract virtual IComponent CreateComponent(Type componentClass);
    public abstract virtual IComponent CreateComponent(Type componentClass, string name);
    public abstract virtual DesignerTransaction CreateTransaction();
    public abstract virtual DesignerTransaction CreateTransaction(string description);
    public abstract virtual void DestroyComponent(IComponent component);
    public abstract virtual IDesigner GetDesigner(IComponent component);
    public abstract virtual Type GetType(string typeName);
}
public interface System.ComponentModel.Design.IDesignerHostTransactionState {
    public bool IsClosingTransaction { get; }
    public abstract virtual bool get_IsClosingTransaction();
}
public interface System.ComponentModel.Design.IDesignerOptionService {
    public abstract virtual object GetOptionValue(string pageName, string valueName);
    public abstract virtual void SetOptionValue(string pageName, string valueName, object value);
}
public interface System.ComponentModel.Design.IDictionaryService {
    public abstract virtual object GetKey(object value);
    public abstract virtual object GetValue(object key);
    public abstract virtual void SetValue(object key, object value);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IEventBindingService {
    public abstract virtual string CreateUniqueMethodName(IComponent component, EventDescriptor e);
    public abstract virtual ICollection GetCompatibleMethods(EventDescriptor e);
    public abstract virtual EventDescriptor GetEvent(PropertyDescriptor property);
    public abstract virtual PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events);
    public abstract virtual PropertyDescriptor GetEventProperty(EventDescriptor e);
    public abstract virtual bool ShowCode();
    public abstract virtual bool ShowCode(int lineNumber);
    public abstract virtual bool ShowCode(IComponent component, EventDescriptor e);
}
public interface System.ComponentModel.Design.IExtenderListService {
    public abstract virtual IExtenderProvider[] GetExtenderProviders();
}
public interface System.ComponentModel.Design.IExtenderProviderService {
    public abstract virtual void AddExtenderProvider(IExtenderProvider provider);
    public abstract virtual void RemoveExtenderProvider(IExtenderProvider provider);
}
public interface System.ComponentModel.Design.IHelpService {
    public abstract virtual void AddContextAttribute(string name, string value, HelpKeywordType keywordType);
    public abstract virtual void ClearContextAttributes();
    public abstract virtual IHelpService CreateLocalContext(HelpContextType contextType);
    public abstract virtual void RemoveContextAttribute(string name, string value);
    public abstract virtual void RemoveLocalContext(IHelpService localContext);
    public abstract virtual void ShowHelpFromKeyword(string helpKeyword);
    public abstract virtual void ShowHelpFromUrl(string helpUrl);
}
public interface System.ComponentModel.Design.IInheritanceService {
    public abstract virtual void AddInheritedComponents(IComponent component, IContainer container);
    public abstract virtual InheritanceAttribute GetInheritanceAttribute(IComponent component);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IMenuCommandService {
    public DesignerVerbCollection Verbs { get; }
    public abstract virtual DesignerVerbCollection get_Verbs();
    public abstract virtual void AddCommand(MenuCommand command);
    public abstract virtual void AddVerb(DesignerVerb verb);
    public abstract virtual MenuCommand FindCommand(CommandID commandID);
    public abstract virtual bool GlobalInvoke(CommandID commandID);
    public abstract virtual void RemoveCommand(MenuCommand command);
    public abstract virtual void RemoveVerb(DesignerVerb verb);
    public abstract virtual void ShowContextMenu(CommandID menuID, int x, int y);
}
public interface System.ComponentModel.Design.IReferenceService {
    public abstract virtual IComponent GetComponent(object reference);
    public abstract virtual object GetReference(string name);
    public abstract virtual string GetName(object reference);
    public abstract virtual Object[] GetReferences();
    public abstract virtual Object[] GetReferences(Type baseType);
}
public interface System.ComponentModel.Design.IResourceService {
    public abstract virtual IResourceReader GetResourceReader(CultureInfo info);
    public abstract virtual IResourceWriter GetResourceWriter(CultureInfo info);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IRootDesigner {
    public ViewTechnology[] SupportedTechnologies { get; }
    public abstract virtual ViewTechnology[] get_SupportedTechnologies();
    public abstract virtual object GetView(ViewTechnology technology);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.ISelectionService {
    public object PrimarySelection { get; }
    public int SelectionCount { get; }
    public abstract virtual object get_PrimarySelection();
    public abstract virtual int get_SelectionCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectionChanging(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectionChanging(EventHandler value);
    public abstract virtual bool GetComponentSelected(object component);
    public abstract virtual ICollection GetSelectedComponents();
    public abstract virtual void SetSelectedComponents(ICollection components);
    public abstract virtual void SetSelectedComponents(ICollection components, SelectionTypes selectionType);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.Design.IServiceContainer {
    public abstract virtual void AddService(Type serviceType, object serviceInstance);
    public abstract virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public abstract virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public abstract virtual void RemoveService(Type serviceType);
    public abstract virtual void RemoveService(Type serviceType, bool promote);
}
public interface System.ComponentModel.Design.ITreeDesigner {
    public ICollection Children { get; }
    public IDesigner Parent { get; }
    public abstract virtual ICollection get_Children();
    public abstract virtual IDesigner get_Parent();
}
public interface System.ComponentModel.Design.ITypeDescriptorFilterService {
    public abstract virtual bool FilterAttributes(IComponent component, IDictionary attributes);
    public abstract virtual bool FilterEvents(IComponent component, IDictionary events);
    public abstract virtual bool FilterProperties(IComponent component, IDictionary properties);
}
public interface System.ComponentModel.Design.ITypeDiscoveryService {
    public abstract virtual ICollection GetTypes(Type baseType, bool excludeGlobalTypes);
}
public interface System.ComponentModel.Design.ITypeResolutionService {
    public abstract virtual Assembly GetAssembly(AssemblyName name);
    public abstract virtual Assembly GetAssembly(AssemblyName name, bool throwOnError);
    public abstract virtual Type GetType(string name);
    public abstract virtual Type GetType(string name, bool throwOnError);
    public abstract virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public abstract virtual void ReferenceAssembly(AssemblyName name);
    public abstract virtual string GetPathOfAssembly(AssemblyName name);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.MenuCommand : object {
    public bool Checked { get; public set; }
    public bool Enabled { get; public set; }
    public IDictionary Properties { get; }
    public bool Supported { get; public set; }
    public bool Visible { get; public set; }
    public CommandID CommandID { get; }
    public int OleStatus { get; }
    public MenuCommand(EventHandler handler, CommandID command);
    public virtual bool get_Checked();
    public virtual void set_Checked(bool value);
    public virtual bool get_Enabled();
    public virtual void set_Enabled(bool value);
    public virtual IDictionary get_Properties();
    public virtual bool get_Supported();
    public virtual void set_Supported(bool value);
    public virtual bool get_Visible();
    public virtual void set_Visible(bool value);
    public void add_CommandChanged(EventHandler value);
    public void remove_CommandChanged(EventHandler value);
    public virtual CommandID get_CommandID();
    public virtual void Invoke();
    public virtual void Invoke(object arg);
    public virtual int get_OleStatus();
    protected virtual void OnCommandChanged(EventArgs e);
    public virtual string ToString();
}
internal class System.ComponentModel.Design.RuntimeLicenseContext : LicenseContext {
    internal Hashtable savedLicenseKeys;
    private static RuntimeLicenseContext();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.ComponentModel.Design.SelectionTypes : Enum {
    public int value__;
    public static SelectionTypes Auto;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Auto instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Normal;
    public static SelectionTypes Replace;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseDown;
    [ObsoleteAttribute("This value has been deprecated.  It is no longer supported. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes MouseUp;
    [ObsoleteAttribute("This value has been deprecated. Use SelectionTypes.Primary instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Click;
    public static SelectionTypes Primary;
    public static SelectionTypes Toggle;
    public static SelectionTypes Add;
    public static SelectionTypes Remove;
    [ObsoleteAttribute("This value has been deprecated. Use Enum class methods to determine valid values, or use a type converter. http://go.microsoft.com/fwlink/?linkid=14202")]
public static SelectionTypes Valid;
}
public abstract class System.ComponentModel.Design.Serialization.ComponentSerializationService : object {
    public abstract virtual SerializationStore CreateStore();
    public abstract virtual SerializationStore LoadStore(Stream stream);
    public abstract virtual void Serialize(SerializationStore store, object value);
    public abstract virtual void SerializeAbsolute(SerializationStore store, object value);
    public abstract virtual void SerializeMember(SerializationStore store, object owningObject, MemberDescriptor member);
    public abstract virtual void SerializeMemberAbsolute(SerializationStore store, object owningObject, MemberDescriptor member);
    public abstract virtual ICollection Deserialize(SerializationStore store);
    public abstract virtual ICollection Deserialize(SerializationStore store, IContainer container);
    public abstract virtual void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes, bool applyDefaults);
    public void DeserializeTo(SerializationStore store, IContainer container);
    public void DeserializeTo(SerializationStore store, IContainer container, bool validateRecycledTypes);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.Design.Serialization.ContextStack : object {
    public object Current { get; }
    public object Item { get; }
    public object Item { get; }
    public object get_Current();
    public object get_Item(int level);
    public object get_Item(Type type);
    public void Append(object context);
    public object Pop();
    public void Push(object context);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.Design.Serialization.DefaultSerializationProviderAttribute : Attribute {
    public string ProviderTypeName { get; }
    public DefaultSerializationProviderAttribute(Type providerType);
    public DefaultSerializationProviderAttribute(string providerTypeName);
    public string get_ProviderTypeName();
}
[ComVisibleAttribute("True")]
public abstract class System.ComponentModel.Design.Serialization.DesignerLoader : object {
    public bool Loading { get; }
    public virtual bool get_Loading();
    public abstract virtual void BeginLoad(IDesignerLoaderHost host);
    public abstract virtual void Dispose();
    public virtual void Flush();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.Design.Serialization.DesignerSerializerAttribute : Attribute {
    public string SerializerTypeName { get; }
    public string SerializerBaseTypeName { get; }
    public object TypeId { get; }
    public DesignerSerializerAttribute(Type serializerType, Type baseSerializerType);
    public DesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType);
    public DesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName);
    public string get_SerializerTypeName();
    public string get_SerializerBaseTypeName();
    public virtual object get_TypeId();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost {
    public abstract virtual void EndLoad(string baseClassName, bool successful, ICollection errorCollection);
    public abstract virtual void Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderHost2 {
    public bool IgnoreErrorsDuringReload { get; public set; }
    public bool CanReloadWithErrors { get; public set; }
    public abstract virtual bool get_IgnoreErrorsDuringReload();
    public abstract virtual void set_IgnoreErrorsDuringReload(bool value);
    public abstract virtual bool get_CanReloadWithErrors();
    public abstract virtual void set_CanReloadWithErrors(bool value);
}
public interface System.ComponentModel.Design.Serialization.IDesignerLoaderService {
    public abstract virtual void AddLoadDependency();
    public abstract virtual void DependentLoadComplete(bool successful, ICollection errorCollection);
    public abstract virtual bool Reload();
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationManager {
    public ContextStack Context { get; }
    public PropertyDescriptorCollection Properties { get; }
    public abstract virtual ContextStack get_Context();
    public abstract virtual PropertyDescriptorCollection get_Properties();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveName(ResolveNameEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SerializationComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SerializationComplete(EventHandler value);
    public abstract virtual void AddSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer);
    public abstract virtual object GetInstance(string name);
    public abstract virtual string GetName(object value);
    public abstract virtual object GetSerializer(Type objectType, Type serializerType);
    public abstract virtual Type GetType(string typeName);
    public abstract virtual void RemoveSerializationProvider(IDesignerSerializationProvider provider);
    public abstract virtual void ReportError(object errorInformation);
    public abstract virtual void SetName(object instance, string name);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationProvider {
    public abstract virtual object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType);
}
public interface System.ComponentModel.Design.Serialization.IDesignerSerializationService {
    public abstract virtual ICollection Deserialize(object serializationData);
    public abstract virtual object Serialize(ICollection objects);
}
public interface System.ComponentModel.Design.Serialization.INameCreationService {
    public abstract virtual string CreateName(IContainer container, Type dataType);
    public abstract virtual bool IsValidName(string name);
    public abstract virtual void ValidateName(string name);
}
public class System.ComponentModel.Design.Serialization.InstanceDescriptor : object {
    public ICollection Arguments { get; }
    public bool IsComplete { get; }
    public MemberInfo MemberInfo { get; }
    public InstanceDescriptor(MemberInfo member, ICollection arguments);
    public InstanceDescriptor(MemberInfo member, ICollection arguments, bool isComplete);
    public ICollection get_Arguments();
    public bool get_IsComplete();
    public MemberInfo get_MemberInfo();
    public object Invoke();
}
public class System.ComponentModel.Design.Serialization.MemberRelationship : ValueType {
    private object _owner;
    private MemberDescriptor _member;
    public static MemberRelationship Empty;
    public bool IsEmpty { get; }
    public MemberDescriptor Member { get; }
    public object Owner { get; }
    public MemberRelationship(object owner, MemberDescriptor member);
    private static MemberRelationship();
    public bool get_IsEmpty();
    public MemberDescriptor get_Member();
    public object get_Owner();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberRelationship left, MemberRelationship right);
    public static bool op_Inequality(MemberRelationship left, MemberRelationship right);
}
[DefaultMemberAttribute("Item")]
public abstract class System.ComponentModel.Design.Serialization.MemberRelationshipService : object {
    public MemberRelationship Item { get; public set; }
    public MemberRelationship Item { get; public set; }
    public MemberRelationship get_Item(MemberRelationship source);
    public void set_Item(MemberRelationship source, MemberRelationship value);
    public MemberRelationship get_Item(object sourceOwner, MemberDescriptor sourceMember);
    public void set_Item(object sourceOwner, MemberDescriptor sourceMember, MemberRelationship value);
    protected virtual MemberRelationship GetRelationship(MemberRelationship source);
    protected virtual void SetRelationship(MemberRelationship source, MemberRelationship relationship);
    public abstract virtual bool SupportsRelationship(MemberRelationship source, MemberRelationship relationship);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventArgs : EventArgs {
    public string Name { get; }
    public object Value { get; public set; }
    public ResolveNameEventArgs(string name);
    public string get_Name();
    public object get_Value();
    public void set_Value(object value);
}
public class System.ComponentModel.Design.Serialization.ResolveNameEventHandler : MulticastDelegate {
    public ResolveNameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ResolveNameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveNameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1028")]
[ObsoleteAttribute("This attribute has been deprecated. Use DesignerSerializerAttribute instead.  For example, to specify a root designer for CodeDom, use DesignerSerializerAttribute(...,typeof(TypeCodeDomSerializer)).  http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.ComponentModel.Design.Serialization.RootDesignerSerializerAttribute : Attribute {
    public bool Reloadable { get; }
    public string SerializerTypeName { get; }
    public string SerializerBaseTypeName { get; }
    public object TypeId { get; }
    public RootDesignerSerializerAttribute(Type serializerType, Type baseSerializerType, bool reloadable);
    public RootDesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType, bool reloadable);
    public RootDesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName, bool reloadable);
    public bool get_Reloadable();
    public string get_SerializerTypeName();
    public string get_SerializerBaseTypeName();
    public virtual object get_TypeId();
}
public abstract class System.ComponentModel.Design.Serialization.SerializationStore : object {
    public ICollection Errors { get; }
    public abstract virtual ICollection get_Errors();
    public abstract virtual void Close();
    public abstract virtual void Save(Stream stream);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.ComponentModel.Design.ServiceContainer : object {
    protected Type[] DefaultServices { get; }
    public ServiceContainer(IServiceProvider parentProvider);
    private static ServiceContainer();
    protected virtual Type[] get_DefaultServices();
    public sealed virtual void AddService(Type serviceType, object serviceInstance);
    public virtual void AddService(Type serviceType, object serviceInstance, bool promote);
    public sealed virtual void AddService(Type serviceType, ServiceCreatorCallback callback);
    public virtual void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual object GetService(Type serviceType);
    public sealed virtual void RemoveService(Type serviceType);
    public virtual void RemoveService(Type serviceType, bool promote);
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.Design.ServiceCreatorCallback : MulticastDelegate {
    public ServiceCreatorCallback(object object, IntPtr method);
    public virtual object Invoke(IServiceContainer container, Type serviceType);
    public virtual IAsyncResult BeginInvoke(IServiceContainer container, Type serviceType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.Design.StandardCommands : object {
    public static CommandID AlignBottom;
    public static CommandID AlignHorizontalCenters;
    public static CommandID AlignLeft;
    public static CommandID AlignRight;
    public static CommandID AlignToGrid;
    public static CommandID AlignTop;
    public static CommandID AlignVerticalCenters;
    public static CommandID ArrangeBottom;
    public static CommandID ArrangeRight;
    public static CommandID BringForward;
    public static CommandID BringToFront;
    public static CommandID CenterHorizontally;
    public static CommandID CenterVertically;
    public static CommandID ViewCode;
    public static CommandID DocumentOutline;
    public static CommandID Copy;
    public static CommandID Cut;
    public static CommandID Delete;
    public static CommandID Group;
    public static CommandID HorizSpaceConcatenate;
    public static CommandID HorizSpaceDecrease;
    public static CommandID HorizSpaceIncrease;
    public static CommandID HorizSpaceMakeEqual;
    public static CommandID Paste;
    public static CommandID Properties;
    public static CommandID Redo;
    public static CommandID MultiLevelRedo;
    public static CommandID SelectAll;
    public static CommandID SendBackward;
    public static CommandID SendToBack;
    public static CommandID SizeToControl;
    public static CommandID SizeToControlHeight;
    public static CommandID SizeToControlWidth;
    public static CommandID SizeToFit;
    public static CommandID SizeToGrid;
    public static CommandID SnapToGrid;
    public static CommandID TabOrder;
    public static CommandID Undo;
    public static CommandID MultiLevelUndo;
    public static CommandID Ungroup;
    public static CommandID VertSpaceConcatenate;
    public static CommandID VertSpaceDecrease;
    public static CommandID VertSpaceIncrease;
    public static CommandID VertSpaceMakeEqual;
    public static CommandID ShowGrid;
    public static CommandID ViewGrid;
    public static CommandID Replace;
    public static CommandID PropertiesWindow;
    public static CommandID LockControls;
    public static CommandID F1Help;
    public static CommandID ArrangeIcons;
    public static CommandID LineupIcons;
    public static CommandID ShowLargeIcons;
    public static CommandID VerbFirst;
    public static CommandID VerbLast;
    private static StandardCommands();
}
public class System.ComponentModel.Design.StandardToolWindows : object {
    public static Guid ObjectBrowser;
    public static Guid OutputWindow;
    public static Guid ProjectExplorer;
    public static Guid PropertyBrowser;
    public static Guid RelatedLinks;
    public static Guid ServerExplorer;
    public static Guid TaskList;
    public static Guid Toolbox;
    private static StandardToolWindows();
}
public abstract class System.ComponentModel.Design.TypeDescriptionProviderService : object {
    public abstract virtual TypeDescriptionProvider GetProvider(object instance);
    public abstract virtual TypeDescriptionProvider GetProvider(Type type);
}
[ComVisibleAttribute("True")]
public enum System.ComponentModel.Design.ViewTechnology : Enum {
    public int value__;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology Passthrough;
    [ObsoleteAttribute("This value has been deprecated. Use ViewTechnology.Default instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static ViewTechnology WindowsForms;
    public static ViewTechnology Default;
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignerAttribute : Attribute {
    public string DesignerBaseTypeName { get; }
    public string DesignerTypeName { get; }
    public object TypeId { get; }
    public DesignerAttribute(string designerTypeName);
    public DesignerAttribute(Type designerType);
    public DesignerAttribute(string designerTypeName, string designerBaseTypeName);
    public DesignerAttribute(string designerTypeName, Type designerBaseType);
    public DesignerAttribute(Type designerType, Type designerBaseType);
    public string get_DesignerBaseTypeName();
    public string get_DesignerTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.DesignerCategoryAttribute : Attribute {
    public static DesignerCategoryAttribute Component;
    public static DesignerCategoryAttribute Default;
    public static DesignerCategoryAttribute Form;
    public static DesignerCategoryAttribute Generic;
    public string Category { get; }
    public object TypeId { get; }
    public DesignerCategoryAttribute(string category);
    private static DesignerCategoryAttribute();
    public string get_Category();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[ComVisibleAttribute("True")]
public enum System.ComponentModel.DesignerSerializationVisibility : Enum {
    public int value__;
    public static DesignerSerializationVisibility Hidden;
    public static DesignerSerializationVisibility Visible;
    public static DesignerSerializationVisibility Content;
}
[AttributeUsageAttribute("960")]
public class System.ComponentModel.DesignerSerializationVisibilityAttribute : Attribute {
    public static DesignerSerializationVisibilityAttribute Content;
    public static DesignerSerializationVisibilityAttribute Hidden;
    public static DesignerSerializationVisibilityAttribute Visible;
    public static DesignerSerializationVisibilityAttribute Default;
    public DesignerSerializationVisibility Visibility { get; }
    public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility visibility);
    private static DesignerSerializationVisibilityAttribute();
    public DesignerSerializationVisibility get_Visibility();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DesignOnlyAttribute : Attribute {
    public static DesignOnlyAttribute Yes;
    public static DesignOnlyAttribute No;
    public static DesignOnlyAttribute Default;
    public bool IsDesignOnly { get; }
    public DesignOnlyAttribute(bool isDesignOnly);
    private static DesignOnlyAttribute();
    public bool get_IsDesignOnly();
    public virtual bool IsDefaultAttribute();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("1028")]
public class System.ComponentModel.DesignTimeVisibleAttribute : Attribute {
    public static DesignTimeVisibleAttribute Yes;
    public static DesignTimeVisibleAttribute No;
    public static DesignTimeVisibleAttribute Default;
    public bool Visible { get; }
    public DesignTimeVisibleAttribute(bool visible);
    private static DesignTimeVisibleAttribute();
    public bool get_Visible();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("708")]
public class System.ComponentModel.DisplayNameAttribute : Attribute {
    public static DisplayNameAttribute Default;
    public string DisplayName { get; }
    protected string DisplayNameValue { get; protected set; }
    public DisplayNameAttribute(string displayName);
    private static DisplayNameAttribute();
    public virtual string get_DisplayName();
    protected string get_DisplayNameValue();
    protected void set_DisplayNameValue(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.DoubleConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.DoWorkEventArgs : CancelEventArgs {
    [SRDescriptionAttribute("BackgroundWorker_DoWorkEventArgs_Argument")]
public object Argument { get; }
    [SRDescriptionAttribute("BackgroundWorker_DoWorkEventArgs_Result")]
public object Result { get; public set; }
    public DoWorkEventArgs(object argument);
    public object get_Argument();
    public object get_Result();
    public void set_Result(object value);
}
public class System.ComponentModel.DoWorkEventHandler : MulticastDelegate {
    public DoWorkEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DoWorkEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DoWorkEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.EditorAttribute : Attribute {
    public string EditorBaseTypeName { get; }
    public string EditorTypeName { get; }
    public object TypeId { get; }
    public EditorAttribute(string typeName, string baseTypeName);
    public EditorAttribute(string typeName, Type baseType);
    public EditorAttribute(Type type, Type baseType);
    public string get_EditorBaseTypeName();
    public string get_EditorTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public class System.ComponentModel.EnumConverter : TypeConverter {
    protected Type EnumType { get; }
    protected StandardValuesCollection Values { get; protected set; }
    protected IComparer Comparer { get; }
    public EnumConverter(Type type);
    protected Type get_EnumType();
    protected StandardValuesCollection get_Values();
    protected void set_Values(StandardValuesCollection value);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    protected virtual IComparer get_Comparer();
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
[ComVisibleAttribute("True")]
public abstract class System.ComponentModel.EventDescriptor : MemberDescriptor {
    public Type ComponentType { get; }
    public Type EventType { get; }
    public bool IsMulticast { get; }
    protected EventDescriptor(string name, Attribute[] attrs);
    protected EventDescriptor(MemberDescriptor descr);
    protected EventDescriptor(MemberDescriptor descr, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public abstract virtual Type get_EventType();
    public abstract virtual bool get_IsMulticast();
    public abstract virtual void AddEventHandler(object component, Delegate value);
    public abstract virtual void RemoveEventHandler(object component, Delegate value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.ComponentModel.EventDescriptorCollection : object {
    public static EventDescriptorCollection Empty;
    public int Count { get; }
    public EventDescriptor Item { get; }
    public EventDescriptor Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public EventDescriptorCollection(EventDescriptor[] events);
    public EventDescriptorCollection(EventDescriptor[] events, bool readOnly);
    private static EventDescriptorCollection();
    public int get_Count();
    public virtual EventDescriptor get_Item(int index);
    public virtual EventDescriptor get_Item(string name);
    public int Add(EventDescriptor value);
    public void Clear();
    public bool Contains(EventDescriptor value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual EventDescriptor Find(string name, bool ignoreCase);
    public int IndexOf(EventDescriptor value);
    public void Insert(int index, EventDescriptor value);
    public void Remove(EventDescriptor value);
    public void RemoveAt(int index);
    public IEnumerator GetEnumerator();
    public virtual EventDescriptorCollection Sort();
    public virtual EventDescriptorCollection Sort(String[] names);
    public virtual EventDescriptorCollection Sort(String[] names, IComparer comparer);
    public virtual EventDescriptorCollection Sort(IComparer comparer);
    protected void InternalSort(String[] names);
    protected void InternalSort(IComparer sorter);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.EventHandlerList : object {
    public Delegate Item { get; public set; }
    internal EventHandlerList(Component parent);
    public Delegate get_Item(object key);
    public void set_Item(object key, Delegate value);
    public void AddHandler(object key, Delegate value);
    public void AddHandlers(EventHandlerList listToAddFrom);
    public sealed virtual void Dispose();
    public void RemoveHandler(object key, Delegate value);
}
public class System.ComponentModel.ExpandableObjectConverter : TypeConverter {
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
internal class System.ComponentModel.ExtendedPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public string DisplayName { get; }
    public ExtendedPropertyDescriptor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider, Attribute[] attributes);
    public ExtendedPropertyDescriptor(PropertyDescriptor extender, Attribute[] attributes);
    public virtual bool CanResetValue(object comp);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual string get_DisplayName();
    public virtual object GetValue(object comp);
    public virtual void ResetValue(object comp);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object comp);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ExtenderProvidedPropertyAttribute : Attribute {
    public PropertyDescriptor ExtenderProperty { get; }
    public IExtenderProvider Provider { get; }
    public Type ReceiverType { get; }
    internal static ExtenderProvidedPropertyAttribute Create(PropertyDescriptor extenderProperty, Type receiverType, IExtenderProvider provider);
    public PropertyDescriptor get_ExtenderProperty();
    public IExtenderProvider get_Provider();
    public Type get_ReceiverType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.GuidConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.ComponentModel.HandledEventArgs : EventArgs {
    public bool Handled { get; public set; }
    public HandledEventArgs(bool defaultHandledValue);
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.ComponentModel.HandledEventHandler : MulticastDelegate {
    public HandledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HandledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HandledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.ComponentModel.IBindingList {
    public bool AllowNew { get; }
    public bool AllowEdit { get; }
    public bool AllowRemove { get; }
    public bool SupportsChangeNotification { get; }
    public bool SupportsSearching { get; }
    public bool SupportsSorting { get; }
    public bool IsSorted { get; }
    public PropertyDescriptor SortProperty { get; }
    public ListSortDirection SortDirection { get; }
    public abstract virtual bool get_AllowNew();
    public abstract virtual object AddNew();
    public abstract virtual bool get_AllowEdit();
    public abstract virtual bool get_AllowRemove();
    public abstract virtual bool get_SupportsChangeNotification();
    public abstract virtual bool get_SupportsSearching();
    public abstract virtual bool get_SupportsSorting();
    public abstract virtual bool get_IsSorted();
    public abstract virtual PropertyDescriptor get_SortProperty();
    public abstract virtual ListSortDirection get_SortDirection();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ListChanged(ListChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ListChanged(ListChangedEventHandler value);
    public abstract virtual void AddIndex(PropertyDescriptor property);
    public abstract virtual void ApplySort(PropertyDescriptor property, ListSortDirection direction);
    public abstract virtual int Find(PropertyDescriptor property, object key);
    public abstract virtual void RemoveIndex(PropertyDescriptor property);
    public abstract virtual void RemoveSort();
}
public interface System.ComponentModel.IBindingListView {
    public string Filter { get; public set; }
    public ListSortDescriptionCollection SortDescriptions { get; }
    public bool SupportsAdvancedSorting { get; }
    public bool SupportsFiltering { get; }
    public abstract virtual void ApplySort(ListSortDescriptionCollection sorts);
    public abstract virtual string get_Filter();
    public abstract virtual void set_Filter(string value);
    public abstract virtual ListSortDescriptionCollection get_SortDescriptions();
    public abstract virtual void RemoveFilter();
    public abstract virtual bool get_SupportsAdvancedSorting();
    public abstract virtual bool get_SupportsFiltering();
}
public interface System.ComponentModel.ICancelAddNew {
    public abstract virtual void CancelNew(int itemIndex);
    public abstract virtual void EndNew(int itemIndex);
}
public interface System.ComponentModel.IChangeTracking {
    public bool IsChanged { get; }
    public abstract virtual bool get_IsChanged();
    public abstract virtual void AcceptChanges();
}
[ObsoleteAttribute("This interface has been deprecated. Add a TypeDescriptionProvider to handle type TypeDescriptor.ComObjectType instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public interface System.ComponentModel.IComNativeDescriptorHandler {
    public abstract virtual AttributeCollection GetAttributes(object component);
    public abstract virtual string GetClassName(object component);
    public abstract virtual TypeConverter GetConverter(object component);
    public abstract virtual EventDescriptor GetDefaultEvent(object component);
    public abstract virtual PropertyDescriptor GetDefaultProperty(object component);
    public abstract virtual object GetEditor(object component, Type baseEditorType);
    public abstract virtual string GetName(object component);
    public abstract virtual EventDescriptorCollection GetEvents(object component);
    public abstract virtual EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    public abstract virtual PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public abstract virtual object GetPropertyValue(object component, string propertyName, Boolean& success);
    public abstract virtual object GetPropertyValue(object component, int dispid, Boolean& success);
}
[RootDesignerSerializerAttribute("System.ComponentModel.Design.Serialization.RootCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "True")]
[DesignerAttribute("System.ComponentModel.Design.ComponentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IDesigner")]
[DesignerAttribute("System.Windows.Forms.Design.ComponentDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")]
[TypeConverterAttribute("System.ComponentModel.ComponentConverter")]
[ComVisibleAttribute("True")]
public interface System.ComponentModel.IComponent {
    public ISite Site { get; public set; }
    public abstract virtual ISite get_Site();
    public abstract virtual void set_Site(ISite value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Disposed(EventHandler value);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.IContainer {
    public ComponentCollection Components { get; }
    public abstract virtual void Add(IComponent component);
    public abstract virtual void Add(IComponent component, string name);
    public abstract virtual ComponentCollection get_Components();
    public abstract virtual void Remove(IComponent component);
}
public interface System.ComponentModel.ICustomTypeDescriptor {
    public abstract virtual AttributeCollection GetAttributes();
    public abstract virtual string GetClassName();
    public abstract virtual string GetComponentName();
    public abstract virtual TypeConverter GetConverter();
    public abstract virtual EventDescriptor GetDefaultEvent();
    public abstract virtual PropertyDescriptor GetDefaultProperty();
    public abstract virtual object GetEditor(Type editorBaseType);
    public abstract virtual EventDescriptorCollection GetEvents();
    public abstract virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public abstract virtual PropertyDescriptorCollection GetProperties();
    public abstract virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public abstract virtual object GetPropertyOwner(PropertyDescriptor pd);
}
[DefaultMemberAttribute("Item")]
public interface System.ComponentModel.IDataErrorInfo {
    public string Item { get; }
    public string Error { get; }
    public abstract virtual string get_Item(string columnName);
    public abstract virtual string get_Error();
}
public interface System.ComponentModel.IEditableObject {
    public abstract virtual void BeginEdit();
    public abstract virtual void EndEdit();
    public abstract virtual void CancelEdit();
}
public interface System.ComponentModel.IExtenderProvider {
    public abstract virtual bool CanExtend(object extendee);
}
public interface System.ComponentModel.IIntellisenseBuilder {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool Show(string language, string value, String& newValue);
}
[TypeConverterAttribute("System.Windows.Forms.Design.DataSourceConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[EditorAttribute("System.Windows.Forms.Design.DataSourceListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MergablePropertyAttribute("False")]
public interface System.ComponentModel.IListSource {
    public bool ContainsListCollection { get; }
    public abstract virtual bool get_ContainsListCollection();
    public abstract virtual IList GetList();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ImmutableObjectAttribute : Attribute {
    public static ImmutableObjectAttribute Yes;
    public static ImmutableObjectAttribute No;
    public static ImmutableObjectAttribute Default;
    public bool Immutable { get; }
    public ImmutableObjectAttribute(bool immutable);
    private static ImmutableObjectAttribute();
    public bool get_Immutable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public interface System.ComponentModel.INestedContainer {
    public IComponent Owner { get; }
    public abstract virtual IComponent get_Owner();
}
public interface System.ComponentModel.INestedSite {
    public string FullName { get; }
    public abstract virtual string get_FullName();
}
[AttributeUsageAttribute("896")]
public class System.ComponentModel.InheritanceAttribute : Attribute {
    public static InheritanceAttribute Inherited;
    public static InheritanceAttribute InheritedReadOnly;
    public static InheritanceAttribute NotInherited;
    public static InheritanceAttribute Default;
    public InheritanceLevel InheritanceLevel { get; }
    public InheritanceAttribute(InheritanceLevel inheritanceLevel);
    private static InheritanceAttribute();
    public InheritanceLevel get_InheritanceLevel();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public virtual string ToString();
}
public enum System.ComponentModel.InheritanceLevel : Enum {
    public int value__;
    public static InheritanceLevel Inherited;
    public static InheritanceLevel InheritedReadOnly;
    public static InheritanceLevel NotInherited;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InitializationEventAttribute : Attribute {
    public string EventName { get; }
    public InitializationEventAttribute(string eventName);
    public string get_EventName();
}
public interface System.ComponentModel.INotifyDataErrorInfo {
    public bool HasErrors { get; }
    public abstract virtual bool get_HasErrors();
    public abstract virtual IEnumerable GetErrors(string propertyName);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
}
public interface System.ComponentModel.INotifyPropertyChanged {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
public interface System.ComponentModel.INotifyPropertyChanging {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.InstallerTypeAttribute : Attribute {
    public Type InstallerType { get; }
    public InstallerTypeAttribute(Type installerType);
    public InstallerTypeAttribute(string typeName);
    public virtual Type get_InstallerType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.InstanceCreationEditor : object {
    public string Text { get; }
    public virtual string get_Text();
    public abstract virtual object CreateInstance(ITypeDescriptorContext context, Type instanceType);
}
public class System.ComponentModel.Int16Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.Int32Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.Int64Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
internal static class System.ComponentModel.IntSecurity : object {
    public static CodeAccessPermission UnmanagedCode;
    public static CodeAccessPermission FullReflection;
    private static IntSecurity();
    public static string UnsafeGetFullPath(string fileName);
}
public class System.ComponentModel.InvalidAsynchronousStateException : ArgumentException {
    public InvalidAsynchronousStateException(string message);
    public InvalidAsynchronousStateException(string message, Exception innerException);
    protected InvalidAsynchronousStateException(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.InvalidEnumArgumentException : ArgumentException {
    public InvalidEnumArgumentException(string message);
    public InvalidEnumArgumentException(string message, Exception innerException);
    public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass);
    protected InvalidEnumArgumentException(SerializationInfo info, StreamingContext context);
}
public interface System.ComponentModel.IRaiseItemChangedEvents {
    public bool RaisesItemChangedEvents { get; }
    public abstract virtual bool get_RaisesItemChangedEvents();
}
public interface System.ComponentModel.IRevertibleChangeTracking {
    public abstract virtual void RejectChanges();
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.ISite {
    public IComponent Component { get; }
    public IContainer Container { get; }
    public bool DesignMode { get; }
    public string Name { get; public set; }
    public abstract virtual IComponent get_Component();
    public abstract virtual IContainer get_Container();
    public abstract virtual bool get_DesignMode();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
[SRDescriptionAttribute("ISupportInitializeDescr")]
public interface System.ComponentModel.ISupportInitialize {
    public abstract virtual void BeginInit();
    public abstract virtual void EndInit();
}
public interface System.ComponentModel.ISupportInitializeNotification {
    public bool IsInitialized { get; }
    public abstract virtual bool get_IsInitialized();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Initialized(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Initialized(EventHandler value);
}
public interface System.ComponentModel.ISynchronizeInvoke {
    public bool InvokeRequired { get; }
    public abstract virtual bool get_InvokeRequired();
    public abstract virtual IAsyncResult BeginInvoke(Delegate method, Object[] args);
    public abstract virtual object EndInvoke(IAsyncResult result);
    public abstract virtual object Invoke(Delegate method, Object[] args);
}
[ComVisibleAttribute("True")]
public interface System.ComponentModel.ITypeDescriptorContext {
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public abstract virtual IContainer get_Container();
    public abstract virtual object get_Instance();
    public abstract virtual PropertyDescriptor get_PropertyDescriptor();
    public abstract virtual bool OnComponentChanging();
    public abstract virtual void OnComponentChanged();
}
public interface System.ComponentModel.ITypedList {
    public abstract virtual string GetListName(PropertyDescriptor[] listAccessors);
    public abstract virtual PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
}
public abstract class System.ComponentModel.License : object {
    public string LicenseKey { get; }
    public abstract virtual string get_LicenseKey();
    public abstract virtual void Dispose();
}
public class System.ComponentModel.LicenseContext : object {
    public LicenseUsageMode UsageMode { get; }
    public virtual LicenseUsageMode get_UsageMode();
    public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly);
    public virtual object GetService(Type type);
    public virtual void SetSavedLicenseKey(Type type, string key);
}
public class System.ComponentModel.LicenseException : SystemException {
    public Type LicensedType { get; }
    public LicenseException(Type type);
    public LicenseException(Type type, object instance);
    public LicenseException(Type type, object instance, string message);
    public LicenseException(Type type, object instance, string message, Exception innerException);
    protected LicenseException(SerializationInfo info, StreamingContext context);
    public Type get_LicensedType();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ComponentModel.LicenseManager : object {
    public static LicenseContext CurrentContext { get; public set; }
    public static LicenseUsageMode UsageMode { get; }
    private static LicenseManager();
    public static LicenseContext get_CurrentContext();
    public static void set_CurrentContext(LicenseContext value);
    public static LicenseUsageMode get_UsageMode();
    public static object CreateWithContext(Type type, LicenseContext creationContext);
    public static object CreateWithContext(Type type, LicenseContext creationContext, Object[] args);
    public static bool IsLicensed(Type type);
    public static bool IsValid(Type type);
    public static bool IsValid(Type type, object instance, License& license);
    public static void LockContext(object contextUser);
    public static void UnlockContext(object contextUser);
    public static void Validate(Type type);
    public static License Validate(Type type, object instance);
}
public abstract class System.ComponentModel.LicenseProvider : object {
    public abstract virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LicenseProviderAttribute : Attribute {
    public static LicenseProviderAttribute Default;
    public Type LicenseProvider { get; }
    public object TypeId { get; }
    public LicenseProviderAttribute(string typeName);
    public LicenseProviderAttribute(Type type);
    private static LicenseProviderAttribute();
    public Type get_LicenseProvider();
    public virtual object get_TypeId();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.LicenseUsageMode : Enum {
    public int value__;
    public static LicenseUsageMode Runtime;
    public static LicenseUsageMode Designtime;
}
public class System.ComponentModel.LicFileLicenseProvider : LicenseProvider {
    protected virtual bool IsKeyValid(string key, Type type);
    protected virtual string GetKey(Type type);
    public virtual License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ListBindableAttribute : Attribute {
    public static ListBindableAttribute Yes;
    public static ListBindableAttribute No;
    public static ListBindableAttribute Default;
    public bool ListBindable { get; }
    public ListBindableAttribute(bool listBindable);
    public ListBindableAttribute(BindableSupport flags);
    private static ListBindableAttribute();
    public bool get_ListBindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ListChangedEventArgs : EventArgs {
    public ListChangedType ListChangedType { get; }
    public int NewIndex { get; }
    public int OldIndex { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, PropertyDescriptor propDesc);
    public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, int oldIndex);
    public ListChangedType get_ListChangedType();
    public int get_NewIndex();
    public int get_OldIndex();
    public PropertyDescriptor get_PropertyDescriptor();
}
public class System.ComponentModel.ListChangedEventHandler : MulticastDelegate {
    public ListChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ListChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ListChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.ListChangedType : Enum {
    public int value__;
    public static ListChangedType Reset;
    public static ListChangedType ItemAdded;
    public static ListChangedType ItemDeleted;
    public static ListChangedType ItemMoved;
    public static ListChangedType ItemChanged;
    public static ListChangedType PropertyDescriptorAdded;
    public static ListChangedType PropertyDescriptorDeleted;
    public static ListChangedType PropertyDescriptorChanged;
}
public class System.ComponentModel.ListSortDescription : object {
    public PropertyDescriptor PropertyDescriptor { get; public set; }
    public ListSortDirection SortDirection { get; public set; }
    public ListSortDescription(PropertyDescriptor property, ListSortDirection direction);
    public PropertyDescriptor get_PropertyDescriptor();
    public void set_PropertyDescriptor(PropertyDescriptor value);
    public ListSortDirection get_SortDirection();
    public void set_SortDirection(ListSortDirection value);
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.ListSortDescriptionCollection : object {
    public ListSortDescription Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ListSortDescriptionCollection(ListSortDescription[] sorts);
    public ListSortDescription get_Item(int index);
    public void set_Item(int index, ListSortDescription value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum System.ComponentModel.ListSortDirection : Enum {
    public int value__;
    public static ListSortDirection Ascending;
    public static ListSortDirection Descending;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.LocalizableAttribute : Attribute {
    public static LocalizableAttribute Yes;
    public static LocalizableAttribute No;
    public static LocalizableAttribute Default;
    public bool IsLocalizable { get; }
    public LocalizableAttribute(bool isLocalizable);
    private static LocalizableAttribute();
    public bool get_IsLocalizable();
    public virtual bool IsDefaultAttribute();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.LookupBindingPropertiesAttribute : Attribute {
    public static LookupBindingPropertiesAttribute Default;
    public string DataSource { get; }
    public string DisplayMember { get; }
    public string ValueMember { get; }
    public string LookupMember { get; }
    public LookupBindingPropertiesAttribute(string dataSource, string displayMember, string valueMember, string lookupMember);
    private static LookupBindingPropertiesAttribute();
    public string get_DataSource();
    public string get_DisplayMember();
    public string get_ValueMember();
    public string get_LookupMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
[DesignerAttribute("System.Windows.Forms.Design.ComponentDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")]
[DesignerCategoryAttribute("Component")]
[TypeConverterAttribute("System.ComponentModel.ComponentConverter")]
public class System.ComponentModel.MarshalByValueComponent : object {
    protected EventHandlerList Events { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IContainer Container { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool DesignMode { get; }
    private static MarshalByValueComponent();
    protected virtual override void Finalize();
    public sealed virtual void add_Disposed(EventHandler value);
    public sealed virtual void remove_Disposed(EventHandler value);
    protected EventHandlerList get_Events();
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual IContainer get_Container();
    public virtual object GetService(Type service);
    public virtual bool get_DesignMode();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.MaskedTextProvider : object {
    public bool AllowPromptAsInput { get; }
    public int AssignedEditPositionCount { get; }
    public int AvailableEditPositionCount { get; }
    public CultureInfo Culture { get; }
    public static char DefaultPasswordChar { get; }
    public int EditPositionCount { get; }
    public IEnumerator EditPositions { get; }
    public bool IncludeLiterals { get; public set; }
    public bool IncludePrompt { get; public set; }
    public bool AsciiOnly { get; }
    public bool IsPassword { get; public set; }
    public static int InvalidIndex { get; }
    public int LastAssignedPosition { get; }
    public int Length { get; }
    public string Mask { get; }
    public bool MaskCompleted { get; }
    public bool MaskFull { get; }
    public char PasswordChar { get; public set; }
    public char PromptChar { get; public set; }
    public bool ResetOnPrompt { get; public set; }
    public bool ResetOnSpace { get; public set; }
    public bool SkipLiterals { get; public set; }
    public char Item { get; }
    public MaskedTextProvider(string mask);
    public MaskedTextProvider(string mask, bool restrictToAscii);
    public MaskedTextProvider(string mask, CultureInfo culture);
    public MaskedTextProvider(string mask, CultureInfo culture, bool restrictToAscii);
    public MaskedTextProvider(string mask, char passwordChar, bool allowPromptAsInput);
    public MaskedTextProvider(string mask, CultureInfo culture, char passwordChar, bool allowPromptAsInput);
    public MaskedTextProvider(string mask, CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);
    private static MaskedTextProvider();
    public bool get_AllowPromptAsInput();
    public int get_AssignedEditPositionCount();
    public int get_AvailableEditPositionCount();
    public sealed virtual object Clone();
    public CultureInfo get_Culture();
    public static char get_DefaultPasswordChar();
    public int get_EditPositionCount();
    public IEnumerator get_EditPositions();
    public bool get_IncludeLiterals();
    public void set_IncludeLiterals(bool value);
    public bool get_IncludePrompt();
    public void set_IncludePrompt(bool value);
    public bool get_AsciiOnly();
    public bool get_IsPassword();
    public void set_IsPassword(bool value);
    public static int get_InvalidIndex();
    public int get_LastAssignedPosition();
    public int get_Length();
    public string get_Mask();
    public bool get_MaskCompleted();
    public bool get_MaskFull();
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    public char get_PromptChar();
    public void set_PromptChar(char value);
    public bool get_ResetOnPrompt();
    public void set_ResetOnPrompt(bool value);
    public bool get_ResetOnSpace();
    public void set_ResetOnSpace(bool value);
    public bool get_SkipLiterals();
    public void set_SkipLiterals(bool value);
    public char get_Item(int index);
    public bool Add(char input);
    public bool Add(char input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Add(string input);
    public bool Add(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public void Clear();
    public void Clear(MaskedTextResultHint& resultHint);
    public int FindAssignedEditPositionFrom(int position, bool direction);
    public int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindEditPositionFrom(int position, bool direction);
    public int FindEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindNonEditPositionFrom(int position, bool direction);
    public int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);
    public int FindUnassignedEditPositionFrom(int position, bool direction);
    public int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);
    public static bool GetOperationResultFromHint(MaskedTextResultHint hint);
    public bool InsertAt(char input, int position);
    public bool InsertAt(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool InsertAt(string input, int position);
    public bool InsertAt(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool IsAvailablePosition(int position);
    public bool IsEditPosition(int position);
    public static bool IsValidInputChar(char c);
    public static bool IsValidMaskChar(char c);
    public static bool IsValidPasswordChar(char c);
    public bool Remove();
    public bool Remove(Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool RemoveAt(int position);
    public bool RemoveAt(int startPosition, int endPosition);
    public bool RemoveAt(int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(char input, int position);
    public bool Replace(char input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(char input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int position);
    public bool Replace(string input, int position, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Replace(string input, int startPosition, int endPosition, Int32& testPosition, MaskedTextResultHint& resultHint);
    public bool Set(string input);
    public bool Set(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
    public string ToDisplayString();
    public virtual string ToString();
    public string ToString(bool ignorePasswordChar);
    public string ToString(int startPosition, int length);
    public string ToString(bool ignorePasswordChar, int startPosition, int length);
    public string ToString(bool includePrompt, bool includeLiterals);
    public string ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);
    public string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);
    public bool VerifyChar(char input, int position, MaskedTextResultHint& hint);
    public bool VerifyEscapeChar(char input, int position);
    public bool VerifyString(string input);
    public bool VerifyString(string input, Int32& testPosition, MaskedTextResultHint& resultHint);
}
public enum System.ComponentModel.MaskedTextResultHint : Enum {
    public int value__;
    public static MaskedTextResultHint Unknown;
    public static MaskedTextResultHint CharacterEscaped;
    public static MaskedTextResultHint NoEffect;
    public static MaskedTextResultHint SideEffect;
    public static MaskedTextResultHint Success;
    public static MaskedTextResultHint AsciiCharacterExpected;
    public static MaskedTextResultHint AlphanumericCharacterExpected;
    public static MaskedTextResultHint DigitExpected;
    public static MaskedTextResultHint LetterExpected;
    public static MaskedTextResultHint SignedDigitExpected;
    public static MaskedTextResultHint InvalidInput;
    public static MaskedTextResultHint PromptCharNotAllowed;
    public static MaskedTextResultHint UnavailableEditPosition;
    public static MaskedTextResultHint NonEditPosition;
    public static MaskedTextResultHint PositionOutOfRange;
}
[ComVisibleAttribute("True")]
public abstract class System.ComponentModel.MemberDescriptor : object {
    protected Attribute[] AttributeArray { get; protected set; }
    public AttributeCollection Attributes { get; }
    public string Category { get; }
    public string Description { get; }
    public bool IsBrowsable { get; }
    public string Name { get; }
    protected int NameHashCode { get; }
    public bool DesignTimeOnly { get; }
    public string DisplayName { get; }
    protected MemberDescriptor(string name);
    protected MemberDescriptor(string name, Attribute[] attributes);
    protected MemberDescriptor(MemberDescriptor descr);
    protected MemberDescriptor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes);
    protected virtual Attribute[] get_AttributeArray();
    protected virtual void set_AttributeArray(Attribute[] value);
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Category();
    public virtual string get_Description();
    public virtual bool get_IsBrowsable();
    public virtual string get_Name();
    protected virtual int get_NameHashCode();
    public virtual bool get_DesignTimeOnly();
    public virtual string get_DisplayName();
    protected virtual AttributeCollection CreateAttributeCollection();
    public virtual bool Equals(object obj);
    protected virtual void FillAttributes(IList attributeList);
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType);
    protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    protected static ISite GetSite(object component);
    [ObsoleteAttribute("This method has been deprecated. Use GetInvocationTarget instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected static object GetInvokee(Type componentClass, object component);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.MergablePropertyAttribute : Attribute {
    public static MergablePropertyAttribute Yes;
    public static MergablePropertyAttribute No;
    public static MergablePropertyAttribute Default;
    public bool AllowMerge { get; }
    public MergablePropertyAttribute(bool allowMerge);
    private static MergablePropertyAttribute();
    public bool get_AllowMerge();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.MultilineStringConverter : TypeConverter {
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.NestedContainer : Container {
    public IComponent Owner { get; }
    protected string OwnerName { get; }
    public NestedContainer(IComponent owner);
    public sealed virtual IComponent get_Owner();
    protected virtual string get_OwnerName();
    protected virtual ISite CreateSite(IComponent component, string name);
    protected virtual void Dispose(bool disposing);
    protected virtual object GetService(Type service);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.NotifyParentPropertyAttribute : Attribute {
    public static NotifyParentPropertyAttribute Yes;
    public static NotifyParentPropertyAttribute No;
    public static NotifyParentPropertyAttribute Default;
    public bool NotifyParent { get; }
    public NotifyParentPropertyAttribute(bool notifyParent);
    private static NotifyParentPropertyAttribute();
    public bool get_NotifyParent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.NullableConverter : TypeConverter {
    public Type NullableType { get; }
    public Type UnderlyingType { get; }
    public TypeConverter UnderlyingTypeConverter { get; }
    public NullableConverter(Type type);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
    public Type get_NullableType();
    public Type get_UnderlyingType();
    public TypeConverter get_UnderlyingTypeConverter();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ParenthesizePropertyNameAttribute : Attribute {
    public static ParenthesizePropertyNameAttribute Default;
    public bool NeedParenthesis { get; }
    public ParenthesizePropertyNameAttribute(bool needParenthesis);
    private static ParenthesizePropertyNameAttribute();
    public bool get_NeedParenthesis();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PasswordPropertyTextAttribute : Attribute {
    public static PasswordPropertyTextAttribute Yes;
    public static PasswordPropertyTextAttribute No;
    public static PasswordPropertyTextAttribute Default;
    public bool Password { get; }
    public PasswordPropertyTextAttribute(bool password);
    private static PasswordPropertyTextAttribute();
    public bool get_Password();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ProgressChangedEventArgs : EventArgs {
    [SRDescriptionAttribute("Async_ProgressChangedEventArgs_ProgressPercentage")]
public int ProgressPercentage { get; }
    [SRDescriptionAttribute("Async_ProgressChangedEventArgs_UserState")]
public object UserState { get; }
    public ProgressChangedEventArgs(int progressPercentage, object userState);
    public int get_ProgressPercentage();
    public object get_UserState();
}
public class System.ComponentModel.ProgressChangedEventHandler : MulticastDelegate {
    public ProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangedEventArgs : EventArgs {
    public string PropertyName { get; }
    public PropertyChangedEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangedEventHandler : MulticastDelegate {
    public PropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.PropertyChangingEventArgs : EventArgs {
    public string PropertyName { get; }
    public PropertyChangingEventArgs(string propertyName);
    public virtual string get_PropertyName();
}
public class System.ComponentModel.PropertyChangingEventHandler : MulticastDelegate {
    public PropertyChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public abstract class System.ComponentModel.PropertyDescriptor : MemberDescriptor {
    public Type ComponentType { get; }
    public TypeConverter Converter { get; }
    public bool IsLocalizable { get; }
    public bool IsReadOnly { get; }
    public DesignerSerializationVisibility SerializationVisibility { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    protected PropertyDescriptor(string name, Attribute[] attrs);
    protected PropertyDescriptor(MemberDescriptor descr);
    protected PropertyDescriptor(MemberDescriptor descr, Attribute[] attrs);
    public abstract virtual Type get_ComponentType();
    public virtual TypeConverter get_Converter();
    public virtual bool get_IsLocalizable();
    public abstract virtual bool get_IsReadOnly();
    public DesignerSerializationVisibility get_SerializationVisibility();
    public abstract virtual Type get_PropertyType();
    public virtual void AddValueChanged(object component, EventHandler handler);
    public abstract virtual bool CanResetValue(object component);
    public virtual bool Equals(object obj);
    protected object CreateInstance(Type type);
    protected virtual void FillAttributes(IList attributeList);
    public PropertyDescriptorCollection GetChildProperties();
    public PropertyDescriptorCollection GetChildProperties(Attribute[] filter);
    public PropertyDescriptorCollection GetChildProperties(object instance);
    public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
    public virtual object GetEditor(Type editorBaseType);
    public virtual int GetHashCode();
    protected virtual object GetInvocationTarget(Type type, object instance);
    protected Type GetTypeFromName(string typeName);
    public abstract virtual object GetValue(object component);
    protected virtual void OnValueChanged(object component, EventArgs e);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    protected internal EventHandler GetValueChangedHandler(object component);
    public abstract virtual void ResetValue(object component);
    public abstract virtual void SetValue(object component, object value);
    public abstract virtual bool ShouldSerializeValue(object component);
    public virtual bool get_SupportsChangeEvents();
}
[DefaultMemberAttribute("Item")]
public class System.ComponentModel.PropertyDescriptorCollection : object {
    public static PropertyDescriptorCollection Empty;
    public int Count { get; }
    public PropertyDescriptor Item { get; }
    public PropertyDescriptor Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PropertyDescriptorCollection(PropertyDescriptor[] properties);
    public PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly);
    private static PropertyDescriptorCollection();
    public int get_Count();
    public virtual PropertyDescriptor get_Item(int index);
    public virtual PropertyDescriptor get_Item(string name);
    public int Add(PropertyDescriptor value);
    public void Clear();
    public bool Contains(PropertyDescriptor value);
    public sealed virtual void CopyTo(Array array, int index);
    public virtual PropertyDescriptor Find(string name, bool ignoreCase);
    public int IndexOf(PropertyDescriptor value);
    public void Insert(int index, PropertyDescriptor value);
    public void Remove(PropertyDescriptor value);
    public void RemoveAt(int index);
    public virtual PropertyDescriptorCollection Sort();
    public virtual PropertyDescriptorCollection Sort(String[] names);
    public virtual PropertyDescriptorCollection Sort(String[] names, IComparer comparer);
    public virtual PropertyDescriptorCollection Sort(IComparer comparer);
    protected void InternalSort(String[] names);
    protected void InternalSort(IComparer sorter);
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.PropertyTabAttribute : Attribute {
    public Type[] TabClasses { get; }
    protected String[] TabClassNames { get; }
    public PropertyTabScope[] TabScopes { get; }
    public PropertyTabAttribute(Type tabClass);
    public PropertyTabAttribute(string tabClassName);
    public PropertyTabAttribute(Type tabClass, PropertyTabScope tabScope);
    public PropertyTabAttribute(string tabClassName, PropertyTabScope tabScope);
    public Type[] get_TabClasses();
    protected String[] get_TabClassNames();
    public PropertyTabScope[] get_TabScopes();
    public virtual bool Equals(object other);
    public bool Equals(PropertyTabAttribute other);
    public virtual int GetHashCode();
    protected void InitializeArrays(String[] tabClassNames, PropertyTabScope[] tabScopes);
    protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes);
}
public enum System.ComponentModel.PropertyTabScope : Enum {
    public int value__;
    public static PropertyTabScope Static;
    public static PropertyTabScope Global;
    public static PropertyTabScope Document;
    public static PropertyTabScope Component;
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ProvidePropertyAttribute : Attribute {
    public string PropertyName { get; }
    public string ReceiverTypeName { get; }
    public object TypeId { get; }
    public ProvidePropertyAttribute(string propertyName, Type receiverType);
    public ProvidePropertyAttribute(string propertyName, string receiverTypeName);
    public string get_PropertyName();
    public string get_ReceiverTypeName();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ReadOnlyAttribute : Attribute {
    public static ReadOnlyAttribute Yes;
    public static ReadOnlyAttribute No;
    public static ReadOnlyAttribute Default;
    public bool IsReadOnly { get; }
    public ReadOnlyAttribute(bool isReadOnly);
    private static ReadOnlyAttribute();
    public bool get_IsReadOnly();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("128")]
[ObsoleteAttribute("Use System.ComponentModel.SettingsBindableAttribute instead to work with the new settings model.")]
public class System.ComponentModel.RecommendedAsConfigurableAttribute : Attribute {
    public static RecommendedAsConfigurableAttribute No;
    public static RecommendedAsConfigurableAttribute Yes;
    public static RecommendedAsConfigurableAttribute Default;
    public bool RecommendedAsConfigurable { get; }
    public RecommendedAsConfigurableAttribute(bool recommendedAsConfigurable);
    private static RecommendedAsConfigurableAttribute();
    public bool get_RecommendedAsConfigurable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.ReferenceConverter : TypeConverter {
    public ReferenceConverter(Type type);
    private static ReferenceConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value);
}
internal class System.ComponentModel.ReflectEventDescriptor : EventDescriptor {
    public Type ComponentType { get; }
    public Type EventType { get; }
    public bool IsMulticast { get; }
    public ReflectEventDescriptor(Type componentClass, string name, Type type, Attribute[] attributes);
    public ReflectEventDescriptor(Type componentClass, EventInfo eventInfo);
    public ReflectEventDescriptor(Type componentType, EventDescriptor oldReflectEventDescriptor, Attribute[] attributes);
    private static ReflectEventDescriptor();
    public virtual Type get_ComponentType();
    public virtual Type get_EventType();
    public virtual bool get_IsMulticast();
    public virtual void AddEventHandler(object component, Delegate value);
    protected virtual void FillAttributes(IList attributes);
    public virtual void RemoveEventHandler(object component, Delegate value);
}
internal class System.ComponentModel.ReflectPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public bool SupportsChangeEvents { get; }
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, Attribute[] attributes);
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, PropertyInfo propInfo, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs);
    public ReflectPropertyDescriptor(Type componentClass, string name, Type type, Type receiverType, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs);
    public ReflectPropertyDescriptor(Type componentClass, PropertyDescriptor oldReflectPropertyDescriptor, Attribute[] attributes);
    private static ReflectPropertyDescriptor();
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual void AddValueChanged(object component, EventHandler handler);
    internal bool ExtenderCanResetValue(IExtenderProvider provider, object component);
    internal Type ExtenderGetReceiverType();
    internal Type ExtenderGetType(IExtenderProvider provider);
    internal object ExtenderGetValue(IExtenderProvider provider, object component);
    internal void ExtenderResetValue(IExtenderProvider provider, object component, PropertyDescriptor notifyDesc);
    internal void ExtenderSetValue(IExtenderProvider provider, object component, object value, PropertyDescriptor notifyDesc);
    internal bool ExtenderShouldSerializeValue(IExtenderProvider provider, object component);
    public virtual bool CanResetValue(object component);
    protected virtual void FillAttributes(IList attributes);
    public virtual object GetValue(object component);
    internal void OnINotifyPropertyChanged(object component, PropertyChangedEventArgs e);
    protected virtual void OnValueChanged(object component, EventArgs e);
    public virtual void RemoveValueChanged(object component, EventHandler handler);
    public virtual void ResetValue(object component);
    public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual bool get_SupportsChangeEvents();
}
internal class System.ComponentModel.ReflectTypeDescriptionProvider : TypeDescriptionProvider {
    internal static Guid ExtenderProviderKey { get; }
    private static ReflectTypeDescriptionProvider();
    internal static Guid get_ExtenderProviderKey();
    internal static void AddEditorTable(Type editorBaseType, Hashtable table);
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    internal AttributeCollection GetAttributes(Type type);
    public virtual IDictionary GetCache(object instance);
    internal string GetClassName(Type type);
    internal string GetComponentName(Type type, object instance);
    internal TypeConverter GetConverter(Type type, object instance);
    internal EventDescriptor GetDefaultEvent(Type type, object instance);
    internal PropertyDescriptor GetDefaultProperty(Type type, object instance);
    internal object GetEditor(Type type, object instance, Type editorBaseType);
    internal EventDescriptorCollection GetEvents(Type type);
    internal AttributeCollection GetExtendedAttributes(object instance);
    internal string GetExtendedClassName(object instance);
    internal string GetExtendedComponentName(object instance);
    internal TypeConverter GetExtendedConverter(object instance);
    internal EventDescriptor GetExtendedDefaultEvent(object instance);
    internal PropertyDescriptor GetExtendedDefaultProperty(object instance);
    internal object GetExtendedEditor(object instance, Type editorBaseType);
    internal EventDescriptorCollection GetExtendedEvents(object instance);
    internal PropertyDescriptorCollection GetExtendedProperties(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    internal object GetExtendedPropertyOwner(object instance, PropertyDescriptor pd);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    public virtual string GetFullComponentName(object component);
    internal Type[] GetPopulatedTypes(Module module);
    internal PropertyDescriptorCollection GetProperties(Type type);
    internal object GetPropertyOwner(Type type, object instance, PropertyDescriptor pd);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    internal bool IsPopulated(Type type);
    internal static Attribute[] ReflectGetAttributes(MemberInfo member);
    internal void Refresh(Type type);
}
public class System.ComponentModel.RefreshEventArgs : EventArgs {
    public object ComponentChanged { get; }
    public Type TypeChanged { get; }
    public RefreshEventArgs(object componentChanged);
    public RefreshEventArgs(Type typeChanged);
    public object get_ComponentChanged();
    public Type get_TypeChanged();
}
public class System.ComponentModel.RefreshEventHandler : MulticastDelegate {
    public RefreshEventHandler(object object, IntPtr method);
    public virtual void Invoke(RefreshEventArgs e);
    public virtual IAsyncResult BeginInvoke(RefreshEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ComponentModel.RefreshProperties : Enum {
    public int value__;
    public static RefreshProperties None;
    public static RefreshProperties All;
    public static RefreshProperties Repaint;
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.RefreshPropertiesAttribute : Attribute {
    public static RefreshPropertiesAttribute All;
    public static RefreshPropertiesAttribute Repaint;
    public static RefreshPropertiesAttribute Default;
    public RefreshProperties RefreshProperties { get; }
    public RefreshPropertiesAttribute(RefreshProperties refresh);
    private static RefreshPropertiesAttribute();
    public RefreshProperties get_RefreshProperties();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.RunInstallerAttribute : Attribute {
    public static RunInstallerAttribute Yes;
    public static RunInstallerAttribute No;
    public static RunInstallerAttribute Default;
    public bool RunInstaller { get; }
    public RunInstallerAttribute(bool runInstaller);
    private static RunInstallerAttribute();
    public bool get_RunInstaller();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
}
public class System.ComponentModel.RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
    public object Result { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public object UserState { get; }
    public RunWorkerCompletedEventArgs(object result, Exception error, bool cancelled);
    public object get_Result();
    public object get_UserState();
}
public class System.ComponentModel.RunWorkerCompletedEventHandler : MulticastDelegate {
    public RunWorkerCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RunWorkerCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RunWorkerCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.ComponentModel.SByteConverter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
[AttributeUsageAttribute("128")]
public class System.ComponentModel.SettingsBindableAttribute : Attribute {
    public static SettingsBindableAttribute Yes;
    public static SettingsBindableAttribute No;
    public bool Bindable { get; }
    public SettingsBindableAttribute(bool bindable);
    private static SettingsBindableAttribute();
    public bool get_Bindable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.ComponentModel.SingleConverter : BaseNumberConverter {
    internal bool AllowHex { get; }
    internal Type TargetType { get; }
    internal virtual bool get_AllowHex();
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.StringConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public static class System.ComponentModel.SyntaxCheck : object {
    public static bool CheckMachineName(string value);
    public static bool CheckPath(string value);
    public static bool CheckRootedPath(string value);
}
public class System.ComponentModel.TimeSpanConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.ToolboxItemAttribute : Attribute {
    public static ToolboxItemAttribute Default;
    public static ToolboxItemAttribute None;
    public Type ToolboxItemType { get; }
    public string ToolboxItemTypeName { get; }
    public ToolboxItemAttribute(bool defaultType);
    public ToolboxItemAttribute(string toolboxItemTypeName);
    public ToolboxItemAttribute(Type toolboxItemType);
    private static ToolboxItemAttribute();
    public virtual bool IsDefaultAttribute();
    public Type get_ToolboxItemType();
    public string get_ToolboxItemTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.ToolboxItemFilterAttribute : Attribute {
    public string FilterString { get; }
    public ToolboxItemFilterType FilterType { get; }
    public object TypeId { get; }
    public ToolboxItemFilterAttribute(string filterString);
    public ToolboxItemFilterAttribute(string filterString, ToolboxItemFilterType filterType);
    public string get_FilterString();
    public ToolboxItemFilterType get_FilterType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool Match(object obj);
    public virtual string ToString();
}
public enum System.ComponentModel.ToolboxItemFilterType : Enum {
    public int value__;
    public static ToolboxItemFilterType Allow;
    public static ToolboxItemFilterType Custom;
    public static ToolboxItemFilterType Prevent;
    public static ToolboxItemFilterType Require;
}
[ComVisibleAttribute("True")]
public class System.ComponentModel.TypeConverter : object {
    private static TypeConverter();
    public bool CanConvertFrom(Type sourceType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public bool CanConvertTo(Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public object ConvertFrom(object value);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public object ConvertFromInvariantString(string text);
    public object ConvertFromInvariantString(ITypeDescriptorContext context, string text);
    public object ConvertFromString(string text);
    public object ConvertFromString(ITypeDescriptorContext context, string text);
    public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text);
    public object ConvertTo(object value, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public string ConvertToInvariantString(object value);
    public string ConvertToInvariantString(ITypeDescriptorContext context, object value);
    public string ConvertToString(object value);
    public string ConvertToString(ITypeDescriptorContext context, object value);
    public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value);
    public object CreateInstance(IDictionary propertyValues);
    public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
    protected Exception GetConvertFromException(object value);
    protected Exception GetConvertToException(object value, Type destinationType);
    public bool GetCreateInstanceSupported();
    public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
    public PropertyDescriptorCollection GetProperties(object value);
    public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value);
    public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
    public bool GetPropertiesSupported();
    public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
    public ICollection GetStandardValues();
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public bool GetStandardValuesExclusive();
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public bool GetStandardValuesSupported();
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public bool IsValid(object value);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
    protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, String[] names);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.TypeConverterAttribute : Attribute {
    public static TypeConverterAttribute Default;
    public string ConverterTypeName { get; }
    public TypeConverterAttribute(Type type);
    public TypeConverterAttribute(string typeName);
    private static TypeConverterAttribute();
    public string get_ConverterTypeName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.ComponentModel.TypeDescriptionProvider : object {
    protected TypeDescriptionProvider(TypeDescriptionProvider parent);
    public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public virtual IDictionary GetCache(object instance);
    public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
    protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
    public virtual string GetFullComponentName(object component);
    public Type GetReflectionType(Type objectType);
    public Type GetReflectionType(object instance);
    public virtual Type GetReflectionType(Type objectType, object instance);
    public virtual Type GetRuntimeType(Type reflectionType);
    public ICustomTypeDescriptor GetTypeDescriptor(Type objectType);
    public ICustomTypeDescriptor GetTypeDescriptor(object instance);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
    public virtual bool IsSupportedType(Type type);
}
[AttributeUsageAttribute("4")]
public class System.ComponentModel.TypeDescriptionProviderAttribute : Attribute {
    public string TypeName { get; }
    public TypeDescriptionProviderAttribute(string typeName);
    public TypeDescriptionProviderAttribute(Type type);
    public string get_TypeName();
}
public class System.ComponentModel.TypeDescriptor : object {
    [ObsoleteAttribute("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static IComNativeDescriptorHandler ComNativeDescriptorHandler { get; public set; }
    [EditorBrowsableAttribute("2")]
public static Type ComObjectType { get; }
    [EditorBrowsableAttribute("2")]
public static Type InterfaceType { get; }
    internal static int MetadataVersion { get; }
    private static TypeDescriptor();
    public static IComNativeDescriptorHandler get_ComNativeDescriptorHandler();
    public static void set_ComNativeDescriptorHandler(IComNativeDescriptorHandler value);
    public static Type get_ComObjectType();
    public static Type get_InterfaceType();
    internal static int get_MetadataVersion();
    [CompilerGeneratedAttribute]
public static void add_Refreshed(RefreshEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Refreshed(RefreshEventHandler value);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(Type type, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider AddAttributes(object instance, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static void AddEditorTable(Type editorBaseType, Hashtable table);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void AddProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void CreateAssociation(object primary, object secondary);
    public static IDesigner CreateDesigner(IComponent component, Type designerBaseType);
    public static EventDescriptor CreateEvent(Type componentType, string name, Type type, Attribute[] attributes);
    public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, Attribute[] attributes);
    public static object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, Object[] args);
    public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, Attribute[] attributes);
    public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static object GetAssociation(Type type, object primary);
    public static AttributeCollection GetAttributes(Type componentType);
    public static AttributeCollection GetAttributes(object component);
    [EditorBrowsableAttribute("2")]
public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc);
    internal static IDictionary GetCache(object instance);
    public static string GetClassName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetClassName(object component, bool noCustomTypeDesc);
    public static string GetClassName(Type componentType);
    public static string GetComponentName(object component);
    [EditorBrowsableAttribute("2")]
public static string GetComponentName(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(object component);
    [EditorBrowsableAttribute("2")]
public static TypeConverter GetConverter(object component, bool noCustomTypeDesc);
    public static TypeConverter GetConverter(Type type);
    public static EventDescriptor GetDefaultEvent(Type componentType);
    public static EventDescriptor GetDefaultEvent(object component);
    [EditorBrowsableAttribute("2")]
public static EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc);
    public static PropertyDescriptor GetDefaultProperty(Type componentType);
    public static PropertyDescriptor GetDefaultProperty(object component);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc);
    internal static ICustomTypeDescriptor GetDescriptor(Type type, string typeName);
    internal static ICustomTypeDescriptor GetDescriptor(object component, bool noCustomTypeDesc);
    internal static ICustomTypeDescriptor GetExtendedDescriptor(object component);
    public static object GetEditor(object component, Type editorBaseType);
    [EditorBrowsableAttribute("2")]
public static object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc);
    public static object GetEditor(Type type, Type editorBaseType);
    public static EventDescriptorCollection GetEvents(Type componentType);
    public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes);
    public static EventDescriptorCollection GetEvents(object component);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc);
    public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
    [EditorBrowsableAttribute("2")]
public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc);
    public static string GetFullComponentName(object component);
    public static PropertyDescriptorCollection GetProperties(Type componentType);
    public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes);
    public static PropertyDescriptorCollection GetProperties(object component);
    [EditorBrowsableAttribute("2")]
public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
    public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(Type type);
    [EditorBrowsableAttribute("2")]
public static TypeDescriptionProvider GetProvider(object instance);
    internal static TypeDescriptionProvider GetProviderRecursive(Type type);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(Type type);
    [EditorBrowsableAttribute("2")]
public static Type GetReflectionType(object instance);
    public static void Refresh(object component);
    public static void Refresh(Type type);
    public static void Refresh(Module module);
    public static void Refresh(Assembly assembly);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociation(object primary, object secondary);
    [EditorBrowsableAttribute("2")]
public static void RemoveAssociations(object primary);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveProvider(TypeDescriptionProvider provider, object instance);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type);
    [EditorBrowsableAttribute("2")]
public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance);
    public static void SortDescriptorArray(IList infos);
    [ConditionalAttribute("DEBUG")]
internal static void Trace(string message, Object[] args);
}
public abstract class System.ComponentModel.TypeListConverter : TypeConverter {
    protected TypeListConverter(Type[] types);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
public class System.ComponentModel.UInt16Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.UInt32Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.UInt64Converter : BaseNumberConverter {
    internal Type TargetType { get; }
    internal virtual Type get_TargetType();
    internal virtual object FromString(string value, int radix);
    internal virtual object FromString(string value, NumberFormatInfo formatInfo);
    internal virtual object FromString(string value, CultureInfo culture);
    internal virtual string ToString(object value, NumberFormatInfo formatInfo);
}
public class System.ComponentModel.WarningException : SystemException {
    public string HelpUrl { get; }
    public string HelpTopic { get; }
    public WarningException(string message);
    public WarningException(string message, string helpUrl);
    public WarningException(string message, Exception innerException);
    public WarningException(string message, string helpUrl, string helpTopic);
    protected WarningException(SerializationInfo info, StreamingContext context);
    public string get_HelpUrl();
    public string get_HelpTopic();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.ComponentModel.WeakHashtable : Hashtable {
    private static WeakHashtable();
    public virtual void Clear();
    public virtual void Remove(object key);
    public void SetWeak(object key, object value);
}
[SuppressUnmanagedCodeSecurityAttribute]
public class System.ComponentModel.Win32Exception : ExternalException {
    public int NativeErrorCode { get; }
    public Win32Exception(int error);
    public Win32Exception(int error, string message);
    public Win32Exception(string message);
    public Win32Exception(string message, Exception innerException);
    protected Win32Exception(SerializationInfo info, StreamingContext context);
    public int get_NativeErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("128")]
public class System.Configuration.ApplicationScopedSettingAttribute : SettingAttribute {
}
[DefaultMemberAttribute("Item")]
public abstract class System.Configuration.ApplicationSettingsBase : SettingsBase {
    [BrowsableAttribute("False")]
public SettingsContext Context { get; }
    [BrowsableAttribute("False")]
public SettingsPropertyCollection Properties { get; }
    [BrowsableAttribute("False")]
public SettingsPropertyValueCollection PropertyValues { get; }
    [BrowsableAttribute("False")]
public SettingsProviderCollection Providers { get; }
    [BrowsableAttribute("False")]
public string SettingsKey { get; public set; }
    public object Item { get; public set; }
    protected ApplicationSettingsBase(IComponent owner);
    protected ApplicationSettingsBase(string settingsKey);
    protected ApplicationSettingsBase(IComponent owner, string settingsKey);
    public virtual SettingsContext get_Context();
    public virtual SettingsPropertyCollection get_Properties();
    public virtual SettingsPropertyValueCollection get_PropertyValues();
    public virtual SettingsProviderCollection get_Providers();
    public string get_SettingsKey();
    public void set_SettingsKey(string value);
    public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public void add_SettingChanging(SettingChangingEventHandler value);
    public void remove_SettingChanging(SettingChangingEventHandler value);
    public void add_SettingsLoaded(SettingsLoadedEventHandler value);
    public void remove_SettingsLoaded(SettingsLoadedEventHandler value);
    public void add_SettingsSaving(SettingsSavingEventHandler value);
    public void remove_SettingsSaving(SettingsSavingEventHandler value);
    public object GetPreviousVersion(string propertyName);
    protected virtual void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    protected virtual void OnSettingChanging(object sender, SettingChangingEventArgs e);
    protected virtual void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e);
    protected virtual void OnSettingsSaving(object sender, CancelEventArgs e);
    public void Reload();
    public void Reset();
    public virtual void Save();
    public virtual object get_Item(string propertyName);
    public virtual void set_Item(string propertyName, object value);
    public virtual void Upgrade();
    internal static bool IsClickOnceDeployed(AppDomain appDomain);
}
public class System.Configuration.ApplicationSettingsGroup : ConfigurationSectionGroup {
}
public class System.Configuration.AppSettingsReader : object {
    private static AppSettingsReader();
    public object GetValue(string key, Type type);
}
public class System.Configuration.ClientSettingsSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public SettingElementCollection Settings { get; }
    private static ClientSettingsSection();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SettingElementCollection get_Settings();
}
internal class System.Configuration.ClientSettingsStore : object {
    internal IDictionary ReadSettings(string sectionName, bool isUserScoped);
    internal static IDictionary ReadSettingsFromFile(string configFileName, string sectionName, bool isUserScoped);
    internal ConnectionStringSettingsCollection ReadConnectionStrings();
    internal void RevertToParent(string sectionName, bool isRoaming);
    internal void WriteSettings(string sectionName, bool isRoaming, IDictionary newSettings);
}
internal static class System.Configuration.CommonConfigurationStrings : object {
    internal static string UriSectionName;
    internal static string IriParsing;
    internal static string Idn;
    internal static string Enabled;
    internal static string SchemeSettings;
    internal static string SchemeName;
    internal static string GenericUriParserOptions;
}
public class System.Configuration.ConfigurationException : SystemException {
    public string Message { get; }
    public string BareMessage { get; }
    public string Filename { get; }
    public int Line { get; }
    protected ConfigurationException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, XmlNode node);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner, XmlNode node);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, string filename, int line);
    [ObsoleteAttribute("This class is obsolete, to create a new exception create a System.Configuration!System.Configuration.ConfigurationErrorsException")]
public ConfigurationException(string message, Exception inner, string filename, int line);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_BareMessage();
    public virtual string get_Filename();
    public virtual int get_Line();
    [ObsoleteAttribute("This class is obsolete, use System.Configuration!System.Configuration.ConfigurationErrorsException.GetFilename instead")]
public static string GetXmlNodeFilename(XmlNode node);
    [ObsoleteAttribute("This class is obsolete, use System.Configuration!System.Configuration.ConfigurationErrorsException.GetLinenumber instead")]
public static int GetXmlNodeLineNumber(XmlNode node);
    internal static string SafeFilename(string filename);
}
internal static class System.Configuration.ConfigurationManagerInternalFactory : object {
    internal static IConfigurationManagerInternal Instance { get; }
    internal static IConfigurationManagerInternal get_Instance();
}
public class System.Configuration.ConfigurationSettings : object {
    [ObsoleteAttribute("This method is obsolete, it has been replaced by System.Configuration!System.Configuration.ConfigurationManager.AppSettings")]
public static NameValueCollection AppSettings { get; }
    public static NameValueCollection get_AppSettings();
    [ObsoleteAttribute("This method is obsolete, it has been replaced by System.Configuration!System.Configuration.ConfigurationManager.GetSection")]
public static object GetConfig(string sectionName);
}
internal class System.Configuration.ConfigXmlAttribute : XmlAttribute {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlAttribute(string filename, int line, string prefix, string localName, string namespaceUri, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
internal class System.Configuration.ConfigXmlCDataSection : XmlCDataSection {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlCDataSection(string filename, int line, string data, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
internal class System.Configuration.ConfigXmlComment : XmlComment {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlComment(string filename, int line, string comment, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
public class System.Configuration.ConfigXmlDocument : XmlDocument {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    public int LineNumber { get; }
    public string Filename { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    public int get_LineNumber();
    public string get_Filename();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual void Load(string filename);
    public void LoadSingleElement(string filename, XmlTextReader sourceReader);
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceUri);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlCDataSection CreateCDataSection(string data);
    public virtual XmlComment CreateComment(string data);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string data);
    public virtual XmlWhitespace CreateWhitespace(string data);
}
internal class System.Configuration.ConfigXmlElement : XmlElement {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlElement(string filename, int line, string prefix, string localName, string namespaceUri, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
internal class System.Configuration.ConfigXmlSignificantWhitespace : XmlSignificantWhitespace {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlSignificantWhitespace(string filename, int line, string strData, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
internal class System.Configuration.ConfigXmlText : XmlText {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlText(string filename, int line, string strData, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
internal class System.Configuration.ConfigXmlWhitespace : XmlWhitespace {
    private int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
    private string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
    public ConfigXmlWhitespace(string filename, int line, string comment, XmlDocument doc);
    private sealed virtual override int System.Configuration.Internal.IConfigErrorInfo.get_LineNumber();
    private sealed virtual override string System.Configuration.Internal.IConfigErrorInfo.get_Filename();
    public virtual XmlNode CloneNode(bool deep);
}
[AttributeUsageAttribute("128")]
public class System.Configuration.DefaultSettingValueAttribute : Attribute {
    public string Value { get; }
    public DefaultSettingValueAttribute(string value);
    public string get_Value();
}
public class System.Configuration.DictionarySectionHandler : object {
    protected string KeyAttributeName { get; }
    protected string ValueAttributeName { get; }
    internal bool ValueRequired { get; }
    public virtual object Create(object parent, object context, XmlNode section);
    protected virtual string get_KeyAttributeName();
    protected virtual string get_ValueAttributeName();
    internal virtual bool get_ValueRequired();
}
internal class System.Configuration.HandlerBase : object {
    internal static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, String& val);
    internal static XmlNode GetAndRemoveBooleanAttribute(XmlNode node, string attrib, Boolean& val);
    internal static XmlNode GetAndRemoveIntegerAttribute(XmlNode node, string attrib, Int32& val);
    internal static void CheckForUnrecognizedAttributes(XmlNode node);
    internal static string RemoveAttribute(XmlNode node, string name);
    internal static string RemoveRequiredAttribute(XmlNode node, string name);
    internal static string RemoveRequiredAttribute(XmlNode node, string name, bool allowEmpty);
    internal static void CheckForNonElement(XmlNode node);
    internal static bool IsIgnorableAlsoCheckForNonElement(XmlNode node);
    internal static void CheckForChildNodes(XmlNode node);
    internal static void ThrowUnrecognizedElement(XmlNode node);
}
public interface System.Configuration.IApplicationSettingsProvider {
    public abstract virtual SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
    public abstract virtual void Reset(SettingsContext context);
    public abstract virtual void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
}
public interface System.Configuration.IConfigurationSectionHandler {
    public abstract virtual object Create(object parent, object configContext, XmlNode section);
}
[ComVisibleAttribute("False")]
public interface System.Configuration.IConfigurationSystem {
    public abstract virtual object GetConfig(string configKey);
    public abstract virtual void Init();
}
public class System.Configuration.IdnElement : ConfigurationElement {
    internal static UriIdnScope EnabledDefaultValue;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("enabled")]
public UriIdnScope Enabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public UriIdnScope get_Enabled();
    public void set_Enabled(UriIdnScope value);
}
public class System.Configuration.IgnoreSectionHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
internal class System.Configuration.Internal.ConfigurationManagerHelper : object {
    private sealed virtual override void System.Configuration.Internal.IConfigurationManagerHelper.EnsureNetConfigLoaded();
}
public interface System.Configuration.IPersistComponentSettings {
    public bool SaveSettings { get; public set; }
    public string SettingsKey { get; public set; }
    public abstract virtual bool get_SaveSettings();
    public abstract virtual void set_SaveSettings(bool value);
    public abstract virtual string get_SettingsKey();
    public abstract virtual void set_SettingsKey(string value);
    public abstract virtual void LoadComponentSettings();
    public abstract virtual void SaveComponentSettings();
    public abstract virtual void ResetComponentSettings();
}
public class System.Configuration.IriParsingElement : ConfigurationElement {
    internal static bool EnabledDefaultValue;
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Enabled();
    public void set_Enabled(bool value);
}
public interface System.Configuration.ISettingsProviderService {
    public abstract virtual SettingsProvider GetSettingsProvider(SettingsProperty property);
}
public class System.Configuration.LocalFileSettingsProvider : SettingsProvider {
    public string ApplicationName { get; public set; }
    public virtual string get_ApplicationName();
    public virtual void set_ApplicationName(string value);
    public virtual void Initialize(string name, NameValueCollection values);
    public virtual SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties);
    public virtual void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values);
    public sealed virtual void Reset(SettingsContext context);
    public sealed virtual void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
    public sealed virtual SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
}
public class System.Configuration.NameValueFileSectionHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Configuration.NameValueSectionHandler : object {
    protected string KeyAttributeName { get; }
    protected string ValueAttributeName { get; }
    public sealed virtual object Create(object parent, object context, XmlNode section);
    internal static object CreateStatic(object parent, XmlNode section);
    internal static object CreateStatic(object parent, XmlNode section, string keyAttriuteName, string valueAttributeName);
    protected virtual string get_KeyAttributeName();
    protected virtual string get_ValueAttributeName();
}
[AttributeUsageAttribute("128")]
public class System.Configuration.NoSettingsVersionUpgradeAttribute : Attribute {
}
internal static class System.Configuration.PrivilegedConfigurationManager : object {
    internal static ConnectionStringSettingsCollection ConnectionStrings { get; }
    internal static ConnectionStringSettingsCollection get_ConnectionStrings();
    internal static object GetSection(string sectionName);
}
internal class System.Configuration.ReadOnlyNameValueCollection : NameValueCollection {
    internal ReadOnlyNameValueCollection(IEqualityComparer equalityComparer);
    internal ReadOnlyNameValueCollection(ReadOnlyNameValueCollection value);
    internal void SetReadOnly();
}
public class System.Configuration.SchemeSettingElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
public string Name { get; }
    [ConfigurationPropertyAttribute("genericUriParserOptions")]
public GenericUriParserOptions GenericUriParserOptions { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static SchemeSettingElement();
    public string get_Name();
    public GenericUriParserOptions get_GenericUriParserOptions();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Configuration.SchemeSettingElement")]
public class System.Configuration.SchemeSettingElementCollection : ConfigurationElementCollection {
    internal static string AddItemName;
    internal static string ClearItemsName;
    internal static string RemoveItemName;
    public ConfigurationElementCollectionType CollectionType { get; }
    public SchemeSettingElement Item { get; }
    public SchemeSettingElement Item { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    public SchemeSettingElement get_Item(int index);
    public SchemeSettingElement get_Item(string name);
    public int IndexOf(SchemeSettingElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal class System.Configuration.SchemeSettingInternal : object {
    public string Name { get; }
    public GenericUriParserOptions Options { get; }
    public SchemeSettingInternal(string name, GenericUriParserOptions options);
    public string get_Name();
    public GenericUriParserOptions get_Options();
}
[AttributeUsageAttribute("128")]
public class System.Configuration.SettingAttribute : Attribute {
}
public class System.Configuration.SettingChangingEventArgs : CancelEventArgs {
    public object NewValue { get; }
    public string SettingClass { get; }
    public string SettingName { get; }
    public string SettingKey { get; }
    public SettingChangingEventArgs(string settingName, string settingClass, string settingKey, object newValue, bool cancel);
    public object get_NewValue();
    public string get_SettingClass();
    public string get_SettingName();
    public string get_SettingKey();
}
public class System.Configuration.SettingChangingEventHandler : MulticastDelegate {
    public SettingChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SettingChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Configuration.SettingElement : ConfigurationElement {
    internal string Key { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("serializeAs")]
public SettingsSerializeAs SerializeAs { get; public set; }
    [ConfigurationPropertyAttribute("value")]
public SettingValueElement Value { get; public set; }
    private static SettingElement();
    public SettingElement(string name, SettingsSerializeAs serializeAs);
    internal string get_Key();
    public virtual bool Equals(object settings);
    public virtual int GetHashCode();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Name();
    public void set_Name(string value);
    public SettingsSerializeAs get_SerializeAs();
    public void set_SerializeAs(SettingsSerializeAs value);
    public SettingValueElement get_Value();
    public void set_Value(SettingValueElement value);
}
public class System.Configuration.SettingElementCollection : ConfigurationElementCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual string get_ElementName();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public SettingElement Get(string elementKey);
    public void Add(SettingElement element);
    public void Remove(SettingElement element);
    public void Clear();
}
public class System.Configuration.SettingsAttributeDictionary : Hashtable {
    public SettingsAttributeDictionary(SettingsAttributeDictionary attributes);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Configuration.SettingsBase : object {
    public object Item { get; public set; }
    public SettingsPropertyCollection Properties { get; }
    public SettingsProviderCollection Providers { get; }
    public SettingsPropertyValueCollection PropertyValues { get; }
    public SettingsContext Context { get; }
    [BrowsableAttribute("False")]
public bool IsSynchronized { get; }
    public virtual object get_Item(string propertyName);
    public virtual void set_Item(string propertyName, object value);
    public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers);
    public virtual void Save();
    public virtual SettingsPropertyCollection get_Properties();
    public virtual SettingsProviderCollection get_Providers();
    public virtual SettingsPropertyValueCollection get_PropertyValues();
    public virtual SettingsContext get_Context();
    public static SettingsBase Synchronized(SettingsBase settingsBase);
    public bool get_IsSynchronized();
}
public class System.Configuration.SettingsContext : Hashtable {
}
[AttributeUsageAttribute("128")]
public class System.Configuration.SettingsDescriptionAttribute : Attribute {
    public string Description { get; }
    public SettingsDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("4")]
public class System.Configuration.SettingsGroupDescriptionAttribute : Attribute {
    public string Description { get; }
    public SettingsGroupDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("4")]
public class System.Configuration.SettingsGroupNameAttribute : Attribute {
    public string GroupName { get; }
    public SettingsGroupNameAttribute(string groupName);
    public string get_GroupName();
}
public class System.Configuration.SettingsLoadedEventArgs : EventArgs {
    public SettingsProvider Provider { get; }
    public SettingsLoadedEventArgs(SettingsProvider provider);
    public SettingsProvider get_Provider();
}
public class System.Configuration.SettingsLoadedEventHandler : MulticastDelegate {
    public SettingsLoadedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SettingsLoadedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Configuration.SettingsManageability : Enum {
    public int value__;
    public static SettingsManageability Roaming;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsManageabilityAttribute : Attribute {
    public SettingsManageability Manageability { get; }
    public SettingsManageabilityAttribute(SettingsManageability manageability);
    public SettingsManageability get_Manageability();
}
public class System.Configuration.SettingsProperty : object {
    public string Name { get; public set; }
    public bool IsReadOnly { get; public set; }
    public object DefaultValue { get; public set; }
    public Type PropertyType { get; public set; }
    public SettingsSerializeAs SerializeAs { get; public set; }
    public SettingsProvider Provider { get; public set; }
    public SettingsAttributeDictionary Attributes { get; }
    public bool ThrowOnErrorDeserializing { get; public set; }
    public bool ThrowOnErrorSerializing { get; public set; }
    public SettingsProperty(string name);
    public SettingsProperty(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing);
    public SettingsProperty(SettingsProperty propertyToCopy);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual bool get_IsReadOnly();
    public virtual void set_IsReadOnly(bool value);
    public virtual object get_DefaultValue();
    public virtual void set_DefaultValue(object value);
    public virtual Type get_PropertyType();
    public virtual void set_PropertyType(Type value);
    public virtual SettingsSerializeAs get_SerializeAs();
    public virtual void set_SerializeAs(SettingsSerializeAs value);
    public virtual SettingsProvider get_Provider();
    public virtual void set_Provider(SettingsProvider value);
    public virtual SettingsAttributeDictionary get_Attributes();
    public bool get_ThrowOnErrorDeserializing();
    public void set_ThrowOnErrorDeserializing(bool value);
    public bool get_ThrowOnErrorSerializing();
    public void set_ThrowOnErrorSerializing(bool value);
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsPropertyCollection : object {
    public SettingsProperty Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public void Add(SettingsProperty property);
    public void Remove(string name);
    public SettingsProperty get_Item(string name);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual object Clone();
    public void SetReadOnly();
    public void Clear();
    protected virtual void OnAdd(SettingsProperty property);
    protected virtual void OnAddComplete(SettingsProperty property);
    protected virtual void OnClear();
    protected virtual void OnClearComplete();
    protected virtual void OnRemove(SettingsProperty property);
    protected virtual void OnRemoveComplete(SettingsProperty property);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
}
public class System.Configuration.SettingsPropertyIsReadOnlyException : Exception {
    public SettingsPropertyIsReadOnlyException(string message);
    public SettingsPropertyIsReadOnlyException(string message, Exception innerException);
    protected SettingsPropertyIsReadOnlyException(SerializationInfo info, StreamingContext context);
}
public class System.Configuration.SettingsPropertyNotFoundException : Exception {
    public SettingsPropertyNotFoundException(string message);
    public SettingsPropertyNotFoundException(string message, Exception innerException);
    protected SettingsPropertyNotFoundException(SerializationInfo info, StreamingContext context);
}
public class System.Configuration.SettingsPropertyValue : object {
    public string Name { get; }
    public bool IsDirty { get; public set; }
    public SettingsProperty Property { get; }
    public bool UsingDefaultValue { get; }
    public object PropertyValue { get; public set; }
    public object SerializedValue { get; public set; }
    public bool Deserialized { get; public set; }
    public SettingsPropertyValue(SettingsProperty property);
    public string get_Name();
    public bool get_IsDirty();
    public void set_IsDirty(bool value);
    public SettingsProperty get_Property();
    public bool get_UsingDefaultValue();
    public object get_PropertyValue();
    public void set_PropertyValue(object value);
    public object get_SerializedValue();
    public void set_SerializedValue(object value);
    public bool get_Deserialized();
    public void set_Deserialized(bool value);
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsPropertyValueCollection : object {
    public SettingsPropertyValue Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public void Add(SettingsPropertyValue property);
    public void Remove(string name);
    public SettingsPropertyValue get_Item(string name);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual object Clone();
    public void SetReadOnly();
    public void Clear();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
}
public class System.Configuration.SettingsPropertyWrongTypeException : Exception {
    public SettingsPropertyWrongTypeException(string message);
    public SettingsPropertyWrongTypeException(string message, Exception innerException);
    protected SettingsPropertyWrongTypeException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Configuration.SettingsProvider : ProviderBase {
    public string ApplicationName { get; public set; }
    public abstract virtual SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection);
    public abstract virtual void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsProviderAttribute : Attribute {
    public string ProviderTypeName { get; }
    public SettingsProviderAttribute(string providerTypeName);
    public SettingsProviderAttribute(Type providerType);
    public string get_ProviderTypeName();
}
[DefaultMemberAttribute("Item")]
public class System.Configuration.SettingsProviderCollection : ProviderCollection {
    public SettingsProvider Item { get; }
    public virtual void Add(ProviderBase provider);
    public SettingsProvider get_Item(string name);
}
public class System.Configuration.SettingsSavingEventHandler : MulticastDelegate {
    public SettingsSavingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Configuration.SettingsSerializeAs : Enum {
    public int value__;
    public static SettingsSerializeAs String;
    public static SettingsSerializeAs Xml;
    public static SettingsSerializeAs Binary;
    public static SettingsSerializeAs ProviderSpecific;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SettingsSerializeAsAttribute : Attribute {
    public SettingsSerializeAs SerializeAs { get; }
    public SettingsSerializeAsAttribute(SettingsSerializeAs serializeAs);
    public SettingsSerializeAs get_SerializeAs();
}
public class System.Configuration.SettingValueElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    public XmlNode ValueXml { get; public set; }
    private static SettingValueElement();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public XmlNode get_ValueXml();
    public void set_ValueXml(XmlNode value);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    public virtual bool Equals(object settingValue);
    public virtual int GetHashCode();
    protected virtual bool IsModified();
    protected virtual void ResetModified();
    protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
    protected virtual void Reset(ConfigurationElement parentElement);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
}
public class System.Configuration.SingleTagSectionHandler : object {
    public virtual object Create(object parent, object context, XmlNode section);
}
public enum System.Configuration.SpecialSetting : Enum {
    public int value__;
    public static SpecialSetting ConnectionString;
    public static SpecialSetting WebServiceUrl;
}
[AttributeUsageAttribute("132")]
public class System.Configuration.SpecialSettingAttribute : Attribute {
    public SpecialSetting SpecialSetting { get; }
    public SpecialSettingAttribute(SpecialSetting specialSetting);
    public SpecialSetting get_SpecialSetting();
}
internal class System.Configuration.StoredSetting : ValueType {
    internal SettingsSerializeAs SerializeAs;
    internal XmlNode Value;
    internal StoredSetting(SettingsSerializeAs serializeAs, XmlNode value);
}
internal static class System.Configuration.TypeUtil : object {
    internal static object CreateInstanceWithReflectionPermission(string typeString);
}
public class System.Configuration.UriSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("idn")]
public IdnElement Idn { get; }
    [ConfigurationPropertyAttribute("iriParsing")]
public IriParsingElement IriParsing { get; }
    [ConfigurationPropertyAttribute("schemeSettings")]
public SchemeSettingElementCollection SchemeSettings { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static UriSection();
    public IdnElement get_Idn();
    public IriParsingElement get_IriParsing();
    public SchemeSettingElementCollection get_SchemeSettings();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Configuration.UriSectionData : object {
    public Nullable`1<UriIdnScope> IdnScope { get; public set; }
    public Nullable`1<bool> IriParsing { get; public set; }
    public Dictionary`2<string, SchemeSettingInternal> SchemeSettings { get; }
    public Nullable`1<UriIdnScope> get_IdnScope();
    public void set_IdnScope(Nullable`1<UriIdnScope> value);
    public Nullable`1<bool> get_IriParsing();
    public void set_IriParsing(Nullable`1<bool> value);
    public Dictionary`2<string, SchemeSettingInternal> get_SchemeSettings();
}
internal class System.Configuration.UriSectionInternal : object {
    internal UriIdnScope IdnScope { get; }
    internal bool IriParsing { get; }
    private static UriSectionInternal();
    internal UriIdnScope get_IdnScope();
    internal bool get_IriParsing();
    internal SchemeSettingInternal GetSchemeSetting(string scheme);
    internal static UriSectionInternal GetSection();
}
internal class System.Configuration.UriSectionReader : object {
    public static UriSectionData Read(string configFilePath);
    public static UriSectionData Read(string configFilePath, UriSectionData parentData);
}
[AttributeUsageAttribute("128")]
public class System.Configuration.UserScopedSettingAttribute : SettingAttribute {
}
public class System.Configuration.UserSettingsGroup : ConfigurationSectionGroup {
}
internal class System.Diagnostics.AlphabeticalEnumConverter : EnumConverter {
    public AlphabeticalEnumConverter(Type type);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
internal class System.Diagnostics.AssertSection : ConfigurationElement {
    [ConfigurationPropertyAttribute("assertuienabled")]
public bool AssertUIEnabled { get; }
    [ConfigurationPropertyAttribute("logfilename")]
public string LogFileName { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static AssertSection();
    public bool get_AssertUIEnabled();
    public string get_LogFileName();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal static class System.Diagnostics.AssertWrapper : object {
    public static void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage);
}
internal class System.Diagnostics.AsyncStreamReader : object {
    internal static int DefaultBufferSize;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal AsyncStreamReader(Process process, Stream stream, UserCallBack callback, Encoding encoding);
    internal AsyncStreamReader(Process process, Stream stream, UserCallBack callback, Encoding encoding, int bufferSize);
    public virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal void BeginReadLine();
    internal void CancelOperation();
    internal void WaitUtilEOF();
}
[SwitchLevelAttribute("System.Boolean")]
public class System.Diagnostics.BooleanSwitch : Switch {
    public bool Enabled { get; public set; }
    public BooleanSwitch(string displayName, string description);
    public BooleanSwitch(string displayName, string description, string defaultSwitchValue);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual void OnValueChanged();
}
internal class System.Diagnostics.CategoryEntry : object {
    internal int NameIndex;
    internal int HelpIndex;
    internal Int32[] CounterIndexes;
    internal Int32[] HelpIndexes;
    internal CategoryEntry(PERF_OBJECT_TYPE perfObject);
}
internal class System.Diagnostics.CategorySample : object {
    internal long SystemFrequency;
    internal long TimeStamp;
    internal long TimeStamp100nSec;
    internal long CounterFrequency;
    internal long CounterTimeStamp;
    internal Hashtable CounterTable;
    internal Hashtable InstanceNameTable;
    internal bool IsMultiInstance;
    internal CategorySample(Byte[] data, CategoryEntry entry, PerformanceCounterLib library);
    internal String[] GetInstanceNamesFromIndex(int categoryIndex);
    internal CounterDefinitionSample GetCounterDefinitionSample(string counter);
    internal InstanceDataCollectionCollection ReadCategory();
}
[AttributeUsageAttribute("748")]
public class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
public class System.Diagnostics.ConsoleTraceListener : TextWriterTraceListener {
    public ConsoleTraceListener(bool useErrorStream);
    public virtual void Close();
}
public class System.Diagnostics.CorrelationManager : object {
    public Guid ActivityId { get; public set; }
    public Stack LogicalOperationStack { get; }
    public Guid get_ActivityId();
    public void set_ActivityId(Guid value);
    public Stack get_LogicalOperationStack();
    public void StartLogicalOperation(object operationId);
    public void StartLogicalOperation();
    public void StopLogicalOperation();
}
[TypeConverterAttribute("System.Diagnostics.Design.CounterCreationDataConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.CounterCreationData : object {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("CounterType")]
public PerformanceCounterType CounterType { get; public set; }
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("CounterName")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string CounterName { get; public set; }
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("CounterHelp")]
public string CounterHelp { get; public set; }
    public CounterCreationData(string counterName, string counterHelp, PerformanceCounterType counterType);
    public PerformanceCounterType get_CounterType();
    public void set_CounterType(PerformanceCounterType value);
    public string get_CounterName();
    public void set_CounterName(string value);
    public string get_CounterHelp();
    public void set_CounterHelp(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.CounterCreationDataCollection : CollectionBase {
    public CounterCreationData Item { get; public set; }
    public CounterCreationDataCollection(CounterCreationDataCollection value);
    public CounterCreationDataCollection(CounterCreationData[] value);
    public CounterCreationData get_Item(int index);
    public void set_Item(int index, CounterCreationData value);
    public int Add(CounterCreationData value);
    public void AddRange(CounterCreationData[] value);
    public void AddRange(CounterCreationDataCollection value);
    public bool Contains(CounterCreationData value);
    public void CopyTo(CounterCreationData[] array, int index);
    public int IndexOf(CounterCreationData value);
    public void Insert(int index, CounterCreationData value);
    public virtual void Remove(CounterCreationData value);
    protected virtual void OnValidate(object value);
}
internal class System.Diagnostics.CounterDefinitionSample : object {
    internal int NameIndex;
    internal int CounterType;
    internal CounterDefinitionSample BaseCounterDefinitionSample;
    internal CounterDefinitionSample(PERF_COUNTER_DEFINITION perfCounter, CategorySample categorySample, int instanceNumber);
    internal CounterSample GetInstanceValue(string instanceName);
    internal InstanceDataCollection ReadInstanceData(string counterName);
    internal CounterSample GetSingleValue();
    internal void SetInstanceValue(int index, IntPtr dataRef);
}
public class System.Diagnostics.CounterSample : ValueType {
    private long rawValue;
    private long baseValue;
    private long timeStamp;
    private long counterFrequency;
    private PerformanceCounterType counterType;
    private long timeStamp100nSec;
    private long systemFrequency;
    private long counterTimeStamp;
    public static CounterSample Empty;
    public long RawValue { get; }
    internal ulong UnsignedRawValue { get; }
    public long BaseValue { get; }
    public long SystemFrequency { get; }
    public long CounterFrequency { get; }
    public long CounterTimeStamp { get; }
    public long TimeStamp { get; }
    public long TimeStamp100nSec { get; }
    public PerformanceCounterType CounterType { get; }
    public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType);
    public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp);
    private static CounterSample();
    public long get_RawValue();
    internal ulong get_UnsignedRawValue();
    public long get_BaseValue();
    public long get_SystemFrequency();
    public long get_CounterFrequency();
    public long get_CounterTimeStamp();
    public long get_TimeStamp();
    public long get_TimeStamp100nSec();
    public PerformanceCounterType get_CounterType();
    public static float Calculate(CounterSample counterSample);
    public static float Calculate(CounterSample counterSample, CounterSample nextCounterSample);
    public virtual bool Equals(object o);
    public bool Equals(CounterSample sample);
    public virtual int GetHashCode();
    public static bool op_Equality(CounterSample a, CounterSample b);
    public static bool op_Inequality(CounterSample a, CounterSample b);
}
public static class System.Diagnostics.CounterSampleCalculator : object {
    private static CounterSampleCalculator();
    public static float ComputeCounterValue(CounterSample newSample);
    public static float ComputeCounterValue(CounterSample oldSample, CounterSample newSample);
}
public class System.Diagnostics.DataReceivedEventArgs : EventArgs {
    internal string _data;
    public string Data { get; }
    internal DataReceivedEventArgs(string data);
    public string get_Data();
}
public class System.Diagnostics.DataReceivedEventHandler : MulticastDelegate {
    public DataReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Diagnostics.Debug : object {
    public static TraceListenerCollection Listeners { get; }
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static TraceListenerCollection get_Listeners();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
}
public class System.Diagnostics.DefaultTraceListener : TraceListener {
    public bool AssertUiEnabled { get; public set; }
    public string LogFileName { get; public set; }
    public bool get_AssertUiEnabled();
    public void set_AssertUiEnabled(bool value);
    public string get_LogFileName();
    public void set_LogFileName(string value);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
}
public class System.Diagnostics.DelimitedListTraceListener : TextWriterTraceListener {
    public string Delimiter { get; public set; }
    public DelimitedListTraceListener(Stream stream);
    public DelimitedListTraceListener(Stream stream, string name);
    public DelimitedListTraceListener(TextWriter writer);
    public DelimitedListTraceListener(TextWriter writer, string name);
    public DelimitedListTraceListener(string fileName);
    public DelimitedListTraceListener(string fileName, string name);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    protected internal virtual String[] GetSupportedAttributes();
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
}
internal static class System.Diagnostics.DiagnosticsConfiguration : object {
    internal static SwitchElementsCollection SwitchSettings { get; }
    internal static bool AssertUIEnabled { get; }
    internal static string ConfigFilePath { get; }
    internal static string LogFileName { get; }
    internal static bool AutoFlush { get; }
    internal static bool UseGlobalLock { get; }
    internal static int IndentSize { get; }
    internal static int PerfomanceCountersFileMappingSize { get; }
    internal static ListenerElementsCollection SharedListeners { get; }
    internal static SourceElementsCollection Sources { get; }
    internal static SystemDiagnosticsSection SystemDiagnosticsSection { get; }
    private static DiagnosticsConfiguration();
    internal static SwitchElementsCollection get_SwitchSettings();
    internal static bool get_AssertUIEnabled();
    internal static string get_ConfigFilePath();
    internal static string get_LogFileName();
    internal static bool get_AutoFlush();
    internal static bool get_UseGlobalLock();
    internal static int get_IndentSize();
    internal static int get_PerfomanceCountersFileMappingSize();
    internal static ListenerElementsCollection get_SharedListeners();
    internal static SourceElementsCollection get_Sources();
    internal static SystemDiagnosticsSection get_SystemDiagnosticsSection();
    internal static bool IsInitializing();
    internal static bool IsInitialized();
    internal static bool CanInitialize();
    internal static void Initialize();
    internal static void Refresh();
}
[ObsoleteAttribute("This class has been deprecated.  http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Diagnostics.DiagnosticsConfigurationHandler : object {
    public virtual object Create(object parent, object configContext, XmlNode section);
}
public class System.Diagnostics.EntryWrittenEventArgs : EventArgs {
    public EventLogEntry Entry { get; }
    public EntryWrittenEventArgs(EventLogEntry entry);
    public EventLogEntry get_Entry();
}
public class System.Diagnostics.EntryWrittenEventHandler : MulticastDelegate {
    public EntryWrittenEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EntryWrittenEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Diagnostics.EnvironmentBlock : object {
    public static Byte[] ToByteArray(StringDictionary sd, bool unicode);
}
public class System.Diagnostics.EventInstance : object {
    public int CategoryId { get; public set; }
    public EventLogEntryType EntryType { get; public set; }
    public long InstanceId { get; public set; }
    public EventInstance(long instanceId, int categoryId);
    public EventInstance(long instanceId, int categoryId, EventLogEntryType entryType);
    public int get_CategoryId();
    public void set_CategoryId(int value);
    public EventLogEntryType get_EntryType();
    public void set_EntryType(EventLogEntryType value);
    public long get_InstanceId();
    public void set_InstanceId(long value);
}
[DefaultEventAttribute("EntryWritten")]
[InstallerTypeAttribute("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("EventLogDesc")]
public class System.Diagnostics.EventLog : Component {
    internal static string DllName;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("LogEntries")]
public EventLogEntryCollection Entries { get; }
    [BrowsableAttribute("False")]
public string LogDisplayName { get; }
    [TypeConverterAttribute("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[ReadOnlyAttribute("True")]
[MonitoringDescriptionAttribute("LogLog")]
[DefaultValueAttribute("")]
[SettingsBindableAttribute("True")]
public string Log { get; public set; }
    [ReadOnlyAttribute("True")]
[MonitoringDescriptionAttribute("LogMachineName")]
[DefaultValueAttribute(".")]
[SettingsBindableAttribute("True")]
public string MachineName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[ComVisibleAttribute("False")]
public long MaximumKilobytes { get; public set; }
    [BrowsableAttribute("False")]
[ComVisibleAttribute("False")]
public OverflowAction OverflowAction { get; }
    [BrowsableAttribute("False")]
[ComVisibleAttribute("False")]
public int MinimumRetentionDays { get; }
    internal bool ComponentDesignMode { get; }
    [BrowsableAttribute("False")]
[MonitoringDescriptionAttribute("LogMonitoring")]
[DefaultValueAttribute("False")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("LogSynchronizingObject")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [ReadOnlyAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("LogSource")]
[DefaultValueAttribute("")]
[SettingsBindableAttribute("True")]
public string Source { get; public set; }
    public EventLog(string logName);
    public EventLog(string logName, string machineName);
    public EventLog(string logName, string machineName, string source);
    internal static PermissionSet _UnsafeGetAssertPermSet();
    public EventLogEntryCollection get_Entries();
    public string get_LogDisplayName();
    public string get_Log();
    public void set_Log(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    public OverflowAction get_OverflowAction();
    public int get_MinimumRetentionDays();
    internal bool get_ComponentDesignMode();
    internal object ComponentGetService(Type service);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public string get_Source();
    public void set_Source(string value);
    public void add_EntryWritten(EntryWrittenEventHandler value);
    public void remove_EntryWritten(EntryWrittenEventHandler value);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    public static void CreateEventSource(string source, string logName);
    [ObsoleteAttribute("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static void CreateEventSource(string source, string logName, string machineName);
    public static void CreateEventSource(EventSourceCreationData sourceData);
    public static void Delete(string logName);
    public static void Delete(string logName, string machineName);
    public static void DeleteEventSource(string source);
    public static void DeleteEventSource(string source, string machineName);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public static bool Exists(string logName);
    public static bool Exists(string logName, string machineName);
    public static EventLog[] GetEventLogs();
    public static EventLog[] GetEventLogs(string machineName);
    internal static RegistryKey GetEventLogRegKey(string machine, bool writable);
    internal static string GetDllPath(string machineName);
    public static bool SourceExists(string source);
    public static bool SourceExists(string source, string machineName);
    internal static bool SourceExists(string source, string machineName, bool wantToCreate);
    public static string LogNameFromSourceName(string source, string machineName);
    internal static string _InternalLogNameFromSourceName(string source, string machineName);
    [ComVisibleAttribute("False")]
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    [ComVisibleAttribute("False")]
public void RegisterDisplayName(string resourceFile, long resourceId);
    internal static string TryFormatMessage(SafeLibraryHandle hModule, UInt32 messageNum, String[] insertionStrings);
    internal static string UnsafeTryFormatMessage(SafeLibraryHandle hModule, UInt32 messageNum, String[] insertionStrings);
    internal static bool ValidLogName(string logName, bool ignoreEmpty);
    public void WriteEntry(string message);
    public static void WriteEntry(string source, string message);
    public void WriteEntry(string message, EventLogEntryType type);
    public static void WriteEntry(string source, string message, EventLogEntryType type);
    public void WriteEntry(string message, EventLogEntryType type, int eventID);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category);
    public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Object[] values);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Object[] values);
    public static void WriteEvent(string source, EventInstance instance, Byte[] data, Object[] values);
}
[ToolboxItemAttribute("False")]
[DesignTimeVisibleAttribute("False")]
public class System.Diagnostics.EventLogEntry : Component {
    internal Byte[] dataBuf;
    internal int bufOffset;
    [MonitoringDescriptionAttribute("LogEntryMachineName")]
public string MachineName { get; }
    [MonitoringDescriptionAttribute("LogEntryData")]
public Byte[] Data { get; }
    [MonitoringDescriptionAttribute("LogEntryIndex")]
public int Index { get; }
    [MonitoringDescriptionAttribute("LogEntryCategory")]
public string Category { get; }
    [MonitoringDescriptionAttribute("LogEntryCategoryNumber")]
public short CategoryNumber { get; }
    [MonitoringDescriptionAttribute("LogEntryEventID")]
[ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.EventLogEntry.InstanceId instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventID { get; }
    [MonitoringDescriptionAttribute("LogEntryEntryType")]
public EventLogEntryType EntryType { get; }
    [MonitoringDescriptionAttribute("LogEntryMessage")]
[EditorAttribute("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public string Message { get; }
    [MonitoringDescriptionAttribute("LogEntrySource")]
public string Source { get; }
    [MonitoringDescriptionAttribute("LogEntryReplacementStrings")]
public String[] ReplacementStrings { get; }
    [MonitoringDescriptionAttribute("LogEntryResourceId")]
[ComVisibleAttribute("False")]
public long InstanceId { get; }
    [MonitoringDescriptionAttribute("LogEntryTimeGenerated")]
public DateTime TimeGenerated { get; }
    [MonitoringDescriptionAttribute("LogEntryTimeWritten")]
public DateTime TimeWritten { get; }
    [MonitoringDescriptionAttribute("LogEntryUserName")]
public string UserName { get; }
    internal EventLogEntry(Byte[] buf, int offset, EventLogInternal log);
    private static EventLogEntry();
    public string get_MachineName();
    public Byte[] get_Data();
    public int get_Index();
    public string get_Category();
    public short get_CategoryNumber();
    public int get_EventID();
    public EventLogEntryType get_EntryType();
    public string get_Message();
    public string get_Source();
    public String[] get_ReplacementStrings();
    public long get_InstanceId();
    public DateTime get_TimeGenerated();
    public DateTime get_TimeWritten();
    public string get_UserName();
    public bool Equals(EventLogEntry otherEntry);
    internal string ReplaceMessageParameters(string msg, String[] insertionStrings);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogEntryCollection : object {
    public int Count { get; }
    public EventLogEntry Item { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal EventLogEntryCollection(EventLogInternal log);
    public sealed virtual int get_Count();
    public virtual EventLogEntry get_Item(int index);
    public void CopyTo(EventLogEntry[] entries, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal EventLogEntry GetEntryAtNoThrow(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
public enum System.Diagnostics.EventLogEntryType : Enum {
    public int value__;
    public static EventLogEntryType Error;
    public static EventLogEntryType Warning;
    public static EventLogEntryType Information;
    public static EventLogEntryType SuccessAudit;
    public static EventLogEntryType FailureAudit;
}
internal class System.Diagnostics.EventLogInternal : object {
    internal string logName;
    internal string machineName;
    internal EntryWrittenEventHandler onEntryWrittenHandler;
    internal string sourceName;
    internal static string DllName;
    internal static int Flag_monitoring;
    public EventLogEntryCollection Entries { get; }
    internal int EntryCount { get; }
    public string LogDisplayName { get; }
    public string Log { get; }
    public string MachineName { get; }
    [ComVisibleAttribute("False")]
public long MaximumKilobytes { get; public set; }
    internal Hashtable MessageLibraries { get; }
    [ComVisibleAttribute("False")]
public OverflowAction OverflowAction { get; }
    [ComVisibleAttribute("False")]
public int MinimumRetentionDays { get; }
    public bool EnableRaisingEvents { get; public set; }
    internal SafeEventLogReadHandle ReadHandle { get; }
    public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public string Source { get; }
    public EventLogInternal(string logName);
    public EventLogInternal(string logName, string machineName);
    public EventLogInternal(string logName, string machineName, string source);
    public EventLogInternal(string logName, string machineName, string source, EventLog parent);
    private static EventLogInternal();
    public EventLogEntryCollection get_Entries();
    internal int get_EntryCount();
    public string get_LogDisplayName();
    public string get_Log();
    public string get_MachineName();
    public long get_MaximumKilobytes();
    public void set_MaximumKilobytes(long value);
    internal Hashtable get_MessageLibraries();
    public OverflowAction get_OverflowAction();
    public int get_MinimumRetentionDays();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    internal SafeEventLogReadHandle get_ReadHandle();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public string get_Source();
    public void add_EntryWritten(EntryWrittenEventHandler value);
    public void remove_EntryWritten(EntryWrittenEventHandler value);
    public sealed virtual void BeginInit();
    public void Clear();
    public void Close();
    public sealed virtual void Dispose();
    internal void Dispose(bool disposing);
    public sealed virtual void EndInit();
    internal string FormatMessageWrapper(string dllNameList, UInt32 messageNum, String[] insertionStrings);
    internal EventLogEntry[] GetAllEntries();
    internal EventLogEntry GetEntryAt(int index);
    internal EventLogEntry GetEntryAtNoThrow(int index);
    internal static RegistryKey GetEventLogRegKey(string machine, bool writable);
    internal static string GetDllPath(string machineName);
    [ComVisibleAttribute("False")]
public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
    [ComVisibleAttribute("False")]
public void RegisterDisplayName(string resourceFile, long resourceId);
    internal static bool ValidLogName(string logName, bool ignoreEmpty);
    public void WriteEntry(string message);
    public void WriteEntry(string message, EventLogEntryType type);
    public void WriteEntry(string message, EventLogEntryType type, int eventID);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
    public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, Byte[] rawData);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Object[] values);
    [ComVisibleAttribute("False")]
public void WriteEvent(EventInstance instance, Byte[] data, Object[] values);
}
public class System.Diagnostics.EventLogPermission : ResourcePermissionBase {
    public EventLogPermissionEntryCollection PermissionEntries { get; }
    public EventLogPermission(PermissionState state);
    public EventLogPermission(EventLogPermissionAccess permissionAccess, string machineName);
    public EventLogPermission(EventLogPermissionEntry[] permissionAccessEntries);
    public EventLogPermissionEntryCollection get_PermissionEntries();
    internal void AddPermissionAccess(EventLogPermissionEntry entry);
    internal void Clear();
    internal void RemovePermissionAccess(EventLogPermissionEntry entry);
}
[FlagsAttribute]
public enum System.Diagnostics.EventLogPermissionAccess : Enum {
    public int value__;
    public static EventLogPermissionAccess None;
    public static EventLogPermissionAccess Write;
    public static EventLogPermissionAccess Administer;
    [ObsoleteAttribute("This member has been deprecated.  Please use System.Diagnostics.EventLogPermissionAccess.Administer instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static EventLogPermissionAccess Browse;
    [ObsoleteAttribute("This member has been deprecated.  Please use System.Diagnostics.EventLogPermissionAccess.Write instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static EventLogPermissionAccess Instrument;
    [ObsoleteAttribute("This member has been deprecated.  Please use System.Diagnostics.EventLogPermissionAccess.Administer instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static EventLogPermissionAccess Audit;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.EventLogPermissionAttribute : CodeAccessSecurityAttribute {
    public string MachineName { get; public set; }
    public EventLogPermissionAccess PermissionAccess { get; public set; }
    public EventLogPermissionAttribute(SecurityAction action);
    public string get_MachineName();
    public void set_MachineName(string value);
    public EventLogPermissionAccess get_PermissionAccess();
    public void set_PermissionAccess(EventLogPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.EventLogPermissionEntry : object {
    public string MachineName { get; }
    public EventLogPermissionAccess PermissionAccess { get; }
    public EventLogPermissionEntry(EventLogPermissionAccess permissionAccess, string machineName);
    internal EventLogPermissionEntry(ResourcePermissionBaseEntry baseEntry);
    public string get_MachineName();
    public EventLogPermissionAccess get_PermissionAccess();
    internal ResourcePermissionBaseEntry GetBaseEntry();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.EventLogPermissionEntryCollection : CollectionBase {
    public EventLogPermissionEntry Item { get; public set; }
    internal EventLogPermissionEntryCollection(EventLogPermission owner, ResourcePermissionBaseEntry[] entries);
    public EventLogPermissionEntry get_Item(int index);
    public void set_Item(int index, EventLogPermissionEntry value);
    public int Add(EventLogPermissionEntry value);
    public void AddRange(EventLogPermissionEntry[] value);
    public void AddRange(EventLogPermissionEntryCollection value);
    public bool Contains(EventLogPermissionEntry value);
    public void CopyTo(EventLogPermissionEntry[] array, int index);
    public int IndexOf(EventLogPermissionEntry value);
    public void Insert(int index, EventLogPermissionEntry value);
    public void Remove(EventLogPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
}
public class System.Diagnostics.EventLogTraceListener : TraceListener {
    public EventLog EventLog { get; public set; }
    public string Name { get; public set; }
    public EventLogTraceListener(EventLog eventLog);
    public EventLogTraceListener(string source);
    public EventLog get_EventLog();
    public void set_EventLog(EventLog value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string format, Object[] args);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType severity, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType severity, int id, Object[] data);
}
public class System.Diagnostics.EventSourceCreationData : object {
    public string LogName { get; public set; }
    public string MachineName { get; public set; }
    public string Source { get; public set; }
    public string MessageResourceFile { get; public set; }
    public string ParameterResourceFile { get; public set; }
    public string CategoryResourceFile { get; public set; }
    public int CategoryCount { get; public set; }
    public EventSourceCreationData(string source, string logName);
    internal EventSourceCreationData(string source, string logName, string machineName);
    public string get_LogName();
    public void set_LogName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public string get_Source();
    public void set_Source(string value);
    public string get_MessageResourceFile();
    public void set_MessageResourceFile(string value);
    public string get_ParameterResourceFile();
    public void set_ParameterResourceFile(string value);
    public string get_CategoryResourceFile();
    public void set_CategoryResourceFile(string value);
    public int get_CategoryCount();
    public void set_CategoryCount(int value);
}
public class System.Diagnostics.EventTypeFilter : TraceFilter {
    public SourceLevels EventType { get; public set; }
    public EventTypeFilter(SourceLevels level);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    public SourceLevels get_EventType();
    public void set_EventType(SourceLevels value);
}
public class System.Diagnostics.FileVersionInfo : object {
    public string Comments { get; }
    public string CompanyName { get; }
    public int FileBuildPart { get; }
    public string FileDescription { get; }
    public int FileMajorPart { get; }
    public int FileMinorPart { get; }
    public string FileName { get; }
    public int FilePrivatePart { get; }
    public string FileVersion { get; }
    public string InternalName { get; }
    public bool IsDebug { get; }
    public bool IsPatched { get; }
    public bool IsPrivateBuild { get; }
    public bool IsPreRelease { get; }
    public bool IsSpecialBuild { get; }
    public string Language { get; }
    public string LegalCopyright { get; }
    public string LegalTrademarks { get; }
    public string OriginalFilename { get; }
    public string PrivateBuild { get; }
    public int ProductBuildPart { get; }
    public int ProductMajorPart { get; }
    public int ProductMinorPart { get; }
    public string ProductName { get; }
    public int ProductPrivatePart { get; }
    public string ProductVersion { get; }
    public string SpecialBuild { get; }
    public string get_Comments();
    public string get_CompanyName();
    public int get_FileBuildPart();
    public string get_FileDescription();
    public int get_FileMajorPart();
    public int get_FileMinorPart();
    public string get_FileName();
    public int get_FilePrivatePart();
    public string get_FileVersion();
    public string get_InternalName();
    public bool get_IsDebug();
    public bool get_IsPatched();
    public bool get_IsPrivateBuild();
    public bool get_IsPreRelease();
    public bool get_IsSpecialBuild();
    public string get_Language();
    public string get_LegalCopyright();
    public string get_LegalTrademarks();
    public string get_OriginalFilename();
    public string get_PrivateBuild();
    public int get_ProductBuildPart();
    public int get_ProductMajorPart();
    public int get_ProductMinorPart();
    public string get_ProductName();
    public int get_ProductPrivatePart();
    public string get_ProductVersion();
    public string get_SpecialBuild();
    public static FileVersionInfo GetVersionInfo(string fileName);
    public virtual string ToString();
}
internal class System.Diagnostics.FilterElement : TypedElement {
    public TraceFilter GetRuntimeObject();
    internal TraceFilter RefreshRuntimeObject(TraceFilter filter);
}
[GuidAttribute("73386977-D6FD-11D2-BED5-00C04F79E3AE")]
[InterfaceTypeAttribute("1")]
public interface System.Diagnostics.ICollectData {
    public abstract virtual void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, IntPtr& res);
    public abstract virtual void CloseData();
}
internal enum System.Diagnostics.InitState : Enum {
    public int value__;
    public static InitState NotInitialized;
    public static InitState Initializing;
    public static InitState Initialized;
}
public class System.Diagnostics.InstanceData : object {
    public string InstanceName { get; }
    public CounterSample Sample { get; }
    public long RawValue { get; }
    public InstanceData(string instanceName, CounterSample sample);
    public string get_InstanceName();
    public CounterSample get_Sample();
    public long get_RawValue();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.InstanceDataCollection : DictionaryBase {
    public string CounterName { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public InstanceData Item { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use System.Diagnostics.InstanceDataCollectionCollection.get_Item to get an instance of this collection instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public InstanceDataCollection(string counterName);
    public string get_CounterName();
    public ICollection get_Keys();
    public ICollection get_Values();
    public InstanceData get_Item(string instanceName);
    internal void Add(string instanceName, InstanceData value);
    public bool Contains(string instanceName);
    public void CopyTo(InstanceData[] instances, int index);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.InstanceDataCollectionCollection : DictionaryBase {
    public InstanceDataCollection Item { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public InstanceDataCollection get_Item(string counterName);
    public ICollection get_Keys();
    public ICollection get_Values();
    internal void Add(string counterName, InstanceDataCollection value);
    public bool Contains(string counterName);
    public void CopyTo(InstanceDataCollection[] counters, int index);
}
internal class System.Diagnostics.ListenerElement : TypedElement {
    internal bool _isAddedByDefault;
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("filter")]
public FilterElement Filter { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    [ConfigurationPropertyAttribute("traceOutputOptions")]
public TraceOptions TraceOutputOptions { get; public set; }
    [ConfigurationPropertyAttribute("type")]
public string TypeName { get; public set; }
    private static ListenerElement();
    public ListenerElement(bool allowReferences);
    public Hashtable get_Attributes();
    public FilterElement get_Filter();
    public string get_Name();
    public void set_Name(string value);
    public TraceOptions get_TraceOutputOptions();
    public void set_TraceOutputOptions(TraceOptions value);
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    public virtual bool Equals(object compareTo);
    public virtual int GetHashCode();
    public TraceListener GetRuntimeObject();
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
    internal TraceListener RefreshRuntimeObject(TraceListener listener);
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Diagnostics.ListenerElement")]
internal class System.Diagnostics.ListenerElementsCollection : ConfigurationElementCollection {
    public ListenerElement Item { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public ListenerElement get_Item(string name);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public TraceListenerCollection GetRuntimeObject();
    protected virtual void InitializeDefault();
    internal void InitializeDefaultInternal();
    protected virtual void BaseAdd(ConfigurationElement element);
}
internal class System.Diagnostics.MainWindowFinder : object {
    public IntPtr FindMainWindow(int processId);
}
internal class System.Diagnostics.MessageBoxPopup : object {
    public int ReturnValue { get; public set; }
    [SecurityCriticalAttribute]
public MessageBoxPopup(string body, string title, int flags);
    [CompilerGeneratedAttribute]
public int get_ReturnValue();
    [CompilerGeneratedAttribute]
public void set_ReturnValue(int value);
    public int ShowMessageBox();
    [SecuritySafeCriticalAttribute]
public void DoPopup();
}
internal class System.Diagnostics.ModuleInfo : object {
    public string baseName;
    public string fileName;
    public IntPtr baseOfDll;
    public IntPtr entryPoint;
    public int sizeOfImage;
    public int Id;
}
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.MonitoringDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public MonitoringDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal static class System.Diagnostics.NtProcessInfoHelper : object {
    public static ProcessInfo[] GetProcessInfos(Predicate`1<int> processIdFilter);
    internal static string GetProcessShortName(string name);
}
internal static class System.Diagnostics.NtProcessManager : object {
    internal static int IdleProcessID;
    internal static int SystemProcessID { get; }
    private static NtProcessManager();
    internal static int get_SystemProcessID();
    public static Int32[] GetProcessIds(string machineName, bool isRemoteMachine);
    public static Int32[] GetProcessIds();
    public static ModuleInfo[] GetModuleInfos(int processId);
    public static ModuleInfo GetFirstModuleInfo(int processId);
    public static int GetProcessIdFromHandle(SafeProcessHandle processHandle);
    public static ProcessInfo[] GetProcessInfos(string machineName, bool isRemoteMachine);
    internal static ThreadWaitReason GetThreadWaitReason(int value);
}
internal class System.Diagnostics.OrdinalCaseInsensitiveComparer : object {
    internal static OrdinalCaseInsensitiveComparer Default;
    private static OrdinalCaseInsensitiveComparer();
    public sealed virtual int Compare(object a, object b);
}
public enum System.Diagnostics.OverflowAction : Enum {
    public int value__;
    public static OverflowAction DoNotOverwrite;
    public static OverflowAction OverwriteAsNeeded;
    public static OverflowAction OverwriteOlder;
}
internal class System.Diagnostics.PerfCounterSection : ConfigurationElement {
    [ConfigurationPropertyAttribute("filemappingsize")]
public int FileMappingSize { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static PerfCounterSection();
    public int get_FileMappingSize();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
[InstallerTypeAttribute("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SRDescriptionAttribute("PerformanceCounterDesc")]
public class System.Diagnostics.PerformanceCounter : Component {
    [ObsoleteAttribute("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")]
public static int DefaultFileMappingSize;
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SRDescriptionAttribute("PCCategoryName")]
[SettingsBindableAttribute("True")]
public string CategoryName { get; public set; }
    [ReadOnlyAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("PC_CounterHelp")]
public string CounterHelp { get; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SRDescriptionAttribute("PCCounterName")]
[SettingsBindableAttribute("True")]
public string CounterName { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("PC_CounterType")]
public PerformanceCounterType CounterType { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[SRDescriptionAttribute("PCInstanceLifetime")]
public PerformanceCounterInstanceLifetime InstanceLifetime { get; public set; }
    [ReadOnlyAttribute("True")]
[DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SRDescriptionAttribute("PCInstanceName")]
[SettingsBindableAttribute("True")]
public string InstanceName { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("True")]
[MonitoringDescriptionAttribute("PC_ReadOnly")]
public bool ReadOnly { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute(".")]
[SRDescriptionAttribute("PCMachineName")]
[SettingsBindableAttribute("True")]
public string MachineName { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("PC_RawValue")]
public long RawValue { get; public set; }
    public PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName);
    internal PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName, bool skipInit);
    public PerformanceCounter(string categoryName, string counterName, string instanceName);
    public PerformanceCounter(string categoryName, string counterName, string instanceName, bool readOnly);
    public PerformanceCounter(string categoryName, string counterName);
    public PerformanceCounter(string categoryName, string counterName, bool readOnly);
    private static PerformanceCounter();
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CounterHelp();
    public string get_CounterName();
    public void set_CounterName(string value);
    public PerformanceCounterType get_CounterType();
    public PerformanceCounterInstanceLifetime get_InstanceLifetime();
    public void set_InstanceLifetime(PerformanceCounterInstanceLifetime value);
    public string get_InstanceName();
    public void set_InstanceName(string value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public long get_RawValue();
    public void set_RawValue(long value);
    public sealed virtual void BeginInit();
    public void Close();
    public static void CloseSharedResources();
    protected virtual void Dispose(bool disposing);
    public long Decrement();
    public sealed virtual void EndInit();
    [ReliabilityContractAttribute("3", "1")]
public long IncrementBy(long value);
    public long Increment();
    public CounterSample NextSample();
    public float NextValue();
    [ReliabilityContractAttribute("3", "1")]
public void RemoveInstance();
}
public class System.Diagnostics.PerformanceCounterCategory : object {
    internal static int MaxCategoryNameLength;
    internal static int MaxCounterNameLength;
    internal static int MaxHelpLength;
    public string CategoryName { get; public set; }
    public string CategoryHelp { get; }
    public PerformanceCounterCategoryType CategoryType { get; }
    public string MachineName { get; public set; }
    public PerformanceCounterCategory(string categoryName);
    public PerformanceCounterCategory(string categoryName, string machineName);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_CategoryHelp();
    public PerformanceCounterCategoryType get_CategoryType();
    public string get_MachineName();
    public void set_MachineName(string value);
    public bool CounterExists(string counterName);
    public static bool CounterExists(string counterName, string categoryName);
    public static bool CounterExists(string counterName, string categoryName, string machineName);
    [ObsoleteAttribute("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp);
    public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp);
    [ObsoleteAttribute("This method has been deprecated.  Please use System.Diagnostics.PerformanceCounterCategory.Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData);
    public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData);
    internal static void CheckValidCategory(string categoryName);
    internal static void CheckValidCounter(string counterName);
    internal static bool CheckValidId(string id, int maxLength);
    internal static void CheckValidHelp(string help);
    internal static void CheckValidCounterLayout(CounterCreationDataCollection counterData);
    public static void Delete(string categoryName);
    public static bool Exists(string categoryName);
    public static bool Exists(string categoryName, string machineName);
    internal static String[] GetCounterInstances(string categoryName, string machineName);
    public PerformanceCounter[] GetCounters();
    public PerformanceCounter[] GetCounters(string instanceName);
    public static PerformanceCounterCategory[] GetCategories();
    public static PerformanceCounterCategory[] GetCategories(string machineName);
    public String[] GetInstanceNames();
    public bool InstanceExists(string instanceName);
    public static bool InstanceExists(string instanceName, string categoryName);
    public static bool InstanceExists(string instanceName, string categoryName, string machineName);
    public InstanceDataCollectionCollection ReadCategory();
}
[FlagsAttribute]
internal enum System.Diagnostics.PerformanceCounterCategoryOptions : Enum {
    public int value__;
    public static PerformanceCounterCategoryOptions EnableReuse;
    public static PerformanceCounterCategoryOptions UseUniqueSharedMemory;
}
public enum System.Diagnostics.PerformanceCounterCategoryType : Enum {
    public int value__;
    public static PerformanceCounterCategoryType Unknown;
    public static PerformanceCounterCategoryType SingleInstance;
    public static PerformanceCounterCategoryType MultiInstance;
}
public enum System.Diagnostics.PerformanceCounterInstanceLifetime : Enum {
    public int value__;
    public static PerformanceCounterInstanceLifetime Global;
    public static PerformanceCounterInstanceLifetime Process;
}
internal class System.Diagnostics.PerformanceCounterLib : object {
    internal static string PerfShimName;
    internal static string OpenEntryPoint;
    internal static string CollectEntryPoint;
    internal static string CloseEntryPoint;
    internal static string SingleInstanceName;
    internal static string ServicePath;
    internal static string ComputerName { get; }
    internal Hashtable HelpTable { get; }
    internal Hashtable NameTable { get; }
    internal PerformanceCounterLib(string machineName, string lcid);
    internal static string get_ComputerName();
    internal Hashtable get_HelpTable();
    internal Hashtable get_NameTable();
    internal static bool CategoryExists(string machine, string category);
    internal bool CategoryExists(string category);
    internal static void CloseAllLibraries();
    internal static void CloseAllTables();
    internal void CloseTables();
    internal void Close();
    internal static bool CounterExists(string machine, string category, string counter);
    internal bool FindCustomCategory(string category, PerformanceCounterCategoryType& categoryType);
    internal static String[] GetCategories(string machineName);
    internal String[] GetCategories();
    internal static string GetCategoryHelp(string machine, string category);
    internal static CategorySample GetCategorySample(string machine, string category);
    internal static String[] GetCounters(string machine, string category);
    internal static string GetCounterHelp(string machine, string category, string counter);
    internal string GetCounterName(int index);
    internal static PerformanceCounterLib GetPerformanceCounterLib(string machineName, CultureInfo culture);
    internal Byte[] GetPerformanceData(string item);
    internal static bool IsCustomCategory(string machine, string category);
    internal static bool IsBaseCounter(int type);
    internal static PerformanceCounterCategoryType GetCategoryType(string machine, string category);
    internal static void RegisterCategory(string categoryName, PerformanceCounterCategoryType categoryType, string categoryHelp, CounterCreationDataCollection creationData);
    internal static void UnregisterCategory(string categoryName);
}
[ComVisibleAttribute("True")]
[GuidAttribute("82840BE1-D273-11D2-B94A-00600893B17A")]
[ObsoleteAttribute("This class has been deprecated.  Use the PerformanceCounters through the System.Diagnostics.PerformanceCounter class instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Diagnostics.PerformanceCounterManager : object {
    [ObsoleteAttribute("This class has been deprecated.  Use the PerformanceCounters through the System.Diagnostics.PerformanceCounter class instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
private sealed virtual override void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, IntPtr& res);
    [ObsoleteAttribute("This class has been deprecated.  Use the PerformanceCounters through the System.Diagnostics.PerformanceCounter class instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
private sealed virtual override void System.Diagnostics.ICollectData.CloseData();
}
public class System.Diagnostics.PerformanceCounterPermission : ResourcePermissionBase {
    public PerformanceCounterPermissionEntryCollection PermissionEntries { get; }
    public PerformanceCounterPermission(PermissionState state);
    public PerformanceCounterPermission(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    public PerformanceCounterPermission(PerformanceCounterPermissionEntry[] permissionAccessEntries);
    public PerformanceCounterPermissionEntryCollection get_PermissionEntries();
    internal void AddPermissionAccess(PerformanceCounterPermissionEntry entry);
    internal void Clear();
    internal void RemovePermissionAccess(PerformanceCounterPermissionEntry entry);
}
[FlagsAttribute]
public enum System.Diagnostics.PerformanceCounterPermissionAccess : Enum {
    public int value__;
    [ObsoleteAttribute("This member has been deprecated.  Use System.Diagnostics.PerformanceCounter.PerformanceCounterPermissionAccess.Read instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static PerformanceCounterPermissionAccess Browse;
    [ObsoleteAttribute("This member has been deprecated.  Use System.Diagnostics.PerformanceCounter.PerformanceCounterPermissionAccess.Write instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public static PerformanceCounterPermissionAccess Instrument;
    public static PerformanceCounterPermissionAccess None;
    public static PerformanceCounterPermissionAccess Read;
    public static PerformanceCounterPermissionAccess Write;
    public static PerformanceCounterPermissionAccess Administer;
}
[AttributeUsageAttribute("621")]
public class System.Diagnostics.PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
    public string CategoryName { get; public set; }
    public string MachineName { get; public set; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; public set; }
    public PerformanceCounterPermissionAttribute(SecurityAction action);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public PerformanceCounterPermissionAccess get_PermissionAccess();
    public void set_PermissionAccess(PerformanceCounterPermissionAccess value);
    public virtual IPermission CreatePermission();
}
public class System.Diagnostics.PerformanceCounterPermissionEntry : object {
    public string CategoryName { get; }
    public string MachineName { get; }
    public PerformanceCounterPermissionAccess PermissionAccess { get; }
    public PerformanceCounterPermissionEntry(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
    internal PerformanceCounterPermissionEntry(ResourcePermissionBaseEntry baseEntry);
    public string get_CategoryName();
    public string get_MachineName();
    public PerformanceCounterPermissionAccess get_PermissionAccess();
    internal ResourcePermissionBaseEntry GetBaseEntry();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.PerformanceCounterPermissionEntryCollection : CollectionBase {
    public PerformanceCounterPermissionEntry Item { get; public set; }
    internal PerformanceCounterPermissionEntryCollection(PerformanceCounterPermission owner, ResourcePermissionBaseEntry[] entries);
    public PerformanceCounterPermissionEntry get_Item(int index);
    public void set_Item(int index, PerformanceCounterPermissionEntry value);
    public int Add(PerformanceCounterPermissionEntry value);
    public void AddRange(PerformanceCounterPermissionEntry[] value);
    public void AddRange(PerformanceCounterPermissionEntryCollection value);
    public bool Contains(PerformanceCounterPermissionEntry value);
    public void CopyTo(PerformanceCounterPermissionEntry[] array, int index);
    public int IndexOf(PerformanceCounterPermissionEntry value);
    public void Insert(int index, PerformanceCounterPermissionEntry value);
    public void Remove(PerformanceCounterPermissionEntry value);
    protected virtual void OnClear();
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnSet(int index, object oldValue, object newValue);
}
[TypeConverterAttribute("System.Diagnostics.AlphabeticalEnumConverter")]
public enum System.Diagnostics.PerformanceCounterType : Enum {
    public int value__;
    public static PerformanceCounterType NumberOfItems32;
    public static PerformanceCounterType NumberOfItems64;
    public static PerformanceCounterType NumberOfItemsHEX32;
    public static PerformanceCounterType NumberOfItemsHEX64;
    public static PerformanceCounterType RateOfCountsPerSecond32;
    public static PerformanceCounterType RateOfCountsPerSecond64;
    public static PerformanceCounterType CountPerTimeInterval32;
    public static PerformanceCounterType CountPerTimeInterval64;
    public static PerformanceCounterType RawFraction;
    public static PerformanceCounterType RawBase;
    public static PerformanceCounterType AverageTimer32;
    public static PerformanceCounterType AverageBase;
    public static PerformanceCounterType AverageCount64;
    public static PerformanceCounterType SampleFraction;
    public static PerformanceCounterType SampleCounter;
    public static PerformanceCounterType SampleBase;
    public static PerformanceCounterType CounterTimer;
    public static PerformanceCounterType CounterTimerInverse;
    public static PerformanceCounterType Timer100Ns;
    public static PerformanceCounterType Timer100NsInverse;
    public static PerformanceCounterType ElapsedTime;
    public static PerformanceCounterType CounterMultiTimer;
    public static PerformanceCounterType CounterMultiTimerInverse;
    public static PerformanceCounterType CounterMultiTimer100Ns;
    public static PerformanceCounterType CounterMultiTimer100NsInverse;
    public static PerformanceCounterType CounterMultiBase;
    public static PerformanceCounterType CounterDelta32;
    public static PerformanceCounterType CounterDelta64;
}
internal class System.Diagnostics.PerformanceMonitor : object {
    internal PerformanceMonitor(string machineName);
    internal void Close();
    internal Byte[] GetData(string item);
}
[MonitoringDescriptionAttribute("ProcessDesc")]
[DefaultEventAttribute("Exited")]
[DefaultPropertyAttribute("StartInfo")]
[DesignerAttribute("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.Process : Component {
    internal AsyncStreamReader output;
    internal AsyncStreamReader error;
    internal bool pendingOutputRead;
    internal bool pendingErrorRead;
    internal static TraceSwitch processTracing;
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessBasePriority")]
public int BasePriority { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessExitCode")]
public int ExitCode { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessTerminated")]
public bool HasExited { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessExitTime")]
public DateTime ExitTime { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessHandle")]
public IntPtr Handle { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public SafeProcessHandle SafeHandle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessHandleCount")]
public int HandleCount { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessId")]
public int Id { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMachineName")]
public string MachineName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMainWindowHandle")]
public IntPtr MainWindowHandle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMainWindowTitle")]
public string MainWindowTitle { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMainModule")]
public ProcessModule MainModule { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMaxWorkingSet")]
public IntPtr MaxWorkingSet { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessMinWorkingSet")]
public IntPtr MinWorkingSet { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessModules")]
public ProcessModuleCollection Modules { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessNonpagedSystemMemorySize")]
public int NonpagedSystemMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessNonpagedSystemMemorySize")]
[ComVisibleAttribute("False")]
public long NonpagedSystemMemorySize64 { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPagedMemorySize")]
public int PagedMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPagedMemorySize")]
[ComVisibleAttribute("False")]
public long PagedMemorySize64 { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPagedSystemMemorySize")]
public int PagedSystemMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPagedSystemMemorySize")]
[ComVisibleAttribute("False")]
public long PagedSystemMemorySize64 { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakPagedMemorySize")]
public int PeakPagedMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakPagedMemorySize")]
[ComVisibleAttribute("False")]
public long PeakPagedMemorySize64 { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakWorkingSet")]
public int PeakWorkingSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakWorkingSet")]
[ComVisibleAttribute("False")]
public long PeakWorkingSet64 { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakVirtualMemorySize")]
public int PeakVirtualMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPeakVirtualMemorySize")]
[ComVisibleAttribute("False")]
public long PeakVirtualMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPriorityBoostEnabled")]
public bool PriorityBoostEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPriorityClass")]
public ProcessPriorityClass PriorityClass { get; public set; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPrivateMemorySize")]
public int PrivateMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPrivateMemorySize")]
[ComVisibleAttribute("False")]
public long PrivateMemorySize64 { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessPrivilegedProcessorTime")]
public TimeSpan PrivilegedProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessProcessName")]
public string ProcessName { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessProcessorAffinity")]
public IntPtr ProcessorAffinity { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessResponding")]
public bool Responding { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessSessionId")]
public int SessionId { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("2")]
[MonitoringDescriptionAttribute("ProcessStartInfo")]
public ProcessStartInfo StartInfo { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessStartTime")]
public DateTime StartTime { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("ProcessSynchronizingObject")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessThreads")]
public ProcessThreadCollection Threads { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessTotalProcessorTime")]
public TimeSpan TotalProcessorTime { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessUserProcessorTime")]
public TimeSpan UserProcessorTime { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessVirtualMemorySize")]
public int VirtualMemorySize { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessVirtualMemorySize")]
[ComVisibleAttribute("False")]
public long VirtualMemorySize64 { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessEnableRaisingEvents")]
public bool EnableRaisingEvents { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessStandardInput")]
public StreamWriter StandardInput { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessStandardOutput")]
public StreamReader StandardOutput { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessStandardError")]
public StreamReader StandardError { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessWorkingSet")]
public int WorkingSet { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("ProcessWorkingSet")]
[ComVisibleAttribute("False")]
public long WorkingSet64 { get; }
    private static Process();
    [CompilerGeneratedAttribute]
public void add_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OutputDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ErrorDataReceived(DataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ErrorDataReceived(DataReceivedEventHandler value);
    public int get_BasePriority();
    public int get_ExitCode();
    public bool get_HasExited();
    public DateTime get_ExitTime();
    public IntPtr get_Handle();
    public SafeProcessHandle get_SafeHandle();
    public int get_HandleCount();
    public int get_Id();
    public string get_MachineName();
    public IntPtr get_MainWindowHandle();
    public string get_MainWindowTitle();
    public ProcessModule get_MainModule();
    public IntPtr get_MaxWorkingSet();
    public void set_MaxWorkingSet(IntPtr value);
    public IntPtr get_MinWorkingSet();
    public void set_MinWorkingSet(IntPtr value);
    public ProcessModuleCollection get_Modules();
    public int get_NonpagedSystemMemorySize();
    public long get_NonpagedSystemMemorySize64();
    public int get_PagedMemorySize();
    public long get_PagedMemorySize64();
    public int get_PagedSystemMemorySize();
    public long get_PagedSystemMemorySize64();
    public int get_PeakPagedMemorySize();
    public long get_PeakPagedMemorySize64();
    public int get_PeakWorkingSet();
    public long get_PeakWorkingSet64();
    public int get_PeakVirtualMemorySize();
    public long get_PeakVirtualMemorySize64();
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public ProcessPriorityClass get_PriorityClass();
    public void set_PriorityClass(ProcessPriorityClass value);
    public int get_PrivateMemorySize();
    public long get_PrivateMemorySize64();
    public TimeSpan get_PrivilegedProcessorTime();
    public string get_ProcessName();
    public IntPtr get_ProcessorAffinity();
    public void set_ProcessorAffinity(IntPtr value);
    public bool get_Responding();
    public int get_SessionId();
    public ProcessStartInfo get_StartInfo();
    public void set_StartInfo(ProcessStartInfo value);
    public DateTime get_StartTime();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public ProcessThreadCollection get_Threads();
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public int get_VirtualMemorySize();
    public long get_VirtualMemorySize64();
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public StreamWriter get_StandardInput();
    public StreamReader get_StandardOutput();
    public StreamReader get_StandardError();
    public int get_WorkingSet();
    public long get_WorkingSet64();
    public void add_Exited(EventHandler value);
    public void remove_Exited(EventHandler value);
    public bool CloseMainWindow();
    protected virtual void Dispose(bool disposing);
    public void Close();
    public static void EnterDebugMode();
    public static void LeaveDebugMode();
    public static Process GetProcessById(int processId, string machineName);
    public static Process GetProcessById(int processId);
    public static Process[] GetProcessesByName(string processName);
    public static Process[] GetProcessesByName(string processName, string machineName);
    public static Process[] GetProcesses();
    public static Process[] GetProcesses(string machineName);
    public static Process GetCurrentProcess();
    protected void OnExited();
    public void Refresh();
    public bool Start();
    public static Process Start(string fileName, string userName, SecureString password, string domain);
    public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain);
    public static Process Start(string fileName);
    public static Process Start(string fileName, string arguments);
    public static Process Start(ProcessStartInfo startInfo);
    public void Kill();
    public virtual string ToString();
    public bool WaitForExit(int milliseconds);
    public void WaitForExit();
    public bool WaitForInputIdle(int milliseconds);
    public bool WaitForInputIdle();
    [ComVisibleAttribute("False")]
public void BeginOutputReadLine();
    [ComVisibleAttribute("False")]
public void BeginErrorReadLine();
    [ComVisibleAttribute("False")]
public void CancelOutputRead();
    [ComVisibleAttribute("False")]
public void CancelErrorRead();
    internal void OutputReadNotifyUser(string data);
    internal void ErrorReadNotifyUser(string data);
}
internal class System.Diagnostics.ProcessData : object {
    public int ProcessId;
    public long StartupTime;
    public ProcessData(int pid, long startTime);
}
internal class System.Diagnostics.ProcessInfo : object {
    public ArrayList threadInfoList;
    public int basePriority;
    public string processName;
    public int processId;
    public int handleCount;
    public long poolPagedBytes;
    public long poolNonpagedBytes;
    public long virtualBytes;
    public long virtualBytesPeak;
    public long workingSetPeak;
    public long workingSet;
    public long pageFileBytesPeak;
    public long pageFileBytes;
    public long privateBytes;
    public int mainModuleId;
    public int sessionId;
}
internal static class System.Diagnostics.ProcessManager : object {
    public static bool IsNt { get; }
    public static bool IsOSOlderThanXP { get; }
    private static ProcessManager();
    public static bool get_IsNt();
    public static bool get_IsOSOlderThanXP();
    public static ProcessInfo GetProcessInfo(int processId, string machineName);
    public static ProcessInfo[] GetProcessInfos(string machineName);
    public static Int32[] GetProcessIds();
    public static Int32[] GetProcessIds(string machineName);
    public static bool IsProcessRunning(int processId, string machineName);
    public static bool IsProcessRunning(int processId);
    public static int GetProcessIdFromHandle(SafeProcessHandle processHandle);
    public static IntPtr GetMainWindowHandle(int processId);
    public static ModuleInfo[] GetModuleInfos(int processId);
    public static SafeProcessHandle OpenProcess(int processId, int access, bool throwIfExited);
    public static SafeThreadHandle OpenThread(int threadId, int access);
    public static bool IsRemoteMachine(string machineName);
}
[DesignerAttribute("System.Diagnostics.Design.ProcessModuleDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.ProcessModule : Component {
    internal ModuleInfo moduleInfo;
    [MonitoringDescriptionAttribute("ProcModModuleName")]
public string ModuleName { get; }
    [MonitoringDescriptionAttribute("ProcModFileName")]
public string FileName { get; }
    [MonitoringDescriptionAttribute("ProcModBaseAddress")]
public IntPtr BaseAddress { get; }
    [MonitoringDescriptionAttribute("ProcModModuleMemorySize")]
public int ModuleMemorySize { get; }
    [MonitoringDescriptionAttribute("ProcModEntryPointAddress")]
public IntPtr EntryPointAddress { get; }
    [BrowsableAttribute("False")]
public FileVersionInfo FileVersionInfo { get; }
    internal ProcessModule(ModuleInfo moduleInfo);
    internal void EnsureNtProcessInfo();
    public string get_ModuleName();
    public string get_FileName();
    public IntPtr get_BaseAddress();
    public int get_ModuleMemorySize();
    public IntPtr get_EntryPointAddress();
    public FileVersionInfo get_FileVersionInfo();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessModuleCollection : ReadOnlyCollectionBase {
    public ProcessModule Item { get; }
    public ProcessModuleCollection(ProcessModule[] processModules);
    public ProcessModule get_Item(int index);
    public int IndexOf(ProcessModule module);
    public bool Contains(ProcessModule module);
    public void CopyTo(ProcessModule[] array, int index);
}
public enum System.Diagnostics.ProcessPriorityClass : Enum {
    public int value__;
    public static ProcessPriorityClass Normal;
    public static ProcessPriorityClass Idle;
    public static ProcessPriorityClass High;
    public static ProcessPriorityClass RealTime;
    public static ProcessPriorityClass BelowNormal;
    public static ProcessPriorityClass AboveNormal;
}
[TypeConverterAttribute("System.ComponentModel.ExpandableObjectConverter")]
public class System.Diagnostics.ProcessStartInfo : object {
    internal StringDictionary environmentVariables;
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("ProcessVerb")]
[NotifyParentPropertyAttribute("True")]
public string Verb { get; public set; }
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("ProcessArguments")]
[SettingsBindableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[NotifyParentPropertyAttribute("True")]
public string Arguments { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessCreateNoWindow")]
[NotifyParentPropertyAttribute("True")]
public bool CreateNoWindow { get; public set; }
    [EditorAttribute("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[DesignerSerializationVisibilityAttribute("2")]
[DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("ProcessEnvironmentVariables")]
[NotifyParentPropertyAttribute("True")]
public StringDictionary EnvironmentVariables { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("")]
[NotifyParentPropertyAttribute("True")]
public IDictionary`2<string, string> Environment { get; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessRedirectStandardInput")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardInput { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessRedirectStandardOutput")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardOutput { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessRedirectStandardError")]
[NotifyParentPropertyAttribute("True")]
public bool RedirectStandardError { get; public set; }
    public Encoding StandardErrorEncoding { get; public set; }
    public Encoding StandardOutputEncoding { get; public set; }
    [DefaultValueAttribute("True")]
[MonitoringDescriptionAttribute("ProcessUseShellExecute")]
[NotifyParentPropertyAttribute("True")]
public bool UseShellExecute { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public String[] Verbs { get; }
    [NotifyParentPropertyAttribute("True")]
public string UserName { get; public set; }
    public SecureString Password { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public string PasswordInClearText { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public string Domain { get; public set; }
    [NotifyParentPropertyAttribute("True")]
public bool LoadUserProfile { get; public set; }
    [DefaultValueAttribute("")]
[EditorAttribute("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[MonitoringDescriptionAttribute("ProcessFileName")]
[SettingsBindableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[NotifyParentPropertyAttribute("True")]
public string FileName { get; public set; }
    [DefaultValueAttribute("")]
[MonitoringDescriptionAttribute("ProcessWorkingDirectory")]
[EditorAttribute("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SettingsBindableAttribute("True")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[NotifyParentPropertyAttribute("True")]
public string WorkingDirectory { get; public set; }
    [DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("ProcessErrorDialog")]
[NotifyParentPropertyAttribute("True")]
public bool ErrorDialog { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public IntPtr ErrorDialogParentHandle { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("ProcessWindowStyle")]
[NotifyParentPropertyAttribute("True")]
public ProcessWindowStyle WindowStyle { get; public set; }
    internal ProcessStartInfo(Process parent);
    public ProcessStartInfo(string fileName);
    public ProcessStartInfo(string fileName, string arguments);
    public string get_Verb();
    public void set_Verb(string value);
    public string get_Arguments();
    public void set_Arguments(string value);
    public bool get_CreateNoWindow();
    public void set_CreateNoWindow(bool value);
    public StringDictionary get_EnvironmentVariables();
    public IDictionary`2<string, string> get_Environment();
    public bool get_RedirectStandardInput();
    public void set_RedirectStandardInput(bool value);
    public bool get_RedirectStandardOutput();
    public void set_RedirectStandardOutput(bool value);
    public bool get_RedirectStandardError();
    public void set_RedirectStandardError(bool value);
    public Encoding get_StandardErrorEncoding();
    public void set_StandardErrorEncoding(Encoding value);
    public Encoding get_StandardOutputEncoding();
    public void set_StandardOutputEncoding(Encoding value);
    public bool get_UseShellExecute();
    public void set_UseShellExecute(bool value);
    public String[] get_Verbs();
    public string get_UserName();
    public void set_UserName(string value);
    public SecureString get_Password();
    public void set_Password(SecureString value);
    public string get_PasswordInClearText();
    public void set_PasswordInClearText(string value);
    public string get_Domain();
    public void set_Domain(string value);
    public bool get_LoadUserProfile();
    public void set_LoadUserProfile(bool value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_ErrorDialog();
    public void set_ErrorDialog(bool value);
    public IntPtr get_ErrorDialogParentHandle();
    public void set_ErrorDialogParentHandle(IntPtr value);
    public ProcessWindowStyle get_WindowStyle();
    public void set_WindowStyle(ProcessWindowStyle value);
}
[DesignerAttribute("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.ProcessThread : Component {
    [MonitoringDescriptionAttribute("ThreadBasePriority")]
public int BasePriority { get; }
    [MonitoringDescriptionAttribute("ThreadCurrentPriority")]
public int CurrentPriority { get; }
    [MonitoringDescriptionAttribute("ThreadId")]
public int Id { get; }
    [BrowsableAttribute("False")]
unknown int IdealProcessor {public set; }
    [MonitoringDescriptionAttribute("ThreadPriorityBoostEnabled")]
public bool PriorityBoostEnabled { get; public set; }
    [MonitoringDescriptionAttribute("ThreadPriorityLevel")]
public ThreadPriorityLevel PriorityLevel { get; public set; }
    [MonitoringDescriptionAttribute("ThreadPrivilegedProcessorTime")]
public TimeSpan PrivilegedProcessorTime { get; }
    [MonitoringDescriptionAttribute("ThreadStartAddress")]
public IntPtr StartAddress { get; }
    [MonitoringDescriptionAttribute("ThreadStartTime")]
public DateTime StartTime { get; }
    [MonitoringDescriptionAttribute("ThreadThreadState")]
public ThreadState ThreadState { get; }
    [MonitoringDescriptionAttribute("ThreadTotalProcessorTime")]
public TimeSpan TotalProcessorTime { get; }
    [MonitoringDescriptionAttribute("ThreadUserProcessorTime")]
public TimeSpan UserProcessorTime { get; }
    [MonitoringDescriptionAttribute("ThreadWaitReason")]
public ThreadWaitReason WaitReason { get; }
    [BrowsableAttribute("False")]
unknown IntPtr ProcessorAffinity {public set; }
    internal ProcessThread(bool isRemoteMachine, ThreadInfo threadInfo);
    public int get_BasePriority();
    public int get_CurrentPriority();
    public int get_Id();
    public void set_IdealProcessor(int value);
    public bool get_PriorityBoostEnabled();
    public void set_PriorityBoostEnabled(bool value);
    public ThreadPriorityLevel get_PriorityLevel();
    public void set_PriorityLevel(ThreadPriorityLevel value);
    public TimeSpan get_PrivilegedProcessorTime();
    public IntPtr get_StartAddress();
    public DateTime get_StartTime();
    public ThreadState get_ThreadState();
    public TimeSpan get_TotalProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public ThreadWaitReason get_WaitReason();
    public void ResetIdealProcessor();
    public void set_ProcessorAffinity(IntPtr value);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.ProcessThreadCollection : ReadOnlyCollectionBase {
    public ProcessThread Item { get; }
    public ProcessThreadCollection(ProcessThread[] processThreads);
    public ProcessThread get_Item(int index);
    public int Add(ProcessThread thread);
    public void Insert(int index, ProcessThread thread);
    public int IndexOf(ProcessThread thread);
    public bool Contains(ProcessThread thread);
    public void Remove(ProcessThread thread);
    public void CopyTo(ProcessThread[] array, int index);
}
internal class System.Diagnostics.ProcessThreadTimes : object {
    internal long create;
    internal long exit;
    internal long kernel;
    internal long user;
    public DateTime StartTime { get; }
    public DateTime ExitTime { get; }
    public TimeSpan PrivilegedProcessorTime { get; }
    public TimeSpan UserProcessorTime { get; }
    public TimeSpan TotalProcessorTime { get; }
    public DateTime get_StartTime();
    public DateTime get_ExitTime();
    public TimeSpan get_PrivilegedProcessorTime();
    public TimeSpan get_UserProcessorTime();
    public TimeSpan get_TotalProcessorTime();
}
internal class System.Diagnostics.ProcessWaitHandle : WaitHandle {
    internal ProcessWaitHandle(SafeProcessHandle processHandle);
}
public enum System.Diagnostics.ProcessWindowStyle : Enum {
    public int value__;
    public static ProcessWindowStyle Normal;
    public static ProcessWindowStyle Hidden;
    public static ProcessWindowStyle Minimized;
    public static ProcessWindowStyle Maximized;
}
[ConfigurationCollectionAttribute("System.Diagnostics.ListenerElement")]
internal class System.Diagnostics.SharedListenerElementsCollection : ListenerElementsCollection {
    public ConfigurationElementCollectionType CollectionType { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual string get_ElementName();
}
internal class System.Diagnostics.SharedPerformanceCounter : object {
    internal static int DefaultCountersFileMappingSize;
    internal static int MaxCountersFileMappingSize;
    internal static int MinCountersFileMappingSize;
    internal static int InstanceNameMaxLength;
    internal static int InstanceNameSlotSize;
    internal static string SingleInstanceName;
    internal static string DefaultFileMappingName;
    internal static int SingleInstanceHashCode;
    internal int InitialOffset;
    internal long Value { get; internal set; }
    internal SharedPerformanceCounter(string catName, string counterName, string instanceName);
    internal SharedPerformanceCounter(string catName, string counterName, string instanceName, PerformanceCounterInstanceLifetime lifetime);
    private static SharedPerformanceCounter();
    internal long get_Value();
    internal void set_Value(long value);
    internal static int GetWstrHashCode(string wstr);
    [ReliabilityContractAttribute("3", "1")]
internal long IncrementBy(long value);
    internal long Increment();
    internal long Decrement();
    internal static void RemoveAllInstances(string categoryName);
    [ReliabilityContractAttribute("3", "1")]
internal void RemoveInstance(string instanceName, PerformanceCounterInstanceLifetime instanceLifetime);
}
internal static class System.Diagnostics.SharedUtils : object {
    internal static int UnknownEnvironment;
    internal static int W2kEnvironment;
    internal static int NtEnvironment;
    internal static int NonNtEnvironment;
    internal static int CurrentEnvironment { get; }
    private static SharedUtils();
    internal static Win32Exception CreateSafeWin32Exception();
    internal static Win32Exception CreateSafeWin32Exception(int error);
    internal static int get_CurrentEnvironment();
    internal static void CheckEnvironment();
    internal static void CheckNtEnvironment();
    internal static void EnterMutex(string name, Mutex& mutex);
    internal static void EnterMutexWithoutGlobal(string mutexName, Mutex& mutex);
    internal static string GetLatestBuildDllDirectory(string machineName);
}
internal class System.Diagnostics.ShellExecuteHelper : object {
    public int ErrorCode { get; }
    public ShellExecuteHelper(ShellExecuteInfo executeInfo);
    public void ShellExecuteFunction();
    public bool ShellExecuteOnSTAThread();
    public int get_ErrorCode();
}
internal class System.Diagnostics.SourceElement : ConfigurationElement {
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("listeners")]
public ListenerElementsCollection Listeners { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("switchName")]
public string SwitchName { get; }
    [ConfigurationPropertyAttribute("switchValue")]
public string SwitchValue { get; }
    [ConfigurationPropertyAttribute("switchType")]
public string SwitchType { get; }
    private static SourceElement();
    public Hashtable get_Attributes();
    public ListenerElementsCollection get_Listeners();
    public string get_Name();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_SwitchName();
    public string get_SwitchValue();
    public string get_SwitchType();
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Diagnostics.SourceElement")]
internal class System.Diagnostics.SourceElementsCollection : ConfigurationElementCollection {
    public SourceElement Item { get; }
    protected string ElementName { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public SourceElement get_Item(string name);
    protected virtual string get_ElementName();
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
public class System.Diagnostics.SourceFilter : TraceFilter {
    public string Source { get; public set; }
    public SourceFilter(string source);
    public virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    public string get_Source();
    public void set_Source(string value);
}
[FlagsAttribute]
public enum System.Diagnostics.SourceLevels : Enum {
    public int value__;
    public static SourceLevels Off;
    public static SourceLevels Critical;
    public static SourceLevels Error;
    public static SourceLevels Warning;
    public static SourceLevels Information;
    public static SourceLevels Verbose;
    [EditorBrowsableAttribute("2")]
public static SourceLevels ActivityTracing;
    public static SourceLevels All;
}
public class System.Diagnostics.SourceSwitch : Switch {
    public SourceLevels Level { get; public set; }
    public SourceSwitch(string name);
    public SourceSwitch(string displayName, string defaultSwitchValue);
    public SourceLevels get_Level();
    public void set_Level(SourceLevels value);
    public bool ShouldTrace(TraceEventType eventType);
    protected virtual void OnValueChanged();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Diagnostics.StackFrameExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasNativeImage(StackFrame stackFrame);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasMethod(StackFrame stackFrame);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasILOffset(StackFrame stackFrame);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool HasSource(StackFrame stackFrame);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr GetNativeIP(StackFrame stackFrame);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr GetNativeImageBase(StackFrame stackFrame);
}
public class System.Diagnostics.Stopwatch : object {
    public static long Frequency;
    public static bool IsHighResolution;
    public bool IsRunning { get; }
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private static Stopwatch();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
    public void Reset();
    public void Restart();
    public bool get_IsRunning();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public static long GetTimestamp();
}
public abstract class System.Diagnostics.Switch : object {
    [XmlIgnoreAttribute]
public StringDictionary Attributes { get; }
    public string DisplayName { get; }
    public string Description { get; }
    protected int SwitchSetting { get; protected set; }
    protected string Value { get; protected set; }
    protected Switch(string displayName, string description);
    protected Switch(string displayName, string description, string defaultSwitchValue);
    private static Switch();
    public StringDictionary get_Attributes();
    public string get_DisplayName();
    public string get_Description();
    protected int get_SwitchSetting();
    protected void set_SwitchSetting(int value);
    protected string get_Value();
    protected void set_Value(string value);
    protected internal virtual String[] GetSupportedAttributes();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
    internal static void RefreshAll();
    internal void Refresh();
}
[AttributeUsageAttribute("741")]
public class System.Diagnostics.SwitchAttribute : Attribute {
    public string SwitchName { get; public set; }
    public Type SwitchType { get; public set; }
    public string SwitchDescription { get; public set; }
    public SwitchAttribute(string switchName, Type switchType);
    public string get_SwitchName();
    public void set_SwitchName(string value);
    public Type get_SwitchType();
    public void set_SwitchType(Type value);
    public string get_SwitchDescription();
    public void set_SwitchDescription(string value);
    public static SwitchAttribute[] GetAll(Assembly assembly);
}
internal class System.Diagnostics.SwitchElement : ConfigurationElement {
    public Hashtable Attributes { get; }
    [ConfigurationPropertyAttribute("name")]
public string Name { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("value")]
public string Value { get; }
    private static SwitchElement();
    public Hashtable get_Attributes();
    public string get_Name();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Value();
    protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
    protected virtual void PreSerialize(XmlWriter writer);
    protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
    protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
    internal void ResetProperties();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Diagnostics.SwitchElement")]
internal class System.Diagnostics.SwitchElementsCollection : ConfigurationElementCollection {
    public SwitchElement Item { get; }
    public ConfigurationElementCollectionType CollectionType { get; }
    public SwitchElement get_Item(string name);
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
}
internal class System.Diagnostics.SwitchesDictionarySectionHandler : DictionarySectionHandler {
    protected string KeyAttributeName { get; }
    internal bool ValueRequired { get; }
    protected virtual string get_KeyAttributeName();
    internal virtual bool get_ValueRequired();
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.SwitchLevelAttribute : Attribute {
    public Type SwitchLevelType { get; public set; }
    public SwitchLevelAttribute(Type switchLevelType);
    public Type get_SwitchLevelType();
    public void set_SwitchLevelType(Type value);
}
internal class System.Diagnostics.SystemDiagnosticsSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("assert")]
public AssertSection Assert { get; }
    [ConfigurationPropertyAttribute("performanceCounters")]
public PerfCounterSection PerfCounters { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("sources")]
public SourceElementsCollection Sources { get; }
    [ConfigurationPropertyAttribute("sharedListeners")]
public ListenerElementsCollection SharedListeners { get; }
    [ConfigurationPropertyAttribute("switches")]
public SwitchElementsCollection Switches { get; }
    [ConfigurationPropertyAttribute("trace")]
public TraceSection Trace { get; }
    private static SystemDiagnosticsSection();
    public AssertSection get_Assert();
    public PerfCounterSection get_PerfCounters();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public SourceElementsCollection get_Sources();
    public ListenerElementsCollection get_SharedListeners();
    public SwitchElementsCollection get_Switches();
    public TraceSection get_Trace();
    protected virtual void InitializeDefault();
}
public class System.Diagnostics.TextWriterTraceListener : TraceListener {
    internal TextWriter writer;
    public TextWriter Writer { get; public set; }
    public TextWriterTraceListener(Stream stream);
    public TextWriterTraceListener(Stream stream, string name);
    public TextWriterTraceListener(TextWriter writer);
    public TextWriterTraceListener(TextWriter writer, string name);
    public TextWriterTraceListener(string fileName);
    public TextWriterTraceListener(string fileName, string name);
    public TextWriter get_Writer();
    public void set_Writer(TextWriter value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    internal bool EnsureWriter();
}
internal class System.Diagnostics.ThreadInfo : object {
    public int threadId;
    public int processId;
    public int basePriority;
    public int currentPriority;
    public IntPtr startAddress;
    public ThreadState threadState;
    public ThreadWaitReason threadWaitReason;
}
public enum System.Diagnostics.ThreadPriorityLevel : Enum {
    public int value__;
    public static ThreadPriorityLevel Idle;
    public static ThreadPriorityLevel Lowest;
    public static ThreadPriorityLevel BelowNormal;
    public static ThreadPriorityLevel Normal;
    public static ThreadPriorityLevel AboveNormal;
    public static ThreadPriorityLevel Highest;
    public static ThreadPriorityLevel TimeCritical;
}
public enum System.Diagnostics.ThreadState : Enum {
    public int value__;
    public static ThreadState Initialized;
    public static ThreadState Ready;
    public static ThreadState Running;
    public static ThreadState Standby;
    public static ThreadState Terminated;
    public static ThreadState Wait;
    public static ThreadState Transition;
    public static ThreadState Unknown;
}
public enum System.Diagnostics.ThreadWaitReason : Enum {
    public int value__;
    public static ThreadWaitReason Executive;
    public static ThreadWaitReason FreePage;
    public static ThreadWaitReason PageIn;
    public static ThreadWaitReason SystemAllocation;
    public static ThreadWaitReason ExecutionDelay;
    public static ThreadWaitReason Suspended;
    public static ThreadWaitReason UserRequest;
    public static ThreadWaitReason EventPairHigh;
    public static ThreadWaitReason EventPairLow;
    public static ThreadWaitReason LpcReceive;
    public static ThreadWaitReason LpcReply;
    public static ThreadWaitReason VirtualMemory;
    public static ThreadWaitReason PageOut;
    public static ThreadWaitReason Unknown;
}
public class System.Diagnostics.Trace : object {
    public static TraceListenerCollection Listeners { get; }
    public static bool AutoFlush { get; public set; }
    public static bool UseGlobalLock { get; public set; }
    public static CorrelationManager CorrelationManager { get; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Trace();
    public static TraceListenerCollection get_Listeners();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static bool get_UseGlobalLock();
    public static void set_UseGlobalLock(bool value);
    public static CorrelationManager get_CorrelationManager();
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("TRACE")]
public static void Flush();
    [ConditionalAttribute("TRACE")]
public static void Close();
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("TRACE")]
public static void Fail(string message);
    [ConditionalAttribute("TRACE")]
public static void Fail(string message, string detailMessage);
    public static void Refresh();
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceWarning(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void TraceError(string message);
    [ConditionalAttribute("TRACE")]
public static void TraceError(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public static void Write(string message);
    [ConditionalAttribute("TRACE")]
public static void Write(object value);
    [ConditionalAttribute("TRACE")]
public static void Write(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void Write(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, string message, string category);
    [ConditionalAttribute("TRACE")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("TRACE")]
public static void Indent();
    [ConditionalAttribute("TRACE")]
public static void Unindent();
}
public class System.Diagnostics.TraceEventCache : object {
    internal Guid ActivityId { get; }
    public string Callstack { get; }
    public Stack LogicalOperationStack { get; }
    public DateTime DateTime { get; }
    public int ProcessId { get; }
    public string ThreadId { get; }
    public long Timestamp { get; }
    internal Guid get_ActivityId();
    public string get_Callstack();
    public Stack get_LogicalOperationStack();
    public DateTime get_DateTime();
    public int get_ProcessId();
    public string get_ThreadId();
    public long get_Timestamp();
    internal static int GetProcessId();
    internal static string GetProcessName();
    internal static int GetThreadId();
}
public enum System.Diagnostics.TraceEventType : Enum {
    public int value__;
    public static TraceEventType Critical;
    public static TraceEventType Error;
    public static TraceEventType Warning;
    public static TraceEventType Information;
    public static TraceEventType Verbose;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Start;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Stop;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Suspend;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Resume;
    [EditorBrowsableAttribute("2")]
public static TraceEventType Transfer;
}
public abstract class System.Diagnostics.TraceFilter : object {
    internal string initializeData;
    public abstract virtual bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1, Object[] data);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args);
    internal bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, Object[] args, object data1);
}
internal static class System.Diagnostics.TraceInternal : object {
    internal static object critSec;
    public static TraceListenerCollection Listeners { get; }
    internal static string AppName { get; }
    public static bool AutoFlush { get; public set; }
    public static bool UseGlobalLock { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static TraceInternal();
    public static TraceListenerCollection get_Listeners();
    internal static string get_AppName();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static bool get_UseGlobalLock();
    public static void set_UseGlobalLock(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    public static void Indent();
    public static void Unindent();
    public static void Flush();
    public static void Close();
    public static void Assert(bool condition);
    public static void Assert(bool condition, string message);
    public static void Assert(bool condition, string message, string detailMessage);
    public static void Fail(string message);
    public static void Fail(string message, string detailMessage);
    internal static void Refresh();
    public static void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    public static void Write(string message);
    public static void Write(object value);
    public static void Write(string message, string category);
    public static void Write(object value, string category);
    public static void WriteLine(string message);
    public static void WriteLine(object value);
    public static void WriteLine(string message, string category);
    public static void WriteLine(object value, string category);
    public static void WriteIf(bool condition, string message);
    public static void WriteIf(bool condition, object value);
    public static void WriteIf(bool condition, string message, string category);
    public static void WriteIf(bool condition, object value, string category);
    public static void WriteLineIf(bool condition, string message);
    public static void WriteLineIf(bool condition, object value);
    public static void WriteLineIf(bool condition, string message, string category);
    public static void WriteLineIf(bool condition, object value, string category);
}
public enum System.Diagnostics.TraceLevel : Enum {
    public int value__;
    public static TraceLevel Off;
    public static TraceLevel Error;
    public static TraceLevel Warning;
    public static TraceLevel Info;
    public static TraceLevel Verbose;
}
public abstract class System.Diagnostics.TraceListener : MarshalByRefObject {
    internal string initializeData;
    public StringDictionary Attributes { get; }
    public string Name { get; public set; }
    public bool IsThreadSafe { get; }
    public int IndentLevel { get; public set; }
    public int IndentSize { get; public set; }
    [ComVisibleAttribute("False")]
public TraceFilter Filter { get; public set; }
    protected bool NeedIndent { get; protected set; }
    [ComVisibleAttribute("False")]
public TraceOptions TraceOutputOptions { get; public set; }
    protected TraceListener(string name);
    public StringDictionary get_Attributes();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual bool get_IsThreadSafe();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Flush();
    public int get_IndentLevel();
    public void set_IndentLevel(int value);
    public int get_IndentSize();
    public void set_IndentSize(int value);
    public TraceFilter get_Filter();
    public void set_Filter(TraceFilter value);
    protected bool get_NeedIndent();
    protected void set_NeedIndent(bool value);
    public TraceOptions get_TraceOutputOptions();
    public void set_TraceOutputOptions(TraceOptions value);
    internal void SetAttributes(Hashtable attribs);
    public virtual void Fail(string message);
    public virtual void Fail(string message, string detailMessage);
    protected internal virtual String[] GetSupportedAttributes();
    public abstract virtual void Write(string message);
    public virtual void Write(object o);
    public virtual void Write(string message, string category);
    public virtual void Write(object o, string category);
    protected virtual void WriteIndent();
    public abstract virtual void WriteLine(string message);
    public virtual void WriteLine(object o);
    public virtual void WriteLine(string message, string category);
    public virtual void WriteLine(object o, string category);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    [ComVisibleAttribute("False")]
public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    [ComVisibleAttribute("False")]
public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    [ComVisibleAttribute("False")]
public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
    internal bool IsEnabled(TraceOptions opts);
}
[DefaultMemberAttribute("Item")]
public class System.Diagnostics.TraceListenerCollection : object {
    public TraceListener Item { get; public set; }
    public TraceListener Item { get; }
    public int Count { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TraceListener get_Item(int i);
    public void set_Item(int i, TraceListener value);
    public TraceListener get_Item(string name);
    public sealed virtual int get_Count();
    public int Add(TraceListener listener);
    public void AddRange(TraceListener[] value);
    public void AddRange(TraceListenerCollection value);
    public sealed virtual void Clear();
    public bool Contains(TraceListener listener);
    public void CopyTo(TraceListener[] listeners, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal void InitializeListener(TraceListener listener);
    public int IndexOf(TraceListener listener);
    public void Insert(int index, TraceListener listener);
    public void Remove(TraceListener listener);
    public void Remove(string name);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[FlagsAttribute]
public enum System.Diagnostics.TraceOptions : Enum {
    public int value__;
    public static TraceOptions None;
    public static TraceOptions LogicalOperationStack;
    public static TraceOptions DateTime;
    public static TraceOptions Timestamp;
    public static TraceOptions ProcessId;
    public static TraceOptions ThreadId;
    public static TraceOptions Callstack;
}
internal class System.Diagnostics.TraceSection : ConfigurationElement {
    [ConfigurationPropertyAttribute("autoflush")]
public bool AutoFlush { get; }
    [ConfigurationPropertyAttribute("indentsize")]
public int IndentSize { get; }
    [ConfigurationPropertyAttribute("listeners")]
public ListenerElementsCollection Listeners { get; }
    [ConfigurationPropertyAttribute("useGlobalLock")]
public bool UseGlobalLock { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static TraceSection();
    public bool get_AutoFlush();
    public int get_IndentSize();
    public ListenerElementsCollection get_Listeners();
    public bool get_UseGlobalLock();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Diagnostics.TraceSource : object {
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initCalled;
    public StringDictionary Attributes { get; }
    public string Name { get; }
    public TraceListenerCollection Listeners { get; }
    public SourceSwitch Switch { get; public set; }
    public TraceSource(string name);
    public TraceSource(string name, SourceLevels defaultLevel);
    private static TraceSource();
    public void Close();
    public void Flush();
    protected internal virtual String[] GetSupportedAttributes();
    internal static void RefreshAll();
    internal void Refresh();
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string message);
    [ConditionalAttribute("TRACE")]
public void TraceEvent(TraceEventType eventType, int id, string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, object data);
    [ConditionalAttribute("TRACE")]
public void TraceData(TraceEventType eventType, int id, Object[] data);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string message);
    [ConditionalAttribute("TRACE")]
public void TraceInformation(string format, Object[] args);
    [ConditionalAttribute("TRACE")]
public void TraceTransfer(int id, string message, Guid relatedActivityId);
    public StringDictionary get_Attributes();
    public string get_Name();
    public TraceListenerCollection get_Listeners();
    public SourceSwitch get_Switch();
    public void set_Switch(SourceSwitch value);
}
[SwitchLevelAttribute("System.Diagnostics.TraceLevel")]
public class System.Diagnostics.TraceSwitch : Switch {
    public TraceLevel Level { get; public set; }
    public bool TraceError { get; }
    public bool TraceWarning { get; }
    public bool TraceInfo { get; }
    public bool TraceVerbose { get; }
    public TraceSwitch(string displayName, string description);
    public TraceSwitch(string displayName, string description, string defaultSwitchValue);
    public TraceLevel get_Level();
    public void set_Level(TraceLevel value);
    public bool get_TraceError();
    public bool get_TraceWarning();
    public bool get_TraceInfo();
    public bool get_TraceVerbose();
    protected virtual void OnSwitchSettingChanged();
    protected virtual void OnValueChanged();
}
internal static class System.Diagnostics.TraceUtils : object {
    internal static object GetRuntimeObject(string className, Type baseType, string initializeData);
    internal static bool IsOwnedTL(Type type);
    internal static bool IsOwnedTextWriterTL(Type type);
    internal static void VerifyAttributes(IDictionary attributes, String[] supportedAttributes, object parent);
}
internal class System.Diagnostics.TypedElement : ConfigurationElement {
    protected static ConfigurationProperty _propTypeName;
    protected static ConfigurationProperty _propInitData;
    protected ConfigurationPropertyCollection _properties;
    protected object _runtimeObject;
    [ConfigurationPropertyAttribute("initializeData")]
public string InitData { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string TypeName { get; public set; }
    public TypedElement(Type baseType);
    private static TypedElement();
    public string get_InitData();
    public void set_InitData(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public virtual string get_TypeName();
    public virtual void set_TypeName(string value);
    protected object BaseGetRuntimeObject();
}
internal class System.Diagnostics.UserCallBack : MulticastDelegate {
    public UserCallBack(object object, IntPtr method);
    public virtual void Invoke(string data);
    public virtual IAsyncResult BeginInvoke(string data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Diagnostics.WinProcessManager : object {
    public static Int32[] GetProcessIds();
    public static ProcessInfo[] GetProcessInfos();
    public static ModuleInfo[] GetModuleInfos(int processId);
}
public class System.Diagnostics.XmlWriterTraceListener : TextWriterTraceListener {
    internal bool shouldRespectFilterOnTraceTransfer;
    public XmlWriterTraceListener(Stream stream);
    public XmlWriterTraceListener(Stream stream, string name);
    public XmlWriterTraceListener(TextWriter writer);
    public XmlWriterTraceListener(TextWriter writer, string name);
    public XmlWriterTraceListener(string filename);
    public XmlWriterTraceListener(string filename, string name);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void Fail(string message, string detailMessage);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, Object[] args);
    public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
    public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, Object[] data);
    public virtual void Close();
    public virtual void TraceTransfer(TraceEventCache eventCache, string source, int id, string message, Guid relatedActivityId);
}
internal class System.DomainNameHelper : object {
    internal static string Localhost;
    internal static string Loopback;
    private static DomainNameHelper();
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& loopback);
    internal static bool IsValid(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile);
    internal static bool IsValidByIri(Char* name, ushort pos, Int32& returnedEnd, Boolean& notCanonical, bool notImplicitFile);
    internal static string IdnEquivalent(string hostname);
    internal static string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn);
    internal static string IdnEquivalent(Char* hostname, int start, int end, Boolean& allAscii, String& bidiStrippedHost);
    internal static string UnicodeEquivalent(string idnHost, Char* hostname, int start, int end);
    internal static string UnicodeEquivalent(Char* hostname, int start, int end, Boolean& allAscii, Boolean& atLeastOneValidIdn);
    internal static bool ContainsCharactersUnsafeForNormalizedHost(string host);
}
[AttributeUsageAttribute("1")]
internal class System.Drawing.BitmapSuffixInSatelliteAssemblyAttribute : Attribute {
}
internal static class System.EnvironmentHelpers : object {
    public static bool IsAppContainerProcess { get; }
    public static bool get_IsAppContainerProcess();
    internal static bool IsWindowsVistaOrAbove();
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument collection;
    public static ExceptionArgument match;
    public static ExceptionArgument converter;
    public static ExceptionArgument queue;
    public static ExceptionArgument stack;
    public static ExceptionArgument capacity;
    public static ExceptionArgument index;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument value;
    public static ExceptionArgument count;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument item;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_ImplementIComparable;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNumRequired;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Serialization_InvalidOnDeser;
    public static ExceptionResource Serialization_MismatchedCount;
    public static ExceptionResource Serialization_MissingValues;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource Argument_InvalidArrayType;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
    public static ExceptionResource InvalidOperation_EmptyCollection;
    public static ExceptionResource InvalidOperation_EmptyQueue;
    public static ExceptionResource InvalidOperation_EnumOpCantHappen;
    public static ExceptionResource InvalidOperation_EnumFailedVersion;
    public static ExceptionResource InvalidOperation_EmptyStack;
    public static ExceptionResource InvalidOperation_EnumNotStarted;
    public static ExceptionResource InvalidOperation_EnumEnded;
    public static ExceptionResource NotSupported_SortedListNestedWrite;
    public static ExceptionResource NotSupported_ValueCollectionSet;
}
internal static class System.ExternDll : object {
    public static string Activeds;
    public static string Advapi32;
    public static string Comctl32;
    public static string Comdlg32;
    public static string Gdi32;
    public static string Gdiplus;
    public static string Hhctrl;
    public static string Imm32;
    public static string Kernel32;
    public static string Loadperf;
    public static string Mscoree;
    public static string Clr;
    public static string Msi;
    public static string Mqrt;
    public static string Ntdll;
    public static string Ole32;
    public static string Oleacc;
    public static string Oleaut32;
    public static string Olepro32;
    public static string PerfCounter;
    public static string Powrprof;
    public static string Psapi;
    public static string Shell32;
    public static string User32;
    public static string Uxtheme;
    public static string WinMM;
    public static string Winspool;
    public static string Wtsapi32;
    public static string Version;
    public static string Vsassert;
    public static string Fxassert;
    public static string Shlwapi;
    public static string Crypt32;
    public static string ShCore;
    public static string Wldp;
    internal static string Odbc32;
    internal static string SNI;
    internal static string OciDll;
    internal static string OraMtsDll;
    internal static string UiaCore;
}
public class System.FileStyleUriParser : UriParser {
}
public class System.FtpStyleUriParser : UriParser {
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    public static void Register(Func`2<object, bool> callback, object targetObj);
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
}
public class System.GenericUriParser : UriParser {
    public GenericUriParser(GenericUriParserOptions options);
}
[FlagsAttribute]
public enum System.GenericUriParserOptions : Enum {
    public int value__;
    public static GenericUriParserOptions Default;
    public static GenericUriParserOptions GenericAuthority;
    public static GenericUriParserOptions AllowEmptyAuthority;
    public static GenericUriParserOptions NoUserInfo;
    public static GenericUriParserOptions NoPort;
    public static GenericUriParserOptions NoQuery;
    public static GenericUriParserOptions NoFragment;
    public static GenericUriParserOptions DontConvertPathBackslashes;
    public static GenericUriParserOptions DontCompressPath;
    public static GenericUriParserOptions DontUnescapePathDotsAndSlashes;
    public static GenericUriParserOptions Idn;
    public static GenericUriParserOptions IriParsing;
}
public class System.GopherStyleUriParser : UriParser {
}
internal static class System.HResults : object {
    internal static int Configuration;
    internal static int Xml;
    internal static int XmlSchema;
    internal static int XmlXslt;
    internal static int XmlXPath;
    internal static int Data;
    internal static int DataDeletedRowInaccessible;
    internal static int DataDuplicateName;
    internal static int DataInRowChangingEvent;
    internal static int DataInvalidConstraint;
    internal static int DataMissingPrimaryKey;
    internal static int DataNoNullAllowed;
    internal static int DataReadOnly;
    internal static int DataRowNotInTable;
    internal static int DataVersionNotFound;
    internal static int DataConstraint;
    internal static int StrongTyping;
    internal static int SqlType;
    internal static int SqlNullValue;
    internal static int SqlTruncate;
    internal static int AdapterMapping;
    internal static int DataAdapter;
    internal static int DBConcurrency;
    internal static int OperationAborted;
    internal static int InvalidUdt;
    internal static int Metadata;
    internal static int InvalidQuery;
    internal static int CommandCompilation;
    internal static int CommandExecution;
    internal static int SqlException;
    internal static int OdbcException;
    internal static int OracleException;
    internal static int ConnectionPlanException;
    internal static int NteBadKeySet;
    internal static int Win32AccessDenied;
    internal static int Win32InvalidHandle;
    internal static int License;
    internal static int InternalBufferOverflow;
    internal static int ServiceControllerTimeout;
    internal static int Install;
    internal static int EFail;
}
public class System.HttpStyleUriParser : UriParser {
}
internal class System.InvariantComparer : object {
    internal static InvariantComparer Default;
    private static InvariantComparer();
    public sealed virtual int Compare(object a, object b);
}
internal enum System.IO.Compression.BlockType : Enum {
    public int value__;
    public static BlockType Uncompressed;
    public static BlockType Static;
    public static BlockType Dynamic;
}
public enum System.IO.Compression.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel Optimal;
    public static CompressionLevel Fastest;
    public static CompressionLevel NoCompression;
}
public enum System.IO.Compression.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Decompress;
    public static CompressionMode Compress;
}
internal class System.IO.Compression.CompressionTracingSwitch : Switch {
    internal static CompressionTracingSwitch tracingSwitch;
    public static bool Verbose { get; }
    public static bool Informational { get; }
    internal CompressionTracingSwitch(string displayName, string description);
    private static CompressionTracingSwitch();
    public static bool get_Verbose();
    public static bool get_Informational();
}
internal enum System.IO.Compression.CompressionTracingSwitchLevel : Enum {
    public int value__;
    public static CompressionTracingSwitchLevel Off;
    public static CompressionTracingSwitchLevel Informational;
    public static CompressionTracingSwitchLevel Verbose;
}
internal class System.IO.Compression.CopyEncoder : object {
    public void GetBlock(DeflateInput input, OutputBuffer output, bool isFinal);
}
internal static class System.IO.Compression.Crc32Helper : object {
    private static Crc32Helper();
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
}
internal class System.IO.Compression.DeflateInput : object {
    internal Byte[] Buffer { get; internal set; }
    internal int Count { get; internal set; }
    internal int StartIndex { get; internal set; }
    internal Byte[] get_Buffer();
    internal void set_Buffer(Byte[] value);
    internal int get_Count();
    internal void set_Count(int value);
    internal int get_StartIndex();
    internal void set_StartIndex(int value);
    internal void ConsumeBytes(int n);
    internal InputState DumpState();
    internal void RestoreState(InputState state);
}
internal class System.IO.Compression.DeflaterManaged : object {
    private sealed virtual override bool System.IO.Compression.IDeflater.NeedsInput();
    private sealed virtual override void System.IO.Compression.IDeflater.SetInput(Byte[] inputBuffer, int startIndex, int count);
    private sealed virtual override int System.IO.Compression.IDeflater.GetDeflateOutput(Byte[] outputBuffer);
    private sealed virtual override bool System.IO.Compression.IDeflater.Finish(Byte[] outputBuffer, Int32& bytesRead);
    private sealed virtual override void System.IDisposable.Dispose();
    protected void Dispose(bool disposing);
}
internal class System.IO.Compression.DeflaterZLib : object {
    internal DeflaterZLib(CompressionLevel compressionLevel);
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
private sealed virtual override bool System.IO.Compression.IDeflater.NeedsInput();
    [SecuritySafeCriticalAttribute]
private sealed virtual override void System.IO.Compression.IDeflater.SetInput(Byte[] inputBuffer, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
private sealed virtual override int System.IO.Compression.IDeflater.GetDeflateOutput(Byte[] outputBuffer);
    private sealed virtual override bool System.IO.Compression.IDeflater.Finish(Byte[] outputBuffer, Int32& bytesRead);
}
public class System.IO.Compression.DeflateStream : Stream {
    internal static int DefaultBufferSize;
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionMode mode);
    internal DeflateStream(Stream stream, bool leaveOpen, IFileFormatReader reader);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    private static DeflateStream();
    internal void SetFileFormatWriter(IFileFormatWriter writer);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] array, int offset, int count);
    internal void InternalWrite(Byte[] array, int offset, int count, bool isAsync);
    protected virtual void Dispose(bool disposing);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
internal class System.IO.Compression.DeflateStreamAsyncResult : object {
    public Byte[] buffer;
    public int offset;
    public int count;
    public bool isWrite;
    internal bool m_CompletedSynchronously;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal object Result { get; }
    public DeflateStreamAsyncResult(object asyncObject, object asyncState, AsyncCallback asyncCallback, Byte[] buffer, int offset, int count);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal object get_Result();
    internal void Close();
    internal void InvokeCallback(bool completedSynchronously, object result);
    internal void InvokeCallback(object result);
}
internal class System.IO.Compression.FastEncoder : object {
    internal int BytesInHistory { get; }
    internal DeflateInput UnprocessedInput { get; }
    internal double LastCompressionRatio { get; }
    internal int get_BytesInHistory();
    internal DeflateInput get_UnprocessedInput();
    internal void FlushInput();
    internal double get_LastCompressionRatio();
    internal void GetBlock(DeflateInput input, OutputBuffer output, int maxBytesToCopy);
    internal void GetCompressedData(DeflateInput input, OutputBuffer output);
    internal void GetBlockHeader(OutputBuffer output);
    internal void GetBlockFooter(OutputBuffer output);
    internal static void WriteMatch(int matchLen, int matchPos, OutputBuffer output);
    internal static void WriteChar(byte b, OutputBuffer output);
    internal static void WriteDeflatePreamble(OutputBuffer output);
}
internal static class System.IO.Compression.FastEncoderStatics : object {
    internal static Byte[] FastEncoderTreeStructureData;
    internal static Byte[] BFinalFastEncoderTreeStructureData;
    internal static UInt32[] FastEncoderLiteralCodeInfo;
    internal static UInt32[] FastEncoderDistanceCodeInfo;
    internal static UInt32[] BitMask;
    internal static Byte[] ExtraLengthBits;
    internal static Byte[] ExtraDistanceBits;
    internal static int NumChars;
    internal static int NumLengthBaseCodes;
    internal static int NumDistBaseCodes;
    internal static UInt32 FastEncoderPostTreeBitBuf;
    internal static int FastEncoderPostTreeBitCount;
    internal static UInt32 NoCompressionHeader;
    internal static int NoCompressionHeaderBitCount;
    internal static UInt32 BFinalNoCompressionHeader;
    internal static int BFinalNoCompressionHeaderBitCount;
    internal static int MaxCodeLen;
    private static FastEncoderStatics();
    internal static int GetSlot(int pos);
    public static UInt32 BitReverse(UInt32 code, int length);
}
internal class System.IO.Compression.FastEncoderWindow : object {
    internal static int MaxMatch;
    internal static int MinMatch;
    public int BytesAvailable { get; }
    public DeflateInput UnprocessedInput { get; }
    public int FreeWindowSpace { get; }
    public int get_BytesAvailable();
    public DeflateInput get_UnprocessedInput();
    public void FlushWindow();
    public int get_FreeWindowSpace();
    public void CopyBytes(Byte[] inputBuffer, int startIndex, int count);
    public void MoveWindows();
    internal bool GetNextSymbolOrMatch(Match match);
}
internal static class System.IO.Compression.GZipConstants : object {
    internal static int CompressionLevel_3;
    internal static int CompressionLevel_10;
    internal static long FileLengthModulo;
    internal static byte ID1;
    internal static byte ID2;
    internal static byte Deflate;
    internal static int Xfl_HeaderPos;
    internal static byte Xfl_FastestAlgorithm;
    internal static byte Xfl_MaxCompressionSlowestAlgorithm;
}
internal class System.IO.Compression.GZipDecoder : object {
    public void Reset();
    public sealed virtual bool ReadHeader(InputBuffer input);
    public sealed virtual bool ReadFooter(InputBuffer input);
    public sealed virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int copied);
    public sealed virtual void Validate();
}
internal class System.IO.Compression.GZipFormatter : object {
    internal GZipFormatter(int compressionLevel);
    public sealed virtual Byte[] GetHeader();
    public sealed virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public sealed virtual Byte[] GetFooter();
    internal void WriteUInt32(Byte[] b, UInt32 value, int startIndex);
}
public class System.IO.Compression.GZipStream : Stream {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream BaseStream { get; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionLevel compressionLevel);
    public GZipStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual void Write(Byte[] array, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public Stream get_BaseStream();
}
internal class System.IO.Compression.HuffmanTree : object {
    internal static int MaxLiteralTreeElements;
    internal static int MaxDistTreeElements;
    internal static int EndOfBlockCode;
    internal static int NumberOfCodeLengthTreeElements;
    public static HuffmanTree StaticLiteralLengthTree { get; }
    public static HuffmanTree StaticDistanceTree { get; }
    private static HuffmanTree();
    public HuffmanTree(Byte[] codeLengths);
    public static HuffmanTree get_StaticLiteralLengthTree();
    public static HuffmanTree get_StaticDistanceTree();
    public int GetNextSymbol(InputBuffer input);
}
internal interface System.IO.Compression.IDeflater {
    public abstract virtual bool NeedsInput();
    public abstract virtual void SetInput(Byte[] inputBuffer, int startIndex, int count);
    public abstract virtual int GetDeflateOutput(Byte[] outputBuffer);
    public abstract virtual bool Finish(Byte[] outputBuffer, Int32& bytesRead);
}
internal interface System.IO.Compression.IFileFormatReader {
    public abstract virtual bool ReadHeader(InputBuffer input);
    public abstract virtual bool ReadFooter(InputBuffer input);
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual void Validate();
}
internal interface System.IO.Compression.IFileFormatWriter {
    public abstract virtual Byte[] GetHeader();
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual Byte[] GetFooter();
}
internal interface System.IO.Compression.IInflater {
    public int AvailableOutput { get; }
    public abstract virtual int get_AvailableOutput();
    public abstract virtual int Inflate(Byte[] bytes, int offset, int length);
    public abstract virtual bool Finished();
    public abstract virtual bool NeedsInput();
    public abstract virtual void SetInput(Byte[] inputBytes, int offset, int length);
}
internal class System.IO.Compression.Inflater : object {
    public int AvailableOutput { get; }
    internal Inflater(IFileFormatReader reader);
    private static Inflater();
    internal void SetFileFormatReader(IFileFormatReader reader);
    public sealed virtual void SetInput(Byte[] inputBytes, int offset, int length);
    public sealed virtual bool Finished();
    public sealed virtual int get_AvailableOutput();
    public sealed virtual bool NeedsInput();
    public sealed virtual int Inflate(Byte[] bytes, int offset, int length);
    public sealed virtual void Dispose();
}
internal enum System.IO.Compression.InflaterState : Enum {
    public int value__;
    public static InflaterState ReadingHeader;
    public static InflaterState ReadingBFinal;
    public static InflaterState ReadingBType;
    public static InflaterState ReadingNumLitCodes;
    public static InflaterState ReadingNumDistCodes;
    public static InflaterState ReadingNumCodeLengthCodes;
    public static InflaterState ReadingCodeLengthCodes;
    public static InflaterState ReadingTreeCodesBefore;
    public static InflaterState ReadingTreeCodesAfter;
    public static InflaterState DecodeTop;
    public static InflaterState HaveInitialLength;
    public static InflaterState HaveFullLength;
    public static InflaterState HaveDistCode;
    public static InflaterState UncompressedAligning;
    public static InflaterState UncompressedByte1;
    public static InflaterState UncompressedByte2;
    public static InflaterState UncompressedByte3;
    public static InflaterState UncompressedByte4;
    public static InflaterState DecodingUncompressed;
    public static InflaterState StartReadingFooter;
    public static InflaterState ReadingFooter;
    public static InflaterState VerifyingFooter;
    public static InflaterState Done;
}
internal class System.IO.Compression.InflaterZlib : object {
    public int AvailableOutput { get; }
    internal InflaterZlib(int windowBits);
    public sealed virtual int get_AvailableOutput();
    public sealed virtual bool Finished();
    public sealed virtual int Inflate(Byte[] bytes, int offset, int length);
    public sealed virtual bool NeedsInput();
    public sealed virtual void SetInput(Byte[] inputBuffer, int startIndex, int count);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual override void Finalize();
}
internal class System.IO.Compression.InputBuffer : object {
    public int AvailableBits { get; }
    public int AvailableBytes { get; }
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public bool EnsureBitsAvailable(int count);
    public UInt32 TryLoad16Bits();
    public int GetBits(int count);
    public int CopyTo(Byte[] output, int offset, int length);
    public bool NeedsInput();
    public void SetInput(Byte[] buffer, int offset, int length);
    public void SkipBits(int n);
    public void SkipToByteBoundary();
}
internal class System.IO.Compression.Match : object {
    internal MatchState State { get; internal set; }
    internal int Position { get; internal set; }
    internal int Length { get; internal set; }
    internal byte Symbol { get; internal set; }
    internal MatchState get_State();
    internal void set_State(MatchState value);
    internal int get_Position();
    internal void set_Position(int value);
    internal int get_Length();
    internal void set_Length(int value);
    internal byte get_Symbol();
    internal void set_Symbol(byte value);
}
internal class System.IO.Compression.OutputBuffer : object {
    internal int BytesWritten { get; }
    internal int FreeBytes { get; }
    internal int BitsInBuffer { get; }
    internal void UpdateBuffer(Byte[] output);
    internal int get_BytesWritten();
    internal int get_FreeBytes();
    internal void WriteUInt16(ushort value);
    internal void WriteBits(int n, UInt32 bits);
    internal void FlushBits();
    internal void WriteBytes(Byte[] byteArray, int offset, int count);
    internal int get_BitsInBuffer();
    internal BufferState DumpState();
    internal void RestoreState(BufferState state);
}
internal class System.IO.Compression.OutputWindow : object {
    public int FreeBytes { get; }
    public int AvailableBytes { get; }
    public void Write(byte b);
    public void WriteLengthDistance(int length, int distance);
    public int CopyFrom(InputBuffer input, int length);
    public int get_FreeBytes();
    public int get_AvailableBytes();
    public int CopyTo(Byte[] output, int offset, int length);
}
internal class System.IO.Compression.ZLibException : IOException {
    public string ZLibContext { get; }
    public int ZLibErrorCode { get; }
    public string ZLibErrorMessage { get; }
    public ZLibException(string message, string zlibErrorContext, int zlibErrorCode, string zlibErrorMessage);
    public ZLibException(string message);
    public ZLibException(string message, Exception inner);
    protected ZLibException(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public string get_ZLibContext();
    public int get_ZLibErrorCode();
    public string get_ZLibErrorMessage();
}
internal static class System.IO.Compression.ZLibNative : object {
    public static string ZLibNativeDllName;
    public static string ZLibVersion;
    internal static IntPtr ZNullPtr;
    public static int Deflate_DefaultWindowBits;
    public static int Deflate_DefaultMemLevel;
    private static ZLibNative();
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle);
    [SecurityCriticalAttribute]
public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle, int windowBits);
    [SecurityCriticalAttribute]
public static int ZLibCompileFlags();
}
internal static class System.IO.Direct : object {
    public static int FILE_ACTION_ADDED;
    public static int FILE_ACTION_REMOVED;
    public static int FILE_ACTION_MODIFIED;
    public static int FILE_ACTION_RENAMED_OLD_NAME;
    public static int FILE_ACTION_RENAMED_NEW_NAME;
    public static int FILE_NOTIFY_CHANGE_FILE_NAME;
    public static int FILE_NOTIFY_CHANGE_DIR_NAME;
    public static int FILE_NOTIFY_CHANGE_NAME;
    public static int FILE_NOTIFY_CHANGE_ATTRIBUTES;
    public static int FILE_NOTIFY_CHANGE_SIZE;
    public static int FILE_NOTIFY_CHANGE_LAST_WRITE;
    public static int FILE_NOTIFY_CHANGE_LAST_ACCESS;
    public static int FILE_NOTIFY_CHANGE_CREATION;
    public static int FILE_NOTIFY_CHANGE_SECURITY;
}
public class System.IO.ErrorEventArgs : EventArgs {
    public ErrorEventArgs(Exception exception);
    public virtual Exception GetException();
}
public class System.IO.ErrorEventHandler : MulticastDelegate {
    public ErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.IO.FileSystemEventArgs : EventArgs {
    public WatcherChangeTypes ChangeType { get; }
    public string FullPath { get; }
    public string Name { get; }
    public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name);
    public WatcherChangeTypes get_ChangeType();
    public string get_FullPath();
    public string get_Name();
}
public class System.IO.FileSystemEventHandler : MulticastDelegate {
    public FileSystemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FileSystemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FileSystemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultEventAttribute("Changed")]
[IODescriptionAttribute("FileSystemWatcherDesc")]
public class System.IO.FileSystemWatcher : Component {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[IODescriptionAttribute("FSW_ChangedFilter")]
public NotifyFilters NotifyFilter { get; public set; }
    [DefaultValueAttribute("False")]
[IODescriptionAttribute("FSW_Enabled")]
public bool EnableRaisingEvents { get; public set; }
    [DefaultValueAttribute("*.*")]
[IODescriptionAttribute("FSW_Filter")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SettingsBindableAttribute("True")]
public string Filter { get; public set; }
    [DefaultValueAttribute("False")]
[IODescriptionAttribute("FSW_IncludeSubdirectories")]
public bool IncludeSubdirectories { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("8192")]
public int InternalBufferSize { get; public set; }
    [DefaultValueAttribute("")]
[IODescriptionAttribute("FSW_Path")]
[EditorAttribute("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[TypeConverterAttribute("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
[SettingsBindableAttribute("True")]
public string Path { get; public set; }
    [BrowsableAttribute("False")]
public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[IODescriptionAttribute("FSW_SynchronizingObject")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    private static FileSystemWatcher();
    public FileSystemWatcher(string path);
    public FileSystemWatcher(string path, string filter);
    public NotifyFilters get_NotifyFilter();
    public void set_NotifyFilter(NotifyFilters value);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_IncludeSubdirectories();
    public void set_IncludeSubdirectories(bool value);
    public int get_InternalBufferSize();
    public void set_InternalBufferSize(int value);
    public string get_Path();
    public void set_Path(string value);
    public virtual ISite get_Site();
    public virtual void set_Site(ISite value);
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public void add_Changed(FileSystemEventHandler value);
    public void remove_Changed(FileSystemEventHandler value);
    public void add_Created(FileSystemEventHandler value);
    public void remove_Created(FileSystemEventHandler value);
    public void add_Deleted(FileSystemEventHandler value);
    public void remove_Deleted(FileSystemEventHandler value);
    public void add_Error(ErrorEventHandler value);
    public void remove_Error(ErrorEventHandler value);
    public void add_Renamed(RenamedEventHandler value);
    public void remove_Renamed(RenamedEventHandler value);
    public sealed virtual void BeginInit();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    protected void OnChanged(FileSystemEventArgs e);
    protected void OnCreated(FileSystemEventArgs e);
    protected void OnDeleted(FileSystemEventArgs e);
    protected void OnError(ErrorEventArgs e);
    protected void OnRenamed(RenamedEventArgs e);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
    public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
}
public class System.IO.InternalBufferOverflowException : SystemException {
    public InternalBufferOverflowException(string message);
    public InternalBufferOverflowException(string message, Exception inner);
    protected InternalBufferOverflowException(SerializationInfo info, StreamingContext context);
}
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
    internal InvalidDataException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("32767")]
public class System.IO.IODescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public IODescriptionAttribute(string description);
    public virtual string get_Description();
}
[FlagsAttribute]
public enum System.IO.NotifyFilters : Enum {
    public int value__;
    public static NotifyFilters FileName;
    public static NotifyFilters DirectoryName;
    public static NotifyFilters Attributes;
    public static NotifyFilters Size;
    public static NotifyFilters LastWrite;
    public static NotifyFilters LastAccess;
    public static NotifyFilters CreationTime;
    public static NotifyFilters Security;
}
internal static class System.IO.PatternMatcher : object {
    public static bool StrictMatchPattern(string expression, string name);
}
public enum System.IO.Ports.Handshake : Enum {
    public int value__;
    public static Handshake None;
    public static Handshake XOnXOff;
    public static Handshake RequestToSend;
    public static Handshake RequestToSendXOnXOff;
}
internal static class System.IO.Ports.InternalResources : object {
    internal static void EndOfFile();
    internal static string GetMessage(int errorCode);
    internal static void FileNotOpen();
    internal static void WrongAsyncResult();
    internal static void EndReadCalledTwice();
    internal static void EndWriteCalledTwice();
    internal static void WinIOError();
    internal static void WinIOError(string str);
    internal static void WinIOError(int errorCode, string str);
    internal static int MakeHRFromErrorCode(int errorCode);
}
public enum System.IO.Ports.Parity : Enum {
    public int value__;
    public static Parity None;
    public static Parity Odd;
    public static Parity Even;
    public static Parity Mark;
    public static Parity Space;
}
public enum System.IO.Ports.SerialData : Enum {
    public int value__;
    public static SerialData Chars;
    public static SerialData Eof;
}
public class System.IO.Ports.SerialDataReceivedEventArgs : EventArgs {
    internal SerialData receiveType;
    public SerialData EventType { get; }
    internal SerialDataReceivedEventArgs(SerialData eventCode);
    public SerialData get_EventType();
}
public class System.IO.Ports.SerialDataReceivedEventHandler : MulticastDelegate {
    public SerialDataReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialDataReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Ports.SerialError : Enum {
    public int value__;
    public static SerialError TXFull;
    public static SerialError RXOver;
    public static SerialError Overrun;
    public static SerialError RXParity;
    public static SerialError Frame;
}
public class System.IO.Ports.SerialErrorReceivedEventArgs : EventArgs {
    public SerialError EventType { get; }
    internal SerialErrorReceivedEventArgs(SerialError eventCode);
    public SerialError get_EventType();
}
public class System.IO.Ports.SerialErrorReceivedEventHandler : MulticastDelegate {
    public SerialErrorReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialErrorReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.IO.Ports.SerialPinChange : Enum {
    public int value__;
    public static SerialPinChange CtsChanged;
    public static SerialPinChange DsrChanged;
    public static SerialPinChange CDChanged;
    public static SerialPinChange Ring;
    public static SerialPinChange Break;
}
public class System.IO.Ports.SerialPinChangedEventArgs : EventArgs {
    public SerialPinChange EventType { get; }
    internal SerialPinChangedEventArgs(SerialPinChange eventCode);
    public SerialPinChange get_EventType();
}
public class System.IO.Ports.SerialPinChangedEventHandler : MulticastDelegate {
    public SerialPinChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SerialPinChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MonitoringDescriptionAttribute("SerialPortDesc")]
public class System.IO.Ports.SerialPort : Component {
    public static int InfiniteTimeout;
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public Stream BaseStream { get; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("9600")]
[MonitoringDescriptionAttribute("BaudRate")]
public int BaudRate { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool BreakState { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int BytesToWrite { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public int BytesToRead { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool CDHolding { get; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool CtsHolding { get; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("8")]
[MonitoringDescriptionAttribute("DataBits")]
public int DataBits { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("DiscardNull")]
public bool DiscardNull { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
public bool DsrHolding { get; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("DtrEnable")]
public bool DtrEnable { get; public set; }
    [BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[MonitoringDescriptionAttribute("Encoding")]
public Encoding Encoding { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("Handshake")]
public Handshake Handshake { get; public set; }
    [BrowsableAttribute("False")]
public bool IsOpen { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("
")]
[MonitoringDescriptionAttribute("NewLine")]
public string NewLine { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("Parity")]
public Parity Parity { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("63")]
[MonitoringDescriptionAttribute("ParityReplace")]
public byte ParityReplace { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("COM1")]
[MonitoringDescriptionAttribute("PortName")]
public string PortName { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("4096")]
[MonitoringDescriptionAttribute("ReadBufferSize")]
public int ReadBufferSize { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("-1")]
[MonitoringDescriptionAttribute("ReadTimeout")]
public int ReadTimeout { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("1")]
[MonitoringDescriptionAttribute("ReceivedBytesThreshold")]
public int ReceivedBytesThreshold { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("False")]
[MonitoringDescriptionAttribute("RtsEnable")]
public bool RtsEnable { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[MonitoringDescriptionAttribute("StopBits")]
public StopBits StopBits { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("2048")]
[MonitoringDescriptionAttribute("WriteBufferSize")]
public int WriteBufferSize { get; public set; }
    [BrowsableAttribute("True")]
[DefaultValueAttribute("-1")]
[MonitoringDescriptionAttribute("WriteTimeout")]
public int WriteTimeout { get; public set; }
    public SerialPort(IContainer container);
    public SerialPort(string portName);
    public SerialPort(string portName, int baudRate);
    public SerialPort(string portName, int baudRate, Parity parity);
    public SerialPort(string portName, int baudRate, Parity parity, int dataBits);
    public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits);
    [CompilerGeneratedAttribute]
public void add_ErrorReceived(SerialErrorReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ErrorReceived(SerialErrorReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PinChanged(SerialPinChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PinChanged(SerialPinChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DataReceived(SerialDataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DataReceived(SerialDataReceivedEventHandler value);
    public Stream get_BaseStream();
    public int get_BaudRate();
    public void set_BaudRate(int value);
    public bool get_BreakState();
    public void set_BreakState(bool value);
    public int get_BytesToWrite();
    public int get_BytesToRead();
    public bool get_CDHolding();
    public bool get_CtsHolding();
    public int get_DataBits();
    public void set_DataBits(int value);
    public bool get_DiscardNull();
    public void set_DiscardNull(bool value);
    public bool get_DsrHolding();
    public bool get_DtrEnable();
    public void set_DtrEnable(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public Handshake get_Handshake();
    public void set_Handshake(Handshake value);
    public bool get_IsOpen();
    public string get_NewLine();
    public void set_NewLine(string value);
    public Parity get_Parity();
    public void set_Parity(Parity value);
    public byte get_ParityReplace();
    public void set_ParityReplace(byte value);
    public string get_PortName();
    public void set_PortName(string value);
    public int get_ReadBufferSize();
    public void set_ReadBufferSize(int value);
    public int get_ReadTimeout();
    public void set_ReadTimeout(int value);
    public int get_ReceivedBytesThreshold();
    public void set_ReceivedBytesThreshold(int value);
    public bool get_RtsEnable();
    public void set_RtsEnable(bool value);
    public StopBits get_StopBits();
    public void set_StopBits(StopBits value);
    public int get_WriteBufferSize();
    public void set_WriteBufferSize(int value);
    public int get_WriteTimeout();
    public void set_WriteTimeout(int value);
    public void Close();
    protected virtual void Dispose(bool disposing);
    public void DiscardInBuffer();
    public void DiscardOutBuffer();
    public static String[] GetPortNames();
    public void Open();
    public int Read(Byte[] buffer, int offset, int count);
    public int ReadChar();
    public int Read(Char[] buffer, int offset, int count);
    public int ReadByte();
    public string ReadExisting();
    public string ReadLine();
    public string ReadTo(string value);
    public void Write(string text);
    public void Write(Char[] buffer, int offset, int count);
    public void Write(Byte[] buffer, int offset, int count);
    public void WriteLine(string text);
}
internal class System.IO.Ports.SerialStream : Stream {
    internal SafeFileHandle _handle;
    internal EventLoopRunner eventRunner;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    unknown int BaudRate {internal set; }
    public bool BreakState { get; public set; }
    unknown int DataBits {internal set; }
    unknown bool DiscardNull {internal set; }
    internal bool DtrEnable { get; internal set; }
    unknown Handshake Handshake {internal set; }
    internal bool IsOpen { get; }
    unknown Parity Parity {internal set; }
    unknown byte ParityReplace {internal set; }
    public int ReadTimeout { get; public set; }
    internal bool RtsEnable { get; internal set; }
    unknown StopBits StopBits {internal set; }
    public int WriteTimeout { get; public set; }
    internal bool CDHolding { get; }
    internal bool CtsHolding { get; }
    internal bool DsrHolding { get; }
    internal int BytesToRead { get; }
    internal int BytesToWrite { get; }
    internal SerialStream(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits, int readTimeout, int writeTimeout, Handshake handshake, bool dtrEnable, bool rtsEnable, bool discardNull, byte parityReplace);
    private static SerialStream();
    [CompilerGeneratedAttribute]
internal void add_DataReceived(SerialDataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DataReceived(SerialDataReceivedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_PinChanged(SerialPinChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PinChanged(SerialPinChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_ErrorReceived(SerialErrorReceivedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ErrorReceived(SerialErrorReceivedEventHandler value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal void set_BaudRate(int value);
    public bool get_BreakState();
    public void set_BreakState(bool value);
    internal void set_DataBits(int value);
    internal void set_DiscardNull(bool value);
    internal bool get_DtrEnable();
    internal void set_DtrEnable(bool value);
    internal void set_Handshake(Handshake value);
    internal bool get_IsOpen();
    internal void set_Parity(Parity value);
    internal void set_ParityReplace(byte value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    internal bool get_RtsEnable();
    internal void set_RtsEnable(bool value);
    internal void set_StopBits(StopBits value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    internal bool get_CDHolding();
    internal bool get_CtsHolding();
    internal bool get_DsrHolding();
    internal int get_BytesToRead();
    internal int get_BytesToWrite();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    internal void DiscardInBuffer();
    internal void DiscardOutBuffer();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] array, int offset, int count);
    internal int Read(Byte[] array, int offset, int count, int timeout);
    public virtual int ReadByte();
    internal int ReadByte(int timeout);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    internal void SetBufferSizes(int readBufferSize, int writeBufferSize);
    public virtual void Write(Byte[] array, int offset, int count);
    internal void Write(Byte[] array, int offset, int count, int timeout);
    public virtual void WriteByte(byte value);
    internal void WriteByte(byte value, int timeout);
    internal int GetDcbFlag(int whichFlag);
    internal void SetDcbFlag(int whichFlag, int setting);
}
public enum System.IO.Ports.StopBits : Enum {
    public int value__;
    public static StopBits None;
    public static StopBits One;
    public static StopBits Two;
    public static StopBits OnePointFive;
}
public class System.IO.RenamedEventArgs : FileSystemEventArgs {
    public string OldFullPath { get; }
    public string OldName { get; }
    public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName);
    public string get_OldFullPath();
    public string get_OldName();
}
public class System.IO.RenamedEventHandler : MulticastDelegate {
    public RenamedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RenamedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RenamedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.IO.WaitForChangedResult : ValueType {
    private WatcherChangeTypes changeType;
    private string name;
    private string oldName;
    private bool timedOut;
    internal static WaitForChangedResult TimedOutResult;
    public WatcherChangeTypes ChangeType { get; public set; }
    public string Name { get; public set; }
    public string OldName { get; public set; }
    public bool TimedOut { get; public set; }
    internal WaitForChangedResult(WatcherChangeTypes changeType, string name, bool timedOut);
    internal WaitForChangedResult(WatcherChangeTypes changeType, string name, string oldName, bool timedOut);
    private static WaitForChangedResult();
    public WatcherChangeTypes get_ChangeType();
    public void set_ChangeType(WatcherChangeTypes value);
    public string get_Name();
    public void set_Name(string value);
    public string get_OldName();
    public void set_OldName(string value);
    public bool get_TimedOut();
    public void set_TimedOut(bool value);
}
[FlagsAttribute]
public enum System.IO.WatcherChangeTypes : Enum {
    public int value__;
    public static WatcherChangeTypes Created;
    public static WatcherChangeTypes Deleted;
    public static WatcherChangeTypes Changed;
    public static WatcherChangeTypes Renamed;
    public static WatcherChangeTypes All;
}
internal static class System.IPv4AddressHelper : object {
    internal static long Invalid;
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& isLoopback);
    internal static int ParseHostNumber(string str, int start, int end);
    internal static bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme);
    internal static bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile);
    internal static long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile);
}
internal static class System.IPv6AddressHelper : object {
    internal static string ParseCanonicalName(string str, int start, Boolean& isLoopback, String& scopeId);
    internal static string CreateCanonicalName(UInt16* numbers);
    internal static bool IsValid(Char* name, int start, Int32& end);
    internal static bool IsValidStrict(Char* name, int start, Int32& end);
    internal static bool Parse(string address, UInt16* numbers, int start, String& scopeId);
}
internal static class System.IriHelper : object {
    internal static bool CheckIriUnicodeRange(char unicode, bool isQuery);
    internal static bool CheckIriUnicodeRange(char highSurr, char lowSurr, Boolean& surrogatePair, bool isQuery);
    internal static bool CheckIsReserved(char ch, UriComponents component);
    internal static string EscapeUnescapeIri(Char* pInput, int start, int end, UriComponents component);
}
public class System.LdapStyleUriParser : UriParser {
}
internal static class System.LocalAppContext : object {
    private static LocalAppContext();
    public static bool IsSwitchEnabled(string switchName);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
internal static class System.LocalAppContextSwitches : object {
    internal static string MemberDescriptorEqualsReturnsFalseIfEquivalentName;
    internal static string DontEnableStrictRFC3986ReservedCharacterSetsName;
    internal static string DontKeepUnicodeBidiFormattingCharactersName;
    internal static string DisableTempFileCollectionDirectoryFeatureName;
    internal static string DontEnableSchUseStrongCryptoName;
    internal static string AllocateOverlappedOnDemandName;
    internal static string DontEnableSchSendAuxRecordName;
    internal static string DontEnableSystemDefaultTlsVersionsName;
    internal static string DontEnableTlsAlertsName;
    internal static string DontCheckCertificateEKUsName;
    internal static string DontCheckCertificateRevocationName;
    internal static string DoNotCatchSerialStreamThreadExceptionsName;
    internal static string DoNotValidateX509KeyStorageFlagsName;
    internal static string DoNotUseNativeZipLibraryForDecompressionName;
    public static bool MemberDescriptorEqualsReturnsFalseIfEquivalent { get; }
    public static bool DontEnableStrictRFC3986ReservedCharacterSets { get; }
    public static bool DontKeepUnicodeBidiFormattingCharacters { get; }
    public static bool DisableTempFileCollectionDirectoryFeature { get; }
    public static bool DontEnableSchUseStrongCrypto { get; }
    public static bool AllocateOverlappedOnDemand { get; }
    public static bool DontEnableSchSendAuxRecord { get; }
    public static bool DontEnableSystemDefaultTlsVersions { get; }
    public static bool DontEnableTlsAlerts { get; }
    public static bool DontCheckCertificateEKUs { get; }
    public static bool DontCheckCertificateRevocation { get; }
    public static bool DoNotCatchSerialStreamThreadExceptions { get; }
    public static bool DoNotValidateX509KeyStorageFlags { get; }
    public static bool DoNotUseNativeZipLibraryForDecompression { get; }
    public static bool get_MemberDescriptorEqualsReturnsFalseIfEquivalent();
    public static bool get_DontEnableStrictRFC3986ReservedCharacterSets();
    public static bool get_DontKeepUnicodeBidiFormattingCharacters();
    public static bool get_DisableTempFileCollectionDirectoryFeature();
    public static bool get_DontEnableSchUseStrongCrypto();
    public static bool get_AllocateOverlappedOnDemand();
    public static bool get_DontEnableSchSendAuxRecord();
    public static bool get_DontEnableSystemDefaultTlsVersions();
    public static bool get_DontEnableTlsAlerts();
    public static bool get_DontCheckCertificateEKUs();
    public static bool get_DontCheckCertificateRevocation();
    public static bool get_DoNotCatchSerialStreamThreadExceptions();
    public static bool get_DoNotValidateX509KeyStorageFlags();
    public static bool get_DoNotUseNativeZipLibraryForDecompression();
}
[ToolboxItemAttribute("False")]
public class System.Media.SoundPlayer : Component {
    public int LoadTimeout { get; public set; }
    public string SoundLocation { get; public set; }
    public Stream Stream { get; public set; }
    public bool IsLoadCompleted { get; }
    public object Tag { get; public set; }
    public SoundPlayer(string soundLocation);
    public SoundPlayer(Stream stream);
    protected SoundPlayer(SerializationInfo serializationInfo, StreamingContext context);
    private static SoundPlayer();
    public int get_LoadTimeout();
    public void set_LoadTimeout(int value);
    public string get_SoundLocation();
    public void set_SoundLocation(string value);
    public Stream get_Stream();
    public void set_Stream(Stream value);
    public bool get_IsLoadCompleted();
    public object get_Tag();
    public void set_Tag(object value);
    public void LoadAsync();
    public void Load();
    public void Play();
    public void PlaySync();
    public void PlayLooping();
    public void Stop();
    public void add_LoadCompleted(AsyncCompletedEventHandler value);
    public void remove_LoadCompleted(AsyncCompletedEventHandler value);
    public void add_SoundLocationChanged(EventHandler value);
    public void remove_SoundLocationChanged(EventHandler value);
    public void add_StreamChanged(EventHandler value);
    public void remove_StreamChanged(EventHandler value);
    protected virtual void OnLoadCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnSoundLocationChanged(EventArgs e);
    protected virtual void OnStreamChanged(EventArgs e);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Media.SystemSound : object {
    internal SystemSound(int soundType);
    public void Play();
}
public class System.Media.SystemSounds : object {
    public static SystemSound Asterisk { get; }
    public static SystemSound Beep { get; }
    public static SystemSound Exclamation { get; }
    public static SystemSound Hand { get; }
    public static SystemSound Question { get; }
    public static SystemSound get_Asterisk();
    public static SystemSound get_Beep();
    public static SystemSound get_Exclamation();
    public static SystemSound get_Hand();
    public static SystemSound get_Question();
}
internal class System.Net._CERT_CHAIN_ELEMENT : ValueType {
    public UInt32 cbSize;
    public IntPtr pCertContext;
}
internal class System.Net.AddressInfo : ValueType {
    internal AddressInfoHints ai_flags;
    internal AddressFamily ai_family;
    internal SocketType ai_socktype;
    internal ProtocolFamily ai_protocol;
    internal int ai_addrlen;
    internal SByte* ai_canonname;
    internal Byte* ai_addr;
    internal AddressInfo* ai_next;
}
[FlagsAttribute]
internal enum System.Net.AddressInfoHints : Enum {
    public int value__;
    public static AddressInfoHints AI_PASSIVE;
    public static AddressInfoHints AI_CANONNAME;
    public static AddressInfoHints AI_NUMERICHOST;
    public static AddressInfoHints AI_FQDN;
}
[FlagsAttribute]
internal enum System.Net.Alg : Enum {
    public int value__;
    public static Alg Any;
    public static Alg ClassSignture;
    public static Alg ClassEncrypt;
    public static Alg ClassHash;
    public static Alg ClassKeyXch;
    public static Alg TypeRSA;
    public static Alg TypeBlock;
    public static Alg TypeStream;
    public static Alg TypeDH;
    public static Alg NameDES;
    public static Alg NameRC2;
    public static Alg Name3DES;
    public static Alg NameAES_128;
    public static Alg NameAES_192;
    public static Alg NameAES_256;
    public static Alg NameAES;
    public static Alg NameRC4;
    public static Alg NameMD5;
    public static Alg NameSHA;
    public static Alg NameSHA256;
    public static Alg NameSHA384;
    public static Alg NameSHA512;
    public static Alg NameDH_Ephem;
}
internal class System.Net.AsyncProtocolCallback : MulticastDelegate {
    public AsyncProtocolCallback(object object, IntPtr method);
    public virtual void Invoke(AsyncProtocolRequest asyncRequest);
    public virtual IAsyncResult BeginInvoke(AsyncProtocolRequest asyncRequest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.AsyncProtocolRequest : object {
    public LazyAsyncResult UserAsyncResult;
    public int Result;
    public object AsyncState;
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    internal object AsyncObject { get; }
    public bool MustCompleteSynchronously { get; }
    internal bool IsUserCompleted { get; }
    public AsyncProtocolRequest(LazyAsyncResult userAsyncResult);
    public void SetNextRequest(Byte[] buffer, int offset, int count, AsyncProtocolCallback callback);
    internal object get_AsyncObject();
    internal void CompleteRequest(int result);
    public bool get_MustCompleteSynchronously();
    internal void CompleteWithError(Exception e);
    internal void CompleteUser();
    internal void CompleteUser(object userResult);
    internal bool get_IsUserCompleted();
}
internal class System.Net.AsyncRequestContext : RequestContextBase {
    internal NativeOverlapped* NativeOverlapped { get; }
    internal AsyncRequestContext(ListenerAsyncResult result);
    internal void Reset(ulong requestId, UInt32 size);
    protected virtual void OnReleasePins();
    protected virtual void Dispose(bool disposing);
    internal NativeOverlapped* get_NativeOverlapped();
}
public class System.Net.AuthenticationManager : object {
    internal static string authenticationManagerRoot;
    internal static string configHighPerformance;
    internal static string configPrefixLookupMaxCount;
    public static ICredentialPolicy CredentialPolicy { get; public set; }
    public static StringDictionary CustomTargetNameDictionary { get; }
    internal static SpnDictionary SpnDictionary { get; }
    internal static bool OSSupportsExtendedProtection { get; }
    internal static bool SspSupportsExtendedProtection { get; }
    public static IEnumerator RegisteredModules { get; }
    private static AuthenticationManager();
    public static ICredentialPolicy get_CredentialPolicy();
    public static void set_CredentialPolicy(ICredentialPolicy value);
    public static StringDictionary get_CustomTargetNameDictionary();
    internal static SpnDictionary get_SpnDictionary();
    internal static void EnsureConfigLoaded();
    internal static bool get_OSSupportsExtendedProtection();
    internal static bool get_SspSupportsExtendedProtection();
    public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public static void Register(IAuthenticationModule authenticationModule);
    public static void Unregister(IAuthenticationModule authenticationModule);
    public static void Unregister(string authenticationScheme);
    public static IEnumerator get_RegisteredModules();
    internal static void BindModule(Uri uri, Authorization response, IAuthenticationModule module);
    internal static int FindSubstringNotInQuotes(string challenge, string signature);
    internal static int SplitNoQuotes(string challenge, Int32& offset);
    internal static Authorization GetGroupAuthorization(IAuthenticationModule thisModule, string token, bool finished, NTAuthentication authSession, bool shareAuthenticatedConnections, bool mutualAuth);
}
internal class System.Net.AuthenticationManager2 : AuthenticationManagerBase {
    public IEnumerator RegisteredModules { get; }
    public AuthenticationManager2(int maxPrefixLookupEntries);
    public virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public virtual void Register(IAuthenticationModule authenticationModule);
    public virtual void Unregister(IAuthenticationModule authenticationModule);
    public virtual void Unregister(string authenticationScheme);
    public virtual IEnumerator get_RegisteredModules();
    public virtual void BindModule(Uri uri, Authorization response, IAuthenticationModule module);
}
internal abstract class System.Net.AuthenticationManagerBase : object {
    public ICredentialPolicy CredentialPolicy { get; public set; }
    public StringDictionary CustomTargetNameDictionary { get; }
    public SpnDictionary SpnDictionary { get; }
    public bool OSSupportsExtendedProtection { get; }
    public bool SspSupportsExtendedProtection { get; }
    public IEnumerator RegisteredModules { get; }
    private static AuthenticationManagerBase();
    public sealed virtual ICredentialPolicy get_CredentialPolicy();
    public sealed virtual void set_CredentialPolicy(ICredentialPolicy value);
    public virtual void EnsureConfigLoaded();
    public sealed virtual StringDictionary get_CustomTargetNameDictionary();
    public sealed virtual SpnDictionary get_SpnDictionary();
    public sealed virtual bool get_OSSupportsExtendedProtection();
    public sealed virtual bool get_SspSupportsExtendedProtection();
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual void Register(IAuthenticationModule authenticationModule);
    public abstract virtual void Unregister(IAuthenticationModule authenticationModule);
    public abstract virtual void Unregister(string authenticationScheme);
    public abstract virtual IEnumerator get_RegisteredModules();
    public abstract virtual void BindModule(Uri uri, Authorization response, IAuthenticationModule module);
    protected static string generalize(Uri location);
}
internal class System.Net.AuthenticationManagerDefault : AuthenticationManagerBase {
    public IEnumerator RegisteredModules { get; }
    public virtual void EnsureConfigLoaded();
    public virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public virtual void Register(IAuthenticationModule authenticationModule);
    public virtual void Unregister(IAuthenticationModule authenticationModule);
    public virtual void Unregister(string authenticationScheme);
    public virtual IEnumerator get_RegisteredModules();
    public virtual void BindModule(Uri uri, Authorization response, IAuthenticationModule module);
}
[FlagsAttribute]
public enum System.Net.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Digest;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes Ntlm;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes Anonymous;
    public static AuthenticationSchemes IntegratedWindowsAuthentication;
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
internal class System.Net.AuthenticationState : object {
    internal Authorization Authorization;
    internal IAuthenticationModule Module;
    internal string UniqueGroupId;
    internal Uri ChallengedUri;
    internal TransportContext TransportContext { get; internal set; }
    internal HttpResponseHeader AuthenticateHeader { get; }
    internal string AuthorizationHeader { get; }
    internal HttpStatusCode StatusCodeMatch { get; }
    internal AuthenticationState(bool isProxyAuth);
    internal NTAuthentication GetSecurityContext(IAuthenticationModule module);
    internal void SetSecurityContext(NTAuthentication securityContext, IAuthenticationModule module);
    internal TransportContext get_TransportContext();
    internal void set_TransportContext(TransportContext value);
    internal HttpResponseHeader get_AuthenticateHeader();
    internal string get_AuthorizationHeader();
    internal HttpStatusCode get_StatusCodeMatch();
    internal SpnToken GetComputeSpn(HttpWebRequest httpWebRequest);
    internal void PreAuthIfNeeded(HttpWebRequest httpWebRequest, ICredentials authInfo);
    internal bool AttemptAuthenticate(HttpWebRequest httpWebRequest, ICredentials authInfo);
    internal void ClearAuthReq(HttpWebRequest httpWebRequest);
    internal void Update(HttpWebRequest httpWebRequest);
    internal void ClearSession();
    internal void ClearSession(HttpWebRequest httpWebRequest);
}
internal class System.Net.AuthIdentity : ValueType {
    internal string UserName;
    internal int UserNameLength;
    internal string Domain;
    internal int DomainLength;
    internal string Password;
    internal int PasswordLength;
    internal int Flags;
    internal AuthIdentity(string userName, string password, string domain);
    public virtual string ToString();
}
public class System.Net.Authorization : object {
    public string Message { get; }
    public string ConnectionGroupId { get; }
    public bool Complete { get; }
    public String[] ProtectionRealm { get; public set; }
    public bool MutuallyAuthenticated { get; public set; }
    public Authorization(string token);
    public Authorization(string token, bool finished);
    public Authorization(string token, bool finished, string connectionGroupId);
    internal Authorization(string token, bool finished, string connectionGroupId, bool mutualAuth);
    public string get_Message();
    public string get_ConnectionGroupId();
    public bool get_Complete();
    internal void SetComplete(bool complete);
    public String[] get_ProtectionRealm();
    public void set_ProtectionRealm(String[] value);
    public bool get_MutuallyAuthenticated();
    public void set_MutuallyAuthenticated(bool value);
}
internal class System.Net.AutoWebProxyScriptEngine : object {
    internal bool AutomaticallyDetectSettings { get; internal set; }
    internal Uri AutomaticConfigurationScript { get; internal set; }
    internal ICredentials Credentials { get; }
    internal AutoWebProxyScriptEngine(WebProxy proxy, bool useRegistry);
    internal void Abort(Int32& syncStatus);
    internal bool get_AutomaticallyDetectSettings();
    internal void set_AutomaticallyDetectSettings(bool value);
    internal Uri get_AutomaticConfigurationScript();
    internal void set_AutomaticConfigurationScript(Uri value);
    internal ICredentials get_Credentials();
    internal bool GetProxies(Uri destination, IList`1& proxyList);
    internal bool GetProxies(Uri destination, IList`1& proxyList, Int32& syncStatus);
    internal WebProxyData GetWebProxyData();
    internal void Close();
    internal void ListenForRegistry();
    internal void CheckForChanges();
}
internal class System.Net.AutoWebProxyScriptWrapper : object {
    internal string ScriptBody { get; }
    internal Byte[] Buffer { get; internal set; }
    internal DateTime LastModified { get; internal set; }
    private static AutoWebProxyScriptWrapper();
    internal void Close();
    protected virtual override void Finalize();
    internal string get_ScriptBody();
    internal Byte[] get_Buffer();
    internal void set_Buffer(Byte[] value);
    internal DateTime get_LastModified();
    internal void set_LastModified(DateTime value);
    internal string FindProxyForURL(string url, string host);
    internal bool Compile(Uri engineScriptLocation, string scriptBody, Byte[] buffer);
}
internal class System.Net.Base64Stream : DelegatedStream {
    public bool CanWrite { get; }
    internal Base64WriteStateInfo WriteState { get; }
    internal Base64Stream(Stream stream, Base64WriteStateInfo writeStateInfo);
    internal Base64Stream(Stream stream, int lineLength);
    internal Base64Stream(Base64WriteStateInfo writeStateInfo);
    private static Base64Stream();
    public virtual bool get_CanWrite();
    internal Base64WriteStateInfo get_WriteState();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.BaseLoggingObject : object {
    internal virtual void EnterFunc(string funcname);
    internal virtual void LeaveFunc(string funcname);
    internal virtual void DumpArrayToConsole();
    internal virtual void PrintLine(string msg);
    internal virtual void DumpArray(bool shouldClose);
    internal virtual void DumpArrayToFile(bool shouldClose);
    internal virtual void Flush();
    internal virtual void Flush(bool close);
    internal virtual void LoggingMonitorTick();
    internal virtual void Dump(Byte[] buffer);
    internal virtual void Dump(Byte[] buffer, int length);
    internal virtual void Dump(Byte[] buffer, int offset, int length);
    internal virtual void Dump(IntPtr pBuffer, int offset, int length);
}
internal abstract class System.Net.BaseWebProxyFinder : object {
    public bool IsValid { get; }
    public bool IsUnrecognizedScheme { get; }
    protected AutoWebProxyState State { get; protected set; }
    protected AutoWebProxyScriptEngine Engine { get; }
    public BaseWebProxyFinder(AutoWebProxyScriptEngine engine);
    public sealed virtual bool get_IsValid();
    public bool get_IsUnrecognizedScheme();
    public abstract virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public abstract virtual void Abort();
    public virtual void Reset();
    public sealed virtual void Dispose();
    protected AutoWebProxyState get_State();
    protected void set_State(AutoWebProxyState value);
    protected AutoWebProxyScriptEngine get_Engine();
    protected abstract virtual void Dispose(bool disposing);
}
internal class System.Net.BasicClient : object {
    internal static string AuthType;
    internal static string Signature;
    internal static int SignatureSize;
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    private static BasicClient();
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual bool get_CanPreAuthenticate();
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    internal static Byte[] EncodingRightGetBytes(string rawString);
}
internal class System.Net.Bindings : ValueType {
    internal int BindingsLength;
    internal IntPtr pBindings;
}
public class System.Net.BindIPEndPoint : MulticastDelegate {
    public BindIPEndPoint(object object, IntPtr method);
    public virtual IPEndPoint Invoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount);
    public virtual IAsyncResult BeginInvoke(ServicePoint servicePoint, IPEndPoint remoteEndPoint, int retryCount, AsyncCallback callback, object object);
    public virtual IPEndPoint EndInvoke(IAsyncResult result);
}
internal class System.Net.Blob : ValueType {
    public int cbSize;
    public int pBlobData;
}
internal enum System.Net.BoundaryType : Enum {
    public int value__;
    public static BoundaryType ContentLength;
    public static BoundaryType Chunked;
    public static BoundaryType Multipart;
    public static BoundaryType None;
    public static BoundaryType Invalid;
}
internal class System.Net.BufferAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public BufferOffsetSize[] Buffers;
    public int Offset;
    public int Count;
    public bool IsWrite;
    public BufferAsyncResult(object asyncObject, BufferOffsetSize[] buffers, object asyncState, AsyncCallback asyncCallback);
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, object asyncState, AsyncCallback asyncCallback);
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, bool isWrite, object asyncState, AsyncCallback asyncCallback);
}
internal class System.Net.BufferedReadStream : DelegatedStream {
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    internal BufferedReadStream(Stream stream);
    internal BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    internal void Push(Byte[] buffer, int offset, int count);
    internal void Append(Byte[] buffer, int offset, int count);
}
internal class System.Net.BufferOffsetSize : object {
    internal Byte[] Buffer;
    internal int Offset;
    internal int Size;
    internal BufferOffsetSize(Byte[] buffer, int offset, int size, bool copyBuffer);
    internal BufferOffsetSize(Byte[] buffer, bool copyBuffer);
}
internal enum System.Net.BufferType : Enum {
    public int value__;
    public static BufferType Empty;
    public static BufferType Data;
    public static BufferType Token;
    public static BufferType Parameters;
    public static BufferType Missing;
    public static BufferType Extra;
    public static BufferType Trailer;
    public static BufferType Header;
    public static BufferType Padding;
    public static BufferType Stream;
    public static BufferType ChannelBindings;
    public static BufferType TargetHost;
    public static BufferType ReadOnlyFlag;
    public static BufferType ReadOnlyWithChecksum;
}
internal static class System.Net.Cache._WinInetCache : object {
    internal static Status LookupInfo(Entry entry);
    internal static SafeUnlockUrlCacheEntryFile LookupFile(Entry entry);
    internal static Status CreateFileName(Entry entry);
    internal static Status Commit(Entry entry);
    internal static Status Update(Entry newEntry, Entry_FC attributes);
    internal static Status Remove(Entry entry);
}
internal abstract class System.Net.Cache.BaseWrapperStream : Stream {
    protected Stream WrappedStream { get; }
    public BaseWrapperStream(Stream wrappedStream);
    protected Stream get_WrappedStream();
    public sealed virtual void TrackRequestLifetime(long requestStartTimestamp);
}
internal enum System.Net.Cache.CacheFreshnessStatus : Enum {
    public int value__;
    public static CacheFreshnessStatus Undefined;
    public static CacheFreshnessStatus Fresh;
    public static CacheFreshnessStatus Stale;
}
internal enum System.Net.Cache.CacheValidationStatus : Enum {
    public int value__;
    public static CacheValidationStatus DoNotUseCache;
    public static CacheValidationStatus Fail;
    public static CacheValidationStatus DoNotTakeFromCache;
    public static CacheValidationStatus RetryResponseFromCache;
    public static CacheValidationStatus RetryResponseFromServer;
    public static CacheValidationStatus ReturnCachedResponse;
    public static CacheValidationStatus CombineCachedAndServerResponse;
    public static CacheValidationStatus CacheResponse;
    public static CacheValidationStatus UpdateResponseInformation;
    public static CacheValidationStatus RemoveFromCache;
    public static CacheValidationStatus DoNotUpdateCache;
    public static CacheValidationStatus Continue;
}
internal class System.Net.Cache.CombinedReadStream : BaseWrapperStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal CombinedReadStream(Stream headStream, Stream tailStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    protected sealed virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    protected virtual void Dispose(bool disposing, CloseExState closeState);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
internal class System.Net.Cache.ForwardingReadStream : BaseWrapperStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal ForwardingReadStream(Stream originalStream, Stream shadowStream, long bytesToSkip, bool throwOnWriteError);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    protected sealed virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    protected virtual void Dispose(bool disposing, CloseExState closeState);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
}
internal class System.Net.Cache.FtpRequestCacheValidator : HttpRequestCacheValidator {
    internal RequestCachePolicy Policy { get; }
    internal FtpRequestCacheValidator(bool strictCacheErrors, TimeSpan unspecifiedMaxAge);
    internal RequestCachePolicy get_Policy();
    internal virtual RequestCacheValidator CreateValidator();
    protected internal virtual CacheValidationStatus ValidateRequest();
    protected internal virtual CacheFreshnessStatus ValidateFreshness();
    protected internal virtual CacheValidationStatus ValidateCache();
    protected internal virtual CacheValidationStatus RevalidateCache();
    protected internal virtual CacheValidationStatus ValidateResponse();
    protected internal virtual CacheValidationStatus UpdateCache();
}
public enum System.Net.Cache.HttpCacheAgeControl : Enum {
    public int value__;
    public static HttpCacheAgeControl None;
    public static HttpCacheAgeControl MinFresh;
    public static HttpCacheAgeControl MaxAge;
    public static HttpCacheAgeControl MaxStale;
    public static HttpCacheAgeControl MaxAgeAndMinFresh;
    public static HttpCacheAgeControl MaxAgeAndMaxStale;
}
internal enum System.Net.Cache.HttpMethod : Enum {
    public int value__;
    public static HttpMethod Other;
    public static HttpMethod Head;
    public static HttpMethod Get;
    public static HttpMethod Post;
    public static HttpMethod Put;
    public static HttpMethod Delete;
    public static HttpMethod Options;
    public static HttpMethod Trace;
    public static HttpMethod Connect;
}
public enum System.Net.Cache.HttpRequestCacheLevel : Enum {
    public int value__;
    public static HttpRequestCacheLevel Default;
    public static HttpRequestCacheLevel BypassCache;
    public static HttpRequestCacheLevel CacheOnly;
    public static HttpRequestCacheLevel CacheIfAvailable;
    public static HttpRequestCacheLevel Revalidate;
    public static HttpRequestCacheLevel Reload;
    public static HttpRequestCacheLevel NoCacheNoStore;
    public static HttpRequestCacheLevel CacheOrNextCacheOnly;
    public static HttpRequestCacheLevel Refresh;
}
public class System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
    internal static HttpRequestCachePolicy BypassCache;
    public HttpRequestCacheLevel Level { get; }
    public DateTime CacheSyncDate { get; }
    internal DateTime InternalCacheSyncDateUtc { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinFresh { get; }
    public TimeSpan MaxStale { get; }
    public HttpRequestCachePolicy(HttpRequestCacheLevel level);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale);
    public HttpRequestCachePolicy(DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate);
    private static HttpRequestCachePolicy();
    public HttpRequestCacheLevel get_Level();
    public DateTime get_CacheSyncDate();
    internal DateTime get_InternalCacheSyncDateUtc();
    public TimeSpan get_MaxAge();
    public TimeSpan get_MinFresh();
    public TimeSpan get_MaxStale();
    public virtual string ToString();
}
internal class System.Net.Cache.HttpRequestCacheValidator : RequestCacheValidator {
    internal static string Warning_110;
    internal static string Warning_111;
    internal static string Warning_112;
    internal static string Warning_113;
    internal static ParseCallback ParseValuesCallback;
    internal HttpStatusCode CacheStatusCode { get; internal set; }
    internal string CacheStatusDescription { get; internal set; }
    internal Version CacheHttpVersion { get; internal set; }
    internal WebHeaderCollection CacheHeaders { get; internal set; }
    internal HttpRequestCachePolicy Policy { get; }
    internal NameValueCollection SystemMeta { get; internal set; }
    internal HttpMethod RequestMethod { get; internal set; }
    internal bool RequestRangeCache { get; internal set; }
    internal bool RequestRangeUser { get; internal set; }
    internal string RequestIfHeader1 { get; internal set; }
    internal string RequestValidator1 { get; internal set; }
    internal string RequestIfHeader2 { get; internal set; }
    internal string RequestValidator2 { get; internal set; }
    internal bool CacheDontUpdateHeaders { get; internal set; }
    internal DateTime CacheDate { get; internal set; }
    internal DateTime CacheExpires { get; internal set; }
    internal DateTime CacheLastModified { get; internal set; }
    internal long CacheEntityLength { get; internal set; }
    internal TimeSpan CacheAge { get; internal set; }
    internal TimeSpan CacheMaxAge { get; internal set; }
    internal bool HeuristicExpiration { get; internal set; }
    internal ResponseCacheControl CacheCacheControl { get; internal set; }
    internal DateTime ResponseDate { get; internal set; }
    internal DateTime ResponseExpires { get; internal set; }
    internal DateTime ResponseLastModified { get; internal set; }
    internal long ResponseEntityLength { get; internal set; }
    internal long ResponseRangeStart { get; internal set; }
    internal long ResponseRangeEnd { get; internal set; }
    internal TimeSpan ResponseAge { get; internal set; }
    internal ResponseCacheControl ResponseCacheControl { get; internal set; }
    internal HttpRequestCacheValidator(bool strictCacheErrors, TimeSpan unspecifiedMaxAge);
    private static HttpRequestCacheValidator();
    internal HttpStatusCode get_CacheStatusCode();
    internal void set_CacheStatusCode(HttpStatusCode value);
    internal string get_CacheStatusDescription();
    internal void set_CacheStatusDescription(string value);
    internal Version get_CacheHttpVersion();
    internal void set_CacheHttpVersion(Version value);
    internal WebHeaderCollection get_CacheHeaders();
    internal void set_CacheHeaders(WebHeaderCollection value);
    internal HttpRequestCachePolicy get_Policy();
    internal NameValueCollection get_SystemMeta();
    internal void set_SystemMeta(NameValueCollection value);
    internal HttpMethod get_RequestMethod();
    internal void set_RequestMethod(HttpMethod value);
    internal bool get_RequestRangeCache();
    internal void set_RequestRangeCache(bool value);
    internal bool get_RequestRangeUser();
    internal void set_RequestRangeUser(bool value);
    internal string get_RequestIfHeader1();
    internal void set_RequestIfHeader1(string value);
    internal string get_RequestValidator1();
    internal void set_RequestValidator1(string value);
    internal string get_RequestIfHeader2();
    internal void set_RequestIfHeader2(string value);
    internal string get_RequestValidator2();
    internal void set_RequestValidator2(string value);
    internal bool get_CacheDontUpdateHeaders();
    internal void set_CacheDontUpdateHeaders(bool value);
    internal DateTime get_CacheDate();
    internal void set_CacheDate(DateTime value);
    internal DateTime get_CacheExpires();
    internal void set_CacheExpires(DateTime value);
    internal DateTime get_CacheLastModified();
    internal void set_CacheLastModified(DateTime value);
    internal long get_CacheEntityLength();
    internal void set_CacheEntityLength(long value);
    internal TimeSpan get_CacheAge();
    internal void set_CacheAge(TimeSpan value);
    internal TimeSpan get_CacheMaxAge();
    internal void set_CacheMaxAge(TimeSpan value);
    internal bool get_HeuristicExpiration();
    internal void set_HeuristicExpiration(bool value);
    internal ResponseCacheControl get_CacheCacheControl();
    internal void set_CacheCacheControl(ResponseCacheControl value);
    internal DateTime get_ResponseDate();
    internal void set_ResponseDate(DateTime value);
    internal DateTime get_ResponseExpires();
    internal void set_ResponseExpires(DateTime value);
    internal DateTime get_ResponseLastModified();
    internal void set_ResponseLastModified(DateTime value);
    internal long get_ResponseEntityLength();
    internal void set_ResponseEntityLength(long value);
    internal long get_ResponseRangeStart();
    internal void set_ResponseRangeStart(long value);
    internal long get_ResponseRangeEnd();
    internal void set_ResponseRangeEnd(long value);
    internal TimeSpan get_ResponseAge();
    internal void set_ResponseAge(TimeSpan value);
    internal ResponseCacheControl get_ResponseCacheControl();
    internal void set_ResponseCacheControl(ResponseCacheControl value);
    internal virtual RequestCacheValidator CreateValidator();
    protected internal virtual CacheValidationStatus ValidateRequest();
    protected internal virtual CacheFreshnessStatus ValidateFreshness();
    protected internal virtual CacheValidationStatus ValidateCache();
    protected internal virtual CacheValidationStatus RevalidateCache();
    protected internal virtual CacheValidationStatus ValidateResponse();
    protected internal virtual CacheValidationStatus UpdateCache();
    internal static void ParseHeaderValues(String[] values, ParseCallback calback, IList list);
}
internal class System.Net.Cache.MetadataUpdateStream : BaseWrapperStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal MetadataUpdateStream(Stream parentStream, RequestCache cache, string key, DateTime expiresGMT, DateTime lastModifiedGMT, DateTime lastSynchronizedGMT, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, bool isStrictCacheErrors);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    protected sealed virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing, CloseExState closeState);
}
internal class System.Net.Cache.RangeStream : BaseWrapperStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal RangeStream(Stream parentStream, long offset, long size);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    protected sealed virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing, CloseExState closeState);
}
internal abstract class System.Net.Cache.RequestCache : object {
    internal static Char[] LineSplits;
    internal bool IsPrivateCache { get; }
    internal bool CanWrite { get; }
    protected RequestCache(bool isPrivateCache, bool canWrite);
    private static RequestCache();
    internal bool get_IsPrivateCache();
    internal bool get_CanWrite();
    internal abstract virtual Stream Retrieve(string key, RequestCacheEntry& cacheEntry);
    internal abstract virtual Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual void Remove(string key);
    internal abstract virtual void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream);
    internal abstract virtual bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream);
    internal abstract virtual bool TryRemove(string key);
    internal abstract virtual bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal abstract virtual void UnlockEntry(Stream retrieveStream);
}
internal class System.Net.Cache.RequestCacheBinding : object {
    internal RequestCache Cache { get; }
    internal RequestCacheValidator Validator { get; }
    internal RequestCachePolicy Policy { get; }
    internal RequestCacheBinding(RequestCache requestCache, RequestCacheValidator cacheValidator, RequestCachePolicy policy);
    internal RequestCache get_Cache();
    internal RequestCacheValidator get_Validator();
    internal RequestCachePolicy get_Policy();
}
internal class System.Net.Cache.RequestCacheEntry : object {
    internal bool IsPrivateEntry { get; internal set; }
    internal long StreamSize { get; internal set; }
    internal DateTime ExpiresUtc { get; internal set; }
    internal DateTime LastAccessedUtc { get; internal set; }
    internal DateTime LastModifiedUtc { get; internal set; }
    internal DateTime LastSynchronizedUtc { get; internal set; }
    internal TimeSpan MaxStale { get; internal set; }
    internal int HitCount { get; internal set; }
    internal int UsageCount { get; internal set; }
    internal bool IsPartialEntry { get; internal set; }
    internal StringCollection EntryMetadata { get; internal set; }
    internal StringCollection SystemMetadata { get; internal set; }
    internal RequestCacheEntry(Entry entry, bool isPrivateEntry);
    internal bool get_IsPrivateEntry();
    internal void set_IsPrivateEntry(bool value);
    internal long get_StreamSize();
    internal void set_StreamSize(long value);
    internal DateTime get_ExpiresUtc();
    internal void set_ExpiresUtc(DateTime value);
    internal DateTime get_LastAccessedUtc();
    internal void set_LastAccessedUtc(DateTime value);
    internal DateTime get_LastModifiedUtc();
    internal void set_LastModifiedUtc(DateTime value);
    internal DateTime get_LastSynchronizedUtc();
    internal void set_LastSynchronizedUtc(DateTime value);
    internal TimeSpan get_MaxStale();
    internal void set_MaxStale(TimeSpan value);
    internal int get_HitCount();
    internal void set_HitCount(int value);
    internal int get_UsageCount();
    internal void set_UsageCount(int value);
    internal bool get_IsPartialEntry();
    internal void set_IsPartialEntry(bool value);
    internal StringCollection get_EntryMetadata();
    internal void set_EntryMetadata(StringCollection value);
    internal StringCollection get_SystemMetadata();
    internal void set_SystemMetadata(StringCollection value);
    internal virtual string ToString(bool verbose);
}
public enum System.Net.Cache.RequestCacheLevel : Enum {
    public int value__;
    public static RequestCacheLevel Default;
    public static RequestCacheLevel BypassCache;
    public static RequestCacheLevel CacheOnly;
    public static RequestCacheLevel CacheIfAvailable;
    public static RequestCacheLevel Revalidate;
    public static RequestCacheLevel Reload;
    public static RequestCacheLevel NoCacheNoStore;
}
internal class System.Net.Cache.RequestCacheManager : object {
    internal static bool IsCachingEnabled { get; }
    private static RequestCacheManager();
    internal static RequestCacheBinding GetBinding(string internedScheme);
    internal static bool get_IsCachingEnabled();
    internal static void SetBinding(string uriScheme, RequestCacheBinding binding);
}
public class System.Net.Cache.RequestCachePolicy : object {
    public RequestCacheLevel Level { get; }
    public RequestCachePolicy(RequestCacheLevel level);
    public RequestCacheLevel get_Level();
    public virtual string ToString();
}
internal class System.Net.Cache.RequestCacheProtocol : object {
    internal CacheValidationStatus ProtocolStatus { get; }
    internal Exception ProtocolException { get; }
    internal Stream ResponseStream { get; }
    internal long ResponseStreamLength { get; }
    internal RequestCacheValidator Validator { get; }
    internal bool IsCacheFresh { get; }
    internal RequestCacheProtocol(RequestCache cache, RequestCacheValidator defaultValidator);
    internal CacheValidationStatus get_ProtocolStatus();
    internal Exception get_ProtocolException();
    internal Stream get_ResponseStream();
    internal long get_ResponseStreamLength();
    internal RequestCacheValidator get_Validator();
    internal bool get_IsCacheFresh();
    internal CacheValidationStatus GetRetrieveStatus(Uri cacheUri, WebRequest request);
    internal CacheValidationStatus GetRevalidateStatus(WebResponse response, Stream responseStream);
    internal CacheValidationStatus GetUpdateStatus(WebResponse response, Stream responseStream);
    internal void Reset();
    internal void Abort();
}
internal abstract class System.Net.Cache.RequestCacheValidator : object {
    internal WebRequest _Request;
    internal WebResponse _Response;
    internal Stream _CacheStream;
    internal bool StrictCacheErrors { get; }
    internal TimeSpan UnspecifiedMaxAge { get; }
    protected internal Uri Uri { get; }
    protected internal WebRequest Request { get; }
    protected internal WebResponse Response { get; }
    protected internal RequestCachePolicy Policy { get; }
    protected internal int ResponseCount { get; }
    protected internal CacheValidationStatus ValidationStatus { get; }
    protected internal CacheFreshnessStatus CacheFreshnessStatus { get; }
    protected internal RequestCacheEntry CacheEntry { get; }
    protected internal Stream CacheStream { get; protected internal set; }
    protected internal long CacheStreamOffset { get; protected internal set; }
    protected internal long CacheStreamLength { get; protected internal set; }
    protected internal string CacheKey { get; }
    protected RequestCacheValidator(bool strictCacheErrors, TimeSpan unspecifiedMaxAge);
    internal abstract virtual RequestCacheValidator CreateValidator();
    internal bool get_StrictCacheErrors();
    internal TimeSpan get_UnspecifiedMaxAge();
    protected internal Uri get_Uri();
    protected internal WebRequest get_Request();
    protected internal WebResponse get_Response();
    protected internal RequestCachePolicy get_Policy();
    protected internal int get_ResponseCount();
    protected internal CacheValidationStatus get_ValidationStatus();
    protected internal CacheFreshnessStatus get_CacheFreshnessStatus();
    protected internal RequestCacheEntry get_CacheEntry();
    protected internal Stream get_CacheStream();
    protected internal void set_CacheStream(Stream value);
    protected internal long get_CacheStreamOffset();
    protected internal void set_CacheStreamOffset(long value);
    protected internal long get_CacheStreamLength();
    protected internal void set_CacheStreamLength(long value);
    protected internal string get_CacheKey();
    protected internal abstract virtual CacheValidationStatus ValidateRequest();
    protected internal abstract virtual CacheFreshnessStatus ValidateFreshness();
    protected internal abstract virtual CacheValidationStatus ValidateCache();
    protected internal abstract virtual CacheValidationStatus ValidateResponse();
    protected internal abstract virtual CacheValidationStatus RevalidateCache();
    protected internal abstract virtual CacheValidationStatus UpdateCache();
    protected internal virtual void FailRequest(WebExceptionStatus webStatus);
    internal void FetchRequest(Uri uri, WebRequest request);
    internal void FetchCacheEntry(RequestCacheEntry fetchEntry);
    internal void FetchResponse(WebResponse fetchResponse);
    internal void SetFreshnessStatus(CacheFreshnessStatus status);
    internal void SetValidationStatus(CacheValidationStatus status);
}
internal class System.Net.Cache.ResponseCacheControl : object {
    internal bool Public;
    internal bool Private;
    internal String[] PrivateHeaders;
    internal bool NoCache;
    internal String[] NoCacheHeaders;
    internal bool NoStore;
    internal bool MustRevalidate;
    internal bool ProxyRevalidate;
    internal int MaxAge;
    internal int SMaxAge;
    internal bool IsNotEmpty { get; }
    internal bool get_IsNotEmpty();
    public virtual string ToString();
}
internal class System.Net.Cache.Rfc2616 : object {
    public static CacheValidationStatus OnValidateRequest(HttpRequestCacheValidator ctx);
    public static CacheFreshnessStatus OnValidateFreshness(HttpRequestCacheValidator ctx);
    public static CacheValidationStatus OnValidateCache(HttpRequestCacheValidator ctx);
    public static CacheValidationStatus OnValidateResponse(HttpRequestCacheValidator ctx);
    public static CacheValidationStatus OnUpdateCache(HttpRequestCacheValidator ctx);
}
internal class System.Net.Cache.SingleItemRequestCache : WinInetCache {
    internal SingleItemRequestCache(bool useWinInet);
    internal virtual Stream Retrieve(string key, RequestCacheEntry& cacheEntry);
    internal virtual Stream Store(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual void Remove(string key);
    internal virtual void Update(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual bool TryRetrieve(string key, RequestCacheEntry& cacheEntry, Stream& readStream);
    internal virtual bool TryStore(string key, long contentLength, DateTime expiresUtc, DateTime lastModifiedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata, Stream& writeStream);
    internal virtual bool TryRemove(string key);
    internal virtual bool TryUpdate(string key, DateTime expiresUtc, DateTime lastModifiedUtc, DateTime lastSynchronizedUtc, TimeSpan maxStale, StringCollection entryMetadata, StringCollection systemMetadata);
    internal virtual void UnlockEntry(Stream stream);
}
internal class System.Net.CachedTransportContext : TransportContext {
    internal CachedTransportContext(ChannelBinding binding);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.CallbackClosure : object {
    internal AsyncCallback AsyncCallback { get; }
    internal ExecutionContext Context { get; }
    internal CallbackClosure(ExecutionContext context, AsyncCallback callback);
    internal bool IsCompatible(AsyncCallback callback);
    internal AsyncCallback get_AsyncCallback();
    internal ExecutionContext get_Context();
}
internal class System.Net.CaseInsensitiveAscii : object {
    internal static CaseInsensitiveAscii StaticInstance;
    internal static Byte[] AsciiToLower;
    private static CaseInsensitiveAscii();
    public sealed virtual int GetHashCode(object myObject);
    public sealed virtual int Compare(object firstObject, object secondObject);
    public sealed virtual bool Equals(object firstObject, object secondObject);
}
internal class System.Net.CertEnhKeyUse : ValueType {
    public UInt32 cUsageIdentifier;
    public Void* rgpszUsageIdentifier;
}
internal enum System.Net.CertificateEncoding : Enum {
    public int value__;
    public static CertificateEncoding Zero;
    public static CertificateEncoding X509AsnEncoding;
    public static CertificateEncoding X509NdrEncoding;
    public static CertificateEncoding Pkcs7AsnEncoding;
    public static CertificateEncoding Pkcs7NdrEncoding;
    public static CertificateEncoding AnyAsnEncoding;
}
internal enum System.Net.CertificateProblem : Enum {
    public int value__;
    public static CertificateProblem OK;
    public static CertificateProblem TrustNOSIGNATURE;
    public static CertificateProblem CertEXPIRED;
    public static CertificateProblem CertVALIDITYPERIODNESTING;
    public static CertificateProblem CertROLE;
    public static CertificateProblem CertPATHLENCONST;
    public static CertificateProblem CertCRITICAL;
    public static CertificateProblem CertPURPOSE;
    public static CertificateProblem CertISSUERCHAINING;
    public static CertificateProblem CertMALFORMED;
    public static CertificateProblem CertUNTRUSTEDROOT;
    public static CertificateProblem CertCHAINING;
    public static CertificateProblem CertREVOKED;
    public static CertificateProblem CertUNTRUSTEDTESTROOT;
    public static CertificateProblem CertREVOCATION_FAILURE;
    public static CertificateProblem CertCN_NO_MATCH;
    public static CertificateProblem CertWRONG_USAGE;
    public static CertificateProblem TrustEXPLICITDISTRUST;
    public static CertificateProblem CertUNTRUSTEDCA;
    public static CertificateProblem CertINVALIDPOLICY;
    public static CertificateProblem CertINVALIDNAME;
    public static CertificateProblem CryptNOREVOCATIONCHECK;
    public static CertificateProblem CryptREVOCATIONOFFLINE;
    public static CertificateProblem TrustSYSTEMERROR;
    public static CertificateProblem TrustNOSIGNERCERT;
    public static CertificateProblem TrustCOUNTERSIGNER;
    public static CertificateProblem TrustCERTSIGNATURE;
    public static CertificateProblem TrustTIMESTAMP;
    public static CertificateProblem TrustBADDIGEST;
    public static CertificateProblem TrustBASICCONSTRAINTS;
    public static CertificateProblem TrustFINANCIALCRITERIA;
}
internal class System.Net.CertPolicyValidationCallback : object {
    internal ICertificatePolicy CertificatePolicy { get; }
    internal bool UsesDefault { get; }
    internal CertPolicyValidationCallback(ICertificatePolicy certificatePolicy);
    internal ICertificatePolicy get_CertificatePolicy();
    internal bool get_UsesDefault();
    internal void Callback(object state);
    internal bool Invoke(string hostName, ServicePoint servicePoint, X509Certificate certificate, WebRequest request, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal enum System.Net.CertUsage : Enum {
    public int value__;
    public static CertUsage MatchTypeAnd;
    public static CertUsage MatchTypeOr;
}
internal class System.Net.CertUsageMatch : ValueType {
    public CertUsage dwType;
    public CertEnhKeyUse Usage;
}
internal class System.Net.ChainParameters : ValueType {
    public UInt32 cbSize;
    public CertUsageMatch RequestedUsage;
    public CertUsageMatch RequestedIssuancePolicy;
    public UInt32 UrlRetrievalTimeout;
    public int BoolCheckRevocationFreshnessTime;
    public UInt32 RevocationFreshnessTime;
    public static UInt32 StructSize;
    private static ChainParameters();
}
internal class System.Net.ChainPolicyParameter : ValueType {
    public UInt32 cbSize;
    public UInt32 dwFlags;
    public SSL_EXTRA_CERT_CHAIN_POLICY_PARA* pvExtraPolicyPara;
    public static UInt32 StructSize;
    private static ChainPolicyParameter();
}
internal class System.Net.ChainPolicyStatus : ValueType {
    public UInt32 cbSize;
    public UInt32 dwError;
    public UInt32 lChainIndex;
    public UInt32 lElementIndex;
    public Void* pvExtraPolicyStatus;
    public static UInt32 StructSize;
    private static ChainPolicyStatus();
}
internal enum System.Net.ChainPolicyType : Enum {
    public int value__;
    public static ChainPolicyType Base;
    public static ChainPolicyType Authenticode;
    public static ChainPolicyType Authenticode_TS;
    public static ChainPolicyType SSL;
    public static ChainPolicyType BasicConstraints;
    public static ChainPolicyType NtAuth;
}
internal class System.Net.ChunkParser : object {
    private static ChunkParser();
    public ChunkParser(Stream dataSource, Byte[] internalBuffer, int initialBufferOffset, int initialBufferCount, int maxBufferLength);
    public IAsyncResult ReadAsync(object caller, Byte[] userBuffer, int userBufferOffset, int userBufferCount, AsyncCallback callback, object state);
    public int Read(Byte[] userBuffer, int userBufferOffset, int userBufferCount);
    public bool TryGetLeftoverBytes(Byte[]& buffer, Int32& leftoverBufferOffset, Int32& leftoverBufferSize);
    public void ReadCallback(IAsyncResult ar);
}
internal class System.Net.ClosableStream : DelegatedStream {
    internal ClosableStream(Stream stream, EventHandler onClose);
    public virtual void Close();
}
[FlagsAttribute]
internal enum System.Net.CloseExState : Enum {
    public int value__;
    public static CloseExState Normal;
    public static CloseExState Abort;
    public static CloseExState Silent;
}
internal class System.Net.CommandStream : PooledStream {
    protected WebRequest m_Request;
    protected bool m_Async;
    protected PipelineEntry[] m_Commands;
    protected int m_Index;
    protected string m_AbortReason;
    internal bool RecoverableFailure { get; }
    protected Encoding Encoding { get; protected set; }
    internal CommandStream(ConnectionPool connectionPool, TimeSpan lifetime, bool checkLifetime);
    private static CommandStream();
    internal virtual void Abort(Exception e);
    protected virtual void Dispose(bool disposing);
    protected void InvokeRequestCallback(object obj);
    internal bool get_RecoverableFailure();
    protected void MarkAsRecoverableFailure();
    internal Stream SubmitRequest(WebRequest request, bool async, bool readInitalResponseOnConnect);
    protected virtual void ClearState();
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest request);
    protected Exception GenerateException(WebExceptionStatus status, Exception innerException);
    protected Exception GenerateException(FtpStatusCode code, string statusDescription, Exception innerException);
    protected void InitCommandPipeline(WebRequest request, PipelineEntry[] commands, bool async);
    internal void CheckContinuePipeline();
    protected Stream ContinueCommandPipeline();
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    protected Encoding get_Encoding();
    protected void set_Encoding(Encoding value);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
}
internal static class System.Net.ComNetOS : object {
    internal static bool IsAspNetServer;
    internal static bool IsWin7orLater;
    internal static bool IsWin7Sp1orLater;
    internal static bool IsWin8orLater;
    internal static WindowsInstallationType InstallationType;
    private static ComNetOS();
}
internal class System.Net.Comparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object ol, object or);
}
internal class System.Net.CompletionDelegate : MulticastDelegate {
    public CompletionDelegate(object object, IntPtr method);
    public virtual void Invoke(Byte[] responseBytes, Exception exception, object State);
    public virtual IAsyncResult BeginInvoke(Byte[] responseBytes, Exception exception, object State, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.Configuration.AuthenticationModuleElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string Type { get; public set; }
    internal string Key { get; }
    public AuthenticationModuleElement(string typeName);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
    internal string get_Key();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Net.Configuration.AuthenticationModuleElement")]
public class System.Net.Configuration.AuthenticationModuleElementCollection : ConfigurationElementCollection {
    public AuthenticationModuleElement Item { get; public set; }
    public AuthenticationModuleElement Item { get; public set; }
    public AuthenticationModuleElement get_Item(int index);
    public void set_Item(int index, AuthenticationModuleElement value);
    public AuthenticationModuleElement get_Item(string name);
    public void set_Item(string name, AuthenticationModuleElement value);
    public void Add(AuthenticationModuleElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(AuthenticationModuleElement element);
    public void Remove(AuthenticationModuleElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Net.Configuration.AuthenticationModulesSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public AuthenticationModuleElementCollection AuthenticationModules { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual void PostDeserialize();
    public AuthenticationModuleElementCollection get_AuthenticationModules();
    protected virtual void InitializeDefault();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.AuthenticationModulesSectionInternal : object {
    internal List`1<Type> AuthenticationModules { get; }
    internal static object ClassSyncObject { get; }
    internal AuthenticationModulesSectionInternal(AuthenticationModulesSection section);
    private static AuthenticationModulesSectionInternal();
    internal List`1<Type> get_AuthenticationModules();
    internal static object get_ClassSyncObject();
    internal static AuthenticationModulesSectionInternal GetSection();
}
public class System.Net.Configuration.BypassElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("address")]
public string Address { get; public set; }
    internal string Key { get; }
    public BypassElement(string address);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Address();
    public void set_Address(string value);
    internal string get_Key();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Net.Configuration.BypassElement")]
public class System.Net.Configuration.BypassElementCollection : ConfigurationElementCollection {
    public BypassElement Item { get; public set; }
    public BypassElement Item { get; public set; }
    protected bool ThrowOnDuplicate { get; }
    public BypassElement get_Item(int index);
    public void set_Item(int index, BypassElement value);
    public BypassElement get_Item(string name);
    public void set_Item(string name, BypassElement value);
    public void Add(BypassElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(BypassElement element);
    public void Remove(BypassElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
    protected virtual bool get_ThrowOnDuplicate();
}
internal static class System.Net.Configuration.ConfigurationStrings : object {
    internal static string Address;
    internal static string AutoConfigUrlRetryInterval;
    internal static string AutoDetect;
    internal static string AlwaysUseCompletionPortsForAccept;
    internal static string AlwaysUseCompletionPortsForConnect;
    internal static string AuthenticationModulesSectionName;
    internal static string BypassList;
    internal static string BypassOnLocal;
    internal static string CheckCertificateName;
    internal static string CheckCertificateRevocationList;
    internal static string ClientDomain;
    internal static string ConnectionManagementSectionName;
    internal static string DefaultCredentials;
    internal static string DefaultCredentialsHandleCacheSize;
    internal static string DefaultHttpCachePolicy;
    internal static string DefaultFtpCachePolicy;
    internal static string DefaultPolicyLevel;
    internal static string DefaultProxySectionName;
    internal static string DeliveryMethod;
    internal static string DeliveryFormat;
    internal static string DisableAllCaching;
    internal static string DnsRefreshTimeout;
    internal static string DownloadTimeout;
    internal static string Enabled;
    internal static string EnableDnsRoundRobin;
    internal static string EnableSsl;
    internal static string EncryptionPolicy;
    internal static string Expect100Continue;
    internal static string File;
    internal static string From;
    internal static string Ftp;
    internal static string Host;
    internal static string HttpWebRequest;
    internal static string HttpListener;
    internal static string Http;
    internal static string Https;
    internal static string Ipv6;
    internal static string IsPrivateCache;
    internal static string IPProtectionLevel;
    internal static string MailSettingsSectionName;
    internal static string MaxConnection;
    internal static string MaximumAge;
    internal static string MaximumStale;
    internal static string MaximumResponseHeadersLength;
    internal static string MaximumErrorResponseLength;
    internal static string MinimumFresh;
    internal static string Module;
    internal static string Name;
    internal static string Network;
    internal static string Password;
    internal static string PerformanceCounters;
    internal static string PickupDirectoryFromIis;
    internal static string PickupDirectoryLocation;
    internal static string PolicyLevel;
    internal static string Port;
    internal static string Prefix;
    internal static string Proxy;
    internal static string ProxyAddress;
    internal static string RequestCachingSectionName;
    internal static string ScriptLocation;
    internal static string SectionGroupName;
    internal static string ServicePointManager;
    internal static string SettingsSectionName;
    internal static string SmtpSectionName;
    internal static string Socket;
    internal static string SpecifiedPickupDirectory;
    internal static string TargetName;
    internal static string Type;
    internal static string UnicodeDecodingConformance;
    internal static string UnicodeEncodingConformance;
    internal static string UnspecifiedMaximumAge;
    internal static string UseDefaultCredentials;
    internal static string UseNagleAlgorithm;
    internal static string UseSystemDefault;
    internal static string UseUnsafeHeaderParsing;
    internal static string UserName;
    internal static string WebProxyScript;
    internal static string WebRequestModulesSectionName;
    internal static string WebUtility;
    internal static string WindowsAuthentication;
    internal static string maximumUnauthorizedUploadLength;
    internal static string UnescapeRequestUrl;
    internal static string Timeouts;
    internal static string EntityBody;
    internal static string DrainEntityBody;
    internal static string RequestQueue;
    internal static string IdleConnection;
    internal static string HeaderWait;
    internal static string MinSendBytesPerSecond;
    internal static string AuthenticationModulesSectionPath { get; }
    internal static string ConnectionManagementSectionPath { get; }
    internal static string DefaultProxySectionPath { get; }
    internal static string SmtpSectionPath { get; }
    internal static string RequestCachingSectionPath { get; }
    internal static string SettingsSectionPath { get; }
    internal static string WebRequestModulesSectionPath { get; }
    internal static string get_AuthenticationModulesSectionPath();
    internal static string get_ConnectionManagementSectionPath();
    internal static string get_DefaultProxySectionPath();
    internal static string get_SmtpSectionPath();
    internal static string get_RequestCachingSectionPath();
    internal static string get_SettingsSectionPath();
    internal static string get_WebRequestModulesSectionPath();
}
public class System.Net.Configuration.ConnectionManagementElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("address")]
public string Address { get; public set; }
    [ConfigurationPropertyAttribute("maxconnection")]
public int MaxConnection { get; public set; }
    internal string Key { get; }
    public ConnectionManagementElement(string address, int maxConnection);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Address();
    public void set_Address(string value);
    public int get_MaxConnection();
    public void set_MaxConnection(int value);
    internal string get_Key();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Net.Configuration.ConnectionManagementElement")]
public class System.Net.Configuration.ConnectionManagementElementCollection : ConfigurationElementCollection {
    public ConnectionManagementElement Item { get; public set; }
    public ConnectionManagementElement Item { get; public set; }
    public ConnectionManagementElement get_Item(int index);
    public void set_Item(int index, ConnectionManagementElement value);
    public ConnectionManagementElement get_Item(string name);
    public void set_Item(string name, ConnectionManagementElement value);
    public void Add(ConnectionManagementElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ConnectionManagementElement element);
    public void Remove(ConnectionManagementElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Net.Configuration.ConnectionManagementSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public ConnectionManagementElementCollection ConnectionManagement { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public ConnectionManagementElementCollection get_ConnectionManagement();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.ConnectionManagementSectionInternal : object {
    internal Hashtable ConnectionManagement { get; }
    internal static object ClassSyncObject { get; }
    internal ConnectionManagementSectionInternal(ConnectionManagementSection section);
    private static ConnectionManagementSectionInternal();
    internal Hashtable get_ConnectionManagement();
    internal static object get_ClassSyncObject();
    internal static ConnectionManagementSectionInternal GetSection();
}
public class System.Net.Configuration.DefaultProxySection : ConfigurationSection {
    [ConfigurationPropertyAttribute("bypasslist")]
public BypassElementCollection BypassList { get; }
    [ConfigurationPropertyAttribute("module")]
public ModuleElement Module { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("proxy")]
public ProxyElement Proxy { get; }
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    [ConfigurationPropertyAttribute("useDefaultCredentials")]
public bool UseDefaultCredentials { get; public set; }
    protected virtual void PostDeserialize();
    public BypassElementCollection get_BypassList();
    public ModuleElement get_Module();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public ProxyElement get_Proxy();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    protected virtual void Reset(ConfigurationElement parentElement);
}
internal class System.Net.Configuration.DefaultProxySectionInternal : object {
    internal static object ClassSyncObject { get; }
    internal IWebProxy WebProxy { get; }
    internal DefaultProxySectionInternal(DefaultProxySection section);
    internal static object get_ClassSyncObject();
    internal static DefaultProxySectionInternal GetSection();
    internal IWebProxy get_WebProxy();
}
public class System.Net.Configuration.FtpCachePolicyElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("policyLevel")]
public RequestCacheLevel PolicyLevel { get; public set; }
    internal bool WasReadFromConfig { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public RequestCacheLevel get_PolicyLevel();
    public void set_PolicyLevel(RequestCacheLevel value);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual void Reset(ConfigurationElement parentElement);
    internal bool get_WasReadFromConfig();
}
public class System.Net.Configuration.HttpCachePolicyElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("maximumAge")]
public TimeSpan MaximumAge { get; public set; }
    [ConfigurationPropertyAttribute("maximumStale")]
public TimeSpan MaximumStale { get; public set; }
    [ConfigurationPropertyAttribute("minimumFresh")]
public TimeSpan MinimumFresh { get; public set; }
    [ConfigurationPropertyAttribute("policyLevel")]
public HttpRequestCacheLevel PolicyLevel { get; public set; }
    internal bool WasReadFromConfig { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public TimeSpan get_MaximumAge();
    public void set_MaximumAge(TimeSpan value);
    public TimeSpan get_MaximumStale();
    public void set_MaximumStale(TimeSpan value);
    public TimeSpan get_MinimumFresh();
    public void set_MinimumFresh(TimeSpan value);
    public HttpRequestCacheLevel get_PolicyLevel();
    public void set_PolicyLevel(HttpRequestCacheLevel value);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual void Reset(ConfigurationElement parentElement);
    internal bool get_WasReadFromConfig();
}
public class System.Net.Configuration.HttpListenerElement : ConfigurationElement {
    internal static bool UnescapeRequestUrlDefaultValue;
    [ConfigurationPropertyAttribute("unescapeRequestUrl")]
public bool UnescapeRequestUrl { get; }
    [ConfigurationPropertyAttribute("timeouts")]
public HttpListenerTimeoutsElement Timeouts { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static HttpListenerElement();
    public bool get_UnescapeRequestUrl();
    public HttpListenerTimeoutsElement get_Timeouts();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.HttpListenerTimeoutsElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("entityBody")]
public TimeSpan EntityBody { get; }
    [ConfigurationPropertyAttribute("drainEntityBody")]
public TimeSpan DrainEntityBody { get; }
    [ConfigurationPropertyAttribute("requestQueue")]
public TimeSpan RequestQueue { get; }
    [ConfigurationPropertyAttribute("idleConnection")]
public TimeSpan IdleConnection { get; }
    [ConfigurationPropertyAttribute("headerWait")]
public TimeSpan HeaderWait { get; }
    [ConfigurationPropertyAttribute("minSendBytesPerSecond")]
public long MinSendBytesPerSecond { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    private static HttpListenerTimeoutsElement();
    public TimeSpan get_EntityBody();
    public TimeSpan get_DrainEntityBody();
    public TimeSpan get_RequestQueue();
    public TimeSpan get_IdleConnection();
    public TimeSpan get_HeaderWait();
    public long get_MinSendBytesPerSecond();
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal Int64[] GetTimeouts();
}
public class System.Net.Configuration.HttpWebRequestElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("maximumUnauthorizedUploadLength")]
public int MaximumUnauthorizedUploadLength { get; public set; }
    [ConfigurationPropertyAttribute("maximumErrorResponseLength")]
public int MaximumErrorResponseLength { get; public set; }
    [ConfigurationPropertyAttribute("maximumResponseHeadersLength")]
public int MaximumResponseHeadersLength { get; public set; }
    [ConfigurationPropertyAttribute("useUnsafeHeaderParsing")]
public bool UseUnsafeHeaderParsing { get; public set; }
    protected virtual void PostDeserialize();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_MaximumUnauthorizedUploadLength();
    public void set_MaximumUnauthorizedUploadLength(int value);
    public int get_MaximumErrorResponseLength();
    public void set_MaximumErrorResponseLength(int value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public bool get_UseUnsafeHeaderParsing();
    public void set_UseUnsafeHeaderParsing(bool value);
}
public class System.Net.Configuration.Ipv6Element : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_Enabled();
    public void set_Enabled(bool value);
}
public class System.Net.Configuration.MailSettingsSectionGroup : ConfigurationSectionGroup {
    public SmtpSection Smtp { get; }
    public SmtpSection get_Smtp();
}
internal class System.Net.Configuration.MailSettingsSectionGroupInternal : object {
    internal SmtpSectionInternal Smtp { get; }
    internal SmtpSectionInternal get_Smtp();
    internal static MailSettingsSectionGroupInternal GetSection();
}
public class System.Net.Configuration.ModuleElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("type")]
public string Type { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Type();
    public void set_Type(string value);
}
public class System.Net.Configuration.NetSectionGroup : ConfigurationSectionGroup {
    [ConfigurationPropertyAttribute("authenticationModules")]
public AuthenticationModulesSection AuthenticationModules { get; }
    [ConfigurationPropertyAttribute("connectionManagement")]
public ConnectionManagementSection ConnectionManagement { get; }
    [ConfigurationPropertyAttribute("defaultProxy")]
public DefaultProxySection DefaultProxy { get; }
    public MailSettingsSectionGroup MailSettings { get; }
    [ConfigurationPropertyAttribute("requestCaching")]
public RequestCachingSection RequestCaching { get; }
    [ConfigurationPropertyAttribute("settings")]
public SettingsSection Settings { get; }
    [ConfigurationPropertyAttribute("webRequestModules")]
public WebRequestModulesSection WebRequestModules { get; }
    public AuthenticationModulesSection get_AuthenticationModules();
    public ConnectionManagementSection get_ConnectionManagement();
    public DefaultProxySection get_DefaultProxy();
    public MailSettingsSectionGroup get_MailSettings();
    public static NetSectionGroup GetSectionGroup(Configuration config);
    public RequestCachingSection get_RequestCaching();
    public SettingsSection get_Settings();
    public WebRequestModulesSection get_WebRequestModules();
}
public class System.Net.Configuration.PerformanceCountersElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("enabled")]
public bool Enabled { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.ProxyElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("autoDetect")]
public AutoDetectValues AutoDetect { get; public set; }
    [ConfigurationPropertyAttribute("scriptLocation")]
public Uri ScriptLocation { get; public set; }
    [ConfigurationPropertyAttribute("bypassonlocal")]
public BypassOnLocalValues BypassOnLocal { get; public set; }
    [ConfigurationPropertyAttribute("proxyaddress")]
public Uri ProxyAddress { get; public set; }
    [ConfigurationPropertyAttribute("usesystemdefault")]
public UseSystemDefaultValues UseSystemDefault { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public AutoDetectValues get_AutoDetect();
    public void set_AutoDetect(AutoDetectValues value);
    public Uri get_ScriptLocation();
    public void set_ScriptLocation(Uri value);
    public BypassOnLocalValues get_BypassOnLocal();
    public void set_BypassOnLocal(BypassOnLocalValues value);
    public Uri get_ProxyAddress();
    public void set_ProxyAddress(Uri value);
    public UseSystemDefaultValues get_UseSystemDefault();
    public void set_UseSystemDefault(UseSystemDefaultValues value);
}
public class System.Net.Configuration.RequestCachingSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("defaultHttpCachePolicy")]
public HttpCachePolicyElement DefaultHttpCachePolicy { get; }
    [ConfigurationPropertyAttribute("defaultFtpCachePolicy")]
public FtpCachePolicyElement DefaultFtpCachePolicy { get; }
    [ConfigurationPropertyAttribute("defaultPolicyLevel")]
public RequestCacheLevel DefaultPolicyLevel { get; public set; }
    [ConfigurationPropertyAttribute("disableAllCaching")]
public bool DisableAllCaching { get; public set; }
    [ConfigurationPropertyAttribute("isPrivateCache")]
public bool IsPrivateCache { get; public set; }
    [ConfigurationPropertyAttribute("unspecifiedMaximumAge")]
public TimeSpan UnspecifiedMaximumAge { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public HttpCachePolicyElement get_DefaultHttpCachePolicy();
    public FtpCachePolicyElement get_DefaultFtpCachePolicy();
    public RequestCacheLevel get_DefaultPolicyLevel();
    public void set_DefaultPolicyLevel(RequestCacheLevel value);
    public bool get_DisableAllCaching();
    public void set_DisableAllCaching(bool value);
    public bool get_IsPrivateCache();
    public void set_IsPrivateCache(bool value);
    public TimeSpan get_UnspecifiedMaximumAge();
    public void set_UnspecifiedMaximumAge(TimeSpan value);
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
    protected virtual void PostDeserialize();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.RequestCachingSectionInternal : object {
    internal static object ClassSyncObject { get; }
    internal bool DisableAllCaching { get; }
    internal RequestCache DefaultCache { get; }
    internal RequestCachePolicy DefaultCachePolicy { get; }
    internal bool IsPrivateCache { get; }
    internal TimeSpan UnspecifiedMaximumAge { get; }
    internal HttpRequestCachePolicy DefaultHttpCachePolicy { get; }
    internal RequestCachePolicy DefaultFtpCachePolicy { get; }
    internal HttpRequestCacheValidator DefaultHttpValidator { get; }
    internal FtpRequestCacheValidator DefaultFtpValidator { get; }
    internal RequestCachingSectionInternal(RequestCachingSection section);
    internal static object get_ClassSyncObject();
    internal bool get_DisableAllCaching();
    internal RequestCache get_DefaultCache();
    internal RequestCachePolicy get_DefaultCachePolicy();
    internal bool get_IsPrivateCache();
    internal TimeSpan get_UnspecifiedMaximumAge();
    internal HttpRequestCachePolicy get_DefaultHttpCachePolicy();
    internal RequestCachePolicy get_DefaultFtpCachePolicy();
    internal HttpRequestCacheValidator get_DefaultHttpValidator();
    internal FtpRequestCacheValidator get_DefaultFtpValidator();
    internal static RequestCachingSectionInternal GetSection();
}
public class System.Net.Configuration.ServicePointManagerElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("checkCertificateName")]
public bool CheckCertificateName { get; public set; }
    [ConfigurationPropertyAttribute("checkCertificateRevocationList")]
public bool CheckCertificateRevocationList { get; public set; }
    [ConfigurationPropertyAttribute("dnsRefreshTimeout")]
public int DnsRefreshTimeout { get; public set; }
    [ConfigurationPropertyAttribute("enableDnsRoundRobin")]
public bool EnableDnsRoundRobin { get; public set; }
    [ConfigurationPropertyAttribute("encryptionPolicy")]
public EncryptionPolicy EncryptionPolicy { get; public set; }
    [ConfigurationPropertyAttribute("expect100Continue")]
public bool Expect100Continue { get; public set; }
    [ConfigurationPropertyAttribute("useNagleAlgorithm")]
public bool UseNagleAlgorithm { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual void PostDeserialize();
    public bool get_CheckCertificateName();
    public void set_CheckCertificateName(bool value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public int get_DnsRefreshTimeout();
    public void set_DnsRefreshTimeout(int value);
    public bool get_EnableDnsRoundRobin();
    public void set_EnableDnsRoundRobin(bool value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public bool get_Expect100Continue();
    public void set_Expect100Continue(bool value);
    public bool get_UseNagleAlgorithm();
    public void set_UseNagleAlgorithm(bool value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.SettingsSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("httpWebRequest")]
public HttpWebRequestElement HttpWebRequest { get; }
    [ConfigurationPropertyAttribute("ipv6")]
public Ipv6Element Ipv6 { get; }
    [ConfigurationPropertyAttribute("servicePointManager")]
public ServicePointManagerElement ServicePointManager { get; }
    [ConfigurationPropertyAttribute("socket")]
public SocketElement Socket { get; }
    [ConfigurationPropertyAttribute("webProxyScript")]
public WebProxyScriptElement WebProxyScript { get; }
    [ConfigurationPropertyAttribute("performanceCounters")]
public PerformanceCountersElement PerformanceCounters { get; }
    [ConfigurationPropertyAttribute("httpListener")]
public HttpListenerElement HttpListener { get; }
    [ConfigurationPropertyAttribute("webUtility")]
public WebUtilityElement WebUtility { get; }
    [ConfigurationPropertyAttribute("windowsAuthentication")]
public WindowsAuthenticationElement WindowsAuthentication { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal static void EnsureConfigLoaded();
    public HttpWebRequestElement get_HttpWebRequest();
    public Ipv6Element get_Ipv6();
    public ServicePointManagerElement get_ServicePointManager();
    public SocketElement get_Socket();
    public WebProxyScriptElement get_WebProxyScript();
    public PerformanceCountersElement get_PerformanceCounters();
    public HttpListenerElement get_HttpListener();
    public WebUtilityElement get_WebUtility();
    public WindowsAuthenticationElement get_WindowsAuthentication();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.SettingsSectionInternal : object {
    internal static SettingsSectionInternal Section { get; }
    internal bool AlwaysUseCompletionPortsForAccept { get; }
    internal bool AlwaysUseCompletionPortsForConnect { get; }
    internal int AutoConfigUrlRetryInterval { get; }
    internal bool CheckCertificateName { get; }
    internal bool CheckCertificateRevocationList { get; internal set; }
    internal int DefaultCredentialsHandleCacheSize { get; internal set; }
    internal int DnsRefreshTimeout { get; internal set; }
    internal int DownloadTimeout { get; }
    internal bool EnableDnsRoundRobin { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; }
    internal bool Expect100Continue { get; internal set; }
    internal IPProtectionLevel IPProtectionLevel { get; }
    internal bool Ipv6Enabled { get; }
    internal int MaximumResponseHeadersLength { get; internal set; }
    internal int MaximumUnauthorizedUploadLength { get; }
    internal int MaximumErrorResponseLength { get; internal set; }
    internal bool UseUnsafeHeaderParsing { get; }
    internal bool UseNagleAlgorithm { get; internal set; }
    internal bool PerformanceCountersEnabled { get; }
    internal bool HttpListenerUnescapeRequestUrl { get; }
    internal Int64[] HttpListenerTimeouts { get; }
    internal UnicodeDecodingConformance WebUtilityUnicodeDecodingConformance { get; private set; }
    internal UnicodeEncodingConformance WebUtilityUnicodeEncodingConformance { get; private set; }
    internal SettingsSectionInternal(SettingsSection section);
    private static SettingsSectionInternal();
    internal static SettingsSectionInternal get_Section();
    internal static SettingsSectionInternal GetSection();
    internal bool get_AlwaysUseCompletionPortsForAccept();
    internal bool get_AlwaysUseCompletionPortsForConnect();
    internal int get_AutoConfigUrlRetryInterval();
    internal bool get_CheckCertificateName();
    internal bool get_CheckCertificateRevocationList();
    internal void set_CheckCertificateRevocationList(bool value);
    internal int get_DefaultCredentialsHandleCacheSize();
    internal void set_DefaultCredentialsHandleCacheSize(int value);
    internal int get_DnsRefreshTimeout();
    internal void set_DnsRefreshTimeout(int value);
    internal int get_DownloadTimeout();
    internal bool get_EnableDnsRoundRobin();
    internal void set_EnableDnsRoundRobin(bool value);
    internal EncryptionPolicy get_EncryptionPolicy();
    internal bool get_Expect100Continue();
    internal void set_Expect100Continue(bool value);
    internal IPProtectionLevel get_IPProtectionLevel();
    internal bool get_Ipv6Enabled();
    internal int get_MaximumResponseHeadersLength();
    internal void set_MaximumResponseHeadersLength(int value);
    internal int get_MaximumUnauthorizedUploadLength();
    internal int get_MaximumErrorResponseLength();
    internal void set_MaximumErrorResponseLength(int value);
    internal bool get_UseUnsafeHeaderParsing();
    internal bool get_UseNagleAlgorithm();
    internal void set_UseNagleAlgorithm(bool value);
    internal bool get_PerformanceCountersEnabled();
    internal bool get_HttpListenerUnescapeRequestUrl();
    internal Int64[] get_HttpListenerTimeouts();
    [CompilerGeneratedAttribute]
internal UnicodeDecodingConformance get_WebUtilityUnicodeDecodingConformance();
    [CompilerGeneratedAttribute]
private void set_WebUtilityUnicodeDecodingConformance(UnicodeDecodingConformance value);
    [CompilerGeneratedAttribute]
internal UnicodeEncodingConformance get_WebUtilityUnicodeEncodingConformance();
    [CompilerGeneratedAttribute]
private void set_WebUtilityUnicodeEncodingConformance(UnicodeEncodingConformance value);
}
public class System.Net.Configuration.SmtpNetworkElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("defaultCredentials")]
public bool DefaultCredentials { get; public set; }
    [ConfigurationPropertyAttribute("host")]
public string Host { get; public set; }
    [ConfigurationPropertyAttribute("targetName")]
public string TargetName { get; public set; }
    [ConfigurationPropertyAttribute("clientDomain")]
public string ClientDomain { get; public set; }
    [ConfigurationPropertyAttribute("password")]
public string Password { get; public set; }
    [ConfigurationPropertyAttribute("port")]
public int Port { get; public set; }
    [ConfigurationPropertyAttribute("userName")]
public string UserName { get; public set; }
    [ConfigurationPropertyAttribute("enableSsl")]
public bool EnableSsl { get; public set; }
    protected virtual void PostDeserialize();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public bool get_DefaultCredentials();
    public void set_DefaultCredentials(bool value);
    public string get_Host();
    public void set_Host(string value);
    public string get_TargetName();
    public void set_TargetName(string value);
    public string get_ClientDomain();
    public void set_ClientDomain(string value);
    public string get_Password();
    public void set_Password(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_UserName();
    public void set_UserName(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
}
internal class System.Net.Configuration.SmtpNetworkElementInternal : object {
    internal NetworkCredential Credential { get; }
    internal string Host { get; }
    internal string ClientDomain { get; }
    internal int Port { get; }
    internal string TargetName { get; }
    internal bool EnableSsl { get; }
    internal SmtpNetworkElementInternal(SmtpNetworkElement element);
    internal NetworkCredential get_Credential();
    internal string get_Host();
    internal string get_ClientDomain();
    internal int get_Port();
    internal string get_TargetName();
    internal bool get_EnableSsl();
}
public class System.Net.Configuration.SmtpSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("deliveryMethod")]
public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    [ConfigurationPropertyAttribute("deliveryFormat")]
public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    [ConfigurationPropertyAttribute("from")]
public string From { get; public set; }
    [ConfigurationPropertyAttribute("network")]
public SmtpNetworkElement Network { get; }
    [ConfigurationPropertyAttribute("specifiedPickupDirectory")]
public SmtpSpecifiedPickupDirectoryElement SpecifiedPickupDirectory { get; }
    protected ConfigurationPropertyCollection Properties { get; }
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_From();
    public void set_From(string value);
    public SmtpNetworkElement get_Network();
    public SmtpSpecifiedPickupDirectoryElement get_SpecifiedPickupDirectory();
    protected virtual ConfigurationPropertyCollection get_Properties();
}
internal class System.Net.Configuration.SmtpSectionInternal : object {
    internal SmtpDeliveryMethod DeliveryMethod { get; }
    internal SmtpDeliveryFormat DeliveryFormat { get; }
    internal SmtpNetworkElementInternal Network { get; }
    internal string From { get; }
    internal SmtpSpecifiedPickupDirectoryElementInternal SpecifiedPickupDirectory { get; }
    internal static object ClassSyncObject { get; }
    internal SmtpSectionInternal(SmtpSection section);
    internal SmtpDeliveryMethod get_DeliveryMethod();
    internal SmtpDeliveryFormat get_DeliveryFormat();
    internal SmtpNetworkElementInternal get_Network();
    internal string get_From();
    internal SmtpSpecifiedPickupDirectoryElementInternal get_SpecifiedPickupDirectory();
    internal static object get_ClassSyncObject();
    internal static SmtpSectionInternal GetSection();
}
public class System.Net.Configuration.SmtpSpecifiedPickupDirectoryElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("pickupDirectoryLocation")]
public string PickupDirectoryLocation { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
}
internal class System.Net.Configuration.SmtpSpecifiedPickupDirectoryElementInternal : object {
    internal string PickupDirectoryLocation { get; }
    internal SmtpSpecifiedPickupDirectoryElementInternal(SmtpSpecifiedPickupDirectoryElement element);
    internal string get_PickupDirectoryLocation();
}
public class System.Net.Configuration.SocketElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("alwaysUseCompletionPortsForAccept")]
public bool AlwaysUseCompletionPortsForAccept { get; public set; }
    [ConfigurationPropertyAttribute("alwaysUseCompletionPortsForConnect")]
public bool AlwaysUseCompletionPortsForConnect { get; public set; }
    [ConfigurationPropertyAttribute("ipProtectionLevel")]
public IPProtectionLevel IPProtectionLevel { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual void PostDeserialize();
    public bool get_AlwaysUseCompletionPortsForAccept();
    public void set_AlwaysUseCompletionPortsForAccept(bool value);
    public bool get_AlwaysUseCompletionPortsForConnect();
    public void set_AlwaysUseCompletionPortsForConnect(bool value);
    public IPProtectionLevel get_IPProtectionLevel();
    public void set_IPProtectionLevel(IPProtectionLevel value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public enum System.Net.Configuration.UnicodeDecodingConformance : Enum {
    public int value__;
    public static UnicodeDecodingConformance Auto;
    public static UnicodeDecodingConformance Strict;
    public static UnicodeDecodingConformance Compat;
    public static UnicodeDecodingConformance Loose;
}
public enum System.Net.Configuration.UnicodeEncodingConformance : Enum {
    public int value__;
    public static UnicodeEncodingConformance Auto;
    public static UnicodeEncodingConformance Strict;
    public static UnicodeEncodingConformance Compat;
}
public class System.Net.Configuration.WebProxyScriptElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("autoConfigUrlRetryInterval")]
public int AutoConfigUrlRetryInterval { get; public set; }
    [ConfigurationPropertyAttribute("downloadTimeout")]
public TimeSpan DownloadTimeout { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    protected virtual void PostDeserialize();
    public int get_AutoConfigUrlRetryInterval();
    public void set_AutoConfigUrlRetryInterval(int value);
    public TimeSpan get_DownloadTimeout();
    public void set_DownloadTimeout(TimeSpan value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.WebRequestModuleElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("prefix")]
public string Prefix { get; public set; }
    [ConfigurationPropertyAttribute("type")]
[TypeConverterAttribute("System.Net.Configuration.WebRequestModuleElement/TypeTypeConverter")]
public Type Type { get; public set; }
    internal string Key { get; }
    public WebRequestModuleElement(string prefix, string type);
    public WebRequestModuleElement(string prefix, Type type);
    protected virtual ConfigurationPropertyCollection get_Properties();
    public string get_Prefix();
    public void set_Prefix(string value);
    public Type get_Type();
    public void set_Type(Type value);
    internal string get_Key();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Net.Configuration.WebRequestModuleElement")]
public class System.Net.Configuration.WebRequestModuleElementCollection : ConfigurationElementCollection {
    public WebRequestModuleElement Item { get; public set; }
    public WebRequestModuleElement Item { get; public set; }
    public WebRequestModuleElement get_Item(int index);
    public void set_Item(int index, WebRequestModuleElement value);
    public WebRequestModuleElement get_Item(string name);
    public void set_Item(string name, WebRequestModuleElement value);
    public void Add(WebRequestModuleElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(WebRequestModuleElement element);
    public void Remove(WebRequestModuleElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
public class System.Net.Configuration.WebRequestModulesSection : ConfigurationSection {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("")]
public WebRequestModuleElementCollection WebRequestModules { get; }
    protected virtual void PostDeserialize();
    protected virtual void InitializeDefault();
    protected virtual ConfigurationPropertyCollection get_Properties();
    public WebRequestModuleElementCollection get_WebRequestModules();
}
internal class System.Net.Configuration.WebRequestModulesSectionInternal : object {
    internal static object ClassSyncObject { get; }
    internal ArrayList WebRequestModules { get; }
    internal WebRequestModulesSectionInternal(WebRequestModulesSection section);
    private static WebRequestModulesSectionInternal();
    internal static object get_ClassSyncObject();
    internal static WebRequestModulesSectionInternal GetSection();
    internal ArrayList get_WebRequestModules();
}
public class System.Net.Configuration.WebUtilityElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("unicodeDecodingConformance")]
public UnicodeDecodingConformance UnicodeDecodingConformance { get; public set; }
    [ConfigurationPropertyAttribute("unicodeEncodingConformance")]
public UnicodeEncodingConformance UnicodeEncodingConformance { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    public UnicodeDecodingConformance get_UnicodeDecodingConformance();
    public void set_UnicodeDecodingConformance(UnicodeDecodingConformance value);
    public UnicodeEncodingConformance get_UnicodeEncodingConformance();
    public void set_UnicodeEncodingConformance(UnicodeEncodingConformance value);
    protected virtual ConfigurationPropertyCollection get_Properties();
}
public class System.Net.Configuration.WindowsAuthenticationElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("defaultCredentialsHandleCacheSize")]
public int DefaultCredentialsHandleCacheSize { get; public set; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public int get_DefaultCredentialsHandleCacheSize();
    public void set_DefaultCredentialsHandleCacheSize(int value);
}
internal class System.Net.Connection : PooledStream {
    internal Exception m_InnerException;
    internal int m_IISVersion;
    internal ServicePoint ServicePoint { get; }
    internal HttpWebRequest LockedRequest { get; internal set; }
    internal int BusyCount { get; }
    internal int IISVersion { get; }
    internal bool AtLeastOneResponseReceived { get; }
    internal bool KeepAlive { get; }
    internal bool NonKeepAliveRequestPipelined { get; }
    internal Connection(ConnectionGroup connectionGroup);
    private static Connection();
    internal virtual ServicePoint get_ServicePoint();
    internal HttpWebRequest get_LockedRequest();
    internal void set_LockedRequest(HttpWebRequest value);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    internal int get_BusyCount();
    internal int get_IISVersion();
    internal bool get_AtLeastOneResponseReceived();
    internal bool SubmitRequest(HttpWebRequest request, bool forcedsubmit);
    internal void WriteStartNextRequest(HttpWebRequest request, ConnectionReturnResult& returnResult);
    internal void SetLeftoverBytes(Byte[] buffer, int bufferOffset, int bufferCount);
    internal void ReadStartNextRequest(WebRequest currentRequest, ConnectionReturnResult& returnResult);
    internal void MarkAsReserved();
    internal void CheckStartReceive(HttpWebRequest request);
    internal bool get_KeepAlive();
    internal bool get_NonKeepAliveRequestPipelined();
    internal void CloseOnIdle();
    internal bool AbortOrDisassociate(HttpWebRequest request, WebException webException);
    internal void AbortSocket(bool isAbortState);
    internal void RemoveFromConnectionList();
    internal void HandleConnectStreamException(bool writeDone, bool readDone, WebExceptionStatus webExceptionStatus, ConnectionReturnResult& returnResult, Exception e);
    internal void PollAndRead(HttpWebRequest request, bool userRetrievedStream);
    internal void SyncRead(HttpWebRequest request, bool userRetrievedStream, bool probeRead);
    internal void Write(ScatterGatherBuffers writeBuffer);
    [ConditionalAttribute("DEBUG")]
internal void DebugMembers(int requestHash);
}
internal class System.Net.ConnectionGroup : object {
    internal bool m_AuthenticationGroup;
    internal string Name { get; }
    internal ServicePoint ServicePoint { get; }
    internal int CurrentConnections { get; }
    internal int ConnectionLimit { get; internal set; }
    internal ConnectionGroup(ServicePoint servicePoint, string connName);
    internal string get_Name();
    internal ServicePoint get_ServicePoint();
    internal int get_CurrentConnections();
    internal int get_ConnectionLimit();
    internal void set_ConnectionLimit(int value);
    internal static string MakeQueryStr(string connName);
    internal void Associate(Connection connection);
    internal void Disassociate(Connection connection);
    internal void ConnectionGoneIdle();
    internal void IncrementConnection();
    internal void DecrementConnection();
    internal void CancelIdleTimer();
    internal void DisableKeepAliveOnConnections();
    internal Connection FindConnection(HttpWebRequest request, string connName, Boolean& forcedsubmit);
    [ConditionalAttribute("DEBUG")]
internal void DebugMembers(int requestHash);
}
internal enum System.Net.ConnectionModes : Enum {
    public int value__;
    public static ConnectionModes Single;
    public static ConnectionModes Persistent;
    public static ConnectionModes Pipeline;
    public static ConnectionModes Mux;
}
internal class System.Net.ConnectionPool : object {
    internal int Count { get; }
    internal ServicePoint ServicePoint { get; }
    internal int MaxPoolSize { get; }
    internal int MinPoolSize { get; }
    internal ConnectionPool(ServicePoint servicePoint, int maxPoolSize, int minPoolSize, int idleTimeout, CreateConnectionDelegate createConnectionCallback);
    private static ConnectionPool();
    internal int get_Count();
    internal ServicePoint get_ServicePoint();
    internal int get_MaxPoolSize();
    internal int get_MinPoolSize();
    internal void ForceCleanup();
    internal void Abort();
    internal PooledStream GetConnection(object owningObject, GeneralAsyncDelegate asyncCallback, int creationTimeout);
    internal void PutConnection(PooledStream pooledStream, object owningObject, int creationTimeout);
    internal void PutConnection(PooledStream pooledStream, object owningObject, int creationTimeout, bool canReuse);
}
internal class System.Net.ConnectionPoolManager : object {
    private static ConnectionPoolManager();
    internal static ConnectionPool GetConnectionPool(ServicePoint servicePoint, string groupName, CreateConnectionDelegate createConnectionCallback);
    internal static bool RemoveConnectionPool(ServicePoint servicePoint, string groupName);
    internal static void CleanupConnectionPool(ServicePoint servicePoint, string groupName);
}
internal class System.Net.ConnectionReturnResult : object {
    internal bool IsNotEmpty { get; }
    internal ConnectionReturnResult(int capacity);
    private static ConnectionReturnResult();
    internal bool get_IsNotEmpty();
    internal static void Add(ConnectionReturnResult& returnResult, HttpWebRequest request, CoreResponseData coreResponseData);
    internal static void AddExceptionRange(ConnectionReturnResult& returnResult, HttpWebRequest[] requests, Exception exception);
    internal static void AddExceptionRange(ConnectionReturnResult& returnResult, HttpWebRequest[] requests, int abortedPipelinedRequestIndex, Exception exception, Exception firstRequestException);
    internal static void SetResponses(ConnectionReturnResult returnResult);
}
internal class System.Net.ConnectStream : Stream {
    internal static Byte[] s_DrainingBuffer;
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal bool FinishedAfterWrite { get; internal set; }
    internal bool IgnoreSocketErrors { get; }
    unknown bool SuppressWrite {internal set; }
    internal Connection Connection { get; }
    internal bool BufferOnly { get; }
    internal ScatterGatherBuffers BufferedData { get; internal set; }
    internal long BytesLeftToWrite { get; internal set; }
    internal bool IsPostStream { get; }
    internal bool ErrorInStream { get; }
    internal bool IsClosed { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Eof { get; }
    public ConnectStream(Connection connection, HttpWebRequest request);
    public ConnectStream(Connection connection, Byte[] buffer, int offset, int bufferCount, long readCount, bool chunked, HttpWebRequest request);
    private static ConnectStream();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    [CompilerGeneratedAttribute]
internal bool get_FinishedAfterWrite();
    [CompilerGeneratedAttribute]
internal void set_FinishedAfterWrite(bool value);
    internal bool get_IgnoreSocketErrors();
    internal void ErrorResponseNotify(bool isKeepAlive);
    internal void FatalResponseNotify();
    internal void SwitchToContentLength();
    internal void set_SuppressWrite(bool value);
    internal Connection get_Connection();
    internal bool get_BufferOnly();
    internal ScatterGatherBuffers get_BufferedData();
    internal void set_BufferedData(ScatterGatherBuffers value);
    internal long get_BytesLeftToWrite();
    internal void set_BytesLeftToWrite(long value);
    internal bool get_IsPostStream();
    internal bool get_ErrorInStream();
    internal void CallDone();
    internal void ProcessWriteCallDone(ConnectionReturnResult returnResult);
    internal bool get_IsClosed();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal bool get_Eof();
    internal void ResubmitWrite(ConnectStream oldStream, bool suppressWrite);
    internal void EnableWriteBuffering();
    internal int FillFromBufferedData(Byte[] buffer, Int32& offset, Int32& size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    internal void WriteHeaders(bool async);
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal void PollAndRead(bool userRetrievedStream);
    internal int SetRtcOption(Byte[] rtcInputSocketConfig, Byte[] rtcOutputSocketResult);
    protected virtual void Dispose(bool disposing);
    internal void CloseInternal(bool internalCall);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    internal static Byte[] GetChunkHeader(int size, Int32& offset);
    private sealed virtual override void System.Net.IRequestLifetimeTracker.TrackRequestLifetime(long requestStartTimestamp);
}
internal class System.Net.ConnectStreamContext : TransportContext {
    internal ConnectStreamContext(ConnectStream connectStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal enum System.Net.ContentTypeValues : Enum {
    public int value__;
    public static ContentTypeValues ChangeCipherSpec;
    public static ContentTypeValues Alert;
    public static ContentTypeValues HandShake;
    public static ContentTypeValues AppData;
    public static ContentTypeValues Unrecognized;
}
internal enum System.Net.ContextAttribute : Enum {
    public int value__;
    public static ContextAttribute Sizes;
    public static ContextAttribute Names;
    public static ContextAttribute Lifespan;
    public static ContextAttribute DceInfo;
    public static ContextAttribute StreamSizes;
    public static ContextAttribute Authority;
    public static ContextAttribute PackageInfo;
    public static ContextAttribute NegotiationInfo;
    public static ContextAttribute UniqueBindings;
    public static ContextAttribute EndpointBindings;
    public static ContextAttribute ClientSpecifiedSpn;
    public static ContextAttribute RemoteCertificate;
    public static ContextAttribute LocalCertificate;
    public static ContextAttribute RootStore;
    public static ContextAttribute IssuerListInfoEx;
    public static ContextAttribute ConnectionInfo;
    public static ContextAttribute UiInfo;
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    internal ExecutionContext ContextCopy { get; }
    internal WindowsIdentity Identity { get; }
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal WindowsIdentity get_Identity();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    internal bool FinishPostingAsyncOp(CallbackClosure& closure);
    protected virtual void Cleanup();
    protected virtual void Complete(IntPtr userToken);
}
[FlagsAttribute]
internal enum System.Net.ContextFlags : Enum {
    public int value__;
    public static ContextFlags Zero;
    public static ContextFlags Delegate;
    public static ContextFlags MutualAuth;
    public static ContextFlags ReplayDetect;
    public static ContextFlags SequenceDetect;
    public static ContextFlags Confidentiality;
    public static ContextFlags UseSessionKey;
    public static ContextFlags AllocateMemory;
    public static ContextFlags Connection;
    public static ContextFlags InitExtendedError;
    public static ContextFlags AcceptExtendedError;
    public static ContextFlags InitStream;
    public static ContextFlags AcceptStream;
    public static ContextFlags InitIntegrity;
    public static ContextFlags AcceptIntegrity;
    public static ContextFlags InitManualCredValidation;
    public static ContextFlags InitUseSuppliedCreds;
    public static ContextFlags InitIdentify;
    public static ContextFlags AcceptIdentify;
    public static ContextFlags ProxyBindings;
    public static ContextFlags AllowMissingBindings;
    public static ContextFlags UnverifiedTargetName;
}
public class System.Net.Cookie : object {
    internal static int MaxSupportedVersion;
    internal static string CommentAttributeName;
    internal static string CommentUrlAttributeName;
    internal static string DiscardAttributeName;
    internal static string DomainAttributeName;
    internal static string ExpiresAttributeName;
    internal static string MaxAgeAttributeName;
    internal static string PathAttributeName;
    internal static string PortAttributeName;
    internal static string SecureAttributeName;
    internal static string VersionAttributeName;
    internal static string HttpOnlyAttributeName;
    internal static string SeparatorLiteral;
    internal static string EqualsLiteral;
    internal static string QuotesLiteral;
    internal static string SpecialAttributeLiteral;
    internal static Char[] PortSplitDelimiters;
    internal static Char[] Reserved2Name;
    internal static Char[] Reserved2Value;
    internal bool IsQuotedVersion;
    internal bool IsQuotedDomain;
    public string Comment { get; public set; }
    public Uri CommentUri { get; public set; }
    public bool HttpOnly { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    internal bool DomainImplicit { get; internal set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    internal bool Plain { get; }
    public string Port { get; public set; }
    internal Int32[] PortList { get; }
    public bool Secure { get; public set; }
    public DateTime TimeStamp { get; }
    public string Value { get; public set; }
    internal CookieVariant Variant { get; internal set; }
    internal string DomainKey { get; }
    public int Version { get; public set; }
    public Cookie(string name, string value);
    public Cookie(string name, string value, string path);
    public Cookie(string name, string value, string path, string domain);
    private static Cookie();
    public string get_Comment();
    public void set_Comment(string value);
    public Uri get_CommentUri();
    public void set_CommentUri(Uri value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public bool get_Discard();
    public void set_Discard(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    internal bool get_DomainImplicit();
    internal void set_DomainImplicit(bool value);
    public bool get_Expired();
    public void set_Expired(bool value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public string get_Name();
    public void set_Name(string value);
    internal bool InternalSetName(string value);
    public string get_Path();
    public void set_Path(string value);
    internal bool get_Plain();
    internal Cookie Clone();
    internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool set_default, bool isThrow);
    public string get_Port();
    public void set_Port(string value);
    internal Int32[] get_PortList();
    public bool get_Secure();
    public void set_Secure(bool value);
    public DateTime get_TimeStamp();
    public string get_Value();
    public void set_Value(string value);
    internal CookieVariant get_Variant();
    internal void set_Variant(CookieVariant value);
    internal string get_DomainKey();
    public int get_Version();
    public void set_Version(int value);
    internal static IComparer GetComparer();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToServerString();
}
[DefaultMemberAttribute("Item")]
public class System.Net.CookieCollection : object {
    internal int m_version;
    public bool IsReadOnly { get; }
    public Cookie Item { get; }
    public Cookie Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal bool IsOtherVersionSeen { get; }
    internal CookieCollection(bool IsReadOnly);
    public bool get_IsReadOnly();
    public Cookie get_Item(int index);
    public Cookie get_Item(string name);
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Cookie[] array, int index);
    internal DateTime TimeStamp(Stamp how);
    internal bool get_IsOtherVersionSeen();
    internal int InternalAdd(Cookie cookie, bool isStrict);
    internal int IndexOf(Cookie cookie);
    internal void RemoveAt(int idx);
    public sealed virtual IEnumerator GetEnumerator();
}
public class System.Net.CookieContainer : object {
    public static int DefaultCookieLimit;
    public static int DefaultPerDomainCookieLimit;
    public static int DefaultCookieLengthLimit;
    public int Capacity { get; public set; }
    public int Count { get; }
    public int MaxCookieSize { get; public set; }
    public int PerDomainCapacity { get; public set; }
    public CookieContainer(int capacity);
    public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize);
    private static CookieContainer();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public int get_MaxCookieSize();
    public void set_MaxCookieSize(int value);
    public int get_PerDomainCapacity();
    public void set_PerDomainCapacity(int value);
    public void Add(Cookie cookie);
    internal void Add(Cookie cookie, bool throwOnError);
    public void Add(CookieCollection cookies);
    internal bool IsLocalDomain(string host);
    public void Add(Uri uri, Cookie cookie);
    public void Add(Uri uri, CookieCollection cookies);
    internal CookieCollection CookieCutter(Uri uri, string headerName, string setCookieHeader, bool isThrow);
    public CookieCollection GetCookies(Uri uri);
    internal CookieCollection InternalGetCookies(Uri uri);
    public string GetCookieHeader(Uri uri);
    internal string GetCookieHeader(Uri uri, String& optCookie2);
    public void SetCookies(Uri uri, string cookieHeader);
}
public class System.Net.CookieException : FormatException {
    internal CookieException(string message);
    internal CookieException(string message, Exception inner);
    protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.Net.CookieModule : object {
    internal static void OnSendingHeaders(HttpWebRequest httpWebRequest);
    internal static void OnReceivedHeaders(HttpWebRequest httpWebRequest);
}
internal class System.Net.CookieParser : object {
    internal CookieParser(string cookieString);
    internal Cookie Get();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
    internal bool EndofHeader();
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : object {
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.CookieVariant : Enum {
    public int value__;
    public static CookieVariant Unknown;
    public static CookieVariant Plain;
    public static CookieVariant Rfc2109;
    public static CookieVariant Rfc2965;
    public static CookieVariant Default;
}
internal class System.Net.CoreResponseData : object {
    public HttpStatusCode m_StatusCode;
    public string m_StatusDescription;
    public bool m_IsVersionHttp11;
    public long m_ContentLength;
    public WebHeaderCollection m_ResponseHeaders;
    public Stream m_ConnectStream;
    internal CoreResponseData Clone();
}
internal class System.Net.CreateConnectionDelegate : MulticastDelegate {
    public CreateConnectionDelegate(object object, IntPtr method);
    public virtual PooledStream Invoke(ConnectionPool pool);
    public virtual IAsyncResult BeginInvoke(ConnectionPool pool, AsyncCallback callback, object object);
    public virtual PooledStream EndInvoke(IAsyncResult result);
}
public class System.Net.CredentialCache : object {
    internal int m_version;
    internal bool IsDefaultInCache { get; }
    public static ICredentials DefaultCredentials { get; }
    public static NetworkCredential DefaultNetworkCredentials { get; }
    internal bool get_IsDefaultInCache();
    public void Add(Uri uriPrefix, string authType, NetworkCredential cred);
    public void Add(string host, int port, string authenticationType, NetworkCredential credential);
    public void Remove(Uri uriPrefix, string authType);
    public void Remove(string host, int port, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(Uri uriPrefix, string authType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    public sealed virtual IEnumerator GetEnumerator();
    public static ICredentials get_DefaultCredentials();
    public static NetworkCredential get_DefaultNetworkCredentials();
}
internal class System.Net.CredentialHostKey : object {
    internal string Host;
    internal string AuthenticationType;
    internal int Port;
    internal CredentialHostKey(string host, int port, string authenticationType);
    internal bool Match(string host, int port, string authenticationType);
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
}
internal class System.Net.CredentialKey : object {
    internal Uri UriPrefix;
    internal int UriPrefixLength;
    internal string AuthenticationType;
    internal CredentialKey(Uri uriPrefix, string authenticationType);
    internal bool Match(Uri uri, string authenticationType);
    internal bool IsPrefix(Uri uri, Uri prefixUri);
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
}
internal enum System.Net.CredentialUse : Enum {
    public int value__;
    public static CredentialUse Inbound;
    public static CredentialUse Outbound;
    public static CredentialUse Both;
}
internal enum System.Net.DataParseStatus : Enum {
    public int value__;
    public static DataParseStatus NeedMoreData;
    public static DataParseStatus ContinueParsing;
    public static DataParseStatus Done;
    public static DataParseStatus Invalid;
    public static DataParseStatus DataTooBig;
}
[FlagsAttribute]
public enum System.Net.DecompressionMethods : Enum {
    public int value__;
    public static DecompressionMethods None;
    public static DecompressionMethods GZip;
    public static DecompressionMethods Deflate;
}
internal class System.Net.DefaultCertPolicy : object {
    public sealed virtual bool CheckValidationResult(ServicePoint sp, X509Certificate cert, WebRequest request, int problem);
}
internal enum System.Net.DefaultPorts : Enum {
    public int value__;
    public static DefaultPorts DEFAULT_FTP_PORT;
    public static DefaultPorts DEFAULT_GOPHER_PORT;
    public static DefaultPorts DEFAULT_HTTP_PORT;
    public static DefaultPorts DEFAULT_HTTPS_PORT;
    public static DefaultPorts DEFAULT_NNTP_PORT;
    public static DefaultPorts DEFAULT_SMTP_PORT;
    public static DefaultPorts DEFAULT_TELNET_PORT;
}
internal class System.Net.DeflateWrapperStream : DeflateStream {
    public DeflateWrapperStream(Stream stream, CompressionMode mode);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int size);
    private sealed virtual override void System.Net.IRequestLifetimeTracker.TrackRequestLifetime(long requestStartTimestamp);
}
internal class System.Net.DelayedRegex : object {
    internal Regex AsRegex { get; }
    internal DelayedRegex(string regexString);
    internal DelayedRegex(Regex regex);
    internal Regex get_AsRegex();
    public virtual string ToString();
}
internal class System.Net.DelegatedStream : Stream {
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.DigestClient : object {
    internal static string AuthType;
    internal static string Signature;
    internal static int SignatureSize;
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public bool CanUseDefaultCredentials { get; }
    internal static bool WDigestAvailable { get; }
    private static DigestClient();
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual bool get_CanPreAuthenticate();
    public sealed virtual string get_AuthenticationType();
    internal static bool CheckQOP(HttpDigestChallenge challenge);
    public sealed virtual bool Update(string challenge, WebRequest webRequest);
    public sealed virtual bool get_CanUseDefaultCredentials();
    internal static bool get_WDigestAvailable();
    public sealed virtual void ClearSession(WebRequest webRequest);
}
internal class System.Net.DirectProxy : ProxyChain {
    internal DirectProxy(Uri destination);
    protected virtual bool GetNextProxy(Uri& proxy);
}
public static class System.Net.Dns : object {
    private static Dns();
    [ObsoleteAttribute("GetHostByName is obsoleted for this type, please use GetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByName(string hostName);
    internal static IPHostEntry InternalGetHostByName(string hostName);
    internal static IPHostEntry InternalGetHostByName(string hostName, bool includeIPv6);
    [ObsoleteAttribute("GetHostByAddress is obsoleted for this type, please use GetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByAddress(string address);
    [ObsoleteAttribute("GetHostByAddress is obsoleted for this type, please use GetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry GetHostByAddress(IPAddress address);
    internal static IPHostEntry InternalGetHostByAddress(IPAddress address, bool includeIPv6);
    public static string GetHostName();
    [ObsoleteAttribute("Resolve is obsoleted for this type, please use GetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry Resolve(string hostName);
    internal static bool TryInternalResolve(string hostName, IPHostEntry& result);
    [ObsoleteAttribute("BeginGetHostByName is obsoleted for this type, please use BeginGetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IAsyncResult BeginGetHostByName(string hostName, AsyncCallback requestCallback, object stateObject);
    [ObsoleteAttribute("EndGetHostByName is obsoleted for this type, please use EndGetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry EndGetHostByName(IAsyncResult asyncResult);
    public static IPHostEntry GetHostEntry(string hostNameOrAddress);
    public static IPHostEntry GetHostEntry(IPAddress address);
    public static IPAddress[] GetHostAddresses(string hostNameOrAddress);
    public static IAsyncResult BeginGetHostEntry(string hostNameOrAddress, AsyncCallback requestCallback, object stateObject);
    public static IAsyncResult BeginGetHostEntry(IPAddress address, AsyncCallback requestCallback, object stateObject);
    public static IPHostEntry EndGetHostEntry(IAsyncResult asyncResult);
    public static IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state);
    public static IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult);
    internal static IAsyncResult UnsafeBeginGetHostAddresses(string hostName, AsyncCallback requestCallback, object state);
    [ObsoleteAttribute("BeginResolve is obsoleted for this type, please use BeginGetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IAsyncResult BeginResolve(string hostName, AsyncCallback requestCallback, object stateObject);
    [ObsoleteAttribute("EndResolve is obsoleted for this type, please use EndGetHostEntry instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static IPHostEntry EndResolve(IAsyncResult asyncResult);
    public static Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress);
    public static Task`1<IPHostEntry> GetHostEntryAsync(IPAddress address);
    public static Task`1<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress);
    internal static string TryGetNameInfo(IPAddress addr, SocketError& errorCode);
}
public class System.Net.DnsEndPoint : EndPoint {
    public string Host { get; }
    public AddressFamily AddressFamily { get; }
    public int Port { get; }
    public DnsEndPoint(string host, int port);
    public DnsEndPoint(string host, int port, AddressFamily addressFamily);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_Host();
    public virtual AddressFamily get_AddressFamily();
    public int get_Port();
}
public class System.Net.DnsPermission : CodeAccessPermission {
    public DnsPermission(PermissionState state);
    internal DnsPermission(bool free);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.DnsPermissionAttribute : CodeAccessSecurityAttribute {
    public DnsPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class System.Net.DownloadDataCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    internal DownloadDataCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.DownloadDataCompletedEventHandler : MulticastDelegate {
    public DownloadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadProgressChangedEventArgs : ProgressChangedEventArgs {
    public long BytesReceived { get; }
    public long TotalBytesToReceive { get; }
    internal DownloadProgressChangedEventArgs(int progressPercentage, object userToken, long bytesReceived, long totalBytesToReceive);
    public long get_BytesReceived();
    public long get_TotalBytesToReceive();
}
public class System.Net.DownloadProgressChangedEventHandler : MulticastDelegate {
    public DownloadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.DownloadStringCompletedEventArgs : AsyncCompletedEventArgs {
    public string Result { get; }
    internal DownloadStringCompletedEventArgs(string result, Exception exception, bool cancelled, object userToken);
    public string get_Result();
}
public class System.Net.DownloadStringCompletedEventHandler : MulticastDelegate {
    public DownloadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DownloadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DownloadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.EmptyWebProxy : object {
    public ICredentials Credentials { get; public set; }
    public sealed virtual Uri GetProxy(Uri uri);
    public sealed virtual bool IsBypassed(Uri uri);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    private sealed virtual override ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination);
}
internal enum System.Net.Endianness : Enum {
    public int value__;
    public static Endianness Network;
    public static Endianness Native;
}
public abstract class System.Net.EndPoint : object {
    public AddressFamily AddressFamily { get; }
    public virtual AddressFamily get_AddressFamily();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
}
public class System.Net.EndpointPermission : object {
    internal string hostname;
    internal int port;
    internal TransportType transport;
    internal bool wildcard;
    internal IPAddress[] address;
    internal bool cached;
    public string Hostname { get; }
    public TransportType Transport { get; }
    public int Port { get; }
    internal bool IsDns { get; }
    internal EndpointPermission(string epname, int port, TransportType trtype);
    private static EndpointPermission();
    public string get_Hostname();
    public TransportType get_Transport();
    public int get_Port();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool get_IsDns();
    internal bool MatchAddress(EndpointPermission e);
    internal bool MatchWildcard(string str);
    internal void Resolve();
    internal bool SubsetMatch(EndpointPermission e);
    public virtual string ToString();
    internal EndpointPermission Intersect(EndpointPermission E);
}
internal enum System.Net.EntitySendFormat : Enum {
    public int value__;
    public static EntitySendFormat ContentLength;
    public static EntitySendFormat Chunked;
}
internal static class System.Net.ExceptionHelper : object {
    internal static KeyContainerPermission KeyContainerPermissionOpen;
    internal static WebPermission WebPermissionUnrestricted;
    internal static SecurityPermission UnmanagedPermission;
    internal static SocketPermission UnrestrictedSocketPermission;
    internal static SecurityPermission InfrastructurePermission;
    internal static SecurityPermission ControlPolicyPermission;
    internal static SecurityPermission ControlPrincipalPermission;
    internal static NotImplementedException MethodNotImplementedException { get; }
    internal static NotImplementedException PropertyNotImplementedException { get; }
    internal static NotSupportedException MethodNotSupportedException { get; }
    internal static NotSupportedException PropertyNotSupportedException { get; }
    internal static WebException IsolatedException { get; }
    internal static WebException RequestAbortedException { get; }
    internal static WebException CacheEntryNotFoundException { get; }
    internal static WebException RequestProhibitedByCachePolicyException { get; }
    private static ExceptionHelper();
    internal static NotImplementedException get_MethodNotImplementedException();
    internal static NotImplementedException get_PropertyNotImplementedException();
    internal static NotSupportedException get_MethodNotSupportedException();
    internal static NotSupportedException get_PropertyNotSupportedException();
    internal static WebException get_IsolatedException();
    internal static WebException get_RequestAbortedException();
    internal static WebException get_CacheEntryNotFoundException();
    internal static WebException get_RequestProhibitedByCachePolicyException();
}
public class System.Net.FileWebRequest : WebRequest {
    internal bool Aborted { get; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public Uri RequestUri { get; }
    public bool UseDefaultCredentials { get; public set; }
    internal FileWebRequest(Uri uri);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static FileWebRequest();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal bool get_Aborted();
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Uri get_RequestUri();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    internal void UnblockReader();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
}
internal class System.Net.FileWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FileWebResponse : WebResponse {
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    internal FileWebResponse(FileWebRequest request, Uri uri, FileAccess access, bool asyncHint);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    public virtual void Close();
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual Stream GetResponseStream();
}
internal class System.Net.FileWebStream : FileStream {
    public FileWebStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing);
    public FileWebStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult ar);
}
internal class System.Net.FixedSizeReader : object {
    public FixedSizeReader(Stream transport);
    private static FixedSizeReader();
    public int ReadPacket(Byte[] buffer, int offset, int count);
    public void AsyncReadPacket(AsyncProtocolRequest request);
}
internal class System.Net.FrameHeader : object {
    public static int IgnoreValue;
    public static int HandshakeDoneId;
    public static int HandshakeErrId;
    public static int HandshakeId;
    public static int DefaultMajorV;
    public static int DefaultMinorV;
    public int Size { get; }
    public int MaxMessageSize { get; }
    public int MessageId { get; public set; }
    public int MajorV { get; }
    public int MinorV { get; }
    public int PayloadSize { get; public set; }
    public FrameHeader(int messageId, int majorV, int minorV);
    public int get_Size();
    public int get_MaxMessageSize();
    public int get_MessageId();
    public void set_MessageId(int value);
    public int get_MajorV();
    public int get_MinorV();
    public int get_PayloadSize();
    public void set_PayloadSize(int value);
    public void CopyTo(Byte[] dest, int start);
    public void CopyFrom(Byte[] bytes, int start, FrameHeader verifier);
}
internal class System.Net.FtpControlStream : CommandStream {
    internal FtpStatusCode StatusCode;
    internal string StatusLine;
    internal NetworkCredential Credentials { get; internal set; }
    internal long ContentLength { get; }
    internal DateTime LastModified { get; }
    internal Uri ResponseUri { get; }
    internal string BannerMessage { get; }
    internal string WelcomeMessage { get; }
    internal string ExitMessage { get; }
    internal FtpControlStream(ConnectionPool connectionPool, TimeSpan lifetime, bool checkLifetime);
    private static FtpControlStream();
    internal NetworkCredential get_Credentials();
    internal void set_Credentials(NetworkCredential value);
    internal void AbortConnect();
    protected virtual void ClearState();
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest req);
    internal void Quit();
    internal long get_ContentLength();
    internal DateTime get_LastModified();
    internal Uri get_ResponseUri();
    internal string get_BannerMessage();
    internal string get_WelcomeMessage();
    internal string get_ExitMessage();
    protected Socket CreateFtpDataSocket(FtpWebRequest request, Socket templateSocket);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
}
internal class System.Net.FtpDataStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal FtpDataStream(NetworkStream networkStream, FtpWebRequest request, TriState writeOnly);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
}
internal enum System.Net.FtpLoginState : Enum {
    public byte value__;
    public static FtpLoginState NotLoggedIn;
    public static FtpLoginState LoggedIn;
    public static FtpLoginState LoggedInButNeedsRelogin;
    public static FtpLoginState ReloginFailed;
}
[FlagsAttribute]
internal enum System.Net.FtpMethodFlags : Enum {
    public int value__;
    public static FtpMethodFlags None;
    public static FtpMethodFlags IsDownload;
    public static FtpMethodFlags IsUpload;
    public static FtpMethodFlags TakesParameter;
    public static FtpMethodFlags MayTakeParameter;
    public static FtpMethodFlags DoesNotTakeParameter;
    public static FtpMethodFlags ParameterIsDirectory;
    public static FtpMethodFlags ShouldParseForResponseUri;
    public static FtpMethodFlags HasHttpCommand;
    public static FtpMethodFlags MustChangeWorkingDirectoryToPath;
}
internal class System.Net.FtpMethodInfo : object {
    internal string Method;
    internal FtpOperation Operation;
    internal FtpMethodFlags Flags;
    internal string HttpCommand;
    internal bool IsCommandOnly { get; }
    internal bool IsUpload { get; }
    internal bool IsDownload { get; }
    internal bool HasHttpCommand { get; }
    internal bool ShouldParseForResponseUri { get; }
    internal FtpMethodInfo(string method, FtpOperation operation, FtpMethodFlags flags, string httpCommand);
    private static FtpMethodInfo();
    internal bool HasFlag(FtpMethodFlags flags);
    internal bool get_IsCommandOnly();
    internal bool get_IsUpload();
    internal bool get_IsDownload();
    internal bool get_HasHttpCommand();
    internal bool get_ShouldParseForResponseUri();
    internal static FtpMethodInfo GetMethodInfo(string method);
}
internal enum System.Net.FtpOperation : Enum {
    public int value__;
    public static FtpOperation DownloadFile;
    public static FtpOperation ListDirectory;
    public static FtpOperation ListDirectoryDetails;
    public static FtpOperation UploadFile;
    public static FtpOperation UploadFileUnique;
    public static FtpOperation AppendFile;
    public static FtpOperation DeleteFile;
    public static FtpOperation GetDateTimestamp;
    public static FtpOperation GetFileSize;
    public static FtpOperation Rename;
    public static FtpOperation MakeDirectory;
    public static FtpOperation RemoveDirectory;
    public static FtpOperation PrintWorkingDirectory;
    public static FtpOperation Other;
}
internal enum System.Net.FtpPrimitive : Enum {
    public int value__;
    public static FtpPrimitive Upload;
    public static FtpPrimitive Download;
    public static FtpPrimitive CommandOnly;
}
public enum System.Net.FtpStatusCode : Enum {
    public int value__;
    public static FtpStatusCode Undefined;
    public static FtpStatusCode RestartMarker;
    public static FtpStatusCode ServiceTemporarilyNotAvailable;
    public static FtpStatusCode DataAlreadyOpen;
    public static FtpStatusCode OpeningData;
    public static FtpStatusCode CommandOK;
    public static FtpStatusCode CommandExtraneous;
    public static FtpStatusCode DirectoryStatus;
    public static FtpStatusCode FileStatus;
    public static FtpStatusCode SystemType;
    public static FtpStatusCode SendUserCommand;
    public static FtpStatusCode ClosingControl;
    public static FtpStatusCode ClosingData;
    public static FtpStatusCode EnteringPassive;
    public static FtpStatusCode LoggedInProceed;
    public static FtpStatusCode ServerWantsSecureSession;
    public static FtpStatusCode FileActionOK;
    public static FtpStatusCode PathnameCreated;
    public static FtpStatusCode SendPasswordCommand;
    public static FtpStatusCode NeedLoginAccount;
    public static FtpStatusCode FileCommandPending;
    public static FtpStatusCode ServiceNotAvailable;
    public static FtpStatusCode CantOpenData;
    public static FtpStatusCode ConnectionClosed;
    public static FtpStatusCode ActionNotTakenFileUnavailableOrBusy;
    public static FtpStatusCode ActionAbortedLocalProcessingError;
    public static FtpStatusCode ActionNotTakenInsufficientSpace;
    public static FtpStatusCode CommandSyntaxError;
    public static FtpStatusCode ArgumentSyntaxError;
    public static FtpStatusCode CommandNotImplemented;
    public static FtpStatusCode BadCommandSequence;
    public static FtpStatusCode NotLoggedIn;
    public static FtpStatusCode AccountNeeded;
    public static FtpStatusCode ActionNotTakenFileUnavailable;
    public static FtpStatusCode ActionAbortedUnknownPageType;
    public static FtpStatusCode FileActionAborted;
    public static FtpStatusCode ActionNotTakenFilenameNotAllowed;
}
public class System.Net.FtpWebRequest : WebRequest {
    internal FtpMethodInfo MethodInfo { get; }
    internal static NetworkCredential DefaultNetworkCredential { get; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public string Method { get; public set; }
    public string RenameTo { get; public set; }
    public ICredentials Credentials { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    internal int RemainingTimeout { get; }
    public int ReadWriteTimeout { get; public set; }
    public long ContentOffset { get; public set; }
    public long ContentLength { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public ServicePoint ServicePoint { get; }
    internal bool Aborted { get; }
    public bool KeepAlive { get; public set; }
    public bool UseBinary { get; public set; }
    public bool UsePassive { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public bool EnableSsl { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string ContentType { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool PreAuthenticate { get; public set; }
    internal FtpWebRequest(Uri uri);
    private static FtpWebRequest();
    internal FtpMethodInfo get_MethodInfo();
    internal static NetworkCredential get_DefaultNetworkCredential();
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public string get_RenameTo();
    public void set_RenameTo(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    internal int get_RemainingTimeout();
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public long get_ContentOffset();
    public void set_ContentOffset(long value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public ServicePoint get_ServicePoint();
    internal bool get_Aborted();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    internal virtual ContextAwareResult GetWritingContext();
    internal virtual void RequestCallback(object obj);
    public virtual void Abort();
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public bool get_UseBinary();
    public void set_UseBinary(bool value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    internal string GetUserString();
    internal void DataStreamClosed(CloseExState closeState);
}
internal class System.Net.FtpWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FtpWebResponse : WebResponse {
    internal Stream m_ResponseStream;
    public long ContentLength { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    public FtpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public DateTime LastModified { get; }
    public string BannerMessage { get; }
    public string WelcomeMessage { get; }
    public string ExitMessage { get; }
    internal FtpWebResponse(Stream responseStream, long contentLength, Uri responseUri, FtpStatusCode statusCode, string statusLine, DateTime lastModified, string bannerMessage, string welcomeMessage, string exitMessage);
    internal FtpWebResponse(HttpWebResponse httpWebResponse);
    internal void UpdateStatus(FtpStatusCode statusCode, string statusLine, string exitMessage);
    public virtual Stream GetResponseStream();
    internal void SetResponseStream(Stream stream);
    public virtual void Close();
    public virtual long get_ContentLength();
    internal void SetContentLength(long value);
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    public FtpStatusCode get_StatusCode();
    public string get_StatusDescription();
    public DateTime get_LastModified();
    public string get_BannerMessage();
    public string get_WelcomeMessage();
    public string get_ExitMessage();
}
internal class System.Net.GeneralAsyncDelegate : MulticastDelegate {
    public GeneralAsyncDelegate(object object, IntPtr method);
    public virtual void Invoke(object request, object state);
    public virtual IAsyncResult BeginInvoke(object request, object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.GlobalLog : object {
    internal static ThreadKinds CurrentThreadKind { get; }
    private static GlobalLog();
    internal static ThreadKinds get_CurrentThreadKind();
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("1", "0")]
internal static void SetThreadSource(ThreadKinds source);
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("1", "0")]
internal static void ThreadContract(ThreadKinds kind, string errorMsg);
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("1", "0")]
internal static void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg);
    [ConditionalAttribute("TRAVE")]
public static void AddToArray(string msg);
    [ConditionalAttribute("TRAVE")]
public static void Ignore(object msg);
    [ConditionalAttribute("TRAVE")]
[ReliabilityContractAttribute("1", "0")]
public static void Print(string msg);
    [ConditionalAttribute("TRAVE")]
public static void PrintHex(string msg, object value);
    [ConditionalAttribute("TRAVE")]
public static void Enter(string func);
    [ConditionalAttribute("TRAVE")]
public static void Enter(string func, string parms);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("_FORCE_ASSERTS")]
[ReliabilityContractAttribute("1", "0")]
public static void Assert(bool condition, string messageFormat, Object[] data);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("_FORCE_ASSERTS")]
[ReliabilityContractAttribute("1", "0")]
public static void Assert(string message);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("_FORCE_ASSERTS")]
[ReliabilityContractAttribute("1", "0")]
public static void Assert(string message, string detailMessage);
    [ConditionalAttribute("TRAVE")]
public static void LeaveException(string func, Exception exception);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, string result);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, int returnval);
    [ConditionalAttribute("TRAVE")]
public static void Leave(string func, bool returnval);
    [ConditionalAttribute("TRAVE")]
public static void DumpArray();
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer);
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer, int length);
    [ConditionalAttribute("TRAVE")]
public static void Dump(Byte[] buffer, int offset, int length);
    [ConditionalAttribute("TRAVE")]
public static void Dump(IntPtr buffer, int offset, int length);
    [ConditionalAttribute("DEBUG")]
internal static void DebugAddRequest(HttpWebRequest request, Connection connection, int flags);
    [ConditionalAttribute("DEBUG")]
internal static void DebugRemoveRequest(HttpWebRequest request);
    [ConditionalAttribute("DEBUG")]
internal static void DebugUpdateRequest(HttpWebRequest request, Connection connection, int flags);
}
[ObsoleteAttribute("This class has been deprecated. Please use WebRequest.DefaultWebProxy instead to access and set the global default proxy. Use 'null' instead of GetEmptyWebProxy. http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Net.GlobalProxySelection : object {
    public static IWebProxy Select { get; public set; }
    public static IWebProxy get_Select();
    public static void set_Select(IWebProxy value);
    public static IWebProxy GetEmptyWebProxy();
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIInterface SSPIAuth;
    internal static SSPIInterface SSPISecureChannel;
    private static GlobalSSPI();
}
internal class System.Net.GZipWrapperStream : GZipStream {
    public GZipWrapperStream(Stream stream, CompressionMode mode);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int size);
    private sealed virtual override void System.Net.IRequestLifetimeTracker.TrackRequestLifetime(long requestStartTimestamp);
}
internal class System.Net.HeaderInfo : object {
    internal bool IsRequestRestricted;
    internal bool IsResponseRestricted;
    internal HeaderParser Parser;
    internal string HeaderName;
    internal bool AllowMultiValues;
    internal HeaderInfo(string name, bool requestRestricted, bool responseRestricted, bool multi, HeaderParser p);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.HeaderInfoTable : object {
    internal HeaderInfo Item { get; }
    private static HeaderInfoTable();
    internal HeaderInfo get_Item(string name);
}
internal class System.Net.HeaderParser : MulticastDelegate {
    public HeaderParser(object object, IntPtr method);
    public virtual String[] Invoke(string value);
    public virtual IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class System.Net.HeaderVariantInfo : ValueType {
    private string m_name;
    private CookieVariant m_variant;
    internal string Name { get; }
    internal CookieVariant Variant { get; }
    internal HeaderVariantInfo(string name, CookieVariant variant);
    internal string get_Name();
    internal CookieVariant get_Variant();
}
internal class System.Net.hostent : ValueType {
    public IntPtr h_name;
    public IntPtr h_aliases;
    public short h_addrtype;
    public short h_length;
    public IntPtr h_addr_list;
}
internal class System.Net.HostHeaderString : object {
    internal string String { get; internal set; }
    internal int ByteCount { get; }
    internal Byte[] Bytes { get; }
    internal HostHeaderString(string s);
    internal string get_String();
    internal void set_String(string value);
    internal int get_ByteCount();
    internal Byte[] get_Bytes();
    internal void Copy(Byte[] destBytes, int destByteIndex);
}
internal class System.Net.HttpAbortDelegate : MulticastDelegate {
    public HttpAbortDelegate(object object, IntPtr method);
    public virtual bool Invoke(HttpWebRequest request, WebException webException);
    public virtual IAsyncResult BeginInvoke(HttpWebRequest request, WebException webException, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal enum System.Net.HttpBehaviour : Enum {
    public byte value__;
    public static HttpBehaviour Unknown;
    public static HttpBehaviour HTTP10;
    public static HttpBehaviour HTTP11PartiallyCompliant;
    public static HttpBehaviour HTTP11;
}
public class System.Net.HttpContinueDelegate : MulticastDelegate {
    public HttpContinueDelegate(object object, IntPtr method);
    public virtual void Invoke(int StatusCode, WebHeaderCollection httpHeaders);
    public virtual IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.HttpDateParse : object {
    public static bool ParseHttpDate(string DateString, DateTime& dtOut);
}
internal static class System.Net.HttpDigest : object {
    internal static string DA_algorithm;
    internal static string DA_cnonce;
    internal static string DA_domain;
    internal static string DA_nc;
    internal static string DA_nonce;
    internal static string DA_opaque;
    internal static string DA_qop;
    internal static string DA_realm;
    internal static string DA_response;
    internal static string DA_stale;
    internal static string DA_uri;
    internal static string DA_username;
    internal static string DA_charset;
    internal static string DA_cipher;
    internal static string DA_hasheddirs;
    internal static string DA_servicename;
    internal static string DA_channelbinding;
    internal static string SupportedQuality;
    internal static string ValidSeparator;
    internal static string HashedDirs;
    internal static string Upgraded;
    internal static string UpgradedV1;
    internal static string ZeroChannelBindingHash;
    private static HttpDigest();
    internal static HttpDigestChallenge Interpret(string challenge, int startingPoint, HttpWebRequest httpWebRequest);
    internal static Authorization Authenticate(HttpDigestChallenge digestChallenge, NetworkCredential NC, string spn, ChannelBinding binding);
    internal static string unquote(string quotedString);
    internal static string pair(string name, string value, bool quote);
}
internal class System.Net.HttpDigestChallenge : object {
    internal string HostName;
    internal string Realm;
    internal Uri ChallengedUri;
    internal string Uri;
    internal string Nonce;
    internal string Opaque;
    internal bool Stale;
    internal string Algorithm;
    internal string Method;
    internal string Domain;
    internal string QualityOfProtection;
    internal string ClientNonce;
    internal int NonceCount;
    internal string Charset;
    internal string ServiceName;
    internal string ChannelBinding;
    internal bool UTF8Charset;
    internal bool QopPresent;
    internal MD5CryptoServiceProvider MD5provider;
    internal void SetFromRequest(HttpWebRequest httpWebRequest);
    internal HttpDigestChallenge CopyAndIncrementNonce();
    public bool defineAttribute(string name, string value);
    internal string ToBlob();
}
internal static class System.Net.HttpKnownHeaderNames : object {
    public static string CacheControl;
    public static string Connection;
    public static string Date;
    public static string KeepAlive;
    public static string Pragma;
    public static string ProxyConnection;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string Via;
    public static string Warning;
    public static string ContentLength;
    public static string ContentType;
    public static string ContentDisposition;
    public static string ContentEncoding;
    public static string ContentLanguage;
    public static string ContentLocation;
    public static string ContentRange;
    public static string Expires;
    public static string LastModified;
    public static string Age;
    public static string Location;
    public static string ProxyAuthenticate;
    public static string RetryAfter;
    public static string Server;
    public static string SetCookie;
    public static string SetCookie2;
    public static string Vary;
    public static string WWWAuthenticate;
    public static string Accept;
    public static string AcceptCharset;
    public static string AcceptEncoding;
    public static string AcceptLanguage;
    public static string Authorization;
    public static string Cookie;
    public static string Cookie2;
    public static string Expect;
    public static string From;
    public static string Host;
    public static string IfMatch;
    public static string IfModifiedSince;
    public static string IfNoneMatch;
    public static string IfRange;
    public static string IfUnmodifiedSince;
    public static string MaxForwards;
    public static string ProxyAuthorization;
    public static string Referer;
    public static string Range;
    public static string UserAgent;
    public static string ContentMD5;
    public static string ETag;
    public static string TE;
    public static string Allow;
    public static string AcceptRanges;
    public static string P3P;
    public static string XPoweredBy;
    public static string XAspNetVersion;
    public static string SecWebSocketKey;
    public static string SecWebSocketExtensions;
    public static string SecWebSocketAccept;
    public static string Origin;
    public static string SecWebSocketProtocol;
    public static string SecWebSocketVersion;
}
public class System.Net.HttpListener : object {
    internal static bool SkipIOCPCallbackOnSuccess;
    internal Hashtable m_UriPrefixes;
    internal CriticalHandle RequestQueueHandle { get; }
    public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public string Realm { get; public set; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    public static bool IsSupported { get; }
    public bool IsListening { get; }
    public bool IgnoreWriteExceptions { get; public set; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    public HttpListenerPrefixCollection Prefixes { get; }
    private static HttpListener();
    internal CriticalHandle get_RequestQueueHandle();
    public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public string get_Realm();
    public void set_Realm(string value);
    internal void SetServerTimeout(Int32[] timeouts, UInt32 minSendBytesPerSecond);
    public HttpListenerTimeoutManager get_TimeoutManager();
    public static bool get_IsSupported();
    public bool get_IsListening();
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    internal void AddPrefix(string uriPrefix);
    public HttpListenerPrefixCollection get_Prefixes();
    internal bool RemovePrefix(string uriPrefix);
    internal void RemoveAll(bool clear);
    internal void EnsureBoundHandle();
    public void Start();
    public void Stop();
    public void Abort();
    public void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    public HttpListenerContext GetContext();
    internal bool ValidateRequest(RequestContextBase requestMemory);
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    public Task`1<HttpListenerContext> GetContextAsync();
    internal static WindowsIdentity CreateWindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated);
    internal HttpListenerContext HandleAuthentication(RequestContextBase memoryBlob, Boolean& stoleBlob);
    internal void SetAuthenticationHeaders(HttpListenerContext context);
    internal ChannelBinding GetChannelBindingFromTls(ulong connectionId);
    internal void CheckDisposed();
}
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    public virtual string get_Password();
}
public class System.Net.HttpListenerContext : object {
    internal static string NTLM;
    public HttpListenerRequest Request { get; }
    public HttpListenerResponse Response { get; }
    public IPrincipal User { get; }
    internal AuthenticationSchemes AuthenticationSchemes { get; internal set; }
    internal ExtendedProtectionPolicy ExtendedProtectionPolicy { get; internal set; }
    internal bool PromoteCookiesToRfc2965 { get; }
    internal string MutualAuthentication { get; }
    internal HttpListener Listener { get; }
    internal CriticalHandle RequestQueueHandle { get; }
    internal ulong RequestId { get; }
    internal HttpListenerContext(HttpListener httpListener, RequestContextBase memoryBlob);
    internal void SetIdentity(IPrincipal principal, string mutualAuthentication);
    public HttpListenerRequest get_Request();
    public HttpListenerResponse get_Response();
    public IPrincipal get_User();
    internal AuthenticationSchemes get_AuthenticationSchemes();
    internal void set_AuthenticationSchemes(AuthenticationSchemes value);
    internal ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    internal void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal bool get_PromoteCookiesToRfc2965();
    internal string get_MutualAuthentication();
    internal HttpListener get_Listener();
    internal CriticalHandle get_RequestQueueHandle();
    internal void EnsureBoundHandle();
    internal ulong get_RequestId();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [EditorBrowsableAttribute("1")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal void Close();
    internal void Abort();
    internal HTTP_VERB GetKnownMethod();
    internal static void CancelRequest(CriticalHandle requestQueueHandle, ulong requestId);
    internal void ForceCancelRequest(CriticalHandle requestQueueHandle, ulong requestId);
    internal void SetAuthenticationHeaders();
}
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.HttpListenerPrefixCollection : object {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual int get_Count();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual bool Contains(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    public sealed virtual void Clear();
}
public class System.Net.HttpListenerRequest : object {
    internal ulong m_ConnectionId;
    internal static UInt32 CertBoblSize;
    internal HttpListenerContext HttpListenerContext { get; }
    internal Byte[] RequestBuffer { get; }
    internal IntPtr OriginalBlobAddress { get; }
    public Guid RequestTraceIdentifier { get; }
    internal ulong RequestId { get; }
    public String[] AcceptTypes { get; }
    public Encoding ContentEncoding { get; }
    public long ContentLength64 { get; }
    public string ContentType { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public bool IsWebSocketRequest { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    public string ServiceName { get; internal set; }
    public Uri Url { get; }
    public Uri UrlReferrer { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public String[] UserLanguages { get; }
    public int ClientCertificateError { get; }
    unknown X509Certificate2 ClientCertificate {internal set; }
    unknown ListenerClientCertState ClientCertState {internal set; }
    public TransportContext TransportContext { get; }
    public CookieCollection Cookies { get; }
    public Version ProtocolVersion { get; }
    public bool HasEntityBody { get; }
    public bool KeepAlive { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public IPEndPoint LocalEndPoint { get; }
    internal HttpListenerRequest(HttpListenerContext httpContext, RequestContextBase memoryBlob);
    internal HttpListenerContext get_HttpListenerContext();
    internal Byte[] get_RequestBuffer();
    internal IntPtr get_OriginalBlobAddress();
    internal void DetachBlob(RequestContextBase memoryBlob);
    internal void ReleasePins();
    public Guid get_RequestTraceIdentifier();
    internal ulong get_RequestId();
    public String[] get_AcceptTypes();
    public Encoding get_ContentEncoding();
    public long get_ContentLength64();
    public string get_ContentType();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsLocal();
    public bool get_IsSecureConnection();
    public bool get_IsWebSocketRequest();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    public string get_ServiceName();
    internal void set_ServiceName(string value);
    public Uri get_Url();
    public Uri get_UrlReferrer();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public String[] get_UserLanguages();
    public int get_ClientCertificateError();
    internal void set_ClientCertificate(X509Certificate2 value);
    internal void set_ClientCertState(ListenerClientCertState value);
    internal void SetClientCertificateError(int clientCertificateError);
    public X509Certificate2 GetClientCertificate();
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public Task`1<X509Certificate2> GetClientCertificateAsync();
    public TransportContext get_TransportContext();
    public CookieCollection get_Cookies();
    public Version get_ProtocolVersion();
    public bool get_HasEntityBody();
    public bool get_KeepAlive();
    public IPEndPoint get_RemoteEndPoint();
    public IPEndPoint get_LocalEndPoint();
    internal void Close();
    internal ChannelBinding GetChannelBinding();
    internal IEnumerable`1<TokenBinding> GetTlsTokenBindings();
    internal void CheckDisposed();
}
internal class System.Net.HttpListenerRequestContext : TransportContext {
    internal HttpListenerRequestContext(HttpListenerRequest request);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual IEnumerable`1<TokenBinding> GetTlsTokenBindings();
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static HttpListenerRequestUriBuilder();
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
}
public class System.Net.HttpListenerResponse : object {
    public Encoding ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    public Stream OutputStream { get; }
    public string RedirectLocation { get; public set; }
    public int StatusCode { get; public set; }
    public string StatusDescription { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public bool SendChunked { get; public set; }
    internal EntitySendFormat EntitySendFormat { get; internal set; }
    public bool KeepAlive { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public long ContentLength64 { get; public set; }
    public Version ProtocolVersion { get; public set; }
    internal BoundaryType BoundaryType { get; }
    internal bool SentHeaders { get; }
    internal bool ComputedHeaders { get; }
    internal HttpListenerResponse(HttpListenerContext httpContext);
    private static HttpListenerResponse();
    public Encoding get_ContentEncoding();
    public void set_ContentEncoding(Encoding value);
    public string get_ContentType();
    public void set_ContentType(string value);
    public Stream get_OutputStream();
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    internal EntitySendFormat get_EntitySendFormat();
    internal void set_EntitySendFormat(EntitySendFormat value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public void AddHeader(string name, string value);
    public void AppendHeader(string name, string value);
    public void Redirect(string url);
    public void AppendCookie(Cookie cookie);
    public void SetCookie(Cookie cookie);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public void Abort();
    public void Close(Byte[] responseEntity, bool willBlock);
    public void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    internal BoundaryType get_BoundaryType();
    internal bool get_SentHeaders();
    internal bool get_ComputedHeaders();
    internal UInt32 SendHeaders(HTTP_DATA_CHUNK* pDataChunk, HttpResponseStreamAsyncResult asyncResult, HTTP_FLAGS flags, bool isWebSocketHandshake);
    internal void ComputeCookies();
    internal HTTP_FLAGS ComputeHeaders();
    internal void ComputeCoreHeaders();
    internal void CancelLastWrite(CriticalHandle requestQueueHandle);
}
public class System.Net.HttpListenerTimeoutManager : object {
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    internal HttpListenerTimeoutManager(HttpListener context);
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
}
internal enum System.Net.HttpProcessingResult : Enum {
    public int value__;
    public static HttpProcessingResult Continue;
    public static HttpProcessingResult ReadWait;
    public static HttpProcessingResult WriteWait;
}
internal class System.Net.HttpProtocolUtils : object {
    internal static DateTime string2date(string S);
    internal static string date2string(DateTime D);
}
internal class System.Net.HttpRequestCreator : object {
    public sealed virtual WebRequest Create(Uri Uri);
}
public enum System.Net.HttpRequestHeader : Enum {
    public int value__;
    public static HttpRequestHeader CacheControl;
    public static HttpRequestHeader Connection;
    public static HttpRequestHeader Date;
    public static HttpRequestHeader KeepAlive;
    public static HttpRequestHeader Pragma;
    public static HttpRequestHeader Trailer;
    public static HttpRequestHeader TransferEncoding;
    public static HttpRequestHeader Upgrade;
    public static HttpRequestHeader Via;
    public static HttpRequestHeader Warning;
    public static HttpRequestHeader Allow;
    public static HttpRequestHeader ContentLength;
    public static HttpRequestHeader ContentType;
    public static HttpRequestHeader ContentEncoding;
    public static HttpRequestHeader ContentLanguage;
    public static HttpRequestHeader ContentLocation;
    public static HttpRequestHeader ContentMd5;
    public static HttpRequestHeader ContentRange;
    public static HttpRequestHeader Expires;
    public static HttpRequestHeader LastModified;
    public static HttpRequestHeader Accept;
    public static HttpRequestHeader AcceptCharset;
    public static HttpRequestHeader AcceptEncoding;
    public static HttpRequestHeader AcceptLanguage;
    public static HttpRequestHeader Authorization;
    public static HttpRequestHeader Cookie;
    public static HttpRequestHeader Expect;
    public static HttpRequestHeader From;
    public static HttpRequestHeader Host;
    public static HttpRequestHeader IfMatch;
    public static HttpRequestHeader IfModifiedSince;
    public static HttpRequestHeader IfNoneMatch;
    public static HttpRequestHeader IfRange;
    public static HttpRequestHeader IfUnmodifiedSince;
    public static HttpRequestHeader MaxForwards;
    public static HttpRequestHeader ProxyAuthorization;
    public static HttpRequestHeader Referer;
    public static HttpRequestHeader Range;
    public static HttpRequestHeader Te;
    public static HttpRequestHeader Translate;
    public static HttpRequestHeader UserAgent;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.HttpRequestQueueV2Handle : CriticalHandleZeroOrMinusOneIsInvalid {
    internal IntPtr DangerousGetHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.Net.HttpRequestStream : Stream {
    internal static int MaxReadSize;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    internal bool Closed { get; }
    internal bool BufferedDataChunksAvailable { get; }
    internal HttpListenerContext InternalHttpContext { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpRequestStream(HttpListenerContext httpContext);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    internal bool get_Closed();
    internal bool get_BufferedDataChunksAvailable();
    internal HttpListenerContext get_InternalHttpContext();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    internal void SwitchToOpaqueMode();
    internal UInt32 GetChunks(Byte[] buffer, int offset, int size);
}
public enum System.Net.HttpResponseHeader : Enum {
    public int value__;
    public static HttpResponseHeader CacheControl;
    public static HttpResponseHeader Connection;
    public static HttpResponseHeader Date;
    public static HttpResponseHeader KeepAlive;
    public static HttpResponseHeader Pragma;
    public static HttpResponseHeader Trailer;
    public static HttpResponseHeader TransferEncoding;
    public static HttpResponseHeader Upgrade;
    public static HttpResponseHeader Via;
    public static HttpResponseHeader Warning;
    public static HttpResponseHeader Allow;
    public static HttpResponseHeader ContentLength;
    public static HttpResponseHeader ContentType;
    public static HttpResponseHeader ContentEncoding;
    public static HttpResponseHeader ContentLanguage;
    public static HttpResponseHeader ContentLocation;
    public static HttpResponseHeader ContentMd5;
    public static HttpResponseHeader ContentRange;
    public static HttpResponseHeader Expires;
    public static HttpResponseHeader LastModified;
    public static HttpResponseHeader AcceptRanges;
    public static HttpResponseHeader Age;
    public static HttpResponseHeader ETag;
    public static HttpResponseHeader Location;
    public static HttpResponseHeader ProxyAuthenticate;
    public static HttpResponseHeader RetryAfter;
    public static HttpResponseHeader Server;
    public static HttpResponseHeader SetCookie;
    public static HttpResponseHeader Vary;
    public static HttpResponseHeader WwwAuthenticate;
}
internal class System.Net.HttpResponseStream : Stream {
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    internal bool Closed { get; }
    internal HttpListenerContext InternalHttpContext { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpResponseStream(HttpListenerContext httpContext);
    internal HTTP_FLAGS ComputeLeftToWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    internal bool get_Closed();
    internal HttpListenerContext get_InternalHttpContext();
    internal void SetClosedFlag();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    internal void SwitchToOpaqueMode();
    internal void CancelLastWrite(CriticalHandle requestQueueHandle);
}
internal class System.Net.HttpResponseStreamAsyncResult : LazyAsyncResult {
    internal NativeOverlapped* m_pOverlapped;
    internal bool m_SentHeaders;
    internal ushort dataChunkCount { get; }
    internal HTTP_DATA_CHUNK* pDataChunks { get; }
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback);
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback, Byte[] buffer, int offset, int size, bool chunked, bool sentHeaders);
    private static HttpResponseStreamAsyncResult();
    internal ushort get_dataChunkCount();
    internal HTTP_DATA_CHUNK* get_pDataChunks();
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    protected virtual void Cleanup();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.HttpServerSessionHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    internal HttpServerSessionHandle(ulong id);
    internal ulong DangerousGetServerSessionId();
    protected virtual bool ReleaseHandle();
}
public enum System.Net.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Continue;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode OK;
    public static HttpStatusCode Created;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode Ambiguous;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode Moved;
    public static HttpStatusCode Found;
    public static HttpStatusCode Redirect;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode RedirectMethod;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode Unused;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode RedirectKeepVerb;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Gone;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode UpgradeRequired;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode HttpVersionNotSupported;
}
internal static class System.Net.HttpStatusDescription : object {
    private static HttpStatusDescription();
    [FriendAccessAllowedAttribute]
internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal static class System.Net.HttpSysSettings : object {
    public static bool EnableNonUtf8 { get; }
    public static bool FavorUtf8 { get; }
    private static HttpSysSettings();
    public static bool get_EnableNonUtf8();
    public static bool get_FavorUtf8();
}
public class System.Net.HttpVersion : object {
    public static Version Version10;
    public static Version Version11;
    private static HttpVersion();
}
[FriendAccessAllowedAttribute]
public class System.Net.HttpWebRequest : WebRequest {
    internal static HttpStatusCode MaxOkStatus;
    internal static string ChunkedHeader;
    internal static string GZipHeader;
    internal static string DeflateHeader;
    internal static int DefaultReadWriteTimeout;
    internal static int DefaultContinueTimeout;
    internal ServicePoint _ServicePoint;
    internal HttpWebResponse _HttpResponse;
    [FriendAccessAllowedAttribute]
internal object ServerCertificateValidationCallbackContext { get; internal set; }
    [FriendAccessAllowedAttribute]
internal bool CheckCertificateRevocationList { get; internal set; }
    [FriendAccessAllowedAttribute]
internal SslProtocols SslProtocols { get; internal set; }
    [FriendAccessAllowedAttribute]
internal RtcState RtcState { get; internal set; }
    internal Timer RequestTimer { get; }
    internal bool Aborted { get; }
    internal Connection TunnelConnection { get; internal set; }
    public bool AllowAutoRedirect { get; public set; }
    public bool AllowWriteStreamBuffering { get; public set; }
    public bool AllowReadStreamBuffering { get; public set; }
    public bool HaveResponse { get; }
    internal bool NtlmKeepAlive { get; internal set; }
    internal bool NeedsToReadForResponse { get; internal set; }
    internal bool BodyStarted { get; }
    public bool KeepAlive { get; public set; }
    internal bool LockConnection { get; internal set; }
    public bool Pipelined { get; public set; }
    public bool PreAuthenticate { get; public set; }
    internal bool Saw100Continue { get; internal set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    internal bool UnsafeOrProxyAuthenticatedConnectionSharing { get; }
    public bool SendChunked { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    internal HttpWriteMode HttpWriteMode { get; internal set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public static int DefaultMaximumResponseHeadersLength { get; public set; }
    public static int DefaultMaximumErrorResponseLength { get; public set; }
    public int MaximumResponseHeadersLength { get; public set; }
    unknown HttpAbortDelegate AbortDelegate {internal set; }
    internal LazyAsyncResult ConnectionAsyncResult { get; }
    internal LazyAsyncResult ConnectionReaderAsyncResult { get; }
    internal bool UserRetrievedWriteStream { get; }
    internal bool Async { get; internal set; }
    internal UnlockConnectionDelegate UnlockConnectionDelegate { get; internal set; }
    internal HttpStatusCode ResponseStatusCode { get; }
    internal bool UsesProxySemantics { get; }
    internal Uri ChallengedUri { get; }
    internal AuthenticationState ProxyAuthenticationState { get; }
    internal AuthenticationState ServerAuthenticationState { get; internal set; }
    internal AuthenticationState CurrentAuthenticationState { get; internal set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public bool SupportsCookieContainer { get; }
    public Uri RequestUri { get; }
    public long ContentLength { get; public set; }
    public int Timeout { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    public int ContinueTimeout { get; public set; }
    internal bool HeadersCompleted { get; internal set; }
    internal bool CanGetResponseStream { get; }
    internal bool RequireBody { get; }
    internal bool HasEntityBody { get; }
    public Uri Address { get; }
    public HttpContinueDelegate ContinueDelegate { get; public set; }
    public ServicePoint ServicePoint { get; }
    public string Host { get; public set; }
    internal bool UseCustomHost { get; }
    public int MaximumAutomaticRedirections { get; public set; }
    public string Method { get; public set; }
    internal KnownHttpVerb CurrentMethod { get; internal set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    internal bool IsTunnelRequest { get; internal set; }
    internal bool IsWebSocketRequest { get; private set; }
    public string ConnectionGroupName { get; public set; }
    unknown bool InternalConnectionGroup {internal set; }
    public WebHeaderCollection Headers { get; public set; }
    public IWebProxy Proxy { get; public set; }
    internal IWebProxy InternalProxy { get; internal set; }
    public Version ProtocolVersion { get; public set; }
    public string ContentType { get; public set; }
    public string MediaType { get; public set; }
    public string TransferEncoding { get; public set; }
    public string Connection { get; public set; }
    public string Accept { get; public set; }
    public string Referer { get; public set; }
    public string UserAgent { get; public set; }
    public string Expect { get; public set; }
    public DateTime IfModifiedSince { get; public set; }
    public DateTime Date { get; public set; }
    internal Byte[] WriteBuffer { get; }
    internal int WriteBufferLength { get; }
    internal int RequestContinueCount { get; }
    internal ServerCertValidationCallback ServerCertValidationCallback { get; private set; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    internal HttpWebRequest(Uri uri, ServicePoint servicePoint);
    internal HttpWebRequest(Uri proxyUri, Uri requestUri, HttpWebRequest orginalRequest);
    internal HttpWebRequest(Uri uri, bool returnResponseOnFailureStatusCode, string connectionGroupName, Action`1<Stream> resendRequestContent);
    internal HttpWebRequest(Uri uri, ServicePoint servicePoint, bool isWebSocketRequest, string connectionGroupName);
    [ObsoleteAttribute("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static HttpWebRequest();
    [CompilerGeneratedAttribute]
internal object get_ServerCertificateValidationCallbackContext();
    [CompilerGeneratedAttribute]
internal void set_ServerCertificateValidationCallbackContext(object value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertificateRevocationList();
    [CompilerGeneratedAttribute]
internal void set_CheckCertificateRevocationList(bool value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
internal void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal RtcState get_RtcState();
    [CompilerGeneratedAttribute]
internal void set_RtcState(RtcState value);
    internal Timer get_RequestTimer();
    internal bool get_Aborted();
    internal Connection get_TunnelConnection();
    internal void set_TunnelConnection(Connection value);
    public virtual bool get_AllowAutoRedirect();
    public virtual void set_AllowAutoRedirect(bool value);
    public virtual bool get_AllowWriteStreamBuffering();
    public virtual void set_AllowWriteStreamBuffering(bool value);
    public virtual bool get_AllowReadStreamBuffering();
    public virtual void set_AllowReadStreamBuffering(bool value);
    public virtual bool get_HaveResponse();
    internal bool get_NtlmKeepAlive();
    internal void set_NtlmKeepAlive(bool value);
    internal bool get_NeedsToReadForResponse();
    internal void set_NeedsToReadForResponse(bool value);
    internal bool get_BodyStarted();
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    internal bool get_LockConnection();
    internal void set_LockConnection(bool value);
    public bool get_Pipelined();
    public void set_Pipelined(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    internal bool get_Saw100Continue();
    internal void set_Saw100Continue(bool value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    internal bool get_UnsafeOrProxyAuthenticatedConnectionSharing();
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    internal HttpWriteMode get_HttpWriteMode();
    internal void set_HttpWriteMode(HttpWriteMode value);
    internal string AuthHeader(HttpResponseHeader header);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public static int get_DefaultMaximumResponseHeadersLength();
    public static void set_DefaultMaximumResponseHeadersLength(int value);
    public static int get_DefaultMaximumErrorResponseLength();
    public static void set_DefaultMaximumErrorResponseLength(int value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    internal void set_AbortDelegate(HttpAbortDelegate value);
    internal LazyAsyncResult get_ConnectionAsyncResult();
    internal LazyAsyncResult get_ConnectionReaderAsyncResult();
    internal bool get_UserRetrievedWriteStream();
    internal bool get_Async();
    internal void set_Async(bool value);
    internal UnlockConnectionDelegate get_UnlockConnectionDelegate();
    internal void set_UnlockConnectionDelegate(UnlockConnectionDelegate value);
    internal HttpStatusCode get_ResponseStatusCode();
    internal bool get_UsesProxySemantics();
    internal Uri get_ChallengedUri();
    internal AuthenticationState get_ProxyAuthenticationState();
    internal AuthenticationState get_ServerAuthenticationState();
    internal void set_ServerAuthenticationState(AuthenticationState value);
    internal AuthenticationState get_CurrentAuthenticationState();
    internal void set_CurrentAuthenticationState(AuthenticationState value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public virtual CookieContainer get_CookieContainer();
    public virtual void set_CookieContainer(CookieContainer value);
    public virtual bool get_SupportsCookieContainer();
    public virtual Uri get_RequestUri();
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public int get_ContinueTimeout();
    public void set_ContinueTimeout(int value);
    internal long SwitchToContentLength();
    internal bool get_HeadersCompleted();
    internal void set_HeadersCompleted(bool value);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context);
    public virtual Stream GetRequestStream();
    public Stream GetRequestStream(TransportContext& context);
    internal bool get_CanGetResponseStream();
    internal bool get_RequireBody();
    internal bool get_HasEntityBody();
    internal void ErrorStatusCodeNotify(Connection connection, bool isKeepAlive, bool fatal);
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual WebResponse GetResponse();
    internal void WriteCallDone(ConnectStream stream, ConnectionReturnResult returnResult);
    internal void NeedEndSubmitRequest();
    public Uri get_Address();
    public HttpContinueDelegate get_ContinueDelegate();
    public void set_ContinueDelegate(HttpContinueDelegate value);
    internal void CallContinueDelegateCallback(object state);
    public ServicePoint get_ServicePoint();
    public string get_Host();
    public void set_Host(string value);
    internal bool get_UseCustomHost();
    public int get_MaximumAutomaticRedirections();
    public void set_MaximumAutomaticRedirections(int value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    internal KnownHttpVerb get_CurrentMethod();
    internal void set_CurrentMethod(KnownHttpVerb value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    internal bool get_IsTunnelRequest();
    internal void set_IsTunnelRequest(bool value);
    internal bool get_IsWebSocketRequest();
    private void set_IsWebSocketRequest(bool value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    internal void set_InternalConnectionGroup(bool value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    internal IWebProxy get_InternalProxy();
    internal void set_InternalProxy(IWebProxy value);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_TransferEncoding();
    public void set_TransferEncoding(string value);
    public string get_Connection();
    public void set_Connection(string value);
    public string get_Accept();
    public void set_Accept(string value);
    public string get_Referer();
    public void set_Referer(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public string get_Expect();
    public void set_Expect(string value);
    public DateTime get_IfModifiedSince();
    public void set_IfModifiedSince(DateTime value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    internal Byte[] get_WriteBuffer();
    internal int get_WriteBufferLength();
    internal void FreeWriteBuffer();
    public virtual void Abort();
    internal void SetRequestSubmitDone(ConnectStream submitStream);
    internal void WriteHeadersCallback(WebExceptionStatus errorStatus, ConnectStream stream, bool async);
    internal void SetRequestContinue();
    internal void SetRequestContinue(CoreResponseData continueResponse);
    internal int get_RequestContinueCount();
    internal void OpenWriteSideResponseWindow();
    internal void CheckWriteSideResponseProcessing();
    internal void SetAndOrProcessResponse(object responseOrException);
    internal virtual ContextAwareResult GetConnectingContext();
    internal virtual ContextAwareResult GetWritingContext();
    internal virtual ContextAwareResult GetReadingContext();
    internal bool EndWriteHeaders(bool async);
    internal bool ShouldWaitFor100Continue();
    internal void StartContinueWait();
    internal void StartAsync100ContinueTimer();
    internal bool FinishContinueWait();
    internal void EndWriteHeaders_Part2();
    internal Uri GetRemoteResourceUri();
    internal void UpdateHeaders();
    internal void SerializeHeaders();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal static StringBuilder GenerateConnectionGroup(string connectionGroupName, bool unsafeConnectionGroup, bool isInternalGroup);
    internal string GetConnectionGroupLine();
    [CompilerGeneratedAttribute]
internal ServerCertValidationCallback get_ServerCertValidationCallback();
    [CompilerGeneratedAttribute]
private void set_ServerCertValidationCallback(ServerCertValidationCallback value);
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public void AddRange(int from, int to);
    public void AddRange(long from, long to);
    public void AddRange(int range);
    public void AddRange(long range);
    public void AddRange(string rangeSpecifier, int from, int to);
    public void AddRange(string rangeSpecifier, long from, long to);
    public void AddRange(string rangeSpecifier, int range);
    public void AddRange(string rangeSpecifier, long range);
}
public class System.Net.HttpWebResponse : WebResponse {
    internal X509Certificate m_Certificate;
    internal bool IsWebSocketResponse { get; internal set; }
    internal string ConnectionGroupName { get; internal set; }
    internal Stream ResponseStream { get; internal set; }
    internal CoreResponseData CoreResponseData { get; }
    public bool IsMutuallyAuthenticated { get; }
    unknown bool InternalSetIsMutuallyAuthenticated {internal set; }
    public CookieCollection Cookies { get; public set; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public long ContentLength { get; }
    public string ContentEncoding { get; }
    public string ContentType { get; }
    public string CharacterSet { get; }
    public string Server { get; }
    public DateTime LastModified { get; }
    public HttpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public Version ProtocolVersion { get; }
    internal bool KeepAlive { get; }
    public Uri ResponseUri { get; }
    public string Method { get; }
    internal HttpWebResponse(Uri responseUri, KnownHttpVerb verb, CoreResponseData coreData, string mediaType, bool usesProxySemantics, DecompressionMethods decompressionMethod, bool isWebSocketResponse, string connectionGroupName);
    [ObsoleteAttribute("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal bool get_IsWebSocketResponse();
    internal void set_IsWebSocketResponse(bool value);
    internal string get_ConnectionGroupName();
    internal void set_ConnectionGroupName(string value);
    internal Stream get_ResponseStream();
    internal void set_ResponseStream(Stream value);
    internal CoreResponseData get_CoreResponseData();
    public virtual bool get_IsMutuallyAuthenticated();
    internal void set_InternalSetIsMutuallyAuthenticated(bool value);
    public virtual CookieCollection get_Cookies();
    public virtual void set_Cookies(CookieCollection value);
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual long get_ContentLength();
    public string get_ContentEncoding();
    public virtual string get_ContentType();
    public string get_CharacterSet();
    public string get_Server();
    public DateTime get_LastModified();
    public virtual HttpStatusCode get_StatusCode();
    public virtual string get_StatusDescription();
    public Version get_ProtocolVersion();
    internal bool get_KeepAlive();
    public virtual Stream GetResponseStream();
    public virtual void Close();
    internal void Abort();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string GetResponseHeader(string headerName);
    public virtual Uri get_ResponseUri();
    public virtual string get_Method();
}
internal enum System.Net.HttpWriteMode : Enum {
    public int value__;
    public static HttpWriteMode Unknown;
    public static HttpWriteMode ContentLength;
    public static HttpWriteMode Chunked;
    public static HttpWriteMode Buffer;
    public static HttpWriteMode None;
}
internal class System.Net.HybridWebProxyFinder : object {
    public bool IsValid { get; }
    private static HybridWebProxyFinder();
    public HybridWebProxyFinder(AutoWebProxyScriptEngine engine);
    public sealed virtual bool get_IsValid();
    public sealed virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public sealed virtual void Abort();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
internal interface System.Net.IAuthenticationManager {
    public ICredentialPolicy CredentialPolicy { get; public set; }
    public StringDictionary CustomTargetNameDictionary { get; }
    public SpnDictionary SpnDictionary { get; }
    public bool OSSupportsExtendedProtection { get; }
    public bool SspSupportsExtendedProtection { get; }
    public IEnumerator RegisteredModules { get; }
    public abstract virtual ICredentialPolicy get_CredentialPolicy();
    public abstract virtual void set_CredentialPolicy(ICredentialPolicy value);
    public abstract virtual StringDictionary get_CustomTargetNameDictionary();
    public abstract virtual SpnDictionary get_SpnDictionary();
    public abstract virtual bool get_OSSupportsExtendedProtection();
    public abstract virtual bool get_SspSupportsExtendedProtection();
    public abstract virtual void EnsureConfigLoaded();
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual void Register(IAuthenticationModule authenticationModule);
    public abstract virtual void Unregister(IAuthenticationModule authenticationModule);
    public abstract virtual void Unregister(string authenticationScheme);
    public abstract virtual IEnumerator get_RegisteredModules();
    public abstract virtual void BindModule(Uri uri, Authorization response, IAuthenticationModule module);
}
public interface System.Net.IAuthenticationModule {
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual bool get_CanPreAuthenticate();
    public abstract virtual string get_AuthenticationType();
}
internal interface System.Net.IAutoWebProxy {
    public abstract virtual ProxyChain GetProxies(Uri destination);
}
public interface System.Net.ICertificatePolicy {
    public abstract virtual bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem);
}
internal interface System.Net.ICloseEx {
    public abstract virtual void CloseEx(CloseExState closeState);
}
public interface System.Net.ICredentialPolicy {
    public abstract virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
}
public interface System.Net.ICredentials {
    public abstract virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public interface System.Net.ICredentialsByHost {
    public abstract virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
internal enum System.Net.IgnoreCertProblem : Enum {
    public int value__;
    public static IgnoreCertProblem not_time_valid;
    public static IgnoreCertProblem ctl_not_time_valid;
    public static IgnoreCertProblem not_time_nested;
    public static IgnoreCertProblem invalid_basic_constraints;
    public static IgnoreCertProblem all_not_time_valid;
    public static IgnoreCertProblem allow_unknown_ca;
    public static IgnoreCertProblem wrong_usage;
    public static IgnoreCertProblem invalid_name;
    public static IgnoreCertProblem invalid_policy;
    public static IgnoreCertProblem end_rev_unknown;
    public static IgnoreCertProblem ctl_signer_rev_unknown;
    public static IgnoreCertProblem ca_rev_unknown;
    public static IgnoreCertProblem root_rev_unknown;
    public static IgnoreCertProblem all_rev_unknown;
    public static IgnoreCertProblem none;
}
internal class System.Net.InterlockedGate : ValueType {
    private int m_State;
    internal static int Open;
    internal static int Triggering;
    internal static int Triggered;
    internal static int Signaling;
    internal static int Signaled;
    internal static int Completed;
    internal void Reset();
    internal bool Trigger(bool exclusive);
    internal bool StartTriggering(bool exclusive);
    internal void FinishTriggering();
    internal bool StartSignaling(bool exclusive);
    internal void FinishSignaling();
    internal bool Complete();
}
internal class System.Net.InterlockedStack : object {
    internal void Push(object pooledStream);
    internal object Pop();
}
internal class System.Net.InternalException : SystemException {
    internal InternalException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.Net.IntPtrHelper : object {
    internal static IntPtr Add(IntPtr a, int b);
    internal static long Subtract(IntPtr a, IntPtr b);
}
public class System.Net.IPAddress : object {
    public static IPAddress Any;
    public static IPAddress Loopback;
    public static IPAddress Broadcast;
    public static IPAddress None;
    internal static long LoopbackMask;
    internal long m_Address;
    internal string m_ToString;
    public static IPAddress IPv6Any;
    public static IPAddress IPv6Loopback;
    public static IPAddress IPv6None;
    internal static int IPv4AddressBytes;
    internal static int IPv6AddressBytes;
    internal static int NumberOfLabels;
    [ObsoleteAttribute("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")]
public long Address { get; public set; }
    public AddressFamily AddressFamily { get; }
    public long ScopeId { get; public set; }
    internal bool IsBroadcast { get; }
    public bool IsIPv6Multicast { get; }
    public bool IsIPv6LinkLocal { get; }
    public bool IsIPv6SiteLocal { get; }
    public bool IsIPv6Teredo { get; }
    public bool IsIPv4MappedToIPv6 { get; }
    public IPAddress(long newAddress);
    public IPAddress(Byte[] address, long scopeid);
    public IPAddress(Byte[] address);
    internal IPAddress(int newAddress);
    private static IPAddress();
    public static bool TryParse(string ipString, IPAddress& address);
    public static IPAddress Parse(string ipString);
    public long get_Address();
    public void set_Address(long value);
    public Byte[] GetAddressBytes();
    public AddressFamily get_AddressFamily();
    public long get_ScopeId();
    public void set_ScopeId(long value);
    public virtual string ToString();
    public static long HostToNetworkOrder(long host);
    public static int HostToNetworkOrder(int host);
    public static short HostToNetworkOrder(short host);
    public static long NetworkToHostOrder(long network);
    public static int NetworkToHostOrder(int network);
    public static short NetworkToHostOrder(short network);
    public static bool IsLoopback(IPAddress address);
    internal bool get_IsBroadcast();
    public bool get_IsIPv6Multicast();
    public bool get_IsIPv6LinkLocal();
    public bool get_IsIPv6SiteLocal();
    public bool get_IsIPv6Teredo();
    public bool get_IsIPv4MappedToIPv6();
    internal bool Equals(object comparandObj, bool compareScopeId);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    internal IPAddress Snapshot();
    public IPAddress MapToIPv6();
    public IPAddress MapToIPv4();
}
public class System.Net.IPEndPoint : EndPoint {
    public static int MinPort;
    public static int MaxPort;
    internal static int AnyPort;
    internal static IPEndPoint Any;
    internal static IPEndPoint IPv6Any;
    public AddressFamily AddressFamily { get; }
    public IPAddress Address { get; public set; }
    public int Port { get; public set; }
    public IPEndPoint(long address, int port);
    public IPEndPoint(IPAddress address, int port);
    private static IPEndPoint();
    public virtual AddressFamily get_AddressFamily();
    public IPAddress get_Address();
    public void set_Address(IPAddress value);
    public int get_Port();
    public void set_Port(int value);
    public virtual string ToString();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    internal IPEndPoint Snapshot();
}
public class System.Net.IPHostEntry : object {
    internal bool isTrustedHost;
    public string HostName { get; public set; }
    public String[] Aliases { get; public set; }
    public IPAddress[] AddressList { get; public set; }
    public string get_HostName();
    public void set_HostName(string value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    public IPAddress[] get_AddressList();
    public void set_AddressList(IPAddress[] value);
}
internal class System.Net.IPMulticastRequest : ValueType {
    internal int MulticastAddress;
    internal int InterfaceAddress;
    internal static int Size;
    private static IPMulticastRequest();
}
internal class System.Net.IPv6MulticastRequest : ValueType {
    internal Byte[] MulticastAddress;
    internal int InterfaceIndex;
    internal static int Size;
    private static IPv6MulticastRequest();
}
internal interface System.Net.IRequestLifetimeTracker {
    public abstract virtual void TrackRequestLifetime(long requestStartTimestamp);
}
internal interface System.Net.ISessionAuthenticationModule {
    public bool CanUseDefaultCredentials { get; }
    public abstract virtual bool Update(string challenge, WebRequest webRequest);
    public abstract virtual void ClearSession(WebRequest webRequest);
    public abstract virtual bool get_CanUseDefaultCredentials();
}
internal class System.Net.IssuerListInfoEx : ValueType {
    public SafeHandle aIssuers;
    public UInt32 cIssuers;
    public IssuerListInfoEx(SafeHandle handle, Byte[] nativeBuffer);
}
public interface System.Net.IWebProxy {
    public ICredentials Credentials { get; public set; }
    public abstract virtual Uri GetProxy(Uri destination);
    public abstract virtual bool IsBypassed(Uri host);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
}
internal interface System.Net.IWebProxyFinder {
    public bool IsValid { get; }
    public abstract virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public abstract virtual void Abort();
    public abstract virtual void Reset();
    public abstract virtual bool get_IsValid();
}
public interface System.Net.IWebProxyScript {
    public abstract virtual bool Load(Uri scriptLocation, string script, Type helperType);
    public abstract virtual string Run(string url, string host);
    public abstract virtual void Close();
}
public interface System.Net.IWebRequestCreate {
    public abstract virtual WebRequest Create(Uri uri);
}
internal class System.Net.KerberosClient : object {
    internal static string AuthType;
    internal static string Signature;
    internal static int SignatureSize;
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public bool CanUseDefaultCredentials { get; }
    private static KerberosClient();
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual bool get_CanPreAuthenticate();
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool Update(string challenge, WebRequest webRequest);
    public sealed virtual void ClearSession(WebRequest webRequest);
    public sealed virtual bool get_CanUseDefaultCredentials();
}
internal class System.Net.KnownHttpVerb : object {
    internal string Name;
    internal bool RequireContentBody;
    internal bool ContentBodyNotAllowed;
    internal bool ConnectRequest;
    internal bool ExpectNoContentResponse;
    internal static KnownHttpVerb Get;
    internal static KnownHttpVerb Connect;
    internal static KnownHttpVerb Head;
    internal static KnownHttpVerb Put;
    internal static KnownHttpVerb Post;
    internal static KnownHttpVerb MkCol;
    internal KnownHttpVerb(string name, bool requireContentBody, bool contentBodyNotAllowed, bool connectRequest, bool expectNoContentResponse);
    private static KnownHttpVerb();
    public bool Equals(KnownHttpVerb verb);
    public static KnownHttpVerb Parse(string name);
}
internal class System.Net.LazyAsyncResult : object {
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    internal void InternalCleanup();
}
internal class System.Net.Linger : ValueType {
    internal ushort OnOff;
    internal ushort Time;
}
internal class System.Net.ListenerAsyncResult : LazyAsyncResult {
    internal static IOCompletionCallback IOCallback { get; }
    internal ListenerAsyncResult(object asyncObject, object userState, AsyncCallback callback);
    private static ListenerAsyncResult();
    internal static IOCompletionCallback get_IOCallback();
    internal UInt32 QueueBeginGetContext();
    protected virtual void Cleanup();
}
internal class System.Net.ListenerClientCertAsyncResult : LazyAsyncResult {
    internal NativeOverlapped* NativeOverlapped { get; }
    internal HTTP_SSL_CLIENT_CERT_INFO* RequestBlob { get; }
    internal ListenerClientCertAsyncResult(object asyncObject, object userState, AsyncCallback callback, UInt32 size);
    private static ListenerClientCertAsyncResult();
    internal NativeOverlapped* get_NativeOverlapped();
    internal HTTP_SSL_CLIENT_CERT_INFO* get_RequestBlob();
    internal void Reset(UInt32 size);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    protected virtual void Cleanup();
    protected virtual override void Finalize();
}
internal enum System.Net.ListenerClientCertState : Enum {
    public int value__;
    public static ListenerClientCertState NotInitialized;
    public static ListenerClientCertState InProgress;
    public static ListenerClientCertState Completed;
}
internal class System.Net.ListenerPrefixEnumerator : object {
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListenerPrefixEnumerator(IEnumerator enumerator);
    public sealed virtual string get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[FriendAccessAllowedAttribute]
internal class System.Net.Logging : object {
    [FriendAccessAllowedAttribute]
internal static bool On { get; }
    internal static TraceSource Web { get; }
    [FriendAccessAllowedAttribute]
internal static TraceSource Http { get; }
    internal static TraceSource HttpListener { get; }
    internal static TraceSource Sockets { get; }
    internal static TraceSource RequestCache { get; }
    internal static TraceSource WebSockets { get; }
    private static Logging();
    internal static bool get_On();
    internal static bool IsVerbose(TraceSource traceSource);
    internal static TraceSource get_Web();
    internal static TraceSource get_Http();
    internal static TraceSource get_HttpListener();
    internal static TraceSource get_Sockets();
    internal static TraceSource get_RequestCache();
    internal static TraceSource get_WebSockets();
    internal static UInt32 GetThreadId();
    internal static void PrintLine(TraceSource traceSource, TraceEventType eventType, int id, string msg);
    [FriendAccessAllowedAttribute]
internal static void Associate(TraceSource traceSource, object objA, object objB);
    [FriendAccessAllowedAttribute]
internal static void Enter(TraceSource traceSource, object obj, string method, string param);
    [FriendAccessAllowedAttribute]
internal static void Enter(TraceSource traceSource, object obj, string method, object paramObject);
    internal static void Enter(TraceSource traceSource, string obj, string method, string param);
    internal static void Enter(TraceSource traceSource, string obj, string method, object paramObject);
    internal static void Enter(TraceSource traceSource, string method, string parameters);
    internal static void Enter(TraceSource traceSource, string msg);
    [FriendAccessAllowedAttribute]
internal static void Exit(TraceSource traceSource, object obj, string method, object retObject);
    internal static void Exit(TraceSource traceSource, string obj, string method, object retObject);
    [FriendAccessAllowedAttribute]
internal static void Exit(TraceSource traceSource, object obj, string method, string retValue);
    internal static void Exit(TraceSource traceSource, string obj, string method, string retValue);
    internal static void Exit(TraceSource traceSource, string method, string parameters);
    internal static void Exit(TraceSource traceSource, string msg);
    [FriendAccessAllowedAttribute]
internal static void Exception(TraceSource traceSource, object obj, string method, Exception e);
    internal static void PrintInfo(TraceSource traceSource, string msg);
    [FriendAccessAllowedAttribute]
internal static void PrintInfo(TraceSource traceSource, object obj, string msg);
    internal static void PrintInfo(TraceSource traceSource, object obj, string method, string param);
    [FriendAccessAllowedAttribute]
internal static void PrintWarning(TraceSource traceSource, string msg);
    internal static void PrintWarning(TraceSource traceSource, object obj, string method, string msg);
    [FriendAccessAllowedAttribute]
internal static void PrintError(TraceSource traceSource, string msg);
    [FriendAccessAllowedAttribute]
internal static void PrintError(TraceSource traceSource, object obj, string method, string msg);
    [FriendAccessAllowedAttribute]
internal static string GetObjectLogHash(object obj);
    internal static void Dump(TraceSource traceSource, object obj, string method, IntPtr bufferPtr, int length);
    internal static void Dump(TraceSource traceSource, object obj, string method, Byte[] buffer, int offset, int length);
}
internal class System.Net.Mail._METADATA_HANDLE_INFO : object {
    internal int dwMDPermissions;
    internal int dwMDSystemChangeNumber;
}
public class System.Net.Mail.AlternateView : AttachmentBase {
    public LinkedResourceCollection LinkedResources { get; }
    public Uri BaseUri { get; public set; }
    public AlternateView(string fileName);
    public AlternateView(string fileName, string mediaType);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(Stream contentStream, ContentType contentType);
    public LinkedResourceCollection get_LinkedResources();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, AlternateView item);
    protected virtual void InsertItem(int index, AlternateView item);
}
public class System.Net.Mail.Attachment : AttachmentBase {
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public ContentDisposition ContentDisposition { get; }
    public Attachment(string fileName);
    public Attachment(string fileName, string mediaType);
    public Attachment(string fileName, ContentType contentType);
    public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    public Attachment(Stream contentStream, ContentType contentType);
    internal void SetContentTypeName(bool allowUnicode);
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public ContentDisposition get_ContentDisposition();
    internal virtual void PrepareForSending(bool allowUnicode);
    public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
    public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
}
public abstract class System.Net.Mail.AttachmentBase : object {
    internal bool disposed;
    public Stream ContentStream { get; }
    public string ContentId { get; public set; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    internal Uri ContentLocation { get; internal set; }
    internal MimePart MimePart { get; }
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, string mediaType);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, string mediaType);
    internal AttachmentBase(Stream contentStream, string name, string mediaType);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal static string ShortNameFromFile(string fileName);
    internal void SetContentFromFile(string fileName, ContentType contentType);
    internal void SetContentFromFile(string fileName, string mediaType);
    internal void SetContentFromString(string contentString, ContentType contentType);
    internal void SetContentFromString(string contentString, Encoding encoding, string mediaType);
    internal virtual void PrepareForSending(bool allowUnicode);
    public Stream get_ContentStream();
    public string get_ContentId();
    public void set_ContentId(string value);
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    internal Uri get_ContentLocation();
    internal void set_ContentLocation(Uri value);
    internal MimePart get_MimePart();
}
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, Attachment item);
    protected virtual void InsertItem(int index, Attachment item);
}
internal static class System.Net.Mail.AuthCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string type, string message, AsyncCallback callback, object state);
    internal static IAsyncResult BeginSend(SmtpConnection conn, string message, AsyncCallback callback, object state);
    internal static LineInfo EndSend(IAsyncResult result);
    internal static LineInfo Send(SmtpConnection conn, string type, string message);
    internal static LineInfo Send(SmtpConnection conn, string message);
}
internal class System.Net.Mail.BufferBuilder : object {
    internal int Length { get; }
    internal BufferBuilder(int initialSize);
    internal void Append(byte value);
    internal void Append(Byte[] value);
    internal void Append(Byte[] value, int offset, int count);
    internal void Append(string value);
    internal void Append(string value, bool allowUnicode);
    internal void Append(string value, int offset, int count, bool allowUnicode);
    internal void Append(string value, int offset, int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
}
internal static class System.Net.Mail.CheckCommand : object {
    private static CheckCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static object EndSend(IAsyncResult result, String& response);
    internal static SmtpStatusCode Send(SmtpConnection conn, String& response);
}
internal static class System.Net.Mail.DataCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static void EndSend(IAsyncResult result);
    internal static void Send(SmtpConnection conn);
}
internal static class System.Net.Mail.DataStopCommand : object {
    internal static void Send(SmtpConnection conn);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnSuccess;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
}
internal static class System.Net.Mail.DomainLiteralReader : object {
    internal static int ReadReverse(string data, int index);
}
internal static class System.Net.Mail.DotAtomReader : object {
    internal static int ReadReverse(string data, int index);
}
internal static class System.Net.Mail.EHelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    internal static String[] EndSend(IAsyncResult result);
    internal static String[] Send(SmtpConnection conn, string domain);
}
internal static class System.Net.Mail.HelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    internal static void EndSend(IAsyncResult result);
    internal static void Send(SmtpConnection conn, string domain);
}
internal static class System.Net.Mail.IisPickupDirectory : object {
    internal static string GetPickupDirectory();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("70b51430-b6ca-11d0-b9b9-00a0c922e750")]
internal interface System.Net.Mail.IMSAdminBase {
    public abstract virtual int AddKey(IntPtr handle, string Path);
    public abstract virtual int DeleteKey(IntPtr handle, string Path);
    public abstract virtual void DeleteChildKeys(IntPtr handle, string Path);
    public abstract virtual int EnumKeys(IntPtr handle, string Path, StringBuilder Buffer, int EnumKeyIndex);
    public abstract virtual void CopyKey(IntPtr source, string SourcePath, IntPtr dest, string DestPath, bool OverwriteFlag, bool CopyFlag);
    public abstract virtual void RenameKey(IntPtr key, string path, string newName);
    public abstract virtual int SetData(IntPtr key, string path, MetadataRecord& data);
    public abstract virtual int GetData(IntPtr key, string path, MetadataRecord& data, UInt32& RequiredDataLen);
    public abstract virtual int DeleteData(IntPtr key, string path, UInt32 Identifier, UInt32 DataType);
    public abstract virtual int EnumData(IntPtr key, string path, MetadataRecord& data, int EnumDataIndex, UInt32& RequiredDataLen);
    public abstract virtual int GetAllData(IntPtr handle, string Path, UInt32 Attributes, UInt32 UserType, UInt32 DataType, UInt32& NumDataEntries, UInt32& DataSetNumber, UInt32 BufferSize, IntPtr buffer, UInt32& RequiredBufferSize);
    public abstract virtual void DeleteAllData(IntPtr handle, string Path, UInt32 UserType, UInt32 DataType);
    public abstract virtual int CopyData(IntPtr sourcehandle, string SourcePath, IntPtr desthandle, string DestPath, int Attributes, int UserType, int DataType, bool CopyFlag);
    public abstract virtual void GetDataPaths(IntPtr handle, string Path, int Identifier, int DataType, int BufferSize, Char[]& Buffer, Int32& RequiredBufferSize);
    public abstract virtual int OpenKey(IntPtr handle, string Path, MBKeyAccess AccessRequested, int TimeOut, IntPtr& NewHandle);
    public abstract virtual int CloseKey(IntPtr handle);
    public abstract virtual void ChangePermissions(IntPtr handle, int TimeOut, MBKeyAccess AccessRequested);
    public abstract virtual void SaveData();
    public abstract virtual void GetHandleInfo(IntPtr handle, _METADATA_HANDLE_INFO& Info);
    public abstract virtual void GetSystemChangeNumber(UInt32& SystemChangeNumber);
    public abstract virtual void GetDataSetNumber(IntPtr handle, string Path, UInt32& DataSetNumber);
    public abstract virtual void SetLastChangeTime(IntPtr handle, string Path, FILETIME& LastChangeTime, bool LocalTime);
    public abstract virtual int GetLastChangeTime(IntPtr handle, string Path, FILETIME& LastChangeTime, bool LocalTime);
    public abstract virtual int KeyExchangePhase1();
    public abstract virtual int KeyExchangePhase2();
    public abstract virtual int Backup(string Location, int Version, int Flags);
    public abstract virtual int Restore(string Location, int Version, int Flags);
    public abstract virtual void EnumBackups(String& Location, UInt32& Version, FILETIME& BackupTime, UInt32 EnumIndex);
    public abstract virtual void DeleteBackup(string Location, int Version);
    public abstract virtual int UnmarshalInterface(IMSAdminBase& interf);
    public abstract virtual int GetServerGuid();
}
internal interface System.Net.Mail.ISmtpAuthenticationModule {
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, NetworkCredential credentials, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public abstract virtual string get_AuthenticationType();
    public abstract virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.LineInfo : ValueType {
    private string line;
    private SmtpStatusCode statusCode;
    internal string Line { get; }
    internal SmtpStatusCode StatusCode { get; }
    internal LineInfo(SmtpStatusCode statusCode, string line);
    internal string get_Line();
    internal SmtpStatusCode get_StatusCode();
}
public class System.Net.Mail.LinkedResource : AttachmentBase {
    public Uri ContentLink { get; public set; }
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, string mediaType);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, string mediaType);
    public LinkedResource(Stream contentStream, ContentType contentType);
    public Uri get_ContentLink();
    public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
}
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, LinkedResource item);
    protected virtual void InsertItem(int index, LinkedResource item);
}
public class System.Net.Mail.MailAddress : object {
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public string Address { get; }
    internal MailAddress(string displayName, string userName, string domain);
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    private static MailAddress();
    public string get_DisplayName();
    public string get_User();
    public string get_Host();
    public string get_Address();
    internal string GetSmtpAddress(bool allowUnicode);
    public virtual string ToString();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void SetItem(int index, MailAddress item);
    protected virtual void InsertItem(int index, MailAddress item);
    internal void ParseValue(string addresses);
    public virtual string ToString();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
internal static class System.Net.Mail.MailAddressParser : object {
    internal static MailAddress ParseAddress(string data);
    internal static IList`1<MailAddress> ParseMultipleAddresses(string data);
    internal static string NormalizeOrThrow(string input);
}
internal static class System.Net.Mail.MailCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, Byte[] command, MailAddress from, bool allowUnicode, AsyncCallback callback, object state);
    internal static void EndSend(IAsyncResult result);
    internal static void Send(SmtpConnection conn, Byte[] command, MailAddress from, bool allowUnicode);
}
internal enum System.Net.Mail.MailHeaderID : Enum {
    public int value__;
    public static MailHeaderID Bcc;
    public static MailHeaderID Cc;
    public static MailHeaderID Comments;
    public static MailHeaderID ContentDescription;
    public static MailHeaderID ContentDisposition;
    public static MailHeaderID ContentID;
    public static MailHeaderID ContentLocation;
    public static MailHeaderID ContentTransferEncoding;
    public static MailHeaderID ContentType;
    public static MailHeaderID Date;
    public static MailHeaderID From;
    public static MailHeaderID Importance;
    public static MailHeaderID InReplyTo;
    public static MailHeaderID Keywords;
    public static MailHeaderID Max;
    public static MailHeaderID MessageID;
    public static MailHeaderID MimeVersion;
    public static MailHeaderID Priority;
    public static MailHeaderID References;
    public static MailHeaderID ReplyTo;
    public static MailHeaderID ResentBcc;
    public static MailHeaderID ResentCc;
    public static MailHeaderID ResentDate;
    public static MailHeaderID ResentFrom;
    public static MailHeaderID ResentMessageID;
    public static MailHeaderID ResentSender;
    public static MailHeaderID ResentTo;
    public static MailHeaderID Sender;
    public static MailHeaderID Subject;
    public static MailHeaderID To;
    public static MailHeaderID XPriority;
    public static MailHeaderID XReceiver;
    public static MailHeaderID XSender;
    public static MailHeaderID ZMaxEnumValue;
    public static MailHeaderID Unknown;
}
internal static class System.Net.Mail.MailHeaderInfo : object {
    private static MailHeaderInfo();
    internal static string GetString(MailHeaderID id);
    internal static MailHeaderID GetID(string name);
    internal static bool IsWellKnown(string name);
    internal static bool IsUserSettable(string name);
    internal static bool IsSingleton(string name);
    internal static string NormalizeCase(string name);
    internal static bool IsMatch(string name, MailHeaderID header);
    internal static bool AllowsUnicode(string name);
}
public class System.Net.Mail.MailMessage : object {
    public MailAddress From { get; public set; }
    public MailAddress Sender { get; public set; }
    [ObsoleteAttribute("ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. http://go.microsoft.com/fwlink/?linkid=14202")]
public MailAddress ReplyTo { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    public MailAddressCollection To { get; }
    public MailAddressCollection Bcc { get; }
    public MailAddressCollection CC { get; }
    public MailPriority Priority { get; public set; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public string Subject { get; public set; }
    public Encoding SubjectEncoding { get; public set; }
    public NameValueCollection Headers { get; }
    public Encoding HeadersEncoding { get; public set; }
    public string Body { get; public set; }
    public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public AttachmentCollection Attachments { get; }
    public AlternateViewCollection AlternateViews { get; }
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    public MailMessage(MailAddress from, MailAddress to);
    public MailAddress get_From();
    public void set_From(MailAddress value);
    public MailAddress get_Sender();
    public void set_Sender(MailAddress value);
    public MailAddress get_ReplyTo();
    public void set_ReplyTo(MailAddress value);
    public MailAddressCollection get_ReplyToList();
    public MailAddressCollection get_To();
    public MailAddressCollection get_Bcc();
    public MailAddressCollection get_CC();
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public string get_Subject();
    public void set_Subject(string value);
    public Encoding get_SubjectEncoding();
    public void set_SubjectEncoding(Encoding value);
    public NameValueCollection get_Headers();
    public Encoding get_HeadersEncoding();
    public void set_HeadersEncoding(Encoding value);
    public string get_Body();
    public void set_Body(string value);
    public Encoding get_BodyEncoding();
    public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public AttachmentCollection get_Attachments();
    public AlternateViewCollection get_AlternateViews();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal IAsyncResult BeginSend(BaseWriter writer, bool sendEnvelope, bool allowUnicode, AsyncCallback callback, object state);
    internal void EndSend(IAsyncResult asyncResult);
    internal string BuildDeliveryStatusNotificationString();
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority Normal;
    public static MailPriority Low;
    public static MailPriority High;
}
internal class System.Net.Mail.MailWriter : BaseWriter {
    internal MailWriter(Stream stream);
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal virtual void Close();
    protected virtual void OnClose(object sender, EventArgs args);
}
internal enum System.Net.Mail.MBDataType : Enum {
    public byte value__;
    public static MBDataType All;
    public static MBDataType Dword;
    public static MBDataType String;
    public static MBDataType Binary;
    public static MBDataType StringExpand;
    public static MBDataType MultiString;
}
internal enum System.Net.Mail.MBErrors : Enum {
    public int value__;
    public static MBErrors DataNotFound;
    public static MBErrors InvalidVersion;
    public static MBErrors DuplicateNameWarning;
    public static MBErrors InvalidDataWarning;
    public static MBErrors AlreadyExists;
    public static MBErrors InvalidParameter;
    public static MBErrors PathNotFound;
    public static MBErrors PathBusy;
    public static MBErrors InsufficientBuffer;
    public static MBErrors NoMoreItems;
    public static MBErrors AccessDenied;
}
[FlagsAttribute]
internal enum System.Net.Mail.MBKeyAccess : Enum {
    public UInt32 value__;
    public static MBKeyAccess Read;
    public static MBKeyAccess Write;
}
internal enum System.Net.Mail.MBUserType : Enum {
    public byte value__;
    public static MBUserType Other;
    public static MBUserType Asp;
    public static MBUserType File;
    public static MBUserType Server;
    public static MBUserType Wam;
}
internal class System.Net.Mail.Message : object {
    public MailPriority Priority { get; public set; }
    internal MailAddress From { get; internal set; }
    internal MailAddress Sender { get; internal set; }
    internal MailAddress ReplyTo { get; internal set; }
    internal MailAddressCollection ReplyToList { get; }
    internal MailAddressCollection To { get; }
    internal MailAddressCollection Bcc { get; }
    internal MailAddressCollection CC { get; }
    internal string Subject { get; internal set; }
    internal Encoding SubjectEncoding { get; internal set; }
    internal HeaderCollection Headers { get; }
    internal Encoding HeadersEncoding { get; internal set; }
    internal HeaderCollection EnvelopeHeaders { get; }
    internal MimeBasePart Content { get; internal set; }
    internal Message(string from, string to);
    internal Message(MailAddress from, MailAddress to);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    internal MailAddress get_From();
    internal void set_From(MailAddress value);
    internal MailAddress get_Sender();
    internal void set_Sender(MailAddress value);
    internal MailAddress get_ReplyTo();
    internal void set_ReplyTo(MailAddress value);
    internal MailAddressCollection get_ReplyToList();
    internal MailAddressCollection get_To();
    internal MailAddressCollection get_Bcc();
    internal MailAddressCollection get_CC();
    internal string get_Subject();
    internal void set_Subject(string value);
    internal Encoding get_SubjectEncoding();
    internal void set_SubjectEncoding(Encoding value);
    internal HeaderCollection get_Headers();
    internal Encoding get_HeadersEncoding();
    internal void set_HeadersEncoding(Encoding value);
    internal HeaderCollection get_EnvelopeHeaders();
    internal virtual MimeBasePart get_Content();
    internal virtual void set_Content(MimeBasePart value);
    internal void EmptySendCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, bool sendEnvelope, bool allowUnicode, AsyncCallback callback, object state);
    internal virtual void EndSend(IAsyncResult asyncResult);
    internal virtual void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal void PrepareEnvelopeHeaders(bool sendEnvelope, bool allowUnicode);
    internal void PrepareHeaders(bool sendEnvelope, bool allowUnicode);
    internal void EncodeHeaders(HeaderCollection headers, bool allowUnicode);
}
internal class System.Net.Mail.MetadataRecord : ValueType {
    internal UInt32 Identifier;
    internal UInt32 Attributes;
    internal UInt32 UserType;
    internal UInt32 DataType;
    internal UInt32 DataLen;
    internal IntPtr DataBuf;
    internal UInt32 DataTag;
}
[ClassInterfaceAttribute("0")]
[TypeLibTypeAttribute("2")]
[GuidAttribute("a9e69610-b80d-11d0-b9b9-00a0c922e750")]
internal class System.Net.Mail.MSAdminBase : object {
}
internal enum System.Net.Mail.PropertyName : Enum {
    public int value__;
    public static PropertyName Invalid;
    public static PropertyName ServerState;
    public static PropertyName PickupDirectory;
}
internal static class System.Net.Mail.QuotedPairReader : object {
    internal static int CountQuotedChars(string data, int index, bool permitUnicodeEscaping);
}
internal static class System.Net.Mail.QuotedStringFormatReader : object {
    internal static int ReadReverseQuoted(string data, int index, bool permitUnicode);
    internal static int ReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter);
}
internal static class System.Net.Mail.ReadLinesCommand : object {
    private static ReadLinesCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static LineInfo[] EndSend(IAsyncResult result);
    internal static LineInfo[] Send(SmtpConnection conn);
}
internal static class System.Net.Mail.RecipientCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string to, AsyncCallback callback, object state);
    internal static bool EndSend(IAsyncResult result, String& response);
    internal static bool Send(SmtpConnection conn, string to, String& response);
}
internal enum System.Net.Mail.RecipientLocationType : Enum {
    public int value__;
    public static RecipientLocationType Local;
    public static RecipientLocationType Unknown;
    public static RecipientLocationType NotLocal;
    public static RecipientLocationType WillForward;
    public static RecipientLocationType Ambiguous;
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.Mail.SendMailAsyncResult : LazyAsyncResult {
    internal SendMailAsyncResult(SmtpConnection connection, MailAddress from, MailAddressCollection toCollection, bool allowUnicode, string deliveryNotify, AsyncCallback callback, object state);
    private static SendMailAsyncResult();
    internal void Send();
    internal static MailWriter End(IAsyncResult result);
    internal SmtpFailedRecipientException GetFailedRecipientException();
}
internal enum System.Net.Mail.ServerState : Enum {
    public int value__;
    public static ServerState Starting;
    public static ServerState Started;
    public static ServerState Stopping;
    public static ServerState Stopped;
    public static ServerState Pausing;
    public static ServerState Paused;
    public static ServerState Continuing;
}
public enum System.Net.Mail.SmtpAccess : Enum {
    public int value__;
    public static SmtpAccess None;
    public static SmtpAccess Connect;
    public static SmtpAccess ConnectToUnrestrictedPort;
}
internal static class System.Net.Mail.SmtpAuthenticationManager : object {
    private static SmtpAuthenticationManager();
    internal static void Register(ISmtpAuthenticationModule module);
    internal static ISmtpAuthenticationModule[] GetModules();
}
public class System.Net.Mail.SmtpClient : object {
    internal string clientDomain;
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public int Timeout { get; public set; }
    public ServicePoint ServicePoint { get; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public bool EnableSsl { get; public set; }
    public X509CertificateCollection ClientCertificates { get; }
    public string TargetName { get; public set; }
    internal bool InCall { get; internal set; }
    internal static MailSettingsSectionGroupInternal MailConfiguration { get; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    private static SmtpClient();
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public ServicePoint get_ServicePoint();
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_TargetName(string value);
    public string get_TargetName();
    internal MailWriter GetFileMailWriter(string pickupDirectory);
    protected void OnSendCompleted(AsyncCompletedEventArgs e);
    public void Send(string from, string recipients, string subject, string body);
    public void Send(MailMessage message);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    public void SendAsync(MailMessage message, object userToken);
    public void SendAsyncCancel();
    public Task SendMailAsync(string from, string recipients, string subject, string body);
    public Task SendMailAsync(MailMessage message);
    internal bool get_InCall();
    internal void set_InCall(bool value);
    internal static MailSettingsSectionGroupInternal get_MailConfiguration();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal static class System.Net.Mail.SmtpCommands : object {
    internal static Byte[] Auth;
    internal static Byte[] CRLF;
    internal static Byte[] Data;
    internal static Byte[] DataStop;
    internal static Byte[] EHello;
    internal static Byte[] Expand;
    internal static Byte[] Hello;
    internal static Byte[] Help;
    internal static Byte[] Mail;
    internal static Byte[] Noop;
    internal static Byte[] Quit;
    internal static Byte[] Recipient;
    internal static Byte[] Reset;
    internal static Byte[] Send;
    internal static Byte[] SendAndMail;
    internal static Byte[] SendOrMail;
    internal static Byte[] Turn;
    internal static Byte[] Verify;
    internal static Byte[] StartTls;
    private static SmtpCommands();
}
internal class System.Net.Mail.SmtpConnection : object {
    internal SmtpTransport parent;
    internal SmtpClient client;
    internal BufferBuilder BufferBuilder { get; }
    internal bool IsConnected { get; }
    internal bool IsStreamOpen { get; }
    internal bool DSNEnabled { get; }
    internal SmtpReplyReaderFactory Reader { get; }
    internal bool EnableSsl { get; internal set; }
    internal int Timeout { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; internal set; }
    internal bool ServerSupportsEai { get; }
    internal SmtpConnection(SmtpTransport parent, SmtpClient client, ICredentialsByHost credentials, ISmtpAuthenticationModule[] authenticationModules);
    private static SmtpConnection();
    internal BufferBuilder get_BufferBuilder();
    internal bool get_IsConnected();
    internal bool get_IsStreamOpen();
    internal bool get_DSNEnabled();
    internal SmtpReplyReaderFactory get_Reader();
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal int get_Timeout();
    internal void set_Timeout(int value);
    internal X509CertificateCollection get_ClientCertificates();
    internal void set_ClientCertificates(X509CertificateCollection value);
    internal bool get_ServerSupportsEai();
    internal IAsyncResult BeginGetConnection(ServicePoint servicePoint, ContextAwareResult outerResult, AsyncCallback callback, object state);
    internal IAsyncResult BeginFlush(AsyncCallback callback, object state);
    internal void EndFlush(IAsyncResult result);
    internal void Flush();
    internal void ReleaseConnection();
    internal void Abort();
    internal void ParseExtensions(String[] extensions);
    internal bool AuthSupported(ISmtpAuthenticationModule module);
    internal void GetConnection(ServicePoint servicePoint);
    internal void EndGetConnection(IAsyncResult result);
    internal Stream GetClosableStream();
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat SevenBit;
    public static SmtpDeliveryFormat International;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
}
internal class System.Net.Mail.SmtpDigestAuthenticationModule : object {
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
public class System.Net.Mail.SmtpException : Exception {
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(SmtpStatusCode statusCode, string message);
    public SmtpException(string message);
    public SmtpException(string message, Exception innerException);
    protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal SmtpException(SmtpStatusCode statusCode, string serverMessage, bool serverResponse);
    internal SmtpException(string message, string serverResponse);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
}
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    internal bool fatal;
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(string message);
    public SmtpFailedRecipientException(string message, Exception innerException);
    protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public string get_FailedRecipient();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    public SmtpFailedRecipientsException(string message);
    public SmtpFailedRecipientsException(string message, Exception innerException);
    protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    internal SmtpFailedRecipientsException(ArrayList innerExceptions, bool allFailed);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.Mail.SmtpLoginAuthenticationModule : object {
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpNegotiateAuthenticationModule : object {
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpNtlmAuthenticationModule : object {
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
public class System.Net.Mail.SmtpPermission : CodeAccessPermission {
    public SmtpAccess Access { get; }
    public SmtpPermission(PermissionState state);
    public SmtpPermission(bool unrestricted);
    public SmtpPermission(SmtpAccess access);
    public SmtpAccess get_Access();
    public void AddPermission(SmtpAccess access);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.Mail.SmtpPermissionAttribute : CodeAccessSecurityAttribute {
    public string Access { get; public set; }
    public SmtpPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public virtual IPermission CreatePermission();
}
internal class System.Net.Mail.SmtpPooledStream : PooledStream {
    internal bool previouslyUsed;
    internal bool dsnEnabled;
    internal bool serverSupportsEai;
    internal ICredentialsByHost creds;
    internal SmtpPooledStream(ConnectionPool connectionPool, TimeSpan lifetime, bool checkLifetime);
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.Mail.SmtpReplyReader : object {
    internal SmtpReplyReader(SmtpReplyReaderFactory reader);
    internal IAsyncResult BeginReadLines(AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(AsyncCallback callback, object state);
    public void Close();
    internal LineInfo[] EndReadLines(IAsyncResult result);
    internal LineInfo EndReadLine(IAsyncResult result);
    internal LineInfo[] ReadLines();
    internal LineInfo ReadLine();
}
internal class System.Net.Mail.SmtpReplyReaderFactory : object {
    internal SmtpReplyReader CurrentReader { get; }
    internal SmtpStatusCode StatusCode { get; }
    internal SmtpReplyReaderFactory(Stream stream);
    internal SmtpReplyReader get_CurrentReader();
    internal SmtpStatusCode get_StatusCode();
    internal IAsyncResult BeginReadLines(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal void Close(SmtpReplyReader caller);
    internal LineInfo[] EndReadLines(IAsyncResult result);
    internal LineInfo EndReadLine(IAsyncResult result);
    internal SmtpReplyReader GetNextReplyReader();
    internal int Read(SmtpReplyReader caller, Byte[] buffer, int offset, int count);
    internal LineInfo ReadLine(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller, bool oneLine);
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode UserNotLocalWillForward;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode MustIssueStartTlsFirst;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode GeneralFailure;
}
internal class System.Net.Mail.SmtpTransport : object {
    internal static int DefaultPort;
    internal ICredentialsByHost Credentials { get; internal set; }
    internal bool IdentityRequired { get; internal set; }
    internal bool IsConnected { get; }
    internal int Timeout { get; internal set; }
    internal bool EnableSsl { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; }
    internal bool ServerSupportsEai { get; }
    internal SmtpTransport(SmtpClient client);
    internal SmtpTransport(SmtpClient client, ISmtpAuthenticationModule[] authenticationModules);
    internal ICredentialsByHost get_Credentials();
    internal void set_Credentials(ICredentialsByHost value);
    internal bool get_IdentityRequired();
    internal void set_IdentityRequired(bool value);
    internal bool get_IsConnected();
    internal int get_Timeout();
    internal void set_Timeout(int value);
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal X509CertificateCollection get_ClientCertificates();
    internal bool get_ServerSupportsEai();
    internal void GetConnection(ServicePoint servicePoint);
    internal IAsyncResult BeginGetConnection(ServicePoint servicePoint, ContextAwareResult outerResult, AsyncCallback callback, object state);
    internal void EndGetConnection(IAsyncResult result);
    internal IAsyncResult BeginSendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, AsyncCallback callback, object state);
    internal void ReleaseConnection();
    internal void Abort();
    internal MailWriter EndSendMail(IAsyncResult result);
    internal MailWriter SendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, SmtpFailedRecipientException& exception);
    internal void CloseIdleConnections(ServicePoint servicePoint);
}
internal static class System.Net.Mail.StartTlsCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static void EndSend(IAsyncResult result);
    internal static void Send(SmtpConnection conn);
}
internal enum System.Net.Mail.SupportedAuth : Enum {
    public int value__;
    public static SupportedAuth None;
    public static SupportedAuth Login;
    public static SupportedAuth NTLM;
    public static SupportedAuth GSSAPI;
    public static SupportedAuth WDigest;
}
internal static class System.Net.Mail.WhitespaceReader : object {
    internal static int ReadFwsReverse(string data, int index);
    internal static int ReadCfwsReverse(string data, int index);
}
internal class System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
    internal int Padding { get; internal set; }
    internal byte LastBits { get; internal set; }
    internal Base64WriteStateInfo(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    [CompilerGeneratedAttribute]
internal int get_Padding();
    [CompilerGeneratedAttribute]
internal void set_Padding(int value);
    [CompilerGeneratedAttribute]
internal byte get_LastBits();
    [CompilerGeneratedAttribute]
internal void set_LastBits(byte value);
}
internal abstract class System.Net.Mime.BaseWriter : object {
    protected static Byte[] CRLF;
    protected BufferBuilder bufferBuilder;
    protected Stream contentStream;
    protected bool isInContent;
    protected Stream stream;
    protected BaseWriter(Stream stream, bool shouldEncodeLeadingDots);
    private static BaseWriter();
    internal abstract virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal void WriteHeader(string name, string value, bool allowUnicode);
    internal Stream GetContentStream();
    internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state);
    internal Stream EndGetContentStream(IAsyncResult result);
    protected void Flush(MultiAsyncResult multiResult);
    protected static void OnWrite(IAsyncResult result);
    internal abstract virtual void Close();
    protected abstract virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
public class System.Net.Mime.ContentDisposition : object {
    public string DispositionType { get; public set; }
    public StringDictionary Parameters { get; }
    public string FileName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    internal bool IsChanged { get; }
    private static ContentDisposition();
    public ContentDisposition(string disposition);
    internal DateTime GetDateParameter(string parameterName);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public StringDictionary get_Parameters();
    public string get_FileName();
    public void set_FileName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    internal void Set(string contentDisposition, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
}
internal enum System.Net.Mime.ContentTransferEncoding : Enum {
    public int value__;
    public static ContentTransferEncoding SevenBit;
    public static ContentTransferEncoding EightBit;
    public static ContentTransferEncoding Binary;
    public static ContentTransferEncoding Base64;
    public static ContentTransferEncoding QuotedPrintable;
    public static ContentTransferEncoding QEncoded;
    public static ContentTransferEncoding Other;
    public static ContentTransferEncoding Unspecified;
}
public class System.Net.Mime.ContentType : object {
    internal static string Default;
    public string Boundary { get; public set; }
    public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    internal bool IsChanged { get; }
    public ContentType(string contentType);
    private static ContentType();
    public string get_Boundary();
    public void set_Boundary(string value);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    internal void Set(string contentType, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
}
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Inline;
    public static string Attachment;
}
internal class System.Net.Mime.EightBitStream : DelegatedStream {
    internal EightBitStream(Stream stream);
    internal EightBitStream(Stream stream, bool shouldEncodeLeadingDots);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
}
internal class System.Net.Mime.EncodedStreamFactory : object {
    internal static int DefaultMaxLineLength { get; }
    internal static int get_DefaultMaxLineLength();
    internal IEncodableStream GetEncoder(TransferEncoding encoding, Stream stream);
    internal IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength);
    protected Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding);
    protected Byte[] CreateFooter();
}
internal class System.Net.Mime.HeaderCollection : NameValueCollection {
    public virtual void Remove(string name);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    internal void InternalRemove(string name);
    internal void InternalSet(string name, string value);
    internal void InternalAdd(string name, string value);
    public virtual void Set(string name, string value);
    public virtual void Add(string name, string value);
}
internal interface System.Net.Mime.IEncodableStream {
    public abstract virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual string GetEncodedString();
    public abstract virtual Stream GetStream();
}
internal static class System.Net.Mime.MailBnfHelper : object {
    internal static Boolean[] Atext;
    internal static Boolean[] Qtext;
    internal static Boolean[] Dtext;
    internal static Boolean[] Ftext;
    internal static Boolean[] Ttext;
    internal static Boolean[] Ctext;
    internal static int Ascii7bitMaxValue;
    internal static char Quote;
    internal static char Space;
    internal static char Tab;
    internal static char CR;
    internal static char LF;
    internal static char StartComment;
    internal static char EndComment;
    internal static char Backslash;
    internal static char At;
    internal static char EndAngleBracket;
    internal static char StartAngleBracket;
    internal static char StartSquareBracket;
    internal static char EndSquareBracket;
    internal static char Comma;
    internal static char Dot;
    internal static IList`1<char> Whitespace;
    private static MailBnfHelper();
    internal static bool SkipCFWS(string data, Int32& offset);
    internal static void ValidateHeaderName(string data);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName);
    internal static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    internal static string ReadToken(string data, Int32& offset, StringBuilder builder);
    internal static string GetDateTimeString(DateTime value, StringBuilder builder);
    internal static void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode);
    internal static bool HasCROrLF(string data);
    internal static bool IsFWSAt(string data, int index);
}
public static class System.Net.Mime.MediaTypeNames : object {
}
internal class System.Net.Mime.MimeBasePart : object {
    protected ContentType contentType;
    protected ContentDisposition contentDisposition;
    internal static string defaultCharSet;
    internal string ContentID { get; internal set; }
    internal string ContentLocation { get; internal set; }
    internal NameValueCollection Headers { get; }
    internal ContentType ContentType { get; internal set; }
    internal static bool ShouldUseBase64Encoding(Encoding encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength);
    internal static string DecodeHeaderValue(string value);
    internal static Encoding DecodeEncoding(string value);
    internal static bool IsAscii(string value, bool permitCROrLF);
    internal static bool IsAnsi(string value, bool permitCROrLF);
    internal string get_ContentID();
    internal void set_ContentID(string value);
    internal string get_ContentLocation();
    internal void set_ContentLocation(string value);
    internal NameValueCollection get_Headers();
    internal ContentType get_ContentType();
    internal void set_ContentType(ContentType value);
    internal void PrepareHeaders(bool allowUnicode);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal void EndSend(IAsyncResult asyncResult);
}
internal class System.Net.Mime.MimeMultiPart : MimeBasePart {
    unknown MimeMultiPartType MimeMultiPartType {internal set; }
    internal Collection`1<MimeBasePart> Parts { get; }
    internal MimeMultiPart(MimeMultiPartType type);
    internal void set_MimeMultiPartType(MimeMultiPartType value);
    internal Collection`1<MimeBasePart> get_Parts();
    internal void Complete(IAsyncResult result, Exception e);
    internal void MimeWriterCloseCallback(IAsyncResult result);
    internal void MimePartSentCallback(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal string GetNextBoundary();
}
internal enum System.Net.Mime.MimeMultiPartType : Enum {
    public int value__;
    public static MimeMultiPartType Mixed;
    public static MimeMultiPartType Alternative;
    public static MimeMultiPartType Parallel;
    public static MimeMultiPartType Related;
    public static MimeMultiPartType Unknown;
}
internal class System.Net.Mime.MimePart : MimeBasePart {
    internal Stream Stream { get; }
    internal ContentDisposition ContentDisposition { get; internal set; }
    internal TransferEncoding TransferEncoding { get; internal set; }
    public sealed virtual void Dispose();
    internal Stream get_Stream();
    internal ContentDisposition get_ContentDisposition();
    internal void set_ContentDisposition(ContentDisposition value);
    internal TransferEncoding get_TransferEncoding();
    internal void set_TransferEncoding(TransferEncoding value);
    internal void SetContent(Stream stream);
    internal void SetContent(Stream stream, string name, string mimeType);
    internal void SetContent(Stream stream, ContentType contentType);
    internal void Complete(IAsyncResult result, Exception e);
    internal void ReadCallback(IAsyncResult result);
    internal void ReadCallbackHandler(IAsyncResult result);
    internal void WriteCallback(IAsyncResult result);
    internal void WriteCallbackHandler(IAsyncResult result);
    internal Stream GetEncodedStream(Stream stream);
    internal void ContentStreamCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal void ResetStream();
}
internal class System.Net.Mime.MimeWriter : BaseWriter {
    internal MimeWriter(Stream stream, string boundary);
    private static MimeWriter();
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal IAsyncResult BeginClose(AsyncCallback callback, object state);
    internal void EndClose(IAsyncResult result);
    internal virtual void Close();
    protected virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
internal class System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
    internal object Context { get; }
    internal MultiAsyncResult(object context, AsyncCallback callback, object state);
    internal object get_Context();
    internal void Enter();
    internal void Leave();
    internal void Leave(object result);
    internal void CompleteSequence();
    internal static object End(IAsyncResult result);
}
internal class System.Net.Mime.QEncodedStream : DelegatedStream {
    internal WriteStateInfoBase WriteState { get; }
    internal QEncodedStream(WriteStateInfoBase wsi);
    private static QEncodedStream();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.QuotedPrintableStream : DelegatedStream {
    internal WriteStateInfoBase WriteState { get; }
    internal QuotedPrintableStream(Stream stream, int lineLength);
    internal QuotedPrintableStream(Stream stream, bool encodeCRLF);
    private static QuotedPrintableStream();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual Stream GetStream();
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.SmtpDateTime : object {
    internal static string unknownTimeZoneDefaultOffset;
    internal static string utcDefaultTimeZoneOffset;
    internal static int offsetLength;
    internal static int maxMinuteValue;
    internal static string dateFormatWithDayOfWeek;
    internal static string dateFormatWithoutDayOfWeek;
    internal static string dateFormatWithDayOfWeekAndNoSeconds;
    internal static string dateFormatWithoutDayOfWeekAndNoSeconds;
    internal static String[] validDateTimeFormats;
    internal static Char[] allowedWhiteSpaceChars;
    internal static IDictionary`2<string, TimeSpan> timeZoneOffsetLookup;
    internal static long timeSpanMaxTicks;
    internal static int offsetMaxValue;
    internal DateTime Date { get; }
    internal SmtpDateTime(DateTime value);
    internal SmtpDateTime(string value);
    private static SmtpDateTime();
    internal static IDictionary`2<string, TimeSpan> InitializeShortHandLookups();
    internal DateTime get_Date();
    public virtual string ToString();
    internal void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes);
    internal void ValidateTimeZoneShortHandValue(string value);
    internal string FormatDate(DateTime value);
    internal DateTime ParseValue(string data, String& timeZone);
    internal bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone);
    internal TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span);
    internal string TimeSpanToOffset(TimeSpan span);
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding Base64;
    public static TransferEncoding SevenBit;
    public static TransferEncoding EightBit;
    public static TransferEncoding Unknown;
}
internal class System.Net.Mime.WriteStateInfoBase : object {
    protected Byte[] _header;
    protected Byte[] _footer;
    protected int _maxLineLength;
    protected Byte[] buffer;
    protected int _currentLineLength;
    protected int _currentBufferUsed;
    protected static int defaultBufferSize;
    internal int FooterLength { get; }
    internal Byte[] Footer { get; }
    internal Byte[] Header { get; }
    internal Byte[] Buffer { get; }
    internal int Length { get; }
    internal int CurrentLineLength { get; }
    internal int MaxLineLength { get; }
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength);
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    internal int get_FooterLength();
    internal Byte[] get_Footer();
    internal Byte[] get_Header();
    internal Byte[] get_Buffer();
    internal int get_Length();
    internal int get_CurrentLineLength();
    internal void Append(byte aByte);
    internal void Append(Byte[] bytes);
    internal void AppendCRLF(bool includeSpace);
    internal void AppendHeader();
    internal void AppendFooter();
    internal int get_MaxLineLength();
    internal void Reset();
    internal void BufferFlushed();
}
[FlagsAttribute]
internal enum System.Net.NameInfoFlags : Enum {
    public int value__;
    public static NameInfoFlags NI_NOFQDN;
    public static NameInfoFlags NI_NUMERICHOST;
    public static NameInfoFlags NI_NAMEREQD;
    public static NameInfoFlags NI_NUMERICSERV;
    public static NameInfoFlags NI_DGRAM;
}
internal static class System.Net.NclConstants : object {
    internal static object Sentinel;
    internal static Object[] EmptyObjectArray;
    internal static Uri[] EmptyUriArray;
    internal static Byte[] CRLF;
    internal static Byte[] ChunkTerminator;
    private static NclConstants();
}
internal static class System.Net.NclUtilities : object {
    internal static bool HasShutdownStarted { get; }
    internal static ContextCallback ContextRelativeDemandCallback { get; }
    internal static IPAddress[] LocalAddresses { get; }
    internal static bool IsThreadPoolLow();
    internal static bool get_HasShutdownStarted();
    internal static bool IsCredentialFailure(SecurityStatus error);
    internal static bool IsClientFault(SecurityStatus error);
    internal static ContextCallback get_ContextRelativeDemandCallback();
    internal static bool GuessWhetherHostIsLoopback(string host);
    internal static bool IsFatal(Exception exception);
    internal static IPAddress[] get_LocalAddresses();
    internal static bool IsAddressLocal(IPAddress ipAddress);
}
internal class System.Net.NegotiateClient : object {
    internal static string AuthType;
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public bool CanUseDefaultCredentials { get; }
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual bool get_CanPreAuthenticate();
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool Update(string challenge, WebRequest webRequest);
    public sealed virtual void ClearSession(WebRequest webRequest);
    public sealed virtual bool get_CanUseDefaultCredentials();
}
internal class System.Net.NegotiationInfo : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
    internal static int Size;
    internal static int NegotiationStateOffest;
    private static NegotiationInfo();
}
internal class System.Net.NegotiationInfoClass : object {
    internal static string NTLM;
    internal static string Kerberos;
    internal static string WDigest;
    internal static string Negotiate;
    internal string AuthenticationPackage;
    internal NegotiationInfoClass(SafeHandle safeHandle, int negotiationState);
}
internal class System.Net.NestedMultipleAsyncResult : LazyAsyncResult {
    internal BufferOffsetSize[] Buffers;
    internal int Size;
    internal NestedMultipleAsyncResult(object asyncObject, object asyncState, AsyncCallback asyncCallback, BufferOffsetSize[] buffers);
}
internal class System.Net.NestedSingleAsyncResult : LazyAsyncResult {
    internal Byte[] Buffer;
    internal int Offset;
    internal int Size;
    internal NestedSingleAsyncResult(object asyncObject, object asyncState, AsyncCallback asyncCallback, object result);
    internal NestedSingleAsyncResult(object asyncObject, object asyncState, AsyncCallback asyncCallback, Byte[] buffer, int offset, int size);
}
internal class System.Net.NetRes : object {
    public static string GetWebStatusString(string Res, WebExceptionStatus Status);
    public static string GetWebStatusString(WebExceptionStatus Status);
    public static string GetWebStatusCodeString(HttpStatusCode statusCode, string statusDescription);
    public static string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription);
}
internal class System.Net.NetWebProxyFinder : BaseWebProxyFinder {
    public NetWebProxyFinder(AutoWebProxyScriptEngine engine);
    private static NetWebProxyFinder();
    public virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public virtual void Abort();
    protected virtual void Dispose(bool disposing);
}
[FlagsAttribute]
public enum System.Net.NetworkAccess : Enum {
    public int value__;
    public static NetworkAccess Accept;
    public static NetworkAccess Connect;
}
internal class System.Net.NetworkAddressChangePolled : object {
    internal bool CheckAndReset();
    public sealed virtual void Dispose();
}
public class System.Net.NetworkCredential : object {
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public SecureString SecurePassword { get; public set; }
    public string Domain { get; public set; }
    public NetworkCredential(string userName, string password);
    public NetworkCredential(string userName, SecureString password);
    public NetworkCredential(string userName, string password, string domain);
    public NetworkCredential(string userName, SecureString password, string domain);
    private static NetworkCredential();
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public void set_SecurePassword(SecureString value);
    public string get_Domain();
    public void set_Domain(string value);
    internal string InternalGetUserName();
    internal string InternalGetPassword();
    internal SecureString InternalGetSecurePassword();
    internal string InternalGetDomain();
    internal string InternalGetDomainUserName();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.AdapterAddressFlags : Enum {
    public int value__;
    public static AdapterAddressFlags DnsEligible;
    public static AdapterAddressFlags Transient;
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.AdapterFlags : Enum {
    public int value__;
    public static AdapterFlags DnsEnabled;
    public static AdapterFlags RegisterAdapterSuffix;
    public static AdapterFlags DhcpEnabled;
    public static AdapterFlags ReceiveOnly;
    public static AdapterFlags NoMulticast;
    public static AdapterFlags Ipv6OtherStatefulConfig;
    public static AdapterFlags NetBiosOverTcp;
    public static AdapterFlags IPv4Enabled;
    public static AdapterFlags IPv6Enabled;
    public static AdapterFlags IPv6ManagedAddressConfigurationSupported;
}
public enum System.Net.NetworkInformation.DuplicateAddressDetectionState : Enum {
    public int value__;
    public static DuplicateAddressDetectionState Invalid;
    public static DuplicateAddressDetectionState Tentative;
    public static DuplicateAddressDetectionState Duplicate;
    public static DuplicateAddressDetectionState Deprecated;
    public static DuplicateAddressDetectionState Preferred;
}
internal class System.Net.NetworkInformation.FIXED_INFO : ValueType {
    internal static int MAX_HOSTNAME_LEN;
    internal static int MAX_DOMAIN_NAME_LEN;
    internal static int MAX_SCOPE_ID_LEN;
    internal string hostName;
    internal string domainName;
    internal UInt32 currentDnsServer;
    internal IpAddrString DnsServerList;
    internal NetBiosNodeType nodeType;
    internal string scopeId;
    internal bool enableRouting;
    internal bool enableProxy;
    internal bool enableDns;
}
internal class System.Net.NetworkInformation.FixedInfo : ValueType {
    internal FIXED_INFO info;
    internal string HostName { get; }
    internal string DomainName { get; }
    internal NetBiosNodeType NodeType { get; }
    internal string ScopeId { get; }
    internal bool EnableRouting { get; }
    internal bool EnableProxy { get; }
    internal bool EnableDns { get; }
    internal FixedInfo(FIXED_INFO info);
    internal string get_HostName();
    internal string get_DomainName();
    internal NetBiosNodeType get_NodeType();
    internal string get_ScopeId();
    internal bool get_EnableRouting();
    internal bool get_EnableProxy();
    internal bool get_EnableDns();
}
public abstract class System.Net.NetworkInformation.GatewayIPAddressInformation : object {
    public IPAddress Address { get; }
    public abstract virtual IPAddress get_Address();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.GatewayIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public GatewayIPAddressInformation Item { get; }
    public virtual void CopyTo(GatewayIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual GatewayIPAddressInformation get_Item(int index);
    public virtual void Add(GatewayIPAddressInformation address);
    internal void InternalAdd(GatewayIPAddressInformation address);
    public virtual bool Contains(GatewayIPAddressInformation address);
    public virtual IEnumerator`1<GatewayIPAddressInformation> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Remove(GatewayIPAddressInformation address);
    public virtual void Clear();
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.GetAdaptersAddressesFlags : Enum {
    public int value__;
    public static GetAdaptersAddressesFlags SkipUnicast;
    public static GetAdaptersAddressesFlags SkipAnycast;
    public static GetAdaptersAddressesFlags SkipMulticast;
    public static GetAdaptersAddressesFlags SkipDnsServer;
    public static GetAdaptersAddressesFlags IncludePrefix;
    public static GetAdaptersAddressesFlags SkipFriendlyName;
    public static GetAdaptersAddressesFlags IncludeWins;
    public static GetAdaptersAddressesFlags IncludeGateways;
    public static GetAdaptersAddressesFlags IncludeAllInterfaces;
    public static GetAdaptersAddressesFlags IncludeAllCompartments;
    public static GetAdaptersAddressesFlags IncludeTunnelBindingOrder;
}
internal class System.Net.NetworkInformation.Icmp6EchoReply : ValueType {
    internal Ipv6Address Address;
    internal UInt32 Status;
    internal UInt32 RoundTripTime;
    internal IntPtr data;
}
internal class System.Net.NetworkInformation.IcmpEchoReply : ValueType {
    internal UInt32 address;
    internal UInt32 status;
    internal UInt32 roundTripTime;
    internal ushort dataSize;
    internal ushort reserved;
    internal IntPtr data;
    internal IPOptions options;
}
internal enum System.Net.NetworkInformation.IcmpV4Code : Enum {
    public int value__;
    public static IcmpV4Code ICMP4_UNREACH_NET;
    public static IcmpV4Code ICMP4_UNREACH_HOST;
    public static IcmpV4Code ICMP4_UNREACH_PROTOCOL;
    public static IcmpV4Code ICMP4_UNREACH_PORT;
    public static IcmpV4Code ICMP4_UNREACH_FRAG_NEEDED;
    public static IcmpV4Code ICMP4_UNREACH_SOURCEROUTE_FAILED;
    public static IcmpV4Code ICMP4_UNREACH_NET_UNKNOWN;
    public static IcmpV4Code ICMP4_UNREACH_HOST_UNKNOWN;
    public static IcmpV4Code ICMP4_UNREACH_ISOLATED;
    public static IcmpV4Code ICMP4_UNREACH_NET_ADMIN;
    public static IcmpV4Code ICMP4_UNREACH_HOST_ADMIN;
    public static IcmpV4Code ICMP4_UNREACH_NET_TOS;
    public static IcmpV4Code ICMP4_UNREACH_HOST_TOS;
    public static IcmpV4Code ICMP4_UNREACH_ADMIN;
}
public abstract class System.Net.NetworkInformation.IcmpV4Statistics : object {
    public long AddressMaskRepliesReceived { get; }
    public long AddressMaskRepliesSent { get; }
    public long AddressMaskRequestsReceived { get; }
    public long AddressMaskRequestsSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long SourceQuenchesReceived { get; }
    public long SourceQuenchesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimestampRepliesReceived { get; }
    public long TimestampRepliesSent { get; }
    public long TimestampRequestsReceived { get; }
    public long TimestampRequestsSent { get; }
    public abstract virtual long get_AddressMaskRepliesReceived();
    public abstract virtual long get_AddressMaskRepliesSent();
    public abstract virtual long get_AddressMaskRequestsReceived();
    public abstract virtual long get_AddressMaskRequestsSent();
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_SourceQuenchesReceived();
    public abstract virtual long get_SourceQuenchesSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
    public abstract virtual long get_TimestampRepliesReceived();
    public abstract virtual long get_TimestampRepliesSent();
    public abstract virtual long get_TimestampRequestsReceived();
    public abstract virtual long get_TimestampRequestsSent();
}
internal enum System.Net.NetworkInformation.IcmpV4Type : Enum {
    public int value__;
    public static IcmpV4Type ICMP4_ECHO_REPLY;
    public static IcmpV4Type ICMP4_DST_UNREACH;
    public static IcmpV4Type ICMP4_SOURCE_QUENCH;
    public static IcmpV4Type ICMP4_TIME_EXCEEDED;
    public static IcmpV4Type ICMP4_PARAM_PROB;
    public static IcmpV4Type ICMP4_REDIRECT;
    public static IcmpV4Type ICMP4_ECHO_REQUEST;
    public static IcmpV4Type ICMP4_ROUTER_ADVERT;
    public static IcmpV4Type ICMP4_ROUTER_SOLICIT;
    public static IcmpV4Type ICMP4_TIMESTAMP_REQUEST;
    public static IcmpV4Type ICMP4_TIMESTAMP_REPLY;
    public static IcmpV4Type ICMP4_MASK_REQUEST;
    public static IcmpV4Type ICMP4_MASK_REPLY;
}
public abstract class System.Net.NetworkInformation.IcmpV6Statistics : object {
    public long DestinationUnreachableMessagesReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long EchoRepliesReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRequestsSent { get; }
    public long ErrorsReceived { get; }
    public long ErrorsSent { get; }
    public long MembershipQueriesReceived { get; }
    public long MembershipQueriesSent { get; }
    public long MembershipReductionsReceived { get; }
    public long MembershipReductionsSent { get; }
    public long MembershipReportsReceived { get; }
    public long MembershipReportsSent { get; }
    public long MessagesReceived { get; }
    public long MessagesSent { get; }
    public long NeighborAdvertisementsReceived { get; }
    public long NeighborAdvertisementsSent { get; }
    public long NeighborSolicitsReceived { get; }
    public long NeighborSolicitsSent { get; }
    public long PacketTooBigMessagesReceived { get; }
    public long PacketTooBigMessagesSent { get; }
    public long ParameterProblemsReceived { get; }
    public long ParameterProblemsSent { get; }
    public long RedirectsReceived { get; }
    public long RedirectsSent { get; }
    public long RouterAdvertisementsReceived { get; }
    public long RouterAdvertisementsSent { get; }
    public long RouterSolicitsReceived { get; }
    public long RouterSolicitsSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public abstract virtual long get_DestinationUnreachableMessagesReceived();
    public abstract virtual long get_DestinationUnreachableMessagesSent();
    public abstract virtual long get_EchoRepliesReceived();
    public abstract virtual long get_EchoRepliesSent();
    public abstract virtual long get_EchoRequestsReceived();
    public abstract virtual long get_EchoRequestsSent();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_ErrorsSent();
    public abstract virtual long get_MembershipQueriesReceived();
    public abstract virtual long get_MembershipQueriesSent();
    public abstract virtual long get_MembershipReductionsReceived();
    public abstract virtual long get_MembershipReductionsSent();
    public abstract virtual long get_MembershipReportsReceived();
    public abstract virtual long get_MembershipReportsSent();
    public abstract virtual long get_MessagesReceived();
    public abstract virtual long get_MessagesSent();
    public abstract virtual long get_NeighborAdvertisementsReceived();
    public abstract virtual long get_NeighborAdvertisementsSent();
    public abstract virtual long get_NeighborSolicitsReceived();
    public abstract virtual long get_NeighborSolicitsSent();
    public abstract virtual long get_PacketTooBigMessagesReceived();
    public abstract virtual long get_PacketTooBigMessagesSent();
    public abstract virtual long get_ParameterProblemsReceived();
    public abstract virtual long get_ParameterProblemsSent();
    public abstract virtual long get_RedirectsReceived();
    public abstract virtual long get_RedirectsSent();
    public abstract virtual long get_RouterAdvertisementsReceived();
    public abstract virtual long get_RouterAdvertisementsSent();
    public abstract virtual long get_RouterSolicitsReceived();
    public abstract virtual long get_RouterSolicitsSent();
    public abstract virtual long get_TimeExceededMessagesReceived();
    public abstract virtual long get_TimeExceededMessagesSent();
}
internal enum System.Net.NetworkInformation.IcmpV6StatType : Enum {
    public int value__;
    public static IcmpV6StatType DestinationUnreachable;
    public static IcmpV6StatType PacketTooBig;
    public static IcmpV6StatType TimeExceeded;
    public static IcmpV6StatType ParameterProblem;
    public static IcmpV6StatType EchoRequest;
    public static IcmpV6StatType EchoReply;
    public static IcmpV6StatType MembershipQuery;
    public static IcmpV6StatType MembershipReport;
    public static IcmpV6StatType MembershipReduction;
    public static IcmpV6StatType RouterSolicit;
    public static IcmpV6StatType RouterAdvertisement;
    public static IcmpV6StatType NeighborSolict;
    public static IcmpV6StatType NeighborAdvertisement;
    public static IcmpV6StatType Redirect;
}
internal enum System.Net.NetworkInformation.InterfaceConnectionType : Enum {
    public int value__;
    public static InterfaceConnectionType Dedicated;
    public static InterfaceConnectionType Passive;
    public static InterfaceConnectionType Demand;
    public static InterfaceConnectionType Maximum;
}
internal enum System.Net.NetworkInformation.InterfaceTunnelType : Enum {
    public int value__;
    public static InterfaceTunnelType None;
    public static InterfaceTunnelType Other;
    public static InterfaceTunnelType Direct;
    public static InterfaceTunnelType SixToFour;
    public static InterfaceTunnelType Isatap;
    public static InterfaceTunnelType Teredo;
    public static InterfaceTunnelType IpHttps;
}
internal class System.Net.NetworkInformation.IpAdapterAddress : ValueType {
    internal UInt32 length;
    internal AdapterAddressFlags flags;
    internal IntPtr next;
    internal IpSocketAddress address;
    internal static IPAddressCollection MarshalIpAddressCollection(IntPtr ptr);
    internal static IPAddressInformationCollection MarshalIpAddressInformationCollection(IntPtr ptr);
}
internal class System.Net.NetworkInformation.IpAdapterAddresses : ValueType {
    internal static int MAX_ADAPTER_ADDRESS_LENGTH;
    internal UInt32 length;
    internal UInt32 index;
    internal IntPtr next;
    internal string AdapterName;
    internal IntPtr firstUnicastAddress;
    internal IntPtr firstAnycastAddress;
    internal IntPtr firstMulticastAddress;
    internal IntPtr firstDnsServerAddress;
    internal string dnsSuffix;
    internal string description;
    internal string friendlyName;
    internal Byte[] address;
    internal UInt32 addressLength;
    internal AdapterFlags flags;
    internal UInt32 mtu;
    internal NetworkInterfaceType type;
    internal OperationalStatus operStatus;
    internal UInt32 ipv6Index;
    internal UInt32[] zoneIndices;
    internal IntPtr firstPrefix;
    internal ulong transmitLinkSpeed;
    internal ulong receiveLinkSpeed;
    internal IntPtr firstWinsServerAddress;
    internal IntPtr firstGatewayAddress;
    internal UInt32 ipv4Metric;
    internal UInt32 ipv6Metric;
    internal ulong luid;
    internal IpSocketAddress dhcpv4Server;
    internal UInt32 compartmentId;
    internal Byte[] networkGuid;
    internal InterfaceConnectionType connectionType;
    internal InterfaceTunnelType tunnelType;
    internal IpSocketAddress dhcpv6Server;
    internal Byte[] dhcpv6ClientDuid;
    internal UInt32 dhcpv6ClientDuidLength;
    internal UInt32 dhcpV6Iaid;
}
internal class System.Net.NetworkInformation.IpAdapterUnicastAddress : ValueType {
    internal UInt32 length;
    internal AdapterAddressFlags flags;
    internal IntPtr next;
    internal IpSocketAddress address;
    internal PrefixOrigin prefixOrigin;
    internal SuffixOrigin suffixOrigin;
    internal DuplicateAddressDetectionState dadState;
    internal UInt32 validLifetime;
    internal UInt32 preferredLifetime;
    internal UInt32 leaseLifetime;
    internal byte prefixLength;
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddress Item { get; }
    public virtual void CopyTo(IPAddress[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(IPAddress address);
    internal void InternalAdd(IPAddress address);
    public virtual bool Contains(IPAddress address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<IPAddress> GetEnumerator();
    public virtual IPAddress get_Item(int index);
    public virtual bool Remove(IPAddress address);
    public virtual void Clear();
}
public abstract class System.Net.NetworkInformation.IPAddressInformation : object {
    public IPAddress Address { get; }
    public bool IsDnsEligible { get; }
    public bool IsTransient { get; }
    public abstract virtual IPAddress get_Address();
    public abstract virtual bool get_IsDnsEligible();
    public abstract virtual bool get_IsTransient();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddressInformation Item { get; }
    public virtual void CopyTo(IPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(IPAddressInformation address);
    internal void InternalAdd(IPAddressInformation address);
    public virtual bool Contains(IPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<IPAddressInformation> GetEnumerator();
    public virtual IPAddressInformation get_Item(int index);
    public virtual bool Remove(IPAddressInformation address);
    public virtual void Clear();
}
internal class System.Net.NetworkInformation.IpAddrString : ValueType {
    internal IntPtr Next;
    internal string IpAddress;
    internal string IpMask;
    internal UInt32 Context;
}
public abstract class System.Net.NetworkInformation.IPGlobalProperties : object {
    public string DhcpScopeName { get; }
    public string DomainName { get; }
    public string HostName { get; }
    public bool IsWinsProxy { get; }
    public NetBiosNodeType NodeType { get; }
    public static IPGlobalProperties GetIPGlobalProperties();
    internal static IPGlobalProperties InternalGetIPGlobalProperties();
    public abstract virtual IPEndPoint[] GetActiveUdpListeners();
    public abstract virtual IPEndPoint[] GetActiveTcpListeners();
    public abstract virtual TcpConnectionInformation[] GetActiveTcpConnections();
    public abstract virtual string get_DhcpScopeName();
    public abstract virtual string get_DomainName();
    public abstract virtual string get_HostName();
    public abstract virtual bool get_IsWinsProxy();
    public abstract virtual NetBiosNodeType get_NodeType();
    public abstract virtual TcpStatistics GetTcpIPv4Statistics();
    public abstract virtual TcpStatistics GetTcpIPv6Statistics();
    public abstract virtual UdpStatistics GetUdpIPv4Statistics();
    public abstract virtual UdpStatistics GetUdpIPv6Statistics();
    public abstract virtual IcmpV4Statistics GetIcmpV4Statistics();
    public abstract virtual IcmpV6Statistics GetIcmpV6Statistics();
    public abstract virtual IPGlobalStatistics GetIPv4GlobalStatistics();
    public abstract virtual IPGlobalStatistics GetIPv6GlobalStatistics();
    public virtual UnicastIPAddressInformationCollection GetUnicastAddresses();
    public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state);
    public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult);
    public virtual Task`1<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync();
}
public abstract class System.Net.NetworkInformation.IPGlobalStatistics : object {
    public int DefaultTtl { get; }
    public bool ForwardingEnabled { get; }
    public int NumberOfInterfaces { get; }
    public int NumberOfIPAddresses { get; }
    public long OutputPacketRequests { get; }
    public long OutputPacketRoutingDiscards { get; }
    public long OutputPacketsDiscarded { get; }
    public long OutputPacketsWithNoRoute { get; }
    public long PacketFragmentFailures { get; }
    public long PacketReassembliesRequired { get; }
    public long PacketReassemblyFailures { get; }
    public long PacketReassemblyTimeout { get; }
    public long PacketsFragmented { get; }
    public long PacketsReassembled { get; }
    public long ReceivedPackets { get; }
    public long ReceivedPacketsDelivered { get; }
    public long ReceivedPacketsDiscarded { get; }
    public long ReceivedPacketsForwarded { get; }
    public long ReceivedPacketsWithAddressErrors { get; }
    public long ReceivedPacketsWithHeadersErrors { get; }
    public long ReceivedPacketsWithUnknownProtocol { get; }
    public int NumberOfRoutes { get; }
    public abstract virtual int get_DefaultTtl();
    public abstract virtual bool get_ForwardingEnabled();
    public abstract virtual int get_NumberOfInterfaces();
    public abstract virtual int get_NumberOfIPAddresses();
    public abstract virtual long get_OutputPacketRequests();
    public abstract virtual long get_OutputPacketRoutingDiscards();
    public abstract virtual long get_OutputPacketsDiscarded();
    public abstract virtual long get_OutputPacketsWithNoRoute();
    public abstract virtual long get_PacketFragmentFailures();
    public abstract virtual long get_PacketReassembliesRequired();
    public abstract virtual long get_PacketReassemblyFailures();
    public abstract virtual long get_PacketReassemblyTimeout();
    public abstract virtual long get_PacketsFragmented();
    public abstract virtual long get_PacketsReassembled();
    public abstract virtual long get_ReceivedPackets();
    public abstract virtual long get_ReceivedPacketsDelivered();
    public abstract virtual long get_ReceivedPacketsDiscarded();
    public abstract virtual long get_ReceivedPacketsForwarded();
    public abstract virtual long get_ReceivedPacketsWithAddressErrors();
    public abstract virtual long get_ReceivedPacketsWithHeadersErrors();
    public abstract virtual long get_ReceivedPacketsWithUnknownProtocol();
    public abstract virtual int get_NumberOfRoutes();
}
internal class System.Net.NetworkInformation.IpHelperErrors : object {
    internal static UInt32 Success;
    internal static UInt32 ErrorInvalidFunction;
    internal static UInt32 ErrorNoSuchDevice;
    internal static UInt32 ErrorInvalidData;
    internal static UInt32 ErrorInvalidParameter;
    internal static UInt32 ErrorBufferOverflow;
    internal static UInt32 ErrorInsufficientBuffer;
    internal static UInt32 ErrorNoData;
    internal static UInt32 Pending;
    internal static UInt32 ErrorNotFound;
}
public abstract class System.Net.NetworkInformation.IPInterfaceProperties : object {
    public bool IsDnsEnabled { get; }
    public string DnsSuffix { get; }
    public bool IsDynamicDnsEnabled { get; }
    public UnicastIPAddressInformationCollection UnicastAddresses { get; }
    public MulticastIPAddressInformationCollection MulticastAddresses { get; }
    public IPAddressInformationCollection AnycastAddresses { get; }
    public IPAddressCollection DnsAddresses { get; }
    public GatewayIPAddressInformationCollection GatewayAddresses { get; }
    public IPAddressCollection DhcpServerAddresses { get; }
    public IPAddressCollection WinsServersAddresses { get; }
    public abstract virtual bool get_IsDnsEnabled();
    public abstract virtual string get_DnsSuffix();
    public abstract virtual bool get_IsDynamicDnsEnabled();
    public abstract virtual UnicastIPAddressInformationCollection get_UnicastAddresses();
    public abstract virtual MulticastIPAddressInformationCollection get_MulticastAddresses();
    public abstract virtual IPAddressInformationCollection get_AnycastAddresses();
    public abstract virtual IPAddressCollection get_DnsAddresses();
    public abstract virtual GatewayIPAddressInformationCollection get_GatewayAddresses();
    public abstract virtual IPAddressCollection get_DhcpServerAddresses();
    public abstract virtual IPAddressCollection get_WinsServersAddresses();
    public abstract virtual IPv4InterfaceProperties GetIPv4Properties();
    public abstract virtual IPv6InterfaceProperties GetIPv6Properties();
}
public abstract class System.Net.NetworkInformation.IPInterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
internal class System.Net.NetworkInformation.IPOptions : ValueType {
    internal byte ttl;
    internal byte tos;
    internal byte flags;
    internal byte optionsSize;
    internal IntPtr optionsData;
    internal IPOptions(PingOptions options);
}
internal class System.Net.NetworkInformation.IpPerAdapterInfo : ValueType {
    internal bool autoconfigEnabled;
    internal bool autoconfigActive;
    internal IntPtr currentDnsServer;
    internal IpAddrString dnsServerList;
}
internal class System.Net.NetworkInformation.IpSocketAddress : ValueType {
    internal IntPtr address;
    internal int addressLength;
    internal IPAddress MarshalIPAddress();
}
public enum System.Net.NetworkInformation.IPStatus : Enum {
    public int value__;
    public static IPStatus Success;
    public static IPStatus DestinationNetworkUnreachable;
    public static IPStatus DestinationHostUnreachable;
    public static IPStatus DestinationProtocolUnreachable;
    public static IPStatus DestinationPortUnreachable;
    public static IPStatus DestinationProhibited;
    public static IPStatus NoResources;
    public static IPStatus BadOption;
    public static IPStatus HardwareError;
    public static IPStatus PacketTooBig;
    public static IPStatus TimedOut;
    public static IPStatus BadRoute;
    public static IPStatus TtlExpired;
    public static IPStatus TtlReassemblyTimeExceeded;
    public static IPStatus ParameterProblem;
    public static IPStatus SourceQuench;
    public static IPStatus BadDestination;
    public static IPStatus DestinationUnreachable;
    public static IPStatus TimeExceeded;
    public static IPStatus BadHeader;
    public static IPStatus UnrecognizedNextHeader;
    public static IPStatus IcmpError;
    public static IPStatus DestinationScopeMismatch;
    public static IPStatus Unknown;
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceProperties : object {
    public bool UsesWins { get; }
    public bool IsDhcpEnabled { get; }
    public bool IsAutomaticPrivateAddressingActive { get; }
    public bool IsAutomaticPrivateAddressingEnabled { get; }
    public int Index { get; }
    public bool IsForwardingEnabled { get; }
    public int Mtu { get; }
    public abstract virtual bool get_UsesWins();
    public abstract virtual bool get_IsDhcpEnabled();
    public abstract virtual bool get_IsAutomaticPrivateAddressingActive();
    public abstract virtual bool get_IsAutomaticPrivateAddressingEnabled();
    public abstract virtual int get_Index();
    public abstract virtual bool get_IsForwardingEnabled();
    public abstract virtual int get_Mtu();
}
public abstract class System.Net.NetworkInformation.IPv4InterfaceStatistics : object {
    public long BytesReceived { get; }
    public long BytesSent { get; }
    public long IncomingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    public long NonUnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long OutputQueueLength { get; }
    public long UnicastPacketsReceived { get; }
    public long UnicastPacketsSent { get; }
    public abstract virtual long get_BytesReceived();
    public abstract virtual long get_BytesSent();
    public abstract virtual long get_IncomingPacketsDiscarded();
    public abstract virtual long get_IncomingPacketsWithErrors();
    public abstract virtual long get_IncomingUnknownProtocolPackets();
    public abstract virtual long get_NonUnicastPacketsReceived();
    public abstract virtual long get_NonUnicastPacketsSent();
    public abstract virtual long get_OutgoingPacketsDiscarded();
    public abstract virtual long get_OutgoingPacketsWithErrors();
    public abstract virtual long get_OutputQueueLength();
    public abstract virtual long get_UnicastPacketsReceived();
    public abstract virtual long get_UnicastPacketsSent();
}
internal class System.Net.NetworkInformation.Ipv6Address : ValueType {
    internal Byte[] Goo;
    internal Byte[] Address;
    internal UInt32 ScopeID;
}
public abstract class System.Net.NetworkInformation.IPv6InterfaceProperties : object {
    public int Index { get; }
    public int Mtu { get; }
    public abstract virtual int get_Index();
    public abstract virtual int get_Mtu();
    public virtual long GetScopeId(ScopeLevel scopeLevel);
}
internal class System.Net.NetworkInformation.MibIcmpInfo : ValueType {
    internal MibIcmpStats inStats;
    internal MibIcmpStats outStats;
}
internal class System.Net.NetworkInformation.MibIcmpInfoEx : ValueType {
    internal MibIcmpStatsEx inStats;
    internal MibIcmpStatsEx outStats;
}
internal class System.Net.NetworkInformation.MibIcmpStats : ValueType {
    internal UInt32 messages;
    internal UInt32 errors;
    internal UInt32 destinationUnreachables;
    internal UInt32 timeExceeds;
    internal UInt32 parameterProblems;
    internal UInt32 sourceQuenches;
    internal UInt32 redirects;
    internal UInt32 echoRequests;
    internal UInt32 echoReplies;
    internal UInt32 timestampRequests;
    internal UInt32 timestampReplies;
    internal UInt32 addressMaskRequests;
    internal UInt32 addressMaskReplies;
}
internal class System.Net.NetworkInformation.MibIcmpStatsEx : ValueType {
    internal UInt32 dwMsgs;
    internal UInt32 dwErrors;
    internal UInt32[] rgdwTypeCount;
}
internal class System.Net.NetworkInformation.MibIfRow2 : ValueType {
    private static int GuidLength;
    private static int IfMaxStringSize;
    private static int IfMaxPhysAddressLength;
    internal ulong interfaceLuid;
    internal UInt32 interfaceIndex;
    internal Byte[] interfaceGuid;
    internal Char[] alias;
    internal Char[] description;
    internal UInt32 physicalAddressLength;
    internal Byte[] physicalAddress;
    internal Byte[] permanentPhysicalAddress;
    internal UInt32 mtu;
    internal NetworkInterfaceType type;
    internal InterfaceTunnelType tunnelType;
    internal UInt32 mediaType;
    internal UInt32 physicalMediumType;
    internal UInt32 accessType;
    internal UInt32 directionType;
    internal byte interfaceAndOperStatusFlags;
    internal OperationalStatus operStatus;
    internal UInt32 adminStatus;
    internal UInt32 mediaConnectState;
    internal Byte[] networkGuid;
    internal InterfaceConnectionType connectionType;
    internal ulong transmitLinkSpeed;
    internal ulong receiveLinkSpeed;
    internal ulong inOctets;
    internal ulong inUcastPkts;
    internal ulong inNUcastPkts;
    internal ulong inDiscards;
    internal ulong inErrors;
    internal ulong inUnknownProtos;
    internal ulong inUcastOctets;
    internal ulong inMulticastOctets;
    internal ulong inBroadcastOctets;
    internal ulong outOctets;
    internal ulong outUcastPkts;
    internal ulong outNUcastPkts;
    internal ulong outDiscards;
    internal ulong outErrors;
    internal ulong outUcastOctets;
    internal ulong outMulticastOctets;
    internal ulong outBroadcastOctets;
    internal ulong outQLen;
}
internal class System.Net.NetworkInformation.MibIpStats : ValueType {
    internal bool forwardingEnabled;
    internal UInt32 defaultTtl;
    internal UInt32 packetsReceived;
    internal UInt32 receivedPacketsWithHeaderErrors;
    internal UInt32 receivedPacketsWithAddressErrors;
    internal UInt32 packetsForwarded;
    internal UInt32 receivedPacketsWithUnknownProtocols;
    internal UInt32 receivedPacketsDiscarded;
    internal UInt32 receivedPacketsDelivered;
    internal UInt32 packetOutputRequests;
    internal UInt32 outputPacketRoutingDiscards;
    internal UInt32 outputPacketsDiscarded;
    internal UInt32 outputPacketsWithNoRoute;
    internal UInt32 packetReassemblyTimeout;
    internal UInt32 packetsReassemblyRequired;
    internal UInt32 packetsReassembled;
    internal UInt32 packetsReassemblyFailed;
    internal UInt32 packetsFragmented;
    internal UInt32 packetsFragmentFailed;
    internal UInt32 packetsFragmentCreated;
    internal UInt32 interfaces;
    internal UInt32 ipAddresses;
    internal UInt32 routes;
}
internal class System.Net.NetworkInformation.MibTcp6RowOwnerPid : ValueType {
    internal Byte[] localAddr;
    internal UInt32 localScopeId;
    internal byte localPort1;
    internal byte localPort2;
    internal byte ignoreLocalPort3;
    internal byte ignoreLocalPort4;
    internal Byte[] remoteAddr;
    internal UInt32 remoteScopeId;
    internal byte remotePort1;
    internal byte remotePort2;
    internal byte ignoreRemotePort3;
    internal byte ignoreRemotePort4;
    internal TcpState state;
    internal UInt32 owningPid;
}
internal class System.Net.NetworkInformation.MibTcp6TableOwnerPid : ValueType {
    internal UInt32 numberOfEntries;
}
internal class System.Net.NetworkInformation.MibTcpRow : ValueType {
    internal TcpState state;
    internal UInt32 localAddr;
    internal byte localPort1;
    internal byte localPort2;
    internal byte ignoreLocalPort3;
    internal byte ignoreLocalPort4;
    internal UInt32 remoteAddr;
    internal byte remotePort1;
    internal byte remotePort2;
    internal byte ignoreRemotePort3;
    internal byte ignoreRemotePort4;
}
internal class System.Net.NetworkInformation.MibTcpStats : ValueType {
    internal UInt32 reTransmissionAlgorithm;
    internal UInt32 minimumRetransmissionTimeOut;
    internal UInt32 maximumRetransmissionTimeOut;
    internal UInt32 maximumConnections;
    internal UInt32 activeOpens;
    internal UInt32 passiveOpens;
    internal UInt32 failedConnectionAttempts;
    internal UInt32 resetConnections;
    internal UInt32 currentConnections;
    internal UInt32 segmentsReceived;
    internal UInt32 segmentsSent;
    internal UInt32 segmentsResent;
    internal UInt32 errorsReceived;
    internal UInt32 segmentsSentWithReset;
    internal UInt32 cumulativeConnections;
}
internal class System.Net.NetworkInformation.MibTcpTable : ValueType {
    internal UInt32 numberOfEntries;
}
internal class System.Net.NetworkInformation.MibUdp6RowOwnerPid : ValueType {
    internal Byte[] localAddr;
    internal UInt32 localScopeId;
    internal byte localPort1;
    internal byte localPort2;
    internal byte ignoreLocalPort3;
    internal byte ignoreLocalPort4;
    internal UInt32 owningPid;
}
internal class System.Net.NetworkInformation.MibUdp6TableOwnerPid : ValueType {
    internal UInt32 numberOfEntries;
}
internal class System.Net.NetworkInformation.MibUdpRow : ValueType {
    internal UInt32 localAddr;
    internal byte localPort1;
    internal byte localPort2;
    internal byte ignoreLocalPort3;
    internal byte ignoreLocalPort4;
}
internal class System.Net.NetworkInformation.MibUdpStats : ValueType {
    internal UInt32 datagramsReceived;
    internal UInt32 incomingDatagramsDiscarded;
    internal UInt32 incomingDatagramsWithErrors;
    internal UInt32 datagramsSent;
    internal UInt32 udpListeners;
}
internal class System.Net.NetworkInformation.MibUdpTable : ValueType {
    internal UInt32 numberOfEntries;
}
public abstract class System.Net.NetworkInformation.MulticastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.MulticastIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MulticastIPAddressInformation Item { get; }
    public virtual void CopyTo(MulticastIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(MulticastIPAddressInformation address);
    internal void InternalAdd(MulticastIPAddressInformation address);
    public virtual bool Contains(MulticastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<MulticastIPAddressInformation> GetEnumerator();
    public virtual MulticastIPAddressInformation get_Item(int index);
    public virtual bool Remove(MulticastIPAddressInformation address);
    public virtual void Clear();
}
public enum System.Net.NetworkInformation.NetBiosNodeType : Enum {
    public int value__;
    public static NetBiosNodeType Unknown;
    public static NetBiosNodeType Broadcast;
    public static NetBiosNodeType Peer2Peer;
    public static NetBiosNodeType Mixed;
    public static NetBiosNodeType Hybrid;
}
public class System.Net.NetworkInformation.NetworkAddressChangedEventHandler : MulticastDelegate {
    public NetworkAddressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityChangedEventHandler : MulticastDelegate {
    public NetworkAvailabilityChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NetworkAvailabilityEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NetworkAvailabilityEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.NetworkAvailabilityEventArgs : EventArgs {
    public bool IsAvailable { get; }
    internal NetworkAvailabilityEventArgs(bool isAvailable);
    public bool get_IsAvailable();
}
public class System.Net.NetworkInformation.NetworkChange : object {
    internal static bool CanListenForNetworkChanges { get; }
    private static NetworkChange();
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterNetworkChange(NetworkChange nc);
    public static void add_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public static void remove_NetworkAvailabilityChanged(NetworkAvailabilityChangedEventHandler value);
    public static void add_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    public static void remove_NetworkAddressChanged(NetworkAddressChangedEventHandler value);
    internal static bool get_CanListenForNetworkChanges();
}
[FlagsAttribute]
public enum System.Net.NetworkInformation.NetworkInformationAccess : Enum {
    public int value__;
    public static NetworkInformationAccess None;
    public static NetworkInformationAccess Read;
    public static NetworkInformationAccess Ping;
}
public class System.Net.NetworkInformation.NetworkInformationException : Win32Exception {
    public int ErrorCode { get; }
    public NetworkInformationException(int errorCode);
    internal NetworkInformationException(SocketError socketError);
    protected NetworkInformationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.NetworkInformation.NetworkInformationPermission : CodeAccessPermission {
    public NetworkInformationAccess Access { get; }
    public NetworkInformationPermission(PermissionState state);
    internal NetworkInformationPermission(bool unrestricted);
    public NetworkInformationPermission(NetworkInformationAccess access);
    public NetworkInformationAccess get_Access();
    public void AddPermission(NetworkInformationAccess access);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.NetworkInformation.NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
    public string Access { get; public set; }
    public NetworkInformationPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public virtual IPermission CreatePermission();
}
public abstract class System.Net.NetworkInformation.NetworkInterface : object {
    public static int LoopbackInterfaceIndex { get; }
    public static int IPv6LoopbackInterfaceIndex { get; }
    public string Id { get; }
    public string Name { get; }
    public string Description { get; }
    public OperationalStatus OperationalStatus { get; }
    public long Speed { get; }
    public bool IsReceiveOnly { get; }
    public bool SupportsMulticast { get; }
    public NetworkInterfaceType NetworkInterfaceType { get; }
    public static NetworkInterface[] GetAllNetworkInterfaces();
    public static bool GetIsNetworkAvailable();
    public static int get_LoopbackInterfaceIndex();
    public static int get_IPv6LoopbackInterfaceIndex();
    public virtual string get_Id();
    public virtual string get_Name();
    public virtual string get_Description();
    public virtual IPInterfaceProperties GetIPProperties();
    public virtual IPv4InterfaceStatistics GetIPv4Statistics();
    public virtual IPInterfaceStatistics GetIPStatistics();
    public virtual OperationalStatus get_OperationalStatus();
    public virtual long get_Speed();
    public virtual bool get_IsReceiveOnly();
    public virtual bool get_SupportsMulticast();
    public virtual PhysicalAddress GetPhysicalAddress();
    public virtual NetworkInterfaceType get_NetworkInterfaceType();
    public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
}
public enum System.Net.NetworkInformation.NetworkInterfaceComponent : Enum {
    public int value__;
    public static NetworkInterfaceComponent IPv4;
    public static NetworkInterfaceComponent IPv6;
}
public enum System.Net.NetworkInformation.NetworkInterfaceType : Enum {
    public int value__;
    public static NetworkInterfaceType Unknown;
    public static NetworkInterfaceType Ethernet;
    public static NetworkInterfaceType TokenRing;
    public static NetworkInterfaceType Fddi;
    public static NetworkInterfaceType BasicIsdn;
    public static NetworkInterfaceType PrimaryIsdn;
    public static NetworkInterfaceType Ppp;
    public static NetworkInterfaceType Loopback;
    public static NetworkInterfaceType Ethernet3Megabit;
    public static NetworkInterfaceType Slip;
    public static NetworkInterfaceType Atm;
    public static NetworkInterfaceType GenericModem;
    public static NetworkInterfaceType FastEthernetT;
    public static NetworkInterfaceType Isdn;
    public static NetworkInterfaceType FastEthernetFx;
    public static NetworkInterfaceType Wireless80211;
    public static NetworkInterfaceType AsymmetricDsl;
    public static NetworkInterfaceType RateAdaptDsl;
    public static NetworkInterfaceType SymmetricDsl;
    public static NetworkInterfaceType VeryHighSpeedDsl;
    public static NetworkInterfaceType IPOverAtm;
    public static NetworkInterfaceType GigabitEthernet;
    public static NetworkInterfaceType Tunnel;
    public static NetworkInterfaceType MultiRateSymmetricDsl;
    public static NetworkInterfaceType HighPerformanceSerialBus;
    public static NetworkInterfaceType Wman;
    public static NetworkInterfaceType Wwanpp;
    public static NetworkInterfaceType Wwanpp2;
}
internal enum System.Net.NetworkInformation.OldOperationalStatus : Enum {
    public int value__;
    public static OldOperationalStatus NonOperational;
    public static OldOperationalStatus Unreachable;
    public static OldOperationalStatus Disconnected;
    public static OldOperationalStatus Connecting;
    public static OldOperationalStatus Connected;
    public static OldOperationalStatus Operational;
}
public enum System.Net.NetworkInformation.OperationalStatus : Enum {
    public int value__;
    public static OperationalStatus Up;
    public static OperationalStatus Down;
    public static OperationalStatus Testing;
    public static OperationalStatus Unknown;
    public static OperationalStatus Dormant;
    public static OperationalStatus NotPresent;
    public static OperationalStatus LowerLayerDown;
}
public class System.Net.NetworkInformation.PhysicalAddress : object {
    public static PhysicalAddress None;
    public PhysicalAddress(Byte[] address);
    private static PhysicalAddress();
    public virtual int GetHashCode();
    public virtual bool Equals(object comparand);
    public virtual string ToString();
    public Byte[] GetAddressBytes();
    public static PhysicalAddress Parse(string address);
}
public class System.Net.NetworkInformation.Ping : Component {
    internal ManualResetEvent pingEvent;
    [CompilerGeneratedAttribute]
public void add_PingCompleted(PingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PingCompleted(PingCompletedEventHandler value);
    protected void OnPingCompleted(PingCompletedEventArgs e);
    protected virtual void Dispose(bool disposing);
    public void SendAsyncCancel();
    public PingReply Send(string hostNameOrAddress);
    public PingReply Send(string hostNameOrAddress, int timeout);
    public PingReply Send(IPAddress address);
    public PingReply Send(IPAddress address, int timeout);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer);
    public PingReply Send(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
    public PingReply Send(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    public void SendAsync(string hostNameOrAddress, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, object userToken);
    public void SendAsync(IPAddress address, object userToken);
    public void SendAsync(IPAddress address, int timeout, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, object userToken);
    public void SendAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public void SendAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options, object userToken);
    public Task`1<PingReply> SendPingAsync(IPAddress address);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer);
    public Task`1<PingReply> SendPingAsync(IPAddress address, int timeout, Byte[] buffer, PingOptions options);
    public Task`1<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, Byte[] buffer, PingOptions options);
}
public class System.Net.NetworkInformation.PingCompletedEventArgs : AsyncCompletedEventArgs {
    public PingReply Reply { get; }
    internal PingCompletedEventArgs(PingReply reply, Exception error, bool cancelled, object userToken);
    public PingReply get_Reply();
}
public class System.Net.NetworkInformation.PingCompletedEventHandler : MulticastDelegate {
    public PingCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PingCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PingCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.NetworkInformation.PingException : InvalidOperationException {
    protected PingException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public PingException(string message);
    public PingException(string message, Exception innerException);
}
public class System.Net.NetworkInformation.PingOptions : object {
    public int Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    internal PingOptions(IPOptions options);
    public PingOptions(int ttl, bool dontFragment);
    public int get_Ttl();
    public void set_Ttl(int value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
}
public class System.Net.NetworkInformation.PingReply : object {
    public IPStatus Status { get; }
    public IPAddress Address { get; }
    public long RoundtripTime { get; }
    public PingOptions Options { get; }
    public Byte[] Buffer { get; }
    internal PingReply(IPStatus ipStatus);
    internal PingReply(Byte[] data, int dataLength, IPAddress address, int time);
    internal PingReply(IcmpEchoReply reply);
    internal PingReply(Icmp6EchoReply reply, IntPtr dataPtr, int sendSize);
    public IPStatus get_Status();
    public IPAddress get_Address();
    public long get_RoundtripTime();
    public PingOptions get_Options();
    public Byte[] get_Buffer();
}
public enum System.Net.NetworkInformation.PrefixOrigin : Enum {
    public int value__;
    public static PrefixOrigin Other;
    public static PrefixOrigin Manual;
    public static PrefixOrigin WellKnown;
    public static PrefixOrigin Dhcp;
    public static PrefixOrigin RouterAdvertisement;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.NetworkInformation.SafeCancelMibChangeNotify : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.NetworkInformation.SafeFreeMibTable : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public enum System.Net.NetworkInformation.ScopeLevel : Enum {
    public int value__;
    public static ScopeLevel None;
    public static ScopeLevel Interface;
    public static ScopeLevel Link;
    public static ScopeLevel Subnet;
    public static ScopeLevel Admin;
    public static ScopeLevel Site;
    public static ScopeLevel Organization;
    public static ScopeLevel Global;
}
internal class System.Net.NetworkInformation.StableUnicastIpAddressTableDelegate : MulticastDelegate {
    public StableUnicastIpAddressTableDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr context, IntPtr table);
    public virtual IAsyncResult BeginInvoke(IntPtr context, IntPtr table, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.StartIPOptions : Enum {
    public int value__;
    public static StartIPOptions Both;
    public static StartIPOptions None;
    public static StartIPOptions StartIPv4;
    public static StartIPOptions StartIPv6;
}
public enum System.Net.NetworkInformation.SuffixOrigin : Enum {
    public int value__;
    public static SuffixOrigin Other;
    public static SuffixOrigin Manual;
    public static SuffixOrigin WellKnown;
    public static SuffixOrigin OriginDhcp;
    public static SuffixOrigin LinkLayerAddress;
    public static SuffixOrigin Random;
}
internal class System.Net.NetworkInformation.SystemGatewayIPAddressInformation : GatewayIPAddressInformation {
    public IPAddress Address { get; }
    public virtual IPAddress get_Address();
    internal static GatewayIPAddressInformationCollection ToGatewayIpAddressInformationCollection(IPAddressCollection addresses);
}
internal class System.Net.NetworkInformation.SystemIcmpV4Statistics : IcmpV4Statistics {
    public long MessagesSent { get; }
    public long MessagesReceived { get; }
    public long ErrorsSent { get; }
    public long ErrorsReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long ParameterProblemsSent { get; }
    public long ParameterProblemsReceived { get; }
    public long SourceQuenchesSent { get; }
    public long SourceQuenchesReceived { get; }
    public long RedirectsSent { get; }
    public long RedirectsReceived { get; }
    public long EchoRequestsSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRepliesReceived { get; }
    public long TimestampRequestsSent { get; }
    public long TimestampRequestsReceived { get; }
    public long TimestampRepliesSent { get; }
    public long TimestampRepliesReceived { get; }
    public long AddressMaskRequestsSent { get; }
    public long AddressMaskRequestsReceived { get; }
    public long AddressMaskRepliesSent { get; }
    public long AddressMaskRepliesReceived { get; }
    public virtual long get_MessagesSent();
    public virtual long get_MessagesReceived();
    public virtual long get_ErrorsSent();
    public virtual long get_ErrorsReceived();
    public virtual long get_DestinationUnreachableMessagesSent();
    public virtual long get_DestinationUnreachableMessagesReceived();
    public virtual long get_TimeExceededMessagesSent();
    public virtual long get_TimeExceededMessagesReceived();
    public virtual long get_ParameterProblemsSent();
    public virtual long get_ParameterProblemsReceived();
    public virtual long get_SourceQuenchesSent();
    public virtual long get_SourceQuenchesReceived();
    public virtual long get_RedirectsSent();
    public virtual long get_RedirectsReceived();
    public virtual long get_EchoRequestsSent();
    public virtual long get_EchoRequestsReceived();
    public virtual long get_EchoRepliesSent();
    public virtual long get_EchoRepliesReceived();
    public virtual long get_TimestampRequestsSent();
    public virtual long get_TimestampRequestsReceived();
    public virtual long get_TimestampRepliesSent();
    public virtual long get_TimestampRepliesReceived();
    public virtual long get_AddressMaskRequestsSent();
    public virtual long get_AddressMaskRequestsReceived();
    public virtual long get_AddressMaskRepliesSent();
    public virtual long get_AddressMaskRepliesReceived();
}
internal class System.Net.NetworkInformation.SystemIcmpV6Statistics : IcmpV6Statistics {
    public long MessagesSent { get; }
    public long MessagesReceived { get; }
    public long ErrorsSent { get; }
    public long ErrorsReceived { get; }
    public long DestinationUnreachableMessagesSent { get; }
    public long DestinationUnreachableMessagesReceived { get; }
    public long PacketTooBigMessagesSent { get; }
    public long PacketTooBigMessagesReceived { get; }
    public long TimeExceededMessagesSent { get; }
    public long TimeExceededMessagesReceived { get; }
    public long ParameterProblemsSent { get; }
    public long ParameterProblemsReceived { get; }
    public long EchoRequestsSent { get; }
    public long EchoRequestsReceived { get; }
    public long EchoRepliesSent { get; }
    public long EchoRepliesReceived { get; }
    public long MembershipQueriesSent { get; }
    public long MembershipQueriesReceived { get; }
    public long MembershipReportsSent { get; }
    public long MembershipReportsReceived { get; }
    public long MembershipReductionsSent { get; }
    public long MembershipReductionsReceived { get; }
    public long RouterAdvertisementsSent { get; }
    public long RouterAdvertisementsReceived { get; }
    public long RouterSolicitsSent { get; }
    public long RouterSolicitsReceived { get; }
    public long NeighborAdvertisementsSent { get; }
    public long NeighborAdvertisementsReceived { get; }
    public long NeighborSolicitsSent { get; }
    public long NeighborSolicitsReceived { get; }
    public long RedirectsSent { get; }
    public long RedirectsReceived { get; }
    public virtual long get_MessagesSent();
    public virtual long get_MessagesReceived();
    public virtual long get_ErrorsSent();
    public virtual long get_ErrorsReceived();
    public virtual long get_DestinationUnreachableMessagesSent();
    public virtual long get_DestinationUnreachableMessagesReceived();
    public virtual long get_PacketTooBigMessagesSent();
    public virtual long get_PacketTooBigMessagesReceived();
    public virtual long get_TimeExceededMessagesSent();
    public virtual long get_TimeExceededMessagesReceived();
    public virtual long get_ParameterProblemsSent();
    public virtual long get_ParameterProblemsReceived();
    public virtual long get_EchoRequestsSent();
    public virtual long get_EchoRequestsReceived();
    public virtual long get_EchoRepliesSent();
    public virtual long get_EchoRepliesReceived();
    public virtual long get_MembershipQueriesSent();
    public virtual long get_MembershipQueriesReceived();
    public virtual long get_MembershipReportsSent();
    public virtual long get_MembershipReportsReceived();
    public virtual long get_MembershipReductionsSent();
    public virtual long get_MembershipReductionsReceived();
    public virtual long get_RouterAdvertisementsSent();
    public virtual long get_RouterAdvertisementsReceived();
    public virtual long get_RouterSolicitsSent();
    public virtual long get_RouterSolicitsReceived();
    public virtual long get_NeighborAdvertisementsSent();
    public virtual long get_NeighborAdvertisementsReceived();
    public virtual long get_NeighborSolicitsSent();
    public virtual long get_NeighborSolicitsReceived();
    public virtual long get_RedirectsSent();
    public virtual long get_RedirectsReceived();
}
internal class System.Net.NetworkInformation.SystemIPAddressInformation : IPAddressInformation {
    internal bool transient;
    internal bool dnsEligible;
    public IPAddress Address { get; }
    public bool IsTransient { get; }
    public bool IsDnsEligible { get; }
    internal SystemIPAddressInformation(IPAddress address, AdapterAddressFlags flags);
    public virtual IPAddress get_Address();
    public virtual bool get_IsTransient();
    public virtual bool get_IsDnsEligible();
}
internal class System.Net.NetworkInformation.SystemIPGlobalProperties : IPGlobalProperties {
    internal FixedInfo FixedInfo { get; }
    public string HostName { get; }
    public string DomainName { get; }
    public NetBiosNodeType NodeType { get; }
    public string DhcpScopeName { get; }
    public bool IsWinsProxy { get; }
    private static SystemIPGlobalProperties();
    internal static FixedInfo GetFixedInfo();
    internal FixedInfo get_FixedInfo();
    public virtual string get_HostName();
    public virtual string get_DomainName();
    public virtual NetBiosNodeType get_NodeType();
    public virtual string get_DhcpScopeName();
    public virtual bool get_IsWinsProxy();
    public virtual TcpConnectionInformation[] GetActiveTcpConnections();
    public virtual IPEndPoint[] GetActiveTcpListeners();
    public virtual IPEndPoint[] GetActiveUdpListeners();
    public virtual IPGlobalStatistics GetIPv4GlobalStatistics();
    public virtual IPGlobalStatistics GetIPv6GlobalStatistics();
    public virtual TcpStatistics GetTcpIPv4Statistics();
    public virtual TcpStatistics GetTcpIPv6Statistics();
    public virtual UdpStatistics GetUdpIPv4Statistics();
    public virtual UdpStatistics GetUdpIPv6Statistics();
    public virtual IcmpV4Statistics GetIcmpV4Statistics();
    public virtual IcmpV6Statistics GetIcmpV6Statistics();
    public virtual UnicastIPAddressInformationCollection GetUnicastAddresses();
    public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback callback, object state);
    public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult);
}
internal class System.Net.NetworkInformation.SystemIPGlobalStatistics : IPGlobalStatistics {
    public bool ForwardingEnabled { get; }
    public int DefaultTtl { get; }
    public long ReceivedPackets { get; }
    public long ReceivedPacketsWithHeadersErrors { get; }
    public long ReceivedPacketsWithAddressErrors { get; }
    public long ReceivedPacketsForwarded { get; }
    public long ReceivedPacketsWithUnknownProtocol { get; }
    public long ReceivedPacketsDiscarded { get; }
    public long ReceivedPacketsDelivered { get; }
    public long OutputPacketRequests { get; }
    public long OutputPacketRoutingDiscards { get; }
    public long OutputPacketsDiscarded { get; }
    public long OutputPacketsWithNoRoute { get; }
    public long PacketReassemblyTimeout { get; }
    public long PacketReassembliesRequired { get; }
    public long PacketsReassembled { get; }
    public long PacketReassemblyFailures { get; }
    public long PacketsFragmented { get; }
    public long PacketFragmentFailures { get; }
    public int NumberOfInterfaces { get; }
    public int NumberOfIPAddresses { get; }
    public int NumberOfRoutes { get; }
    internal SystemIPGlobalStatistics(AddressFamily family);
    public virtual bool get_ForwardingEnabled();
    public virtual int get_DefaultTtl();
    public virtual long get_ReceivedPackets();
    public virtual long get_ReceivedPacketsWithHeadersErrors();
    public virtual long get_ReceivedPacketsWithAddressErrors();
    public virtual long get_ReceivedPacketsForwarded();
    public virtual long get_ReceivedPacketsWithUnknownProtocol();
    public virtual long get_ReceivedPacketsDiscarded();
    public virtual long get_ReceivedPacketsDelivered();
    public virtual long get_OutputPacketRequests();
    public virtual long get_OutputPacketRoutingDiscards();
    public virtual long get_OutputPacketsDiscarded();
    public virtual long get_OutputPacketsWithNoRoute();
    public virtual long get_PacketReassemblyTimeout();
    public virtual long get_PacketReassembliesRequired();
    public virtual long get_PacketsReassembled();
    public virtual long get_PacketReassemblyFailures();
    public virtual long get_PacketsFragmented();
    public virtual long get_PacketFragmentFailures();
    public virtual int get_NumberOfInterfaces();
    public virtual int get_NumberOfIPAddresses();
    public virtual int get_NumberOfRoutes();
}
internal class System.Net.NetworkInformation.SystemIPInterfaceProperties : IPInterfaceProperties {
    public bool IsDnsEnabled { get; }
    public bool IsDynamicDnsEnabled { get; }
    public string DnsSuffix { get; }
    public IPAddressInformationCollection AnycastAddresses { get; }
    public UnicastIPAddressInformationCollection UnicastAddresses { get; }
    public MulticastIPAddressInformationCollection MulticastAddresses { get; }
    public IPAddressCollection DnsAddresses { get; }
    public GatewayIPAddressInformationCollection GatewayAddresses { get; }
    public IPAddressCollection DhcpServerAddresses { get; }
    public IPAddressCollection WinsServersAddresses { get; }
    internal SystemIPInterfaceProperties(FixedInfo fixedInfo, IpAdapterAddresses ipAdapterAddresses);
    public virtual bool get_IsDnsEnabled();
    public virtual bool get_IsDynamicDnsEnabled();
    public virtual IPv4InterfaceProperties GetIPv4Properties();
    public virtual IPv6InterfaceProperties GetIPv6Properties();
    public virtual string get_DnsSuffix();
    public virtual IPAddressInformationCollection get_AnycastAddresses();
    public virtual UnicastIPAddressInformationCollection get_UnicastAddresses();
    public virtual MulticastIPAddressInformationCollection get_MulticastAddresses();
    public virtual IPAddressCollection get_DnsAddresses();
    public virtual GatewayIPAddressInformationCollection get_GatewayAddresses();
    public virtual IPAddressCollection get_DhcpServerAddresses();
    public virtual IPAddressCollection get_WinsServersAddresses();
}
internal class System.Net.NetworkInformation.SystemIPInterfaceStatistics : IPInterfaceStatistics {
    public long OutputQueueLength { get; }
    public long BytesSent { get; }
    public long BytesReceived { get; }
    public long UnicastPacketsSent { get; }
    public long UnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long NonUnicastPacketsReceived { get; }
    public long IncomingPacketsDiscarded { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    internal SystemIPInterfaceStatistics(long index);
    public virtual long get_OutputQueueLength();
    public virtual long get_BytesSent();
    public virtual long get_BytesReceived();
    public virtual long get_UnicastPacketsSent();
    public virtual long get_UnicastPacketsReceived();
    public virtual long get_NonUnicastPacketsSent();
    public virtual long get_NonUnicastPacketsReceived();
    public virtual long get_IncomingPacketsDiscarded();
    public virtual long get_OutgoingPacketsDiscarded();
    public virtual long get_IncomingPacketsWithErrors();
    public virtual long get_OutgoingPacketsWithErrors();
    public virtual long get_IncomingUnknownProtocolPackets();
    internal static MibIfRow2 GetIfEntry2(long index);
}
internal class System.Net.NetworkInformation.SystemIPv4InterfaceProperties : IPv4InterfaceProperties {
    public bool UsesWins { get; }
    public bool IsDhcpEnabled { get; }
    public bool IsForwardingEnabled { get; }
    public bool IsAutomaticPrivateAddressingEnabled { get; }
    public bool IsAutomaticPrivateAddressingActive { get; }
    public int Mtu { get; }
    public int Index { get; }
    internal SystemIPv4InterfaceProperties(FixedInfo fixedInfo, IpAdapterAddresses ipAdapterAddresses);
    public virtual bool get_UsesWins();
    public virtual bool get_IsDhcpEnabled();
    public virtual bool get_IsForwardingEnabled();
    public virtual bool get_IsAutomaticPrivateAddressingEnabled();
    public virtual bool get_IsAutomaticPrivateAddressingActive();
    public virtual int get_Mtu();
    public virtual int get_Index();
}
internal class System.Net.NetworkInformation.SystemIPv4InterfaceStatistics : IPv4InterfaceStatistics {
    public long OutputQueueLength { get; }
    public long BytesSent { get; }
    public long BytesReceived { get; }
    public long UnicastPacketsSent { get; }
    public long UnicastPacketsReceived { get; }
    public long NonUnicastPacketsSent { get; }
    public long NonUnicastPacketsReceived { get; }
    public long IncomingPacketsDiscarded { get; }
    public long OutgoingPacketsDiscarded { get; }
    public long IncomingPacketsWithErrors { get; }
    public long OutgoingPacketsWithErrors { get; }
    public long IncomingUnknownProtocolPackets { get; }
    internal SystemIPv4InterfaceStatistics(long index);
    public virtual long get_OutputQueueLength();
    public virtual long get_BytesSent();
    public virtual long get_BytesReceived();
    public virtual long get_UnicastPacketsSent();
    public virtual long get_UnicastPacketsReceived();
    public virtual long get_NonUnicastPacketsSent();
    public virtual long get_NonUnicastPacketsReceived();
    public virtual long get_IncomingPacketsDiscarded();
    public virtual long get_OutgoingPacketsDiscarded();
    public virtual long get_IncomingPacketsWithErrors();
    public virtual long get_OutgoingPacketsWithErrors();
    public virtual long get_IncomingUnknownProtocolPackets();
}
internal class System.Net.NetworkInformation.SystemIPv6InterfaceProperties : IPv6InterfaceProperties {
    public int Index { get; }
    public int Mtu { get; }
    internal SystemIPv6InterfaceProperties(UInt32 index, UInt32 mtu, UInt32[] zoneIndices);
    public virtual int get_Index();
    public virtual int get_Mtu();
    public virtual long GetScopeId(ScopeLevel scopeLevel);
}
internal class System.Net.NetworkInformation.SystemMulticastIPAddressInformation : MulticastIPAddressInformation {
    public IPAddress Address { get; }
    public bool IsTransient { get; }
    public bool IsDnsEligible { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public long AddressValidLifetime { get; }
    public long AddressPreferredLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public SystemMulticastIPAddressInformation(SystemIPAddressInformation addressInfo);
    public virtual IPAddress get_Address();
    public virtual bool get_IsTransient();
    public virtual bool get_IsDnsEligible();
    public virtual PrefixOrigin get_PrefixOrigin();
    public virtual SuffixOrigin get_SuffixOrigin();
    public virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public virtual long get_AddressValidLifetime();
    public virtual long get_AddressPreferredLifetime();
    public virtual long get_DhcpLeaseLifetime();
    internal static MulticastIPAddressInformationCollection ToMulticastIpAddressInformationCollection(IPAddressInformationCollection addresses);
}
internal class System.Net.NetworkInformation.SystemNetworkInterface : NetworkInterface {
    internal static int InternalLoopbackInterfaceIndex { get; }
    internal static int InternalIPv6LoopbackInterfaceIndex { get; }
    public string Id { get; }
    public string Name { get; }
    public string Description { get; }
    public NetworkInterfaceType NetworkInterfaceType { get; }
    public OperationalStatus OperationalStatus { get; }
    public long Speed { get; }
    public bool IsReceiveOnly { get; }
    public bool SupportsMulticast { get; }
    internal SystemNetworkInterface(FixedInfo fixedInfo, IpAdapterAddresses ipAdapterAddresses);
    internal static int get_InternalLoopbackInterfaceIndex();
    internal static int get_InternalIPv6LoopbackInterfaceIndex();
    internal static bool InternalGetIsNetworkAvailable();
    internal static NetworkInterface[] GetNetworkInterfaces();
    public virtual string get_Id();
    public virtual string get_Name();
    public virtual string get_Description();
    public virtual PhysicalAddress GetPhysicalAddress();
    public virtual NetworkInterfaceType get_NetworkInterfaceType();
    public virtual IPInterfaceProperties GetIPProperties();
    public virtual IPv4InterfaceStatistics GetIPv4Statistics();
    public virtual IPInterfaceStatistics GetIPStatistics();
    public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
    public virtual OperationalStatus get_OperationalStatus();
    public virtual long get_Speed();
    public virtual bool get_IsReceiveOnly();
    public virtual bool get_SupportsMulticast();
}
internal class System.Net.NetworkInformation.SystemTcpConnectionInformation : TcpConnectionInformation {
    public TcpState State { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    internal SystemTcpConnectionInformation(MibTcpRow row);
    internal SystemTcpConnectionInformation(MibTcp6RowOwnerPid row);
    public virtual TcpState get_State();
    public virtual IPEndPoint get_LocalEndPoint();
    public virtual IPEndPoint get_RemoteEndPoint();
}
internal class System.Net.NetworkInformation.SystemTcpStatistics : TcpStatistics {
    public long MinimumTransmissionTimeout { get; }
    public long MaximumTransmissionTimeout { get; }
    public long MaximumConnections { get; }
    public long ConnectionsInitiated { get; }
    public long ConnectionsAccepted { get; }
    public long FailedConnectionAttempts { get; }
    public long ResetConnections { get; }
    public long CurrentConnections { get; }
    public long SegmentsReceived { get; }
    public long SegmentsSent { get; }
    public long SegmentsResent { get; }
    public long ErrorsReceived { get; }
    public long ResetsSent { get; }
    public long CumulativeConnections { get; }
    internal SystemTcpStatistics(AddressFamily family);
    public virtual long get_MinimumTransmissionTimeout();
    public virtual long get_MaximumTransmissionTimeout();
    public virtual long get_MaximumConnections();
    public virtual long get_ConnectionsInitiated();
    public virtual long get_ConnectionsAccepted();
    public virtual long get_FailedConnectionAttempts();
    public virtual long get_ResetConnections();
    public virtual long get_CurrentConnections();
    public virtual long get_SegmentsReceived();
    public virtual long get_SegmentsSent();
    public virtual long get_SegmentsResent();
    public virtual long get_ErrorsReceived();
    public virtual long get_ResetsSent();
    public virtual long get_CumulativeConnections();
}
internal class System.Net.NetworkInformation.SystemUdpStatistics : UdpStatistics {
    public long DatagramsReceived { get; }
    public long IncomingDatagramsDiscarded { get; }
    public long IncomingDatagramsWithErrors { get; }
    public long DatagramsSent { get; }
    public int UdpListeners { get; }
    internal SystemUdpStatistics(AddressFamily family);
    public virtual long get_DatagramsReceived();
    public virtual long get_IncomingDatagramsDiscarded();
    public virtual long get_IncomingDatagramsWithErrors();
    public virtual long get_DatagramsSent();
    public virtual int get_UdpListeners();
}
internal class System.Net.NetworkInformation.SystemUnicastIPAddressInformation : UnicastIPAddressInformation {
    public IPAddress Address { get; }
    public IPAddress IPv4Mask { get; }
    public int PrefixLength { get; }
    public bool IsTransient { get; }
    public bool IsDnsEligible { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public long AddressValidLifetime { get; }
    public long AddressPreferredLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    internal SystemUnicastIPAddressInformation(IpAdapterUnicastAddress adapterAddress);
    public virtual IPAddress get_Address();
    public virtual IPAddress get_IPv4Mask();
    public virtual int get_PrefixLength();
    public virtual bool get_IsTransient();
    public virtual bool get_IsDnsEligible();
    public virtual PrefixOrigin get_PrefixOrigin();
    public virtual SuffixOrigin get_SuffixOrigin();
    public virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public virtual long get_AddressValidLifetime();
    public virtual long get_AddressPreferredLifetime();
    public virtual long get_DhcpLeaseLifetime();
    internal static UnicastIPAddressInformationCollection MarshalUnicastIpAddressInformationCollection(IntPtr ptr);
}
public abstract class System.Net.NetworkInformation.TcpConnectionInformation : object {
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public TcpState State { get; }
    public abstract virtual IPEndPoint get_LocalEndPoint();
    public abstract virtual IPEndPoint get_RemoteEndPoint();
    public abstract virtual TcpState get_State();
}
public enum System.Net.NetworkInformation.TcpState : Enum {
    public int value__;
    public static TcpState Unknown;
    public static TcpState Closed;
    public static TcpState Listen;
    public static TcpState SynSent;
    public static TcpState SynReceived;
    public static TcpState Established;
    public static TcpState FinWait1;
    public static TcpState FinWait2;
    public static TcpState CloseWait;
    public static TcpState Closing;
    public static TcpState LastAck;
    public static TcpState TimeWait;
    public static TcpState DeleteTcb;
}
public abstract class System.Net.NetworkInformation.TcpStatistics : object {
    public long ConnectionsAccepted { get; }
    public long ConnectionsInitiated { get; }
    public long CumulativeConnections { get; }
    public long CurrentConnections { get; }
    public long ErrorsReceived { get; }
    public long FailedConnectionAttempts { get; }
    public long MaximumConnections { get; }
    public long MaximumTransmissionTimeout { get; }
    public long MinimumTransmissionTimeout { get; }
    public long ResetConnections { get; }
    public long SegmentsReceived { get; }
    public long SegmentsResent { get; }
    public long SegmentsSent { get; }
    public long ResetsSent { get; }
    public abstract virtual long get_ConnectionsAccepted();
    public abstract virtual long get_ConnectionsInitiated();
    public abstract virtual long get_CumulativeConnections();
    public abstract virtual long get_CurrentConnections();
    public abstract virtual long get_ErrorsReceived();
    public abstract virtual long get_FailedConnectionAttempts();
    public abstract virtual long get_MaximumConnections();
    public abstract virtual long get_MaximumTransmissionTimeout();
    public abstract virtual long get_MinimumTransmissionTimeout();
    public abstract virtual long get_ResetConnections();
    public abstract virtual long get_SegmentsReceived();
    public abstract virtual long get_SegmentsResent();
    public abstract virtual long get_SegmentsSent();
    public abstract virtual long get_ResetsSent();
}
internal enum System.Net.NetworkInformation.TcpTableClass : Enum {
    public int value__;
    public static TcpTableClass TcpTableBasicListener;
    public static TcpTableClass TcpTableBasicConnections;
    public static TcpTableClass TcpTableBasicAll;
    public static TcpTableClass TcpTableOwnerPidListener;
    public static TcpTableClass TcpTableOwnerPidConnections;
    public static TcpTableClass TcpTableOwnerPidAll;
    public static TcpTableClass TcpTableOwnerModuleListener;
    public static TcpTableClass TcpTableOwnerModuleConnections;
    public static TcpTableClass TcpTableOwnerModuleAll;
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.NetworkInformation.TeredoHelper : object {
    private static TeredoHelper();
    public static bool UnsafeNotifyStableUnicastIpAddressTable(Action`1<object> callback, object state);
}
public abstract class System.Net.NetworkInformation.UdpStatistics : object {
    public long DatagramsReceived { get; }
    public long DatagramsSent { get; }
    public long IncomingDatagramsDiscarded { get; }
    public long IncomingDatagramsWithErrors { get; }
    public int UdpListeners { get; }
    public abstract virtual long get_DatagramsReceived();
    public abstract virtual long get_DatagramsSent();
    public abstract virtual long get_IncomingDatagramsDiscarded();
    public abstract virtual long get_IncomingDatagramsWithErrors();
    public abstract virtual int get_UdpListeners();
}
internal enum System.Net.NetworkInformation.UdpTableClass : Enum {
    public int value__;
    public static UdpTableClass UdpTableBasic;
    public static UdpTableClass UdpTableOwnerPid;
    public static UdpTableClass UdpTableOwnerModule;
}
public abstract class System.Net.NetworkInformation.UnicastIPAddressInformation : IPAddressInformation {
    public long AddressPreferredLifetime { get; }
    public long AddressValidLifetime { get; }
    public long DhcpLeaseLifetime { get; }
    public DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
    public PrefixOrigin PrefixOrigin { get; }
    public SuffixOrigin SuffixOrigin { get; }
    public IPAddress IPv4Mask { get; }
    public int PrefixLength { get; }
    public abstract virtual long get_AddressPreferredLifetime();
    public abstract virtual long get_AddressValidLifetime();
    public abstract virtual long get_DhcpLeaseLifetime();
    public abstract virtual DuplicateAddressDetectionState get_DuplicateAddressDetectionState();
    public abstract virtual PrefixOrigin get_PrefixOrigin();
    public abstract virtual SuffixOrigin get_SuffixOrigin();
    public abstract virtual IPAddress get_IPv4Mask();
    public virtual int get_PrefixLength();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.UnicastIPAddressInformationCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public UnicastIPAddressInformation Item { get; }
    public virtual void CopyTo(UnicastIPAddressInformation[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(UnicastIPAddressInformation address);
    internal void InternalAdd(UnicastIPAddressInformation address);
    public virtual bool Contains(UnicastIPAddressInformation address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<UnicastIPAddressInformation> GetEnumerator();
    public virtual UnicastIPAddressInformation get_Item(int index);
    public virtual bool Remove(UnicastIPAddressInformation address);
    public virtual void Clear();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.Net.NetworkInformation.UnsafeNetInfoNativeMethods : object {
    internal static UInt32 GetAdaptersAddresses(AddressFamily family, UInt32 flags, IntPtr pReserved, SafeLocalFree adapterAddresses, UInt32& outBufLen);
    internal static UInt32 GetBestInterfaceEx(Byte[] ipAddress, Int32& index);
    internal static UInt32 GetIfEntry2(MibIfRow2& pIfRow);
    internal static UInt32 GetIpStatisticsEx(MibIpStats& statistics, AddressFamily family);
    internal static UInt32 GetTcpStatisticsEx(MibTcpStats& statistics, AddressFamily family);
    internal static UInt32 GetUdpStatisticsEx(MibUdpStats& statistics, AddressFamily family);
    internal static UInt32 GetIcmpStatistics(MibIcmpInfo& statistics);
    internal static UInt32 GetIcmpStatisticsEx(MibIcmpInfoEx& statistics, AddressFamily family);
    internal static UInt32 GetTcpTable(SafeLocalFree pTcpTable, UInt32& dwOutBufLen, bool order);
    internal static UInt32 GetExtendedTcpTable(SafeLocalFree pTcpTable, UInt32& dwOutBufLen, bool order, UInt32 IPVersion, TcpTableClass tableClass, UInt32 reserved);
    internal static UInt32 GetUdpTable(SafeLocalFree pUdpTable, UInt32& dwOutBufLen, bool order);
    internal static UInt32 GetExtendedUdpTable(SafeLocalFree pUdpTable, UInt32& dwOutBufLen, bool order, UInt32 IPVersion, UdpTableClass tableClass, UInt32 reserved);
    internal static UInt32 GetNetworkParams(SafeLocalFree pFixedInfo, UInt32& pOutBufLen);
    internal static UInt32 GetPerAdapterInfo(UInt32 IfIndex, SafeLocalFree pPerAdapterInfo, UInt32& pOutBufLen);
    internal static SafeCloseIcmpHandle IcmpCreateFile();
    internal static SafeCloseIcmpHandle Icmp6CreateFile();
    internal static bool IcmpCloseHandle(IntPtr handle);
    internal static UInt32 IcmpSendEcho2(SafeCloseIcmpHandle icmpHandle, SafeWaitHandle Event, IntPtr apcRoutine, IntPtr apcContext, UInt32 ipAddress, SafeLocalFree data, ushort dataSize, IPOptions& options, SafeLocalFree replyBuffer, UInt32 replySize, UInt32 timeout);
    internal static UInt32 IcmpSendEcho2(SafeCloseIcmpHandle icmpHandle, IntPtr Event, IntPtr apcRoutine, IntPtr apcContext, UInt32 ipAddress, SafeLocalFree data, ushort dataSize, IPOptions& options, SafeLocalFree replyBuffer, UInt32 replySize, UInt32 timeout);
    internal static UInt32 Icmp6SendEcho2(SafeCloseIcmpHandle icmpHandle, SafeWaitHandle Event, IntPtr apcRoutine, IntPtr apcContext, Byte[] sourceSocketAddress, Byte[] destSocketAddress, SafeLocalFree data, ushort dataSize, IPOptions& options, SafeLocalFree replyBuffer, UInt32 replySize, UInt32 timeout);
    internal static UInt32 Icmp6SendEcho2(SafeCloseIcmpHandle icmpHandle, IntPtr Event, IntPtr apcRoutine, IntPtr apcContext, Byte[] sourceSocketAddress, Byte[] destSocketAddress, SafeLocalFree data, ushort dataSize, IPOptions& options, SafeLocalFree replyBuffer, UInt32 replySize, UInt32 timeout);
    [ReliabilityContractAttribute("3", "2")]
internal static void FreeMibTable(IntPtr handle);
    [ReliabilityContractAttribute("3", "1")]
internal static UInt32 CancelMibChangeNotify2(IntPtr notificationHandle);
    internal static UInt32 NotifyStableUnicastIpAddressTable(AddressFamily addressFamily, SafeFreeMibTable& table, StableUnicastIpAddressTableDelegate callback, IntPtr context, SafeCancelMibChangeNotify& notificationHandle);
}
internal enum System.Net.NetworkingPerfCounterName : Enum {
    public int value__;
    public static NetworkingPerfCounterName SocketConnectionsEstablished;
    public static NetworkingPerfCounterName SocketBytesReceived;
    public static NetworkingPerfCounterName SocketBytesSent;
    public static NetworkingPerfCounterName SocketDatagramsReceived;
    public static NetworkingPerfCounterName SocketDatagramsSent;
    public static NetworkingPerfCounterName HttpWebRequestCreated;
    public static NetworkingPerfCounterName HttpWebRequestAvgLifeTime;
    public static NetworkingPerfCounterName HttpWebRequestAvgLifeTimeBase;
    public static NetworkingPerfCounterName HttpWebRequestQueued;
    public static NetworkingPerfCounterName HttpWebRequestAvgQueueTime;
    public static NetworkingPerfCounterName HttpWebRequestAvgQueueTimeBase;
    public static NetworkingPerfCounterName HttpWebRequestAborted;
    public static NetworkingPerfCounterName HttpWebRequestFailed;
}
internal class System.Net.NetworkingPerfCounters : object {
    public static NetworkingPerfCounters Instance { get; }
    public bool Enabled { get; }
    private static NetworkingPerfCounters();
    public static NetworkingPerfCounters get_Instance();
    public static long GetTimestamp();
    public bool get_Enabled();
    public void Increment(NetworkingPerfCounterName perfCounter);
    public void Increment(NetworkingPerfCounterName perfCounter, long amount);
    public void Decrement(NetworkingPerfCounterName perfCounter);
    public void Decrement(NetworkingPerfCounterName perfCounter, long amount);
    public void IncrementAverage(NetworkingPerfCounterName perfCounter, long startTimestamp);
}
internal class System.Net.NTAuthentication : object {
    internal string UniqueUserId { get; }
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal string AssociatedName { get; }
    internal bool IsConfidentialityFlag { get; }
    internal bool IsIntegrityFlag { get; }
    internal bool IsMutualAuthFlag { get; }
    internal bool IsDelegationFlag { get; }
    internal bool IsIdentifyFlag { get; }
    internal string Spn { get; }
    internal string ClientSpecifiedSpn { get; }
    internal bool OSSupportsExtendedProtection { get; }
    internal bool IsServer { get; }
    internal bool IsKerberos { get; }
    internal bool IsNTLM { get; }
    internal string Package { get; }
    internal string ProtocolName { get; }
    internal SecSizes Sizes { get; }
    internal ChannelBinding ChannelBinding { get; }
    internal NTAuthentication(string package, NetworkCredential networkCredential, SpnToken spnToken, WebRequest request, ChannelBinding channelBinding);
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlags requestedContextFlags, ContextAwareResult context, ChannelBinding channelBinding);
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlags requestedContextFlags, ChannelBinding channelBinding);
    internal NTAuthentication(bool isServer, string package, string spn, ContextFlags requestedContextFlags, ChannelBinding channelBinding);
    private static NTAuthentication();
    internal string get_UniqueUserId();
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal string get_AssociatedName();
    internal bool get_IsConfidentialityFlag();
    internal bool get_IsIntegrityFlag();
    internal bool get_IsMutualAuthFlag();
    internal bool get_IsDelegationFlag();
    internal bool get_IsIdentifyFlag();
    internal string get_Spn();
    internal string get_ClientSpecifiedSpn();
    internal bool get_OSSupportsExtendedProtection();
    internal bool get_IsServer();
    internal bool get_IsKerberos();
    internal bool get_IsNTLM();
    internal string get_Package();
    internal string get_ProtocolName();
    internal SecSizes get_Sizes();
    internal ChannelBinding get_ChannelBinding();
    internal SafeCloseHandle GetContextToken(SecurityStatus& status);
    internal SafeCloseHandle GetContextToken();
    internal void CloseContext();
    internal string GetOutgoingBlob(string incomingBlob);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatus& statusCode);
    internal string GetOutgoingDigestBlob(string incomingBlob, string requestMethod, string requestedUri, string realm, bool isClientPreAuth, bool throwOnError, SecurityStatus& statusCode);
    internal int Encrypt(Byte[] buffer, int offset, int count, Byte[]& output, UInt32 sequenceNumber);
    internal int Decrypt(Byte[] payload, int offset, int count, Int32& newOffset, UInt32 expectedSeqNumber);
    internal int VerifySignature(Byte[] buffer, int offset, int count);
    internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output);
}
internal class System.Net.NtlmClient : object {
    internal static string AuthType;
    internal static string Signature;
    internal static int SignatureSize;
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public bool CanUseDefaultCredentials { get; }
    private static NtlmClient();
    public sealed virtual Authorization Authenticate(string challenge, WebRequest webRequest, ICredentials credentials);
    public sealed virtual bool get_CanPreAuthenticate();
    public sealed virtual Authorization PreAuthenticate(WebRequest webRequest, ICredentials credentials);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual bool Update(string challenge, WebRequest webRequest);
    public sealed virtual void ClearSession(WebRequest webRequest);
    public sealed virtual bool get_CanUseDefaultCredentials();
}
public class System.Net.OpenReadCompletedEventArgs : AsyncCompletedEventArgs {
    public Stream Result { get; }
    internal OpenReadCompletedEventArgs(Stream result, Exception exception, bool cancelled, object userToken);
    public Stream get_Result();
}
public class System.Net.OpenReadCompletedEventHandler : MulticastDelegate {
    public OpenReadCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenReadCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenReadCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.OpenWriteCompletedEventArgs : AsyncCompletedEventArgs {
    public Stream Result { get; }
    internal OpenWriteCompletedEventArgs(Stream result, Exception exception, bool cancelled, object userToken);
    public Stream get_Result();
}
public class System.Net.OpenWriteCompletedEventHandler : MulticastDelegate {
    public OpenWriteCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OpenWriteCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OpenWriteCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.PathList : object {
    public int Count { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    public int get_Count();
    public int GetCookiesCount();
    public ICollection get_Values();
    public object get_Item(string s);
    public void set_Item(string s, object value);
    public IEnumerator GetEnumerator();
    public object get_SyncRoot();
}
internal class System.Net.PolicyWrapper : object {
    internal PolicyWrapper(ICertificatePolicy policy, ServicePoint sp, WebRequest wr);
    public bool Accept(X509Certificate Certificate, int CertificateProblem);
    internal static UInt32 VerifyChainPolicy(SafeFreeCertChain chainContext, ChainPolicyParameter& cpp);
    internal bool CheckErrors(string hostName, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal class System.Net.PooledStream : Stream {
    internal bool JustConnected { get; }
    internal IPAddress ServerAddress { get; }
    internal bool IsInitalizing { get; }
    internal bool CanBePooled { get; internal set; }
    internal bool IsEmancipated { get; }
    internal object Owner { get; internal set; }
    internal ConnectionPool Pool { get; }
    internal ServicePoint ServicePoint { get; }
    protected bool UsingSecureStream { get; }
    internal NetworkStream NetworkStream { get; internal set; }
    protected Socket Socket { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal PooledStream(object owner);
    internal PooledStream(ConnectionPool connectionPool, TimeSpan lifetime, bool checkLifetime);
    internal bool get_JustConnected();
    internal IPAddress get_ServerAddress();
    internal bool get_IsInitalizing();
    internal bool get_CanBePooled();
    internal void set_CanBePooled(bool value);
    internal bool get_IsEmancipated();
    internal object get_Owner();
    internal void set_Owner(object value);
    internal ConnectionPool get_Pool();
    internal virtual ServicePoint get_ServicePoint();
    internal bool Activate(object owningObject, GeneralAsyncDelegate asyncCallback);
    protected bool Activate(object owningObject, bool async, GeneralAsyncDelegate asyncCallback);
    internal void Deactivate();
    internal virtual void ConnectionCallback(object owningObject, Exception e, Socket socket, IPAddress address);
    protected void CheckLifetime();
    internal void UpdateLifetime();
    internal void PrePush(object expectedOwner);
    internal void PostPop(object newOwner);
    protected bool get_UsingSecureStream();
    internal NetworkStream get_NetworkStream();
    internal void set_NetworkStream(NetworkStream value);
    protected Socket get_Socket();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    internal void MultipleWrite(BufferOffsetSize[] buffers);
    protected virtual void Dispose(bool disposing);
    internal void CloseSocket();
    public void Close(int timeout);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state);
    internal void EndMultipleWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
    internal bool Poll(int microSeconds, SelectMode mode);
    internal bool PollRead();
}
internal class System.Net.PrefixLookup : object {
    public PrefixLookup(int capacity);
    public void Add(string prefix, object value);
    public object Lookup(string lookupKey);
}
public class System.Net.ProtocolViolationException : InvalidOperationException {
    public ProtocolViolationException(string message);
    protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal abstract class System.Net.ProxyChain : object {
    internal IEnumerator`1<Uri> Enumerator { get; }
    internal Uri Destination { get; }
    internal HttpAbortDelegate HttpAbortDelegate { get; }
    protected ProxyChain(Uri destination);
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Dispose();
    internal IEnumerator`1<Uri> get_Enumerator();
    internal Uri get_Destination();
    internal virtual void Abort();
    internal bool HttpAbort(HttpWebRequest request, WebException webException);
    internal HttpAbortDelegate get_HttpAbortDelegate();
    protected abstract virtual bool GetNextProxy(Uri& proxy);
}
internal class System.Net.ProxyScriptChain : ProxyChain {
    internal ProxyScriptChain(WebProxy proxy, Uri destination);
    protected virtual bool GetNextProxy(Uri& proxy);
    internal virtual void Abort();
}
internal enum System.Net.ReadState : Enum {
    public int value__;
    public static ReadState Start;
    public static ReadState StatusLine;
    public static ReadState Headers;
    public static ReadState Data;
}
internal class System.Net.ReceiveState : object {
    internal ResponseDescription Resp;
    internal int ValidThrough;
    internal Byte[] Buffer;
    internal CommandStream Connection;
    internal ReceiveState(CommandStream connection);
}
internal class System.Net.RegBlobWebProxyDataBuilder : WebProxyDataBuilder {
    internal static string PolicyKey;
    internal static string ProxyKey;
    public RegBlobWebProxyDataBuilder(string connectoid, SafeRegistryHandle registry);
    public string ReadString();
    internal int ReadInt32();
    protected virtual void BuildInternal();
}
internal static class System.Net.RegistryConfiguration : object {
    public static int GlobalConfigReadInt(string configVariable, int defaultValue);
    public static string GlobalConfigReadString(string configVariable, string defaultValue);
    public static int AppConfigReadInt(string configVariable, int defaultValue);
    public static string AppConfigReadString(string configVariable, string defaultValue);
}
internal abstract class System.Net.RequestContextBase : object {
    internal HTTP_REQUEST* RequestBlob { get; }
    internal Byte[] RequestBuffer { get; }
    internal UInt32 Size { get; }
    internal IntPtr OriginalBlobAddress { get; }
    protected void BaseConstruction(HTTP_REQUEST* requestBlob);
    internal void ReleasePins();
    protected abstract virtual void OnReleasePins();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal HTTP_REQUEST* get_RequestBlob();
    internal Byte[] get_RequestBuffer();
    internal UInt32 get_Size();
    internal IntPtr get_OriginalBlobAddress();
    protected void SetBlob(HTTP_REQUEST* requestBlob);
    protected void UnsetBlob();
    protected void SetBuffer(int size);
}
internal class System.Net.RequestLifetimeSetter : object {
    internal RequestLifetimeSetter(long requestStartTimestamp);
    internal static void Report(RequestLifetimeSetter tracker);
}
internal class System.Net.ResponseDescription : object {
    internal static int NoStatus;
    internal bool Multiline;
    internal int Status;
    internal string StatusDescription;
    internal StringBuilder StatusBuffer;
    internal string StatusCodeString;
    internal bool PositiveIntermediate { get; }
    internal bool PositiveCompletion { get; }
    internal bool TransientFailure { get; }
    internal bool PermanentFailure { get; }
    internal bool InvalidStatusCode { get; }
    internal bool get_PositiveIntermediate();
    internal bool get_PositiveCompletion();
    internal bool get_TransientFailure();
    internal bool get_PermanentFailure();
    internal bool get_InvalidStatusCode();
}
[FriendAccessAllowedAttribute]
internal class System.Net.RtcState : object {
    internal Byte[] inputData;
    internal Byte[] outputData;
    internal ManualResetEvent connectComplete;
    internal ManualResetEvent flushComplete;
    internal int result;
    internal bool IsAborted { get; }
    internal bool get_IsAborted();
    internal void Abort();
    internal bool IsEnabled();
}
internal class System.Net.SafeCertSelectCritera : SafeHandleZeroOrMinusOneIsInvalid {
    internal int Count { get; }
    internal int get_Count();
    public virtual string ToString();
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeCloseHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    internal IntPtr DangerousGetHandle();
    protected virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "2")]
internal void Abort();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeCloseIcmpHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeCloseSocket : SafeHandleMinusOneIsInvalid {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    protected static void CreateSocket(InnerSafeCloseSocket socket, SafeCloseSocket target);
    internal static SafeCloseSocket CreateWSASocket(Byte* pinnedBuffer);
    internal static SafeCloseSocket CreateWSASocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    internal static SafeCloseSocket Accept(SafeCloseSocket socketHandle, Byte[] socketAddress, Int32& socketAddressSize);
    protected virtual bool ReleaseHandle();
    internal void CloseAsIs();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeCloseSocketAndEvent : SafeCloseSocket {
    protected virtual bool ReleaseHandle();
    internal static SafeCloseSocketAndEvent CreateWSASocketWithEvent(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, bool autoReset, bool signaled);
    internal static void CompleteInitialization(SafeCloseSocketAndEvent socketAndEventHandle);
    internal WaitHandle GetEventHandle();
}
internal class System.Net.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials _Target;
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.SafeDeleteContext : SafeHandle {
    internal SSPIHandle _handle;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SecurDll dll, SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SecurDll dll, SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, SecurityBuffer inSecBuffer, SecurityBuffer[] inSecBuffers, SecurityBuffer outSecBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SecurDll dll, SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers);
    internal static int ApplyControlToken(SecurDll dll, SafeDeleteContext& refContext, SecurityBuffer[] inSecBuffers);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeDeleteContext_SECURITY : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeAddrInfo : SafeHandleZeroOrMinusOneIsInvalid {
    internal static int GetAddrInfo(string nodename, string servicename, AddressInfo& hints, SafeFreeAddrInfo& outAddrInfo);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeCertChain : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeFreeCertChain(IntPtr handle);
    internal SafeFreeCertChain(IntPtr handle, bool ownsHandle);
    public virtual string ToString();
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeCertChainList : SafeHandleZeroOrMinusOneIsInvalid {
    public virtual string ToString();
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "2")]
internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal abstract class System.Net.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "2")]
internal void Set(IntPtr value);
    internal static int EnumeratePackages(SecurDll Dll, Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle(SecurDll dll);
    public static int QueryContextAttributes(SecurDll dll, SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
    public static int SetContextAttributes(SecurDll dll, SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte[] buffer);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal abstract class System.Net.SafeFreeContextBufferChannelBinding : ChannelBinding {
    public int Size { get; }
    public virtual int get_Size();
    [ReliabilityContractAttribute("3", "2")]
internal void Set(IntPtr value);
    internal static SafeFreeContextBufferChannelBinding CreateEmptyHandle(SecurDll dll);
    public static int QueryContextChannelBinding(SecurDll dll, SafeDeleteContext phContext, ContextAttribute contextAttribute, Bindings* buffer, SafeFreeContextBufferChannelBinding refHandle);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeContextBufferChannelBinding_SECURITY : SafeFreeContextBufferChannelBinding {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.SafeFreeCredentials : SafeHandle {
    internal SSPIHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireCredentialsHandle(SecurDll dll, string package, CredentialUse intent, AuthIdentity& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireDefaultCredential(SecurDll dll, string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(SecurDll dll, string package, CredentialUse intent, SecureCredential& authdata, SafeFreeCredentials& outCredential);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeGlobalFree : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeGlobalFree(bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeInternetHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeLoadLibrary : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeLoadLibrary Zero;
    private static SafeLoadLibrary();
    private SafeLoadLibrary(bool ownsHandle);
    public static SafeLoadLibrary LoadLibraryEx(string library);
    public bool HasFunction(string functionName);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeLocalFree : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeLocalFree Zero;
    private SafeLocalFree(bool ownsHandle);
    private static SafeLocalFree();
    public static SafeLocalFree LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeLocalFreeChannelBinding : ChannelBinding {
    public int Size { get; }
    public virtual int get_Size();
    public static SafeLocalFreeChannelBinding LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
}
internal class System.Net.SafeNativeOverlapped : SafeHandle {
    internal static SafeNativeOverlapped Zero;
    public bool IsInvalid { get; }
    internal SafeNativeOverlapped(NativeOverlapped* handle);
    internal SafeNativeOverlapped(IntPtr handle);
    private static SafeNativeOverlapped();
    public virtual bool get_IsInvalid();
    public void ReinitializeNativeOverlapped();
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.Net.SafeNclNativeMethods : object {
}
[ComVisibleAttribute("False")]
internal class System.Net.SafeOverlappedFree : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeOverlappedFree Zero;
    private SafeOverlappedFree(bool ownsHandle);
    private static SafeOverlappedFree();
    public static SafeOverlappedFree Alloc();
    public static SafeOverlappedFree Alloc(SafeCloseSocket socketHandle);
    [ReliabilityContractAttribute("3", "2")]
public void Close(bool resetOwner);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static UInt32 RegOpenKeyEx(IntPtr key, string subKey, UInt32 ulOptions, UInt32 samDesired, SafeRegistryHandle& resultSubKey);
    internal UInt32 RegOpenKeyEx(string subKey, UInt32 ulOptions, UInt32 samDesired, SafeRegistryHandle& resultSubKey);
    internal UInt32 RegCloseKey();
    internal UInt32 QueryValue(string name, Object& data);
    internal UInt32 RegNotifyChangeKeyValue(bool watchSubTree, UInt32 notifyFilter, SafeWaitHandle regEvent, bool async);
    internal static UInt32 RegOpenCurrentUser(UInt32 samDesired, SafeRegistryHandle& resultKey);
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
internal class System.Net.SafeUnlockUrlCacheEntryFile : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
    internal static Status GetAndLockFile(string key, Byte* entryPtr, Int32& entryBufSize, SafeUnlockUrlCacheEntryFile& handle);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.SafeWebSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.ScatterGatherBuffers : object {
    internal int Length { get; }
    internal ScatterGatherBuffers(long totalSize);
    internal BufferOffsetSize[] GetBuffers();
    internal int get_Length();
    internal void Write(Byte[] buffer, int offset, int count);
}
[FlagsAttribute]
internal enum System.Net.SchProtocols : Enum {
    public int value__;
    public static SchProtocols Zero;
    public static SchProtocols PctClient;
    public static SchProtocols PctServer;
    public static SchProtocols Pct;
    public static SchProtocols Ssl2Client;
    public static SchProtocols Ssl2Server;
    public static SchProtocols Ssl2;
    public static SchProtocols Ssl3Client;
    public static SchProtocols Ssl3Server;
    public static SchProtocols Ssl3;
    public static SchProtocols Tls10Client;
    public static SchProtocols Tls10Server;
    public static SchProtocols Tls10;
    public static SchProtocols Tls11Client;
    public static SchProtocols Tls11Server;
    public static SchProtocols Tls11;
    public static SchProtocols Tls12Client;
    public static SchProtocols Tls12Server;
    public static SchProtocols Tls12;
    public static SchProtocols Tls13Client;
    public static SchProtocols Tls13Server;
    public static SchProtocols Tls13;
    public static SchProtocols Ssl3Tls;
    public static SchProtocols UniClient;
    public static SchProtocols UniServer;
    public static SchProtocols Unified;
    public static SchProtocols ClientMask;
    public static SchProtocols ServerMask;
}
internal class System.Net.SecChannelBindings : object {
    internal int dwInitiatorAddrType;
    internal int cbInitiatorLength;
    internal int dwInitiatorOffset;
    internal int dwAcceptorAddrType;
    internal int cbAcceptorLength;
    internal int dwAcceptorOffset;
    internal int cbApplicationDataLength;
    internal int dwApplicationDataOffset;
}
internal class System.Net.SecSizes : object {
    public int MaxToken;
    public int MaxSignature;
    public int BlockSize;
    public int SecurityTrailer;
    public static int SizeOf;
    internal SecSizes(Byte[] memory);
    private static SecSizes();
}
internal enum System.Net.SecurDll : Enum {
    public int value__;
    public static SecurDll SECURITY;
    public static SecurDll SECUR32;
    public static SecurDll SCHANNEL;
}
internal class System.Net.SecureCredential : ValueType {
    public static int CurrentVersion;
    public int version;
    public int cCreds;
    public IntPtr certContextArray;
    private IntPtr rootStore;
    public int cMappers;
    private IntPtr phMappers;
    public int cSupportedAlgs;
    private IntPtr palgSupportedAlgs;
    public SchProtocols grbitEnabledProtocols;
    public int dwMinimumCipherStrength;
    public int dwMaximumCipherStrength;
    public int dwSessionLifespan;
    public Flags dwFlags;
    public int reserved;
    public SecureCredential(int version, X509Certificate certificate, Flags flags, SchProtocols protocols, EncryptionPolicy policy);
    [ConditionalAttribute("TRAVE")]
internal void DebugDump();
}
internal class System.Net.Security._SslStream : object {
    internal bool DataAvailable { get; }
    internal _SslStream(SslState sslState);
    private static _SslStream();
    protected virtual override void Finalize();
    internal int Read(Byte[] buffer, int offset, int count);
    internal void Write(Byte[] buffer, int offset, int count);
    internal void Write(BufferOffsetSize[] buffers);
    internal IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal int EndRead(IAsyncResult asyncResult);
    internal IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    internal IAsyncResult BeginWrite(BufferOffsetSize[] buffers, AsyncCallback asyncCallback, object asyncState);
    internal void EndWrite(IAsyncResult asyncResult);
    internal bool get_DataAvailable();
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
public enum System.Net.Security.AuthenticationLevel : Enum {
    public int value__;
    public static AuthenticationLevel None;
    public static AuthenticationLevel MutualAuthRequested;
    public static AuthenticationLevel MutualAuthRequired;
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
    public LocalCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.NegoState : object {
    internal static int c_MaxReadFrameSize;
    internal static int c_MaxWriteDataSize;
    internal static string DefaultPackage { get; }
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool IsEncrypted { get; }
    internal bool IsSigned { get; }
    internal bool IsServer { get; }
    internal bool CanGetSecureStream { get; }
    internal TokenImpersonationLevel AllowedImpersonation { get; }
    internal NegoState(Stream innerStream, bool leaveStreamOpen);
    private static NegoState();
    internal static string get_DefaultPackage();
    internal void ValidateCreateContext(string package, NetworkCredential credential, string servicePrincipalName, ExtendedProtectionPolicy policy, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    internal void ValidateCreateContext(string package, bool isServer, NetworkCredential credential, string servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_IsEncrypted();
    internal bool get_IsSigned();
    internal bool get_IsServer();
    internal bool get_CanGetSecureStream();
    internal TokenImpersonationLevel get_AllowedImpersonation();
    internal IIdentity GetIdentity();
    internal void CheckThrow(bool authSucessCheck);
    internal void Close();
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void EndProcessAuthentication(IAsyncResult result);
    internal int EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer);
    internal int DecryptData(Byte[] buffer, int offset, int count, Int32& newOffset);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public IIdentity RemoteIdentity { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    private static NegotiateStream();
    public virtual void AuthenticateAsClient();
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer();
    public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual IIdentity get_RemoteIdentity();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
internal class System.Net.Security.ProtocolToken : object {
    internal SecurityStatus Status;
    internal Byte[] Payload;
    internal int Size;
    internal bool Failed { get; }
    internal bool Done { get; }
    internal bool Renegotiate { get; }
    internal bool CloseConnection { get; }
    internal ProtocolToken(Byte[] data, SecurityStatus errorCode);
    internal bool get_Failed();
    internal bool get_Done();
    internal bool get_Renegotiate();
    internal bool get_CloseConnection();
    internal Win32Exception GetException();
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
    public RemoteCertValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string host, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SecureChannel : object {
    internal static string SecurityPackage;
    internal static int ReadHeaderSize;
    internal X509Certificate LocalServerCertificate { get; }
    internal X509Certificate LocalClientCertificate { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal bool CheckCertRevocationStatus { get; }
    internal X509CertificateCollection ClientCertificates { get; }
    internal int HeaderSize { get; }
    internal int MaxDataSize { get; }
    internal SslConnectionInfo ConnectionInfo { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal bool RemoteCertRequired { get; }
    internal SecureChannel(string hostname, bool serverMode, SchProtocols protocolFlags, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertName, bool checkCertRevocationStatus, EncryptionPolicy encryptionPolicy, LocalCertSelectionCallback certSelectionDelegate);
    private static SecureChannel();
    internal X509Certificate get_LocalServerCertificate();
    internal X509Certificate get_LocalClientCertificate();
    internal bool get_IsRemoteCertificateAvailable();
    internal X509Certificate2 GetRemoteCertificate(X509Certificate2Collection& remoteCertificateStore);
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool get_CheckCertRevocationStatus();
    internal X509CertificateCollection get_ClientCertificates();
    internal int get_HeaderSize();
    internal int get_MaxDataSize();
    internal SslConnectionInfo get_ConnectionInfo();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal bool get_RemoteCertRequired();
    internal void SetRefreshCredentialNeeded();
    internal void Close();
    internal static X509Store EnsureStoreOpened(bool isMachineStore);
    internal ProtocolToken NextMessage(Byte[] incoming, int offset, int count);
    internal void ProcessHandshakeSuccess();
    internal SecurityStatus Encrypt(Byte[] buffer, int offset, int size, Byte[]& output, Int32& resultSize);
    internal SecurityStatus Decrypt(Byte[] payload, Int32& offset, Int32& count);
    internal bool VerifyRemoteCertificate(RemoteCertValidationCallback remoteCertValidationCallback, ProtocolToken& alertToken);
    public ProtocolToken CreateFatalHandshakeAlertToken(SslPolicyErrors sslPolicyErrors, X509Chain chain);
    public ProtocolToken CreateShutdownToken();
}
[FlagsAttribute]
public enum System.Net.Security.SslPolicyErrors : Enum {
    public int value__;
    public static SslPolicyErrors None;
    public static SslPolicyErrors RemoteCertificateNotAvailable;
    public static SslPolicyErrors RemoteCertificateNameMismatch;
    public static SslPolicyErrors RemoteCertificateChainErrors;
}
internal static class System.Net.Security.SslSessionsCache : object {
    private static SslSessionsCache();
    internal static SafeFreeCredentials TryCachedCredential(Byte[] thumbPrint, SchProtocols allowedProtocols, EncryptionPolicy encryptionPolicy);
    internal static void CacheCredential(SafeFreeCredentials creds, Byte[] thumbPrint, SchProtocols allowedProtocols, EncryptionPolicy encryptionPolicy);
}
internal class System.Net.Security.SslState : object {
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool RemoteCertRequired { get; }
    internal bool IsServer { get; }
    internal X509Certificate LocalCertificate { get; }
    internal X509Certificate InternalLocalCertificate { get; }
    internal bool CheckCertRevocationStatus { get; }
    internal SecurityStatus LastSecurityStatus { get; }
    internal bool IsCertValidationFailed { get; }
    internal bool IsShutdown { get; }
    internal bool DataAvailable { get; }
    internal CipherAlgorithmType CipherAlgorithm { get; }
    internal int CipherStrength { get; }
    internal HashAlgorithmType HashAlgorithm { get; }
    internal int HashStrength { get; }
    internal ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    internal int KeyExchangeStrength { get; }
    internal SslProtocols SslProtocol { get; }
    internal Stream InnerStream { get; }
    internal _SslStream SecureStream { get; }
    internal int HeaderSize { get; }
    internal int MaxDataSize { get; }
    internal Byte[] LastPayload { get; }
    internal SslState(Stream innerStream, bool isHTTP, EncryptionPolicy encryptionPolicy);
    internal SslState(Stream innerStream, RemoteCertValidationCallback certValidationCallback, LocalCertSelectionCallback certSelectionCallback, EncryptionPolicy encryptionPolicy);
    private static SslState();
    internal void ValidateCreateContext(bool isServer, string targetHost, SslProtocols enabledSslProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertRevocationStatus);
    internal void ValidateCreateContext(bool isServer, string targetHost, SslProtocols enabledSslProtocols, X509Certificate serverCertificate, X509CertificateCollection clientCertificates, bool remoteCertRequired, bool checkCertRevocationStatus, bool checkCertName);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_RemoteCertRequired();
    internal bool get_IsServer();
    internal void SetCertValidationDelegate(RemoteCertValidationCallback certValidationCallback);
    internal X509Certificate get_LocalCertificate();
    internal X509Certificate get_InternalLocalCertificate();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool get_CheckCertRevocationStatus();
    internal SecurityStatus get_LastSecurityStatus();
    internal bool get_IsCertValidationFailed();
    internal bool get_IsShutdown();
    internal bool get_DataAvailable();
    internal CipherAlgorithmType get_CipherAlgorithm();
    internal int get_CipherStrength();
    internal HashAlgorithmType get_HashAlgorithm();
    internal int get_HashStrength();
    internal ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    internal int get_KeyExchangeStrength();
    internal SslProtocols get_SslProtocol();
    internal Stream get_InnerStream();
    internal _SslStream get_SecureStream();
    internal int get_HeaderSize();
    internal int get_MaxDataSize();
    internal Byte[] get_LastPayload();
    internal void LastPayloadConsumed();
    internal void CheckThrow(bool authSuccessCheck, bool shutdownCheck);
    internal void Flush();
    internal void Close();
    internal SecurityStatus EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer, Int32& outSize);
    internal SecurityStatus DecryptData(Byte[] buffer, Int32& offset, Int32& count);
    internal int CheckOldKeyDecryptedData(Byte[] buffer, int offset, int count);
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void ReplyOnReAuthentication(Byte[] buffer);
    internal void EndProcessAuthentication(IAsyncResult result);
    internal void InternalEndProcessAuthentication(LazyAsyncResult lazyResult);
    internal int CheckEnqueueRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest request);
    internal void FinishRead(Byte[] renegotiateBuffer);
    internal bool CheckEnqueueWrite(AsyncProtocolRequest asyncRequest);
    internal void FinishWrite();
    internal IAsyncResult BeginShutdown(AsyncCallback asyncCallback, object asyncState);
    internal void EndShutdown(IAsyncResult result);
    internal int GetRemainingFrameSize(Byte[] buffer, int dataSize);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    internal virtual IAsyncResult BeginShutdown(AsyncCallback asyncCallback, object asyncState);
    internal virtual void EndShutdown(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public virtual Task ShutdownAsync();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual X509Certificate get_LocalCertificate();
    public virtual X509Certificate get_RemoteCertificate();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
internal enum System.Net.Security.TlsAlertMessage : Enum {
    public int value__;
    public static TlsAlertMessage CloseNotify;
    public static TlsAlertMessage UnexpectedMessage;
    public static TlsAlertMessage BadRecordMac;
    public static TlsAlertMessage DecryptionFailed;
    public static TlsAlertMessage RecordOverflow;
    public static TlsAlertMessage DecompressionFail;
    public static TlsAlertMessage HandshakeFailure;
    public static TlsAlertMessage BadCertificate;
    public static TlsAlertMessage UnsupportedCert;
    public static TlsAlertMessage CertificateRevoked;
    public static TlsAlertMessage CertificateExpired;
    public static TlsAlertMessage CertificateUnknown;
    public static TlsAlertMessage IllegalParameter;
    public static TlsAlertMessage UnknownCA;
    public static TlsAlertMessage AccessDenied;
    public static TlsAlertMessage DecodeError;
    public static TlsAlertMessage DecryptError;
    public static TlsAlertMessage ExportRestriction;
    public static TlsAlertMessage ProtocolVersion;
    public static TlsAlertMessage InsuffientSecurity;
    public static TlsAlertMessage InternalError;
    public static TlsAlertMessage UserCanceled;
    public static TlsAlertMessage NoRenegotiation;
    public static TlsAlertMessage UnsupportedExt;
}
internal enum System.Net.Security.TlsAlertType : Enum {
    public int value__;
    public static TlsAlertType Warning;
    public static TlsAlertType Fatal;
}
internal class System.Net.SecurityBuffer : object {
    public int size;
    public BufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public int offset;
    public SecurityBuffer(Byte[] data, int offset, int size, BufferType tokentype);
    public SecurityBuffer(Byte[] data, BufferType tokentype);
    public SecurityBuffer(int size, BufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal class System.Net.SecurityBufferDescriptor : object {
    public int Version;
    public int Count;
    public Void* UnmanagedPointer;
    public SecurityBufferDescriptor(int count);
    [ConditionalAttribute("TRAVE")]
internal void DebugDump();
}
internal class System.Net.SecurityBufferStruct : ValueType {
    public int count;
    public BufferType type;
    public IntPtr token;
    public static int Size;
    private static SecurityBufferStruct();
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
    internal static int Size;
    internal static int NameOffest;
    private static SecurityPackageInfo();
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Net.SecurityProtocolType : Enum {
    public int value__;
    public static SecurityProtocolType SystemDefault;
    public static SecurityProtocolType Ssl3;
    public static SecurityProtocolType Tls;
    public static SecurityProtocolType Tls11;
    public static SecurityProtocolType Tls12;
    public static SecurityProtocolType Tls13;
}
internal enum System.Net.SecurityStatus : Enum {
    public int value__;
    public static SecurityStatus OK;
    public static SecurityStatus ContinueNeeded;
    public static SecurityStatus CompleteNeeded;
    public static SecurityStatus CompAndContinue;
    public static SecurityStatus ContextExpired;
    public static SecurityStatus CredentialsNeeded;
    public static SecurityStatus Renegotiate;
    public static SecurityStatus OutOfMemory;
    public static SecurityStatus InvalidHandle;
    public static SecurityStatus Unsupported;
    public static SecurityStatus TargetUnknown;
    public static SecurityStatus InternalError;
    public static SecurityStatus PackageNotFound;
    public static SecurityStatus NotOwner;
    public static SecurityStatus CannotInstall;
    public static SecurityStatus InvalidToken;
    public static SecurityStatus CannotPack;
    public static SecurityStatus QopNotSupported;
    public static SecurityStatus NoImpersonation;
    public static SecurityStatus LogonDenied;
    public static SecurityStatus UnknownCredentials;
    public static SecurityStatus NoCredentials;
    public static SecurityStatus MessageAltered;
    public static SecurityStatus OutOfSequence;
    public static SecurityStatus NoAuthenticatingAuthority;
    public static SecurityStatus IncompleteMessage;
    public static SecurityStatus IncompleteCredentials;
    public static SecurityStatus BufferNotEnough;
    public static SecurityStatus WrongPrincipal;
    public static SecurityStatus TimeSkew;
    public static SecurityStatus UntrustedRoot;
    public static SecurityStatus IllegalMessage;
    public static SecurityStatus CertUnknown;
    public static SecurityStatus CertExpired;
    public static SecurityStatus AlgorithmMismatch;
    public static SecurityStatus SecurityQosFailed;
    public static SecurityStatus SmartcardLogonRequired;
    public static SecurityStatus UnsupportedPreauth;
    public static SecurityStatus BadBinding;
}
internal class System.Net.Semaphore : WaitHandle {
    internal Semaphore(int initialCount, int maxCount);
    internal bool ReleaseSemaphore();
}
internal class System.Net.ServerCertValidationCallback : object {
    internal RemoteCertificateValidationCallback ValidationCallback { get; }
    internal ServerCertValidationCallback(RemoteCertificateValidationCallback validationCallback);
    internal RemoteCertificateValidationCallback get_ValidationCallback();
    internal void Callback(object state);
    internal bool Invoke(object request, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
}
internal class System.Net.ServiceNameStore : object {
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    public void Clear();
    public string BuildSimpleServiceName(string uriPrefix);
    public String[] BuildServiceNames(string uriPrefix);
}
[FriendAccessAllowedAttribute]
public class System.Net.ServicePoint : object {
    internal static int LoopbackConnectionLimit;
    internal string LookupString { get; }
    internal string Hostname { get; }
    internal bool IsTrustedHost { get; }
    public BindIPEndPoint BindIPEndPointDelegate { get; public set; }
    internal object CachedChannelBinding { get; }
    public int ConnectionLeaseTimeout { get; public set; }
    internal Queue ConnectionLeaseTimerQueue { get; }
    public Uri Address { get; }
    internal Uri InternalAddress { get; }
    internal string Host { get; }
    internal int Port { get; }
    public int MaxIdleTime { get; public set; }
    public bool UseNagleAlgorithm { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public bool Expect100Continue { get; public set; }
    public DateTime IdleSince { get; }
    public Version ProtocolVersion { get; }
    internal HttpBehaviour HttpBehaviour { get; internal set; }
    public string ConnectionName { get; }
    public int ConnectionLimit { get; public set; }
    public int CurrentConnections { get; }
    public X509Certificate Certificate { get; }
    public X509Certificate ClientCertificate { get; }
    public bool SupportsPipelining { get; }
    internal bool Understands100Continue { get; internal set; }
    internal bool InternalProxyServicePoint { get; }
    internal ServicePoint(Uri address, Queue defaultIdlingQueue, int defaultConnectionLimit, string lookupString, bool userChangedLimit, bool proxyServicePoint);
    internal ServicePoint(string host, int port, Queue defaultIdlingQueue, int defaultConnectionLimit, string lookupString, bool userChangedLimit, bool proxyServicePoint);
    private static ServicePoint();
    internal string get_LookupString();
    internal string get_Hostname();
    internal bool get_IsTrustedHost();
    public BindIPEndPoint get_BindIPEndPointDelegate();
    public void set_BindIPEndPointDelegate(BindIPEndPoint value);
    internal object get_CachedChannelBinding();
    internal void SetCachedChannelBinding(Uri uri, ChannelBinding binding);
    internal Socket GetConnection(PooledStream PooledStream, object owner, bool async, IPAddress& address, Socket& abortSocket, Socket& abortSocket6);
    internal virtual void SubmitRequest(HttpWebRequest request);
    internal void SubmitRequest(HttpWebRequest request, string connName);
    public int get_ConnectionLeaseTimeout();
    public void set_ConnectionLeaseTimeout(int value);
    internal Queue get_ConnectionLeaseTimerQueue();
    public Uri get_Address();
    internal Uri get_InternalAddress();
    internal string get_Host();
    internal int get_Port();
    public int get_MaxIdleTime();
    public void set_MaxIdleTime(int value);
    public bool get_UseNagleAlgorithm();
    public void set_UseNagleAlgorithm(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public void set_Expect100Continue(bool value);
    public bool get_Expect100Continue();
    public DateTime get_IdleSince();
    public virtual Version get_ProtocolVersion();
    internal HttpBehaviour get_HttpBehaviour();
    internal void set_HttpBehaviour(HttpBehaviour value);
    public string get_ConnectionName();
    public bool CloseConnectionGroup(string connectionGroupName);
    internal void CloseConnectionGroupInternal(string connectionGroupName);
    public int get_ConnectionLimit();
    public void set_ConnectionLimit(int value);
    public int get_CurrentConnections();
    public X509Certificate get_Certificate();
    internal void UpdateServerCertificate(X509Certificate certificate);
    public X509Certificate get_ClientCertificate();
    internal void UpdateClientCertificate(X509Certificate certificate);
    public bool get_SupportsPipelining();
    public void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
    internal void set_Understands100Continue(bool value);
    internal bool get_Understands100Continue();
    internal bool get_InternalProxyServicePoint();
    internal void IncrementConnection();
    internal void DecrementConnection();
    internal RemoteCertValidationCallback SetupHandshakeDoneProcedure(TlsStream secureStream, object request);
    internal Timer CreateConnectionGroupTimer(ConnectionGroup connectionGroup);
    internal bool ReleaseConnectionGroup(string connName);
    internal void ReleaseAllConnectionGroups();
    [ConditionalAttribute("DEBUG")]
internal void DebugMembers(int requestHash);
}
public class System.Net.ServicePointManager : object {
    public static int DefaultNonPersistentConnectionLimit;
    public static int DefaultPersistentConnectionLimit;
    internal static string SpecialConnectGroupName;
    internal static Callback s_IdleServicePointTimeoutDelegate;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_UseTcpKeepAlive;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_TcpKeepAliveTime;
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_TcpKeepAliveInterval;
    internal static Callback IdleServicePointTimeoutDelegate { get; }
    public static SecurityProtocolType SecurityProtocol { get; public set; }
    internal static bool DisableStrongCrypto { get; }
    internal static bool DisableSystemDefaultTlsVersions { get; }
    internal static bool DisableSendAuxRecord { get; }
    internal static bool DisableCertificateEKUs { get; }
    internal static SslProtocols DefaultSslProtocols { get; }
    internal static bool UseHttpPipeliningAndBufferPooling { get; }
    internal static bool UseSafeSynchronousClose { get; }
    internal static bool UseStrictRfcInterimResponseHandling { get; }
    internal static bool AllowDangerousUnicodeDecompositions { get; }
    public static int MaxServicePoints { get; public set; }
    public static int DefaultConnectionLimit { get; public set; }
    public static int MaxServicePointIdleTime { get; public set; }
    public static bool UseNagleAlgorithm { get; public set; }
    public static bool Expect100Continue { get; public set; }
    public static bool EnableDnsRoundRobin { get; public set; }
    public static int DnsRefreshTimeout { get; public set; }
    [ObsoleteAttribute("CertificatePolicy is obsoleted for this type, please use ServerCertificateValidationCallback instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static ICertificatePolicy CertificatePolicy { get; public set; }
    internal static CertPolicyValidationCallback CertPolicyValidationCallback { get; }
    public static RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    internal static ServerCertValidationCallback ServerCertValidationCallback { get; }
    public static bool ReusePort { get; public set; }
    internal static Nullable`1<bool> ReusePortSupported { get; internal set; }
    public static bool CheckCertificateRevocationList { get; public set; }
    public static EncryptionPolicy EncryptionPolicy { get; }
    internal static bool CheckCertificateName { get; }
    private static ServicePointManager();
    [ConditionalAttribute("DEBUG")]
internal static void DebugMembers(int requestHash);
    internal static Callback get_IdleServicePointTimeoutDelegate();
    public static SecurityProtocolType get_SecurityProtocol();
    public static void set_SecurityProtocol(SecurityProtocolType value);
    internal static bool get_DisableStrongCrypto();
    internal static bool get_DisableSystemDefaultTlsVersions();
    internal static bool get_DisableSendAuxRecord();
    internal static bool get_DisableCertificateEKUs();
    internal static SslProtocols get_DefaultSslProtocols();
    internal static bool get_UseHttpPipeliningAndBufferPooling();
    internal static bool get_UseSafeSynchronousClose();
    internal static bool get_UseStrictRfcInterimResponseHandling();
    internal static bool get_AllowDangerousUnicodeDecompositions();
    public static int get_MaxServicePoints();
    public static void set_MaxServicePoints(int value);
    public static int get_DefaultConnectionLimit();
    public static void set_DefaultConnectionLimit(int value);
    public static int get_MaxServicePointIdleTime();
    public static void set_MaxServicePointIdleTime(int value);
    public static bool get_UseNagleAlgorithm();
    public static void set_UseNagleAlgorithm(bool value);
    public static bool get_Expect100Continue();
    public static void set_Expect100Continue(bool value);
    public static bool get_EnableDnsRoundRobin();
    public static void set_EnableDnsRoundRobin(bool value);
    public static int get_DnsRefreshTimeout();
    public static void set_DnsRefreshTimeout(int value);
    public static ICertificatePolicy get_CertificatePolicy();
    public static void set_CertificatePolicy(ICertificatePolicy value);
    internal static ICertificatePolicy GetLegacyCertificatePolicy();
    internal static CertPolicyValidationCallback get_CertPolicyValidationCallback();
    public static RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public static void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    internal static ServerCertValidationCallback get_ServerCertValidationCallback();
    public static bool get_ReusePort();
    public static void set_ReusePort(bool value);
    internal static Nullable`1<bool> get_ReusePortSupported();
    internal static void set_ReusePortSupported(Nullable`1<bool> value);
    public static bool get_CheckCertificateRevocationList();
    public static void set_CheckCertificateRevocationList(bool value);
    public static EncryptionPolicy get_EncryptionPolicy();
    internal static bool get_CheckCertificateName();
    internal static string MakeQueryString(Uri address);
    internal static string MakeQueryString(Uri address1, bool isProxy);
    public static ServicePoint FindServicePoint(Uri address);
    public static ServicePoint FindServicePoint(string uriString, IWebProxy proxy);
    public static ServicePoint FindServicePoint(Uri address, IWebProxy proxy);
    internal static ServicePoint FindServicePoint(Uri address, IWebProxy proxy, ProxyChain& chain, HttpAbortDelegate& abortDelegate, Int32& abortState);
    internal static ServicePoint FindServicePoint(ProxyChain chain);
    internal static ServicePoint FindServicePoint(string host, int port);
    [FriendAccessAllowedAttribute]
internal static void CloseConnectionGroups(string connectionGroupName);
    public static void SetTcpKeepAlive(bool enabled, int keepAliveTime, int keepAliveInterval);
}
internal class System.Net.ShellExpression : ValueType {
    private ShExpTokens[] pattern;
    private Int32[] match;
    internal ShellExpression(string pattern);
    internal bool IsMatch(string target);
}
[DefaultMemberAttribute("Item")]
public class System.Net.SocketAddress : object {
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    internal int m_Size;
    internal Byte[] m_Buffer;
    public AddressFamily Family { get; }
    public int Size { get; }
    public byte Item { get; public set; }
    public SocketAddress(AddressFamily family);
    public SocketAddress(AddressFamily family, int size);
    internal SocketAddress(IPAddress ipAddress);
    internal SocketAddress(IPAddress ipaddress, int port);
    public AddressFamily get_Family();
    public int get_Size();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    internal IPAddress GetIPAddress();
    internal IPEndPoint GetIPEndPoint();
    internal void CopyAddressSizeIntoBuffer();
    internal int GetAddressSizeOffset();
    internal void SetSize(IntPtr ptr);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
internal enum System.Net.SocketConstructorFlags : Enum {
    public int value__;
    public static SocketConstructorFlags WSA_FLAG_OVERLAPPED;
    public static SocketConstructorFlags WSA_FLAG_MULTIPOINT_C_ROOT;
    public static SocketConstructorFlags WSA_FLAG_MULTIPOINT_C_LEAF;
    public static SocketConstructorFlags WSA_FLAG_MULTIPOINT_D_ROOT;
    public static SocketConstructorFlags WSA_FLAG_MULTIPOINT_D_LEAF;
}
public class System.Net.SocketPermission : CodeAccessPermission {
    public static int AllPorts;
    internal static int AnyPort;
    public IEnumerator ConnectList { get; }
    public IEnumerator AcceptList { get; }
    public SocketPermission(PermissionState state);
    internal SocketPermission(bool free);
    public SocketPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    public IEnumerator get_ConnectList();
    public IEnumerator get_AcceptList();
    public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
    internal void AddPermission(NetworkAccess access, EndpointPermission endPoint);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.SocketPermissionAttribute : CodeAccessSecurityAttribute {
    public string Access { get; public set; }
    public string Host { get; public set; }
    public string Transport { get; public set; }
    public string Port { get; public set; }
    public SocketPermissionAttribute(SecurityAction action);
    public string get_Access();
    public void set_Access(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Transport();
    public void set_Transport(string value);
    public string get_Port();
    public void set_Port(string value);
    public virtual IPermission CreatePermission();
}
internal class System.Net.Sockets.AcceptAsyncResult : ContextAwareResult {
    internal AcceptAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.AcceptExDelegate : MulticastDelegate {
    public AcceptExDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket listenSocketHandle, SafeCloseSocket acceptSocketHandle, IntPtr buffer, int len, int localAddressLength, int remoteAddressLength, Int32& bytesReceived, SafeHandle overlapped);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket listenSocketHandle, SafeCloseSocket acceptSocketHandle, IntPtr buffer, int len, int localAddressLength, int remoteAddressLength, Int32& bytesReceived, SafeHandle overlapped, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& bytesReceived, IAsyncResult result);
}
internal class System.Net.Sockets.AcceptOverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal Byte[] Buffer { get; }
    internal int BytesTransferred { get; }
    unknown Socket AcceptSocket {internal set; }
    internal AcceptOverlappedAsyncResult(Socket listenSocket, object asyncState, AsyncCallback asyncCallback);
    internal virtual object PostCompletion(int numBytes);
    internal void SetUnmanagedStructures(Byte[] buffer, int addressBufferLength);
    internal Byte[] get_Buffer();
    internal int get_BytesTransferred();
    internal void set_AcceptSocket(Socket value);
}
public enum System.Net.Sockets.AddressFamily : Enum {
    public int value__;
    public static AddressFamily Unknown;
    public static AddressFamily Unspecified;
    public static AddressFamily Unix;
    public static AddressFamily InterNetwork;
    public static AddressFamily ImpLink;
    public static AddressFamily Pup;
    public static AddressFamily Chaos;
    public static AddressFamily NS;
    public static AddressFamily Ipx;
    public static AddressFamily Iso;
    public static AddressFamily Osi;
    public static AddressFamily Ecma;
    public static AddressFamily DataKit;
    public static AddressFamily Ccitt;
    public static AddressFamily Sna;
    public static AddressFamily DecNet;
    public static AddressFamily DataLink;
    public static AddressFamily Lat;
    public static AddressFamily HyperChannel;
    public static AddressFamily AppleTalk;
    public static AddressFamily NetBios;
    public static AddressFamily VoiceView;
    public static AddressFamily FireFox;
    public static AddressFamily Banyan;
    public static AddressFamily Atm;
    public static AddressFamily InterNetworkV6;
    public static AddressFamily Cluster;
    public static AddressFamily Ieee12844;
    public static AddressFamily Irda;
    public static AddressFamily NetworkDesigners;
    public static AddressFamily Max;
}
[FlagsAttribute]
internal enum System.Net.Sockets.AsyncEventBits : Enum {
    public int value__;
    public static AsyncEventBits FdNone;
    public static AsyncEventBits FdRead;
    public static AsyncEventBits FdWrite;
    public static AsyncEventBits FdOob;
    public static AsyncEventBits FdAccept;
    public static AsyncEventBits FdConnect;
    public static AsyncEventBits FdClose;
    public static AsyncEventBits FdQos;
    public static AsyncEventBits FdGroupQos;
    public static AsyncEventBits FdRoutingInterfaceChange;
    public static AsyncEventBits FdAddressListChange;
    public static AsyncEventBits FdAllEvents;
}
internal enum System.Net.Sockets.AsyncEventBitsPos : Enum {
    public int value__;
    public static AsyncEventBitsPos FdReadBit;
    public static AsyncEventBitsPos FdWriteBit;
    public static AsyncEventBitsPos FdOobBit;
    public static AsyncEventBitsPos FdAcceptBit;
    public static AsyncEventBitsPos FdConnectBit;
    public static AsyncEventBitsPos FdCloseBit;
    public static AsyncEventBitsPos FdQosBit;
    public static AsyncEventBitsPos FdGroupQosBit;
    public static AsyncEventBitsPos FdRoutingInterfaceChangeBit;
    public static AsyncEventBitsPos FdAddressListChangeBit;
    public static AsyncEventBitsPos FdMaxEvents;
}
internal class System.Net.Sockets.BaseOverlappedAsyncResult : ContextAwareResult {
    internal SafeHandle OverlappedHandle { get; }
    internal BaseOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    internal BaseOverlappedAsyncResult(Socket socket);
    private static BaseOverlappedAsyncResult();
    internal virtual object PostCompletion(int numBytes);
    internal void SetUnmanagedStructures(object objectsToPin);
    protected void SetupCache(OverlappedCache& overlappedCache);
    protected void PinUnmanagedObjects(object objectsToPin);
    internal void ExtractCache(OverlappedCache& overlappedCache);
    internal SocketError CheckAsyncCallOverlappedResult(SocketError errorCode);
    internal SafeHandle get_OverlappedHandle();
    protected virtual void Cleanup();
    protected virtual void ForceReleaseUnmanagedStructures();
    protected virtual override void Finalize();
}
internal class System.Net.Sockets.ConnectAsyncResult : ContextAwareResult {
    internal EndPoint RemoteEndPoint { get; }
    internal ConnectAsyncResult(object myObject, EndPoint endPoint, object myState, AsyncCallback myCallBack);
    internal EndPoint get_RemoteEndPoint();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.ConnectExDelegate : MulticastDelegate {
    public ConnectExDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket socketHandle, IntPtr socketAddress, int socketAddressSize, IntPtr buffer, int dataLength, Int32& bytesSent, SafeHandle overlapped);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr socketAddress, int socketAddressSize, IntPtr buffer, int dataLength, Int32& bytesSent, SafeHandle overlapped, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& bytesSent, IAsyncResult result);
}
internal class System.Net.Sockets.ConnectOverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal EndPoint RemoteEndPoint { get; }
    internal ConnectOverlappedAsyncResult(Socket socket, EndPoint endPoint, object asyncState, AsyncCallback asyncCallback);
    internal virtual object PostCompletion(int numBytes);
    internal EndPoint get_RemoteEndPoint();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.DisconnectExDelegate : MulticastDelegate {
    public DisconnectExDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket socketHandle, SafeHandle overlapped, int flags, int reserved);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, SafeHandle overlapped, int flags, int reserved, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.DisconnectExDelegate_Blocking : MulticastDelegate {
    public DisconnectExDelegate_Blocking(object object, IntPtr method);
    public virtual bool Invoke(IntPtr socketHandle, IntPtr overlapped, int flags, int reserved);
    public virtual IAsyncResult BeginInvoke(IntPtr socketHandle, IntPtr overlapped, int flags, int reserved, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Sockets.DisconnectOverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal DisconnectOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    internal virtual object PostCompletion(int numBytes);
}
internal class System.Net.Sockets.DynamicWinsockMethods : object {
    private static DynamicWinsockMethods();
    public static DynamicWinsockMethods GetMethods(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public T GetDelegate(SafeCloseSocket socketHandle);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.GetAcceptExSockaddrsDelegate : MulticastDelegate {
    public GetAcceptExSockaddrsDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength);
    public virtual IAsyncResult BeginInvoke(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength, AsyncCallback callback, object object);
    public virtual void EndInvoke(IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength, IAsyncResult result);
}
public enum System.Net.Sockets.IOControlCode : Enum {
    public long value__;
    public static IOControlCode AsyncIO;
    public static IOControlCode NonBlockingIO;
    public static IOControlCode DataToRead;
    public static IOControlCode OobDataRead;
    public static IOControlCode AssociateHandle;
    public static IOControlCode EnableCircularQueuing;
    public static IOControlCode Flush;
    public static IOControlCode GetBroadcastAddress;
    public static IOControlCode GetExtensionFunctionPointer;
    public static IOControlCode GetQos;
    public static IOControlCode GetGroupQos;
    public static IOControlCode MultipointLoopback;
    public static IOControlCode MulticastScope;
    public static IOControlCode SetQos;
    public static IOControlCode SetGroupQos;
    public static IOControlCode TranslateHandle;
    public static IOControlCode RoutingInterfaceQuery;
    public static IOControlCode RoutingInterfaceChange;
    public static IOControlCode AddressListQuery;
    public static IOControlCode AddressListChange;
    public static IOControlCode QueryTargetPnpHandle;
    public static IOControlCode NamespaceChange;
    public static IOControlCode AddressListSort;
    public static IOControlCode ReceiveAll;
    public static IOControlCode ReceiveAllMulticast;
    public static IOControlCode ReceiveAllIgmpMulticast;
    public static IOControlCode KeepAliveValues;
    public static IOControlCode AbsorbRouterAlert;
    public static IOControlCode UnicastInterface;
    public static IOControlCode LimitBroadcasts;
    public static IOControlCode BindToInterface;
    public static IOControlCode MulticastInterface;
    public static IOControlCode AddMulticastGroupOnInterface;
    public static IOControlCode DeleteMulticastGroupFromInterface;
}
internal static class System.Net.Sockets.IoctlSocketConstants : object {
    public static int FIONREAD;
    public static int FIONBIO;
    public static int FIOASYNC;
    public static int SIOGETEXTENSIONFUNCTIONPOINTER;
}
public class System.Net.Sockets.IPPacketInformation : ValueType {
    private IPAddress address;
    private int networkInterface;
    public IPAddress Address { get; }
    public int Interface { get; }
    internal IPPacketInformation(IPAddress address, int networkInterface);
    public IPAddress get_Address();
    public int get_Interface();
    public static bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public static bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
public enum System.Net.Sockets.IPProtectionLevel : Enum {
    public int value__;
    public static IPProtectionLevel Unspecified;
    public static IPProtectionLevel Unrestricted;
    public static IPProtectionLevel EdgeRestricted;
    public static IPProtectionLevel Restricted;
}
public class System.Net.Sockets.IPv6MulticastOption : object {
    public IPAddress Group { get; public set; }
    public long InterfaceIndex { get; public set; }
    public IPv6MulticastOption(IPAddress group, long ifindex);
    public IPv6MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public long get_InterfaceIndex();
    public void set_InterfaceIndex(long value);
}
public class System.Net.Sockets.LingerOption : object {
    public bool Enabled { get; public set; }
    public int LingerTime { get; public set; }
    public LingerOption(bool enable, int seconds);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_LingerTime();
    public void set_LingerTime(int value);
}
public class System.Net.Sockets.MulticastOption : object {
    public IPAddress Group { get; public set; }
    public IPAddress LocalAddress { get; public set; }
    public int InterfaceIndex { get; public set; }
    public MulticastOption(IPAddress group, IPAddress mcint);
    public MulticastOption(IPAddress group, int interfaceIndex);
    public MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public IPAddress get_LocalAddress();
    public void set_LocalAddress(IPAddress value);
    public int get_InterfaceIndex();
    public void set_InterfaceIndex(int value);
}
internal abstract class System.Net.Sockets.MultipleConnectAsync : object {
    protected SocketAsyncEventArgs userArgs;
    protected SocketAsyncEventArgs internalArgs;
    protected DnsEndPoint endPoint;
    protected IPAddress[] addressList;
    protected int nextAddress;
    public bool StartConnectAsync(SocketAsyncEventArgs args, DnsEndPoint endPoint);
    protected abstract virtual void OnSucceed();
    protected void Succeed();
    protected abstract virtual void OnFail(bool abortive);
    public void Cancel();
    protected abstract virtual IPAddress GetNextAddress(Socket& attemptSocket);
}
internal class System.Net.Sockets.MultipleSocketMultipleConnectAsync : MultipleConnectAsync {
    public MultipleSocketMultipleConnectAsync(SocketType socketType, ProtocolType protocolType);
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnSucceed();
    protected virtual void OnFail(bool abortive);
}
internal class System.Net.Sockets.NetworkEvents : ValueType {
    public AsyncEventBits Events;
    public Int32[] ErrorCodes;
}
public class System.Net.Sockets.NetworkStream : Stream {
    protected Socket Socket { get; }
    internal Socket InternalSocket { get; }
    protected bool Readable { get; protected set; }
    protected bool Writeable { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Connected { get; }
    public NetworkStream(Socket socket);
    public NetworkStream(Socket socket, bool ownsSocket);
    internal NetworkStream(NetworkStream networkStream, bool ownsSocket);
    public NetworkStream(Socket socket, FileAccess access);
    public NetworkStream(Socket socket, FileAccess access, bool ownsSocket);
    protected Socket get_Socket();
    internal Socket get_InternalSocket();
    internal void InternalAbortSocket();
    internal void ConvertToNotSocketOwner();
    protected bool get_Readable();
    protected void set_Readable(bool value);
    protected bool get_Writeable();
    protected void set_Writeable(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    internal void InitNetworkStream(Socket socket, FileAccess Access);
    internal bool PollRead();
    internal bool Poll(int microSeconds, SelectMode mode);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public void Close(int timeout);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal bool get_Connected();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal virtual void MultipleWrite(BufferOffsetSize[] buffers);
    internal virtual IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state);
    internal virtual void EndMultipleWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
}
internal class System.Net.Sockets.OverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal WSABuffer m_SingleBuffer;
    internal WSABuffer[] m_WSABuffers;
    internal SocketAddress SocketAddress { get; }
    internal SocketAddress SocketAddressOriginal { get; internal set; }
    internal OverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    internal IntPtr GetSocketAddressPtr();
    internal IntPtr GetSocketAddressSizePtr();
    internal SocketAddress get_SocketAddress();
    internal SocketAddress get_SocketAddressOriginal();
    internal void set_SocketAddressOriginal(SocketAddress value);
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, bool pinSocketAddress);
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, bool pinSocketAddress, OverlappedCache& overlappedCache);
    internal void SetUnmanagedStructures(BufferOffsetSize[] buffers);
    internal void SetUnmanagedStructures(BufferOffsetSize[] buffers, OverlappedCache& overlappedCache);
    internal void SetUnmanagedStructures(IList`1<ArraySegment`1<byte>> buffers);
    internal void SetUnmanagedStructures(IList`1<ArraySegment`1<byte>> buffers, OverlappedCache& overlappedCache);
    internal virtual object PostCompletion(int numBytes);
}
internal class System.Net.Sockets.OverlappedCache : object {
    internal Overlapped m_Overlapped;
    internal SafeNativeOverlapped m_NativeOverlapped;
    internal object m_PinnedObjects;
    internal Object[] m_PinnedObjectsArray;
    internal Overlapped Overlapped { get; }
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal object PinnedObjects { get; }
    internal Object[] PinnedObjectsArray { get; }
    internal OverlappedCache(Overlapped overlapped, Object[] pinnedObjectsArray, IOCompletionCallback callback);
    internal OverlappedCache(Overlapped overlapped, object pinnedObjects, IOCompletionCallback callback, bool alreadyTriedCast);
    internal Overlapped get_Overlapped();
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal object get_PinnedObjects();
    internal Object[] get_PinnedObjectsArray();
    internal void Free();
    internal static void InterlockedFree(OverlappedCache& overlappedCache);
    protected virtual override void Finalize();
}
public enum System.Net.Sockets.ProtocolFamily : Enum {
    public int value__;
    public static ProtocolFamily Unknown;
    public static ProtocolFamily Unspecified;
    public static ProtocolFamily Unix;
    public static ProtocolFamily InterNetwork;
    public static ProtocolFamily ImpLink;
    public static ProtocolFamily Pup;
    public static ProtocolFamily Chaos;
    public static ProtocolFamily NS;
    public static ProtocolFamily Ipx;
    public static ProtocolFamily Iso;
    public static ProtocolFamily Osi;
    public static ProtocolFamily Ecma;
    public static ProtocolFamily DataKit;
    public static ProtocolFamily Ccitt;
    public static ProtocolFamily Sna;
    public static ProtocolFamily DecNet;
    public static ProtocolFamily DataLink;
    public static ProtocolFamily Lat;
    public static ProtocolFamily HyperChannel;
    public static ProtocolFamily AppleTalk;
    public static ProtocolFamily NetBios;
    public static ProtocolFamily VoiceView;
    public static ProtocolFamily FireFox;
    public static ProtocolFamily Banyan;
    public static ProtocolFamily Atm;
    public static ProtocolFamily InterNetworkV6;
    public static ProtocolFamily Cluster;
    public static ProtocolFamily Ieee12844;
    public static ProtocolFamily Irda;
    public static ProtocolFamily NetworkDesigners;
    public static ProtocolFamily Max;
}
public enum System.Net.Sockets.ProtocolType : Enum {
    public int value__;
    public static ProtocolType IP;
    public static ProtocolType IPv6HopByHopOptions;
    public static ProtocolType Icmp;
    public static ProtocolType Igmp;
    public static ProtocolType Ggp;
    public static ProtocolType IPv4;
    public static ProtocolType Tcp;
    public static ProtocolType Pup;
    public static ProtocolType Udp;
    public static ProtocolType Idp;
    public static ProtocolType IPv6;
    public static ProtocolType IPv6RoutingHeader;
    public static ProtocolType IPv6FragmentHeader;
    public static ProtocolType IPSecEncapsulatingSecurityPayload;
    public static ProtocolType IPSecAuthenticationHeader;
    public static ProtocolType IcmpV6;
    public static ProtocolType IPv6NoNextHeader;
    public static ProtocolType IPv6DestinationOptions;
    public static ProtocolType ND;
    public static ProtocolType Raw;
    public static ProtocolType Unspecified;
    public static ProtocolType Ipx;
    public static ProtocolType Spx;
    public static ProtocolType SpxII;
    public static ProtocolType Unknown;
}
internal class System.Net.Sockets.ReceiveMessageOverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal SocketAddress SocketAddressOriginal;
    internal SocketAddress m_SocketAddress;
    internal Byte[] m_MessageBuffer;
    internal SocketFlags m_flags;
    internal IPPacketInformation m_IPPacketInformation;
    internal SocketAddress SocketAddress { get; }
    internal ReceiveMessageOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    private static ReceiveMessageOverlappedAsyncResult();
    internal IntPtr GetSocketAddressSizePtr();
    internal SocketAddress get_SocketAddress();
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, SocketFlags socketFlags);
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, SocketFlags socketFlags, OverlappedCache& overlappedCache);
    internal void SyncReleaseUnmanagedStructures();
    protected virtual void ForceReleaseUnmanagedStructures();
    internal virtual object PostCompletion(int numBytes);
}
public enum System.Net.Sockets.SelectMode : Enum {
    public int value__;
    public static SelectMode SelectRead;
    public static SelectMode SelectWrite;
    public static SelectMode SelectError;
}
public class System.Net.Sockets.SendPacketsElement : object {
    internal string m_FilePath;
    internal Byte[] m_Buffer;
    internal int m_Offset;
    internal int m_Count;
    internal TransmitPacketsElementFlags m_Flags;
    public string FilePath { get; }
    public Byte[] Buffer { get; }
    public int Count { get; }
    public int Offset { get; }
    public bool EndOfPacket { get; }
    public SendPacketsElement(string filepath);
    public SendPacketsElement(string filepath, int offset, int count);
    public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
    public SendPacketsElement(Byte[] buffer);
    public SendPacketsElement(Byte[] buffer, int offset, int count);
    public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket);
    public string get_FilePath();
    public Byte[] get_Buffer();
    public int get_Count();
    public int get_Offset();
    public bool get_EndOfPacket();
}
internal class System.Net.Sockets.SingleSocketMultipleConnectAsync : MultipleConnectAsync {
    public SingleSocketMultipleConnectAsync(Socket socket, bool userSocket);
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnFail(bool abortive);
    protected virtual void OnSucceed();
}
public class System.Net.Sockets.Socket : object {
    internal static int DefaultCloseTimeout;
    internal EndPoint m_RightEndPoint;
    internal EndPoint m_RemoteEndPoint;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) UseOverlappedIO;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv4;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_SupportsIPv6;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_OSSupportsIPv6;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_Initialized;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_PerfCountersEnabled;
    [ObsoleteAttribute("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv4 { get; }
    public static bool OSSupportsIPv4 { get; }
    [ObsoleteAttribute("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static bool SupportsIPv6 { get; }
    internal static bool LegacySupportsIPv6 { get; }
    public static bool OSSupportsIPv6 { get; }
    public int Available { get; }
    public EndPoint LocalEndPoint { get; }
    public EndPoint RemoteEndPoint { get; }
    public IntPtr Handle { get; }
    internal SafeCloseSocket SafeHandle { get; }
    public bool Blocking { get; public set; }
    public bool UseOnlyOverlappedIO { get; public set; }
    public bool Connected { get; }
    public AddressFamily AddressFamily { get; }
    public SocketType SocketType { get; }
    public ProtocolType ProtocolType { get; }
    public bool IsBound { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool DualMode { get; public set; }
    internal bool CleanedUp { get; }
    internal TransportType Transport { get; }
    public Socket(SocketType socketType, ProtocolType protocolType);
    public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public Socket(SocketInformation socketInformation);
    private static Socket();
    public static bool get_SupportsIPv4();
    public static bool get_OSSupportsIPv4();
    public static bool get_SupportsIPv6();
    internal static bool get_LegacySupportsIPv6();
    public static bool get_OSSupportsIPv6();
    public int get_Available();
    public EndPoint get_LocalEndPoint();
    public EndPoint get_RemoteEndPoint();
    public IntPtr get_Handle();
    internal SafeCloseSocket get_SafeHandle();
    public bool get_Blocking();
    public void set_Blocking(bool value);
    public bool get_UseOnlyOverlappedIO();
    public void set_UseOnlyOverlappedIO(bool value);
    public bool get_Connected();
    public AddressFamily get_AddressFamily();
    public SocketType get_SocketType();
    public ProtocolType get_ProtocolType();
    public bool get_IsBound();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_DualMode();
    public void set_DualMode(bool value);
    internal bool CanTryAddressFamily(AddressFamily family);
    public void Bind(EndPoint localEP);
    internal void InternalBind(EndPoint localEP);
    public void Connect(EndPoint remoteEP);
    public void Connect(IPAddress address, int port);
    public void Connect(string host, int port);
    public void Connect(IPAddress[] addresses, int port);
    public void Close();
    public void Close(int timeout);
    public void Listen(int backlog);
    public Socket Accept();
    public int Send(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, SocketFlags socketFlags);
    public int Send(Byte[] buffer);
    public int Send(IList`1<ArraySegment`1<byte>> buffers);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public void SendFile(string fileName);
    public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, EndPoint remoteEP);
    public int Receive(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, SocketFlags socketFlags);
    public int Receive(Byte[] buffer);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP);
    public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    internal int IOControl(IOControlCode ioControlCode, IntPtr optionInValue, int inValueSize, IntPtr optionOutValue, int outValueSize);
    public void SetIPProtectionLevel(IPProtectionLevel level);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
    public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
    public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
    public bool Poll(int microSeconds, SelectMode mode);
    public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
    public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    public SocketInformation DuplicateAndClose(int targetProcessId);
    internal IAsyncResult UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state);
    public void Disconnect(bool reuseSocket);
    public void EndConnect(IAsyncResult asyncResult);
    public void EndDisconnect(IAsyncResult asyncResult);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndSend(IAsyncResult asyncResult);
    public int EndSend(IAsyncResult asyncResult, SocketError& errorCode);
    public void EndSendFile(IAsyncResult asyncResult);
    public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);
    public int EndSendTo(IAsyncResult asyncResult);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndReceive(IAsyncResult asyncResult);
    public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode);
    public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation);
    public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint);
    public IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);
    public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);
    public Socket EndAccept(IAsyncResult asyncResult);
    public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult);
    public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult);
    public void Shutdown(SocketShutdown how);
    internal void GetAcceptExSockaddrs(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength);
    internal bool get_CleanedUp();
    internal TransportType get_Transport();
    internal static void InitializeSockets();
    internal void InternalConnect(EndPoint remoteEP);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal void InternalShutdown(SocketShutdown how);
    internal void SetReceivingPacketInformation();
    internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent);
    internal void InternalSetBlocking(bool desired);
    internal void MultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags);
    internal IAsyncResult BeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginMultipleSend(BufferOffsetSize[] buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal int EndMultipleSend(IAsyncResult asyncResult);
    internal Socket UpdateAcceptSocket(Socket socket, EndPoint remoteEP, bool needCancelSelect);
    internal void SetToConnected();
    internal void SetToDisconnected();
    internal void UpdateStatusAfterSocketError(SocketException socketException);
    internal void UpdateStatusAfterSocketError(SocketError errorCode);
    internal void BindToCompletionPort();
    public bool AcceptAsync(SocketAsyncEventArgs e);
    public bool ConnectAsync(SocketAsyncEventArgs e);
    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
    public static void CancelConnectAsync(SocketAsyncEventArgs e);
    public bool DisconnectAsync(SocketAsyncEventArgs e);
    public bool ReceiveAsync(SocketAsyncEventArgs e);
    public bool ReceiveFromAsync(SocketAsyncEventArgs e);
    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
    public bool SendAsync(SocketAsyncEventArgs e);
    public bool SendPacketsAsync(SocketAsyncEventArgs e);
    public bool SendToAsync(SocketAsyncEventArgs e);
    internal Task`1<Socket> AcceptAsync(Socket acceptSocket);
    internal Task ConnectAsync(EndPoint remoteEP);
    internal Task ConnectAsync(IPAddress address, int port);
    internal Task ConnectAsync(IPAddress[] addresses, int port);
    internal Task ConnectAsync(string host, int port);
    internal Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream);
    internal Task`1<int> ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    internal Task`1<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    internal Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    internal Task`1<int> SendAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream);
    internal Task`1<int> SendAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    internal Task`1<int> SendToAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
}
public class System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
    internal static int s_ControlDataSize;
    internal static int s_ControlDataIPv6Size;
    internal static int s_WSAMsgSize;
    internal Socket m_AcceptSocket;
    internal Byte[] m_Buffer;
    internal WSABuffer m_WSABuffer;
    internal IntPtr m_PtrSingleBuffer;
    internal int m_Count;
    internal int m_Offset;
    internal IList`1<ArraySegment`1<byte>> m_BufferList;
    internal WSABuffer[] m_WSABufferArray;
    internal TransmitFileOptions m_SendPacketsFlags;
    internal int m_SendPacketsSendSize;
    internal SendPacketsElement[] m_SendPacketsElements;
    internal int m_SendPacketsElementsFileCount;
    internal int m_SendPacketsElementsBufferCount;
    internal SocketFlags m_SocketFlags;
    internal Byte[] m_AcceptBuffer;
    internal int m_AcceptAddressBufferCount;
    internal IntPtr m_PtrAcceptBuffer;
    internal SocketAddress m_SocketAddress;
    internal IntPtr m_PtrSocketAddressBuffer;
    internal IntPtr m_PtrSocketAddressBufferSize;
    internal IntPtr m_PtrWSAMessageBuffer;
    internal IntPtr m_PtrControlBuffer;
    internal FileStream[] m_SendPacketsFileStreams;
    internal SafeHandle[] m_SendPacketsFileHandles;
    internal TransmitPacketsElement[] m_SendPacketsDescriptor;
    internal IntPtr m_PtrSendPacketsDescriptor;
    internal SafeNativeOverlapped m_PtrNativeOverlapped;
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { get; public set; }
    public Socket AcceptSocket { get; public set; }
    public Socket ConnectSocket { get; }
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public IList`1<ArraySegment`1<byte>> BufferList { get; public set; }
    public int BytesTransferred { get; }
    public bool DisconnectReuseSocket { get; public set; }
    public SocketAsyncOperation LastOperation { get; }
    public IPPacketInformation ReceiveMessageFromPacketInfo { get; }
    public EndPoint RemoteEndPoint { get; public set; }
    public SendPacketsElement[] SendPacketsElements { get; public set; }
    public TransmitFileOptions SendPacketsFlags { get; public set; }
    public int SendPacketsSendSize { get; public set; }
    public SocketError SocketError { get; public set; }
    public Exception ConnectByNameError { get; }
    public SocketFlags SocketFlags { get; public set; }
    public object UserToken { get; public set; }
    private static SocketAsyncEventArgs();
    [CompilerGeneratedAttribute]
public SocketClientAccessPolicyProtocol get_SocketClientAccessPolicyProtocol();
    [CompilerGeneratedAttribute]
public void set_SocketClientAccessPolicyProtocol(SocketClientAccessPolicyProtocol value);
    public Socket get_AcceptSocket();
    public void set_AcceptSocket(Socket value);
    public Socket get_ConnectSocket();
    public Byte[] get_Buffer();
    public int get_Offset();
    public int get_Count();
    public IList`1<ArraySegment`1<byte>> get_BufferList();
    public void set_BufferList(IList`1<ArraySegment`1<byte>> value);
    public int get_BytesTransferred();
    public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    protected virtual void OnCompleted(SocketAsyncEventArgs e);
    public bool get_DisconnectReuseSocket();
    public void set_DisconnectReuseSocket(bool value);
    public SocketAsyncOperation get_LastOperation();
    public IPPacketInformation get_ReceiveMessageFromPacketInfo();
    public EndPoint get_RemoteEndPoint();
    public void set_RemoteEndPoint(EndPoint value);
    public SendPacketsElement[] get_SendPacketsElements();
    public void set_SendPacketsElements(SendPacketsElement[] value);
    public TransmitFileOptions get_SendPacketsFlags();
    public void set_SendPacketsFlags(TransmitFileOptions value);
    public int get_SendPacketsSendSize();
    public void set_SendPacketsSendSize(int value);
    public SocketError get_SocketError();
    public void set_SocketError(SocketError value);
    public Exception get_ConnectByNameError();
    public SocketFlags get_SocketFlags();
    public void set_SocketFlags(SocketFlags value);
    public object get_UserToken();
    public void set_UserToken(object value);
    public void SetBuffer(Byte[] buffer, int offset, int count);
    public void SetBuffer(int offset, int count);
    internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void SetResults(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void Complete();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal void StartOperationCommon(Socket socket);
    internal void StartOperationAccept();
    internal void StartOperationConnect();
    internal void StartOperationWrapperConnect(MultipleConnectAsync args);
    internal void CancelConnectAsync();
    internal void StartOperationDisconnect();
    internal void StartOperationReceive();
    internal void StartOperationReceiveFrom();
    internal void StartOperationReceiveMessageFrom();
    internal void StartOperationSend();
    internal void StartOperationSendPackets();
    internal void StartOperationSendTo();
    internal void LogBuffer(int size);
    internal void LogSendPacketsBuffers(int size);
    internal void UpdatePerfCounters(int size, bool sendOp);
    internal void FinishOperationSyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void FinishConnectByNameSyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishWrapperConnectSuccess(Socket connectSocket, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationSuccess(SocketError socketError, int bytesTransferred, SocketFlags flags);
}
public enum System.Net.Sockets.SocketAsyncOperation : Enum {
    public int value__;
    public static SocketAsyncOperation None;
    public static SocketAsyncOperation Accept;
    public static SocketAsyncOperation Connect;
    public static SocketAsyncOperation Disconnect;
    public static SocketAsyncOperation Receive;
    public static SocketAsyncOperation ReceiveFrom;
    public static SocketAsyncOperation ReceiveMessageFrom;
    public static SocketAsyncOperation Send;
    public static SocketAsyncOperation SendPackets;
    public static SocketAsyncOperation SendTo;
}
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public enum System.Net.Sockets.SocketClientAccessPolicyProtocol : Enum {
    public int value__;
    public static SocketClientAccessPolicyProtocol Tcp;
    public static SocketClientAccessPolicyProtocol Http;
}
public enum System.Net.Sockets.SocketError : Enum {
    public int value__;
    public static SocketError Success;
    public static SocketError SocketError;
    public static SocketError Interrupted;
    public static SocketError AccessDenied;
    public static SocketError Fault;
    public static SocketError InvalidArgument;
    public static SocketError TooManyOpenSockets;
    public static SocketError WouldBlock;
    public static SocketError InProgress;
    public static SocketError AlreadyInProgress;
    public static SocketError NotSocket;
    public static SocketError DestinationAddressRequired;
    public static SocketError MessageSize;
    public static SocketError ProtocolType;
    public static SocketError ProtocolOption;
    public static SocketError ProtocolNotSupported;
    public static SocketError SocketNotSupported;
    public static SocketError OperationNotSupported;
    public static SocketError ProtocolFamilyNotSupported;
    public static SocketError AddressFamilyNotSupported;
    public static SocketError AddressAlreadyInUse;
    public static SocketError AddressNotAvailable;
    public static SocketError NetworkDown;
    public static SocketError NetworkUnreachable;
    public static SocketError NetworkReset;
    public static SocketError ConnectionAborted;
    public static SocketError ConnectionReset;
    public static SocketError NoBufferSpaceAvailable;
    public static SocketError IsConnected;
    public static SocketError NotConnected;
    public static SocketError Shutdown;
    public static SocketError TimedOut;
    public static SocketError ConnectionRefused;
    public static SocketError HostDown;
    public static SocketError HostUnreachable;
    public static SocketError ProcessLimit;
    public static SocketError SystemNotReady;
    public static SocketError VersionNotSupported;
    public static SocketError NotInitialized;
    public static SocketError Disconnecting;
    public static SocketError TypeNotFound;
    public static SocketError HostNotFound;
    public static SocketError TryAgain;
    public static SocketError NoRecovery;
    public static SocketError NoData;
    public static SocketError IOPending;
    public static SocketError OperationAborted;
}
public class System.Net.Sockets.SocketException : Win32Exception {
    public int ErrorCode { get; }
    public string Message { get; }
    public SocketError SocketErrorCode { get; }
    internal SocketException(EndPoint endPoint);
    public SocketException(int errorCode);
    internal SocketException(int errorCode, EndPoint endPoint);
    internal SocketException(SocketError socketError);
    protected SocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
    public virtual string get_Message();
    public SocketError get_SocketErrorCode();
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketFlags : Enum {
    public int value__;
    public static SocketFlags None;
    public static SocketFlags OutOfBand;
    public static SocketFlags Peek;
    public static SocketFlags DontRoute;
    public static SocketFlags MaxIOVectorLength;
    public static SocketFlags Truncated;
    public static SocketFlags ControlDataTruncated;
    public static SocketFlags Broadcast;
    public static SocketFlags Multicast;
    public static SocketFlags Partial;
}
public class System.Net.Sockets.SocketInformation : ValueType {
    private Byte[] protocolInformation;
    private SocketInformationOptions options;
    [OptionalFieldAttribute]
private EndPoint remoteEndPoint;
    public Byte[] ProtocolInformation { get; public set; }
    public SocketInformationOptions Options { get; public set; }
    internal bool IsNonBlocking { get; internal set; }
    internal bool IsConnected { get; internal set; }
    internal bool IsListening { get; internal set; }
    internal bool UseOnlyOverlappedIO { get; internal set; }
    internal EndPoint RemoteEndPoint { get; internal set; }
    public Byte[] get_ProtocolInformation();
    public void set_ProtocolInformation(Byte[] value);
    public SocketInformationOptions get_Options();
    public void set_Options(SocketInformationOptions value);
    internal bool get_IsNonBlocking();
    internal void set_IsNonBlocking(bool value);
    internal bool get_IsConnected();
    internal void set_IsConnected(bool value);
    internal bool get_IsListening();
    internal void set_IsListening(bool value);
    internal bool get_UseOnlyOverlappedIO();
    internal void set_UseOnlyOverlappedIO(bool value);
    internal EndPoint get_RemoteEndPoint();
    internal void set_RemoteEndPoint(EndPoint value);
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketInformationOptions : Enum {
    public int value__;
    public static SocketInformationOptions NonBlocking;
    public static SocketInformationOptions Connected;
    public static SocketInformationOptions Listening;
    public static SocketInformationOptions UseOnlyOverlappedIO;
}
public enum System.Net.Sockets.SocketOptionLevel : Enum {
    public int value__;
    public static SocketOptionLevel Socket;
    public static SocketOptionLevel IP;
    public static SocketOptionLevel IPv6;
    public static SocketOptionLevel Tcp;
    public static SocketOptionLevel Udp;
}
public enum System.Net.Sockets.SocketOptionName : Enum {
    public int value__;
    public static SocketOptionName Debug;
    public static SocketOptionName AcceptConnection;
    public static SocketOptionName ReuseAddress;
    public static SocketOptionName KeepAlive;
    public static SocketOptionName DontRoute;
    public static SocketOptionName Broadcast;
    public static SocketOptionName UseLoopback;
    public static SocketOptionName Linger;
    public static SocketOptionName OutOfBandInline;
    public static SocketOptionName DontLinger;
    public static SocketOptionName ExclusiveAddressUse;
    public static SocketOptionName SendBuffer;
    public static SocketOptionName ReceiveBuffer;
    public static SocketOptionName SendLowWater;
    public static SocketOptionName ReceiveLowWater;
    public static SocketOptionName SendTimeout;
    public static SocketOptionName ReceiveTimeout;
    public static SocketOptionName Error;
    public static SocketOptionName Type;
    public static SocketOptionName ReuseUnicastPort;
    public static SocketOptionName MaxConnections;
    public static SocketOptionName IPOptions;
    public static SocketOptionName HeaderIncluded;
    public static SocketOptionName TypeOfService;
    public static SocketOptionName IpTimeToLive;
    public static SocketOptionName MulticastInterface;
    public static SocketOptionName MulticastTimeToLive;
    public static SocketOptionName MulticastLoopback;
    public static SocketOptionName AddMembership;
    public static SocketOptionName DropMembership;
    public static SocketOptionName DontFragment;
    public static SocketOptionName AddSourceMembership;
    public static SocketOptionName DropSourceMembership;
    public static SocketOptionName BlockSource;
    public static SocketOptionName UnblockSource;
    public static SocketOptionName PacketInformation;
    public static SocketOptionName HopLimit;
    public static SocketOptionName IPProtectionLevel;
    public static SocketOptionName IPv6Only;
    public static SocketOptionName NoDelay;
    public static SocketOptionName BsdUrgent;
    public static SocketOptionName Expedited;
    public static SocketOptionName NoChecksum;
    public static SocketOptionName ChecksumCoverage;
    public static SocketOptionName UpdateAcceptContext;
    public static SocketOptionName UpdateConnectContext;
}
public class System.Net.Sockets.SocketReceiveFromResult : ValueType {
    public int ReceivedBytes;
    public EndPoint RemoteEndPoint;
}
public class System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
    public int ReceivedBytes;
    public SocketFlags SocketFlags;
    public EndPoint RemoteEndPoint;
    public IPPacketInformation PacketInformation;
}
public enum System.Net.Sockets.SocketShutdown : Enum {
    public int value__;
    public static SocketShutdown Receive;
    public static SocketShutdown Send;
    public static SocketShutdown Both;
}
[ExtensionAttribute]
public static class System.Net.Sockets.SocketTaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket);
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, EndPoint remoteEP);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress address, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress[] addresses, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, string host, int port);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
}
public enum System.Net.Sockets.SocketType : Enum {
    public int value__;
    public static SocketType Stream;
    public static SocketType Dgram;
    public static SocketType Raw;
    public static SocketType Rdm;
    public static SocketType Seqpacket;
    public static SocketType Unknown;
}
public class System.Net.Sockets.TcpClient : object {
    public Socket Client { get; public set; }
    protected bool Active { get; protected set; }
    public int Available { get; }
    public bool Connected { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public TcpClient(IPEndPoint localEP);
    public TcpClient(AddressFamily family);
    public TcpClient(string hostname, int port);
    internal TcpClient(Socket acceptedSocket);
    public Socket get_Client();
    public void set_Client(Socket value);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public bool get_Connected();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void Connect(string hostname, int port);
    public void Connect(IPAddress address, int port);
    public void Connect(IPEndPoint remoteEP);
    public void Connect(IPAddress[] ipAddresses, int port);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public void EndConnect(IAsyncResult asyncResult);
    public Task ConnectAsync(IPAddress address, int port);
    public Task ConnectAsync(string host, int port);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    public NetworkStream GetStream();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
}
public class System.Net.Sockets.TcpListener : object {
    public Socket Server { get; }
    protected bool Active { get; }
    public EndPoint LocalEndpoint { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public TcpListener(IPEndPoint localEP);
    public TcpListener(IPAddress localaddr, int port);
    [ObsoleteAttribute("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public TcpListener(int port);
    public static TcpListener Create(int port);
    public Socket get_Server();
    protected bool get_Active();
    public EndPoint get_LocalEndpoint();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void AllowNatTraversal(bool allowed);
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public bool Pending();
    public Socket AcceptSocket();
    public TcpClient AcceptTcpClient();
    public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state);
    public Socket EndAcceptSocket(IAsyncResult asyncResult);
    public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state);
    public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult);
    public Task`1<Socket> AcceptSocketAsync();
    public Task`1<TcpClient> AcceptTcpClientAsync();
}
internal class System.Net.Sockets.TimeValue : ValueType {
    public int Seconds;
    public int Microseconds;
}
[FlagsAttribute]
public enum System.Net.Sockets.TransmitFileOptions : Enum {
    public int value__;
    public static TransmitFileOptions UseDefaultWorkerThread;
    public static TransmitFileOptions Disconnect;
    public static TransmitFileOptions ReuseSocket;
    public static TransmitFileOptions WriteBehind;
    public static TransmitFileOptions UseSystemThread;
    public static TransmitFileOptions UseKernelApc;
}
internal class System.Net.Sockets.TransmitFileOverlappedAsyncResult : BaseOverlappedAsyncResult {
    internal TransmitFileBuffers TransmitFileBuffers { get; }
    internal TransmitFileOptions Flags { get; }
    internal TransmitFileOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    internal TransmitFileOverlappedAsyncResult(Socket socket);
    internal void SetUnmanagedStructures(Byte[] preBuffer, Byte[] postBuffer, FileStream fileStream, TransmitFileOptions flags, bool sync);
    internal void SetUnmanagedStructures(Byte[] preBuffer, Byte[] postBuffer, FileStream fileStream, TransmitFileOptions flags, OverlappedCache& overlappedCache);
    protected virtual void ForceReleaseUnmanagedStructures();
    internal void SyncReleaseUnmanagedStructures();
    internal TransmitFileBuffers get_TransmitFileBuffers();
    internal TransmitFileOptions get_Flags();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.TransmitPacketsDelegate : MulticastDelegate {
    public TransmitPacketsDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket socketHandle, IntPtr packetArray, int elementCount, int sendSize, SafeNativeOverlapped overlapped, TransmitFileOptions flags);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr packetArray, int elementCount, int sendSize, SafeNativeOverlapped overlapped, TransmitFileOptions flags, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Net.Sockets.UdpClient : object {
    public Socket Client { get; public set; }
    protected bool Active { get; protected set; }
    public int Available { get; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public UdpClient(AddressFamily family);
    public UdpClient(int port);
    public UdpClient(int port, AddressFamily family);
    public UdpClient(IPEndPoint localEP);
    public UdpClient(string hostname, int port);
    public Socket get_Client();
    public void set_Client(Socket value);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void AllowNatTraversal(bool allowed);
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Connect(string hostname, int port);
    public void Connect(IPAddress addr, int port);
    public void Connect(IPEndPoint endPoint);
    public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint);
    public int Send(Byte[] dgram, int bytes, string hostname, int port);
    public int Send(Byte[] dgram, int bytes);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    public int EndSend(IAsyncResult asyncResult);
    public Byte[] Receive(IPEndPoint& remoteEP);
    public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state);
    public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP);
    public void JoinMulticastGroup(IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
    public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
    public void DropMulticastGroup(IPAddress multicastAddr);
    public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port);
    public Task`1<UdpReceiveResult> ReceiveAsync();
}
public class System.Net.Sockets.UdpReceiveResult : ValueType {
    private Byte[] m_buffer;
    private IPEndPoint m_remoteEndPoint;
    public Byte[] Buffer { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public UdpReceiveResult(Byte[] buffer, IPEndPoint remoteEndPoint);
    public Byte[] get_Buffer();
    public IPEndPoint get_RemoteEndPoint();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UdpReceiveResult other);
    public static bool op_Equality(UdpReceiveResult left, UdpReceiveResult right);
    public static bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.WSARecvMsgDelegate : MulticastDelegate {
    public WSARecvMsgDelegate(object object, IntPtr method);
    public virtual SocketError Invoke(SafeCloseSocket socketHandle, IntPtr msg, Int32& bytesTransferred, SafeHandle overlapped, IntPtr completionRoutine);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr msg, Int32& bytesTransferred, SafeHandle overlapped, IntPtr completionRoutine, AsyncCallback callback, object object);
    public virtual SocketError EndInvoke(Int32& bytesTransferred, IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class System.Net.Sockets.WSARecvMsgDelegate_Blocking : MulticastDelegate {
    public WSARecvMsgDelegate_Blocking(object object, IntPtr method);
    public virtual SocketError Invoke(IntPtr socketHandle, IntPtr msg, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine);
    public virtual IAsyncResult BeginInvoke(IntPtr socketHandle, IntPtr msg, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine, AsyncCallback callback, object object);
    public virtual SocketError EndInvoke(Int32& bytesTransferred, IAsyncResult result);
}
internal class System.Net.SplitWritesState : object {
    internal bool IsDone { get; }
    internal SplitWritesState(BufferOffsetSize[] buffers);
    internal bool get_IsDone();
    internal BufferOffsetSize[] GetNextBuffers();
}
[DefaultMemberAttribute("Item")]
internal class System.Net.SpnDictionary : StringDictionary {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    internal SpnToken InternalGet(string canonicalKey);
    internal void InternalSet(string canonicalKey, SpnToken spnToken);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual bool ContainsKey(string key);
    public virtual bool ContainsValue(string value);
    public virtual void CopyTo(Array array, int index);
    [IteratorStateMachineAttribute("System.Net.SpnDictionary/<GetEnumerator>d__23")]
public virtual IEnumerator GetEnumerator();
    public virtual void Remove(string key);
}
internal class System.Net.SpnToken : object {
    internal bool IsTrusted { get; internal set; }
    internal string Spn { get; }
    internal SpnToken(string spn);
    internal SpnToken(string spn, bool trusted);
    internal bool get_IsTrusted();
    internal void set_IsTrusted(bool value);
    internal string get_Spn();
}
internal class System.Net.SSL_EXTRA_CERT_CHAIN_POLICY_PARA : ValueType {
    internal U u;
    internal int dwAuthType;
    internal UInt32 fdwChecks;
    internal Char* pwszServerName;
    internal SSL_EXTRA_CERT_CHAIN_POLICY_PARA(bool amIServer);
    private static SSL_EXTRA_CERT_CHAIN_POLICY_PARA();
}
internal class System.Net.SslConnectionInfo : object {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
    internal SslConnectionInfo(Byte[] nativeBuffer);
}
internal class System.Net.SslStreamContext : TransportContext {
    internal SslStreamContext(SslStream sslStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.SSPIAuthType : object {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    private static SSPIAuthType();
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, AuthIdentity& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SecureCredential& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext context, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& binding);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int SetContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Byte[] buffer);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SafeCloseHandle& phToken);
    public sealed virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    public sealed virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal class System.Net.SSPIHandle : ValueType {
    private IntPtr HandleHi;
    private IntPtr HandleLo;
    public bool IsZero { get; }
    public bool get_IsZero();
    [ReliabilityContractAttribute("3", "2")]
internal void SetToInvalid();
    public virtual string ToString();
}
internal interface System.Net.SSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, AuthIdentity& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SecureCredential& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public abstract virtual int EncryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public abstract virtual int DecryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public abstract virtual int MakeSignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public abstract virtual int VerifySignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public abstract virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer);
    public abstract virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SafeCloseHandle& phToken);
    public abstract virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    public abstract virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal class System.Net.SSPISecureChannelType : object {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    private static SSPISecureChannelType();
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, AuthIdentity& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SecureCredential& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, SecurityBuffer inputBuffer, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, SecurityBuffer[] inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecurityBufferDescriptor inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int SetContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Byte[] buffer);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SafeCloseHandle& phToken);
    public sealed virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
    public sealed virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer[] inputBuffers);
}
internal static class System.Net.SSPIWrapper : object {
    private static SSPIWrapper();
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface SecModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(SSPIInterface SecModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface SecModule, string package, CredentialUse intent, AuthIdentity& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface SecModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface SecModule, string package, CredentialUse intent, SecureCredential scc);
    internal static int InitializeSecurityContext(SSPIInterface SecModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int InitializeSecurityContext(SSPIInterface SecModule, SafeFreeCredentials credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface SecModule, SafeFreeCredentials& credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer inputBuffer, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface SecModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, SecurityBuffer[] inputBuffers, SecurityBuffer outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SSPIInterface SecModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers);
    internal static int ApplyControlToken(SSPIInterface SecModule, SafeDeleteContext& context, SecurityBuffer[] inputBuffers);
    public static int QuerySecurityContextToken(SSPIInterface SecModule, SafeDeleteContext context, SafeCloseHandle& token);
    public static int EncryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int DecryptMessage(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int ApplyAlertToken(SSPIInterface secModule, SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext, TlsAlertType alertType, TlsAlertMessage alertMessage);
    public static int ApplyShutdownToken(SSPIInterface secModule, SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext);
    internal static int MakeSignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static int VerifySignature(SSPIInterface secModule, SafeDeleteContext context, SecurityBuffer[] input, UInt32 sequenceNumber);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SSPIInterface SecModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static object QueryContextAttributes(SSPIInterface SecModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static object QueryContextAttributes(SSPIInterface SecModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Int32& errorCode);
    public static int SetContextAttributes(SSPIInterface SecModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, object value);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.StaticProxy : ProxyChain {
    internal StaticProxy(Uri destination, Uri proxy);
    protected virtual bool GetNextProxy(Uri& proxy);
}
internal class System.Net.StreamFramer : object {
    public FrameHeader ReadHeader { get; }
    public FrameHeader WriteHeader { get; }
    public Stream Transport { get; }
    public StreamFramer(Stream Transport);
    public FrameHeader get_ReadHeader();
    public FrameHeader get_WriteHeader();
    public Stream get_Transport();
    public Byte[] ReadMessage();
    public IAsyncResult BeginReadMessage(AsyncCallback asyncCallback, object stateObject);
    public Byte[] EndReadMessage(IAsyncResult asyncResult);
    public void WriteMessage(Byte[] message);
    public IAsyncResult BeginWriteMessage(Byte[] message, AsyncCallback asyncCallback, object stateObject);
    public void EndWriteMessage(IAsyncResult asyncResult);
}
internal class System.Net.StreamSizes : object {
    public int header;
    public int trailer;
    public int maximumMessage;
    public int buffersCount;
    public int blockSize;
    public static int SizeOf;
    internal StreamSizes(Byte[] memory);
    private static StreamSizes();
}
internal class System.Net.SyncMemoryStream : MemoryStream {
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal SyncMemoryStream(Byte[] bytes);
    internal SyncMemoryStream(int initialCapacity);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public sealed virtual void TrackRequestLifetime(long requestStartTimestamp);
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.SyncRequestContext : RequestContextBase {
    internal SyncRequestContext(int size);
    internal void Reset(int size);
    protected virtual void OnReleasePins();
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.SystemNetworkCredential : NetworkCredential {
    internal static SystemNetworkCredential defaultCredential;
    private static SystemNetworkCredential();
}
[FlagsAttribute]
internal enum System.Net.ThreadKinds : Enum {
    public int value__;
    public static ThreadKinds Unknown;
    public static ThreadKinds User;
    public static ThreadKinds System;
    public static ThreadKinds Sync;
    public static ThreadKinds Async;
    public static ThreadKinds Timer;
    public static ThreadKinds CompletionPort;
    public static ThreadKinds Worker;
    public static ThreadKinds Finalization;
    public static ThreadKinds Other;
    public static ThreadKinds OwnerMask;
    public static ThreadKinds SyncMask;
    public static ThreadKinds SourceMask;
    public static ThreadKinds SafeSources;
    public static ThreadKinds ThreadPool;
}
internal class System.Net.TimeoutValidator : ConfigurationValidatorBase {
    internal TimeoutValidator(bool zeroValid);
    public virtual bool CanValidate(Type type);
    public virtual void Validate(object value);
}
internal static class System.Net.TimerThread : object {
    private static TimerThread();
    internal static Queue CreateQueue(int durationMilliseconds);
    internal static Queue GetOrCreateQueue(int durationMilliseconds);
}
internal class System.Net.TlsStream : NetworkStream {
    internal WebExceptionStatus ExceptionStatus { get; }
    public bool DataAvailable { get; }
    public X509Certificate ClientCertificate { get; }
    public TlsStream(string destinationHost, NetworkStream networkStream, bool checkCertificateRevocationList, SslProtocols sslProtocols, X509CertificateCollection clientCertificates, ServicePoint servicePoint, object initiatingRequest, ExecutionContext executionContext);
    private static TlsStream();
    internal WebExceptionStatus get_ExceptionStatus();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_DataAvailable();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState);
    internal virtual IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState);
    internal virtual IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal virtual void MultipleWrite(BufferOffsetSize[] buffers);
    internal virtual IAsyncResult BeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginMultipleWrite(BufferOffsetSize[] buffers, AsyncCallback callback, object state);
    internal virtual void EndMultipleWrite(IAsyncResult asyncResult);
    public X509Certificate get_ClientCertificate();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal bool ProcessAuthentication(LazyAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingStringDictionary : StringDictionary {
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingStringDictionary(bool isReadOnly);
    internal bool get_IsChanged();
    internal void set_IsChanged(bool value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingValidationObjectDictionary : StringDictionary {
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingValidationObjectDictionary(IDictionary`2<string, ValidateAndParseValue> validators);
    [CompilerGeneratedAttribute]
internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal void set_IsChanged(bool value);
    internal object InternalGet(string key);
    internal void InternalSet(string key, object value);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
}
internal class System.Net.TransmitFileBuffers : object {
    internal IntPtr preBuffer;
    internal int preBufferLength;
    internal IntPtr postBuffer;
    internal int postBufferLength;
}
public abstract class System.Net.TransportContext : object {
    public abstract virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual IEnumerable`1<TokenBinding> GetTlsTokenBindings();
}
public enum System.Net.TransportType : Enum {
    public int value__;
    public static TransportType Udp;
    public static TransportType Connectionless;
    public static TransportType Tcp;
    public static TransportType ConnectionOriented;
    public static TransportType All;
}
internal enum System.Net.TriState : Enum {
    public int value__;
    public static TriState Unspecified;
    public static TriState False;
    public static TriState True;
}
internal class System.Net.TunnelStateObject : ValueType {
    internal Connection Connection;
    internal HttpWebRequest OriginalRequest;
    internal TunnelStateObject(HttpWebRequest r, Connection c);
}
internal class System.Net.UnlockConnectionDelegate : MulticastDelegate {
    public UnlockConnectionDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.Net.UnsafeNclNativeMethods : object {
    internal static int CLSCTX_SERVER;
    internal static IntPtr CreateSemaphore(IntPtr lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, IntPtr lpName);
    internal static bool ReleaseSemaphore(IntPtr hSemaphore, int lReleaseCount, IntPtr lpPreviousCount);
    internal static UInt32 GetCurrentThreadId();
    internal static UInt32 CancelIoEx(CriticalHandle handle, NativeOverlapped* overlapped);
    internal static UInt32 CancelIoEx(SafeHandle handle, IntPtr overlapped);
    internal static bool SetFileCompletionNotificationModes(CriticalHandle handle, FileCompletionNotificationModes modes);
    internal static IntPtr GetProcessHeap();
    internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
    [SecurityCriticalAttribute]
internal static IntPtr GetProcAddress(SafeLoadLibrary hModule, string entryPoint);
    [SecurityCriticalAttribute]
internal static IntPtr GetProcAddress(IntPtr hModule, string entryPoint);
    internal static void DebugBreak();
    public static void CoCreateInstance(Guid& clsid, IntPtr pUnkOuter, int context, Guid& iid, Object& o);
}
public class System.Net.UploadDataCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    internal UploadDataCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadDataCompletedEventHandler : MulticastDelegate {
    public UploadDataCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadDataCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadDataCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadFileCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    internal UploadFileCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadFileCompletedEventHandler : MulticastDelegate {
    public UploadFileCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadFileCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadFileCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadProgressChangedEventArgs : ProgressChangedEventArgs {
    public long BytesReceived { get; }
    public long TotalBytesToReceive { get; }
    public long BytesSent { get; }
    public long TotalBytesToSend { get; }
    internal UploadProgressChangedEventArgs(int progressPercentage, object userToken, long bytesSent, long totalBytesToSend, long bytesReceived, long totalBytesToReceive);
    public long get_BytesReceived();
    public long get_TotalBytesToReceive();
    public long get_BytesSent();
    public long get_TotalBytesToSend();
}
public class System.Net.UploadProgressChangedEventHandler : MulticastDelegate {
    public UploadProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadStringCompletedEventArgs : AsyncCompletedEventArgs {
    public string Result { get; }
    internal UploadStringCompletedEventArgs(string result, Exception exception, bool cancelled, object userToken);
    public string get_Result();
}
public class System.Net.UploadStringCompletedEventHandler : MulticastDelegate {
    public UploadStringCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadStringCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadStringCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Net.UploadValuesCompletedEventArgs : AsyncCompletedEventArgs {
    public Byte[] Result { get; }
    internal UploadValuesCompletedEventArgs(Byte[] result, Exception exception, bool cancelled, object userToken);
    public Byte[] get_Result();
}
public class System.Net.UploadValuesCompletedEventHandler : MulticastDelegate {
    public UploadValuesCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UploadValuesCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UploadValuesCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.ValidationHelper : object {
    public static String[] EmptyArray;
    internal static Char[] InvalidMethodChars;
    internal static Char[] InvalidParamChars;
    private static ValidationHelper();
    public static String[] MakeEmptyArrayNull(String[] stringArray);
    public static string MakeStringNull(string stringValue);
    public static string ExceptionMessage(Exception exception);
    public static string ToString(object objectValue);
    public static string HashString(object objectValue);
    public static bool IsInvalidHttpString(string stringValue);
    public static bool IsBlankString(string stringValue);
    public static bool ValidateTcpPort(int port);
    public static bool ValidateRange(int actual, int fromAllowed, int toAllowed);
    internal static void ValidateSegment(ArraySegment`1<byte> segment);
}
[ComVisibleAttribute("True")]
public class System.Net.WebClient : Component {
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public bool AllowReadStreamBuffering { get; public set; }
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public bool AllowWriteStreamBuffering { get; public set; }
    public Encoding Encoding { get; public set; }
    public string BaseAddress { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public NameValueCollection QueryString { get; public set; }
    public WebHeaderCollection ResponseHeaders { get; }
    public IWebProxy Proxy { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public bool IsBusy { get; }
    [CompilerGeneratedAttribute]
public bool get_AllowReadStreamBuffering();
    [CompilerGeneratedAttribute]
public void set_AllowReadStreamBuffering(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowWriteStreamBuffering();
    [CompilerGeneratedAttribute]
public void set_AllowWriteStreamBuffering(bool value);
    public void add_WriteStreamClosed(WriteStreamClosedEventHandler value);
    public void remove_WriteStreamClosed(WriteStreamClosedEventHandler value);
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
protected virtual void OnWriteStreamClosed(WriteStreamClosedEventArgs e);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_BaseAddress();
    public void set_BaseAddress(string value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    public NameValueCollection get_QueryString();
    public void set_QueryString(NameValueCollection value);
    public WebHeaderCollection get_ResponseHeaders();
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public RequestCachePolicy get_CachePolicy();
    public void set_CachePolicy(RequestCachePolicy value);
    public bool get_IsBusy();
    protected virtual WebRequest GetWebRequest(Uri address);
    protected virtual WebResponse GetWebResponse(WebRequest request);
    protected virtual WebResponse GetWebResponse(WebRequest request, IAsyncResult result);
    public Byte[] DownloadData(string address);
    public Byte[] DownloadData(Uri address);
    public void DownloadFile(string address, string fileName);
    public void DownloadFile(Uri address, string fileName);
    public Stream OpenRead(string address);
    public Stream OpenRead(Uri address);
    public Stream OpenWrite(string address);
    public Stream OpenWrite(Uri address);
    public Stream OpenWrite(string address, string method);
    public Stream OpenWrite(Uri address, string method);
    public Byte[] UploadData(string address, Byte[] data);
    public Byte[] UploadData(Uri address, Byte[] data);
    public Byte[] UploadData(string address, string method, Byte[] data);
    public Byte[] UploadData(Uri address, string method, Byte[] data);
    public Byte[] UploadFile(string address, string fileName);
    public Byte[] UploadFile(Uri address, string fileName);
    public Byte[] UploadFile(string address, string method, string fileName);
    public Byte[] UploadFile(Uri address, string method, string fileName);
    public Byte[] UploadValues(string address, NameValueCollection data);
    public Byte[] UploadValues(Uri address, NameValueCollection data);
    public Byte[] UploadValues(string address, string method, NameValueCollection data);
    public Byte[] UploadValues(Uri address, string method, NameValueCollection data);
    public string UploadString(string address, string data);
    public string UploadString(Uri address, string data);
    public string UploadString(string address, string method, string data);
    public string UploadString(Uri address, string method, string data);
    public string DownloadString(string address);
    public string DownloadString(Uri address);
    [CompilerGeneratedAttribute]
public void add_OpenReadCompleted(OpenReadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OpenReadCompleted(OpenReadCompletedEventHandler value);
    protected virtual void OnOpenReadCompleted(OpenReadCompletedEventArgs e);
    public void OpenReadAsync(Uri address);
    public void OpenReadAsync(Uri address, object userToken);
    [CompilerGeneratedAttribute]
public void add_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OpenWriteCompleted(OpenWriteCompletedEventHandler value);
    protected virtual void OnOpenWriteCompleted(OpenWriteCompletedEventArgs e);
    public void OpenWriteAsync(Uri address);
    public void OpenWriteAsync(Uri address, string method);
    public void OpenWriteAsync(Uri address, string method, object userToken);
    [CompilerGeneratedAttribute]
public void add_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadStringCompleted(DownloadStringCompletedEventHandler value);
    protected virtual void OnDownloadStringCompleted(DownloadStringCompletedEventArgs e);
    public void DownloadStringAsync(Uri address);
    public void DownloadStringAsync(Uri address, object userToken);
    [CompilerGeneratedAttribute]
public void add_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadDataCompleted(DownloadDataCompletedEventHandler value);
    protected virtual void OnDownloadDataCompleted(DownloadDataCompletedEventArgs e);
    public void DownloadDataAsync(Uri address);
    public void DownloadDataAsync(Uri address, object userToken);
    [CompilerGeneratedAttribute]
public void add_DownloadFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadFileCompleted(AsyncCompletedEventHandler value);
    protected virtual void OnDownloadFileCompleted(AsyncCompletedEventArgs e);
    public void DownloadFileAsync(Uri address, string fileName);
    public void DownloadFileAsync(Uri address, string fileName, object userToken);
    [CompilerGeneratedAttribute]
public void add_UploadStringCompleted(UploadStringCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadStringCompleted(UploadStringCompletedEventHandler value);
    protected virtual void OnUploadStringCompleted(UploadStringCompletedEventArgs e);
    public void UploadStringAsync(Uri address, string data);
    public void UploadStringAsync(Uri address, string method, string data);
    public void UploadStringAsync(Uri address, string method, string data, object userToken);
    [CompilerGeneratedAttribute]
public void add_UploadDataCompleted(UploadDataCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadDataCompleted(UploadDataCompletedEventHandler value);
    protected virtual void OnUploadDataCompleted(UploadDataCompletedEventArgs e);
    public void UploadDataAsync(Uri address, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data);
    public void UploadDataAsync(Uri address, string method, Byte[] data, object userToken);
    [CompilerGeneratedAttribute]
public void add_UploadFileCompleted(UploadFileCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadFileCompleted(UploadFileCompletedEventHandler value);
    protected virtual void OnUploadFileCompleted(UploadFileCompletedEventArgs e);
    public void UploadFileAsync(Uri address, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName);
    public void UploadFileAsync(Uri address, string method, string fileName, object userToken);
    [CompilerGeneratedAttribute]
public void add_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadValuesCompleted(UploadValuesCompletedEventHandler value);
    protected virtual void OnUploadValuesCompleted(UploadValuesCompletedEventArgs e);
    public void UploadValuesAsync(Uri address, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data);
    public void UploadValuesAsync(Uri address, string method, NameValueCollection data, object userToken);
    public void CancelAsync();
    [ComVisibleAttribute("False")]
public Task`1<string> DownloadStringTaskAsync(string address);
    [ComVisibleAttribute("False")]
public Task`1<string> DownloadStringTaskAsync(Uri address);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenReadTaskAsync(string address);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenReadTaskAsync(Uri address);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenWriteTaskAsync(string address);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenWriteTaskAsync(Uri address);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenWriteTaskAsync(string address, string method);
    [ComVisibleAttribute("False")]
public Task`1<Stream> OpenWriteTaskAsync(Uri address, string method);
    [ComVisibleAttribute("False")]
public Task`1<string> UploadStringTaskAsync(string address, string data);
    [ComVisibleAttribute("False")]
public Task`1<string> UploadStringTaskAsync(Uri address, string data);
    [ComVisibleAttribute("False")]
public Task`1<string> UploadStringTaskAsync(string address, string method, string data);
    [ComVisibleAttribute("False")]
public Task`1<string> UploadStringTaskAsync(Uri address, string method, string data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> DownloadDataTaskAsync(string address);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> DownloadDataTaskAsync(Uri address);
    [ComVisibleAttribute("False")]
public Task DownloadFileTaskAsync(string address, string fileName);
    [ComVisibleAttribute("False")]
public Task DownloadFileTaskAsync(Uri address, string fileName);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadDataTaskAsync(string address, Byte[] data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, Byte[] data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadDataTaskAsync(string address, string method, Byte[] data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadDataTaskAsync(Uri address, string method, Byte[] data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadFileTaskAsync(string address, string fileName);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string fileName);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadFileTaskAsync(string address, string method, string fileName);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadFileTaskAsync(Uri address, string method, string fileName);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadValuesTaskAsync(string address, NameValueCollection data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadValuesTaskAsync(string address, string method, NameValueCollection data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, NameValueCollection data);
    [ComVisibleAttribute("False")]
public Task`1<Byte[]> UploadValuesTaskAsync(Uri address, string method, NameValueCollection data);
    [CompilerGeneratedAttribute]
public void add_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DownloadProgressChanged(DownloadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_UploadProgressChanged(UploadProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_UploadProgressChanged(UploadProgressChangedEventHandler value);
    protected virtual void OnDownloadProgressChanged(DownloadProgressChangedEventArgs e);
    protected virtual void OnUploadProgressChanged(UploadProgressChangedEventArgs e);
}
public class System.Net.WebException : InvalidOperationException {
    public WebExceptionStatus Status { get; }
    public WebResponse Response { get; }
    internal WebExceptionInternalStatus InternalStatus { get; }
    public WebException(string message);
    public WebException(string message, Exception innerException);
    public WebException(string message, WebExceptionStatus status);
    internal WebException(string message, WebExceptionStatus status, WebExceptionInternalStatus internalStatus, Exception innerException);
    public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
    internal WebException(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response);
    internal WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus);
    internal WebException(string message, string data, Exception innerException, WebExceptionStatus status, WebResponse response, WebExceptionInternalStatus internalStatus);
    protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebExceptionStatus get_Status();
    public WebResponse get_Response();
    internal WebExceptionInternalStatus get_InternalStatus();
}
internal enum System.Net.WebExceptionInternalStatus : Enum {
    public int value__;
    public static WebExceptionInternalStatus RequestFatal;
    public static WebExceptionInternalStatus ServicePointFatal;
    public static WebExceptionInternalStatus Recoverable;
    public static WebExceptionInternalStatus Isolated;
}
internal static class System.Net.WebExceptionMapping : object {
    private static WebExceptionMapping();
    internal static string GetWebStatusString(WebExceptionStatus status);
}
public enum System.Net.WebExceptionStatus : Enum {
    public int value__;
    public static WebExceptionStatus Success;
    public static WebExceptionStatus NameResolutionFailure;
    public static WebExceptionStatus ConnectFailure;
    public static WebExceptionStatus ReceiveFailure;
    public static WebExceptionStatus SendFailure;
    public static WebExceptionStatus PipelineFailure;
    public static WebExceptionStatus RequestCanceled;
    public static WebExceptionStatus ProtocolError;
    public static WebExceptionStatus ConnectionClosed;
    public static WebExceptionStatus TrustFailure;
    public static WebExceptionStatus SecureChannelFailure;
    public static WebExceptionStatus ServerProtocolViolation;
    public static WebExceptionStatus KeepAliveFailure;
    public static WebExceptionStatus Pending;
    public static WebExceptionStatus Timeout;
    public static WebExceptionStatus ProxyNameResolutionFailure;
    public static WebExceptionStatus UnknownError;
    public static WebExceptionStatus MessageLengthLimitExceeded;
    public static WebExceptionStatus CacheEntryNotFound;
    public static WebExceptionStatus RequestProhibitedByCachePolicy;
    public static WebExceptionStatus RequestProhibitedByProxy;
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Net.WebHeaderCollection : NameValueCollection {
    internal string ContentLength { get; }
    internal string CacheControl { get; }
    internal string ContentType { get; }
    internal string Date { get; }
    internal string Expires { get; }
    internal string ETag { get; }
    internal string LastModified { get; }
    internal string Location { get; }
    internal string ProxyAuthenticate { get; }
    internal string SetCookie2 { get; }
    internal string SetCookie { get; }
    internal string Server { get; }
    internal string Via { get; }
    internal bool AllowHttpResponseHeader { get; }
    public string Item { get; public set; }
    public string Item { get; public set; }
    public int Count { get; }
    public KeysCollection Keys { get; }
    public String[] AllKeys { get; }
    internal WebHeaderCollection(WebHeaderCollectionType type);
    internal WebHeaderCollection(NameValueCollection cc);
    protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebHeaderCollection();
    internal string get_ContentLength();
    internal string get_CacheControl();
    internal string get_ContentType();
    internal string get_Date();
    internal string get_Expires();
    internal string get_ETag();
    internal string get_LastModified();
    internal string get_Location();
    internal string get_ProxyAuthenticate();
    internal string get_SetCookie2();
    internal string get_SetCookie();
    internal string get_Server();
    internal string get_Via();
    internal bool get_AllowHttpResponseHeader();
    public string get_Item(HttpRequestHeader header);
    public void set_Item(HttpRequestHeader header, string value);
    public string get_Item(HttpResponseHeader header);
    public void set_Item(HttpResponseHeader header, string value);
    public void Add(HttpRequestHeader header, string value);
    public void Add(HttpResponseHeader header, string value);
    public void Set(HttpRequestHeader header, string value);
    public void Set(HttpResponseHeader header, string value);
    internal void SetInternal(HttpResponseHeader header, string value);
    public void Remove(HttpRequestHeader header);
    public void Remove(HttpResponseHeader header);
    protected void AddWithoutValidate(string headerName, string headerValue);
    internal void SetAddVerified(string name, string value);
    internal void AddInternal(string name, string value);
    internal void ChangeInternal(string name, string value);
    internal void RemoveInternal(string name);
    internal void CheckUpdate(string name, string value);
    internal static string CheckBadChars(string name, bool isHeaderValue);
    internal static bool IsValidToken(string token);
    internal static bool ContainsNonAsciiChars(string token);
    internal void ThrowOnRestrictedHeader(string headerName);
    public virtual void Add(string name, string value);
    public void Add(string header);
    public virtual void Set(string name, string value);
    internal void SetInternal(string name, string value);
    public virtual void Remove(string name);
    public virtual String[] GetValues(string header);
    public virtual string ToString();
    internal string ToString(bool forTrace);
    internal static string GetAsString(NameValueCollection cc, bool winInetCompat, bool forTrace);
    public Byte[] ToByteArray();
    public static bool IsRestricted(string headerName);
    public static bool IsRestricted(string headerName, bool response);
    public virtual void OnDeserialization(object sender);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal DataParseStatus ParseHeaders(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError);
    internal DataParseStatus ParseHeadersStrict(Byte[] buffer, int size, Int32& unparsed, Int32& totalResponseHeadersLength, int maximumResponseHeadersLength, WebParseError& parseError);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string Get(string name);
    public virtual IEnumerator GetEnumerator();
    public virtual int get_Count();
    public virtual KeysCollection get_Keys();
    internal virtual bool InternalHasKeys();
    public virtual string Get(int index);
    public virtual String[] GetValues(int index);
    public virtual string GetKey(int index);
    public virtual String[] get_AllKeys();
    public virtual void Clear();
}
internal enum System.Net.WebHeaderCollectionType : Enum {
    public ushort value__;
    public static WebHeaderCollectionType Unknown;
    public static WebHeaderCollectionType WebRequest;
    public static WebHeaderCollectionType WebResponse;
    public static WebHeaderCollectionType HttpWebRequest;
    public static WebHeaderCollectionType HttpWebResponse;
    public static WebHeaderCollectionType HttpListenerRequest;
    public static WebHeaderCollectionType HttpListenerResponse;
    public static WebHeaderCollectionType FtpWebRequest;
    public static WebHeaderCollectionType FtpWebResponse;
    public static WebHeaderCollectionType FileWebRequest;
    public static WebHeaderCollectionType FileWebResponse;
}
internal class System.Net.WebParseError : ValueType {
    public WebParseErrorSection Section;
    public WebParseErrorCode Code;
}
internal enum System.Net.WebParseErrorCode : Enum {
    public int value__;
    public static WebParseErrorCode Generic;
    public static WebParseErrorCode InvalidHeaderName;
    public static WebParseErrorCode InvalidContentLength;
    public static WebParseErrorCode IncompleteHeaderLine;
    public static WebParseErrorCode CrLfError;
    public static WebParseErrorCode InvalidChunkFormat;
    public static WebParseErrorCode UnexpectedServerResponse;
}
internal enum System.Net.WebParseErrorSection : Enum {
    public int value__;
    public static WebParseErrorSection Generic;
    public static WebParseErrorSection ResponseHeader;
    public static WebParseErrorSection ResponseStatusLine;
    public static WebParseErrorSection ResponseBody;
}
public class System.Net.WebPermission : CodeAccessPermission {
    internal static string MatchAll;
    internal static Regex MatchAllRegex { get; }
    public IEnumerator ConnectList { get; }
    public IEnumerator AcceptList { get; }
    public WebPermission(PermissionState state);
    internal WebPermission(bool unrestricted);
    internal WebPermission(NetworkAccess access);
    public WebPermission(NetworkAccess access, Regex uriRegex);
    public WebPermission(NetworkAccess access, string uriString);
    internal WebPermission(NetworkAccess access, Uri uri);
    internal static Regex get_MatchAllRegex();
    public IEnumerator get_ConnectList();
    public IEnumerator get_AcceptList();
    public void AddPermission(NetworkAccess access, string uriString);
    internal void AddPermission(NetworkAccess access, Uri uri);
    public void AddPermission(NetworkAccess access, Regex uriRegex);
    internal void AddAsPattern(NetworkAccess access, DelayedRegex uriRegexPattern);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public class System.Net.WebPermissionAttribute : CodeAccessSecurityAttribute {
    public string Connect { get; public set; }
    public string Accept { get; public set; }
    public string ConnectPattern { get; public set; }
    public string AcceptPattern { get; public set; }
    public WebPermissionAttribute(SecurityAction action);
    public string get_Connect();
    public void set_Connect(string value);
    public string get_Accept();
    public void set_Accept(string value);
    public string get_ConnectPattern();
    public void set_ConnectPattern(string value);
    public string get_AcceptPattern();
    public void set_AcceptPattern(string value);
    public virtual IPermission CreatePermission();
}
public class System.Net.WebProxy : object {
    public Uri Address { get; public set; }
    unknown bool AutoDetect {internal set; }
    unknown Uri ScriptLocation {internal set; }
    public bool BypassProxyOnLocal { get; public set; }
    public String[] BypassList { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ArrayList BypassArrayList { get; }
    internal AutoWebProxyScriptEngine ScriptEngine { get; internal set; }
    public WebProxy(Uri Address);
    public WebProxy(Uri Address, bool BypassOnLocal);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(Uri Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    public WebProxy(string Host, int Port);
    public WebProxy(string Address);
    public WebProxy(string Address, bool BypassOnLocal);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList);
    public WebProxy(string Address, bool BypassOnLocal, String[] BypassList, ICredentials Credentials);
    protected WebProxy(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal WebProxy(bool enableAutoproxy);
    public Uri get_Address();
    public void set_Address(Uri value);
    internal void set_AutoDetect(bool value);
    internal void set_ScriptLocation(Uri value);
    public bool get_BypassProxyOnLocal();
    public void set_BypassProxyOnLocal(bool value);
    public String[] get_BypassList();
    public void set_BypassList(String[] value);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ArrayList get_BypassArrayList();
    internal void CheckForChanges();
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri host);
    [ObsoleteAttribute("This method has been deprecated. Please use the proxy selected for you by default. http://go.microsoft.com/fwlink/?linkid=14202")]
public static WebProxy GetDefaultProxy();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal AutoWebProxyScriptEngine get_ScriptEngine();
    internal void set_ScriptEngine(AutoWebProxyScriptEngine value);
    internal void DeleteScriptEngine();
    internal void UnsafeUpdateFromRegistry();
    internal void Update(WebProxyData webProxyData);
    private sealed virtual override ProxyChain System.Net.IAutoWebProxy.GetProxies(Uri destination);
    internal Uri[] GetProxiesAuto(Uri destination, Int32& syncStatus);
    internal void AbortGetProxiesAuto(Int32& syncStatus);
    internal Uri GetProxyAutoFailover(Uri destination);
}
internal class System.Net.WebProxyData : object {
    internal bool bypassOnLocal;
    internal bool automaticallyDetectSettings;
    internal Uri proxyAddress;
    internal Hashtable proxyHostAddresses;
    internal Uri scriptLocation;
    internal ArrayList bypassList;
}
internal abstract class System.Net.WebProxyDataBuilder : object {
    public WebProxyData Build();
    protected abstract virtual void BuildInternal();
    protected void SetProxyAndBypassList(string addressString, string bypassListString);
    protected void SetAutoProxyUrl(string autoConfigUrl);
    protected void SetAutoDetectSettings(bool value);
}
internal class System.Net.WebProxyScriptHelper : object {
    private Type System.Reflection.IReflect.UnderlyingSystemType { get; }
    private static WebProxyScriptHelper();
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr);
    private sealed virtual override MethodInfo[] System.Reflection.IReflect.GetMethods(BindingFlags bindingAttr);
    private sealed virtual override FieldInfo System.Reflection.IReflect.GetField(string name, BindingFlags bindingAttr);
    private sealed virtual override FieldInfo[] System.Reflection.IReflect.GetFields(BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override PropertyInfo[] System.Reflection.IReflect.GetProperties(BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMember(string name, BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMembers(BindingFlags bindingAttr);
    private sealed virtual override object System.Reflection.IReflect.InvokeMember(string name, BindingFlags bindingAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    private sealed virtual override Type System.Reflection.IReflect.get_UnderlyingSystemType();
    public bool isPlainHostName(string hostName);
    public bool dnsDomainIs(string host, string domain);
    public bool localHostOrDomainIs(string host, string hostDom);
    public bool isResolvable(string host);
    public string dnsResolve(string host);
    public string myIpAddress();
    public int dnsDomainLevels(string host);
    public bool isInNet(string host, string pattern, string mask);
    public bool shExpMatch(string host, string pattern);
    public bool weekdayRange(string wd1, object wd2, object gmt);
    public string getClientVersion();
    public string sortIpAddressList(string IPAddressList);
    public bool isInNetEx(string ipAddress, string ipPrefix);
    public string myIpAddressEx();
    public string dnsResolveEx(string host);
    public bool isResolvableEx(string host);
}
public abstract class System.Net.WebRequest : MarshalByRefObject {
    internal static int DefaultTimeout;
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public IWebRequestCreate CreatorInstance { get; }
    internal static Queue DefaultTimerQueue { get; }
    internal static ArrayList PrefixList { get; internal set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public string ConnectionGroupName { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public int Timeout { get; public set; }
    internal RequestCacheProtocol CacheProtocol { get; internal set; }
    public AuthenticationLevel AuthenticationLevel { get; public set; }
    public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    internal static IWebProxy InternalDefaultWebProxy { get; internal set; }
    public static IWebProxy DefaultWebProxy { get; public set; }
    protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest();
    public virtual IWebRequestCreate get_CreatorInstance();
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterPortableWebRequestCreator(IWebRequestCreate creator);
    internal static Queue get_DefaultTimerQueue();
    public static WebRequest Create(string requestUriString);
    public static WebRequest Create(Uri requestUri);
    public static WebRequest CreateDefault(Uri requestUri);
    public static HttpWebRequest CreateHttp(string requestUriString);
    public static HttpWebRequest CreateHttp(Uri requestUri);
    public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
    internal static ArrayList get_PrefixList();
    internal static void set_PrefixList(ArrayList value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual Uri get_RequestUri();
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    public virtual Task`1<WebResponse> GetResponseAsync();
    public virtual void Abort();
    internal RequestCacheProtocol get_CacheProtocol();
    internal void set_CacheProtocol(RequestCacheProtocol value);
    public AuthenticationLevel get_AuthenticationLevel();
    public void set_AuthenticationLevel(AuthenticationLevel value);
    internal virtual ContextAwareResult GetConnectingContext();
    internal virtual ContextAwareResult GetWritingContext();
    internal virtual ContextAwareResult GetReadingContext();
    public TokenImpersonationLevel get_ImpersonationLevel();
    public void set_ImpersonationLevel(TokenImpersonationLevel value);
    internal virtual void RequestCallback(object obj);
    internal static IWebProxy get_InternalDefaultWebProxy();
    internal static void set_InternalDefaultWebProxy(IWebProxy value);
    public static IWebProxy get_DefaultWebProxy();
    public static void set_DefaultWebProxy(IWebProxy value);
    public static IWebProxy GetSystemWebProxy();
    internal static IWebProxy InternalGetSystemWebProxy();
    internal void SetupCacheProtocol(Uri uri);
    internal void LogBeginGetResponse(bool success, bool synchronous);
    internal void LogEndGetResponse(bool success, bool synchronous, int statusCode);
    internal void LogBeginGetRequestStream(bool success, bool synchronous);
    internal void LogEndGetRequestStream(bool success, bool synchronous);
}
public static class System.Net.WebRequestMethods : object {
}
internal class System.Net.WebRequestPrefixElement : object {
    public string Prefix;
    internal IWebRequestCreate creator;
    internal Type creatorType;
    public IWebRequestCreate Creator { get; public set; }
    public WebRequestPrefixElement(string P, Type creatorType);
    public WebRequestPrefixElement(string P, IWebRequestCreate C);
    public IWebRequestCreate get_Creator();
    public void set_Creator(IWebRequestCreate value);
}
public abstract class System.Net.WebResponse : MarshalByRefObject {
    public bool IsFromCache { get; }
    unknown bool InternalSetFromCache {internal set; }
    internal bool IsCacheFresh { get; }
    unknown bool InternalSetIsCacheFresh {internal set; }
    public bool IsMutuallyAuthenticated { get; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public Uri ResponseUri { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsFromCache();
    internal void set_InternalSetFromCache(bool value);
    internal virtual bool get_IsCacheFresh();
    internal void set_InternalSetIsCacheFresh(bool value);
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual Stream GetResponseStream();
    public virtual Uri get_ResponseUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
}
internal class System.Net.WebSocketHttpRequestCreator : object {
    public WebSocketHttpRequestCreator(bool usingHttps);
    public sealed virtual WebRequest Create(Uri Uri);
}
public class System.Net.WebSockets.ClientWebSocket : WebSocket {
    public ClientWebSocketOptions Options { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public string SubProtocol { get; }
    public WebSocketState State { get; }
    private static ClientWebSocket();
    public ClientWebSocketOptions get_Options();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    public virtual string get_SubProtocol();
    public virtual WebSocketState get_State();
    public Task ConnectAsync(Uri uri, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Abort();
    public virtual void Dispose();
}
public class System.Net.WebSockets.ClientWebSocketOptions : object {
    internal WebHeaderCollection RequestHeaders { get; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentials Credentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    internal X509CertificateCollection InternalClientCertificates { get; }
    public CookieContainer Cookies { get; public set; }
    internal int ReceiveBufferSize { get; }
    internal int SendBufferSize { get; }
    internal IList`1<string> RequestedSubProtocols { get; }
    public TimeSpan KeepAliveInterval { get; public set; }
    public void SetRequestHeader(string headerName, string headerValue);
    internal WebHeaderCollection get_RequestHeaders();
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    internal X509CertificateCollection get_InternalClientCertificates();
    public CookieContainer get_Cookies();
    public void set_Cookies(CookieContainer value);
    public void SetBuffer(int receiveBufferSize, int sendBufferSize);
    public void SetBuffer(int receiveBufferSize, int sendBufferSize, ArraySegment`1<byte> buffer);
    internal int get_ReceiveBufferSize();
    internal int get_SendBufferSize();
    internal ArraySegment`1<byte> GetOrCreateBuffer();
    public void AddSubProtocol(string subProtocol);
    internal IList`1<string> get_RequestedSubProtocols();
    public TimeSpan get_KeepAliveInterval();
    public void set_KeepAliveInterval(TimeSpan value);
    internal void SetToReadOnly();
}
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
}
internal class System.Net.WebSockets.InternalClientWebSocket : WebSocketBase {
    internal SafeHandle SessionHandle { get; }
    public InternalClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer);
    internal virtual SafeHandle get_SessionHandle();
}
internal class System.Net.WebSockets.ServerWebSocket : WebSocketBase {
    internal SafeHandle SessionHandle { get; }
    public ServerWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal virtual SafeHandle get_SessionHandle();
}
public abstract class System.Net.WebSockets.WebSocket : object {
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    public string SubProtocol { get; }
    public WebSocketState State { get; }
    public static TimeSpan DefaultKeepAliveInterval { get; }
    public abstract virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public abstract virtual string get_CloseStatusDescription();
    public abstract virtual string get_SubProtocol();
    public abstract virtual WebSocketState get_State();
    public static TimeSpan get_DefaultKeepAliveInterval();
    public static ArraySegment`1<byte> CreateClientBuffer(int receiveBufferSize, int sendBufferSize);
    public static ArraySegment`1<byte> CreateServerBuffer(int receiveBufferSize);
    [EditorBrowsableAttribute("1")]
public static WebSocket CreateClientWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval, bool useZeroMaskingKey, ArraySegment`1<byte> internalBuffer);
    internal static WebSocket CreateServerWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    [EditorBrowsableAttribute("1")]
public static void RegisterPrefixes();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.")]
public static bool IsApplicationTargeting45();
    public abstract virtual void Abort();
    public abstract virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public abstract virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public abstract virtual void Dispose();
    public abstract virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public abstract virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    protected static void ThrowOnInvalidState(WebSocketState state, WebSocketState[] validStates);
    protected static bool IsStateTerminal(WebSocketState state);
}
internal abstract class System.Net.WebSockets.WebSocketBase : WebSocket {
    internal static bool LoggingEnabled { get; }
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    internal WebSocketBuffer InternalBuffer { get; }
    internal SafeHandle SessionHandle { get; }
    protected WebSocketBase(Stream innerStream, string subProtocol, TimeSpan keepAliveInterval, WebSocketBuffer internalBuffer);
    internal static bool get_LoggingEnabled();
    public virtual WebSocketState get_State();
    public virtual string get_SubProtocol();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    internal WebSocketBuffer get_InternalBuffer();
    protected void StartKeepAliveTimer();
    internal abstract virtual SafeHandle get_SessionHandle();
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    public virtual void Abort();
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Dispose();
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    internal void ThrowIfClosedOrAborted();
}
internal class System.Net.WebSockets.WebSocketBuffer : object {
    internal static int MinSendBufferSize;
    internal static int MinReceiveBufferSize;
    internal static int MaxBufferSize;
    internal static int SizeOfUInt { get; }
    public int ReceiveBufferSize { get; }
    public int SendBufferSize { get; }
    private static WebSocketBuffer();
    internal static int get_SizeOfUInt();
    public int get_ReceiveBufferSize();
    public int get_SendBufferSize();
    internal static WebSocketBuffer CreateClientBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize, int sendBufferSize);
    internal static WebSocketBuffer CreateServerBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize);
    public void Dispose(WebSocketState webSocketState);
    public sealed virtual void Dispose();
    internal Property[] CreateProperties(bool useZeroMaskingKey);
    internal void PinSendBuffer(ArraySegment`1<byte> payload, Boolean& bufferHasBeenPinned);
    internal IntPtr ConvertPinnedSendPayloadToNative(ArraySegment`1<byte> payload);
    internal IntPtr ConvertPinnedSendPayloadToNative(Byte[] buffer, int offset, int count);
    internal ArraySegment`1<byte> ConvertPinnedSendPayloadFromNative(Buffer buffer, BufferType bufferType);
    internal bool IsPinnedSendPayloadBuffer(Buffer buffer, BufferType bufferType);
    internal void ReleasePinnedSendBuffer();
    internal void BufferPayload(ArraySegment`1<byte> payload, int unconsumedDataOffset, WebSocketMessageType messageType, bool endOfMessage);
    internal bool ReceiveFromBufferedPayload(ArraySegment`1<byte> buffer, WebSocketReceiveResult& receiveResult);
    internal ArraySegment`1<byte> ConvertNativeBuffer(Action action, Buffer buffer, BufferType bufferType);
    internal void ConvertCloseBuffer(Action action, Buffer buffer, WebSocketCloseStatus& closeStatus, String& reason);
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    internal static void UnwrapWebSocketBuffer(Buffer buffer, BufferType bufferType, IntPtr& bufferData, UInt32& bufferLength);
    internal bool IsInternalBuffer(Byte[] buffer, int offset, int count);
    internal IntPtr ToIntPtr(int offset);
    internal static ArraySegment`1<byte> CreateInternalBufferArraySegment(int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
    internal static void Validate(int count, int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
}
public enum System.Net.WebSockets.WebSocketCloseStatus : Enum {
    public int value__;
    public static WebSocketCloseStatus NormalClosure;
    public static WebSocketCloseStatus EndpointUnavailable;
    public static WebSocketCloseStatus ProtocolError;
    public static WebSocketCloseStatus InvalidMessageType;
    public static WebSocketCloseStatus Empty;
    public static WebSocketCloseStatus InvalidPayloadData;
    public static WebSocketCloseStatus PolicyViolation;
    public static WebSocketCloseStatus MessageTooBig;
    public static WebSocketCloseStatus MandatoryExtension;
    public static WebSocketCloseStatus InternalServerError;
}
internal class System.Net.WebSockets.WebSocketConnectionStream : BufferedReadStream {
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool SupportsMultipleWrite { get; }
    public WebSocketConnectionStream(ConnectStream connectStream, string connectionGroupName);
    private static WebSocketConnectionStream();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public sealed virtual bool get_SupportsMultipleWrite();
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketConnectionStream/<CloseNetworkConnectionAsync>d__19")]
public sealed virtual Task CloseNetworkConnectionAsync(CancellationToken cancellationToken);
    public virtual void Close();
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketConnectionStream/<ReadAsync>d__21")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketConnectionStream/<WriteAsync>d__22")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual void SwitchToOpaqueMode(WebSocketBase webSocket);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketConnectionStream/<MultipleWriteAsync>d__24")]
public sealed virtual Task MultipleWriteAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public sealed virtual void Abort();
}
public abstract class System.Net.WebSockets.WebSocketContext : object {
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    public abstract virtual Uri get_RequestUri();
    public abstract virtual NameValueCollection get_Headers();
    public abstract virtual string get_Origin();
    public abstract virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public abstract virtual string get_SecWebSocketVersion();
    public abstract virtual string get_SecWebSocketKey();
    public abstract virtual CookieCollection get_CookieCollection();
    public abstract virtual IPrincipal get_User();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsSecureConnection();
    public abstract virtual WebSocket get_WebSocket();
}
public enum System.Net.WebSockets.WebSocketError : Enum {
    public int value__;
    public static WebSocketError Success;
    public static WebSocketError InvalidMessageType;
    public static WebSocketError Faulted;
    public static WebSocketError NativeError;
    public static WebSocketError NotAWebSocket;
    public static WebSocketError UnsupportedVersion;
    public static WebSocketError UnsupportedProtocol;
    public static WebSocketError HeaderError;
    public static WebSocketError ConnectionClosedPrematurely;
    public static WebSocketError InvalidState;
}
public class System.Net.WebSockets.WebSocketException : Win32Exception {
    public int ErrorCode { get; }
    public WebSocketError WebSocketErrorCode { get; }
    public WebSocketException(WebSocketError error);
    public WebSocketException(WebSocketError error, string message);
    public WebSocketException(WebSocketError error, Exception innerException);
    public WebSocketException(WebSocketError error, string message, Exception innerException);
    public WebSocketException(int nativeError);
    public WebSocketException(int nativeError, string message);
    public WebSocketException(int nativeError, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError);
    public WebSocketException(WebSocketError error, int nativeError, string message);
    public WebSocketException(WebSocketError error, int nativeError, Exception innerException);
    public WebSocketException(WebSocketError error, int nativeError, string message, Exception innerException);
    public WebSocketException(string message);
    public WebSocketException(string message, Exception innerException);
    private WebSocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
    public WebSocketError get_WebSocketErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Net.WebSockets.WebSocketHelpers : object {
    internal static string SecWebSocketKeyGuid;
    internal static string WebSocketUpgradeToken;
    internal static int DefaultReceiveBufferSize;
    internal static int DefaultClientSendBufferSize;
    internal static int MaxControlFramePayloadLength;
    internal static int ClientTcpCloseTimeout;
    internal static ArraySegment`1<byte> EmptyPayload { get; }
    private static WebSocketHelpers();
    internal static ArraySegment`1<byte> get_EmptyPayload();
    internal static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal static string GetSecWebSocketAcceptString(string secWebSocketKey);
    internal static string GetTraceMsgForParameters(int offset, int count, CancellationToken cancellationToken);
    internal static bool ProcessWebSocketProtocolHeader(string clientSecWebSocketProtocol, string subProtocol, String& acceptProtocol);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable SuppressContextFlow(Task task);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable`1<T> SuppressContextFlow(Task`1<T> task);
    internal static void ValidateBuffer(Byte[] buffer, int offset, int count);
    internal static void PrepareWebRequest(HttpWebRequest& request);
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription);
    internal static void ValidateOptions(string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval);
    internal static void ValidateBufferSizes(int receiveBufferSize, int sendBufferSize);
    internal static void ValidateInnerStream(Stream innerStream);
    internal static void ThrowIfConnectionAborted(Stream connection, bool read);
    internal static void ThrowPlatformNotSupportedException_WSPC();
    internal static void ValidateArraySegment(ArraySegment`1<T> arraySegment, string parameterName);
}
internal class System.Net.WebSockets.WebSocketHttpListenerDuplexStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool SupportsMultipleWrite { get; }
    public WebSocketHttpListenerDuplexStream(HttpRequestStream inputStream, HttpResponseStream outputStream, HttpListenerContext context);
    private static WebSocketHttpListenerDuplexStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public sealed virtual bool get_SupportsMultipleWrite();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public sealed virtual Task MultipleWriteAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<CloseNetworkConnectionAsync>d__50")]
public sealed virtual Task CloseNetworkConnectionAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Abort();
    public sealed virtual void SwitchToOpaqueMode(WebSocketBase webSocket);
}
public enum System.Net.WebSockets.WebSocketMessageType : Enum {
    public int value__;
    public static WebSocketMessageType Text;
    public static WebSocketMessageType Binary;
    public static WebSocketMessageType Close;
}
internal static class System.Net.WebSockets.WebSocketProtocolComponent : object {
    internal static string SupportedVersion { get; }
    internal static bool IsSupported { get; }
    [SecuritySafeCriticalAttribute]
private static WebSocketProtocolComponent();
    internal static string get_SupportedVersion();
    internal static bool get_IsSupported();
    internal static string GetSupportedVersion();
    internal static void WebSocketCreateClientHandle(Property[] properties, SafeWebSocketHandle& webSocketHandle);
    internal static void WebSocketCreateServerHandle(Property[] properties, int propertyCount, SafeWebSocketHandle& webSocketHandle);
    internal static void WebSocketAbortHandle(SafeHandle webSocketHandle);
    [ReliabilityContractAttribute("3", "2")]
internal static void WebSocketDeleteHandle(IntPtr webSocketPtr);
    internal static void WebSocketSend(WebSocketBase webSocket, BufferType bufferType, Buffer buffer);
    internal static void WebSocketSendWithoutBody(WebSocketBase webSocket, BufferType bufferType);
    internal static void WebSocketReceive(WebSocketBase webSocket);
    internal static void WebSocketGetAction(WebSocketBase webSocket, ActionQueue actionQueue, Buffer[] dataBuffers, UInt32& dataBufferCount, Action& action, BufferType& bufferType, IntPtr& actionContext);
    internal static void WebSocketCompleteAction(WebSocketBase webSocket, IntPtr actionContext, int bytesTransferred);
    internal static TimeSpan WebSocketGetDefaultKeepAliveInterval();
    public static bool Succeeded(int hr);
}
public class System.Net.WebSockets.WebSocketReceiveResult : object {
    public int Count { get; private set; }
    public bool EndOfMessage { get; private set; }
    public WebSocketMessageType MessageType { get; private set; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; private set; }
    public string CloseStatusDescription { get; private set; }
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
    public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable`1<WebSocketCloseStatus> closeStatus, string closeStatusDescription);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public bool get_EndOfMessage();
    [CompilerGeneratedAttribute]
private void set_EndOfMessage(bool value);
    [CompilerGeneratedAttribute]
public WebSocketMessageType get_MessageType();
    [CompilerGeneratedAttribute]
private void set_MessageType(WebSocketMessageType value);
    [CompilerGeneratedAttribute]
public Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    [CompilerGeneratedAttribute]
private void set_CloseStatus(Nullable`1<WebSocketCloseStatus> value);
    [CompilerGeneratedAttribute]
public string get_CloseStatusDescription();
    [CompilerGeneratedAttribute]
private void set_CloseStatusDescription(string value);
    internal WebSocketReceiveResult Copy(int count);
}
public enum System.Net.WebSockets.WebSocketState : Enum {
    public int value__;
    public static WebSocketState None;
    public static WebSocketState Connecting;
    public static WebSocketState Open;
    public static WebSocketState CloseSent;
    public static WebSocketState CloseReceived;
    public static WebSocketState Closed;
    public static WebSocketState Aborted;
}
public static class System.Net.WebUtility : object {
    private static WebUtility();
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
}
internal static class System.Net.Win32 : object {
    internal static int OverlappedInternalOffset;
    internal static int OverlappedInternalHighOffset;
    internal static int OverlappedOffsetOffset;
    internal static int OverlappedOffsetHighOffset;
    internal static int OverlappedhEventOffset;
    internal static int OverlappedSize;
    private static Win32();
}
internal enum System.Net.WindowsInstallationType : Enum {
    public int value__;
    public static WindowsInstallationType Unknown;
    public static WindowsInstallationType Client;
    public static WindowsInstallationType Server;
    public static WindowsInstallationType ServerCore;
    public static WindowsInstallationType Embedded;
}
internal class System.Net.WinHttpWebProxyBuilder : WebProxyDataBuilder {
    protected virtual void BuildInternal();
}
internal class System.Net.WinHttpWebProxyFinder : BaseWebProxyFinder {
    public WinHttpWebProxyFinder(AutoWebProxyScriptEngine engine);
    public virtual bool GetProxies(Uri destination, IList`1& proxyList);
    public virtual void Abort();
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.WorkerAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public int Offset;
    public int End;
    public bool IsWrite;
    public WorkerAsyncResult ParentResult;
    public bool HeaderDone;
    public bool HandshakeDone;
    public WorkerAsyncResult(object asyncObject, object asyncState, AsyncCallback savedAsyncCallback, Byte[] buffer, int offset, int end);
}
internal enum System.Net.WriteBufferState : Enum {
    public int value__;
    public static WriteBufferState Disabled;
    public static WriteBufferState Headers;
    public static WriteBufferState Buffer;
    public static WriteBufferState Playback;
}
internal class System.Net.WriteHeadersCallbackState : ValueType {
    internal HttpWebRequest request;
    internal ConnectStream stream;
    internal WriteHeadersCallbackState(HttpWebRequest request, ConnectStream stream);
}
[EditorBrowsableAttribute("1")]
public class System.Net.WriteStreamClosedEventArgs : EventArgs {
    [ObsoleteAttribute("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", "True")]
[EditorBrowsableAttribute("1")]
public Exception Error { get; }
    public Exception get_Error();
}
[EditorBrowsableAttribute("1")]
public class System.Net.WriteStreamClosedEventHandler : MulticastDelegate {
    public WriteStreamClosedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WriteStreamClosedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WriteStreamClosedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.WSABuffer : ValueType {
    internal int Length;
    internal IntPtr Pointer;
}
internal class System.Net.WSAData : ValueType {
    internal short wVersion;
    internal short wHighVersion;
    internal string szDescription;
    internal string szSystemStatus;
    internal short iMaxSockets;
    internal short iMaxUdpDg;
    internal IntPtr lpVendorInfo;
}
public class System.NetPipeStyleUriParser : UriParser {
}
public class System.NetTcpStyleUriParser : UriParser {
}
public class System.NewsStyleUriParser : UriParser {
}
internal enum System.ParsingError : Enum {
    public int value__;
    public static ParsingError None;
    public static ParsingError BadFormat;
    public static ParsingError BadScheme;
    public static ParsingError BadAuthority;
    public static ParsingError EmptyUriString;
    public static ParsingError LastRelativeUriOkErrIndex;
    public static ParsingError SchemeLimit;
    public static ParsingError SizeLimit;
    public static ParsingError MustRootedPath;
    public static ParsingError BadHostName;
    public static ParsingError NonEmptyHost;
    public static ParsingError BadPort;
    public static ParsingError BadAuthorityTerminator;
    public static ParsingError CannotCreateRelative;
}
internal class System.PinnableBufferCache : object {
    public PinnableBufferCache(string cacheName, int numberOfElements);
    [SecuritySafeCriticalAttribute]
internal PinnableBufferCache(string cacheName, Func`1<object> factory);
    public Byte[] AllocateBuffer();
    public void FreeBuffer(Byte[] buffer);
    [SecuritySafeCriticalAttribute]
internal object Allocate();
    [SecuritySafeCriticalAttribute]
internal void Free(object buffer);
}
[EventSourceAttribute]
internal class System.PinnableBufferCacheEventSource : EventSource {
    public static PinnableBufferCacheEventSource Log;
    private static PinnableBufferCacheEventSource();
    [EventAttribute("1")]
public void DebugMessage(string message);
    [EventAttribute("2")]
public void DebugMessage1(string message, long value);
    [EventAttribute("3")]
public void DebugMessage2(string message, long value1, long value2);
    [EventAttribute("18")]
public void DebugMessage3(string message, long value1, long value2, long value3);
    [EventAttribute("4")]
public void Create(string cacheName);
    [EventAttribute("5")]
public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter);
    [EventAttribute("6")]
public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter);
    [EventAttribute("7")]
public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount);
    [EventAttribute("8")]
public void AllocateBufferAged(string cacheName, int agedCount);
    [EventAttribute("9")]
public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore);
    [EventAttribute("10")]
public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore);
    [EventAttribute("11")]
public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore);
    [EventAttribute("13")]
public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec);
    [EventAttribute("14")]
public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed);
    [EventAttribute("15")]
public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial);
    [EventAttribute("16")]
public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount);
    [EventAttribute("17")]
public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore);
    [EventAttribute("20")]
public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount);
    [EventAttribute("21")]
public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList);
    [EventAttribute("22")]
public void FreeBufferNull(string cacheName, int freeCountBefore);
    internal static ulong AddressOf(object obj);
    [SecuritySafeCriticalAttribute]
internal static long AddressOfByteArray(Byte[] array);
}
public interface System.Reflection.ICustomTypeProvider {
    public abstract virtual Type GetCustomType();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.ADVF : Enum {
    public int value__;
    public static ADVF ADVF_NODATA;
    public static ADVF ADVF_PRIMEFIRST;
    public static ADVF ADVF_ONLYONCE;
    public static ADVF ADVF_DATAONSTOP;
    public static ADVF ADVFCACHE_NOHANDLER;
    public static ADVF ADVFCACHE_FORCEBUILTIN;
    public static ADVF ADVFCACHE_ONSAVE;
}
public enum System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
    public int value__;
    public static DATADIR DATADIR_GET;
    public static DATADIR DATADIR_SET;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
    public int value__;
    public static DVASPECT DVASPECT_CONTENT;
    public static DVASPECT DVASPECT_THUMBNAIL;
    public static DVASPECT DVASPECT_ICON;
    public static DVASPECT DVASPECT_DOCPRINT;
}
public class System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
    public short cfFormat;
    public IntPtr ptd;
    public DVASPECT dwAspect;
    public int lindex;
    public TYMED tymed;
}
[GuidAttribute("0000010F-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IAdviseSink {
    public abstract virtual void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium);
    public abstract virtual void OnViewChange(int aspect, int index);
    public abstract virtual void OnRename(IMoniker moniker);
    public abstract virtual void OnSave();
    public abstract virtual void OnClose();
}
[GuidAttribute("0000010E-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IDataObject {
    public abstract virtual void GetData(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual void GetDataHere(FORMATETC& format, STGMEDIUM& medium);
    public abstract virtual int QueryGetData(FORMATETC& format);
    public abstract virtual int GetCanonicalFormatEtc(FORMATETC& formatIn, FORMATETC& formatOut);
    public abstract virtual void SetData(FORMATETC& formatIn, STGMEDIUM& medium, bool release);
    public abstract virtual IEnumFORMATETC EnumFormatEtc(DATADIR direction);
    public abstract virtual int DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink adviseSink, Int32& connection);
    public abstract virtual void DUnadvise(int connection);
    public abstract virtual int EnumDAdvise(IEnumSTATDATA& enumAdvise);
}
[GuidAttribute("00000103-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
    public abstract virtual int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(IEnumFORMATETC& newEnum);
}
[GuidAttribute("00000103-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumSTATDATA {
    public abstract virtual int Next(int celt, STATDATA[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(IEnumSTATDATA& newEnum);
}
public class System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
    public FORMATETC formatetc;
    public ADVF advf;
    public IAdviseSink advSink;
    public int connection;
}
public class System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
    public TYMED tymed;
    public IntPtr unionmember;
    public object pUnkForRelease;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYMED : Enum {
    public int value__;
    public static TYMED TYMED_HGLOBAL;
    public static TYMED TYMED_FILE;
    public static TYMED TYMED_ISTREAM;
    public static TYMED TYMED_ISTORAGE;
    public static TYMED TYMED_GDI;
    public static TYMED TYMED_MFPICT;
    public static TYMED TYMED_ENHMF;
    public static TYMED TYMED_NULL;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    public object get_Value();
}
public class System.Runtime.InteropServices.HandleCollector : object {
    public int Count { get; }
    public int InitialThreshold { get; }
    public int MaximumThreshold { get; }
    public string Name { get; }
    public HandleCollector(string name, int initialThreshold);
    public HandleCollector(string name, int initialThreshold, int maximumThreshold);
    public int get_Count();
    public int get_InitialThreshold();
    public int get_MaximumThreshold();
    public string get_Name();
    public void Add();
    public void Remove();
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.StandardOleMarshalObject : MarshalByRefObject {
    private static StandardOleMarshalObject();
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.GetUnmarshalClass(Guid& riid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, Guid& pCid);
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.GetMarshalSizeMax(Guid& riid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, Int32& pSize);
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.MarshalInterface(IntPtr pStm, Guid& riid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags);
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.UnmarshalInterface(IntPtr pStm, Guid& riid, IntPtr& ppv);
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.ReleaseMarshalData(IntPtr pStm);
    private sealed virtual override int Microsoft.Win32.UnsafeNativeMethods.IMarshal.DisconnectObject(int dwReserved);
}
[GuidAttribute("e5af3542-ca67-4081-995b-709dd13792df")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICommand_WinRT {
    public abstract virtual EventRegistrationToken add_CanExecuteChanged(EventHandler`1<object> value);
    public abstract virtual void remove_CanExecuteChanged(EventRegistrationToken token);
    public abstract virtual bool CanExecute(object parameter);
    public abstract virtual void Execute(object parameter);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICommandAdapterHelpers : object {
    internal static EventHandler`1<object> CreateWrapperHandler(EventHandler handler);
    internal static EventHandler CreateWrapperHandler(EventHandler`1<object> handler);
    internal static EventHandler`1<object> GetValueFromEquivalentKey(ConditionalWeakTable`2<EventHandler, EventHandler`1<object>> table, EventHandler key, CreateValueCallback<EventHandler, EventHandler`1<object>> callback);
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.ICommandToManagedAdapter : object {
    private static ICommandToManagedAdapter();
}
[SecurityCriticalAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.ICommandToWinRTAdapter : object {
    private static ICommandToWinRTAdapter();
}
[GuidAttribute("28b167d5-1a31-465b-9b25-d5c3ae686c40")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChanged_WinRT {
    public abstract virtual EventRegistrationToken add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual void remove_CollectionChanged(EventRegistrationToken token);
}
[GuidAttribute("4cf68d33-e3f2-4964-b85e-945b4f7e2f21")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChangedEventArgs {
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public IList OldItems { get; }
    public int NewStartingIndex { get; }
    public int OldStartingIndex { get; }
    public abstract virtual NotifyCollectionChangedAction get_Action();
    public abstract virtual IList get_NewItems();
    public abstract virtual IList get_OldItems();
    public abstract virtual int get_NewStartingIndex();
    public abstract virtual int get_OldStartingIndex();
}
[GuidAttribute("cf75d69c-f2f4-486b-b302-bb4c09baebfa")]
internal interface System.Runtime.InteropServices.WindowsRuntime.INotifyPropertyChanged_WinRT {
    public abstract virtual EventRegistrationToken add_PropertyChanged(PropertyChangedEventHandler value);
    public abstract virtual void remove_PropertyChanged(EventRegistrationToken token);
}
[GuidAttribute("4f33a9a0-5cf4-47a4-b16f-d7faaf17457e")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyChangedEventArgs {
    public string PropertyName { get; }
    public abstract virtual string get_PropertyName();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedEventArgsMarshaler : object {
    [SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(NotifyCollectionChangedEventArgs managedArgs);
    [SecurityCriticalAttribute]
internal static NotifyCollectionChangedEventArgs ConvertToManaged(IntPtr nativeArgsIP);
}
[GuidAttribute("ca10b37c-f382-4591-8557-5e24965279b0")]
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedEventHandler_WinRT : MulticastDelegate {
    public NotifyCollectionChangedEventHandler_WinRT(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedToManagedAdapter : object {
    [SecurityCriticalAttribute]
internal void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [SecurityCriticalAttribute]
internal void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyCollectionChangedToWinRTAdapter : object {
    private static NotifyCollectionChangedToWinRTAdapter();
    [SecurityCriticalAttribute]
internal EventRegistrationToken add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [SecurityCriticalAttribute]
internal void remove_CollectionChanged(EventRegistrationToken token);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyPropertyChangedToManagedAdapter : object {
    [SecurityCriticalAttribute]
internal void add_PropertyChanged(PropertyChangedEventHandler value);
    [SecurityCriticalAttribute]
internal void remove_PropertyChanged(PropertyChangedEventHandler value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.NotifyPropertyChangedToWinRTAdapter : object {
    private static NotifyPropertyChangedToWinRTAdapter();
    [SecurityCriticalAttribute]
internal EventRegistrationToken add_PropertyChanged(PropertyChangedEventHandler value);
    [SecurityCriticalAttribute]
internal void remove_PropertyChanged(EventRegistrationToken token);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.PropertyChangedEventArgsMarshaler : object {
    [SecurityCriticalAttribute]
internal static IntPtr ConvertToNative(PropertyChangedEventArgs managedArgs);
    [SecurityCriticalAttribute]
internal static PropertyChangedEventArgs ConvertToManaged(IntPtr nativeArgsIP);
}
[GuidAttribute("50f19c16-0a22-4d8e-a089-1ea9951657d2")]
internal class System.Runtime.InteropServices.WindowsRuntime.PropertyChangedEventHandler_WinRT : MulticastDelegate {
    public PropertyChangedEventHandler_WinRT(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Runtime.Versioning.FrameworkName : object {
    public string Identifier { get; }
    public Version Version { get; }
    public string Profile { get; }
    public string FullName { get; }
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public FrameworkName(string frameworkName);
    public string get_Identifier();
    public Version get_Version();
    public string get_Profile();
    public string get_FullName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreAccessRule : AccessRule {
    public SemaphoreRights SemaphoreRights { get; }
    public SemaphoreAccessRule(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type);
    public SemaphoreAccessRule(string identity, SemaphoreRights eventRights, AccessControlType type);
    internal SemaphoreAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public SemaphoreRights get_SemaphoreRights();
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreAuditRule : AuditRule {
    public SemaphoreRights SemaphoreRights { get; }
    public SemaphoreAuditRule(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags);
    internal SemaphoreAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public SemaphoreRights get_SemaphoreRights();
}
[FlagsAttribute]
[ComVisibleAttribute("False")]
public enum System.Security.AccessControl.SemaphoreRights : Enum {
    public int value__;
    public static SemaphoreRights Modify;
    public static SemaphoreRights Delete;
    public static SemaphoreRights ReadPermissions;
    public static SemaphoreRights ChangePermissions;
    public static SemaphoreRights TakeOwnership;
    public static SemaphoreRights Synchronize;
    public static SemaphoreRights FullControl;
}
[ComVisibleAttribute("False")]
public class System.Security.AccessControl.SemaphoreSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public SemaphoreSecurity(string name, AccessControlSections includeSections);
    internal SemaphoreSecurity(SafeWaitHandle handle, AccessControlSections includeSections);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    internal void Persist(SafeWaitHandle handle);
    public void AddAccessRule(SemaphoreAccessRule rule);
    public void SetAccessRule(SemaphoreAccessRule rule);
    public void ResetAccessRule(SemaphoreAccessRule rule);
    public bool RemoveAccessRule(SemaphoreAccessRule rule);
    public void RemoveAccessRuleAll(SemaphoreAccessRule rule);
    public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule);
    public void AddAuditRule(SemaphoreAuditRule rule);
    public void SetAuditRule(SemaphoreAuditRule rule);
    public bool RemoveAuditRule(SemaphoreAuditRule rule);
    public void RemoveAuditRuleAll(SemaphoreAuditRule rule);
    public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public class System.Security.Authentication.AuthenticationException : SystemException {
    protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
}
public enum System.Security.Authentication.CipherAlgorithmType : Enum {
    public int value__;
    public static CipherAlgorithmType None;
    public static CipherAlgorithmType Rc2;
    public static CipherAlgorithmType Rc4;
    public static CipherAlgorithmType Des;
    public static CipherAlgorithmType TripleDes;
    public static CipherAlgorithmType Aes;
    public static CipherAlgorithmType Aes128;
    public static CipherAlgorithmType Aes192;
    public static CipherAlgorithmType Aes256;
    public static CipherAlgorithmType Null;
}
public enum System.Security.Authentication.ExchangeAlgorithmType : Enum {
    public int value__;
    public static ExchangeAlgorithmType None;
    public static ExchangeAlgorithmType RsaSign;
    public static ExchangeAlgorithmType RsaKeyX;
    public static ExchangeAlgorithmType DiffieHellman;
}
public abstract class System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
    public int Size { get; }
    protected ChannelBinding(bool ownsHandle);
    public abstract virtual int get_Size();
}
public enum System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
    public int value__;
    public static ChannelBindingKind Unknown;
    public static ChannelBindingKind Unique;
    public static ChannelBindingKind Endpoint;
}
internal static class System.Security.Authentication.ExtendedProtection.Configuration.ExtendedProtectionConfigurationStrings : object {
    internal static string ExtendedProtectionPolicy;
    internal static string PolicyEnforcement;
    internal static string ProtectionScenario;
    internal static string CustomServiceNames;
    internal static string Name;
}
public class System.Security.Authentication.ExtendedProtection.Configuration.ExtendedProtectionPolicyElement : ConfigurationElement {
    protected ConfigurationPropertyCollection Properties { get; }
    [ConfigurationPropertyAttribute("policyEnforcement")]
public PolicyEnforcement PolicyEnforcement { get; public set; }
    [ConfigurationPropertyAttribute("protectionScenario")]
public ProtectionScenario ProtectionScenario { get; public set; }
    [ConfigurationPropertyAttribute("customServiceNames")]
public ServiceNameElementCollection CustomServiceNames { get; }
    protected virtual ConfigurationPropertyCollection get_Properties();
    public PolicyEnforcement get_PolicyEnforcement();
    public void set_PolicyEnforcement(PolicyEnforcement value);
    public ProtectionScenario get_ProtectionScenario();
    public void set_ProtectionScenario(ProtectionScenario value);
    public ServiceNameElementCollection get_CustomServiceNames();
    public ExtendedProtectionPolicy BuildPolicy();
}
public class System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("name")]
public string Name { get; public set; }
    protected ConfigurationPropertyCollection Properties { get; }
    internal string Key { get; }
    public string get_Name();
    public void set_Name(string value);
    protected virtual ConfigurationPropertyCollection get_Properties();
    internal string get_Key();
}
[DefaultMemberAttribute("Item")]
[ConfigurationCollectionAttribute("System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElement")]
public class System.Security.Authentication.ExtendedProtection.Configuration.ServiceNameElementCollection : ConfigurationElementCollection {
    public ServiceNameElement Item { get; public set; }
    public ServiceNameElement Item { get; public set; }
    public ServiceNameElement get_Item(int index);
    public void set_Item(int index, ServiceNameElement value);
    public ServiceNameElement get_Item(string name);
    public void set_Item(string name, ServiceNameElement value);
    public void Add(ServiceNameElement element);
    public void Clear();
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual object GetElementKey(ConfigurationElement element);
    public int IndexOf(ServiceNameElement element);
    public void Remove(ServiceNameElement element);
    public void Remove(string name);
    public void RemoveAt(int index);
}
[TypeConverterAttribute("System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter")]
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    public ServiceNameCollection CustomServiceNames { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public ChannelBinding CustomChannelBinding { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    public ServiceNameCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    public ChannelBinding get_CustomChannelBinding();
    public virtual string ToString();
    public static bool get_OSSupportsExtendedProtection();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicyTypeConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    internal static bool Contains(string searchServiceName, ICollection serviceNames);
    public bool Contains(string searchServiceName);
    internal static string NormalizeServiceName(string inputServiceName);
    internal static bool Match(string serviceName1, string serviceName2);
}
public class System.Security.Authentication.ExtendedProtection.TokenBinding : object {
    public TokenBindingType BindingType { get; private set; }
    internal TokenBinding(TokenBindingType bindingType, Byte[] rawData);
    public Byte[] GetRawTokenBindingId();
    [CompilerGeneratedAttribute]
public TokenBindingType get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(TokenBindingType value);
}
public enum System.Security.Authentication.ExtendedProtection.TokenBindingType : Enum {
    public int value__;
    public static TokenBindingType Provided;
    public static TokenBindingType Referred;
}
public enum System.Security.Authentication.HashAlgorithmType : Enum {
    public int value__;
    public static HashAlgorithmType None;
    public static HashAlgorithmType Md5;
    public static HashAlgorithmType Sha1;
    public static HashAlgorithmType Sha256;
    public static HashAlgorithmType Sha384;
    public static HashAlgorithmType Sha512;
}
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
}
[FlagsAttribute]
public enum System.Security.Authentication.SslProtocols : Enum {
    public int value__;
    public static SslProtocols None;
    public static SslProtocols Ssl2;
    public static SslProtocols Ssl3;
    public static SslProtocols Tls;
    public static SslProtocols Tls11;
    public static SslProtocols Tls12;
    public static SslProtocols Tls13;
    public static SslProtocols Default;
}
public static class System.Security.Claims.DynamicRoleClaimProvider : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ClaimsAuthenticationManager to add claims to a ClaimsIdentity", "True")]
public static void AddDynamicRoleClaims(ClaimsIdentity claimsIdentity, IEnumerable`1<Claim> claims);
}
public class System.Security.Cryptography.AsnEncodedData : object {
    internal Oid m_oid;
    internal Byte[] m_rawData;
    public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    internal AsnEncodedData(Oid oid);
    internal AsnEncodedData(string oid, CRYPTOAPI_BLOB encodedBlob);
    internal AsnEncodedData(Oid oid, CRYPTOAPI_BLOB encodedBlob);
    public AsnEncodedData(Byte[] rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public Oid get_Oid();
    public void set_Oid(Oid value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    public AsnEncodedData Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public int Add(AsnEncodedData asnEncodedData);
    public void Remove(AsnEncodedData asnEncodedData);
    public AsnEncodedData get_Item(int index);
    public sealed virtual int get_Count();
    public AsnEncodedDataEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(AsnEncodedData[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AsnEncodedDataEnumerator(AsnEncodedDataCollection asnEncodedDatas);
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Security.Cryptography.BigInt : object {
    internal int Size { get; internal set; }
    internal BigInt(byte b);
    private static BigInt();
    internal int get_Size();
    internal void set_Size(int value);
    internal byte GetDigit(int index);
    internal void SetDigit(int index, byte digit);
    internal void SetDigit(int index, byte digit, Int32& size);
    public static bool op_LessThan(BigInt value1, BigInt value2);
    public static bool op_GreaterThan(BigInt value1, BigInt value2);
    public static bool op_Equality(BigInt value1, BigInt value2);
    public static bool op_Inequality(BigInt value1, BigInt value2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static void Add(BigInt a, byte b, BigInt& c);
    internal static void Negate(BigInt& a);
    internal static void Subtract(BigInt a, BigInt b, BigInt& c);
    internal static void Divide(BigInt numerator, BigInt denominator, BigInt& quotient, BigInt& remainder);
    internal void CopyFrom(BigInt a);
    internal bool IsZero();
    internal Byte[] ToByteArray();
    internal void Clear();
    internal void FromHexadecimal(string hexNum);
    internal void FromDecimal(string decNum);
    internal string ToDecimal();
}
internal class System.Security.Cryptography.CAPI : CAPIMethods {
    internal static Byte[] BlobToByteArray(IntPtr pBlob);
    internal static Byte[] BlobToByteArray(CRYPTOAPI_BLOB blob);
    internal static bool DecodeObject(IntPtr pszStructType, IntPtr pbEncoded, UInt32 cbEncoded, SafeLocalAllocHandle& decodedValue, UInt32& cbDecodedValue);
    internal static bool DecodeObject(IntPtr pszStructType, Byte[] pbEncoded, SafeLocalAllocHandle& decodedValue, UInt32& cbDecodedValue);
    internal static bool EncodeObject(IntPtr lpszStructType, IntPtr pvStructInfo, Byte[]& encodedData);
    internal static bool EncodeObject(string lpszStructType, IntPtr pvStructInfo, Byte[]& encodedData);
    internal static string GetCertNameInfo(SafeCertContextHandle safeCertContext, UInt32 dwFlags, UInt32 dwDisplayType);
    internal static SafeLocalAllocHandle LocalAlloc(UInt32 uFlags, IntPtr sizetdwBytes);
    internal static bool CryptAcquireContext(SafeCryptProvHandle& hCryptProv, string pwszContainer, string pwszProvider, UInt32 dwProvType, UInt32 dwFlags);
    internal static bool CryptAcquireContext(SafeCryptProvHandle& hCryptProv, IntPtr pwszContainer, IntPtr pwszProvider, UInt32 dwProvType, UInt32 dwFlags);
    internal static CRYPT_OID_INFO CryptFindOIDInfo(UInt32 dwKeyType, IntPtr pvKey, OidGroup dwGroupId);
    internal static CRYPT_OID_INFO CryptFindOIDInfo(UInt32 dwKeyType, SafeLocalAllocHandle pvKey, OidGroup dwGroupId);
    internal static string CryptFormatObject(UInt32 dwCertEncodingType, UInt32 dwFormatStrType, string lpszStructType, Byte[] rawData);
    internal static string CryptFormatObject(UInt32 dwCertEncodingType, UInt32 dwFormatStrType, IntPtr lpszStructType, Byte[] rawData);
    internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, UInt32 dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, UInt32 cCountersigners, IntPtr rgCountersigners);
    internal static SafeCryptMsgHandle CryptMsgOpenToEncode(UInt32 dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, IntPtr pvMsgEncodeInfo, IntPtr pszInnerContentObjID, IntPtr pStreamInfo);
    internal static SafeCryptMsgHandle CryptMsgOpenToEncode(UInt32 dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, IntPtr pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    internal static bool CertSetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, UInt32 dwFlags, IntPtr pvData);
    internal static bool CertSetCertificateContextProperty(SafeCertContextHandle pCertContext, UInt32 dwPropId, UInt32 dwFlags, IntPtr pvData);
    internal static bool CertSetCertificateContextProperty(SafeCertContextHandle pCertContext, UInt32 dwPropId, UInt32 dwFlags, SafeLocalAllocHandle safeLocalAllocHandle);
    internal static SafeCertContextHandle CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static SafeCertContextHandle CertDuplicateCertificateContext(SafeCertContextHandle pCertContext);
    internal static IntPtr CertEnumCertificatesInStore(SafeCertStoreHandle hCertStore, IntPtr pPrevCertContext);
    internal static SafeCertContextHandle CertEnumCertificatesInStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pPrevCertContext);
    internal static bool CryptQueryObject(UInt32 dwObjectType, object pvObject, UInt32 dwExpectedContentTypeFlags, UInt32 dwExpectedFormatTypeFlags, UInt32 dwFlags, IntPtr pdwMsgAndCertEncodingType, IntPtr pdwContentType, IntPtr pdwFormatType, IntPtr phCertStore, IntPtr phMsg, IntPtr ppvContext);
    internal static bool CryptQueryObject(UInt32 dwObjectType, object pvObject, UInt32 dwExpectedContentTypeFlags, UInt32 dwExpectedFormatTypeFlags, UInt32 dwFlags, IntPtr pdwMsgAndCertEncodingType, IntPtr pdwContentType, IntPtr pdwFormatType, SafeCertStoreHandle& phCertStore, IntPtr phMsg, IntPtr ppvContext);
    internal static SafeCertStoreHandle PFXImportCertStore(UInt32 dwObjectType, object pvObject, string szPassword, UInt32 dwFlags, bool persistKeyContainers);
    internal static bool CertAddCertificateContextToStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pCertContext, UInt32 dwAddDisposition, SafeCertContextHandle ppStoreContext);
    internal static bool CertAddCertificateLinkToStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pCertContext, UInt32 dwAddDisposition, SafeCertContextHandle ppStoreContext);
    internal static bool CertDeleteCertificateFromStore(SafeCertContextHandle pCertContext);
    internal static SafeCertStoreHandle CertOpenStore(IntPtr lpszStoreProvider, UInt32 dwMsgAndCertEncodingType, IntPtr hCryptProv, UInt32 dwFlags, string pvPara);
    internal static SafeCertContextHandle CertFindCertificateInStore(SafeCertStoreHandle hCertStore, UInt32 dwCertEncodingType, UInt32 dwFindFlags, UInt32 dwFindType, IntPtr pvFindPara, SafeCertContextHandle pPrevCertContext);
    internal static bool PFXExportCertStore(SafeCertStoreHandle hCertStore, IntPtr pPFX, string szPassword, UInt32 dwFlags);
    internal static bool CertSaveStore(SafeCertStoreHandle hCertStore, UInt32 dwMsgAndCertEncodingType, UInt32 dwSaveAs, UInt32 dwSaveTo, IntPtr pvSaveToPara, UInt32 dwFlags);
}
internal abstract class System.Security.Cryptography.CAPIBase : object {
    internal static string ADVAPI32;
    internal static string CRYPT32;
    internal static string KERNEL32;
    internal static UInt32 LMEM_FIXED;
    internal static UInt32 LMEM_ZEROINIT;
    internal static UInt32 LPTR;
    internal static int S_OK;
    internal static int S_FALSE;
    internal static UInt32 FORMAT_MESSAGE_FROM_SYSTEM;
    internal static UInt32 FORMAT_MESSAGE_IGNORE_INSERTS;
    internal static UInt32 VER_PLATFORM_WIN32s;
    internal static UInt32 VER_PLATFORM_WIN32_WINDOWS;
    internal static UInt32 VER_PLATFORM_WIN32_NT;
    internal static UInt32 VER_PLATFORM_WINCE;
    internal static UInt32 ASN_TAG_NULL;
    internal static UInt32 ASN_TAG_OBJID;
    internal static UInt32 CERT_QUERY_OBJECT_FILE;
    internal static UInt32 CERT_QUERY_OBJECT_BLOB;
    internal static UInt32 CERT_QUERY_CONTENT_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_STORE;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_SERIALIZED_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
    internal static UInt32 CERT_QUERY_CONTENT_PKCS10;
    internal static UInt32 CERT_QUERY_CONTENT_PFX;
    internal static UInt32 CERT_QUERY_CONTENT_CERT_PAIR;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_PKCS10;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_PFX;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_CERT_PAIR;
    internal static UInt32 CERT_QUERY_CONTENT_FLAG_ALL;
    internal static UInt32 CERT_QUERY_FORMAT_BINARY;
    internal static UInt32 CERT_QUERY_FORMAT_BASE64_ENCODED;
    internal static UInt32 CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED;
    internal static UInt32 CERT_QUERY_FORMAT_FLAG_BINARY;
    internal static UInt32 CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED;
    internal static UInt32 CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED;
    internal static UInt32 CERT_QUERY_FORMAT_FLAG_ALL;
    internal static UInt32 CRYPT_OID_INFO_OID_KEY;
    internal static UInt32 CRYPT_OID_INFO_NAME_KEY;
    internal static UInt32 CRYPT_OID_INFO_ALGID_KEY;
    internal static UInt32 CRYPT_OID_INFO_SIGN_KEY;
    internal static UInt32 CRYPT_HASH_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_ENCRYPT_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_PUBKEY_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_SIGN_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_RDN_ATTR_OID_GROUP_ID;
    internal static UInt32 CRYPT_EXT_OR_ATTR_OID_GROUP_ID;
    internal static UInt32 CRYPT_ENHKEY_USAGE_OID_GROUP_ID;
    internal static UInt32 CRYPT_POLICY_OID_GROUP_ID;
    internal static UInt32 CRYPT_TEMPLATE_OID_GROUP_ID;
    internal static UInt32 CRYPT_LAST_OID_GROUP_ID;
    internal static UInt32 CRYPT_FIRST_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_LAST_ALG_OID_GROUP_ID;
    internal static UInt32 CRYPT_ASN_ENCODING;
    internal static UInt32 CRYPT_NDR_ENCODING;
    internal static UInt32 X509_ASN_ENCODING;
    internal static UInt32 X509_NDR_ENCODING;
    internal static UInt32 PKCS_7_ASN_ENCODING;
    internal static UInt32 PKCS_7_NDR_ENCODING;
    internal static UInt32 PKCS_7_OR_X509_ASN_ENCODING;
    internal static UInt32 CERT_STORE_PROV_MSG;
    internal static UInt32 CERT_STORE_PROV_MEMORY;
    internal static UInt32 CERT_STORE_PROV_FILE;
    internal static UInt32 CERT_STORE_PROV_REG;
    internal static UInt32 CERT_STORE_PROV_PKCS7;
    internal static UInt32 CERT_STORE_PROV_SERIALIZED;
    internal static UInt32 CERT_STORE_PROV_FILENAME_A;
    internal static UInt32 CERT_STORE_PROV_FILENAME_W;
    internal static UInt32 CERT_STORE_PROV_FILENAME;
    internal static UInt32 CERT_STORE_PROV_SYSTEM_A;
    internal static UInt32 CERT_STORE_PROV_SYSTEM_W;
    internal static UInt32 CERT_STORE_PROV_SYSTEM;
    internal static UInt32 CERT_STORE_PROV_COLLECTION;
    internal static UInt32 CERT_STORE_PROV_SYSTEM_REGISTRY_A;
    internal static UInt32 CERT_STORE_PROV_SYSTEM_REGISTRY_W;
    internal static UInt32 CERT_STORE_PROV_SYSTEM_REGISTRY;
    internal static UInt32 CERT_STORE_PROV_PHYSICAL_W;
    internal static UInt32 CERT_STORE_PROV_PHYSICAL;
    internal static UInt32 CERT_STORE_PROV_SMART_CARD_W;
    internal static UInt32 CERT_STORE_PROV_SMART_CARD;
    internal static UInt32 CERT_STORE_PROV_LDAP_W;
    internal static UInt32 CERT_STORE_PROV_LDAP;
    internal static UInt32 CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    internal static UInt32 CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    internal static UInt32 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
    internal static UInt32 CERT_STORE_DELETE_FLAG;
    internal static UInt32 CERT_STORE_SHARE_STORE_FLAG;
    internal static UInt32 CERT_STORE_SHARE_CONTEXT_FLAG;
    internal static UInt32 CERT_STORE_MANIFOLD_FLAG;
    internal static UInt32 CERT_STORE_ENUM_ARCHIVED_FLAG;
    internal static UInt32 CERT_STORE_UPDATE_KEYID_FLAG;
    internal static UInt32 CERT_STORE_BACKUP_RESTORE_FLAG;
    internal static UInt32 CERT_STORE_READONLY_FLAG;
    internal static UInt32 CERT_STORE_OPEN_EXISTING_FLAG;
    internal static UInt32 CERT_STORE_CREATE_NEW_FLAG;
    internal static UInt32 CERT_STORE_MAXIMUM_ALLOWED_FLAG;
    internal static UInt32 CERT_SYSTEM_STORE_UNPROTECTED_FLAG;
    internal static UInt32 CERT_SYSTEM_STORE_LOCATION_MASK;
    internal static UInt32 CERT_SYSTEM_STORE_LOCATION_SHIFT;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_SERVICE_ID;
    internal static UInt32 CERT_SYSTEM_STORE_SERVICES_ID;
    internal static UInt32 CERT_SYSTEM_STORE_USERS_ID;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_SERVICE;
    internal static UInt32 CERT_SYSTEM_STORE_SERVICES;
    internal static UInt32 CERT_SYSTEM_STORE_USERS;
    internal static UInt32 CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
    internal static UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE;
    internal static UInt32 CERT_NAME_EMAIL_TYPE;
    internal static UInt32 CERT_NAME_RDN_TYPE;
    internal static UInt32 CERT_NAME_ATTR_TYPE;
    internal static UInt32 CERT_NAME_SIMPLE_DISPLAY_TYPE;
    internal static UInt32 CERT_NAME_FRIENDLY_DISPLAY_TYPE;
    internal static UInt32 CERT_NAME_DNS_TYPE;
    internal static UInt32 CERT_NAME_URL_TYPE;
    internal static UInt32 CERT_NAME_UPN_TYPE;
    internal static UInt32 CERT_SIMPLE_NAME_STR;
    internal static UInt32 CERT_OID_NAME_STR;
    internal static UInt32 CERT_X500_NAME_STR;
    internal static UInt32 CERT_NAME_STR_SEMICOLON_FLAG;
    internal static UInt32 CERT_NAME_STR_NO_PLUS_FLAG;
    internal static UInt32 CERT_NAME_STR_NO_QUOTING_FLAG;
    internal static UInt32 CERT_NAME_STR_CRLF_FLAG;
    internal static UInt32 CERT_NAME_STR_COMMA_FLAG;
    internal static UInt32 CERT_NAME_STR_REVERSE_FLAG;
    internal static UInt32 CERT_NAME_ISSUER_FLAG;
    internal static UInt32 CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG;
    internal static UInt32 CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
    internal static UInt32 CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG;
    internal static UInt32 CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG;
    internal static UInt32 CERT_KEY_PROV_HANDLE_PROP_ID;
    internal static UInt32 CERT_KEY_PROV_INFO_PROP_ID;
    internal static UInt32 CERT_SHA1_HASH_PROP_ID;
    internal static UInt32 CERT_MD5_HASH_PROP_ID;
    internal static UInt32 CERT_HASH_PROP_ID;
    internal static UInt32 CERT_KEY_CONTEXT_PROP_ID;
    internal static UInt32 CERT_KEY_SPEC_PROP_ID;
    internal static UInt32 CERT_IE30_RESERVED_PROP_ID;
    internal static UInt32 CERT_PUBKEY_HASH_RESERVED_PROP_ID;
    internal static UInt32 CERT_ENHKEY_USAGE_PROP_ID;
    internal static UInt32 CERT_CTL_USAGE_PROP_ID;
    internal static UInt32 CERT_NEXT_UPDATE_LOCATION_PROP_ID;
    internal static UInt32 CERT_FRIENDLY_NAME_PROP_ID;
    internal static UInt32 CERT_PVK_FILE_PROP_ID;
    internal static UInt32 CERT_DESCRIPTION_PROP_ID;
    internal static UInt32 CERT_ACCESS_STATE_PROP_ID;
    internal static UInt32 CERT_SIGNATURE_HASH_PROP_ID;
    internal static UInt32 CERT_SMART_CARD_DATA_PROP_ID;
    internal static UInt32 CERT_EFS_PROP_ID;
    internal static UInt32 CERT_FORTEZZA_DATA_PROP_ID;
    internal static UInt32 CERT_ARCHIVED_PROP_ID;
    internal static UInt32 CERT_KEY_IDENTIFIER_PROP_ID;
    internal static UInt32 CERT_AUTO_ENROLL_PROP_ID;
    internal static UInt32 CERT_PUBKEY_ALG_PARA_PROP_ID;
    internal static UInt32 CERT_CROSS_CERT_DIST_POINTS_PROP_ID;
    internal static UInt32 CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID;
    internal static UInt32 CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID;
    internal static UInt32 CERT_ENROLLMENT_PROP_ID;
    internal static UInt32 CERT_DATE_STAMP_PROP_ID;
    internal static UInt32 CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID;
    internal static UInt32 CERT_SUBJECT_NAME_MD5_HASH_PROP_ID;
    internal static UInt32 CERT_EXTENDED_ERROR_INFO_PROP_ID;
    internal static UInt32 CERT_RENEWAL_PROP_ID;
    internal static UInt32 CERT_ARCHIVED_KEY_HASH_PROP_ID;
    internal static UInt32 CERT_FIRST_RESERVED_PROP_ID;
    internal static UInt32 CERT_NCRYPT_KEY_HANDLE_PROP_ID;
    internal static UInt32 CERT_DELETE_KEYSET_PROP_ID;
    internal static UInt32 CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG;
    internal static UInt32 CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG;
    internal static UInt32 CERT_INFO_VERSION_FLAG;
    internal static UInt32 CERT_INFO_SERIAL_NUMBER_FLAG;
    internal static UInt32 CERT_INFO_SIGNATURE_ALGORITHM_FLAG;
    internal static UInt32 CERT_INFO_ISSUER_FLAG;
    internal static UInt32 CERT_INFO_NOT_BEFORE_FLAG;
    internal static UInt32 CERT_INFO_NOT_AFTER_FLAG;
    internal static UInt32 CERT_INFO_SUBJECT_FLAG;
    internal static UInt32 CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG;
    internal static UInt32 CERT_INFO_ISSUER_UNIQUE_ID_FLAG;
    internal static UInt32 CERT_INFO_SUBJECT_UNIQUE_ID_FLAG;
    internal static UInt32 CERT_INFO_EXTENSION_FLAG;
    internal static UInt32 CERT_COMPARE_MASK;
    internal static UInt32 CERT_COMPARE_SHIFT;
    internal static UInt32 CERT_COMPARE_ANY;
    internal static UInt32 CERT_COMPARE_SHA1_HASH;
    internal static UInt32 CERT_COMPARE_NAME;
    internal static UInt32 CERT_COMPARE_ATTR;
    internal static UInt32 CERT_COMPARE_MD5_HASH;
    internal static UInt32 CERT_COMPARE_PROPERTY;
    internal static UInt32 CERT_COMPARE_PUBLIC_KEY;
    internal static UInt32 CERT_COMPARE_HASH;
    internal static UInt32 CERT_COMPARE_NAME_STR_A;
    internal static UInt32 CERT_COMPARE_NAME_STR_W;
    internal static UInt32 CERT_COMPARE_KEY_SPEC;
    internal static UInt32 CERT_COMPARE_ENHKEY_USAGE;
    internal static UInt32 CERT_COMPARE_CTL_USAGE;
    internal static UInt32 CERT_COMPARE_SUBJECT_CERT;
    internal static UInt32 CERT_COMPARE_ISSUER_OF;
    internal static UInt32 CERT_COMPARE_EXISTING;
    internal static UInt32 CERT_COMPARE_SIGNATURE_HASH;
    internal static UInt32 CERT_COMPARE_KEY_IDENTIFIER;
    internal static UInt32 CERT_COMPARE_CERT_ID;
    internal static UInt32 CERT_COMPARE_CROSS_CERT_DIST_POINTS;
    internal static UInt32 CERT_COMPARE_PUBKEY_MD5_HASH;
    internal static UInt32 CERT_FIND_ANY;
    internal static UInt32 CERT_FIND_SHA1_HASH;
    internal static UInt32 CERT_FIND_MD5_HASH;
    internal static UInt32 CERT_FIND_SIGNATURE_HASH;
    internal static UInt32 CERT_FIND_KEY_IDENTIFIER;
    internal static UInt32 CERT_FIND_HASH;
    internal static UInt32 CERT_FIND_PROPERTY;
    internal static UInt32 CERT_FIND_PUBLIC_KEY;
    internal static UInt32 CERT_FIND_SUBJECT_NAME;
    internal static UInt32 CERT_FIND_SUBJECT_ATTR;
    internal static UInt32 CERT_FIND_ISSUER_NAME;
    internal static UInt32 CERT_FIND_ISSUER_ATTR;
    internal static UInt32 CERT_FIND_SUBJECT_STR_A;
    internal static UInt32 CERT_FIND_SUBJECT_STR_W;
    internal static UInt32 CERT_FIND_SUBJECT_STR;
    internal static UInt32 CERT_FIND_ISSUER_STR_A;
    internal static UInt32 CERT_FIND_ISSUER_STR_W;
    internal static UInt32 CERT_FIND_ISSUER_STR;
    internal static UInt32 CERT_FIND_KEY_SPEC;
    internal static UInt32 CERT_FIND_ENHKEY_USAGE;
    internal static UInt32 CERT_FIND_CTL_USAGE;
    internal static UInt32 CERT_FIND_SUBJECT_CERT;
    internal static UInt32 CERT_FIND_ISSUER_OF;
    internal static UInt32 CERT_FIND_EXISTING;
    internal static UInt32 CERT_FIND_CERT_ID;
    internal static UInt32 CERT_FIND_CROSS_CERT_DIST_POINTS;
    internal static UInt32 CERT_FIND_PUBKEY_MD5_HASH;
    internal static UInt32 CERT_ENCIPHER_ONLY_KEY_USAGE;
    internal static UInt32 CERT_CRL_SIGN_KEY_USAGE;
    internal static UInt32 CERT_KEY_CERT_SIGN_KEY_USAGE;
    internal static UInt32 CERT_KEY_AGREEMENT_KEY_USAGE;
    internal static UInt32 CERT_DATA_ENCIPHERMENT_KEY_USAGE;
    internal static UInt32 CERT_KEY_ENCIPHERMENT_KEY_USAGE;
    internal static UInt32 CERT_NON_REPUDIATION_KEY_USAGE;
    internal static UInt32 CERT_DIGITAL_SIGNATURE_KEY_USAGE;
    internal static UInt32 CERT_DECIPHER_ONLY_KEY_USAGE;
    internal static UInt32 CERT_STORE_ADD_NEW;
    internal static UInt32 CERT_STORE_ADD_USE_EXISTING;
    internal static UInt32 CERT_STORE_ADD_REPLACE_EXISTING;
    internal static UInt32 CERT_STORE_ADD_ALWAYS;
    internal static UInt32 CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
    internal static UInt32 CERT_STORE_ADD_NEWER;
    internal static UInt32 CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
    internal static UInt32 CRYPT_FORMAT_STR_MULTI_LINE;
    internal static UInt32 CRYPT_FORMAT_STR_NO_HEX;
    internal static UInt32 CERT_STORE_SAVE_AS_STORE;
    internal static UInt32 CERT_STORE_SAVE_AS_PKCS7;
    internal static UInt32 CERT_STORE_SAVE_TO_FILE;
    internal static UInt32 CERT_STORE_SAVE_TO_MEMORY;
    internal static UInt32 CERT_STORE_SAVE_TO_FILENAME_A;
    internal static UInt32 CERT_STORE_SAVE_TO_FILENAME_W;
    internal static UInt32 CERT_STORE_SAVE_TO_FILENAME;
    internal static UInt32 CERT_CA_SUBJECT_FLAG;
    internal static UInt32 CERT_END_ENTITY_SUBJECT_FLAG;
    internal static UInt32 REPORT_NO_PRIVATE_KEY;
    internal static UInt32 REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY;
    internal static UInt32 EXPORT_PRIVATE_KEYS;
    internal static UInt32 PKCS12_EXPORT_RESERVED_MASK;
    internal static UInt32 RSA_CSP_PUBLICKEYBLOB;
    internal static UInt32 X509_MULTI_BYTE_UINT;
    internal static UInt32 X509_DSS_PUBLICKEY;
    internal static UInt32 X509_DSS_PARAMETERS;
    internal static UInt32 X509_DSS_SIGNATURE;
    internal static UInt32 X509_EXTENSIONS;
    internal static UInt32 X509_NAME_VALUE;
    internal static UInt32 X509_NAME;
    internal static UInt32 X509_AUTHORITY_KEY_ID;
    internal static UInt32 X509_KEY_USAGE_RESTRICTION;
    internal static UInt32 X509_BASIC_CONSTRAINTS;
    internal static UInt32 X509_KEY_USAGE;
    internal static UInt32 X509_BASIC_CONSTRAINTS2;
    internal static UInt32 X509_CERT_POLICIES;
    internal static UInt32 PKCS_UTC_TIME;
    internal static UInt32 PKCS_ATTRIBUTE;
    internal static UInt32 X509_UNICODE_NAME_VALUE;
    internal static UInt32 X509_OCTET_STRING;
    internal static UInt32 X509_BITS;
    internal static UInt32 X509_ANY_STRING;
    internal static UInt32 X509_UNICODE_ANY_STRING;
    internal static UInt32 X509_ENHANCED_KEY_USAGE;
    internal static UInt32 PKCS_RC2_CBC_PARAMETERS;
    internal static UInt32 X509_CERTIFICATE_TEMPLATE;
    internal static UInt32 PKCS7_SIGNER_INFO;
    internal static UInt32 CMS_SIGNER_INFO;
    internal static string szOID_COMMON_NAME;
    internal static string szOID_AUTHORITY_KEY_IDENTIFIER;
    internal static string szOID_KEY_USAGE_RESTRICTION;
    internal static string szOID_SUBJECT_ALT_NAME;
    internal static string szOID_ISSUER_ALT_NAME;
    internal static string szOID_BASIC_CONSTRAINTS;
    internal static string szOID_SUBJECT_KEY_IDENTIFIER;
    internal static string szOID_KEY_USAGE;
    internal static string szOID_SUBJECT_ALT_NAME2;
    internal static string szOID_ISSUER_ALT_NAME2;
    internal static string szOID_BASIC_CONSTRAINTS2;
    internal static string szOID_CRL_DIST_POINTS;
    internal static string szOID_CERT_POLICIES;
    internal static string szOID_ENHANCED_KEY_USAGE;
    internal static string szOID_KEYID_RDN;
    internal static string szOID_ENROLL_CERTTYPE_EXTENSION;
    internal static string szOID_NT_PRINCIPAL_NAME;
    internal static string szOID_CERTIFICATE_TEMPLATE;
    internal static string szOID_RDN_DUMMY_SIGNER;
    internal static string szOID_AUTHORITY_INFO_ACCESS;
    internal static UInt32 CERT_CHAIN_POLICY_BASE;
    internal static UInt32 CERT_CHAIN_POLICY_AUTHENTICODE;
    internal static UInt32 CERT_CHAIN_POLICY_AUTHENTICODE_TS;
    internal static UInt32 CERT_CHAIN_POLICY_SSL;
    internal static UInt32 CERT_CHAIN_POLICY_BASIC_CONSTRAINTS;
    internal static UInt32 CERT_CHAIN_POLICY_NT_AUTH;
    internal static UInt32 CERT_CHAIN_POLICY_MICROSOFT_ROOT;
    internal static UInt32 USAGE_MATCH_TYPE_AND;
    internal static UInt32 USAGE_MATCH_TYPE_OR;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    internal static UInt32 CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    internal static UInt32 CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT;
    internal static UInt32 CERT_TRUST_NO_ERROR;
    internal static UInt32 CERT_TRUST_IS_NOT_TIME_VALID;
    internal static UInt32 CERT_TRUST_IS_NOT_TIME_NESTED;
    internal static UInt32 CERT_TRUST_IS_REVOKED;
    internal static UInt32 CERT_TRUST_IS_NOT_SIGNATURE_VALID;
    internal static UInt32 CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    internal static UInt32 CERT_TRUST_IS_UNTRUSTED_ROOT;
    internal static UInt32 CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
    internal static UInt32 CERT_TRUST_IS_CYCLIC;
    internal static UInt32 CERT_TRUST_INVALID_EXTENSION;
    internal static UInt32 CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
    internal static UInt32 CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    internal static UInt32 CERT_TRUST_INVALID_NAME_CONSTRAINTS;
    internal static UInt32 CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;
    internal static UInt32 CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;
    internal static UInt32 CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;
    internal static UInt32 CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;
    internal static UInt32 CERT_TRUST_IS_OFFLINE_REVOCATION;
    internal static UInt32 CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
    internal static UInt32 CERT_TRUST_IS_EXPLICIT_DISTRUST;
    internal static UInt32 CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT;
    internal static UInt32 CERT_TRUST_HAS_WEAK_SIGNATURE;
    internal static UInt32 CERT_TRUST_IS_PARTIAL_CHAIN;
    internal static UInt32 CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    internal static UInt32 CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    internal static UInt32 CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG;
    internal static UInt32 CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    internal static UInt32 CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    internal static UInt32 CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    internal static UInt32 CERT_TRUST_HAS_NAME_MATCH_ISSUER;
    internal static UInt32 CERT_TRUST_IS_SELF_SIGNED;
    internal static UInt32 CERT_TRUST_HAS_PREFERRED_ISSUER;
    internal static UInt32 CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
    internal static UInt32 CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    internal static UInt32 CERT_TRUST_IS_COMPLEX_CHAIN;
    internal static string szOID_PKIX_NO_SIGNATURE;
    internal static string szOID_PKIX_KP_SERVER_AUTH;
    internal static string szOID_PKIX_KP_CLIENT_AUTH;
    internal static string szOID_PKIX_KP_CODE_SIGNING;
    internal static string szOID_PKIX_KP_EMAIL_PROTECTION;
    internal static string SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID;
    internal static string SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID;
    internal static UInt32 HCCE_CURRENT_USER;
    internal static UInt32 HCCE_LOCAL_MACHINE;
    internal static string szOID_PKCS_1;
    internal static string szOID_PKCS_2;
    internal static string szOID_PKCS_3;
    internal static string szOID_PKCS_4;
    internal static string szOID_PKCS_5;
    internal static string szOID_PKCS_6;
    internal static string szOID_PKCS_7;
    internal static string szOID_PKCS_8;
    internal static string szOID_PKCS_9;
    internal static string szOID_PKCS_10;
    internal static string szOID_PKCS_12;
    internal static string szOID_RSA_data;
    internal static string szOID_RSA_signedData;
    internal static string szOID_RSA_envelopedData;
    internal static string szOID_RSA_signEnvData;
    internal static string szOID_RSA_digestedData;
    internal static string szOID_RSA_hashedData;
    internal static string szOID_RSA_encryptedData;
    internal static string szOID_RSA_emailAddr;
    internal static string szOID_RSA_unstructName;
    internal static string szOID_RSA_contentType;
    internal static string szOID_RSA_messageDigest;
    internal static string szOID_RSA_signingTime;
    internal static string szOID_RSA_counterSign;
    internal static string szOID_RSA_challengePwd;
    internal static string szOID_RSA_unstructAddr;
    internal static string szOID_RSA_extCertAttrs;
    internal static string szOID_RSA_SMIMECapabilities;
    internal static string szOID_CAPICOM;
    internal static string szOID_CAPICOM_version;
    internal static string szOID_CAPICOM_attribute;
    internal static string szOID_CAPICOM_documentName;
    internal static string szOID_CAPICOM_documentDescription;
    internal static string szOID_CAPICOM_encryptedData;
    internal static string szOID_CAPICOM_encryptedContent;
    internal static string szOID_OIWSEC_sha1;
    internal static string szOID_RSA_MD5;
    internal static string szOID_OIWSEC_SHA256;
    internal static string szOID_OIWSEC_SHA384;
    internal static string szOID_OIWSEC_SHA512;
    internal static string szOID_RSA_RC2CBC;
    internal static string szOID_RSA_RC4;
    internal static string szOID_RSA_DES_EDE3_CBC;
    internal static string szOID_OIWSEC_desCBC;
    internal static string szOID_RSA_SMIMEalg;
    internal static string szOID_RSA_SMIMEalgESDH;
    internal static string szOID_RSA_SMIMEalgCMS3DESwrap;
    internal static string szOID_RSA_SMIMEalgCMSRC2wrap;
    internal static string szOID_X957_DSA;
    internal static string szOID_X957_sha1DSA;
    internal static string szOID_OIWSEC_sha1RSASign;
    internal static UInt32 CERT_ALT_NAME_OTHER_NAME;
    internal static UInt32 CERT_ALT_NAME_RFC822_NAME;
    internal static UInt32 CERT_ALT_NAME_DNS_NAME;
    internal static UInt32 CERT_ALT_NAME_X400_ADDRESS;
    internal static UInt32 CERT_ALT_NAME_DIRECTORY_NAME;
    internal static UInt32 CERT_ALT_NAME_EDI_PARTY_NAME;
    internal static UInt32 CERT_ALT_NAME_URL;
    internal static UInt32 CERT_ALT_NAME_IP_ADDRESS;
    internal static UInt32 CERT_ALT_NAME_REGISTERED_ID;
    internal static UInt32 CERT_RDN_ANY_TYPE;
    internal static UInt32 CERT_RDN_ENCODED_BLOB;
    internal static UInt32 CERT_RDN_OCTET_STRING;
    internal static UInt32 CERT_RDN_NUMERIC_STRING;
    internal static UInt32 CERT_RDN_PRINTABLE_STRING;
    internal static UInt32 CERT_RDN_TELETEX_STRING;
    internal static UInt32 CERT_RDN_T61_STRING;
    internal static UInt32 CERT_RDN_VIDEOTEX_STRING;
    internal static UInt32 CERT_RDN_IA5_STRING;
    internal static UInt32 CERT_RDN_GRAPHIC_STRING;
    internal static UInt32 CERT_RDN_VISIBLE_STRING;
    internal static UInt32 CERT_RDN_ISO646_STRING;
    internal static UInt32 CERT_RDN_GENERAL_STRING;
    internal static UInt32 CERT_RDN_UNIVERSAL_STRING;
    internal static UInt32 CERT_RDN_INT4_STRING;
    internal static UInt32 CERT_RDN_BMP_STRING;
    internal static UInt32 CERT_RDN_UNICODE_STRING;
    internal static UInt32 CERT_RDN_UTF8_STRING;
    internal static UInt32 CERT_RDN_TYPE_MASK;
    internal static UInt32 CERT_RDN_FLAGS_MASK;
    internal static UInt32 CERT_STORE_CTRL_RESYNC;
    internal static UInt32 CERT_STORE_CTRL_NOTIFY_CHANGE;
    internal static UInt32 CERT_STORE_CTRL_COMMIT;
    internal static UInt32 CERT_STORE_CTRL_AUTO_RESYNC;
    internal static UInt32 CERT_STORE_CTRL_CANCEL_NOTIFY;
    internal static UInt32 CERT_ID_ISSUER_SERIAL_NUMBER;
    internal static UInt32 CERT_ID_KEY_IDENTIFIER;
    internal static UInt32 CERT_ID_SHA1_HASH;
    internal static string MS_ENHANCED_PROV;
    internal static string MS_STRONG_PROV;
    internal static string MS_DEF_PROV;
    internal static string MS_DEF_DSS_DH_PROV;
    internal static string MS_ENH_DSS_DH_PROV;
    internal static string DummySignerCommonName;
    internal static UInt32 PROV_RSA_FULL;
    internal static UInt32 PROV_DSS_DH;
    internal static UInt32 ALG_TYPE_ANY;
    internal static UInt32 ALG_TYPE_DSS;
    internal static UInt32 ALG_TYPE_RSA;
    internal static UInt32 ALG_TYPE_BLOCK;
    internal static UInt32 ALG_TYPE_STREAM;
    internal static UInt32 ALG_TYPE_DH;
    internal static UInt32 ALG_TYPE_SECURECHANNEL;
    internal static UInt32 ALG_CLASS_ANY;
    internal static UInt32 ALG_CLASS_SIGNATURE;
    internal static UInt32 ALG_CLASS_MSG_ENCRYPT;
    internal static UInt32 ALG_CLASS_DATA_ENCRYPT;
    internal static UInt32 ALG_CLASS_HASH;
    internal static UInt32 ALG_CLASS_KEY_EXCHANGE;
    internal static UInt32 ALG_CLASS_ALL;
    internal static UInt32 ALG_SID_ANY;
    internal static UInt32 ALG_SID_RSA_ANY;
    internal static UInt32 ALG_SID_RSA_PKCS;
    internal static UInt32 ALG_SID_RSA_MSATWORK;
    internal static UInt32 ALG_SID_RSA_ENTRUST;
    internal static UInt32 ALG_SID_RSA_PGP;
    internal static UInt32 ALG_SID_DSS_ANY;
    internal static UInt32 ALG_SID_DSS_PKCS;
    internal static UInt32 ALG_SID_DSS_DMS;
    internal static UInt32 ALG_SID_DES;
    internal static UInt32 ALG_SID_3DES;
    internal static UInt32 ALG_SID_DESX;
    internal static UInt32 ALG_SID_IDEA;
    internal static UInt32 ALG_SID_CAST;
    internal static UInt32 ALG_SID_SAFERSK64;
    internal static UInt32 ALG_SID_SAFERSK128;
    internal static UInt32 ALG_SID_3DES_112;
    internal static UInt32 ALG_SID_CYLINK_MEK;
    internal static UInt32 ALG_SID_RC5;
    internal static UInt32 ALG_SID_AES_128;
    internal static UInt32 ALG_SID_AES_192;
    internal static UInt32 ALG_SID_AES_256;
    internal static UInt32 ALG_SID_AES;
    internal static UInt32 ALG_SID_SKIPJACK;
    internal static UInt32 ALG_SID_TEK;
    internal static UInt32 ALG_SID_RC2;
    internal static UInt32 ALG_SID_RC4;
    internal static UInt32 ALG_SID_SEAL;
    internal static UInt32 ALG_SID_DH_SANDF;
    internal static UInt32 ALG_SID_DH_EPHEM;
    internal static UInt32 ALG_SID_AGREED_KEY_ANY;
    internal static UInt32 ALG_SID_KEA;
    internal static UInt32 ALG_SID_MD2;
    internal static UInt32 ALG_SID_MD4;
    internal static UInt32 ALG_SID_MD5;
    internal static UInt32 ALG_SID_SHA;
    internal static UInt32 ALG_SID_SHA1;
    internal static UInt32 ALG_SID_MAC;
    internal static UInt32 ALG_SID_RIPEMD;
    internal static UInt32 ALG_SID_RIPEMD160;
    internal static UInt32 ALG_SID_SSL3SHAMD5;
    internal static UInt32 ALG_SID_HMAC;
    internal static UInt32 ALG_SID_TLS1PRF;
    internal static UInt32 ALG_SID_HASH_REPLACE_OWF;
    internal static UInt32 ALG_SID_SSL3_MASTER;
    internal static UInt32 ALG_SID_SCHANNEL_MASTER_HASH;
    internal static UInt32 ALG_SID_SCHANNEL_MAC_KEY;
    internal static UInt32 ALG_SID_PCT1_MASTER;
    internal static UInt32 ALG_SID_SSL2_MASTER;
    internal static UInt32 ALG_SID_TLS1_MASTER;
    internal static UInt32 ALG_SID_SCHANNEL_ENC_KEY;
    internal static UInt32 CALG_MD2;
    internal static UInt32 CALG_MD4;
    internal static UInt32 CALG_MD5;
    internal static UInt32 CALG_SHA;
    internal static UInt32 CALG_SHA1;
    internal static UInt32 CALG_MAC;
    internal static UInt32 CALG_RSA_SIGN;
    internal static UInt32 CALG_DSS_SIGN;
    internal static UInt32 CALG_NO_SIGN;
    internal static UInt32 CALG_RSA_KEYX;
    internal static UInt32 CALG_DES;
    internal static UInt32 CALG_3DES_112;
    internal static UInt32 CALG_3DES;
    internal static UInt32 CALG_DESX;
    internal static UInt32 CALG_RC2;
    internal static UInt32 CALG_RC4;
    internal static UInt32 CALG_SEAL;
    internal static UInt32 CALG_DH_SF;
    internal static UInt32 CALG_DH_EPHEM;
    internal static UInt32 CALG_AGREEDKEY_ANY;
    internal static UInt32 CALG_KEA_KEYX;
    internal static UInt32 CALG_HUGHES_MD5;
    internal static UInt32 CALG_SKIPJACK;
    internal static UInt32 CALG_TEK;
    internal static UInt32 CALG_CYLINK_MEK;
    internal static UInt32 CALG_SSL3_SHAMD5;
    internal static UInt32 CALG_SSL3_MASTER;
    internal static UInt32 CALG_SCHANNEL_MASTER_HASH;
    internal static UInt32 CALG_SCHANNEL_MAC_KEY;
    internal static UInt32 CALG_SCHANNEL_ENC_KEY;
    internal static UInt32 CALG_PCT1_MASTER;
    internal static UInt32 CALG_SSL2_MASTER;
    internal static UInt32 CALG_TLS1_MASTER;
    internal static UInt32 CALG_RC5;
    internal static UInt32 CALG_HMAC;
    internal static UInt32 CALG_TLS1PRF;
    internal static UInt32 CALG_HASH_REPLACE_OWF;
    internal static UInt32 CALG_AES_128;
    internal static UInt32 CALG_AES_192;
    internal static UInt32 CALG_AES_256;
    internal static UInt32 CALG_AES;
    internal static UInt32 CRYPT_FIRST;
    internal static UInt32 CRYPT_NEXT;
    internal static UInt32 PP_ENUMALGS_EX;
    internal static UInt32 CRYPT_VERIFYCONTEXT;
    internal static UInt32 CRYPT_NEWKEYSET;
    internal static UInt32 CRYPT_DELETEKEYSET;
    internal static UInt32 CRYPT_MACHINE_KEYSET;
    internal static UInt32 CRYPT_SILENT;
    internal static UInt32 CRYPT_USER_KEYSET;
    internal static UInt32 PKCS12_ALWAYS_CNG_KSP;
    internal static UInt32 PKCS12_NO_PERSIST_KEY;
    internal static UInt32 CRYPT_EXPORTABLE;
    internal static UInt32 CRYPT_USER_PROTECTED;
    internal static UInt32 CRYPT_CREATE_SALT;
    internal static UInt32 CRYPT_UPDATE_KEY;
    internal static UInt32 CRYPT_NO_SALT;
    internal static UInt32 CRYPT_PREGEN;
    internal static UInt32 CRYPT_RECIPIENT;
    internal static UInt32 CRYPT_INITIATOR;
    internal static UInt32 CRYPT_ONLINE;
    internal static UInt32 CRYPT_SF;
    internal static UInt32 CRYPT_CREATE_IV;
    internal static UInt32 CRYPT_KEK;
    internal static UInt32 CRYPT_DATA_KEY;
    internal static UInt32 CRYPT_VOLATILE;
    internal static UInt32 CRYPT_SGCKEY;
    internal static UInt32 CRYPT_ARCHIVABLE;
    internal static byte CUR_BLOB_VERSION;
    internal static byte SIMPLEBLOB;
    internal static byte PUBLICKEYBLOB;
    internal static byte PRIVATEKEYBLOB;
    internal static byte PLAINTEXTKEYBLOB;
    internal static byte OPAQUEKEYBLOB;
    internal static byte PUBLICKEYBLOBEX;
    internal static byte SYMMETRICWRAPKEYBLOB;
    internal static UInt32 DSS_MAGIC;
    internal static UInt32 DSS_PRIVATE_MAGIC;
    internal static UInt32 DSS_PUB_MAGIC_VER3;
    internal static UInt32 DSS_PRIV_MAGIC_VER3;
    internal static UInt32 RSA_PUB_MAGIC;
    internal static UInt32 RSA_PRIV_MAGIC;
    internal static UInt32 CRYPT_ACQUIRE_CACHE_FLAG;
    internal static UInt32 CRYPT_ACQUIRE_USE_PROV_INFO_FLAG;
    internal static UInt32 CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
    internal static UInt32 CRYPT_ACQUIRE_SILENT_FLAG;
    internal static UInt32 CMSG_BARE_CONTENT_FLAG;
    internal static UInt32 CMSG_LENGTH_ONLY_FLAG;
    internal static UInt32 CMSG_DETACHED_FLAG;
    internal static UInt32 CMSG_AUTHENTICATED_ATTRIBUTES_FLAG;
    internal static UInt32 CMSG_CONTENTS_OCTETS_FLAG;
    internal static UInt32 CMSG_MAX_LENGTH_FLAG;
    internal static UInt32 CMSG_TYPE_PARAM;
    internal static UInt32 CMSG_CONTENT_PARAM;
    internal static UInt32 CMSG_BARE_CONTENT_PARAM;
    internal static UInt32 CMSG_INNER_CONTENT_TYPE_PARAM;
    internal static UInt32 CMSG_SIGNER_COUNT_PARAM;
    internal static UInt32 CMSG_SIGNER_INFO_PARAM;
    internal static UInt32 CMSG_SIGNER_CERT_INFO_PARAM;
    internal static UInt32 CMSG_SIGNER_HASH_ALGORITHM_PARAM;
    internal static UInt32 CMSG_SIGNER_AUTH_ATTR_PARAM;
    internal static UInt32 CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    internal static UInt32 CMSG_CERT_COUNT_PARAM;
    internal static UInt32 CMSG_CERT_PARAM;
    internal static UInt32 CMSG_CRL_COUNT_PARAM;
    internal static UInt32 CMSG_CRL_PARAM;
    internal static UInt32 CMSG_ENVELOPE_ALGORITHM_PARAM;
    internal static UInt32 CMSG_RECIPIENT_COUNT_PARAM;
    internal static UInt32 CMSG_RECIPIENT_INDEX_PARAM;
    internal static UInt32 CMSG_RECIPIENT_INFO_PARAM;
    internal static UInt32 CMSG_HASH_ALGORITHM_PARAM;
    internal static UInt32 CMSG_HASH_DATA_PARAM;
    internal static UInt32 CMSG_COMPUTED_HASH_PARAM;
    internal static UInt32 CMSG_ENCRYPT_PARAM;
    internal static UInt32 CMSG_ENCRYPTED_DIGEST;
    internal static UInt32 CMSG_ENCODED_SIGNER;
    internal static UInt32 CMSG_ENCODED_MESSAGE;
    internal static UInt32 CMSG_VERSION_PARAM;
    internal static UInt32 CMSG_ATTR_CERT_COUNT_PARAM;
    internal static UInt32 CMSG_ATTR_CERT_PARAM;
    internal static UInt32 CMSG_CMS_RECIPIENT_COUNT_PARAM;
    internal static UInt32 CMSG_CMS_RECIPIENT_INDEX_PARAM;
    internal static UInt32 CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM;
    internal static UInt32 CMSG_CMS_RECIPIENT_INFO_PARAM;
    internal static UInt32 CMSG_UNPROTECTED_ATTR_PARAM;
    internal static UInt32 CMSG_SIGNER_CERT_ID_PARAM;
    internal static UInt32 CMSG_CMS_SIGNER_INFO_PARAM;
    internal static UInt32 CMSG_CTRL_VERIFY_SIGNATURE;
    internal static UInt32 CMSG_CTRL_DECRYPT;
    internal static UInt32 CMSG_CTRL_VERIFY_HASH;
    internal static UInt32 CMSG_CTRL_ADD_SIGNER;
    internal static UInt32 CMSG_CTRL_DEL_SIGNER;
    internal static UInt32 CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR;
    internal static UInt32 CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR;
    internal static UInt32 CMSG_CTRL_ADD_CERT;
    internal static UInt32 CMSG_CTRL_DEL_CERT;
    internal static UInt32 CMSG_CTRL_ADD_CRL;
    internal static UInt32 CMSG_CTRL_DEL_CRL;
    internal static UInt32 CMSG_CTRL_ADD_ATTR_CERT;
    internal static UInt32 CMSG_CTRL_DEL_ATTR_CERT;
    internal static UInt32 CMSG_CTRL_KEY_TRANS_DECRYPT;
    internal static UInt32 CMSG_CTRL_KEY_AGREE_DECRYPT;
    internal static UInt32 CMSG_CTRL_MAIL_LIST_DECRYPT;
    internal static UInt32 CMSG_CTRL_VERIFY_SIGNATURE_EX;
    internal static UInt32 CMSG_CTRL_ADD_CMS_SIGNER_INFO;
    internal static UInt32 CMSG_VERIFY_SIGNER_PUBKEY;
    internal static UInt32 CMSG_VERIFY_SIGNER_CERT;
    internal static UInt32 CMSG_VERIFY_SIGNER_CHAIN;
    internal static UInt32 CMSG_VERIFY_SIGNER_NULL;
    internal static UInt32 CMSG_DATA;
    internal static UInt32 CMSG_SIGNED;
    internal static UInt32 CMSG_ENVELOPED;
    internal static UInt32 CMSG_SIGNED_AND_ENVELOPED;
    internal static UInt32 CMSG_HASHED;
    internal static UInt32 CMSG_ENCRYPTED;
    internal static UInt32 CMSG_KEY_TRANS_RECIPIENT;
    internal static UInt32 CMSG_KEY_AGREE_RECIPIENT;
    internal static UInt32 CMSG_MAIL_LIST_RECIPIENT;
    internal static UInt32 CMSG_KEY_AGREE_ORIGINATOR_CERT;
    internal static UInt32 CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
    internal static UInt32 CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
    internal static UInt32 CMSG_KEY_AGREE_STATIC_KEY_CHOICE;
    internal static UInt32 CMSG_ENVELOPED_RECIPIENT_V0;
    internal static UInt32 CMSG_ENVELOPED_RECIPIENT_V2;
    internal static UInt32 CMSG_ENVELOPED_RECIPIENT_V3;
    internal static UInt32 CMSG_ENVELOPED_RECIPIENT_V4;
    internal static UInt32 CMSG_KEY_TRANS_PKCS_1_5_VERSION;
    internal static UInt32 CMSG_KEY_TRANS_CMS_VERSION;
    internal static UInt32 CMSG_KEY_AGREE_VERSION;
    internal static UInt32 CMSG_MAIL_LIST_VERSION;
    internal static UInt32 CRYPT_RC2_40BIT_VERSION;
    internal static UInt32 CRYPT_RC2_56BIT_VERSION;
    internal static UInt32 CRYPT_RC2_64BIT_VERSION;
    internal static UInt32 CRYPT_RC2_128BIT_VERSION;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int NTE_NO_KEY;
    internal static int NTE_BAD_PUBLIC_KEY;
    internal static int NTE_BAD_KEYSET;
    internal static int CRYPT_E_MSG_ERROR;
    internal static int CRYPT_E_UNKNOWN_ALGO;
    internal static int CRYPT_E_INVALID_MSG_TYPE;
    internal static int CRYPT_E_RECIPIENT_NOT_FOUND;
    internal static int CRYPT_E_ISSUER_SERIALNUMBER;
    internal static int CRYPT_E_SIGNER_NOT_FOUND;
    internal static int CRYPT_E_ATTRIBUTES_MISSING;
    internal static int CRYPT_E_BAD_ENCODE;
    internal static int CRYPT_E_NOT_FOUND;
    internal static int CRYPT_E_NO_MATCH;
    internal static int CRYPT_E_NO_SIGNER;
    internal static int CRYPT_E_REVOKED;
    internal static int CRYPT_E_NO_REVOCATION_CHECK;
    internal static int CRYPT_E_REVOCATION_OFFLINE;
    internal static int CRYPT_E_ASN1_BADTAG;
    internal static int CERTSRV_E_WEAK_SIGNATURE_OR_KEY;
    internal static int TRUST_E_CERT_SIGNATURE;
    internal static int TRUST_E_BASIC_CONSTRAINTS;
    internal static int CERT_E_EXPIRED;
    internal static int CERT_E_VALIDITYPERIODNESTING;
    internal static int CERT_E_CRITICAL;
    internal static int CERT_E_UNTRUSTEDROOT;
    internal static int CERT_E_CHAINING;
    internal static int TRUST_E_FAIL;
    internal static int CERT_E_REVOKED;
    internal static int CERT_E_UNTRUSTEDTESTROOT;
    internal static int CERT_E_REVOCATION_FAILURE;
    internal static int CERT_E_WRONG_USAGE;
    internal static int TRUST_E_EXPLICIT_DISTRUST;
    internal static int CERT_E_INVALID_POLICY;
    internal static int CERT_E_INVALID_NAME;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_CALL_NOT_IMPLEMENTED;
    internal static int ERROR_CANCELLED;
}
internal abstract class System.Security.Cryptography.CAPIMethods : CAPIUnsafe {
}
internal abstract class System.Security.Cryptography.CAPINative : CAPIBase {
}
[SuppressUnmanagedCodeSecurityAttribute]
internal abstract class System.Security.Cryptography.CAPISafe : CAPINative {
    internal static UInt32 FormatMessage(UInt32 dwFlags, IntPtr lpSource, UInt32 dwMessageId, UInt32 dwLanguageId, StringBuilder lpBuffer, UInt32 nSize, IntPtr Arguments);
    public static bool FreeLibrary(IntPtr hModule);
    internal static IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    internal static SafeLocalAllocHandle LocalAlloc(UInt32 uFlags, IntPtr sizetdwBytes);
    internal static IntPtr LoadLibrary(string lpFileName);
    internal static bool CertControlStore(SafeCertStoreHandle hCertStore, UInt32 dwFlags, UInt32 dwCtrlType, IntPtr pvCtrlPara);
    internal static SafeCertContextHandle CertCreateCertificateContext(UInt32 dwCertEncodingType, SafeLocalAllocHandle pbCertEncoded, UInt32 cbCertEncoded);
    internal static SafeCertContextHandle CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static SafeCertContextHandle CertDuplicateCertificateContext(SafeCertContextHandle pCertContext);
    internal static SafeX509ChainHandle CertDuplicateCertificateChain(IntPtr pChainContext);
    internal static SafeX509ChainHandle CertDuplicateCertificateChain(SafeX509ChainHandle pChainContext);
    internal static SafeCertStoreHandle CertDuplicateStore(IntPtr hCertStore);
    internal static IntPtr CertFindExtension(string pszObjId, UInt32 cExtensions, IntPtr rgExtensions);
    protected internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    internal static bool CertGetCertificateChain(IntPtr hChainEngine, SafeCertContextHandle pCertContext, FILETIME& pTime, SafeCertStoreHandle hAdditionalStore, CERT_CHAIN_PARA& pChainPara, UInt32 dwFlags, IntPtr pvReserved, SafeX509ChainHandle& ppChainContext);
    internal static bool CertGetCertificateContextProperty(SafeCertContextHandle pCertContext, UInt32 dwPropId, SafeLocalAllocHandle pvData, UInt32& pcbData);
    internal static bool CertGetIntendedKeyUsage(UInt32 dwCertEncodingType, IntPtr pCertInfo, IntPtr pbKeyUsage, UInt32 cbKeyUsage);
    internal static UInt32 CertGetNameStringW(SafeCertContextHandle pCertContext, UInt32 dwType, UInt32 dwFlags, IntPtr pvTypePara, SafeLocalAllocHandle pszNameString, UInt32 cchNameString);
    internal static UInt32 CertGetPublicKeyLength(UInt32 dwCertEncodingType, IntPtr pPublicKey);
    internal static bool CertGetValidUsages(UInt32 cCerts, IntPtr rghCerts, IntPtr cNumOIDs, SafeLocalAllocHandle rghOIDs, IntPtr pcbOIDs);
    internal static UInt32 CertNameToStrW(UInt32 dwCertEncodingType, IntPtr pName, UInt32 dwStrType, SafeLocalAllocHandle psz, UInt32 csz);
    internal static bool CertSerializeCertificateStoreElement(SafeCertContextHandle pCertContext, UInt32 dwFlags, SafeLocalAllocHandle pbElement, IntPtr pcbElement);
    internal static bool CertStrToNameW(UInt32 dwCertEncodingType, string pszX500, UInt32 dwStrType, IntPtr pvReserved, IntPtr pbEncoded, UInt32& pcbEncoded, IntPtr ppszError);
    internal static int CertVerifyTimeValidity(FILETIME& pTimeToVerify, IntPtr pCertInfo);
    internal static bool CertVerifyCertificateChainPolicy(IntPtr pszPolicyOID, SafeX509ChainHandle pChainContext, CERT_CHAIN_POLICY_PARA& pPolicyPara, CERT_CHAIN_POLICY_STATUS& pPolicyStatus);
    internal static bool CryptAcquireCertificatePrivateKey(SafeCertContextHandle pCert, UInt32 dwFlags, IntPtr pvReserved, SafeCryptProvHandle& phCryptProv, UInt32& pdwKeySpec, Boolean& pfCallerFreeProv);
    internal static bool CryptDecodeObject(UInt32 dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, SafeLocalAllocHandle pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptDecodeObject(UInt32 dwCertEncodingType, IntPtr lpszStructType, Byte[] pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, SafeLocalAllocHandle pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptEncodeObject(UInt32 dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, SafeLocalAllocHandle pbEncoded, IntPtr pcbEncoded);
    internal static bool CryptEncodeObject(UInt32 dwCertEncodingType, string lpszStructType, IntPtr pvStructInfo, SafeLocalAllocHandle pbEncoded, IntPtr pcbEncoded);
    internal static IntPtr CryptFindOIDInfo(UInt32 dwKeyType, IntPtr pvKey, OidGroup dwGroupId);
    internal static IntPtr CryptFindOIDInfo(UInt32 dwKeyType, SafeLocalAllocHandle pvKey, OidGroup dwGroupId);
    internal static bool CryptFormatObject(UInt32 dwCertEncodingType, UInt32 dwFormatType, UInt32 dwFormatStrType, IntPtr pFormatStruct, string lpszStructType, Byte[] pbEncoded, UInt32 cbEncoded, SafeLocalAllocHandle pbFormat, IntPtr pcbFormat);
    internal static bool CryptFormatObject(UInt32 dwCertEncodingType, UInt32 dwFormatType, UInt32 dwFormatStrType, IntPtr pFormatStruct, IntPtr lpszStructType, Byte[] pbEncoded, UInt32 cbEncoded, SafeLocalAllocHandle pbFormat, IntPtr pcbFormat);
    internal static bool CryptGetProvParam(SafeCryptProvHandle hProv, UInt32 dwParam, IntPtr pbData, IntPtr pdwDataLen, UInt32 dwFlags);
    internal static bool CryptHashCertificate(IntPtr hCryptProv, UInt32 Algid, UInt32 dwFlags, IntPtr pbEncoded, UInt32 cbEncoded, IntPtr pbComputedHash, IntPtr pcbComputedHash);
    internal static bool CryptHashPublicKeyInfo(IntPtr hCryptProv, UInt32 Algid, UInt32 dwFlags, UInt32 dwCertEncodingType, IntPtr pInfo, IntPtr pbComputedHash, IntPtr pcbComputedHash);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, UInt32 dwParamType, UInt32 dwIndex, IntPtr pvData, IntPtr pcbData);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, UInt32 dwParamType, UInt32 dwIndex, SafeLocalAllocHandle pvData, IntPtr pcbData);
    internal static SafeCryptMsgHandle CryptMsgOpenToDecode(UInt32 dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, IntPtr hCryptProv, IntPtr pRecipientInfo, IntPtr pStreamInfo);
    internal static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, Byte[] pbData, UInt32 cbData, bool fFinal);
    internal static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, IntPtr pbData, UInt32 cbData, bool fFinal);
    internal static bool CryptMsgVerifyCountersignatureEncoded(IntPtr hCryptProv, UInt32 dwEncodingType, IntPtr pbSignerInfo, UInt32 cbSignerInfo, IntPtr pbSignerInfoCountersignature, UInt32 cbSignerInfoCountersignature, IntPtr pciCountersigner);
    internal static void SetLastError(UInt32 dwErrorCode);
    [ReliabilityContractAttribute("3", "2")]
internal static IntPtr LocalFree(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
internal static void ZeroMemory(IntPtr handle, UInt32 length);
    [ReliabilityContractAttribute("3", "2")]
internal static int LsaNtStatusToWinError(int status);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal abstract class System.Security.Cryptography.CAPIUnsafe : CAPISafe {
    protected internal static bool CryptAcquireContext(SafeCryptProvHandle& hCryptProv, string pszContainer, string pszProvider, UInt32 dwProvType, UInt32 dwFlags);
    protected internal static bool CertAddCertificateContextToStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pCertContext, UInt32 dwAddDisposition, SafeCertContextHandle ppStoreContext);
    protected internal static bool CertAddCertificateLinkToStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pCertContext, UInt32 dwAddDisposition, SafeCertContextHandle ppStoreContext);
    protected internal static bool CertDeleteCertificateFromStore(SafeCertContextHandle pCertContext);
    protected internal static IntPtr CertEnumCertificatesInStore(SafeCertStoreHandle hCertStore, IntPtr pPrevCertContext);
    protected internal static SafeCertContextHandle CertEnumCertificatesInStore(SafeCertStoreHandle hCertStore, SafeCertContextHandle pPrevCertContext);
    protected internal static SafeCertContextHandle CertFindCertificateInStore(SafeCertStoreHandle hCertStore, UInt32 dwCertEncodingType, UInt32 dwFindFlags, UInt32 dwFindType, IntPtr pvFindPara, SafeCertContextHandle pPrevCertContext);
    protected internal static SafeCertStoreHandle CertOpenStore(IntPtr lpszStoreProvider, UInt32 dwMsgAndCertEncodingType, IntPtr hCryptProv, UInt32 dwFlags, string pvPara);
    protected internal static bool CertSaveStore(SafeCertStoreHandle hCertStore, UInt32 dwMsgAndCertEncodingType, UInt32 dwSaveAs, UInt32 dwSaveTo, IntPtr pvSaveToPara, UInt32 dwFlags);
    protected internal static bool CertSetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, UInt32 dwFlags, IntPtr pvData);
    protected internal static bool CertSetCertificateContextProperty(SafeCertContextHandle pCertContext, UInt32 dwPropId, UInt32 dwFlags, IntPtr pvData);
    protected internal static bool CertSetCertificateContextProperty(SafeCertContextHandle pCertContext, UInt32 dwPropId, UInt32 dwFlags, SafeLocalAllocHandle safeLocalAllocHandle);
    protected internal static SafeCertContextHandle CertCreateSelfSignCertificate(SafeCryptProvHandle hProv, IntPtr pSubjectIssuerBlob, UInt32 dwFlags, IntPtr pKeyProvInfo, IntPtr pSignatureAlgorithm, IntPtr pStartTime, IntPtr pEndTime, IntPtr pExtensions);
    protected internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, UInt32 dwCtrlType, IntPtr pvCtrlPara);
    protected internal static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, UInt32 cCountersigners, IntPtr rgCountersigners);
    protected internal static SafeCryptMsgHandle CryptMsgOpenToEncode(UInt32 dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, IntPtr pvMsgEncodeInfo, IntPtr pszInnerContentObjID, IntPtr pStreamInfo);
    protected internal static SafeCryptMsgHandle CryptMsgOpenToEncode(UInt32 dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, IntPtr pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    protected internal static bool CryptQueryObject(UInt32 dwObjectType, IntPtr pvObject, UInt32 dwExpectedContentTypeFlags, UInt32 dwExpectedFormatTypeFlags, UInt32 dwFlags, IntPtr pdwMsgAndCertEncodingType, IntPtr pdwContentType, IntPtr pdwFormatType, IntPtr phCertStore, IntPtr phMsg, IntPtr ppvContext);
    protected internal static bool CryptQueryObject(UInt32 dwObjectType, IntPtr pvObject, UInt32 dwExpectedContentTypeFlags, UInt32 dwExpectedFormatTypeFlags, UInt32 dwFlags, IntPtr pdwMsgAndCertEncodingType, IntPtr pdwContentType, IntPtr pdwFormatType, SafeCertStoreHandle& phCertStore, IntPtr phMsg, IntPtr ppvContext);
    internal static bool CryptProtectData(IntPtr pDataIn, string szDataDescr, IntPtr pOptionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, UInt32 dwFlags, IntPtr pDataBlob);
    internal static bool CryptUnprotectData(IntPtr pDataIn, IntPtr ppszDataDescr, IntPtr pOptionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, UInt32 dwFlags, IntPtr pDataBlob);
    protected internal static bool PFXExportCertStore(SafeCertStoreHandle hStore, IntPtr pPFX, string szPassword, UInt32 dwFlags);
    protected internal static SafeCertStoreHandle PFXImportCertStore(IntPtr pPFX, string szPassword, UInt32 dwFlags);
}
public class System.Security.Cryptography.Oid : object {
    public string Value { get; public set; }
    public string FriendlyName { get; public set; }
    public Oid(string oid);
    internal Oid(string oid, OidGroup group, bool lookupFriendlyName);
    public Oid(string value, string friendlyName);
    public Oid(Oid oid);
    public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    public static Oid FromOidValue(string oidValue, OidGroup group);
    public string get_Value();
    public void set_Value(string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    public Oid Item { get; }
    public Oid Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Add(Oid oid);
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual int get_Count();
    public OidEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Oid[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.OidEnumerator : object {
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OidEnumerator(OidCollection oids);
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
internal class System.Security.Cryptography.SafeCertContextHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertContextHandle InvalidHandle { get; }
    internal SafeCertContextHandle(IntPtr handle);
    internal static SafeCertContextHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeCertStoreHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCertStoreHandle InvalidHandle { get; }
    internal SafeCertStoreHandle(IntPtr handle);
    internal static SafeCertStoreHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeCryptMsgHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCryptMsgHandle InvalidHandle { get; }
    internal SafeCryptMsgHandle(IntPtr handle);
    internal static SafeCryptMsgHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeCryptProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeCryptProvHandle InvalidHandle { get; }
    internal SafeCryptProvHandle(IntPtr handle);
    internal static SafeCryptProvHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeLocalAllocHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeLocalAllocHandle InvalidHandle { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    internal static SafeLocalAllocHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    internal UInt32 AlgorithmId { get; }
    public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public AsnEncodedData EncodedKeyValue { get; }
    public AsnEncodedData EncodedParameters { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    internal PublicKey(PublicKey publicKey);
    internal UInt32 get_AlgorithmId();
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
    public AsnEncodedData get_EncodedKeyValue();
    public AsnEncodedData get_EncodedParameters();
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    public string Name { get; }
    internal X500DistinguishedName(CRYPTOAPI_BLOB encodedDistinguishedNameBlob);
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    internal static X509KeyStorageFlags KeyStorageFlags47;
    internal static X509KeyStorageFlags KeyStorageFlagsAll;
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public X500DistinguishedName SubjectName { get; }
    public Oid SignatureAlgorithm { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    internal SafeCertContextHandle CertContext { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    public X509Certificate2(Byte[] rawData, SecureString password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    public X509Certificate2(string fileName, SecureString password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    public X509Certificate2(X509Certificate certificate);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public bool get_HasPrivateKey();
    public AsymmetricAlgorithm get_PrivateKey();
    public void set_PrivateKey(AsymmetricAlgorithm value);
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public X500DistinguishedName get_SubjectName();
    public Oid get_SignatureAlgorithm();
    public string get_Thumbprint();
    public int get_Version();
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Reset();
    public bool Verify();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    internal SafeCertContextHandle get_CertContext();
    internal static bool GetPrivateKeyInfo(SafeCertContextHandle safeCertContext, CspParameters& parameters);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    public void Insert(int index, X509Certificate2 certificate);
    public X509Certificate2Enumerator GetEnumerator();
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection mappings);
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509CertificateCollection value);
    public X509CertificateCollection(X509Certificate[] value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public X509CertificateEnumerator GetEnumerator();
    public void Remove(X509Certificate value);
    public virtual int GetHashCode();
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    public IntPtr ChainContext { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public X509ChainElementCollection ChainElements { get; }
    [SecurityCriticalAttribute]
public X509Chain(bool useMachineContext);
    public X509Chain(IntPtr chainContext);
    private static X509Chain();
    public static X509Chain Create();
    public IntPtr get_ChainContext();
    [SecurityCriticalAttribute]
public SafeX509ChainHandle get_SafeHandle();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public X509ChainElementCollection get_ChainElements();
    public bool Build(X509Certificate2 certificate);
    [SecurityCriticalAttribute]
public void Reset();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    internal static X509ChainStatus[] GetChainStatusInformation(UInt32 dwStatus);
    [SecurityCriticalAttribute]
internal static int BuildChain(IntPtr hChainEngine, SafeCertContextHandle pCertContext, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout, SafeX509ChainHandle& ppChainContext);
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    public X509Certificate2 Certificate { get; }
    public X509ChainStatus[] ChainElementStatus { get; }
    public string Information { get; }
    internal X509ChainElement(IntPtr pChainElement);
    public X509Certificate2 get_Certificate();
    public X509ChainStatus[] get_ChainElementStatus();
    public string get_Information();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    public X509ChainElement Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal X509ChainElementCollection(IntPtr pSimpleChain);
    public X509ChainElement get_Item(int index);
    public sealed virtual int get_Count();
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(X509ChainElement[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public X509Certificate2Collection ExtraStore { get; }
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    public TimeSpan get_UrlRetrievalTimeout();
    public void set_UrlRetrievalTimeout(TimeSpan value);
    public X509Certificate2Collection get_ExtraStore();
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    private X509ChainStatusFlags m_status;
    private string m_statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    public X509ChainStatusFlags get_Status();
    public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    public bool Critical { get; public set; }
    internal X509Extension(string oid);
    internal X509Extension(IntPtr pExtension);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public bool get_Critical();
    public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal X509ExtensionCollection(SafeCertContextHandle safeCertContextHandle);
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public sealed virtual int get_Count();
    public int Add(X509Extension extension);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(X509Extension[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    public IntPtr StoreHandle { get; }
    public StoreLocation Location { get; }
    public string Name { get; }
    public X509Certificate2Collection Certificates { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(IntPtr storeHandle);
    public IntPtr get_StoreHandle();
    public StoreLocation get_Location();
    public string get_Name();
    public void Open(OpenFlags flags);
    public sealed virtual void Dispose();
    public void Close();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public X509Certificate2Collection get_Certificates();
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
internal class System.Security.Cryptography.X509Certificates.X509Utils : object {
    private static X509Utils();
    internal static bool IsCertRdnCharString(UInt32 dwValueType);
    internal static X509ContentType MapContentType(UInt32 contentType);
    internal static UInt32 MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    internal static UInt32 MapX509StoreFlags(StoreLocation storeLocation, OpenFlags flags);
    internal static UInt32 MapNameType(X509NameType nameType);
    internal static UInt32 MapRevocationFlags(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag);
    internal static string EncodeHexString(Byte[] sArray);
    internal static string EncodeHexString(Byte[] sArray, UInt32 start, UInt32 end);
    internal static string EncodeHexStringFromInt(Byte[] sArray, UInt32 start, UInt32 end);
    internal static byte HexToByte(char val);
    internal static UInt32 AlignedLength(UInt32 length);
    internal static string DiscardWhiteSpaces(string inputBuffer);
    internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
    internal static Byte[] DecodeHexString(string s);
    internal static int GetHexArraySize(Byte[] hex);
    internal static SafeLocalAllocHandle ByteToPtr(Byte[] managed);
    internal static void memcpy(IntPtr source, IntPtr dest, UInt32 size);
    internal static Byte[] PtrToByte(IntPtr unmanaged, UInt32 size);
    internal static bool MemEqual(Byte* pbBuf1, UInt32 cbBuf1, Byte* pbBuf2, UInt32 cbBuf2);
    internal static SafeLocalAllocHandle StringToAnsiPtr(string s);
    internal static SafeLocalAllocHandle StringToUniPtr(string s);
    internal static SafeCertStoreHandle ExportToMemoryStore(X509Certificate2Collection collection);
    internal static UInt32 OidToAlgId(string value);
    internal static string FindOidInfo(UInt32 keyType, string keyValue, OidGroup oidGroup);
    internal static string FindOidInfoWithFallback(UInt32 key, string value, OidGroup group);
    internal static void ValidateOidValue(string keyValue);
    internal static SafeLocalAllocHandle CopyOidsToUnmanagedMemory(OidCollection oids);
    internal static X509Certificate2Collection GetCertificates(SafeCertStoreHandle safeCertStoreHandle);
    internal static int VerifyCertificate(SafeCertContextHandle pCertContext, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout, X509Certificate2Collection extraStore, IntPtr pszPolicy, IntPtr pdwErrorStatus);
    internal static string GetSystemErrorString(int hr);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
public abstract class System.Security.Permissions.ResourcePermissionBase : CodeAccessPermission {
    public static string Any;
    public static string Local;
    protected Type PermissionAccessType { get; protected set; }
    protected String[] TagNames { get; protected set; }
    protected ResourcePermissionBase(PermissionState state);
    protected Type get_PermissionAccessType();
    protected void set_PermissionAccessType(Type value);
    protected String[] get_TagNames();
    protected void set_TagNames(String[] value);
    protected void AddPermissionAccess(ResourcePermissionBaseEntry entry);
    protected void Clear();
    public virtual IPermission Copy();
    protected ResourcePermissionBaseEntry[] GetPermissionEntries();
    public virtual void FromXml(SecurityElement securityElement);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
}
public class System.Security.Permissions.ResourcePermissionBaseEntry : object {
    public int PermissionAccess { get; }
    public String[] PermissionAccessPath { get; }
    public ResourcePermissionBaseEntry(int permissionAccess, String[] permissionAccessPath);
    public int get_PermissionAccess();
    public String[] get_PermissionAccessPath();
}
public class System.Security.Permissions.StorePermission : CodeAccessPermission {
    public StorePermissionFlags Flags { get; public set; }
    public StorePermission(PermissionState state);
    public StorePermission(StorePermissionFlags flag);
    public void set_Flags(StorePermissionFlags value);
    public StorePermissionFlags get_Flags();
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    internal static void VerifyFlags(StorePermissionFlags flags);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.StorePermissionAttribute : CodeAccessSecurityAttribute {
    public StorePermissionFlags Flags { get; public set; }
    public bool CreateStore { get; public set; }
    public bool DeleteStore { get; public set; }
    public bool EnumerateStores { get; public set; }
    public bool OpenStore { get; public set; }
    public bool AddToStore { get; public set; }
    public bool RemoveFromStore { get; public set; }
    public bool EnumerateCertificates { get; public set; }
    public StorePermissionAttribute(SecurityAction action);
    public StorePermissionFlags get_Flags();
    public void set_Flags(StorePermissionFlags value);
    public bool get_CreateStore();
    public void set_CreateStore(bool value);
    public bool get_DeleteStore();
    public void set_DeleteStore(bool value);
    public bool get_EnumerateStores();
    public void set_EnumerateStores(bool value);
    public bool get_OpenStore();
    public void set_OpenStore(bool value);
    public bool get_AddToStore();
    public void set_AddToStore(bool value);
    public bool get_RemoveFromStore();
    public void set_RemoveFromStore(bool value);
    public bool get_EnumerateCertificates();
    public void set_EnumerateCertificates(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.StorePermissionFlags : Enum {
    public int value__;
    public static StorePermissionFlags NoFlags;
    public static StorePermissionFlags CreateStore;
    public static StorePermissionFlags DeleteStore;
    public static StorePermissionFlags EnumerateStores;
    public static StorePermissionFlags OpenStore;
    public static StorePermissionFlags AddToStore;
    public static StorePermissionFlags RemoveFromStore;
    public static StorePermissionFlags EnumerateCertificates;
    public static StorePermissionFlags AllFlags;
}
public class System.Security.Permissions.TypeDescriptorPermission : CodeAccessPermission {
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public TypeDescriptorPermission(PermissionState state);
    public TypeDescriptorPermission(TypeDescriptorPermissionFlags flag);
    public void set_Flags(TypeDescriptorPermissionFlags value);
    public TypeDescriptorPermissionFlags get_Flags();
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Copy();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement securityElement);
    internal static void VerifyFlags(TypeDescriptorPermissionFlags flags);
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.TypeDescriptorPermissionAttribute : CodeAccessSecurityAttribute {
    public TypeDescriptorPermissionFlags Flags { get; public set; }
    public bool RestrictedRegistrationAccess { get; public set; }
    public TypeDescriptorPermissionAttribute(SecurityAction action);
    public TypeDescriptorPermissionFlags get_Flags();
    public void set_Flags(TypeDescriptorPermissionFlags value);
    public bool get_RestrictedRegistrationAccess();
    public void set_RestrictedRegistrationAccess(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.TypeDescriptorPermissionFlags : Enum {
    public int value__;
    public static TypeDescriptorPermissionFlags NoFlags;
    public static TypeDescriptorPermissionFlags RestrictedRegistrationAccess;
}
[EditorBrowsableAttribute("1")]
public static class System.Security.SecureStringMarshal : object {
    [SecuritySafeCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    [SecuritySafeCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    [SecuritySafeCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    [SecuritySafeCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
}
internal static class System.SecurityUtils : object {
    private static SecurityUtils();
    internal static object SecureCreateInstance(Type type);
    internal static object SecureCreateInstance(Type type, Object[] args, bool allowNonPublic);
    internal static object SecureCreateInstance(Type type, Object[] args);
    internal static object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic);
    internal static object SecureConstructorInvoke(Type type, Type[] argTypes, Object[] args, bool allowNonPublic, BindingFlags extraFlags);
    internal static object FieldInfoGetValue(FieldInfo field, object target);
    internal static object MethodInfoInvoke(MethodInfo method, object target, Object[] args);
    internal static object ConstructorInfoInvoke(ConstructorInfo ctor, Object[] args);
    internal static object ArrayCreateInstance(Type type, int length);
}
internal class System.SR : object {
    internal static string RTL;
    internal static string ContinueButtonText;
    internal static string DebugAssertBanner;
    internal static string DebugAssertShortMessage;
    internal static string DebugAssertLongMessage;
    internal static string DebugMessageTruncated;
    internal static string DebugAssertTitle;
    internal static string NotSupported;
    internal static string DebugLaunchFailed;
    internal static string DebugLaunchFailedTitle;
    internal static string ObjectDisposed;
    internal static string ExceptionOccurred;
    internal static string MustAddListener;
    internal static string ToStringNull;
    internal static string EnumConverterInvalidValue;
    internal static string ConvertFromException;
    internal static string ConvertToException;
    internal static string ConvertInvalidPrimitive;
    internal static string ErrorMissingPropertyAccessors;
    internal static string ErrorInvalidPropertyType;
    internal static string ErrorMissingEventAccessors;
    internal static string ErrorInvalidEventHandler;
    internal static string ErrorInvalidEventType;
    internal static string InvalidMemberName;
    internal static string ErrorBadExtenderType;
    internal static string NullableConverterBadCtorArg;
    internal static string TypeDescriptorExpectedElementType;
    internal static string TypeDescriptorSameAssociation;
    internal static string TypeDescriptorAlreadyAssociated;
    internal static string TypeDescriptorProviderError;
    internal static string TypeDescriptorUnsupportedRemoteObject;
    internal static string TypeDescriptorArgsCountMismatch;
    internal static string ErrorCreateSystemEvents;
    internal static string ErrorCreateTimer;
    internal static string ErrorKillTimer;
    internal static string ErrorSystemEventsNotSupported;
    internal static string ErrorGetTempPath;
    internal static string CHECKOUTCanceled;
    internal static string ErrorInvalidServiceInstance;
    internal static string ErrorServiceExists;
    internal static string Argument_InvalidNumberStyles;
    internal static string Argument_InvalidHexStyle;
    internal static string Argument_ByteArrayLengthMustBeAMultipleOf4;
    internal static string Argument_InvalidCharactersInString;
    internal static string Argument_ParsedStringWasInvalid;
    internal static string Argument_MustBeBigInt;
    internal static string Format_InvalidFormatSpecifier;
    internal static string Format_TooLarge;
    internal static string ArgumentOutOfRange_MustBeLessThanUInt32MaxValue;
    internal static string ArgumentOutOfRange_MustBeNonNeg;
    internal static string NotSupported_NumberStyle;
    internal static string Overflow_BigIntInfinity;
    internal static string Overflow_NotANumber;
    internal static string Overflow_ParseBigInteger;
    internal static string Overflow_Int32;
    internal static string Overflow_Int64;
    internal static string Overflow_UInt32;
    internal static string Overflow_UInt64;
    internal static string Overflow_Decimal;
    internal static string Argument_FrameworkNameTooShort;
    internal static string Argument_FrameworkNameInvalid;
    internal static string Argument_FrameworkNameInvalidVersion;
    internal static string Argument_FrameworkNameMissingVersion;
    internal static string ArgumentNull_Key;
    internal static string Argument_AddingDuplicate;
    internal static string Argument_InvalidValue;
    internal static string ArgumentOutOfRange_NeedNonNegNum;
    internal static string ArgumentOutOfRange_InvalidThreshold;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string Arg_MultiRank;
    internal static string Arg_NonZeroLowerBound;
    internal static string Arg_InsufficientSpace;
    internal static string NotSupported_EnumeratorReset;
    internal static string Invalid_Array_Type;
    internal static string Serialization_InvalidOnDeser;
    internal static string Serialization_MissingValues;
    internal static string Serialization_MismatchedCount;
    internal static string ExternalLinkedListNode;
    internal static string LinkedListNodeIsAttached;
    internal static string LinkedListEmpty;
    internal static string Arg_WrongType;
    internal static string Argument_ItemNotExist;
    internal static string Argument_ImplementIComparable;
    internal static string InvalidOperation_EmptyCollection;
    internal static string InvalidOperation_EmptyQueue;
    internal static string InvalidOperation_EmptyStack;
    internal static string InvalidOperation_CannotRemoveFromStackOrQueue;
    internal static string ArgumentOutOfRange_Index;
    internal static string ArgumentOutOfRange_SmallCapacity;
    internal static string Arg_ArrayPlusOffTooSmall;
    internal static string NotSupported_KeyCollectionSet;
    internal static string NotSupported_ValueCollectionSet;
    internal static string NotSupported_ReadOnlyCollection;
    internal static string NotSupported_SortedListNestedWrite;
    internal static string BlockingCollection_ctor_BoundedCapacityRange;
    internal static string BlockingCollection_ctor_CountMoreThanCapacity;
    internal static string BlockingCollection_Add_ConcurrentCompleteAdd;
    internal static string BlockingCollection_Add_Failed;
    internal static string BlockingCollection_Take_CollectionModified;
    internal static string BlockingCollection_Completed;
    internal static string BlockingCollection_Disposed;
    internal static string BlockingCollection_TimeoutInvalid;
    internal static string BlockingCollection_CantTakeWhenDone;
    internal static string BlockingCollection_CantAddAnyWhenCompleted;
    internal static string BlockingCollection_CantTakeAnyWhenAllDone;
    internal static string BlockingCollection_ValidateCollectionsArray_ZeroSize;
    internal static string BlockingCollection_ValidateCollectionsArray_LargeSize;
    internal static string BlockingCollection_ValidateCollectionsArray_NullElems;
    internal static string BlockingCollection_ValidateCollectionsArray_DispElems;
    internal static string BlockingCollection_CompleteAdding_AlreadyDone;
    internal static string BlockingCollection_CopyTo_NonNegative;
    internal static string BlockingCollection_CopyTo_TooManyElems;
    internal static string BlockingCollection_CopyTo_MultiDim;
    internal static string BlockingCollection_CopyTo_IncorrectType;
    internal static string ConcurrentBag_Ctor_ArgumentNullException;
    internal static string ConcurrentBag_CopyTo_ArgumentNullException;
    internal static string ConcurrentBag_CopyTo_ArgumentOutOfRangeException;
    internal static string ConcurrentBag_CopyTo_ArgumentException_IndexGreaterThanLength;
    internal static string ConcurrentBag_CopyTo_ArgumentException_NoEnoughSpace;
    internal static string ConcurrentBag_CopyTo_ArgumentException_InvalidArrayType;
    internal static string ConcurrentCollection_SyncRoot_NotSupported;
    internal static string Common_OperationCanceled;
    internal static string Barrier_ctor_ArgumentOutOfRange;
    internal static string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange;
    internal static string Barrier_AddParticipants_Overflow_ArgumentOutOfRange;
    internal static string Barrier_InvalidOperation_CalledFromPHA;
    internal static string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange;
    internal static string Barrier_RemoveParticipants_ArgumentOutOfRange;
    internal static string Barrier_RemoveParticipants_InvalidOperation;
    internal static string Barrier_SignalAndWait_ArgumentOutOfRange;
    internal static string Barrier_SignalAndWait_InvalidOperation_ZeroTotal;
    internal static string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded;
    internal static string Barrier_Dispose;
    internal static string BarrierPostPhaseException;
    internal static string UriTypeConverter_ConvertFrom_CannotConvert;
    internal static string UriTypeConverter_ConvertTo_CannotConvert;
    internal static string ISupportInitializeDescr;
    internal static string CantModifyListSortDescriptionCollection;
    internal static string Argument_NullComment;
    internal static string InvalidPrimitiveType;
    internal static string Cannot_Specify_Both_Compiler_Path_And_Version;
    internal static string CodeGenOutputWriter;
    internal static string CodeGenReentrance;
    internal static string InvalidLanguageIdentifier;
    internal static string InvalidTypeName;
    internal static string Empty_attribute;
    internal static string Invalid_nonnegative_integer_attribute;
    internal static string CodeDomProvider_NotDefined;
    internal static string Language_Names_Cannot_Be_Empty;
    internal static string Extension_Names_Cannot_Be_Empty_Or_Non_Period_Based;
    internal static string Unable_To_Locate_Type;
    internal static string NotSupported_CodeDomAPI;
    internal static string ArityDoesntMatch;
    internal static string PartialTrustErrorTextReplacement;
    internal static string PartialTrustIllegalProvider;
    internal static string IllegalAssemblyReference;
    internal static string NullOrEmpty_Value_in_Property;
    internal static string AutoGen_Comment_Line1;
    internal static string AutoGen_Comment_Line2;
    internal static string AutoGen_Comment_Line3;
    internal static string AutoGen_Comment_Line4;
    internal static string AutoGen_Comment_Line5;
    internal static string CantContainNullEntries;
    internal static string InvalidPathCharsInChecksum;
    internal static string InvalidRegion;
    internal static string Provider_does_not_support_options;
    internal static string FileIntegrityCheckFailed;
    internal static string MetaExtenderName;
    internal static string InvalidEnumArgument;
    internal static string InvalidArgument;
    internal static string InvalidNullArgument;
    internal static string InvalidNullEmptyArgument;
    internal static string LicExceptionTypeOnly;
    internal static string LicExceptionTypeAndInstance;
    internal static string LicMgrContextCannotBeChanged;
    internal static string LicMgrAlreadyLocked;
    internal static string LicMgrDifferentUser;
    internal static string InvalidElementType;
    internal static string InvalidIdentifier;
    internal static string ExecFailedToCreate;
    internal static string ExecTimeout;
    internal static string ExecBadreturn;
    internal static string ExecCantGetRetCode;
    internal static string ExecCantExec;
    internal static string ExecCantRevert;
    internal static string CompilerNotFound;
    internal static string DuplicateFileName;
    internal static string CollectionReadOnly;
    internal static string BitVectorFull;
    internal static string ArrayConverterText;
    internal static string CollectionConverterText;
    internal static string MultilineStringConverterText;
    internal static string CultureInfoConverterDefaultCultureString;
    internal static string CultureInfoConverterInvalidCulture;
    internal static string InvalidPrimitive;
    internal static string TimerInvalidInterval;
    internal static string TraceSwitchLevelTooHigh;
    internal static string TraceSwitchLevelTooLow;
    internal static string TraceSwitchInvalidLevel;
    internal static string TraceListenerIndentSize;
    internal static string TraceListenerFail;
    internal static string TraceAsTraceSource;
    internal static string InvalidLowBoundArgument;
    internal static string DuplicateComponentName;
    internal static string NotImplemented;
    internal static string OutOfMemory;
    internal static string EOF;
    internal static string IOError;
    internal static string BadChar;
    internal static string toStringNone;
    internal static string toStringUnknown;
    internal static string InvalidEnum;
    internal static string IndexOutOfRange;
    internal static string ErrorPropertyAccessorException;
    internal static string InvalidOperation;
    internal static string EmptyStack;
    internal static string PerformanceCounterDesc;
    internal static string PCCategoryName;
    internal static string PCCounterName;
    internal static string PCInstanceName;
    internal static string PCMachineName;
    internal static string PCInstanceLifetime;
    internal static string PropertyCategoryAction;
    internal static string PropertyCategoryAppearance;
    internal static string PropertyCategoryAsynchronous;
    internal static string PropertyCategoryBehavior;
    internal static string PropertyCategoryData;
    internal static string PropertyCategoryDDE;
    internal static string PropertyCategoryDesign;
    internal static string PropertyCategoryDragDrop;
    internal static string PropertyCategoryFocus;
    internal static string PropertyCategoryFont;
    internal static string PropertyCategoryFormat;
    internal static string PropertyCategoryKey;
    internal static string PropertyCategoryList;
    internal static string PropertyCategoryLayout;
    internal static string PropertyCategoryDefault;
    internal static string PropertyCategoryMouse;
    internal static string PropertyCategoryPosition;
    internal static string PropertyCategoryText;
    internal static string PropertyCategoryScale;
    internal static string PropertyCategoryWindowStyle;
    internal static string PropertyCategoryConfig;
    internal static string ArgumentNull_ArrayWithNullElements;
    internal static string OnlyAllowedOnce;
    internal static string BeginIndexNotNegative;
    internal static string LengthNotNegative;
    internal static string UnimplementedState;
    internal static string UnexpectedOpcode;
    internal static string NoResultOnFailed;
    internal static string UnterminatedBracket;
    internal static string TooManyParens;
    internal static string NestedQuantify;
    internal static string QuantifyAfterNothing;
    internal static string InternalError;
    internal static string IllegalRange;
    internal static string NotEnoughParens;
    internal static string BadClassInCharRange;
    internal static string ReversedCharRange;
    internal static string UndefinedReference;
    internal static string MalformedReference;
    internal static string UnrecognizedGrouping;
    internal static string UnterminatedComment;
    internal static string IllegalEndEscape;
    internal static string MalformedNameRef;
    internal static string UndefinedBackref;
    internal static string UndefinedNameRef;
    internal static string TooFewHex;
    internal static string MissingControl;
    internal static string UnrecognizedControl;
    internal static string UnrecognizedEscape;
    internal static string IllegalCondition;
    internal static string TooManyAlternates;
    internal static string MakeException;
    internal static string IncompleteSlashP;
    internal static string MalformedSlashP;
    internal static string InvalidGroupName;
    internal static string CapnumNotZero;
    internal static string AlternationCantCapture;
    internal static string AlternationCantHaveComment;
    internal static string CaptureGroupOutOfRange;
    internal static string SubtractionMustBeLast;
    internal static string UnknownProperty;
    internal static string ReplacementError;
    internal static string CountTooSmall;
    internal static string EnumNotStarted;
    internal static string Arg_InvalidArrayType;
    internal static string Arg_RankMultiDimNotSupported;
    internal static string RegexMatchTimeoutException_Occurred;
    internal static string IllegalDefaultRegexMatchTimeoutInAppDomain;
    internal static string FileObject_AlreadyOpen;
    internal static string FileObject_Closed;
    internal static string FileObject_NotWhileWriting;
    internal static string FileObject_FileDoesNotExist;
    internal static string FileObject_MustBeClosed;
    internal static string FileObject_MustBeFileName;
    internal static string FileObject_InvalidInternalState;
    internal static string FileObject_PathNotSet;
    internal static string FileObject_Reading;
    internal static string FileObject_Writing;
    internal static string FileObject_InvalidEnumeration;
    internal static string FileObject_NoReset;
    internal static string DirectoryObject_MustBeDirName;
    internal static string DirectoryObjectPathDescr;
    internal static string FileObjectDetectEncodingDescr;
    internal static string FileObjectEncodingDescr;
    internal static string FileObjectPathDescr;
    internal static string Arg_EnumIllegalVal;
    internal static string Arg_OutOfRange_NeedNonNegNum;
    internal static string Argument_InvalidPermissionState;
    internal static string Argument_InvalidOidValue;
    internal static string Argument_WrongType;
    internal static string Arg_EmptyOrNullString;
    internal static string Arg_EmptyOrNullArray;
    internal static string Argument_InvalidClassAttribute;
    internal static string Argument_InvalidNameType;
    internal static string InvalidOperation_EnumNotStarted;
    internal static string InvalidOperation_DuplicateItemNotAllowed;
    internal static string Cryptography_Asn_MismatchedOidInCollection;
    internal static string Cryptography_Cms_Envelope_Empty_Content;
    internal static string Cryptography_Cms_Invalid_Recipient_Info_Type;
    internal static string Cryptography_Cms_Invalid_Subject_Identifier_Type;
    internal static string Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch;
    internal static string Cryptography_Cms_Key_Agree_Date_Not_Available;
    internal static string Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available;
    internal static string Cryptography_Cms_MessageNotSigned;
    internal static string Cryptography_Cms_MessageNotSignedByNoSignature;
    internal static string Cryptography_Cms_MessageNotEncrypted;
    internal static string Cryptography_Cms_Not_Supported;
    internal static string Cryptography_Cms_RecipientCertificateNotFound;
    internal static string Cryptography_Cms_Sign_Empty_Content;
    internal static string Cryptography_Cms_Sign_No_Signature_First_Signer;
    internal static string Cryptography_DpApi_InvalidMemoryLength;
    internal static string Cryptography_InvalidHandle;
    internal static string Cryptography_InvalidContextHandle;
    internal static string Cryptography_InvalidStoreHandle;
    internal static string Cryptography_Oid_InvalidValue;
    internal static string Cryptography_Pkcs9_ExplicitAddNotAllowed;
    internal static string Cryptography_Pkcs9_InvalidOid;
    internal static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed;
    internal static string Cryptography_Pkcs9_AttributeMismatch;
    internal static string Cryptography_X509_AddFailed;
    internal static string Cryptography_X509_BadEncoding;
    internal static string Cryptography_X509_ExportFailed;
    internal static string Cryptography_X509_ExtensionMismatch;
    internal static string Cryptography_X509_InvalidFindType;
    internal static string Cryptography_X509_InvalidFindValue;
    internal static string Cryptography_X509_InvalidEncodingFormat;
    internal static string Cryptography_X509_InvalidContentType;
    internal static string Cryptography_X509_KeyMismatch;
    internal static string Cryptography_X509_RemoveFailed;
    internal static string Cryptography_X509_StoreNotOpen;
    internal static string Environment_NotInteractive;
    internal static string NotSupported_InvalidKeyImpl;
    internal static string NotSupported_KeyAlgorithm;
    internal static string NotSupported_PlatformRequiresNT;
    internal static string NotSupported_UnreadableStream;
    internal static string Security_InvalidValue;
    internal static string Unknown_Error;
    internal static string security_ServiceNameCollection_EmptyServiceName;
    internal static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever;
    internal static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection;
    internal static string security_ExtendedProtection_NoOSSupport;
    internal static string net_nonClsCompliantException;
    internal static string net_illegalConfigWith;
    internal static string net_illegalConfigWithout;
    internal static string net_baddate;
    internal static string net_writestarted;
    internal static string net_clsmall;
    internal static string net_reqsubmitted;
    internal static string net_rspsubmitted;
    internal static string net_ftp_no_http_cmd;
    internal static string net_ftp_invalid_method_name;
    internal static string net_ftp_invalid_renameto;
    internal static string net_ftp_no_defaultcreds;
    internal static string net_ftpnoresponse;
    internal static string net_ftp_response_invalid_format;
    internal static string net_ftp_no_offsetforhttp;
    internal static string net_ftp_invalid_uri;
    internal static string net_ftp_invalid_status_response;
    internal static string net_ftp_server_failed_passive;
    internal static string net_ftp_active_address_different;
    internal static string net_ftp_proxy_does_not_support_ssl;
    internal static string net_ftp_invalid_response_filename;
    internal static string net_ftp_unsupported_method;
    internal static string net_resubmitcanceled;
    internal static string net_redirect_perm;
    internal static string net_resubmitprotofailed;
    internal static string net_needchunked;
    internal static string net_nochunked;
    internal static string net_nochunkuploadonhttp10;
    internal static string net_connarg;
    internal static string net_no100;
    internal static string net_fromto;
    internal static string net_rangetoosmall;
    internal static string net_entitytoobig;
    internal static string net_invalidversion;
    internal static string net_invalidstatus;
    internal static string net_toosmall;
    internal static string net_toolong;
    internal static string net_connclosed;
    internal static string net_noseek;
    internal static string net_servererror;
    internal static string net_nouploadonget;
    internal static string net_mutualauthfailed;
    internal static string net_invasync;
    internal static string net_inasync;
    internal static string net_mustbeuri;
    internal static string net_format_shexp;
    internal static string net_cannot_load_proxy_helper;
    internal static string net_invalid_host;
    internal static string net_repcall;
    internal static string net_wrongversion;
    internal static string net_badmethod;
    internal static string net_io_notenoughbyteswritten;
    internal static string net_io_timeout_use_ge_zero;
    internal static string net_io_timeout_use_gt_zero;
    internal static string net_io_no_0timeouts;
    internal static string net_requestaborted;
    internal static string net_tooManyRedirections;
    internal static string net_authmodulenotregistered;
    internal static string net_authschemenotregistered;
    internal static string net_proxyschemenotsupported;
    internal static string net_maxsrvpoints;
    internal static string net_unknown_prefix;
    internal static string net_notconnected;
    internal static string net_notstream;
    internal static string net_timeout;
    internal static string net_nocontentlengthonget;
    internal static string net_contentlengthmissing;
    internal static string net_nonhttpproxynotallowed;
    internal static string net_nottoken;
    internal static string net_rangetype;
    internal static string net_need_writebuffering;
    internal static string net_securitypackagesupport;
    internal static string net_securityprotocolnotsupported;
    internal static string net_nodefaultcreds;
    internal static string net_stopped;
    internal static string net_udpconnected;
    internal static string net_readonlystream;
    internal static string net_writeonlystream;
    internal static string net_no_concurrent_io_allowed;
    internal static string net_needmorethreads;
    internal static string net_MethodNotImplementedException;
    internal static string net_PropertyNotImplementedException;
    internal static string net_MethodNotSupportedException;
    internal static string net_PropertyNotSupportedException;
    internal static string net_ProtocolNotSupportedException;
    internal static string net_SelectModeNotSupportedException;
    internal static string net_InvalidSocketHandle;
    internal static string net_InvalidAddressFamily;
    internal static string net_InvalidEndPointAddressFamily;
    internal static string net_InvalidSocketAddressSize;
    internal static string net_invalidAddressList;
    internal static string net_invalidPingBufferSize;
    internal static string net_cant_perform_during_shutdown;
    internal static string net_cant_create_environment;
    internal static string net_completed_result;
    internal static string net_protocol_invalid_family;
    internal static string net_protocol_invalid_multicast_family;
    internal static string net_empty_osinstalltype;
    internal static string net_unknown_osinstalltype;
    internal static string net_cant_determine_osinstalltype;
    internal static string net_osinstalltype;
    internal static string net_entire_body_not_written;
    internal static string net_must_provide_request_body;
    internal static string net_ssp_dont_support_cbt;
    internal static string net_sockets_zerolist;
    internal static string net_sockets_blocking;
    internal static string net_sockets_useblocking;
    internal static string net_sockets_select;
    internal static string net_sockets_toolarge_select;
    internal static string net_sockets_empty_select;
    internal static string net_sockets_mustbind;
    internal static string net_sockets_mustlisten;
    internal static string net_sockets_mustnotlisten;
    internal static string net_sockets_mustnotbebound;
    internal static string net_sockets_namedmustnotbebound;
    internal static string net_sockets_invalid_socketinformation;
    internal static string net_sockets_invalid_ipaddress_length;
    internal static string net_sockets_invalid_optionValue;
    internal static string net_sockets_invalid_optionValue_all;
    internal static string net_sockets_invalid_dnsendpoint;
    internal static string net_sockets_disconnectedConnect;
    internal static string net_sockets_disconnectedAccept;
    internal static string net_tcplistener_mustbestopped;
    internal static string net_sockets_no_duplicate_async;
    internal static string net_socketopinprogress;
    internal static string net_buffercounttoosmall;
    internal static string net_multibuffernotsupported;
    internal static string net_ambiguousbuffers;
    internal static string net_sockets_ipv6only;
    internal static string net_perfcounter_initialized_success;
    internal static string net_perfcounter_initialized_error;
    internal static string net_perfcounter_nocategory;
    internal static string net_perfcounter_initialization_started;
    internal static string net_perfcounter_cant_queue_workitem;
    internal static string net_config_proxy;
    internal static string net_config_proxy_module_not_public;
    internal static string net_config_authenticationmodules;
    internal static string net_config_webrequestmodules;
    internal static string net_config_requestcaching;
    internal static string net_config_section_permission;
    internal static string net_config_element_permission;
    internal static string net_config_property_permission;
    internal static string net_WebResponseParseError_InvalidHeaderName;
    internal static string net_WebResponseParseError_InvalidContentLength;
    internal static string net_WebResponseParseError_IncompleteHeaderLine;
    internal static string net_WebResponseParseError_CrLfError;
    internal static string net_WebResponseParseError_InvalidChunkFormat;
    internal static string net_WebResponseParseError_UnexpectedServerResponse;
    internal static string net_webstatus_Success;
    internal static string net_webstatus_NameResolutionFailure;
    internal static string net_webstatus_ConnectFailure;
    internal static string net_webstatus_ReceiveFailure;
    internal static string net_webstatus_SendFailure;
    internal static string net_webstatus_PipelineFailure;
    internal static string net_webstatus_RequestCanceled;
    internal static string net_webstatus_ConnectionClosed;
    internal static string net_webstatus_TrustFailure;
    internal static string net_webstatus_SecureChannelFailure;
    internal static string net_webstatus_ServerProtocolViolation;
    internal static string net_webstatus_KeepAliveFailure;
    internal static string net_webstatus_ProxyNameResolutionFailure;
    internal static string net_webstatus_MessageLengthLimitExceeded;
    internal static string net_webstatus_CacheEntryNotFound;
    internal static string net_webstatus_RequestProhibitedByCachePolicy;
    internal static string net_webstatus_Timeout;
    internal static string net_webstatus_RequestProhibitedByProxy;
    internal static string net_InvalidStatusCode;
    internal static string net_ftpstatuscode_ServiceNotAvailable;
    internal static string net_ftpstatuscode_CantOpenData;
    internal static string net_ftpstatuscode_ConnectionClosed;
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy;
    internal static string net_ftpstatuscode_ActionAbortedLocalProcessingError;
    internal static string net_ftpstatuscode_ActionNotTakenInsufficentSpace;
    internal static string net_ftpstatuscode_CommandSyntaxError;
    internal static string net_ftpstatuscode_ArgumentSyntaxError;
    internal static string net_ftpstatuscode_CommandNotImplemented;
    internal static string net_ftpstatuscode_BadCommandSequence;
    internal static string net_ftpstatuscode_NotLoggedIn;
    internal static string net_ftpstatuscode_AccountNeeded;
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailable;
    internal static string net_ftpstatuscode_ActionAbortedUnknownPageType;
    internal static string net_ftpstatuscode_FileActionAborted;
    internal static string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed;
    internal static string net_httpstatuscode_NoContent;
    internal static string net_httpstatuscode_NonAuthoritativeInformation;
    internal static string net_httpstatuscode_ResetContent;
    internal static string net_httpstatuscode_PartialContent;
    internal static string net_httpstatuscode_MultipleChoices;
    internal static string net_httpstatuscode_Ambiguous;
    internal static string net_httpstatuscode_MovedPermanently;
    internal static string net_httpstatuscode_Moved;
    internal static string net_httpstatuscode_Found;
    internal static string net_httpstatuscode_Redirect;
    internal static string net_httpstatuscode_SeeOther;
    internal static string net_httpstatuscode_RedirectMethod;
    internal static string net_httpstatuscode_NotModified;
    internal static string net_httpstatuscode_UseProxy;
    internal static string net_httpstatuscode_TemporaryRedirect;
    internal static string net_httpstatuscode_RedirectKeepVerb;
    internal static string net_httpstatuscode_BadRequest;
    internal static string net_httpstatuscode_Unauthorized;
    internal static string net_httpstatuscode_PaymentRequired;
    internal static string net_httpstatuscode_Forbidden;
    internal static string net_httpstatuscode_NotFound;
    internal static string net_httpstatuscode_MethodNotAllowed;
    internal static string net_httpstatuscode_NotAcceptable;
    internal static string net_httpstatuscode_ProxyAuthenticationRequired;
    internal static string net_httpstatuscode_RequestTimeout;
    internal static string net_httpstatuscode_Conflict;
    internal static string net_httpstatuscode_Gone;
    internal static string net_httpstatuscode_LengthRequired;
    internal static string net_httpstatuscode_InternalServerError;
    internal static string net_httpstatuscode_NotImplemented;
    internal static string net_httpstatuscode_BadGateway;
    internal static string net_httpstatuscode_ServiceUnavailable;
    internal static string net_httpstatuscode_GatewayTimeout;
    internal static string net_httpstatuscode_HttpVersionNotSupported;
    internal static string net_uri_BadScheme;
    internal static string net_uri_BadFormat;
    internal static string net_uri_BadUserPassword;
    internal static string net_uri_BadHostName;
    internal static string net_uri_BadAuthority;
    internal static string net_uri_BadAuthorityTerminator;
    internal static string net_uri_EmptyUri;
    internal static string net_uri_BadString;
    internal static string net_uri_MustRootedPath;
    internal static string net_uri_BadPort;
    internal static string net_uri_SizeLimit;
    internal static string net_uri_SchemeLimit;
    internal static string net_uri_NotAbsolute;
    internal static string net_uri_PortOutOfRange;
    internal static string net_uri_UserDrivenParsing;
    internal static string net_uri_AlreadyRegistered;
    internal static string net_uri_NeedFreshParser;
    internal static string net_uri_CannotCreateRelative;
    internal static string net_uri_InvalidUriKind;
    internal static string net_uri_BadUnicodeHostForIdn;
    internal static string net_uri_GenericAuthorityNotDnsSafe;
    internal static string net_uri_NotJustSerialization;
    internal static string net_emptystringcall;
    internal static string net_emptystringset;
    internal static string net_headers_req;
    internal static string net_headers_rsp;
    internal static string net_headers_toolong;
    internal static string net_WebHeaderInvalidControlChars;
    internal static string net_WebHeaderInvalidCRLFChars;
    internal static string net_WebHeaderInvalidHeaderChars;
    internal static string net_WebHeaderInvalidNonAsciiChars;
    internal static string net_WebHeaderMissingColon;
    internal static string net_headerrestrict;
    internal static string net_io_completionportwasbound;
    internal static string net_io_writefailure;
    internal static string net_io_readfailure;
    internal static string net_io_connectionclosed;
    internal static string net_io_transportfailure;
    internal static string net_io_internal_bind;
    internal static string net_io_invalidasyncresult;
    internal static string net_io_invalidnestedcall;
    internal static string net_io_invalidendcall;
    internal static string net_io_must_be_rw_stream;
    internal static string net_io_header_id;
    internal static string net_io_out_range;
    internal static string net_io_encrypt;
    internal static string net_io_decrypt;
    internal static string net_io_read;
    internal static string net_io_write;
    internal static string net_io_eof;
    internal static string net_io_async_result;
    internal static string net_listener_mustcall;
    internal static string net_listener_mustcompletecall;
    internal static string net_listener_callinprogress;
    internal static string net_listener_scheme;
    internal static string net_listener_host;
    internal static string net_listener_slash;
    internal static string net_listener_repcall;
    internal static string net_listener_invalid_cbt_type;
    internal static string net_listener_no_spns;
    internal static string net_listener_cannot_set_custom_cbt;
    internal static string net_listener_cbt_not_supported;
    internal static string net_listener_detach_error;
    internal static string net_listener_close_urlgroup_error;
    internal static string net_tls_version;
    internal static string net_perm_target;
    internal static string net_perm_both_regex;
    internal static string net_perm_none;
    internal static string net_perm_attrib_count;
    internal static string net_perm_invalid_val;
    internal static string net_perm_attrib_multi;
    internal static string net_perm_epname;
    internal static string net_perm_invalid_val_in_element;
    internal static string net_invalid_ip_addr;
    internal static string dns_bad_ip_address;
    internal static string net_bad_mac_address;
    internal static string net_ping;
    internal static string net_bad_ip_address_prefix;
    internal static string net_max_ip_address_list_length_exceeded;
    internal static string net_ipv4_not_installed;
    internal static string net_ipv6_not_installed;
    internal static string net_webclient;
    internal static string net_webclient_ContentType;
    internal static string net_webclient_Multipart;
    internal static string net_webclient_no_concurrent_io_allowed;
    internal static string net_webclient_invalid_baseaddress;
    internal static string net_container_add_cookie;
    internal static string net_cookie_invalid;
    internal static string net_cookie_size;
    internal static string net_cookie_parse_header;
    internal static string net_cookie_attribute;
    internal static string net_cookie_format;
    internal static string net_cookie_exists;
    internal static string net_cookie_capacity_range;
    internal static string net_set_token;
    internal static string net_revert_token;
    internal static string net_ssl_io_async_context;
    internal static string net_ssl_io_encrypt;
    internal static string net_ssl_io_decrypt;
    internal static string net_ssl_io_context_expired;
    internal static string net_ssl_io_handshake_start;
    internal static string net_ssl_io_handshake;
    internal static string net_ssl_io_frame;
    internal static string net_ssl_io_corrupted;
    internal static string net_ssl_io_cert_validation;
    internal static string net_ssl_io_invalid_end_call;
    internal static string net_ssl_io_invalid_begin_call;
    internal static string net_ssl_io_no_server_cert;
    internal static string net_auth_bad_client_creds;
    internal static string net_auth_bad_client_creds_or_target_mismatch;
    internal static string net_auth_context_expectation;
    internal static string net_auth_context_expectation_remote;
    internal static string net_auth_supported_impl_levels;
    internal static string net_auth_no_anonymous_support;
    internal static string net_auth_reauth;
    internal static string net_auth_noauth;
    internal static string net_auth_client_server;
    internal static string net_auth_noencryption;
    internal static string net_auth_SSPI;
    internal static string net_auth_failure;
    internal static string net_auth_eof;
    internal static string net_auth_alert;
    internal static string net_auth_ignored_reauth;
    internal static string net_auth_empty_read;
    internal static string net_auth_message_not_encrypted;
    internal static string net_auth_must_specify_extended_protection_scheme;
    internal static string net_frame_size;
    internal static string net_frame_read_io;
    internal static string net_frame_read_size;
    internal static string net_frame_max_size;
    internal static string net_jscript_load;
    internal static string net_proxy_not_gmt;
    internal static string net_proxy_invalid_dayofweek;
    internal static string net_proxy_invalid_url_format;
    internal static string net_param_not_string;
    internal static string net_value_cannot_be_negative;
    internal static string net_invalid_offset;
    internal static string net_offset_plus_count;
    internal static string net_cannot_be_false;
    internal static string net_invalid_enum;
    internal static string net_listener_already;
    internal static string net_cache_shadowstream_not_writable;
    internal static string net_cache_validator_fail;
    internal static string net_cache_access_denied;
    internal static string net_cache_validator_result;
    internal static string net_cache_retrieve_failure;
    internal static string net_cache_not_supported_body;
    internal static string net_cache_not_supported_command;
    internal static string net_cache_not_accept_response;
    internal static string net_cache_method_failed;
    internal static string net_cache_key_failed;
    internal static string net_cache_no_stream;
    internal static string net_cache_unsupported_partial_stream;
    internal static string net_cache_not_configured;
    internal static string net_cache_non_seekable_stream_not_supported;
    internal static string net_invalid_cast;
    internal static string net_collection_readonly;
    internal static string net_not_ipermission;
    internal static string net_no_classname;
    internal static string net_no_typename;
    internal static string net_array_too_small;
    internal static string net_servicePointAddressNotSupportedInHostMode;
    internal static string net_Websockets_AlreadyOneOutstandingOperation;
    internal static string net_Websockets_WebSocketBaseFaulted;
    internal static string net_WebSockets_NativeSendResponseHeaders;
    internal static string net_WebSockets_Generic;
    internal static string net_WebSockets_NotAWebSocket_Generic;
    internal static string net_WebSockets_UnsupportedWebSocketVersion_Generic;
    internal static string net_WebSockets_HeaderError_Generic;
    internal static string net_WebSockets_UnsupportedProtocol_Generic;
    internal static string net_WebSockets_UnsupportedPlatform;
    internal static string net_WebSockets_AcceptNotAWebSocket;
    internal static string net_WebSockets_AcceptUnsupportedWebSocketVersion;
    internal static string net_WebSockets_AcceptHeaderNotFound;
    internal static string net_WebSockets_AcceptUnsupportedProtocol;
    internal static string net_WebSockets_ClientAcceptingNoProtocols;
    internal static string net_WebSockets_ClientSecWebSocketProtocolsBlank;
    internal static string net_WebSockets_ArgumentOutOfRange_TooSmall;
    internal static string net_WebSockets_ArgumentOutOfRange_InternalBuffer;
    internal static string net_WebSockets_ArgumentOutOfRange_TooBig;
    internal static string net_WebSockets_InvalidState_Generic;
    internal static string net_WebSockets_InvalidState_ClosedOrAborted;
    internal static string net_WebSockets_InvalidState;
    internal static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync;
    internal static string net_WebSockets_InvalidMessageType;
    internal static string net_WebSockets_InvalidBufferType;
    internal static string net_WebSockets_InvalidMessageType_Generic;
    internal static string net_WebSockets_Argument_InvalidMessageType;
    internal static string net_WebSockets_ConnectionClosedPrematurely_Generic;
    internal static string net_WebSockets_InvalidCharInProtocolString;
    internal static string net_WebSockets_InvalidEmptySubProtocol;
    internal static string net_WebSockets_ReasonNotNull;
    internal static string net_WebSockets_InvalidCloseStatusCode;
    internal static string net_WebSockets_InvalidCloseStatusDescription;
    internal static string net_WebSockets_Scheme;
    internal static string net_WebSockets_AlreadyStarted;
    internal static string net_WebSockets_Connect101Expected;
    internal static string net_WebSockets_InvalidResponseHeader;
    internal static string net_WebSockets_NotConnected;
    internal static string net_WebSockets_InvalidRegistration;
    internal static string net_WebSockets_NoDuplicateProtocol;
    internal static string net_log_exception;
    internal static string net_log_listener_delegate_exception;
    internal static string net_log_listener_unsupported_authentication_scheme;
    internal static string net_log_listener_unmatched_authentication_scheme;
    internal static string net_log_listener_create_valid_identity_failed;
    internal static string net_log_listener_httpsys_registry_null;
    internal static string net_log_listener_httpsys_registry_error;
    internal static string net_log_listener_cant_convert_raw_path;
    internal static string net_log_listener_cant_convert_percent_value;
    internal static string net_log_listener_cant_convert_bytes;
    internal static string net_log_listener_cant_convert_to_utf8;
    internal static string net_log_listener_cant_create_uri;
    internal static string net_log_listener_no_cbt_disabled;
    internal static string net_log_listener_no_cbt_http;
    internal static string net_log_listener_no_cbt_platform;
    internal static string net_log_listener_no_cbt_trustedproxy;
    internal static string net_log_listener_cbt;
    internal static string net_log_listener_no_spn_kerberos;
    internal static string net_log_listener_no_spn_disabled;
    internal static string net_log_listener_no_spn_cbt;
    internal static string net_log_listener_no_spn_platform;
    internal static string net_log_listener_no_spn_whensupported;
    internal static string net_log_listener_no_spn_loopback;
    internal static string net_log_listener_spn;
    internal static string net_log_listener_spn_passed;
    internal static string net_log_listener_spn_failed;
    internal static string net_log_listener_spn_failed_always;
    internal static string net_log_listener_spn_failed_empty;
    internal static string net_log_listener_spn_failed_dump;
    internal static string net_log_listener_spn_add;
    internal static string net_log_listener_spn_not_add;
    internal static string net_log_listener_spn_remove;
    internal static string net_log_listener_spn_not_remove;
    internal static string net_log_sspi_enumerating_security_packages;
    internal static string net_log_sspi_security_package_not_found;
    internal static string net_log_sspi_security_context_input_buffer;
    internal static string net_log_sspi_security_context_input_buffers;
    internal static string net_log_sspi_selected_cipher_suite;
    internal static string net_log_remote_certificate;
    internal static string net_log_locating_private_key_for_certificate;
    internal static string net_log_cert_is_of_type_2;
    internal static string net_log_found_cert_in_store;
    internal static string net_log_did_not_find_cert_in_store;
    internal static string net_log_open_store_failed;
    internal static string net_log_got_certificate_from_delegate;
    internal static string net_log_no_delegate_and_have_no_client_cert;
    internal static string net_log_no_delegate_but_have_client_cert;
    internal static string net_log_attempting_restart_using_cert;
    internal static string net_log_no_issuers_try_all_certs;
    internal static string net_log_server_issuers_look_for_matching_certs;
    internal static string net_log_selected_cert;
    internal static string net_log_n_certs_after_filtering;
    internal static string net_log_finding_matching_certs;
    internal static string net_log_using_cached_credential;
    internal static string net_log_remote_cert_user_declared_valid;
    internal static string net_log_remote_cert_user_declared_invalid;
    internal static string net_log_remote_cert_has_no_errors;
    internal static string net_log_remote_cert_has_errors;
    internal static string net_log_remote_cert_not_available;
    internal static string net_log_remote_cert_name_mismatch;
    internal static string net_log_proxy_autodetect_script_location_parse_error;
    internal static string net_log_proxy_autodetect_failed;
    internal static string net_log_proxy_script_execution_error;
    internal static string net_log_proxy_script_download_compile_error;
    internal static string net_log_proxy_system_setting_update;
    internal static string net_log_proxy_update_due_to_ip_config_change;
    internal static string net_log_proxy_called_with_null_parameter;
    internal static string net_log_proxy_called_with_invalid_parameter;
    internal static string net_log_proxy_ras_supported;
    internal static string net_log_proxy_ras_notsupported_exception;
    internal static string net_log_proxy_winhttp_cant_open_session;
    internal static string net_log_proxy_winhttp_getproxy_failed;
    internal static string net_log_proxy_winhttp_timeout_error;
    internal static string net_log_cache_validation_failed_resubmit;
    internal static string net_log_cache_refused_server_response;
    internal static string net_log_cache_ftp_proxy_doesnt_support_partial;
    internal static string net_log_cache_ftp_method;
    internal static string net_log_cache_ftp_supports_bin_only;
    internal static string net_log_cache_replacing_entry_with_HTTP_200;
    internal static string net_log_cache_now_time;
    internal static string net_log_cache_max_age_absolute;
    internal static string net_log_cache_age1;
    internal static string net_log_cache_age1_date_header;
    internal static string net_log_cache_age1_last_synchronized;
    internal static string net_log_cache_age1_last_synchronized_age_header;
    internal static string net_log_cache_age2;
    internal static string net_log_cache_max_age_cache_s_max_age;
    internal static string net_log_cache_max_age_expires_date;
    internal static string net_log_cache_max_age_cache_max_age;
    internal static string net_log_cache_no_max_age_use_10_percent;
    internal static string net_log_cache_no_max_age_use_default;
    internal static string net_log_cache_validator_invalid_for_policy;
    internal static string net_log_cache_response_last_modified;
    internal static string net_log_cache_cache_last_modified;
    internal static string net_log_cache_partial_and_non_zero_content_offset;
    internal static string net_log_cache_response_valid_based_on_policy;
    internal static string net_log_cache_null_response_failure;
    internal static string net_log_cache_ftp_response_status;
    internal static string net_log_cache_resp_valid_based_on_retry;
    internal static string net_log_cache_no_update_based_on_method;
    internal static string net_log_cache_removed_existing_invalid_entry;
    internal static string net_log_cache_not_updated_based_on_policy;
    internal static string net_log_cache_not_updated_because_no_response;
    internal static string net_log_cache_removed_existing_based_on_method;
    internal static string net_log_cache_existing_not_removed_because_unexpected_response_status;
    internal static string net_log_cache_removed_existing_based_on_policy;
    internal static string net_log_cache_not_updated_based_on_ftp_response_status;
    internal static string net_log_cache_update_not_supported_for_ftp_restart;
    internal static string net_log_cache_removed_entry_because_ftp_restart_response_changed;
    internal static string net_log_cache_last_synchronized;
    internal static string net_log_cache_suppress_update_because_synched_last_minute;
    internal static string net_log_cache_updating_last_synchronized;
    internal static string net_log_cache_cannot_remove;
    internal static string net_log_cache_key_status;
    internal static string net_log_cache_key_remove_failed_status;
    internal static string net_log_cache_usecount_file;
    internal static string net_log_cache_stream;
    internal static string net_log_cache_filename;
    internal static string net_log_cache_lookup_failed;
    internal static string net_log_cache_exception;
    internal static string net_log_cache_expected_length;
    internal static string net_log_cache_last_modified;
    internal static string net_log_cache_expires;
    internal static string net_log_cache_max_stale;
    internal static string net_log_cache_dumping_metadata;
    internal static string net_log_cache_create_failed;
    internal static string net_log_cache_set_expires;
    internal static string net_log_cache_set_last_modified;
    internal static string net_log_cache_set_last_synchronized;
    internal static string net_log_cache_enable_max_stale;
    internal static string net_log_cache_disable_max_stale;
    internal static string net_log_cache_set_new_metadata;
    internal static string net_log_cache_dumping;
    internal static string net_log_cache_key;
    internal static string net_log_cache_no_commit;
    internal static string net_log_cache_error_deleting_filename;
    internal static string net_log_cache_update_failed;
    internal static string net_log_cache_delete_failed;
    internal static string net_log_cache_commit_failed;
    internal static string net_log_cache_committed_as_partial;
    internal static string net_log_cache_max_stale_and_update_status;
    internal static string net_log_cache_failing_request_with_exception;
    internal static string net_log_cache_request_method;
    internal static string net_log_cache_http_status_parse_failure;
    internal static string net_log_cache_http_status_line;
    internal static string net_log_cache_cache_control;
    internal static string net_log_cache_invalid_http_version;
    internal static string net_log_cache_no_http_response_header;
    internal static string net_log_cache_http_header_parse_error;
    internal static string net_log_cache_metadata_name_value_parse_error;
    internal static string net_log_cache_content_range_error;
    internal static string net_log_cache_cache_control_error;
    internal static string net_log_cache_unexpected_status;
    internal static string net_log_cache_object_and_exception;
    internal static string net_log_cache_revalidation_not_needed;
    internal static string net_log_cache_not_updated_based_on_cache_protocol_status;
    internal static string net_log_cache_closing_cache_stream;
    internal static string net_log_cache_exception_ignored;
    internal static string net_log_cache_no_cache_entry;
    internal static string net_log_cache_null_cached_stream;
    internal static string net_log_cache_requested_combined_but_null_cached_stream;
    internal static string net_log_cache_returned_range_cache;
    internal static string net_log_cache_entry_not_found_freshness_undefined;
    internal static string net_log_cache_dumping_cache_context;
    internal static string net_log_cache_result;
    internal static string net_log_cache_uri_with_query_has_no_expiration;
    internal static string net_log_cache_uri_with_query_and_cached_resp_from_http_10;
    internal static string net_log_cache_valid_as_fresh_or_because_policy;
    internal static string net_log_cache_accept_based_on_retry_count;
    internal static string net_log_cache_date_header_older_than_cache_entry;
    internal static string net_log_cache_server_didnt_satisfy_range;
    internal static string net_log_cache_304_received_on_unconditional_request;
    internal static string net_log_cache_304_received_on_unconditional_request_expected_200_206;
    internal static string net_log_cache_last_modified_header_older_than_cache_entry;
    internal static string net_log_cache_freshness_outside_policy_limits;
    internal static string net_log_cache_need_to_remove_invalid_cache_entry_304;
    internal static string net_log_cache_resp_status;
    internal static string net_log_cache_resp_304_or_request_head;
    internal static string net_log_cache_dont_update_cached_headers;
    internal static string net_log_cache_update_cached_headers;
    internal static string net_log_cache_partial_resp_not_combined_with_existing_entry;
    internal static string net_log_cache_request_contains_conditional_header;
    internal static string net_log_cache_not_a_get_head_post;
    internal static string net_log_cache_cannot_update_cache_if_304;
    internal static string net_log_cache_cannot_update_cache_with_head_resp;
    internal static string net_log_cache_http_resp_is_null;
    internal static string net_log_cache_resp_cache_control_is_no_store;
    internal static string net_log_cache_resp_cache_control_is_public;
    internal static string net_log_cache_resp_cache_control_is_private;
    internal static string net_log_cache_resp_cache_control_is_private_plus_headers;
    internal static string net_log_cache_resp_older_than_cache;
    internal static string net_log_cache_revalidation_required;
    internal static string net_log_cache_needs_revalidation;
    internal static string net_log_cache_resp_allows_caching;
    internal static string net_log_cache_auth_header_and_no_s_max_age;
    internal static string net_log_cache_post_resp_without_cache_control_or_expires;
    internal static string net_log_cache_valid_based_on_status_code;
    internal static string net_log_cache_resp_no_cache_control;
    internal static string net_log_cache_age;
    internal static string net_log_cache_policy_min_fresh;
    internal static string net_log_cache_policy_max_age;
    internal static string net_log_cache_policy_cache_sync_date;
    internal static string net_log_cache_policy_max_stale;
    internal static string net_log_cache_control_no_cache;
    internal static string net_log_cache_control_no_cache_removing_some_headers;
    internal static string net_log_cache_control_must_revalidate;
    internal static string net_log_cache_cached_auth_header;
    internal static string net_log_cache_cached_auth_header_no_control_directive;
    internal static string net_log_cache_after_validation;
    internal static string net_log_cache_resp_status_304;
    internal static string net_log_cache_head_resp_has_different_content_length;
    internal static string net_log_cache_head_resp_has_different_content_md5;
    internal static string net_log_cache_head_resp_has_different_etag;
    internal static string net_log_cache_304_head_resp_has_different_last_modified;
    internal static string net_log_cache_existing_entry_has_to_be_discarded;
    internal static string net_log_cache_existing_entry_should_be_discarded;
    internal static string net_log_cache_206_resp_non_matching_entry;
    internal static string net_log_cache_206_resp_starting_position_not_adjusted;
    internal static string net_log_cache_combined_resp_requested;
    internal static string net_log_cache_updating_headers_on_304;
    internal static string net_log_cache_suppressing_headers_update_on_304;
    internal static string net_log_cache_status_code_not_304_206;
    internal static string net_log_cache_sxx_resp_cache_only;
    internal static string net_log_cache_sxx_resp_can_be_replaced;
    internal static string net_log_cache_vary_header_empty;
    internal static string net_log_cache_vary_header_contains_asterisks;
    internal static string net_log_cache_no_headers_in_metadata;
    internal static string net_log_cache_vary_header_mismatched_count;
    internal static string net_log_cache_vary_header_mismatched_field;
    internal static string net_log_cache_vary_header_match;
    internal static string net_log_cache_range;
    internal static string net_log_cache_range_invalid_format;
    internal static string net_log_cache_range_not_in_cache;
    internal static string net_log_cache_range_in_cache;
    internal static string net_log_cache_partial_resp;
    internal static string net_log_cache_range_request_range;
    internal static string net_log_cache_could_be_partial;
    internal static string net_log_cache_condition_if_none_match;
    internal static string net_log_cache_condition_if_modified_since;
    internal static string net_log_cache_cannot_construct_conditional_request;
    internal static string net_log_cache_cannot_construct_conditional_range_request;
    internal static string net_log_cache_entry_size_too_big;
    internal static string net_log_cache_condition_if_range;
    internal static string net_log_cache_conditional_range_not_implemented_on_http_10;
    internal static string net_log_cache_saving_request_headers;
    internal static string net_log_cache_only_byte_range_implemented;
    internal static string net_log_cache_multiple_complex_range_not_implemented;
    internal static string net_log_digest_hash_algorithm_not_supported;
    internal static string net_log_digest_qop_not_supported;
    internal static string net_log_digest_requires_nonce;
    internal static string net_log_auth_invalid_challenge;
    internal static string net_log_unknown;
    internal static string net_log_operation_returned_something;
    internal static string net_log_operation_failed_with_error;
    internal static string net_log_buffered_n_bytes;
    internal static string net_log_method_equal;
    internal static string net_log_releasing_connection;
    internal static string net_log_unexpected_exception;
    internal static string net_log_server_response_error_code;
    internal static string net_log_resubmitting_request;
    internal static string net_log_retrieving_localhost_exception;
    internal static string net_log_resolved_servicepoint_may_not_be_remote_server;
    internal static string net_log_closed_idle;
    internal static string net_log_received_status_line;
    internal static string net_log_sending_headers;
    internal static string net_log_received_headers;
    internal static string net_log_shell_expression_pattern_format_warning;
    internal static string net_log_exception_in_callback;
    internal static string net_log_sending_command;
    internal static string net_log_received_response;
    internal static string net_log_socket_connected;
    internal static string net_log_socket_accepted;
    internal static string net_log_socket_not_logged_file;
    internal static string net_log_socket_connect_dnsendpoint;
    internal static string net_log_set_socketoption_reuseport;
    internal static string net_log_set_socketoption_reuseport_not_supported;
    internal static string net_log_set_socketoption_reuseport_default_on;
    internal static string MailAddressInvalidFormat;
    internal static string MailSubjectInvalidFormat;
    internal static string MailBase64InvalidCharacter;
    internal static string MailCollectionIsReadOnly;
    internal static string MailDateInvalidFormat;
    internal static string MailHeaderFieldAlreadyExists;
    internal static string MailHeaderFieldInvalidCharacter;
    internal static string MailHeaderFieldMalformedHeader;
    internal static string MailHeaderFieldMismatchedName;
    internal static string MailHeaderIndexOutOfBounds;
    internal static string MailHeaderItemAccessorOnlySingleton;
    internal static string MailHeaderListHasChanged;
    internal static string MailHeaderResetCalledBeforeEOF;
    internal static string MailHeaderTargetArrayTooSmall;
    internal static string MailHeaderInvalidCID;
    internal static string MailHostNotFound;
    internal static string MailReaderGetContentStreamAlreadyCalled;
    internal static string MailReaderTruncated;
    internal static string MailWriterIsInContent;
    internal static string MailServerDoesNotSupportStartTls;
    internal static string MailServerResponse;
    internal static string SSPIAuthenticationOrSPNNull;
    internal static string SSPIPInvokeError;
    internal static string SSPIInvalidHandleType;
    internal static string SmtpAlreadyConnected;
    internal static string SmtpAuthenticationFailed;
    internal static string SmtpAuthenticationFailedNoCreds;
    internal static string SmtpDataStreamOpen;
    internal static string SmtpDefaultMimePreamble;
    internal static string SmtpDefaultSubject;
    internal static string SmtpInvalidResponse;
    internal static string SmtpNotConnected;
    internal static string SmtpSystemStatus;
    internal static string SmtpHelpMessage;
    internal static string SmtpServiceReady;
    internal static string SmtpServiceClosingTransmissionChannel;
    internal static string SmtpOK;
    internal static string SmtpUserNotLocalWillForward;
    internal static string SmtpStartMailInput;
    internal static string SmtpServiceNotAvailable;
    internal static string SmtpMailboxBusy;
    internal static string SmtpLocalErrorInProcessing;
    internal static string SmtpInsufficientStorage;
    internal static string SmtpPermissionDenied;
    internal static string SmtpCommandUnrecognized;
    internal static string SmtpSyntaxError;
    internal static string SmtpCommandNotImplemented;
    internal static string SmtpBadCommandSequence;
    internal static string SmtpCommandParameterNotImplemented;
    internal static string SmtpMailboxUnavailable;
    internal static string SmtpUserNotLocalTryAlternatePath;
    internal static string SmtpExceededStorageAllocation;
    internal static string SmtpMailboxNameNotAllowed;
    internal static string SmtpTransactionFailed;
    internal static string SmtpSendMailFailure;
    internal static string SmtpRecipientFailed;
    internal static string SmtpRecipientRequired;
    internal static string SmtpFromRequired;
    internal static string SmtpAllRecipientsFailed;
    internal static string SmtpClientNotPermitted;
    internal static string SmtpMustIssueStartTlsFirst;
    internal static string SmtpNeedAbsolutePickupDirectory;
    internal static string SmtpGetIisPickupDirectoryFailed;
    internal static string SmtpPickupDirectoryDoesnotSupportSsl;
    internal static string SmtpOperationInProgress;
    internal static string SmtpAuthResponseInvalid;
    internal static string SmtpEhloResponseInvalid;
    internal static string SmtpNonAsciiUserNotSupported;
    internal static string SmtpInvalidHostName;
    internal static string MimeTransferEncodingNotSupported;
    internal static string SeekNotSupported;
    internal static string WriteNotSupported;
    internal static string InvalidHexDigit;
    internal static string InvalidSSPIContext;
    internal static string InvalidSSPIContextKey;
    internal static string InvalidSSPINegotiationElement;
    internal static string InvalidHeaderName;
    internal static string InvalidHeaderValue;
    internal static string CannotGetEffectiveTimeOfSSPIContext;
    internal static string CannotGetExpiryTimeOfSSPIContext;
    internal static string ReadNotSupported;
    internal static string InvalidAsyncResult;
    internal static string UnspecifiedHost;
    internal static string InvalidPort;
    internal static string SmtpInvalidOperationDuringSend;
    internal static string MimePartCantResetStream;
    internal static string MediaTypeInvalid;
    internal static string ContentTypeInvalid;
    internal static string ContentDispositionInvalid;
    internal static string AttributeNotSupported;
    internal static string Cannot_remove_with_null;
    internal static string Config_base_elements_only;
    internal static string Config_base_no_child_nodes;
    internal static string Config_base_required_attribute_empty;
    internal static string Config_base_required_attribute_missing;
    internal static string Config_base_time_overflow;
    internal static string Config_base_type_must_be_configurationvalidation;
    internal static string Config_base_type_must_be_typeconverter;
    internal static string Config_base_unknown_format;
    internal static string Config_base_unrecognized_attribute;
    internal static string Config_base_unrecognized_element;
    internal static string Config_invalid_boolean_attribute;
    internal static string Config_invalid_integer_attribute;
    internal static string Config_invalid_positive_integer_attribute;
    internal static string Config_invalid_type_attribute;
    internal static string Config_missing_required_attribute;
    internal static string Config_name_value_file_section_file_invalid_root;
    internal static string Config_provider_must_implement_type;
    internal static string Config_provider_name_null_or_empty;
    internal static string Config_provider_not_found;
    internal static string Config_property_name_cannot_be_empty;
    internal static string Config_section_cannot_clear_locked_section;
    internal static string Config_section_record_not_found;
    internal static string Config_source_cannot_contain_file;
    internal static string Config_system_already_set;
    internal static string Config_unable_to_read_security_policy;
    internal static string Config_write_xml_returned_null;
    internal static string Cannot_clear_sections_within_group;
    internal static string Cannot_exit_up_top_directory;
    internal static string Could_not_create_listener;
    internal static string TL_InitializeData_NotSpecified;
    internal static string Could_not_create_type_instance;
    internal static string Could_not_find_type;
    internal static string Could_not_get_constructor;
    internal static string EmptyTypeName_NotAllowed;
    internal static string Incorrect_base_type;
    internal static string Only_specify_one;
    internal static string Provider_Already_Initialized;
    internal static string Reference_listener_cant_have_properties;
    internal static string Reference_to_nonexistent_listener;
    internal static string SettingsPropertyNotFound;
    internal static string SettingsPropertyReadOnly;
    internal static string SettingsPropertyWrongType;
    internal static string Type_isnt_tracelistener;
    internal static string Unable_to_convert_type_from_string;
    internal static string Unable_to_convert_type_to_string;
    internal static string Value_must_be_numeric;
    internal static string Could_not_create_from_default_value;
    internal static string Could_not_create_from_default_value_2;
    internal static string InvalidDirName;
    internal static string FSW_IOError;
    internal static string PatternInvalidChar;
    internal static string BufferSizeTooLarge;
    internal static string FSW_ChangedFilter;
    internal static string FSW_Enabled;
    internal static string FSW_Filter;
    internal static string FSW_IncludeSubdirectories;
    internal static string FSW_Path;
    internal static string FSW_SynchronizingObject;
    internal static string FSW_Changed;
    internal static string FSW_Created;
    internal static string FSW_Deleted;
    internal static string FSW_Renamed;
    internal static string FSW_BufferOverflow;
    internal static string FileSystemWatcherDesc;
    internal static string NotSet;
    internal static string TimerAutoReset;
    internal static string TimerEnabled;
    internal static string TimerInterval;
    internal static string TimerIntervalElapsed;
    internal static string TimerSynchronizingObject;
    internal static string MismatchedCounterTypes;
    internal static string NoPropertyForAttribute;
    internal static string InvalidAttributeType;
    internal static string Generic_ArgCantBeEmptyString;
    internal static string BadLogName;
    internal static string InvalidProperty;
    internal static string CantMonitorEventLog;
    internal static string InitTwice;
    internal static string InvalidParameter;
    internal static string MissingParameter;
    internal static string ParameterTooLong;
    internal static string LocalSourceAlreadyExists;
    internal static string SourceAlreadyExists;
    internal static string LocalLogAlreadyExistsAsSource;
    internal static string LogAlreadyExistsAsSource;
    internal static string DuplicateLogName;
    internal static string RegKeyMissing;
    internal static string LocalRegKeyMissing;
    internal static string RegKeyMissingShort;
    internal static string InvalidParameterFormat;
    internal static string NoLogName;
    internal static string RegKeyNoAccess;
    internal static string MissingLog;
    internal static string SourceNotRegistered;
    internal static string LocalSourceNotRegistered;
    internal static string CantRetrieveEntries;
    internal static string IndexOutOfBounds;
    internal static string CantReadLogEntryAt;
    internal static string MissingLogProperty;
    internal static string CantOpenLog;
    internal static string NeedSourceToOpen;
    internal static string NeedSourceToWrite;
    internal static string CantOpenLogAccess;
    internal static string LogEntryTooLong;
    internal static string TooManyReplacementStrings;
    internal static string LogSourceMismatch;
    internal static string NoAccountInfo;
    internal static string NoCurrentEntry;
    internal static string MessageNotFormatted;
    internal static string EventID;
    internal static string LogDoesNotExists;
    internal static string InvalidCustomerLogName;
    internal static string CannotDeleteEqualSource;
    internal static string RentionDaysOutOfRange;
    internal static string MaximumKilobytesOutOfRange;
    internal static string SomeLogsInaccessible;
    internal static string SomeLogsInaccessibleToCreate;
    internal static string BadConfigSwitchValue;
    internal static string ConfigSectionsUnique;
    internal static string ConfigSectionsUniquePerSection;
    internal static string SourceListenerDoesntExist;
    internal static string SourceSwitchDoesntExist;
    internal static string CategoryHelpCorrupt;
    internal static string CounterNameCorrupt;
    internal static string CounterDataCorrupt;
    internal static string ReadOnlyCounter;
    internal static string ReadOnlyRemoveInstance;
    internal static string NotCustomCounter;
    internal static string CategoryNameMissing;
    internal static string CounterNameMissing;
    internal static string InstanceNameProhibited;
    internal static string InstanceNameRequired;
    internal static string MissingInstance;
    internal static string PerformanceCategoryExists;
    internal static string InvalidCounterName;
    internal static string DuplicateCounterName;
    internal static string CantChangeCategoryRegistration;
    internal static string CantDeleteCategory;
    internal static string MissingCategory;
    internal static string MissingCategoryDetail;
    internal static string CantReadCategory;
    internal static string MissingCounter;
    internal static string CategoryNameNotSet;
    internal static string CounterExists;
    internal static string CantReadCategoryIndex;
    internal static string CantReadCounter;
    internal static string CantReadInstance;
    internal static string RemoteWriting;
    internal static string CounterLayout;
    internal static string PossibleDeadlock;
    internal static string SharedMemoryGhosted;
    internal static string HelpNotAvailable;
    internal static string PerfInvalidHelp;
    internal static string PerfInvalidCounterName;
    internal static string PerfInvalidCategoryName;
    internal static string MustAddCounterCreationData;
    internal static string RemoteCounterAdmin;
    internal static string NoInstanceInformation;
    internal static string PerfCounterPdhError;
    internal static string MultiInstanceOnly;
    internal static string SingleInstanceOnly;
    internal static string InstanceNameTooLong;
    internal static string CategoryNameTooLong;
    internal static string InstanceLifetimeProcessonReadOnly;
    internal static string InstanceLifetimeProcessforSingleInstance;
    internal static string InstanceAlreadyExists;
    internal static string CantSetLifetimeAfterInitialized;
    internal static string ProcessLifetimeNotValidInGlobal;
    internal static string CantConvertProcessToGlobal;
    internal static string CantConvertGlobalToProcess;
    internal static string PCNotSupportedUnderAppContainer;
    internal static string PriorityClassNotSupported;
    internal static string WinNTRequired;
    internal static string Win2kRequired;
    internal static string NoAssociatedProcess;
    internal static string ProcessIdRequired;
    internal static string NotSupportedRemote;
    internal static string NoProcessInfo;
    internal static string WaitTillExit;
    internal static string NoProcessHandle;
    internal static string MissingProccess;
    internal static string BadMinWorkset;
    internal static string BadMaxWorkset;
    internal static string WinNTRequiredForRemote;
    internal static string ProcessHasExited;
    internal static string ProcessHasExitedNoId;
    internal static string ThreadExited;
    internal static string Win2000Required;
    internal static string ProcessNotFound;
    internal static string CantGetProcessId;
    internal static string ProcessDisabled;
    internal static string WaitReasonUnavailable;
    internal static string NotSupportedRemoteThread;
    internal static string UseShellExecuteRequiresSTA;
    internal static string CantRedirectStreams;
    internal static string CantUseEnvVars;
    internal static string CantStartAsUser;
    internal static string CouldntConnectToRemoteMachine;
    internal static string CouldntGetProcessInfos;
    internal static string InputIdleUnkownError;
    internal static string FileNameMissing;
    internal static string EnvironmentBlock;
    internal static string EnumProcessModuleFailed;
    internal static string EnumProcessModuleFailedDueToWow;
    internal static string PendingAsyncOperation;
    internal static string NoAsyncOperation;
    internal static string InvalidApplication;
    internal static string StandardOutputEncodingNotAllowed;
    internal static string StandardErrorEncodingNotAllowed;
    internal static string CountersOOM;
    internal static string MappingCorrupted;
    internal static string SetSecurityDescriptorFailed;
    internal static string CantCreateFileMapping;
    internal static string CantMapFileView;
    internal static string CantGetMappingSize;
    internal static string CantGetStandardOut;
    internal static string CantGetStandardIn;
    internal static string CantGetStandardError;
    internal static string CantMixSyncAsyncOperation;
    internal static string NoFileMappingSize;
    internal static string EnvironmentBlockTooLong;
    internal static string CantSetDuplicatePassword;
    internal static string Arg_InvalidSerialPort;
    internal static string Arg_InvalidSerialPortExtended;
    internal static string Arg_SecurityException;
    internal static string Argument_InvalidOffLen;
    internal static string ArgumentNull_Array;
    internal static string ArgumentNull_Buffer;
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper;
    internal static string ArgumentOutOfRange_Enum;
    internal static string ArgumentOutOfRange_NeedNonNegNumRequired;
    internal static string ArgumentOutOfRange_NeedPosNum;
    internal static string ArgumentOutOfRange_Timeout;
    internal static string ArgumentOutOfRange_WriteTimeout;
    internal static string ArgumentOutOfRange_OffsetOut;
    internal static string IndexOutOfRange_IORaceCondition;
    internal static string IO_BindHandleFailed;
    internal static string IO_OperationAborted;
    internal static string NotSupported_UnseekableStream;
    internal static string IO_EOF_ReadBeyondEOF;
    internal static string ObjectDisposed_StreamClosed;
    internal static string UnauthorizedAccess_IODenied_Path;
    internal static string IO_UnknownError;
    internal static string Arg_WrongAsyncResult;
    internal static string InvalidOperation_EndReadCalledMultiple;
    internal static string InvalidOperation_EndWriteCalledMultiple;
    internal static string IO_PortNotFound;
    internal static string IO_PortNotFoundFileName;
    internal static string UnauthorizedAccess_IODenied_NoPathName;
    internal static string IO_PathTooLong;
    internal static string IO_SharingViolation_NoFileName;
    internal static string IO_SharingViolation_File;
    internal static string NotSupported_UnwritableStream;
    internal static string ObjectDisposed_WriterClosed;
    internal static string BaseStream_Invalid_Not_Open;
    internal static string PortNameEmpty_String;
    internal static string Port_not_open;
    internal static string Port_already_open;
    internal static string Cant_be_set_when_open;
    internal static string Max_Baud;
    internal static string In_Break_State;
    internal static string Write_timed_out;
    internal static string CantSetRtsWithHandshaking;
    internal static string NotSupportedOS;
    internal static string NotSupportedEncoding;
    internal static string BaudRate;
    internal static string DataBits;
    internal static string DiscardNull;
    internal static string DtrEnable;
    internal static string Encoding;
    internal static string Handshake;
    internal static string NewLine;
    internal static string Parity;
    internal static string ParityReplace;
    internal static string PortName;
    internal static string ReadBufferSize;
    internal static string ReadTimeout;
    internal static string ReceivedBytesThreshold;
    internal static string RtsEnable;
    internal static string SerialPortDesc;
    internal static string StopBits;
    internal static string WriteBufferSize;
    internal static string WriteTimeout;
    internal static string SerialErrorReceived;
    internal static string SerialPinChanged;
    internal static string SerialDataReceived;
    internal static string CounterType;
    internal static string CounterName;
    internal static string CounterHelp;
    internal static string EventLogDesc;
    internal static string ErrorDataReceived;
    internal static string LogEntries;
    internal static string LogLog;
    internal static string LogMachineName;
    internal static string LogMonitoring;
    internal static string LogSynchronizingObject;
    internal static string LogSource;
    internal static string LogEntryWritten;
    internal static string LogEntryMachineName;
    internal static string LogEntryData;
    internal static string LogEntryIndex;
    internal static string LogEntryCategory;
    internal static string LogEntryCategoryNumber;
    internal static string LogEntryEventID;
    internal static string LogEntryEntryType;
    internal static string LogEntryMessage;
    internal static string LogEntrySource;
    internal static string LogEntryReplacementStrings;
    internal static string LogEntryResourceId;
    internal static string LogEntryTimeGenerated;
    internal static string LogEntryTimeWritten;
    internal static string LogEntryUserName;
    internal static string OutputDataReceived;
    internal static string PC_CounterHelp;
    internal static string PC_CounterType;
    internal static string PC_ReadOnly;
    internal static string PC_RawValue;
    internal static string ProcessAssociated;
    internal static string ProcessDesc;
    internal static string ProcessExitCode;
    internal static string ProcessTerminated;
    internal static string ProcessExitTime;
    internal static string ProcessHandle;
    internal static string ProcessHandleCount;
    internal static string ProcessId;
    internal static string ProcessMachineName;
    internal static string ProcessMainModule;
    internal static string ProcessModules;
    internal static string ProcessSynchronizingObject;
    internal static string ProcessSessionId;
    internal static string ProcessThreads;
    internal static string ProcessEnableRaisingEvents;
    internal static string ProcessExited;
    internal static string ProcessFileName;
    internal static string ProcessWorkingDirectory;
    internal static string ProcessBasePriority;
    internal static string ProcessMainWindowHandle;
    internal static string ProcessMainWindowTitle;
    internal static string ProcessMaxWorkingSet;
    internal static string ProcessMinWorkingSet;
    internal static string ProcessNonpagedSystemMemorySize;
    internal static string ProcessPagedMemorySize;
    internal static string ProcessPagedSystemMemorySize;
    internal static string ProcessPeakPagedMemorySize;
    internal static string ProcessPeakWorkingSet;
    internal static string ProcessPeakVirtualMemorySize;
    internal static string ProcessPriorityBoostEnabled;
    internal static string ProcessPriorityClass;
    internal static string ProcessPrivateMemorySize;
    internal static string ProcessPrivilegedProcessorTime;
    internal static string ProcessProcessName;
    internal static string ProcessProcessorAffinity;
    internal static string ProcessResponding;
    internal static string ProcessStandardError;
    internal static string ProcessStandardInput;
    internal static string ProcessStandardOutput;
    internal static string ProcessStartInfo;
    internal static string ProcessStartTime;
    internal static string ProcessTotalProcessorTime;
    internal static string ProcessUserProcessorTime;
    internal static string ProcessVirtualMemorySize;
    internal static string ProcessWorkingSet;
    internal static string ProcModModuleName;
    internal static string ProcModFileName;
    internal static string ProcModBaseAddress;
    internal static string ProcModModuleMemorySize;
    internal static string ProcModEntryPointAddress;
    internal static string ProcessVerb;
    internal static string ProcessArguments;
    internal static string ProcessErrorDialog;
    internal static string ProcessWindowStyle;
    internal static string ProcessCreateNoWindow;
    internal static string ProcessEnvironmentVariables;
    internal static string ProcessRedirectStandardInput;
    internal static string ProcessRedirectStandardOutput;
    internal static string ProcessRedirectStandardError;
    internal static string ProcessUseShellExecute;
    internal static string ThreadBasePriority;
    internal static string ThreadCurrentPriority;
    internal static string ThreadId;
    internal static string ThreadPriorityBoostEnabled;
    internal static string ThreadPriorityLevel;
    internal static string ThreadPrivilegedProcessorTime;
    internal static string ThreadStartAddress;
    internal static string ThreadStartTime;
    internal static string ThreadThreadState;
    internal static string ThreadTotalProcessorTime;
    internal static string ThreadUserProcessorTime;
    internal static string ThreadWaitReason;
    internal static string VerbEditorDefault;
    internal static string AppSettingsReaderNoKey;
    internal static string AppSettingsReaderNoParser;
    internal static string AppSettingsReaderCantParse;
    internal static string AppSettingsReaderEmptyString;
    internal static string InvalidPermissionState;
    internal static string PermissionNumberOfElements;
    internal static string PermissionItemExists;
    internal static string PermissionItemDoesntExist;
    internal static string PermissionBadParameterEnum;
    internal static string PermissionInvalidLength;
    internal static string PermissionTypeMismatch;
    internal static string Argument_NotAPermissionElement;
    internal static string Argument_InvalidXMLBadVersion;
    internal static string InvalidPermissionLevel;
    internal static string TargetNotWebBrowserPermissionLevel;
    internal static string WebBrowserBadXml;
    internal static string KeyedCollNeedNonNegativeNum;
    internal static string KeyedCollDuplicateKey;
    internal static string KeyedCollReferenceKeyNotFound;
    internal static string KeyedCollKeyNotFound;
    internal static string KeyedCollInvalidKey;
    internal static string KeyedCollCapacityOverflow;
    internal static string InvalidOperation_EnumEnded;
    internal static string OrderedDictionary_ReadOnly;
    internal static string OrderedDictionary_SerializationMismatch;
    internal static string Async_ExceptionOccurred;
    internal static string Async_QueueingFailed;
    internal static string Async_OperationCancelled;
    internal static string Async_OperationAlreadyCompleted;
    internal static string Async_NullDelegate;
    internal static string BackgroundWorker_AlreadyRunning;
    internal static string BackgroundWorker_CancellationNotSupported;
    internal static string BackgroundWorker_OperationCompleted;
    internal static string BackgroundWorker_ProgressNotSupported;
    internal static string BackgroundWorker_WorkerAlreadyRunning;
    internal static string BackgroundWorker_WorkerDoesntReportProgress;
    internal static string BackgroundWorker_WorkerDoesntSupportCancellation;
    internal static string Async_ProgressChangedEventArgs_ProgressPercentage;
    internal static string Async_ProgressChangedEventArgs_UserState;
    internal static string Async_AsyncEventArgs_Cancelled;
    internal static string Async_AsyncEventArgs_Error;
    internal static string Async_AsyncEventArgs_UserState;
    internal static string BackgroundWorker_CancellationPending;
    internal static string BackgroundWorker_DoWork;
    internal static string BackgroundWorker_IsBusy;
    internal static string BackgroundWorker_ProgressChanged;
    internal static string BackgroundWorker_RunWorkerCompleted;
    internal static string BackgroundWorker_WorkerReportsProgress;
    internal static string BackgroundWorker_WorkerSupportsCancellation;
    internal static string BackgroundWorker_DoWorkEventArgs_Argument;
    internal static string BackgroundWorker_DoWorkEventArgs_Result;
    internal static string BackgroundWorker_Desc;
    internal static string InstanceCreationEditorDefaultText;
    internal static string PropertyTabAttributeBadPropertyTabScope;
    internal static string PropertyTabAttributeTypeLoadException;
    internal static string PropertyTabAttributeArrayLengthMismatch;
    internal static string PropertyTabAttributeParamsBothNull;
    internal static string InstanceDescriptorCannotBeStatic;
    internal static string InstanceDescriptorMustBeStatic;
    internal static string InstanceDescriptorMustBeReadable;
    internal static string InstanceDescriptorLengthMismatch;
    internal static string ToolboxItemAttributeFailedGetType;
    internal static string PropertyDescriptorCollectionBadValue;
    internal static string PropertyDescriptorCollectionBadKey;
    internal static string AspNetHostingPermissionBadXml;
    internal static string CorruptedGZipHeader;
    internal static string UnknownCompressionMode;
    internal static string UnknownState;
    internal static string InvalidHuffmanData;
    internal static string InvalidCRC;
    internal static string InvalidStreamSize;
    internal static string UnknownBlockType;
    internal static string InvalidBlockLength;
    internal static string GenericInvalidData;
    internal static string CannotReadFromDeflateStream;
    internal static string CannotWriteToDeflateStream;
    internal static string NotReadableStream;
    internal static string NotWriteableStream;
    internal static string InvalidArgumentOffsetCount;
    internal static string InvalidBeginCall;
    internal static string InvalidEndCall;
    internal static string StreamSizeOverflow;
    internal static string ZLibErrorDLLLoadError;
    internal static string ZLibErrorUnexpected;
    internal static string ZLibErrorInconsistentStream;
    internal static string ZLibErrorSteamFreedPrematurely;
    internal static string ZLibErrorNotEnoughMemory;
    internal static string ZLibErrorIncorrectInitParameters;
    internal static string ZLibErrorVersionMismatch;
    internal static string InvalidOperation_HCCountOverflow;
    internal static string Argument_InvalidThreshold;
    internal static string Argument_SemaphoreInitialMaximum;
    internal static string Argument_WaitHandleNameTooLong;
    internal static string WaitHandleCannotBeOpenedException_InvalidHandle;
    internal static string ArgumentNotAPermissionElement;
    internal static string ArgumentWrongType;
    internal static string BadXmlVersion;
    internal static string BinarySerializationNotSupported;
    internal static string BothScopeAttributes;
    internal static string NoScopeAttributes;
    internal static string PositionOutOfRange;
    internal static string ProviderInstantiationFailed;
    internal static string ProviderTypeLoadFailed;
    internal static string SaveAppScopedNotSupported;
    internal static string SettingsResetFailed;
    internal static string SettingsSaveFailed;
    internal static string SettingsSaveFailedNoSection;
    internal static string StringDeserializationFailed;
    internal static string StringSerializationFailed;
    internal static string UnknownSerializationFormat;
    internal static string UnknownSeekOrigin;
    internal static string UnknownUserLevel;
    internal static string UserSettingsNotSupported;
    internal static string XmlDeserializationFailed;
    internal static string XmlSerializationFailed;
    internal static string MemberRelationshipService_RelationshipNotSupported;
    internal static string MaskedTextProviderPasswordAndPromptCharError;
    internal static string MaskedTextProviderInvalidCharError;
    internal static string MaskedTextProviderMaskNullOrEmpty;
    internal static string MaskedTextProviderMaskInvalidChar;
    internal static string StandardOleMarshalObjectGetMarshalerFailed;
    internal static string SoundAPIBadSoundLocation;
    internal static string SoundAPIFileDoesNotExist;
    internal static string SoundAPIFormatNotSupported;
    internal static string SoundAPIInvalidWaveFile;
    internal static string SoundAPIInvalidWaveHeader;
    internal static string SoundAPILoadTimedOut;
    internal static string SoundAPILoadTimeout;
    internal static string SoundAPIReadError;
    internal static string WrongActionForCtor;
    internal static string MustBeResetAddOrRemoveActionForCtor;
    internal static string ResetActionRequiresNullItem;
    internal static string ResetActionRequiresIndexMinus1;
    internal static string IndexCannotBeNegative;
    internal static string ObservableCollectionReentrancyNotAllowed;
    internal static string net_ssl_io_already_shutdown;
    internal static string net_io_readwritefailure;
    internal static string Cryptography_X509_InvalidFlagCombination;
    public static ResourceManager Resources { get; }
    private static SR();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class System.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.SRDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsNormalized(string value);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsNormalized(string value, NormalizationForm normalizationForm);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static string Normalize(string value);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
[EditorBrowsableAttribute("1")]
public static string Normalize(string value, NormalizationForm normalizationForm);
}
internal class System.Text.RegularExpressions.CachedCodeEntry : object {
    internal string _key;
    internal RegexCode _code;
    internal Hashtable _caps;
    internal Hashtable _capnames;
    internal String[] _capslist;
    internal int _capsize;
    internal RegexRunnerFactory _factory;
    internal ExclusiveReference _runnerref;
    internal SharedReference _replref;
    internal CachedCodeEntry(string key, Hashtable capnames, String[] capslist, RegexCode code, Hashtable caps, int capsize, ExclusiveReference runner, SharedReference repl);
    internal void AddCompiled(RegexRunnerFactory factory);
}
public class System.Text.RegularExpressions.Capture : object {
    internal string _text;
    internal int _index;
    internal int _length;
    public int Index { get; }
    public int Length { get; }
    public string Value { get; }
    internal Capture(string text, int i, int l);
    public int get_Index();
    public int get_Length();
    public string get_Value();
    public virtual string ToString();
    internal string GetOriginalString();
    internal string GetLeftSubstring();
    internal string GetRightSubstring();
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.CaptureCollection : object {
    internal Group _group;
    internal int _capcount;
    internal Capture[] _captures;
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Capture Item { get; }
    internal CaptureCollection(Group group);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public Capture get_Item(int i);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
    internal Capture GetCapture(int i);
}
internal class System.Text.RegularExpressions.CaptureEnumerator : object {
    internal CaptureCollection _rcc;
    internal int _curindex;
    public object Current { get; }
    public Capture Capture { get; }
    internal CaptureEnumerator(CaptureCollection rcc);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public Capture get_Capture();
    public sealed virtual void Reset();
}
internal class System.Text.RegularExpressions.CompiledRegexRunner : RegexRunner {
    internal void SetDelegates(NoParamDelegate go, FindFirstCharDelegate firstChar, NoParamDelegate trackCount);
    protected virtual void Go();
    protected virtual bool FindFirstChar();
    protected virtual void InitTrackCount();
}
internal class System.Text.RegularExpressions.CompiledRegexRunnerFactory : RegexRunnerFactory {
    internal CompiledRegexRunnerFactory(DynamicMethod go, DynamicMethod firstChar, DynamicMethod trackCount);
    protected internal virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.CreateInstanceDelegate : MulticastDelegate {
    public CreateInstanceDelegate(object object, IntPtr method);
    public virtual RegexRunner Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual RegexRunner EndInvoke(IAsyncResult result);
}
internal class System.Text.RegularExpressions.ExclusiveReference : object {
    internal object Get();
    internal void Release(object obj);
}
internal class System.Text.RegularExpressions.FindFirstCharDelegate : MulticastDelegate {
    public FindFirstCharDelegate(object object, IntPtr method);
    public virtual bool Invoke(RegexRunner r);
    public virtual IAsyncResult BeginInvoke(RegexRunner r, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Text.RegularExpressions.Group : Capture {
    internal static Group _emptygroup;
    internal Int32[] _caps;
    internal int _capcount;
    internal CaptureCollection _capcoll;
    [OptionalFieldAttribute]
internal string _name;
    public bool Success { get; }
    public string Name { get; }
    public CaptureCollection Captures { get; }
    internal Group(string text, Int32[] caps, int capcount, string name);
    private static Group();
    public bool get_Success();
    public string get_Name();
    public CaptureCollection get_Captures();
    public static Group Synchronized(Group inner);
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.GroupCollection : object {
    internal Match _match;
    internal Hashtable _captureMap;
    internal Group[] _groups;
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public Group Item { get; }
    public Group Item { get; }
    internal GroupCollection(Match match, Hashtable caps);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public Group get_Item(int groupnum);
    public Group get_Item(string groupname);
    internal Group GetGroup(int groupnum);
    internal Group GetGroupImpl(int groupnum);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class System.Text.RegularExpressions.GroupEnumerator : object {
    internal GroupCollection _rgc;
    internal int _curindex;
    public object Current { get; }
    public Capture Capture { get; }
    internal GroupEnumerator(GroupCollection rgc);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public Capture get_Capture();
    public sealed virtual void Reset();
}
public class System.Text.RegularExpressions.Match : Group {
    internal static Match _empty;
    internal GroupCollection _groupcoll;
    internal Regex _regex;
    internal int _textbeg;
    internal int _textpos;
    internal int _textend;
    internal int _textstart;
    internal Int32[][] _matches;
    internal Int32[] _matchcount;
    internal bool _balancing;
    public static Match Empty { get; }
    public GroupCollection Groups { get; }
    internal Match(Regex regex, int capcount, string text, int begpos, int len, int startpos);
    private static Match();
    public static Match get_Empty();
    internal virtual void Reset(Regex regex, string text, int textbeg, int textend, int textstart);
    public virtual GroupCollection get_Groups();
    public Match NextMatch();
    public virtual string Result(string replacement);
    internal virtual string GroupToStringImpl(int groupnum);
    internal string LastGroupToStringImpl();
    public static Match Synchronized(Match inner);
    internal virtual void AddMatch(int cap, int start, int len);
    internal virtual void BalanceMatch(int cap);
    internal virtual void RemoveMatch(int cap);
    internal virtual bool IsMatched(int cap);
    internal virtual int MatchIndex(int cap);
    internal virtual int MatchLength(int cap);
    internal virtual void Tidy(int textpos);
}
[DefaultMemberAttribute("Item")]
public class System.Text.RegularExpressions.MatchCollection : object {
    internal Regex _regex;
    internal ArrayList _matches;
    internal bool _done;
    internal string _input;
    internal int _beginning;
    internal int _length;
    internal int _startat;
    internal int _prevlen;
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public Match Item { get; }
    internal MatchCollection(Regex regex, string input, int beginning, int length, int startat);
    private static MatchCollection();
    internal Match GetMatch(int i);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    public virtual Match get_Item(int i);
    public sealed virtual void CopyTo(Array array, int arrayIndex);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class System.Text.RegularExpressions.MatchEnumerator : object {
    internal MatchCollection _matchcoll;
    internal Match _match;
    internal int _curindex;
    internal bool _done;
    public object Current { get; }
    internal MatchEnumerator(MatchCollection matchcoll);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
public class System.Text.RegularExpressions.MatchEvaluator : MulticastDelegate {
    public MatchEvaluator(object object, IntPtr method);
    public virtual string Invoke(Match match);
    public virtual IAsyncResult BeginInvoke(Match match, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class System.Text.RegularExpressions.MatchSparse : Match {
    internal Hashtable _caps;
    public GroupCollection Groups { get; }
    internal MatchSparse(Regex regex, Hashtable caps, int capcount, string text, int begpos, int len, int startpos);
    public virtual GroupCollection get_Groups();
}
internal class System.Text.RegularExpressions.NoParamDelegate : MulticastDelegate {
    public NoParamDelegate(object object, IntPtr method);
    public virtual void Invoke(RegexRunner r);
    public virtual IAsyncResult BeginInvoke(RegexRunner r, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Text.RegularExpressions.Regex : object {
    protected internal string pattern;
    protected internal RegexRunnerFactory factory;
    protected internal RegexOptions roptions;
    public static TimeSpan InfiniteMatchTimeout;
    [OptionalFieldAttribute]
protected internal TimeSpan internalMatchTimeout;
    internal static TimeSpan FallbackDefaultMatchTimeout;
    internal static TimeSpan DefaultMatchTimeout;
    protected internal Hashtable caps;
    protected internal Hashtable capnames;
    protected internal String[] capslist;
    protected internal int capsize;
    internal ExclusiveReference runnerref;
    internal SharedReference replref;
    internal RegexCode code;
    internal bool refsInitialized;
    internal static LinkedList`1<CachedCodeEntry> livecode;
    internal static int cacheSize;
    internal static int MaxOptionShift;
    [CLSCompliantAttribute("False")]
protected IDictionary Caps { get; protected set; }
    [CLSCompliantAttribute("False")]
protected IDictionary CapNames { get; protected set; }
    public static int CacheSize { get; public set; }
    public RegexOptions Options { get; }
    public TimeSpan MatchTimeout { get; }
    public bool RightToLeft { get; }
    public Regex(string pattern);
    public Regex(string pattern, RegexOptions options);
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
    protected Regex(SerializationInfo info, StreamingContext context);
    private static Regex();
    protected IDictionary get_Caps();
    protected void set_Caps(IDictionary value);
    protected IDictionary get_CapNames();
    protected void set_CapNames(IDictionary value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
    internal RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions);
    public static string Escape(string str);
    public static string Unescape(string str);
    public static int get_CacheSize();
    public static void set_CacheSize(int value);
    public RegexOptions get_Options();
    public TimeSpan get_MatchTimeout();
    public bool get_RightToLeft();
    public virtual string ToString();
    public String[] GetGroupNames();
    public Int32[] GetGroupNumbers();
    public string GroupNameFromNumber(int i);
    public int GroupNumberFromName(string name);
    public static bool IsMatch(string input, string pattern);
    public static bool IsMatch(string input, string pattern, RegexOptions options);
    public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public bool IsMatch(string input);
    public bool IsMatch(string input, int startat);
    public static Match Match(string input, string pattern);
    public static Match Match(string input, string pattern, RegexOptions options);
    public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public Match Match(string input);
    public Match Match(string input, int startat);
    public Match Match(string input, int beginning, int length);
    public static MatchCollection Matches(string input, string pattern);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options);
    public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public MatchCollection Matches(string input);
    public MatchCollection Matches(string input, int startat);
    public static string Replace(string input, string pattern, string replacement);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options);
    public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, string replacement);
    public string Replace(string input, string replacement, int count);
    public string Replace(string input, string replacement, int count, int startat);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
    public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
    public string Replace(string input, MatchEvaluator evaluator);
    public string Replace(string input, MatchEvaluator evaluator, int count);
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
    public static String[] Split(string input, string pattern);
    public static String[] Split(string input, string pattern, RegexOptions options);
    public static String[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
    public String[] Split(string input);
    public String[] Split(string input, int count);
    public String[] Split(string input, int count, int startat);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes);
    public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile);
    protected void InitializeReferences();
    internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat);
    protected bool UseOptionC();
    protected bool UseOptionR();
    internal bool UseOptionInvariant();
}
internal class System.Text.RegularExpressions.RegexBoyerMoore : object {
    internal Int32[] _positive;
    internal Int32[] _negativeASCII;
    internal Int32[][] _negativeUnicode;
    internal string _pattern;
    internal int _lowASCII;
    internal int _highASCII;
    internal bool _rightToLeft;
    internal bool _caseInsensitive;
    internal CultureInfo _culture;
    internal static int infinite;
    internal RegexBoyerMoore(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture);
    internal bool IsMatch(string text, int index, int beglimit, int endlimit);
    internal int Scan(string text, int index, int beglimit, int endlimit);
    public virtual string ToString();
}
internal class System.Text.RegularExpressions.RegexCharClass : object {
    internal static string SpaceClass;
    internal static string NotSpaceClass;
    internal static string WordClass;
    internal static string NotWordClass;
    internal static string DigitClass;
    internal static string NotDigitClass;
    internal static string ECMASpaceClass;
    internal static string NotECMASpaceClass;
    internal static string ECMAWordClass;
    internal static string NotECMAWordClass;
    internal static string ECMADigitClass;
    internal static string NotECMADigitClass;
    internal static string AnyClass;
    internal static string EmptyClass;
    internal bool CanMerge { get; }
    unknown bool Negate {internal set; }
    private static RegexCharClass();
    internal bool get_CanMerge();
    internal void set_Negate(bool value);
    internal void AddChar(char c);
    internal void AddCharClass(RegexCharClass cc);
    internal void AddSubtraction(RegexCharClass sub);
    internal void AddRange(char first, char last);
    internal void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern);
    internal void AddLowercase(CultureInfo culture);
    internal void AddWord(bool ecma, bool negate);
    internal void AddSpace(bool ecma, bool negate);
    internal void AddDigit(bool ecma, bool negate, string pattern);
    internal static string ConvertOldStringsToClass(string set, string category);
    internal static char SingletonChar(string set);
    internal static bool IsMergeable(string charClass);
    internal static bool IsEmpty(string charClass);
    internal static bool IsSingleton(string set);
    internal static bool IsSingletonInverse(string set);
    internal static bool IsNegated(string set);
    internal static bool IsECMAWordChar(char ch);
    internal static bool IsWordChar(char ch);
    internal static bool CharInClass(char ch, string set);
    internal static bool CharInClassRecursive(char ch, string set, int start);
    internal static RegexCharClass Parse(string charClass);
    internal string ToStringClass();
}
internal class System.Text.RegularExpressions.RegexCode : object {
    internal static int Onerep;
    internal static int Notonerep;
    internal static int Setrep;
    internal static int Oneloop;
    internal static int Notoneloop;
    internal static int Setloop;
    internal static int Onelazy;
    internal static int Notonelazy;
    internal static int Setlazy;
    internal static int One;
    internal static int Notone;
    internal static int Set;
    internal static int Multi;
    internal static int Ref;
    internal static int Bol;
    internal static int Eol;
    internal static int Boundary;
    internal static int Nonboundary;
    internal static int Beginning;
    internal static int Start;
    internal static int EndZ;
    internal static int End;
    internal static int Nothing;
    internal static int Lazybranch;
    internal static int Branchmark;
    internal static int Lazybranchmark;
    internal static int Nullcount;
    internal static int Setcount;
    internal static int Branchcount;
    internal static int Lazybranchcount;
    internal static int Nullmark;
    internal static int Setmark;
    internal static int Capturemark;
    internal static int Getmark;
    internal static int Setjump;
    internal static int Backjump;
    internal static int Forejump;
    internal static int Testref;
    internal static int Goto;
    internal static int Prune;
    internal static int Stop;
    internal static int ECMABoundary;
    internal static int NonECMABoundary;
    internal static int Mask;
    internal static int Rtl;
    internal static int Back;
    internal static int Back2;
    internal static int Ci;
    internal Int32[] _codes;
    internal String[] _strings;
    internal int _trackcount;
    internal Hashtable _caps;
    internal int _capsize;
    internal RegexPrefix _fcPrefix;
    internal RegexBoyerMoore _bmPrefix;
    internal int _anchors;
    internal bool _rightToLeft;
    internal RegexCode(Int32[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, RegexPrefix fcPrefix, int anchors, bool rightToLeft);
    internal static bool OpcodeBacktracks(int Op);
    internal static int OpcodeSize(int Opcode);
    internal static ArgumentException MakeException(string message);
}
public class System.Text.RegularExpressions.RegexCompilationInfo : object {
    public string Pattern { get; public set; }
    public RegexOptions Options { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsPublic { get; public set; }
    public TimeSpan MatchTimeout { get; public set; }
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic);
    public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);
    public string get_Pattern();
    public void set_Pattern(string value);
    public RegexOptions get_Options();
    public void set_Options(RegexOptions value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public TimeSpan get_MatchTimeout();
    public void set_MatchTimeout(TimeSpan value);
}
internal abstract class System.Text.RegularExpressions.RegexCompiler : object {
    internal static FieldInfo _textbegF;
    internal static FieldInfo _textendF;
    internal static FieldInfo _textstartF;
    internal static FieldInfo _textposF;
    internal static FieldInfo _textF;
    internal static FieldInfo _trackposF;
    internal static FieldInfo _trackF;
    internal static FieldInfo _stackposF;
    internal static FieldInfo _stackF;
    internal static FieldInfo _trackcountF;
    internal static MethodInfo _ensurestorageM;
    internal static MethodInfo _captureM;
    internal static MethodInfo _transferM;
    internal static MethodInfo _uncaptureM;
    internal static MethodInfo _ismatchedM;
    internal static MethodInfo _matchlengthM;
    internal static MethodInfo _matchindexM;
    internal static MethodInfo _isboundaryM;
    internal static MethodInfo _isECMABoundaryM;
    internal static MethodInfo _chartolowerM;
    internal static MethodInfo _getcharM;
    internal static MethodInfo _crawlposM;
    internal static MethodInfo _charInSetM;
    internal static MethodInfo _getCurrentCulture;
    internal static MethodInfo _getInvariantCulture;
    internal static MethodInfo _checkTimeoutM;
    internal ILGenerator _ilg;
    internal LocalBuilder _textstartV;
    internal LocalBuilder _textbegV;
    internal LocalBuilder _textendV;
    internal LocalBuilder _textposV;
    internal LocalBuilder _textV;
    internal LocalBuilder _trackposV;
    internal LocalBuilder _trackV;
    internal LocalBuilder _stackposV;
    internal LocalBuilder _stackV;
    internal LocalBuilder _tempV;
    internal LocalBuilder _temp2V;
    internal LocalBuilder _temp3V;
    internal RegexCode _code;
    internal Int32[] _codes;
    internal String[] _strings;
    internal RegexPrefix _fcPrefix;
    internal RegexBoyerMoore _bmPrefix;
    internal int _anchors;
    internal Label[] _labels;
    internal BacktrackNote[] _notes;
    internal int _notecount;
    internal int _trackcount;
    internal Label _backtrack;
    internal int _regexopcode;
    internal int _codepos;
    internal int _backpos;
    internal RegexOptions _options;
    internal Int32[] _uniquenote;
    internal Int32[] _goto;
    internal static int stackpop;
    internal static int stackpop2;
    internal static int stackpop3;
    internal static int capback;
    internal static int capback2;
    internal static int branchmarkback2;
    internal static int lazybranchmarkback2;
    internal static int branchcountback2;
    internal static int lazybranchcountback2;
    internal static int forejumpback;
    internal static int uniquecount;
    private static RegexCompiler();
    internal static RegexRunnerFactory Compile(RegexCode code, RegexOptions options);
    internal static void CompileToAssembly(RegexCompilationInfo[] regexes, AssemblyName an, CustomAttributeBuilder[] attribs, string resourceFile);
    internal int AddBacktrackNote(int flags, Label l, int codepos);
    internal int AddTrack();
    internal int AddTrack(int flags);
    internal int AddGoto(int destpos);
    internal int AddUniqueTrack(int i);
    internal int AddUniqueTrack(int i, int flags);
    internal Label DefineLabel();
    internal void MarkLabel(Label l);
    internal int Operand(int i);
    internal bool IsRtl();
    internal bool IsCi();
    internal int Code();
    internal void Ldstr(string str);
    internal void Ldc(int i);
    internal void LdcI8(long i);
    internal void Dup();
    internal void Ret();
    internal void Pop();
    internal void Add();
    internal void Add(bool negate);
    internal void Sub();
    internal void Sub(bool negate);
    internal void Ldloc(LocalBuilder lt);
    internal void Stloc(LocalBuilder lt);
    internal void Ldthis();
    internal void Ldthisfld(FieldInfo ft);
    internal void Mvfldloc(FieldInfo ft, LocalBuilder lt);
    internal void Mvlocfld(LocalBuilder lt, FieldInfo ft);
    internal void Stfld(FieldInfo ft);
    internal void Callvirt(MethodInfo mt);
    internal void Call(MethodInfo mt);
    internal void Newobj(ConstructorInfo ct);
    internal void BrfalseFar(Label l);
    internal void BrtrueFar(Label l);
    internal void BrFar(Label l);
    internal void BleFar(Label l);
    internal void BltFar(Label l);
    internal void BgeFar(Label l);
    internal void BgtFar(Label l);
    internal void BneFar(Label l);
    internal void BeqFar(Label l);
    internal void Brfalse(Label l);
    internal void Br(Label l);
    internal void Ble(Label l);
    internal void Blt(Label l);
    internal void Bge(Label l);
    internal void Bgt(Label l);
    internal void Bgtun(Label l);
    internal void Bne(Label l);
    internal void Beq(Label l);
    internal void Ldlen();
    internal void Rightchar();
    internal void Rightcharnext();
    internal void Leftchar();
    internal void Leftcharnext();
    internal void Track();
    internal void Trackagain();
    internal void PushTrack(LocalBuilder lt);
    internal void TrackUnique(int i);
    internal void TrackUnique2(int i);
    internal void ReadyPushTrack();
    internal void PopTrack();
    internal void TopTrack();
    internal void PushStack(LocalBuilder lt);
    internal void ReadyReplaceStack(int i);
    internal void ReadyPushStack();
    internal void TopStack();
    internal void PopStack();
    internal void PopDiscardStack();
    internal void PopDiscardStack(int i);
    internal void DoReplace();
    internal void DoPush();
    internal void Back();
    internal void Goto(int i);
    internal int NextCodepos();
    internal Label AdvanceLabel();
    internal void Advance();
    internal void CallToLower();
    internal void GenerateForwardSection();
    internal void GenerateMiddleSection();
    internal void GenerateBacktrackSection();
    internal void GenerateFindFirstChar();
    internal void GenerateInitTrackCount();
    internal LocalBuilder DeclareInt();
    internal LocalBuilder DeclareIntArray();
    internal LocalBuilder DeclareString();
    internal void GenerateGo();
    internal void GenerateOneCode();
}
internal class System.Text.RegularExpressions.RegexFC : object {
    internal RegexCharClass _cc;
    internal bool _nullable;
    internal bool _caseInsensitive;
    internal RegexFC(bool nullable);
    internal RegexFC(char ch, bool not, bool nullable, bool caseInsensitive);
    internal RegexFC(string charClass, bool nullable, bool caseInsensitive);
    internal bool AddFC(RegexFC fc, bool concatenate);
    internal string GetFirstChars(CultureInfo culture);
    internal bool IsCaseInsensitive();
}
internal class System.Text.RegularExpressions.RegexFCD : object {
    internal static int Beginning;
    internal static int Bol;
    internal static int Start;
    internal static int Eol;
    internal static int EndZ;
    internal static int End;
    internal static int Boundary;
    internal static int ECMABoundary;
    internal static RegexPrefix FirstChars(RegexTree t);
    internal static RegexPrefix Prefix(RegexTree tree);
    internal static int Anchors(RegexTree tree);
}
internal class System.Text.RegularExpressions.RegexInterpreter : RegexRunner {
    internal int runoperator;
    internal Int32[] runcodes;
    internal int runcodepos;
    internal String[] runstrings;
    internal RegexCode runcode;
    internal RegexPrefix runfcPrefix;
    internal RegexBoyerMoore runbmPrefix;
    internal int runanchors;
    internal bool runrtl;
    internal bool runci;
    internal CultureInfo runculture;
    internal RegexInterpreter(RegexCode code, CultureInfo culture);
    protected virtual void InitTrackCount();
    protected virtual bool FindFirstChar();
    protected virtual void Go();
}
internal class System.Text.RegularExpressions.RegexLWCGCompiler : RegexCompiler {
    private static RegexLWCGCompiler();
    internal RegexRunnerFactory FactoryInstanceFromCode(RegexCode code, RegexOptions options);
    internal DynamicMethod DefineDynamicMethod(string methname, Type returntype, Type hostType);
}
public class System.Text.RegularExpressions.RegexMatchTimeoutException : TimeoutException {
    public string Pattern { get; }
    public string Input { get; }
    public TimeSpan MatchTimeout { get; }
    public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
    public RegexMatchTimeoutException(string message);
    public RegexMatchTimeoutException(string message, Exception inner);
    protected RegexMatchTimeoutException(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
    public string get_Pattern();
    public string get_Input();
    public TimeSpan get_MatchTimeout();
}
internal class System.Text.RegularExpressions.RegexNode : object {
    internal static int Oneloop;
    internal static int Notoneloop;
    internal static int Setloop;
    internal static int Onelazy;
    internal static int Notonelazy;
    internal static int Setlazy;
    internal static int One;
    internal static int Notone;
    internal static int Set;
    internal static int Multi;
    internal static int Ref;
    internal static int Bol;
    internal static int Eol;
    internal static int Boundary;
    internal static int Nonboundary;
    internal static int ECMABoundary;
    internal static int NonECMABoundary;
    internal static int Beginning;
    internal static int Start;
    internal static int EndZ;
    internal static int End;
    internal static int Nothing;
    internal static int Empty;
    internal static int Alternate;
    internal static int Concatenate;
    internal static int Loop;
    internal static int Lazyloop;
    internal static int Capture;
    internal static int Group;
    internal static int Require;
    internal static int Prevent;
    internal static int Greedy;
    internal static int Testref;
    internal static int Testgroup;
    internal int _type;
    internal List`1<RegexNode> _children;
    internal string _str;
    internal char _ch;
    internal int _m;
    internal int _n;
    internal RegexOptions _options;
    internal RegexNode _next;
    internal RegexNode(int type, RegexOptions options);
    internal RegexNode(int type, RegexOptions options, char ch);
    internal RegexNode(int type, RegexOptions options, string str);
    internal RegexNode(int type, RegexOptions options, int m);
    internal RegexNode(int type, RegexOptions options, int m, int n);
    internal bool UseOptionR();
    internal RegexNode ReverseLeft();
    internal void MakeRep(int type, int min, int max);
    internal RegexNode Reduce();
    internal RegexNode StripEnation(int emptyType);
    internal RegexNode ReduceGroup();
    internal RegexNode ReduceRep();
    internal RegexNode ReduceSet();
    internal RegexNode ReduceAlternation();
    internal RegexNode ReduceConcatenation();
    internal RegexNode MakeQuantifier(bool lazy, int min, int max);
    internal void AddChild(RegexNode newChild);
    internal RegexNode Child(int i);
    internal int ChildCount();
    internal int Type();
}
[FlagsAttribute]
public enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions None;
    public static RegexOptions IgnoreCase;
    public static RegexOptions Multiline;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions Compiled;
    public static RegexOptions Singleline;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions RightToLeft;
    public static RegexOptions ECMAScript;
    public static RegexOptions CultureInvariant;
}
internal class System.Text.RegularExpressions.RegexParser : object {
    internal RegexNode _stack;
    internal RegexNode _group;
    internal RegexNode _alternation;
    internal RegexNode _concatenation;
    internal RegexNode _unit;
    internal string _pattern;
    internal int _currentPos;
    internal CultureInfo _culture;
    internal int _autocap;
    internal int _capcount;
    internal int _captop;
    internal int _capsize;
    internal Hashtable _caps;
    internal Hashtable _capnames;
    internal Int32[] _capnumlist;
    internal List`1<string> _capnamelist;
    internal RegexOptions _options;
    internal List`1<RegexOptions> _optionsStack;
    internal bool _ignoreNextParen;
    internal static int MaxValueDiv10;
    internal static int MaxValueMod10;
    internal static byte Q;
    internal static byte S;
    internal static byte Z;
    internal static byte X;
    internal static byte E;
    internal static Byte[] _category;
    private static RegexParser();
    internal static RegexTree Parse(string re, RegexOptions op);
    internal static RegexReplacement ParseReplacement(string rep, Hashtable caps, int capsize, Hashtable capnames, RegexOptions op);
    internal static string Escape(string input);
    internal static string Unescape(string input);
    internal void SetPattern(string Re);
    internal void Reset(RegexOptions topopts);
    internal RegexNode ScanRegex();
    internal RegexNode ScanReplacement();
    internal RegexCharClass ScanCharClass(bool caseInsensitive);
    internal RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
    internal RegexNode ScanGroupOpen();
    internal void ScanBlank();
    internal RegexNode ScanBackslash();
    internal RegexNode ScanBasicBackslash();
    internal RegexNode ScanDollar();
    internal string ScanCapname();
    internal char ScanOctal();
    internal int ScanDecimal();
    internal char ScanHex(int c);
    internal static int HexDigit(char ch);
    internal char ScanControl();
    internal bool IsOnlyTopOption(RegexOptions option);
    internal void ScanOptions();
    internal char ScanCharEscape();
    internal string ParseProperty();
    internal int TypeFromCode(char ch);
    internal static RegexOptions OptionFromCode(char ch);
    internal void CountCaptures();
    internal void NoteCaptureSlot(int i, int pos);
    internal void NoteCaptureName(string name, int pos);
    internal void NoteCaptures(Hashtable caps, int capsize, Hashtable capnames);
    internal void AssignNameSlots();
    internal int CaptureSlotFromName(string capname);
    internal bool IsCaptureSlot(int i);
    internal bool IsCaptureName(string capname);
    internal bool UseOptionN();
    internal bool UseOptionI();
    internal bool UseOptionM();
    internal bool UseOptionS();
    internal bool UseOptionX();
    internal bool UseOptionE();
    internal static bool IsSpecial(char ch);
    internal static bool IsStopperX(char ch);
    internal static bool IsQuantifier(char ch);
    internal bool IsTrueQuantifier();
    internal static bool IsSpace(char ch);
    internal static bool IsMetachar(char ch);
    internal void AddConcatenate(int pos, int cch, bool isReplacement);
    internal void PushGroup();
    internal void PopGroup();
    internal bool EmptyStack();
    internal void StartGroup(RegexNode openGroup);
    internal void AddAlternate();
    internal void AddConcatenate();
    internal void AddConcatenate(bool lazy, int min, int max);
    internal RegexNode Unit();
    internal void AddUnitOne(char ch);
    internal void AddUnitNotone(char ch);
    internal void AddUnitSet(string cc);
    internal void AddUnitNode(RegexNode node);
    internal void AddUnitType(int type);
    internal void AddGroup();
    internal void PushOptions();
    internal void PopOptions();
    internal bool EmptyOptionsStack();
    internal void PopKeepOptions();
    internal ArgumentException MakeException(string message);
    internal int Textpos();
    internal void Textto(int pos);
    internal char MoveRightGetChar();
    internal void MoveRight();
    internal void MoveRight(int i);
    internal void MoveLeft();
    internal char CharAt(int i);
    internal char RightChar();
    internal char RightChar(int i);
    internal int CharsRight();
}
internal class System.Text.RegularExpressions.RegexPrefix : object {
    internal string _prefix;
    internal bool _caseInsensitive;
    internal static RegexPrefix _empty;
    internal string Prefix { get; }
    internal bool CaseInsensitive { get; }
    internal static RegexPrefix Empty { get; }
    internal RegexPrefix(string prefix, bool ci);
    private static RegexPrefix();
    internal string get_Prefix();
    internal bool get_CaseInsensitive();
    internal static RegexPrefix get_Empty();
}
internal class System.Text.RegularExpressions.RegexReplacement : object {
    internal string _rep;
    internal List`1<string> _strings;
    internal List`1<int> _rules;
    internal static int Specials;
    internal static int LeftPortion;
    internal static int RightPortion;
    internal static int LastGroup;
    internal static int WholeString;
    internal string Pattern { get; }
    internal RegexReplacement(string rep, RegexNode concat, Hashtable _caps);
    internal string get_Pattern();
    internal string Replacement(Match match);
    internal string Replace(Regex regex, string input, int count, int startat);
    internal static string Replace(MatchEvaluator evaluator, Regex regex, string input, int count, int startat);
    internal static String[] Split(Regex regex, string input, int count, int startat);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunner : object {
    protected internal int runtextbeg;
    protected internal int runtextend;
    protected internal int runtextstart;
    protected internal string runtext;
    protected internal int runtextpos;
    protected internal Int32[] runtrack;
    protected internal int runtrackpos;
    protected internal Int32[] runstack;
    protected internal int runstackpos;
    protected internal Int32[] runcrawl;
    protected internal int runcrawlpos;
    protected internal int runtrackcount;
    protected internal Match runmatch;
    protected internal Regex runregex;
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
    protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
    protected void CheckTimeout();
    protected abstract virtual void Go();
    protected abstract virtual bool FindFirstChar();
    protected abstract virtual void InitTrackCount();
    protected void EnsureStorage();
    protected bool IsBoundary(int index, int startpos, int endpos);
    protected bool IsECMABoundary(int index, int startpos, int endpos);
    protected static bool CharInSet(char ch, string set, string category);
    protected static bool CharInClass(char ch, string charClass);
    protected void DoubleTrack();
    protected void DoubleStack();
    protected void DoubleCrawl();
    protected void Crawl(int i);
    protected int Popcrawl();
    protected int Crawlpos();
    protected void Capture(int capnum, int start, int end);
    protected void TransferCapture(int capnum, int uncapnum, int start, int end);
    protected void Uncapture();
    protected bool IsMatched(int cap);
    protected int MatchIndex(int cap);
    protected int MatchLength(int cap);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Text.RegularExpressions.RegexRunnerFactory : object {
    protected internal abstract virtual RegexRunner CreateInstance();
}
internal class System.Text.RegularExpressions.RegexTree : object {
    internal RegexNode _root;
    internal Hashtable _caps;
    internal Int32[] _capnumlist;
    internal Hashtable _capnames;
    internal String[] _capslist;
    internal RegexOptions _options;
    internal int _captop;
    internal RegexTree(RegexNode root, Hashtable caps, Int32[] capnumlist, int captop, Hashtable capnames, String[] capslist, RegexOptions opts);
}
internal class System.Text.RegularExpressions.RegexTypeCompiler : RegexCompiler {
    internal RegexTypeCompiler(AssemblyName an, CustomAttributeBuilder[] attribs, string resourceFile);
    private static RegexTypeCompiler();
    internal Type FactoryTypeFromCode(RegexCode code, RegexOptions options, string typeprefix);
    internal void GenerateRegexType(string pattern, RegexOptions opts, string name, bool ispublic, RegexCode code, RegexTree tree, Type factory, TimeSpan matchTimeout);
    internal void GenerateCreateHashtable(FieldInfo field, Hashtable ht);
    internal void Save();
    internal void GenerateCreateInstance(Type newtype);
    internal void DefineType(string typename, bool ispublic, Type inheritfromclass);
    internal void DefineMethod(string methname, Type returntype);
    internal void BakeMethod();
    internal Type BakeType();
}
internal class System.Text.RegularExpressions.RegexWriter : object {
    internal Int32[] _intStack;
    internal int _depth;
    internal Int32[] _emitted;
    internal int _curpos;
    internal Dictionary`2<string, int> _stringhash;
    internal List`1<string> _stringtable;
    internal bool _counting;
    internal int _count;
    internal int _trackcount;
    internal Hashtable _caps;
    internal static int BeforeChild;
    internal static int AfterChild;
    internal static RegexCode Write(RegexTree t);
    internal void PushInt(int I);
    internal bool EmptyStack();
    internal int PopInt();
    internal int CurPos();
    internal void PatchJump(int Offset, int jumpDest);
    internal void Emit(int op);
    internal void Emit(int op, int opd1);
    internal void Emit(int op, int opd1, int opd2);
    internal int StringCode(string str);
    internal ArgumentException MakeException(string message);
    internal int MapCapnum(int capnum);
    internal RegexCode RegexCodeFromRegexTree(RegexTree tree);
    internal void EmitFragment(int nodetype, RegexNode node, int CurIndex);
}
internal class System.Text.RegularExpressions.SharedReference : object {
    internal object Get();
    internal void Cache(object obj);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Participant Count={ParticipantCount},Participants Remaining={ParticipantsRemaining}")]
public class System.Threading.Barrier : object {
    public int ParticipantsRemaining { get; }
    public int ParticipantCount { get; }
    public long CurrentPhaseNumber { get; internal set; }
    public Barrier(int participantCount);
    public Barrier(int participantCount, Action`1<Barrier> postPhaseAction);
    public int get_ParticipantsRemaining();
    public int get_ParticipantCount();
    public long get_CurrentPhaseNumber();
    internal void set_CurrentPhaseNumber(long value);
    public long AddParticipant();
    public long AddParticipants(int participantCount);
    public void RemoveParticipant();
    public void RemoveParticipants(int participantCount);
    public void SignalAndWait();
    public void SignalAndWait(CancellationToken cancellationToken);
    public bool SignalAndWait(TimeSpan timeout);
    public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool SignalAndWait(int millisecondsTimeout);
    public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class System.Threading.BarrierPostPhaseException : Exception {
    public BarrierPostPhaseException(Exception innerException);
    public BarrierPostPhaseException(string message);
    public BarrierPostPhaseException(string message, Exception innerException);
    [SecurityCriticalAttribute]
protected BarrierPostPhaseException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("False")]
public class System.Threading.Semaphore : WaitHandle {
    [SecuritySafeCriticalAttribute]
public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew, SemaphoreSecurity semaphoreSecurity);
    public static Semaphore OpenExisting(string name);
    public static Semaphore OpenExisting(string name, SemaphoreRights rights);
    public static bool TryOpenExisting(string name, Semaphore& result);
    public static bool TryOpenExisting(string name, SemaphoreRights rights, Semaphore& result);
    [ReliabilityContractAttribute("3", "2")]
[PrePrepareMethodAttribute]
public int Release();
    [ReliabilityContractAttribute("3", "2")]
public int Release(int releaseCount);
    public SemaphoreSecurity GetAccessControl();
    public void SetAccessControl(SemaphoreSecurity semaphoreSecurity);
}
public class System.Threading.ThreadExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public ThreadExceptionEventArgs(Exception t);
    public Exception get_Exception();
}
public class System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
    public ThreadExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ThreadExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.ThrowHelper : object {
    internal static void ThrowWrongKeyTypeArgumentException(object key, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
    internal static void ThrowKeyNotFoundException();
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    internal static string GetArgumentName(ExceptionArgument argument);
    internal static string GetResourceName(ExceptionResource resource);
}
public class System.Timers.ElapsedEventArgs : EventArgs {
    public DateTime SignalTime { get; }
    internal ElapsedEventArgs(int low, int high);
    public DateTime get_SignalTime();
}
public class System.Timers.ElapsedEventHandler : MulticastDelegate {
    public ElapsedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ElapsedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ElapsedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultPropertyAttribute("Interval")]
[DefaultEventAttribute("Elapsed")]
public class System.Timers.Timer : Component {
    [CategoryAttribute("Behavior")]
[TimersDescriptionAttribute("TimerAutoReset")]
[DefaultValueAttribute("True")]
public bool AutoReset { get; public set; }
    [CategoryAttribute("Behavior")]
[TimersDescriptionAttribute("TimerEnabled")]
[DefaultValueAttribute("False")]
public bool Enabled { get; public set; }
    [CategoryAttribute("Behavior")]
[TimersDescriptionAttribute("TimerInterval")]
[DefaultValueAttribute("100")]
[SettingsBindableAttribute("True")]
public double Interval { get; public set; }
    public ISite Site { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[TimersDescriptionAttribute("TimerSynchronizingObject")]
public ISynchronizeInvoke SynchronizingObject { get; public set; }
    public Timer(double interval);
    public bool get_AutoReset();
    public void set_AutoReset(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public double get_Interval();
    public void set_Interval(double value);
    public void add_Elapsed(ElapsedEventHandler value);
    public void remove_Elapsed(ElapsedEventHandler value);
    public virtual void set_Site(ISite value);
    public virtual ISite get_Site();
    public ISynchronizeInvoke get_SynchronizingObject();
    public void set_SynchronizingObject(ISynchronizeInvoke value);
    public sealed virtual void BeginInit();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void EndInit();
    public void Start();
    public void Stop();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetSystemTimeAsFileTime(FILE_TIME& lpSystemTimeAsFileTime);
}
[AttributeUsageAttribute("32767")]
public class System.Timers.TimersDescriptionAttribute : DescriptionAttribute {
    public string Description { get; }
    public TimersDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class System.UncNameHelper : object {
    internal static int MaximumInternetNameLength;
    internal static string ParseCanonicalName(string str, int start, int end, Boolean& loopback);
    internal static bool IsValid(Char* name, ushort start, Int32& returnedEnd, bool notImplicitFile);
}
[FlagsAttribute]
internal enum System.UnescapeMode : Enum {
    public int value__;
    public static UnescapeMode CopyOnly;
    public static UnescapeMode Escape;
    public static UnescapeMode Unescape;
    public static UnescapeMode EscapeUnescape;
    public static UnescapeMode V1ToStringFlag;
    public static UnescapeMode UnescapeAll;
    public static UnescapeMode UnescapeAllOrThrow;
}
[TypeConverterAttribute("System.UriTypeConverter")]
public class System.Uri : object {
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    internal static string UriSchemeWs;
    internal static string UriSchemeWss;
    public static string UriSchemeMailto;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    public static string UriSchemeNetTcp;
    public static string UriSchemeNetPipe;
    public static string SchemeDelimiter;
    internal static int c_MaxUriBufferSize;
    internal static char c_DummyChar;
    internal static char c_EOL;
    internal static Char[] HexLowerChars;
    internal bool UserDrivenParsing { get; }
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string LocalPath { get; }
    public string Authority { get; }
    public UriHostNameType HostNameType { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public string PathAndQuery { get; }
    public String[] Segments { get; }
    public bool IsUnc { get; }
    public string Host { get; }
    public int Port { get; }
    public string Query { get; }
    public string Fragment { get; }
    public string Scheme { get; }
    public string OriginalString { get; }
    public string DnsSafeHost { get; }
    public string IdnHost { get; }
    public bool IsAbsoluteUri { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    internal bool HasAuthority { get; }
    public Uri(string uriString);
    [ObsoleteAttribute("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(string uriString, bool dontEscape);
    [ObsoleteAttribute("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    public Uri(string uriString, UriKind uriKind);
    public Uri(Uri baseUri, string relativeUri);
    public Uri(Uri baseUri, Uri relativeUri);
    protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static Uri();
    internal static bool IriParsingStatic(UriParser syntax);
    internal bool get_UserDrivenParsing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_LocalPath();
    public string get_Authority();
    public UriHostNameType get_HostNameType();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public string get_PathAndQuery();
    public String[] get_Segments();
    public bool get_IsUnc();
    public string get_Host();
    public int get_Port();
    public string get_Query();
    public string get_Fragment();
    public string get_Scheme();
    public string get_OriginalString();
    public string get_DnsSafeHost();
    public string get_IdnHost();
    public bool get_IsAbsoluteUri();
    public bool get_UserEscaped();
    public string get_UserInfo();
    public static UriHostNameType CheckHostName(string name);
    public string GetLeftPart(UriPartial part);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    public static bool IsHexEncoding(string pattern, int index);
    internal static bool IsGenDelim(char ch);
    public static bool CheckSchemeName(string schemeName);
    public static bool IsHexDigit(char character);
    public static int FromHex(char digit);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Uri uri1, Uri uri2);
    public static bool op_Inequality(Uri uri1, Uri uri2);
    public virtual bool Equals(object comparand);
    public Uri MakeRelativeUri(Uri uri);
    internal static string InternalEscapeString(string rawString);
    internal UriFormatException ParseMinimal();
    internal string GetParts(UriComponents uriParts, UriFormat formatAs);
    internal static int CalculateCaseInsensitiveHashCode(string text);
    internal bool get_HasAuthority();
    internal static bool IsAsciiLetterOrDigit(char character);
    internal static bool IsBidiControlCharacter(char ch);
    internal static string StripBidiControlCharacter(Char* strToClean, int start, int length);
    [ObsoleteAttribute("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")]
public string MakeRelative(Uri toUri);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Parse();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Canonicalize();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Escape();
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual string Unescape(string path);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static string EscapeString(string str);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void CheckSecurity();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsReservedCharacter(char character);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static bool IsExcludedCharacter(char character);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsBadFileSystemCharacter(char character);
    public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    public string GetComponents(UriComponents components, UriFormat format);
    public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    public bool IsWellFormedOriginalString();
    public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    internal bool InternalIsWellFormedOriginalString();
    public static string UnescapeDataString(string stringToUnescape);
    public static string EscapeUriString(string stringToEscape);
    public static string EscapeDataString(string stringToEscape);
    internal string EscapeUnescapeIri(string input, int start, int end, UriComponents component);
    internal static Uri CreateHelper(string uriString, bool dontEscape, UriKind uriKind, UriFormatException& e);
    internal static Uri ResolveHelper(Uri baseUri, Uri relativeUri, String& newUriString, Boolean& userEscaped, UriFormatException& e);
    internal string GetComponentsHelper(UriComponents uriComponents, UriFormat uriFormat);
    public bool IsBaseOf(Uri uri);
    internal bool IsBaseOfHelper(Uri uriLink);
}
public class System.UriBuilder : object {
    public string Fragment { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Path { get; public set; }
    public int Port { get; public set; }
    public string Query { get; public set; }
    public string Scheme { get; public set; }
    public Uri Uri { get; }
    public string UserName { get; public set; }
    public UriBuilder(string uri);
    public UriBuilder(Uri uri);
    public UriBuilder(string schemeName, string hostName);
    public UriBuilder(string scheme, string host, int portNumber);
    public UriBuilder(string scheme, string host, int port, string pathValue);
    public UriBuilder(string scheme, string host, int port, string path, string extraValue);
    public string get_Fragment();
    public void set_Fragment(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Path();
    public void set_Path(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_Query();
    public void set_Query(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public Uri get_Uri();
    public string get_UserName();
    public void set_UserName(string value);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents Scheme;
    public static UriComponents UserInfo;
    public static UriComponents Host;
    public static UriComponents Port;
    public static UriComponents Path;
    public static UriComponents Query;
    public static UriComponents Fragment;
    public static UriComponents StrongPort;
    public static UriComponents NormalizedHost;
    public static UriComponents KeepDelimiter;
    public static UriComponents SerializationInfoString;
    public static UriComponents AbsoluteUri;
    public static UriComponents HostAndPort;
    public static UriComponents StrongAuthority;
    public static UriComponents SchemeAndServer;
    public static UriComponents HttpRequestUrl;
    public static UriComponents PathAndQuery;
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat UriEscaped;
    public static UriFormat Unescaped;
    public static UriFormat SafeUnescaped;
}
public class System.UriFormatException : FormatException {
    public UriFormatException(string textString);
    public UriFormatException(string textString, Exception e);
    protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.UriHelper : object {
    internal static string RFC3986ReservedMarks;
    private static UriHelper();
    internal static bool TestForSubPath(Char* pMe, ushort meLength, Char* pShe, ushort sheLength, bool ignoreCase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    internal static Char[] UnescapeString(string input, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
    internal static Char[] UnescapeString(Char* pStr, int start, int end, Char[] dest, Int32& destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
    internal static void MatchUTF8Sequence(Char* pDest, Char[] dest, Int32& destOffset, Char[] unescapedChars, int charCount, Byte[] bytes, int byteCount, bool isQuery, bool iriParsing);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    internal static char EscapedAscii(char digit, char next);
    internal static bool IsNotSafeForUnescape(char ch);
    internal static bool IsUnreserved(char c);
    internal static bool Is3986Unreserved(char c);
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Unknown;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
}
public enum System.UriIdnScope : Enum {
    public int value__;
    public static UriIdnScope None;
    public static UriIdnScope AllExceptIntranet;
    public static UriIdnScope All;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind RelativeOrAbsolute;
    public static UriKind Absolute;
    public static UriKind Relative;
}
public abstract class System.UriParser : object {
    internal static int NoDefaultPort;
    internal static UriParser HttpUri;
    internal static UriParser HttpsUri;
    internal static UriParser WsUri;
    internal static UriParser WssUri;
    internal static UriParser FtpUri;
    internal static UriParser FileUri;
    internal static UriParser GopherUri;
    internal static UriParser NntpUri;
    internal static UriParser NewsUri;
    internal static UriParser MailToUri;
    internal static UriParser UuidUri;
    internal static UriParser TelnetUri;
    internal static UriParser LdapUri;
    internal static UriParser NetTcpUri;
    internal static UriParser NetPipeUri;
    internal static UriParser VsMacrosUri;
    internal string SchemeName { get; }
    internal int DefaultPort { get; }
    internal static bool ShouldUseLegacyV2Quirks { get; }
    internal static bool DontEnableStrictRFC3986ReservedCharacterSets { get; }
    internal static bool DontKeepUnicodeBidiFormattingCharacters { get; }
    internal UriSyntaxFlags Flags { get; }
    internal bool IsSimple { get; }
    private static UriParser();
    internal UriParser(UriSyntaxFlags flags);
    internal string get_SchemeName();
    internal int get_DefaultPort();
    protected virtual UriParser OnNewUri();
    protected virtual void OnRegister(string schemeName, int defaultPort);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError);
    protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri);
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual bool IsWellFormedOriginalString(Uri uri);
    public static void Register(UriParser uriParser, string schemeName, int defaultPort);
    public static bool IsKnownScheme(string schemeName);
    internal static bool get_ShouldUseLegacyV2Quirks();
    internal static bool get_DontEnableStrictRFC3986ReservedCharacterSets();
    internal static bool get_DontKeepUnicodeBidiFormattingCharacters();
    internal UriSyntaxFlags get_Flags();
    internal bool NotAny(UriSyntaxFlags flags);
    internal bool InFact(UriSyntaxFlags flags);
    internal bool IsAllSet(UriSyntaxFlags flags);
    internal static UriParser FindOrFetchAsUnknownV1Syntax(string lwrCaseScheme);
    internal static UriParser GetSyntax(string lwrCaseScheme);
    internal bool get_IsSimple();
    internal void CheckSetIsSimpleFlag();
    internal void SetUpdatableFlags(UriSyntaxFlags flags);
    internal UriParser InternalOnNewUri();
    internal void InternalValidate(Uri thisUri, UriFormatException& parsingError);
    internal string InternalResolve(Uri thisBaseUri, Uri uriLink, UriFormatException& parsingError);
    internal bool InternalIsBaseOf(Uri thisBaseUri, Uri uriLink);
    internal string InternalGetComponents(Uri thisUri, UriComponents uriComponents, UriFormat uriFormat);
    internal bool InternalIsWellFormedOriginalString(Uri thisUri);
}
public enum System.UriPartial : Enum {
    public int value__;
    public static UriPartial Scheme;
    public static UriPartial Authority;
    public static UriPartial Path;
    public static UriPartial Query;
}
[FlagsAttribute]
internal enum System.UriSyntaxFlags : Enum {
    public int value__;
    public static UriSyntaxFlags None;
    public static UriSyntaxFlags MustHaveAuthority;
    public static UriSyntaxFlags OptionalAuthority;
    public static UriSyntaxFlags MayHaveUserInfo;
    public static UriSyntaxFlags MayHavePort;
    public static UriSyntaxFlags MayHavePath;
    public static UriSyntaxFlags MayHaveQuery;
    public static UriSyntaxFlags MayHaveFragment;
    public static UriSyntaxFlags AllowEmptyHost;
    public static UriSyntaxFlags AllowUncHost;
    public static UriSyntaxFlags AllowDnsHost;
    public static UriSyntaxFlags AllowIPv4Host;
    public static UriSyntaxFlags AllowIPv6Host;
    public static UriSyntaxFlags AllowAnInternetHost;
    public static UriSyntaxFlags AllowAnyOtherHost;
    public static UriSyntaxFlags FileLikeUri;
    public static UriSyntaxFlags MailToLikeUri;
    public static UriSyntaxFlags V1_UnknownUri;
    public static UriSyntaxFlags SimpleUserSyntax;
    public static UriSyntaxFlags BuiltInSyntax;
    public static UriSyntaxFlags ParserSchemeOnly;
    public static UriSyntaxFlags AllowDOSPath;
    public static UriSyntaxFlags PathIsRooted;
    public static UriSyntaxFlags ConvertPathSlashes;
    public static UriSyntaxFlags CompressPath;
    public static UriSyntaxFlags CanonicalizeAsFilePath;
    public static UriSyntaxFlags UnEscapeDotsAndSlashes;
    public static UriSyntaxFlags AllowIdn;
    public static UriSyntaxFlags AllowIriParsing;
}
public class System.UriTypeConverter : TypeConverter {
    internal UriTypeConverter(UriKind uriKind);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public class System.Web.AspNetHostingPermission : CodeAccessPermission {
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermission(PermissionState state);
    public AspNetHostingPermission(AspNetHostingPermissionLevel level);
    internal static void VerifyAspNetHostingPermissionLevel(AspNetHostingPermissionLevel level, string arg);
    public AspNetHostingPermissionLevel get_Level();
    public void set_Level(AspNetHostingPermissionLevel value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("32767")]
public class System.Web.AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute {
    public AspNetHostingPermissionLevel Level { get; public set; }
    public AspNetHostingPermissionAttribute(SecurityAction action);
    public AspNetHostingPermissionLevel get_Level();
    public void set_Level(AspNetHostingPermissionLevel value);
    public virtual IPermission CreatePermission();
}
public enum System.Web.AspNetHostingPermissionLevel : Enum {
    public int value__;
    public static AspNetHostingPermissionLevel None;
    public static AspNetHostingPermissionLevel Minimal;
    public static AspNetHostingPermissionLevel Low;
    public static AspNetHostingPermissionLevel Medium;
    public static AspNetHostingPermissionLevel High;
    public static AspNetHostingPermissionLevel Unrestricted;
}
internal class System.Windows.Input.BuildInfo : object {
    public static string WCP_VERSION;
    public static string WCP_PUBLIC_KEY_TOKEN;
}
[TypeForwardedFromAttribute("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public interface System.Windows.Input.ICommand {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CanExecuteChanged(EventHandler value);
    public abstract virtual bool CanExecute(object parameter);
    public abstract virtual void Execute(object parameter);
}
[AttributeUsageAttribute("1244")]
[TypeForwardedFromAttribute("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
public class System.Windows.Markup.ValueSerializerAttribute : Attribute {
    public Type ValueSerializerType { get; }
    public string ValueSerializerTypeName { get; }
    public ValueSerializerAttribute(Type valueSerializerType);
    public ValueSerializerAttribute(string valueSerializerTypeName);
    public Type get_ValueSerializerType();
    public string get_ValueSerializerTypeName();
}
internal static class ThisAssembly : object {
    internal static string Title;
    internal static string Description;
    internal static string DefaultAlias;
    internal static string Copyright;
    internal static string Version;
    internal static string InformationalVersion;
    internal static string DailyBuildNumberStr;
    internal static string BuildRevisionStr;
    internal static int DailyBuildNumber;
}
