[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Frozen.FrozenDictionary : object {
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TValue> ToFrozenDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TSource> ToFrozenDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TElement> ToFrozenDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Collections.Frozen.FrozenDictionary`2 : object {
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public static FrozenDictionary`2<TKey, TValue> Empty { get; }
    [IsReadOnlyAttribute]
public TValue& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TKey> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Item { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TValue> Values { get; }
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public static FrozenDictionary`2<TKey, TValue> get_Empty();
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) get_Item(TKey key);
    public ImmutableArray`1<TKey> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public ImmutableArray`1<TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] destination, int destinationIndex);
    public void CopyTo(Span`1<KeyValuePair`2<TKey, TValue>> destination);
    public Enumerator<TKey, TValue> GetEnumerator();
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRef(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
[ExtensionAttribute]
public static class System.Collections.Frozen.FrozenSet : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static FrozenSet`1<T> ToFrozenSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Collections.Frozen.FrozenSet`1 : object {
    public IEqualityComparer`1<T> Comparer { get; }
    public int Count { get; }
    public static FrozenSet`1<T> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public IEqualityComparer`1<T> get_Comparer();
    public sealed virtual int get_Count();
    public static FrozenSet`1<T> get_Empty();
    public ImmutableArray`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Contains(T item);
    public void CopyTo(Span`1<T> destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public Enumerator<T> GetEnumerator();
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryGetValue(T equalValue, T& actualValue);
}
[NullableContextAttribute("1")]
public interface System.Collections.Immutable.IImmutableDictionary`2 {
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Clear();
    public abstract virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public abstract virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableList", "Create")]
public interface System.Collections.Immutable.IImmutableList`1 {
    public abstract virtual IImmutableList`1<T> Add(T value);
    public abstract virtual IImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public abstract virtual IImmutableList`1<T> Clear();
    public abstract virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> Insert(int index, T element);
    public abstract virtual IImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public abstract virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public abstract virtual IImmutableList`1<T> RemoveAt(int index);
    public abstract virtual IImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveRange(int index, int count);
    public abstract virtual IImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> SetItem(int index, T value);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableQueue", "Create")]
public interface System.Collections.Immutable.IImmutableQueue`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableQueue`1<T> Clear();
    public abstract virtual IImmutableQueue`1<T> Dequeue();
    public abstract virtual IImmutableQueue`1<T> Enqueue(T value);
    public abstract virtual T Peek();
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableHashSet", "Create")]
public interface System.Collections.Immutable.IImmutableSet`1 {
    public abstract virtual IImmutableSet`1<T> Add(T value);
    public abstract virtual IImmutableSet`1<T> Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual IImmutableSet`1<T> Except(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Intersect(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Remove(T value);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public abstract virtual bool TryGetValue(T equalValue, T& actualValue);
    public abstract virtual IImmutableSet`1<T> Union(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableStack", "Create")]
public interface System.Collections.Immutable.IImmutableStack`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableStack`1<T> Clear();
    public abstract virtual T Peek();
    public abstract virtual IImmutableStack`1<T> Pop();
    public abstract virtual IImmutableStack`1<T> Push(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableArray : object {
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value, IComparer`1<T> comparer);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(int initialCapacity);
    public static ImmutableArray`1<T> CreateRange(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`3<TSource, TArg, TResult> selector, TArg arg);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`3<TSource, TArg, TResult> selector, TArg arg);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create();
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(ImmutableArray`1<T> items, int start, int length);
    public static ImmutableArray`1<T> Create(T item);
    public static ImmutableArray`1<T> Create(T item1, T item2);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3, T item4);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(T[] items);
    public static ImmutableArray`1<T> Create(T[] items, int start, int length);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(Span`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> ToImmutableArray(IEnumerable`1<TSource> items);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> ToImmutableArray(Builder<TSource> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(Span`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableArray", "Create")]
public class System.Collections.Immutable.ImmutableArray`1 : ValueType {
    private T[] array;
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<T> Empty;
    public bool IsDefault { get; }
    public bool IsDefaultOrEmpty { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public int Length { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    public bool get_IsEmpty();
    public T get_Item(int index);
    public int get_Length();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ImmutableArray`1<T> Add(T item);
    public ImmutableArray`1<T> AddRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> AddRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> AddRange(T[] items, int length);
    public ImmutableArray`1<T> AddRange(TDerived[] items);
    public ImmutableArray`1<T> AddRange(ImmutableArray`1<T> items, int length);
    [NullableContextAttribute("0")]
public ImmutableArray`1<T> AddRange(ImmutableArray`1<TDerived> items);
    public ImmutableArray`1<T> AddRange(ReadOnlySpan`1<T> items);
    public ImmutableArray`1<T> AddRange(T[] items);
    public ReadOnlyMemory`1<T> AsMemory();
    public ReadOnlySpan`1<T> AsSpan();
    public ReadOnlySpan`1<T> AsSpan(int start, int length);
    [NullableContextAttribute("0")]
public ImmutableArray`1<TOther> As();
    [NullableContextAttribute("0")]
public ImmutableArray`1<TOther> CastArray();
    [NullableContextAttribute("0")]
public static ImmutableArray`1<T> CastUp(ImmutableArray`1<TDerived> items);
    public ImmutableArray`1<T> Clear();
    public sealed virtual bool Contains(T item);
    public bool Contains(T item, IEqualityComparer`1<T> equalityComparer);
    public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length);
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(Span`1<T> destination);
    public sealed virtual bool Equals(ImmutableArray`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int startIndex);
    public int IndexOf(T item, int startIndex, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public sealed virtual int IndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Insert(int index, T item);
    public ImmutableArray`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public ImmutableArray`1<T> InsertRange(int index, ImmutableArray`1<T> items);
    public ImmutableArray`1<T> InsertRange(int index, T[] items);
    public ImmutableArray`1<T> InsertRange(int index, ReadOnlySpan`1<T> items);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int startIndex);
    public int LastIndexOf(T item, int startIndex, int count);
    public sealed virtual int LastIndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public IEnumerable`1<TResult> OfType();
    public static bool op_Equality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    public static bool op_Inequality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    public static bool op_Inequality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    public ImmutableArray`1<T> Remove(T item);
    public ImmutableArray`1<T> Remove(T item, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableArray`1<T> RemoveAt(int index);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(int index, int length);
    public ImmutableArray`1<T> RemoveRange(ReadOnlySpan`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(T[] items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> SetItem(int index, T item);
    public ImmutableArray`1<T> Slice(int start, int length);
    public ImmutableArray`1<T> Sort();
    public ImmutableArray`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableArray`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableArray`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public Builder<T> ToBuilder();
    public ReadOnlySpan`1<T> AsSpan(Range range);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableDictionary : object {
    [ExtensionAttribute]
public static bool Contains(IImmutableDictionary`2<TKey, TValue> map, TKey key, TValue value);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> Create();
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Immutable.ImmutableDictionary`2 : object {
    public static ImmutableDictionary`2<TKey, TValue> Empty;
    public int Count { get; }
    public bool IsEmpty { get; }
    public TValue Item { get; }
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public IEnumerable`1<TKey> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public IEnumerable`1<TValue> Values { get; }
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual TValue get_Item(TKey key);
    public IEqualityComparer`1<TKey> get_KeyComparer();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public ImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public Builder<TKey, TValue> ToBuilder();
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableHashSet : object {
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> Create();
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, ReadOnlySpan`1<T> items);
    public static ImmutableHashSet`1<T> Create(T item);
    public static ImmutableHashSet`1<T> Create(T[] items);
    public static ImmutableHashSet`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableHashSet", "Create")]
public class System.Collections.Immutable.ImmutableHashSet`1 : object {
    public static ImmutableHashSet`1<T> Empty;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEqualityComparer`1<T> KeyComparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public IEqualityComparer`1<T> get_KeyComparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public ImmutableHashSet`1<T> Add(T item);
    public ImmutableHashSet`1<T> Clear();
    public sealed virtual bool Contains(T item);
    public ImmutableHashSet`1<T> Except(IEnumerable`1<T> other);
    public Enumerator<T> GetEnumerator();
    public ImmutableHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> Remove(T item);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T item);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T item);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    public Builder<T> ToBuilder();
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableHashSet`1<T> Union(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Collections.Immutable.ImmutableInterlocked : object {
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static void Enqueue(ImmutableQueue`1& location, T value);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> InterlockedCompareExchange(ImmutableArray`1& location, ImmutableArray`1<T> value, ImmutableArray`1<T> comparand);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> InterlockedExchange(ImmutableArray`1& location, ImmutableArray`1<T> value);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableArray`1& location, ImmutableArray`1<T> value);
    public static void Push(ImmutableStack`1& location, T value);
    public static bool TryAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static bool TryDequeue(ImmutableQueue`1& location, T& value);
    public static bool TryPop(ImmutableStack`1& location, T& value);
    public static bool TryRemove(ImmutableDictionary`2& location, TKey key, TValue& value);
    public static bool TryUpdate(ImmutableDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool Update(T& location, Func`2<T, T> transformer);
    public static bool Update(T& location, Func`3<T, TArg, T> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableArray`1& location, Func`2<ImmutableArray`1<T>, ImmutableArray`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableArray`1& location, Func`3<ImmutableArray`1<T>, TArg, ImmutableArray`1<T>> transformer, TArg transformerArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableList : object {
    public static Builder<T> CreateBuilder();
    public static ImmutableList`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableList`1<T> Create();
    public static ImmutableList`1<T> Create(T item);
    public static ImmutableList`1<T> Create(T[] items);
    public static ImmutableList`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
    [ExtensionAttribute]
public static IImmutableList`1<T> RemoveRange(IImmutableList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IImmutableList`1<T> Remove(IImmutableList`1<T> list, T value);
    [ExtensionAttribute]
public static IImmutableList`1<T> Replace(IImmutableList`1<T> list, T oldValue, T newValue);
    [ExtensionAttribute]
public static ImmutableList`1<TSource> ToImmutableList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableList`1<TSource> ToImmutableList(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableList", "Create")]
public class System.Collections.Immutable.ImmutableList`1 : object {
    public static ImmutableList`1<T> Empty;
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual T get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ImmutableList`1<T> Add(T value);
    public ImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public ImmutableList`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public ImmutableList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    public ImmutableList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Insert(int index, T item);
    public ImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Remove(T value);
    public ImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableList`1<T> RemoveAt(int index);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveRange(int index, int count);
    public ImmutableList`1<T> Replace(T oldValue, T newValue);
    public ImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Reverse();
    public ImmutableList`1<T> Reverse(int index, int count);
    public ImmutableList`1<T> SetItem(int index, T value);
    public ImmutableList`1<T> Sort();
    public ImmutableList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T item);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    public Builder<T> ToBuilder();
    public bool TrueForAll(Predicate`1<T> match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableQueue : object {
    public static ImmutableQueue`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableQueue`1<T> Create();
    public static ImmutableQueue`1<T> Create(T item);
    public static ImmutableQueue`1<T> Create(T[] items);
    public static ImmutableQueue`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static IImmutableQueue`1<T> Dequeue(IImmutableQueue`1<T> queue, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableQueue", "Create")]
public class System.Collections.Immutable.ImmutableQueue`1 : object {
    public static ImmutableQueue`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public static ImmutableQueue`1<T> get_Empty();
    public sealed virtual bool get_IsEmpty();
    public ImmutableQueue`1<T> Clear();
    public ImmutableQueue`1<T> Dequeue();
    public ImmutableQueue`1<T> Dequeue(T& value);
    public ImmutableQueue`1<T> Enqueue(T value);
    public Enumerator<T> GetEnumerator();
    public sealed virtual T Peek();
    public T& modreq(System.Runtime.InteropServices.InAttribute) PeekRef();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Clear();
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Dequeue();
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Enqueue(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedDictionary : object {
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> Create();
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Immutable.ImmutableSortedDictionary`2 : object {
    public static ImmutableSortedDictionary`2<TKey, TValue> Empty;
    public int Count { get; }
    public bool IsEmpty { get; }
    public TValue Item { get; }
    public IComparer`1<TKey> KeyComparer { get; }
    public IEnumerable`1<TKey> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public IEnumerable`1<TValue> Values { get; }
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual TValue get_Item(TKey key);
    public IComparer`1<TKey> get_KeyComparer();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public ImmutableSortedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableSortedDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableSortedDictionary`2<TKey, TValue> Remove(TKey value);
    public ImmutableSortedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public Builder<TKey, TValue> ToBuilder();
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) ValueRef(TKey key);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedSet : object {
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IComparer`1<T> comparer);
    public static ImmutableSortedSet`1<T> CreateRange(IComparer`1<T> comparer, IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> Create();
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T item);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T[] items);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, ReadOnlySpan`1<T> items);
    public static ImmutableSortedSet`1<T> Create(T item);
    public static ImmutableSortedSet`1<T> Create(T[] items);
    public static ImmutableSortedSet`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableSortedSet", "Create")]
public class System.Collections.Immutable.ImmutableSortedSet`1 : object {
    public static ImmutableSortedSet`1<T> Empty;
    public int Count { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public IComparer`1<T> KeyComparer { get; }
    [NullableAttribute("2")]
public T Max { get; }
    [NullableAttribute("2")]
public T Min { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual T get_Item(int index);
    public IComparer`1<T> get_KeyComparer();
    [NullableContextAttribute("2")]
public T get_Max();
    [NullableContextAttribute("2")]
public T get_Min();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ImmutableSortedSet`1<T> Add(T value);
    public ImmutableSortedSet`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSortedSet`1<T> Except(IEnumerable`1<T> other);
    public Enumerator<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public ImmutableSortedSet`1<T> Intersect(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> Remove(T value);
    public IEnumerable`1<T> Reverse();
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    public Builder<T> ToBuilder();
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSortedSet`1<T> Union(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> WithComparer(IComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableStack : object {
    public static ImmutableStack`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableStack`1<T> Create();
    public static ImmutableStack`1<T> Create(T item);
    public static ImmutableStack`1<T> Create(T[] items);
    public static ImmutableStack`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static IImmutableStack`1<T> Pop(IImmutableStack`1<T> stack, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableStack", "Create")]
public class System.Collections.Immutable.ImmutableStack`1 : object {
    public static ImmutableStack`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public static ImmutableStack`1<T> get_Empty();
    public sealed virtual bool get_IsEmpty();
    public ImmutableStack`1<T> Clear();
    public Enumerator<T> GetEnumerator();
    public sealed virtual T Peek();
    public T& modreq(System.Runtime.InteropServices.InAttribute) PeekRef();
    public ImmutableStack`1<T> Pop();
    public ImmutableStack`1<T> Pop(T& value);
    public ImmutableStack`1<T> Push(T value);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Clear();
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Pop();
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Push(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.ImmutableArrayExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T Aggregate(ImmutableArray`1<T> immutableArray, Func`3<T, T, T> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static bool All(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T ElementAtOrDefault(ImmutableArray`1<T> immutableArray, int index);
    [ExtensionAttribute]
public static T ElementAt(ImmutableArray`1<T> immutableArray, int index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T First(Builder<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(ImmutableArray`1<TSource> immutableArray, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableArray`1<T> immutableArray, Func`2<T, TResult> selector);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, IEnumerable`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, Func`3<TBase, TBase, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T[] ToArray(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> Where(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.ImmutableCollectionsMarshal : object {
    public static ImmutableArray`1<T> AsImmutableArray(T[] array);
    public static T[] AsArray(ImmutableArray`1<T> array);
}
