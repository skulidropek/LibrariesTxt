internal static class FxResources.System.Private.Interop.SR : object {
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
[AttributeUsageAttribute("5148")]
public class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string assemblyIdentity);
}
[FlagsAttribute]
public enum Internal.Reflection.MetadataTransformation : Enum {
    public int value__;
    public static MetadataTransformation None;
    public static MetadataTransformation OriginallyNotSealed;
    public static MetadataTransformation OriginallyVirtual;
    public static MetadataTransformation OriginallySealed;
    public static MetadataTransformation OriginallyNewSlot;
    public static MetadataTransformation OriginallyAccessCheckedOnOverride;
    public static MetadataTransformation OriginallyForeignObject;
    public static MetadataTransformation OriginallyComObject;
}
[DependencyReductionRootAttribute]
[AttributeUsageAttribute("5212")]
public class Internal.Reflection.MetadataTransformedAttribute : Attribute {
    public MetadataTransformedAttribute(MetadataTransformation transformation);
}
public static class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
public class Internal.Runtime.CompilerServices.FixupRuntimeTypeHandle : ValueType {
    private RuntimeTypeHandle _handle;
    public RuntimeTypeHandle RuntimeTypeHandle { get; }
    public FixupRuntimeTypeHandle(RuntimeTypeHandle runtimeTypeHandle);
    public RuntimeTypeHandle get_RuntimeTypeHandle();
}
internal static class Interop : object {
    internal static string CORE_SYNCH_L2;
}
[CLSCompliantAttribute("False")]
public abstract class System.__ComGenericInterfaceDispatcher : object {
    public __ComObject m_comObject;
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public class System.__ComObject : object {
    [DebuggerBrowsableAttribute("0")]
private ContextBoundInterfacePointer m_baseIUnknown;
    [DebuggerBrowsableAttribute("0")]
private int m_refCount;
    [DebuggerBrowsableAttribute("0")]
private ComObjectFlags m_flags;
    [DebuggerBrowsableAttribute("0")]
private ComCallableObject m_outer;
    [DebuggerBrowsableAttribute("0")]
private IntPtr m_savedIUnknownVtbl;
    [DebuggerBrowsableAttribute("0")]
internal SimpleComInterfaceCacheItem[] m_cachedInterfaces;
    internal static int FIXED_CACHE_SIZE;
    [DebuggerBrowsableAttribute("0")]
private AdditionalComInterfaceCacheContext[] m_additionalCachedInterfaces_dontAccessDirectly;
    [DebuggerBrowsableAttribute("0")]
private static AdditionalComInterfaceCacheContext[] CacheLocked;
    [DebuggerBrowsableAttribute("0")]
private RCWFinalizer m_finalizer;
    [DebuggerBrowsableAttribute("0")]
internal IntPtr BaseIUnknown_UnsafeNoAddRef { get; }
    [DebuggerBrowsableAttribute("0")]
internal IntPtr SavedIUnknownVtbl { get; }
    [DebuggerBrowsableAttribute("0")]
public UInt32 AllocationId { get; }
    [DebuggerBrowsableAttribute("0")]
internal ComCallableObject Outer { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
private ComMarshalingType MarshalingType { get; }
    [DebuggerBrowsableAttribute("0")]
private bool IsGCPressureSet { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsJupiterObject { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool ExtendsComObject { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsAggregated { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsFreeThreaded { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsDuplicate { get; }
    [DebuggerBrowsableAttribute("0")]
internal ContextCookie ContextCookie { get; }
    [DebuggerBrowsableAttribute("0")]
internal ComObjectFlags Flags { get; }
    private static __ComObject();
    internal __ComObject(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    internal IntPtr get_BaseIUnknown_UnsafeNoAddRef();
    internal IntPtr get_SavedIUnknownVtbl();
    public UInt32 get_AllocationId();
    internal ComCallableObject get_Outer();
    internal void set_Outer(ComCallableObject value);
    private AdditionalComInterfaceCacheContext[] AcquireAdditionalCacheExclusive();
    private void ReleaseAdditionalCacheExclusive(AdditionalComInterfaceCacheContext[] contexts);
    private AdditionalComInterfaceCacheContext[] AcquireAdditionalCacheForRead();
    private bool AddToAdditionalCache(ContextCookie contextCookie, RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter, bool checkDup);
    internal static int AttachingCtor(__ComObject comObject, IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    private void __AttachingCtor(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    private void AddGCMemoryPressure(GCPressureRange gcMemoryPressureRange);
    private void UpdateComMarshalingType(ComMarshalingType marshallingType);
    private ComMarshalingType get_MarshalingType();
    private bool get_IsGCPressureSet();
    private void __InitToDefaultState();
    private IntPtr GetVtbl(IntPtr pUnk);
    private void __Attach(IntPtr pBaseIUnknown);
    private void __Attach(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    [CLSCompliantAttribute("False")]
public void __AttachAndRelease(IntPtr pBaseIUnknown);
    [GCCallbackAttribute]
internal bool get_IsJupiterObject();
    internal bool get_ExtendsComObject();
    internal void set_ExtendsComObject(bool value);
    internal bool get_IsAggregated();
    [GCCallbackAttribute]
internal __com_IJupiterObject* GetIJupiterObject_NoAddRef();
    internal int AddRef();
    internal int Release();
    internal void FinalReleaseSelf();
    internal int PeekRefCount();
    internal void Cleanup(bool disposing);
    internal void RemoveInterfacesForContext(ContextCookie currentContext);
    internal bool get_IsFreeThreaded();
    internal bool get_IsDuplicate();
    internal ContextCookie get_ContextCookie();
    internal ComObjectFlags get_Flags();
    private int QueryInterface_NoAddRef(RuntimeTypeHandle interfaceType, bool cacheOnly, IntPtr& pComPtr);
    internal IntPtr QueryInterface_NoAddRef_Internal(RuntimeTypeHandle interfaceType, bool cacheOnly, bool throwOnQueryInterfaceFailure);
    private int QueryInterface_NoAddRef_SlowNoCacheLookup(RuntimeTypeHandle interfaceType, ContextCookie currentCookie, IntPtr& pComPtr);
    private int QueryInterface_NoAddRef_Slow(RuntimeTypeHandle interfaceType, ContextCookie& currentCookie, bool cacheOnly, IntPtr& pComPtr);
    private int QueryInterfaceAndInsertToCache_NoAddRef(IntPtr pIUnknown, RuntimeTypeHandle interfaceType, ContextCookie currentCookie, IntPtr& pComPtr);
    internal RuntimeTypeHandle FindCastableGenericInterfaceInCache(RuntimeTypeHandle interfaceType, IntPtr& pComPtr);
    private InvalidCastException CreateInvalidCastExceptionForFailedQI(RuntimeTypeHandle interfaceType, int hr);
    internal void InsertIntoCache(RuntimeTypeHandle interfaceType, ContextCookie cookie, IntPtr& pComPtr, bool checkDup);
    private bool TryGetInterfacePointerFromAdditionalCache_NoAddRef(RuntimeTypeHandle interfaceType, IntPtr& pComPtr, ContextCookie currentCookie);
    private sealed virtual override bool System.Runtime.CompilerServices.ICastable.IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    private sealed virtual override RuntimeTypeHandle System.Runtime.CompilerServices.ICastable.GetImplType(RuntimeTypeHandle interfaceType);
    internal object GetDynamicAdapter(RuntimeTypeHandle requestedType, RuntimeTypeHandle targetType);
    private bool TryQITypeForICollection(RuntimeTypeHandle firstTypeHandle, RuntimeTypeHandle secondaryTypeHandle, RuntimeTypeHandle& resolvedTypeHandle);
    private object GetDynamicAdapterUsingQICache(RuntimeTypeHandle requestedType, AdditionalComInterfaceCacheContext[] cacheContext);
    private object GetDynamicAdapterUsingVariance(RuntimeTypeHandle requestedType, AdditionalComInterfaceCacheContext[] cacheContext);
    private object GetDynamicAdapterInternal(RuntimeTypeHandle requestedType, RuntimeTypeHandle targetType);
    private object FindDynamicAdapterForInterface(RuntimeTypeHandle requestedType, RuntimeTypeHandle existingType);
    public virtual string ToString();
}
internal static class System.__HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.Internal.Dictionary`2 : DictionaryBase {
    private TKey[] keyArray;
    private TValue[] valueArray;
    private IEqualityComparer`1<TKey> comparer;
    private Lock m_lock;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public TValue Item { get; public set; }
    public Dictionary`2(bool sync);
    public Dictionary`2(int capacity);
    public Dictionary`2(int capacity, bool sync);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer, bool sync);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer, bool sync);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public void LockAcquire();
    public void LockRelease();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public Enumerator<TKey, TValue> GetEnumerator();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public void Add(TKey key, TValue value);
    public void Add(TKey key, TValue value, int hashCode);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [GCCallbackAttribute]
public int GetMaxCount();
    public bool GetKey(int index, TKey& key);
    [GCCallbackAttribute]
public bool GetValue(int index, TValue& value);
    private int FindEntry(TKey key);
    private int FindEntry(TKey key, int hashCode);
    public int FindFirstKey(TKey& key);
    public int FindNextKey(TKey& key, int entry);
    private void Initialize(int capacity);
    private bool Insert(TKey key, TValue value, bool add);
    private bool Insert(TKey key, TValue value, bool add, int hashCode);
    private void Resize();
    private void Resize(int newSize);
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryGetValue(TKey key, int hashCode, TValue& value);
    public bool TryGetKey(TKey& key);
}
internal class System.Collections.Generic.Internal.DictionaryBase : object {
    protected int count;
    protected int version;
    protected int freeList;
    protected int freeCount;
    protected Entry[] entries;
    public int Count { get; }
    public int get_Count();
    protected int InitializeBase(int capacity);
    protected void ClearBase();
    protected Entry[] ResizeBase1(int newSize);
    protected void ResizeBase2(Entry[] newEntries, int newSize);
    protected int ModLength(int hashCode);
    protected int FindFirstEntry(int hashCode);
    protected int FindNextEntry(int entry);
}
internal class System.Collections.Generic.Internal.HashHelpers : object {
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
internal class System.Collections.Generic.Internal.HashSet`1 : DictionaryBase {
    private static int MinimalSize;
    private TKey[] keyArray;
    private Lock m_lock;
    public KeyCollection<TKey> Keys { get; }
    public HashSet`1(int capacity);
    public HashSet`1(int capacity, bool sync);
    public void LockAcquire();
    public void LockRelease();
    public void Clear();
    public bool ContainsKey(TKey key, int hashCode);
    private int FindEntry(TKey key, int hashCode);
    public int FindFirstKey(TKey& key, int hashCode);
    public int FindNextKey(TKey& key, int entry);
    [GCCallbackAttribute]
internal bool GetNext(TKey& key, Int32& index);
    private void Initialize(int capacity);
    public KeyCollection<TKey> get_Keys();
    public bool Add(TKey key, int hashCode);
    private void Resize();
    private void Resize(int newSize);
    public bool Remove(TKey key, int hashCode);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.Internal.List`1 : object {
    private T[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public int IndexOf(T item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public void Insert(int index, T item);
    public bool Remove(T item);
    public void RemoveAt(int index);
    public T[] ToArray();
    public void TrimExcess();
}
internal class System.Collections.Generic.Internal.SR : object {
    internal static string ArgumentOutOfRange_NeedNonNegNum;
    internal static string Arg_WrongType;
    internal static string Arg_ArrayPlusOffTooSmall;
    internal static string Arg_RankMultiDimNotSupported;
    internal static string Arg_NonZeroLowerBound;
    internal static string Argument_InvalidArrayType;
    internal static string Argument_AddingDuplicate;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string NotSupported_KeyCollectionSet;
    internal static string NotSupported_ValueCollectionSet;
    internal static string ArgumentOutOfRange_SmallCapacity;
    internal static string Argument_InvalidOffLen;
    private static SR();
}
public static class System.Diagnostics.DebugAnnotations : object {
    public static void PreviousCallContainsDebuggerStepInCode();
}
internal class System.RCWFinalizer : object {
    private __ComObject m_comObject;
    internal RCWFinalizer(__ComObject comObject);
    protected virtual override void Finalize();
}
public abstract class System.Reflection.DispatchProxy : object {
    protected abstract virtual object Invoke(MethodInfo targetMethod, Object[] args);
    public static T Create();
}
public class System.Reflection.DispatchProxyEntry : ValueType {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <ProxyClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <ImplementationClassType>k__BackingField;
    public RuntimeTypeHandle ProxyClassType { get; public set; }
    public RuntimeTypeHandle InterfaceType { get; public set; }
    public RuntimeTypeHandle ImplementationClassType { get; public set; }
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_ProxyClassType();
    [CompilerGeneratedAttribute]
public void set_ProxyClassType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_InterfaceType();
    [CompilerGeneratedAttribute]
public void set_InterfaceType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_ImplementationClassType();
    [CompilerGeneratedAttribute]
public void set_ImplementationClassType(RuntimeTypeHandle value);
}
public static class System.Reflection.DispatchProxyHelpers : object {
    private static DispatchProxyEntry[] s_entryTable;
    public static void RegisterImplementations(DispatchProxyEntry[] entryTable);
    public static RuntimeTypeHandle GetConcreteProxyType(RuntimeTypeHandle proxyClassTypeHandle, RuntimeTypeHandle interfaceTypeHandle);
    public static RuntimeMethodHandle GetCorrespondingInterfaceMethodFromMethodImpl();
}
public class System.Reflection.DispatchProxyInstanceNotFoundException : Exception {
    public DispatchProxyInstanceNotFoundException(string message);
    public DispatchProxyInstanceNotFoundException(string message, Exception inner);
}
public class System.Reflection.MissingMetadataException : TypeAccessException {
    public MissingMetadataException(string message);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.DependencyReductionConditionallyDependentAttribute : Attribute {
    public DependencyReductionConditionallyDependentAttribute(Type dependencyType);
}
[AttributeUsageAttribute("1132")]
public class System.Runtime.CompilerServices.DependencyReductionRootAttribute : Attribute {
}
[DependencyReductionRootAttribute]
public class System.Runtime.CompilerServices.DependencyReductionTypeRemoved : object {
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.EagerStaticClassConstructionAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
    private string _assemblyName;
    public string AssemblyName { get; }
    public IgnoresAccessChecksToAttribute(string assemblyName);
    public string get_AssemblyName();
}
public static class System.Runtime.CompilerServices.McgResource : object {
    public static string GetResourceString(string resourceKey, string defaultString);
}
public class System.Runtime.CompilerServices.MissingInteropDataException : Exception {
    [CompilerGeneratedAttribute]
private Type <MissingType>k__BackingField;
    public Type MissingType { get; private set; }
    public MissingInteropDataException(string resourceFormat, Type pertainantType);
    [CompilerGeneratedAttribute]
public Type get_MissingType();
    [CompilerGeneratedAttribute]
private void set_MissingType(Type value);
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.ModuleConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.PreInitializedAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.UnmanagedValueTypeConstraintAttribute : Attribute {
}
internal class System.Runtime.InteropServices.__com_ICCW : ValueType {
    internal __vtable_ICCW* pVtable;
}
internal class System.Runtime.InteropServices.__com_ICLRServices : ValueType {
    public __vtable_ICLRServices* pVtable;
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__com_IDispatch : ValueType {
    internal __vtable_IDispatch* pVtable;
}
internal class System.Runtime.InteropServices.__com_IFindDependentWrappers : ValueType {
    internal __vtable_IFindDependentWrappers* pVtable;
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__com_IInspectable : ValueType {
    public __vtable_IInspectable* pVtable;
}
internal class System.Runtime.InteropServices.__com_IJupiterGCManager : ValueType {
    internal __vtable_IJupiterGCManager* pVTable;
}
internal class System.Runtime.InteropServices.__com_IJupiterObject : ValueType {
    public __vtable_IJupiterObject* pVtable;
}
internal class System.Runtime.InteropServices.__com_IManagedActivationFactory : ValueType {
    internal __vtable_IManagedActivationFactory* pVtable;
}
internal class System.Runtime.InteropServices.__com_IMarshal : ValueType {
    internal __vtable_IMarshal* pVtable;
}
internal class System.Runtime.InteropServices.__com_IStream : ValueType {
    internal __vtable_IStream* pVtable;
    public Byte* m_pMem;
    public int m_cbSize;
    public int m_cbCurrent;
    public int m_cRef;
    internal static IntPtr CreateMemStm(ulong lSize);
    internal static void DestroyMemStm(__com_IStream* pIStream);
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__com_IUnknown : ValueType {
    internal __vtable_IUnknown* pVtable;
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.__interface_ccw : ValueType {
    private Void* m_pVtable;
    private __native_ccw* m_pNativeCCW;
    private __interface_ccw* m_pNext;
    private RuntimeTypeHandle m_interfaceType;
    private static IntPtr s_cached_interface_ccw;
    internal __interface_ccw* Next { get; internal set; }
    internal ComCallableObject ComCallableObject { get; }
    internal __native_ccw* NativeCCW { get; }
    internal RuntimeTypeHandle InterfaceType { get; }
    internal static __interface_ccw* Allocate(ComCallableObject managedCCW, RuntimeTypeHandle typeHandle);
    internal static void Destroy(__interface_ccw* pInterfaceCCW);
    internal __interface_ccw* get_Next();
    internal void set_Next(__interface_ccw* value);
    internal ComCallableObject get_ComCallableObject();
    [GCCallbackAttribute]
internal __native_ccw* get_NativeCCW();
    internal RuntimeTypeHandle get_InterfaceType();
    internal static int DirectRelease(IntPtr __IntPtr__pComThis);
}
internal class System.Runtime.InteropServices.__native_ccw : ValueType {
    private long m_lRefCount;
    private GCHandle m_hCCW;
    private IntPtr m_pFirstInterfaceCCW;
    private int m_flags;
    private int m_hashCode;
    private static IntPtr s_cached_native_ccw;
    internal static long COM_REFCOUNT_MASK;
    internal static long JUPITER_REFCOUNT_MASK;
    internal static int JUPITER_REFCOUNT_SHIFT;
    internal static long JUPITER_REFCOUNT_INC;
    internal static long ALL_REFCOUNT_MASK;
    internal ComCallableObject ComCallableObject { get; }
    internal ComCallableObject ComCallableObjectUnsafe { get; }
    internal GCHandle CCWHandle { get; }
    internal bool IsAggregatingRCW { get; }
    internal bool IsCleanupPending { get; }
    private long CombinedRefCount { get; }
    internal int JupiterRefCount { get; }
    internal int COMRefCount { get; }
    internal bool IsNeutered { get; }
    internal bool IsPegged { get; internal set; }
    internal static __native_ccw* Allocate(ComCallableObject managedCCW, object targetObject);
    private IntPtr GetObjectID();
    private void Init(ComCallableObject ccw, object targetObject);
    internal void Cleanup();
    internal void Link(__interface_ccw* pInterfaceCCW);
    internal ComCallableObject get_ComCallableObject();
    internal void AccessNeuteredCCW_FailFast();
    internal ComCallableObject get_ComCallableObjectUnsafe();
    internal GCHandle get_CCWHandle();
    internal bool get_IsAggregatingRCW();
    internal bool get_IsCleanupPending();
    internal bool IsAlive();
    private bool IsAlive(long lRefCount);
    private long get_CombinedRefCount();
    private int JupiterRefCountFrom(long lRefCount);
    private int COMRefCountFrom(long lRefCount);
    internal int get_JupiterRefCount();
    internal int get_COMRefCount();
    internal int AddJupiterRef();
    internal int ReleaseJupiterRef();
    internal int AddCOMRef();
    internal bool TryAddCOMRefIfNotCleanupPending();
    internal int ReleaseCOMRef();
    internal bool get_IsNeutered();
    internal bool get_IsPegged();
    internal void set_IsPegged(bool value);
    private void SetFlag(ComCallableObjectFlags newFlag, bool isSet);
    private bool IsFlagSet(ComCallableObjectFlags flag);
    internal int GetFlags();
    internal int GetHashCodeForLookup();
}
internal class System.Runtime.InteropServices.__vtable_ICCW : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnAddRefFromJupiter;
    private IntPtr pfnReleaseFromJupiter;
    private IntPtr pfnPeg;
    private IntPtr pfnUnpeg;
    public static IntPtr pNativeVtable;
    private static __vtable_ICCW s_theCcwVtable;
    private static __vtable_ICCW();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_ICCW();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int QueryInterface__STUB(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int AddRef__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int Release__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int AddRefFromJupiter__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int ReleaseFromJupiter__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int Peg__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int Unpeg__STUB(IntPtr __IntPtr__pComThis);
}
internal class System.Runtime.InteropServices.__vtable_ICLRServices : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnGarbageCollect;
    internal IntPtr pfnFinalizerThreadWait;
    internal IntPtr pfnDisconnectRCWsInCurrentApartment;
    internal IntPtr pfnCreateManagedReference;
    internal IntPtr pfnAddMemoryPressure;
    internal IntPtr pfnRemoveMemoryPressure;
    private static __vtable_ICLRServices s_theCcwVtable;
    internal static __vtable_ICLRServices* GetVtable();
    private void InitVtable();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int AddRef__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int Release__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int QueryInterface__STUB(IntPtr IntPtr__pComThis, IntPtr IntPtr__pIID, IntPtr IntPtr__ppvObject);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int GarbageCollect__STUB(IntPtr pComThis, int flags);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int FinalizerThreadWait__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int DisconnectRCWsInCurrentApartment__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int CreateManagedReference__STUB(IntPtr pComThis, IntPtr __IntPtr__pUnknown, IntPtr __IntPtr__ppNewReference);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int AddMemoryPressure__STUB(IntPtr pComThis, ulong bytesAllocated);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int RemoveMemoryPressure__STUB(IntPtr pComThis, ulong bytesAllocated);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__vtable_IDispatch : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnGetTypeInfoCount;
    internal IntPtr pfnGetTypeInfo;
    internal IntPtr pfnGetIDsOfNames;
    internal IntPtr pfnInvoke;
    public static IntPtr pNativeVtable;
    private static __vtable_IDispatch s_theCcwVtable;
    private static int E_NOTIMPL;
    private static __vtable_IDispatch();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IDispatch();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetTypeInfoCount(IntPtr pComThis, IntPtr pctinfo);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetTypeInfo(IntPtr pComThis, UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetIDsOfNames(IntPtr pComThis, IntPtr riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int Invoke(IntPtr pComThis, int dispIdMember, IntPtr riid, UInt32 lcid, ushort wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Runtime.InteropServices.__vtable_IFindDependentWrappers : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnOnFoundDependentWrapper;
    private static __vtable_IFindDependentWrappers s_theVtable;
    internal static __vtable_IFindDependentWrappers* GetVtable();
    private void InitVtable();
    [GCCallbackAttribute]
[NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int AddRef__STUB(IntPtr pComThis);
    [GCCallbackAttribute]
[NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int Release__STUB(IntPtr pComThis);
    [GCCallbackAttribute]
[NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int QueryInterface__STUB(IntPtr IntPtr__pComThis, IntPtr IntPtr__pIID, IntPtr IntPtr__ppvObject);
    [GCCallbackAttribute]
[NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int OnFoundDependentWrapper__STUB(IntPtr pComThis, IntPtr IntPtr__pCCW);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__vtable_IInspectable : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnGetIids;
    internal IntPtr pfnGetRuntimeClassName;
    internal IntPtr pfnGetTrustLevel;
    public static IntPtr pNativeVtable;
    private static __vtable_IInspectable s_theCcwVtable;
    private static int S_OK;
    private static int E_NOTIMPL;
    private static int BaseTrust;
    private static __vtable_IInspectable();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IInspectable();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetIIDs(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__iidCount, IntPtr __IntPtr__iids);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetRuntimeClassName(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__className);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int GetTrustLevel(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pTrustLevel);
}
internal class System.Runtime.InteropServices.__vtable_IJupiterGCManager : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnOnGCStarted;
    internal IntPtr pfnOnRCWWalkFinished;
    internal IntPtr pfnOnGCFinished;
    internal IntPtr pfnSetCLRServices;
}
internal class System.Runtime.InteropServices.__vtable_IJupiterObject : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnConnect;
    internal IntPtr pfnDisconnect;
    internal IntPtr pfnFindDependentWrappers;
    internal IntPtr pfnGetJupiterGCManager;
    internal IntPtr pfnAfterAddRef;
    internal IntPtr pfnBeforeRelease;
    internal IntPtr pfnPeg;
}
internal class System.Runtime.InteropServices.__vtable_IManagedActivationFactory : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnRunClassConstructor;
    public static IntPtr pNativeVtable;
    private static __vtable_IManagedActivationFactory s_theCcwVtable;
    private static __vtable_IManagedActivationFactory();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IManagedActivationFactory();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int RunClassConstructor(IntPtr pComThis);
}
internal class System.Runtime.InteropServices.__vtable_IMarshal : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetUnmarshalClass;
    private IntPtr pfnGetMarshalSizeMax;
    private IntPtr pfnMarshalInterface;
    private IntPtr pfnUnmarshalInterface;
    private IntPtr pfnReleaseMarshalData;
    private IntPtr pfnDisconnectObject;
    public static IntPtr pNativeVtable;
    private static __vtable_IMarshal s_theCcwVtable;
    private static __vtable_IMarshal();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IMarshal();
    private static int GetIMarshal(Void** ppIMarshal);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int GetUnmarshalClass(IntPtr pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pclsid);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int GetMarshalSizeMax(IntPtr pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pSize);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int MarshalInterface(IntPtr pComThis, IntPtr pStm, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int UnmarshalInterface(IntPtr pComThis, IntPtr pStm, IntPtr piid, IntPtr ppvObj);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int ReleaseMarshalData(IntPtr pComThis, IntPtr pStm);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int DisconnectObject(IntPtr pComThis, int dwReserved);
}
internal class System.Runtime.InteropServices.__vtable_IStream : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnRead;
    internal IntPtr pfnWrite;
    internal IntPtr pfnSeek;
    internal IntPtr pfnSetSize;
    internal IntPtr pfnCopyTo;
    internal IntPtr pfnCommit;
    internal IntPtr pfnRevert;
    internal IntPtr pfnLockRegion;
    internal IntPtr pfnUnlockRegion;
    internal IntPtr pfnStat;
    internal IntPtr pfnClone;
    public static IntPtr pNativeVtable;
    private static __vtable_IStream s_theCcwVtable;
    private static int STG_E_INVALIDPOINTER;
    private static __vtable_IStream();
    internal static IntPtr GetVtable();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int QueryInterface(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int AddRef(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Release(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int CopyTo(IntPtr pComThis, IntPtr pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Read(IntPtr pComThis, IntPtr pv, int cb, IntPtr pcb);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Write(IntPtr pComThis, IntPtr pv, int cb, IntPtr pcbWritten);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Seek(IntPtr pComThis, long dlibMove, int dwOrigin, IntPtr plib);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Stat(IntPtr pComThis, IntPtr pstatstg, int grfStatFlag);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Clone(IntPtr pComThis, IntPtr ppstm);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Commit(IntPtr pComThis, int grfCommitFlags);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int LockRegion(IntPtr pComThis, long libOffset, long cb, int dwLockType);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int Revert(IntPtr pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int SetSize(IntPtr pComThis, long libNewSize);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
internal static int UnlockRegion(IntPtr pComThis, long libOffset, long cb, int dwLockType);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.__vtable_IUnknown : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    public static IntPtr pNativeVtable;
    private static __vtable_IUnknown s_theCcwVtable;
    private static __vtable_IUnknown();
    internal static void Initialize();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IUnknown();
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int QueryInterface(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int AddRef(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
public static int Release(IntPtr __IntPtr__pComThis);
}
internal class System.Runtime.InteropServices.AdditionalComInterfaceCacheContext : object {
    internal ContextEntry context;
    internal WithInlineStorage<AdditionalComInterfaceCacheItem> items;
    internal AdditionalComInterfaceCacheContext(ContextCookie contextCookie);
    internal bool Add(RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter, bool checkDup);
}
internal class System.Runtime.InteropServices.AdditionalComInterfaceCacheItem : ValueType {
    internal RuntimeTypeHandle typeHandle;
    internal IntPtr ptr;
    internal object dynamicAdapter;
    internal AdditionalComInterfaceCacheItem(RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter);
}
public class System.Runtime.InteropServices.AddrOfAddRef : MulticastDelegate {
    public AddrOfAddRef(object object, IntPtr method);
    public virtual int Invoke(IntPtr pComThis);
    public virtual IAsyncResult BeginInvoke(IntPtr pComThis, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class System.Runtime.InteropServices.AddrOfGetCCWVtable : MulticastDelegate {
    public AddrOfGetCCWVtable(object object, IntPtr method);
    public virtual IntPtr Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.InteropServices.AddrOfIntrinsics : object {
    internal static IntPtr AddrOf(T ftn);
    internal static IntPtr StaticFieldAddr(T& field);
    internal static IntPtr VirtualAddrOf(object o, int methodIndex);
}
public class System.Runtime.InteropServices.AddrOfQueryInterface : MulticastDelegate {
    public AddrOfQueryInterface(object object, IntPtr method);
    public virtual int Invoke(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    public virtual IAsyncResult BeginInvoke(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class System.Runtime.InteropServices.AddrOfRelease : MulticastDelegate {
    public AddrOfRelease(object object, IntPtr method);
    public virtual int Invoke(IntPtr pComThis);
    public virtual IAsyncResult BeginInvoke(IntPtr pComThis, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public abstract class System.Runtime.InteropServices.BoxedKeyValuePair : object {
    public abstract virtual object Initialize(object val);
    public abstract virtual object GetTarget();
}
public class System.Runtime.InteropServices.BoxedValue : object {
    protected object m_data;
    protected short m_type;
    protected bool m_unboxed;
    public BoxedValue(object val, int type);
    public virtual void Initialize(object val, int type);
    public sealed virtual object GetTarget();
    public virtual string ToString();
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.InteropServices.CalliIntrinsics : object {
    private static MethodImplOptions InternalCall;
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__QueryInterface(IntPtr pfn, IntPtr pComThis, IntPtr arg0, IntPtr arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__AddRef(IntPtr pfn, IntPtr pComThis);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__Release(IntPtr pfn, IntPtr pComThis);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, UInt32 arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, Void* arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, int arg1, IntPtr arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, IntPtr arg1, UInt32 arg2, IntPtr arg3, UInt32 arg4, Void* arg5);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static int StdCall__int(IntPtr pfn, Void* pthis, HSTRING arg0, Void* arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static int StdCall__int(IntPtr pfn, Void* pthis, Void* arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static int StdCall__int(IntPtr pfn, IntPtr pthis, HSTRING arg0, IntPtr arg1, Void* arg2, Void* arg3);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static int StdCall__int(IntPtr pfn, IntPtr pthis, int arg0, IntPtr arg1, IntPtr arg2, int arg3, int arg4, IntPtr arg5, Void* arg6, Void* arg7);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, ulong arg0, UInt32 arg1, Void* arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr arg0, Void* arg1, Void* arg2, int arg3, IntPtr arg4);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, UInt32 arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* arg0, UInt32 arg1, Void* arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* arg0, Void* arg1, Void* arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* arg0, UInt32 arg1, Void* arg2, Void* arg3);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, int hr, Void* errorMsg, IntPtr pUnk);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, IntPtr& arg1, Int32& arg2, IntPtr& arg3, IntPtr& arg4);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, IntPtr& arg);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Guid arg1, IntPtr& arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pclsid);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm, IntPtr piid, IntPtr ppvObj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static int StdCall__int(IntPtr pfn, Void* pComThis, int dwReserved);
    internal static int StdCallCOOP(IntPtr pfn, Void* pComThis);
    internal static int StdCallCOOP(IntPtr pfn, Void* pComThis, Void* arg0);
    internal static int StdCallCOOP(IntPtr pfn, Void* pComThis, int arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static IntPtr Call__GetCcwVtable(IntPtr pfn);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, Void* arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, object arg0);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, object arg0, object arg1, int arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, object arg0, int arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, Void* arg0, Void* arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, Void* arg0, int arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, IntPtr arg0, UInt32 arg1, IntPtr arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, IntPtr arg0, UInt32 arg1, Void* arg2, IntPtr arg3);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, __ComObject arg0, IntPtr arg1);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static T Call(IntPtr pfn, __ComObject arg0, IntPtr arg1, RuntimeTypeHandle arg2);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal static Delegate Call__Delegate(IntPtr pfn, IntPtr pStub);
}
internal class System.Runtime.InteropServices.CCWCacheEntry : ValueType {
    internal RuntimeTypeHandle TypeHandle;
    internal IntPtr CCW;
    internal Guid InterfaceGuid;
    internal CCWCacheEntry(RuntimeTypeHandle typeHandle, IntPtr pCCW, Guid& guid);
}
internal class System.Runtime.InteropServices.CCWLookupMap : object {
    private static HashSet`1<EquatableIntPtr> s_ccwLookupMap;
    private static Lock s_ccwLookupMapLock;
    internal static void InitializeStatics();
    internal static ComCallableObject GetOrCreateCCW(object target, RuntimeTypeHandle typeHandle, IntPtr& interfaceCCW);
    internal static void Register(__native_ccw* pNativeCCW);
    internal static void RegisterLocked(__native_ccw* pNativeCCW);
    internal static void Unregister(__native_ccw* pNativeCCW);
    [GCCallbackAttribute]
internal static void LogCCWs();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.CCWTemplateData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public FixupRuntimeTypeHandle FixupBaseType;
    public int ParentCCWTemplateIndex;
    public int SupportedInterfaceListBeginIndex;
    public int NumberOfSupportedInterface;
    public bool IsWinRTType;
    public Guid Clsid;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle BaseType { get; }
    public RuntimeTypeHandle get_ClassType();
    public RuntimeTypeHandle get_BaseType();
}
[GuidAttribute("4ffdd514-7dec-47cf-a0ad-4971868d8455")]
public class System.Runtime.InteropServices.ClassFactory : object {
    private McgModule parent;
    private RuntimeTypeHandle classType;
    public ClassFactory(McgModule parent, RuntimeTypeHandle classType);
    public sealed virtual int CreateInstance(IntPtr pUnkOuter, Guid* riid, IntPtr* ppv);
    public sealed virtual int LockServer(int fLock);
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.ComCallableObject : object {
    private __native_ccw* m_pNativeCCW;
    private WithInlineStorage<CCWCacheEntry> m_CCWs;
    private __ComObject m_innerRCW;
    private object m_target;
    private bool m_supportsICustomQueryInterface;
    private bool m_hasCCWTemplateData;
    private RuntimeTypeHandle m_type;
    private static CCWWellKnownType[] CCWWellknownTypes;
    internal __native_ccw* NativeCCW { get; }
    [GCCallbackAttribute]
internal object TargetObject { get; }
    internal bool IsAggregatingRCW { get; }
    internal ComCallableObject(object target);
    internal ComCallableObject(object target, bool locked);
    internal ComCallableObject(object target, __ComObject innerRCW);
    private static ComCallableObject();
    internal static void InitRefCountedHandleCallback();
    [GCCallbackAttribute]
internal static bool IsAlive(ComCallableObject ccw);
    internal static bool TryGetCCW(IntPtr pComItf, ComCallableObject& ccw);
    [GCCallbackAttribute]
internal static ComCallableObject FromThisPointer(IntPtr pUnk);
    internal static object GetTarget(IntPtr pUnk);
    internal void Init(object target, __ComObject innerRCW, bool locked);
    internal __native_ccw* get_NativeCCW();
    internal int AddJupiterRef();
    internal int ReleaseJupiterRef();
    internal void Peg();
    internal void Unpeg();
    internal object get_TargetObject();
    internal IntPtr GetComInterfaceForIID(Guid& iid);
    internal IntPtr GetComInterfaceForIID(Guid& iid, RuntimeTypeHandle interfaceType);
    private IntPtr GetComInterfaceForIIDInternal(Guid& iid, RuntimeTypeHandle interfaceType);
    internal InterfaceCheckResult SupportsInterface(RuntimeTypeHandle ccwType, Guid& guid, RuntimeTypeHandle& interfaceType);
    internal IntPtr GetComInterfaceForType_NoCheck_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForTypeFromCache_NoCheck_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr AddFirstType_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForTypeFromCache_NoCheck(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForType_NoCheck(RuntimeTypeHandle typeHandle, Guid& guid);
    internal int AddRef();
    internal int Release();
    internal bool get_IsAggregatingRCW();
    private static bool IsWellKnownInterface(Guid& guid, object targetObject, RuntimeTypeHandle& interfaceType, Boolean& isCCWSupported);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.ComCallableObjectFlags : Enum {
    public int value__;
    public static ComCallableObjectFlags None;
    public static ComCallableObjectFlags IsPegged;
    public static ComCallableObjectFlags IsAggregatingRCW;
}
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComInterfaceDynamicAdapter : object {
    private __ComObject m_comObject;
    public __ComObject ComObject { get; }
    internal void Initialize(__ComObject comObject);
    public __ComObject get_ComObject();
}
internal enum System.Runtime.InteropServices.ComMarshalingType : Enum {
    public int value__;
    public static ComMarshalingType Unknown;
    public static ComMarshalingType Inhibit;
    public static ComMarshalingType Free;
    public static ComMarshalingType Standard;
}
internal static class System.Runtime.InteropServices.ComObjectCache : object {
    private static Lock s_lock;
    internal static Dictionary`2<IntPtr, IntPtr> s_comObjectMap;
    internal static bool Add(IntPtr pComItf, __ComObject o);
    internal static void Remove(IntPtr pComItf, __ComObject o);
    internal static __ComObject Lookup(IntPtr pComItf);
    internal static void RemoveRCWsForContext(ContextCookie contextCookie);
    internal static void InitializeStatics();
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.ComObjectFlags : Enum {
    public int value__;
    public static ComObjectFlags None;
    public static ComObjectFlags IsDuplicate;
    public static ComObjectFlags IsJupiterObject;
    public static ComObjectFlags ExtendsComObject;
    public static ComObjectFlags GCPressure_Set;
    public static ComObjectFlags GCPressureWinRT_Low;
    public static ComObjectFlags GCPressureWinRT_Medium;
    public static ComObjectFlags GCPressureWinRT_High;
    public static ComObjectFlags GCPressureWinRT_Mask;
    public static ComObjectFlags MarshalingBehavior_Inhibit;
    public static ComObjectFlags MarshalingBehavior_Free;
    public static ComObjectFlags MarshalingBehavior_Standard;
    public static ComObjectFlags MarshalingBehavior_Mask;
}
internal class System.Runtime.InteropServices.ContextBoundInterfacePointer : ValueType {
    private IntPtr m_pComPtr;
    private ContextEntry m_context;
    private IntPtr m_pCachedStream;
    private ComMarshalingType m_type;
    private static int StreamInUse;
    internal IntPtr ComPointer_UnsafeNoAddRef { get; }
    internal ContextCookie ContextCookie { get; }
    internal ContextEntry ContextEntry { get; }
    internal bool IsFreeThreaded { get; }
    internal bool IsInhibit { get; }
    internal bool IsStandard { get; }
    internal bool IsUnknown { get; }
    internal bool IsDisposed { get; }
    internal void Initialize(IntPtr pComPtr, ComMarshalingType type);
    internal IntPtr GetIUnknownForCurrContext(ContextCookie currentCookie);
    internal IntPtr get_ComPointer_UnsafeNoAddRef();
    internal ContextCookie get_ContextCookie();
    internal ContextEntry get_ContextEntry();
    private ComMarshalingType GetComMarshalingBehaviorAtRuntime();
    internal bool get_IsFreeThreaded();
    internal bool get_IsInhibit();
    internal bool get_IsStandard();
    internal bool get_IsUnknown();
    private IntPtr GetAddRefedComPointerForCurrentContext();
    private IntPtr MarshalComPointerToStream();
    private static IntPtr MarshalComPointerToStream_InDifferentContext(ContextEntry context, IntPtr pComPtr);
    private static IntPtr MarshalComPointerToStream_InCurrentContext(IntPtr pComPtr);
    private static bool MarshalInterThreadInterfaceInStream(Guid& iid, IntPtr pUnknown, IntPtr& pRetStream);
    internal bool get_IsDisposed();
    internal void Dispose(bool inCurrentContext);
}
internal class System.Runtime.InteropServices.ContextCookie : ValueType {
    internal IntPtr pCookie;
    internal static ContextCookie Default { get; }
    internal bool IsDefault { get; }
    internal bool IsCurrent { get; }
    internal static ContextCookie Current { get; }
    private ContextCookie(IntPtr _pCookie);
    internal static ContextCookie get_Default();
    internal bool get_IsDefault();
    internal bool Equals(ContextCookie cookie);
    internal bool get_IsCurrent();
    internal static ContextCookie get_Current();
}
internal class System.Runtime.InteropServices.ContextCookieComparer : object {
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Runtime.InteropServices.ContextCookie>.Equals(ContextCookie x, ContextCookie y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Runtime.InteropServices.ContextCookie>.GetHashCode(ContextCookie obj);
}
internal class System.Runtime.InteropServices.ContextEntry : object {
    private ContextCookie m_cookie;
    private IntPtr m_pObjectContext;
    private Lock m_delayedReleaseListLock;
    private List`1<IntPtr> m_delayedReleaseList;
    private List`1<IntPtr> m_delayedReleaseStreamList;
    internal ContextCookie ContextCookie { get; }
    internal bool IsCurrent { get; }
    private ContextEntry(ContextCookie cookie);
    internal ContextCookie get_ContextCookie();
    internal bool get_IsCurrent();
    protected virtual override void Finalize();
    internal static void RemoveCurrentContext();
    internal bool EnterContext(EnterContextCallback callback);
    [NativeCallableAttribute]
[NativeCallableInternalAttribute]
private static int EnterContextCallbackProc(IntPtr ptr);
    internal static ContextEntry GetCurrentContext(ContextCookie currentCookie);
    internal void EnqueueDelayedComRelease(IntPtr pComPtr);
    internal void EnqueueDelayedStreamRelease(IntPtr pStream);
    internal void PerformDelayedCleanup();
    private void PerformDelayedCleanupWorker();
}
public class System.Runtime.InteropServices.DECIMAL : ValueType {
    private ulong Hi64;
    private ulong Lo64;
    internal DECIMAL(decimal dec);
    internal decimal ToDecimal();
    public static decimal op_Implicit(DECIMAL dec);
    public static DECIMAL op_Implicit(decimal dec);
}
internal class System.Runtime.InteropServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public void SetPrimaryAndSecondary(object primary, object secondary);
    public void Free();
}
internal class System.Runtime.InteropServices.DependentHandleList : ValueType {
    private int m_freeIndex;
    private int m_capacity;
    private IntPtr* m_pHandles;
    private int m_shrinkHint;
    internal static int DefaultCapacity;
    internal static int ShrinkHintThreshold;
    [GCCallbackAttribute]
internal bool ResetHandles();
    [GCCallbackAttribute]
internal bool AllocateHandle(object primary, object secondary);
    [GCCallbackAttribute]
internal bool Grow();
    [GCCallbackAttribute]
internal bool Shrink();
}
internal class System.Runtime.InteropServices.EnumerableCustomPropertyProviderProxy : object {
    private IEnumerable m_target;
    internal EnumerableCustomPropertyProviderProxy(IEnumerable target);
    public sealed virtual object GetTarget();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Runtime.InteropServices.EqualityComparerForIntPtr : EqualityComparer`1<IntPtr> {
    public virtual bool Equals(IntPtr x, IntPtr y);
    public virtual int GetHashCode(IntPtr x);
}
internal class System.Runtime.InteropServices.EquatableIntPtr : ValueType {
    private Void* m_value;
    internal EquatableIntPtr(Void* p);
    internal Void* ToPointer();
    public sealed virtual bool Equals(EquatableIntPtr other);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.ExternalInterop : object {
    [McgGeneratedNativeCallCodeAttribute]
public static int WindowsCreateString(Char* sourceString, UInt32 length, Void* hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static void WindowsDeleteString(Void* hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static Char* WindowsGetStringRawBuffer(Void* hstring, UInt32* pLength);
    [McgGeneratedNativeCallCodeAttribute]
public static int RoActivateInstance(Void* hActivableClassId, Void*& ppv);
    [McgGeneratedNativeCallCodeAttribute]
public static int GetRestrictedErrorInfo(IntPtr& pRestrictedErrorInfo);
    [McgGeneratedNativeCallCodeAttribute]
public static int RoOriginateError(int hr, HSTRING hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static int SetRestrictedErrorInfo(IntPtr pRestrictedErrorInfo);
    [McgGeneratedNativeCallCodeAttribute]
internal static int RoOriginateLanguageException(int hr, HSTRING message, IntPtr pLanguageException);
    [McgGeneratedNativeCallCodeAttribute]
internal static int RoReportUnhandledError(IntPtr pRestrictedErrorInfo);
    internal static int RoParseTypeName(HSTRING typename, UInt32* typenamePartsLength, IntPtr** typenameParts);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoCreateFreeThreadedMarshaler(Void* pOuter, Void** ppunkMarshal);
    [McgGeneratedNativeCallCodeAttribute]
public static int CoGetContextToken(IntPtr* ppToken);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoGetObjectContext(Guid* iid, Void* ppv);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoGetMarshalSizeMax(UInt64* pulSize, Guid* iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoMarshalInterface(IntPtr pStream, Guid* iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoUnmarshalInterface(IntPtr pStream, Guid* iid, Void** ppv);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoReleaseMarshalData(IntPtr pStream);
    internal static int CoMarshalInterface(IntPtr pStream, Guid& iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    internal static int CoUnmarshalInterface(IntPtr pStream, Guid& iid, IntPtr& ppv);
    internal static int CoGetMarshalSizeMax(UInt64& pulSize, Guid& iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    public static int CoGetContextToken(IntPtr& ppToken);
    internal static int CoGetObjectContext(Guid& iid, IntPtr& ppv);
    public static IntPtr MemAlloc(UIntPtr sizeInBytes);
    public static void MemFree(IntPtr ptr);
    public static IntPtr MemReAlloc(IntPtr ptr, UIntPtr newSize);
    internal static IntPtr MemAllocWithZeroInitializeNoThrow(UIntPtr sizeInBytes);
    internal static IntPtr MemReAllocWithZeroInitializeNoThrow(IntPtr ptr, UIntPtr oldSize, UIntPtr newSize);
    public static void SafeCoTaskMemFree(Void* pv);
    public static IntPtr SysAllocStringLen(Char* pStrIn, UInt32 dwSize);
    public static void SysFreeString(Void* pBSTR);
    public static void SysFreeString(IntPtr pBSTR);
    internal static void VariantClear(IntPtr pObject);
    internal static int GetLastWin32Error();
    public static UInt32 SysStringLen(Void* pBSTR);
    public static UInt32 SysStringLen(IntPtr pBSTR);
    internal static void OutputDebugString(string outputString);
}
internal class System.Runtime.InteropServices.FixedHashTable : object {
    private static int slot_bucket;
    private static int slot_next;
    private static int slot_index;
    private Int32[] m_entries;
    private int m_size;
    private int m_count;
    internal FixedHashTable(int size);
    internal void Add(int hashCode, int index);
    internal int GetFirst(int hashCode);
    internal int GetIndex(int bucket);
    internal int GetNext(int bucket);
}
public class System.Runtime.InteropServices.ForwardDelegateCreationStub : MulticastDelegate {
    public ForwardDelegateCreationStub(object object, IntPtr method);
    public virtual Delegate Invoke(IntPtr pFunc);
    public virtual IAsyncResult BeginInvoke(IntPtr pFunc, AsyncCallback callback, object object);
    public virtual Delegate EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.GCCallbackAttribute : Attribute {
}
internal static class System.Runtime.InteropServices.GCEventProvider : object {
    public static bool IsETWHeapCollectionEnabled();
    [GCCallbackAttribute]
public static void TaskLogLiveCCW(IntPtr CCWGCHandle, IntPtr pCCW, IntPtr typeRawValue, IntPtr IUnknown, int ComRefCount, int JupiterRefCount, int flags);
    [GCCallbackAttribute]
public static void TaskLogLiveRCW(IntPtr pRCW, IntPtr typeRawValue, IntPtr IUnknown, IntPtr VTable, int refCount, ComObjectFlags flags);
    [GCCallbackAttribute]
public static void FlushComETW();
}
public class System.Runtime.InteropServices.GCHelpers : object {
    public static void RhpSetThreadDoNotTriggerGC();
    public static void RhpClearThreadDoNotTriggerGC();
}
internal class System.Runtime.InteropServices.GCMemoryPressureConstants : ValueType {
    internal static int GC_PRESSURE_DEFAULT;
    internal static int GC_PRESSURE_WINRT_LOW;
    internal static int GC_PRESSURE_WINRT_MEDIUM;
    internal static int GC_PRESSURE_WINRT_HIGH;
}
internal enum System.Runtime.InteropServices.GCPressureRange : Enum {
    public int value__;
    public static GCPressureRange None;
    public static GCPressureRange WinRT_Default;
    public static GCPressureRange WinRT_Low;
    public static GCPressureRange WinRT_Medium;
    public static GCPressureRange WinRT_High;
}
public class System.Runtime.InteropServices.HSTRING : ValueType {
    public IntPtr handle;
    public HSTRING(IntPtr hndl);
}
public class System.Runtime.InteropServices.HSTRING_HEADER : ValueType {
}
[GuidAttribute("00000001-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.IClassFactory {
    public abstract virtual int CreateInstance(IntPtr pUnkOuter, Guid* riid, IntPtr* ppvObject);
    public abstract virtual int LockServer(int fLock);
}
public interface System.Runtime.InteropServices.IManagedWrapper {
    public abstract virtual object GetTarget();
}
internal enum System.Runtime.InteropServices.InterfaceCheckResult : Enum {
    public int value__;
    public static InterfaceCheckResult Supported;
    public static InterfaceCheckResult Rejected;
    public static InterfaceCheckResult NotFound;
}
[ExtensionAttribute]
internal static class System.Runtime.InteropServices.InternalExtensions : object {
    [ExtensionAttribute]
internal static double ToOADate(DateTime dateTime);
    [ExtensionAttribute]
internal static long DoubleDateToTicks(double value);
}
internal class System.Runtime.InteropServices.InternalModule : McgModule {
    private static int PriorityForInternalModule;
    internal static McgInterfaceData s_IUnknown;
    internal static McgInterfaceData s_IInspectable;
    internal static McgInterfaceData s_ICCW;
    internal static McgInterfaceData s_IMarshal;
    internal static McgInterfaceData s_IDispatch;
    private static McgInterfaceData[] s_interfaceData;
    private static InternalModule();
}
internal class System.Runtime.InteropServices.InternalTypes : object {
    internal static RuntimeTypeHandle IUnknown;
    internal static RuntimeTypeHandle ICCW;
    internal static RuntimeTypeHandle IMarshal;
    internal static RuntimeTypeHandle IDispatch;
    internal static RuntimeTypeHandle IInspectable;
    private static InternalTypes();
}
internal class System.Runtime.InteropServices.InteropEventProvider : object {
    public static InteropEventProvider Log;
    private static int TASKRCWCREATION_ID;
    private static int TASKRCWFINALIZATION_ID;
    private static int TASKRCWREFCOUNTINC_ID;
    private static int TASKRCWREFCOUNTDEC_ID;
    private static int TASKRCWQUERYINTERFACEFAILURE_ID;
    private static int TASKRCWQUERYINTERFACE_ID;
    private static int TASKCCWCREATION_ID;
    private static int TASKCCWFINALIZATION_ID;
    private static int TASKCCWREFCOUNTINC_ID;
    private static int TASKCCWREFCOUNTDEC_ID;
    private static int TASKCCWQUERYRUNTIMECLASSNAME_ID;
    private static int TASKCCWQUERYINTERFACEFAILURE_ID;
    private static int TASKCCWQUERYINTERFACE_ID;
    private static int TASKCCWRESOLVEFAILURE_ID;
    private static int TASKJUPITERGARBAGECOLLECT_ID;
    private static int TASKJUPITERDISCONNECTERCWSINCURRENTAPARTMENT_ID;
    private static int TASKJUPITERADDMEMORYPRESSURE_ID;
    private static int TASKJUPITERREMOVEMEMORYPRESSURE_ID;
    private static int TASKJUPITERCREATEMANAGEDREFERENCE_ID;
    private static InteropEventProvider();
    internal static bool IsEnabled();
    private static bool IsEnabled(EventLevel level, EventKeywords keywords);
    private void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [EventAttribute("10")]
public void TaskRCWCreation(long objectID, long typeRawValue, string runtimeClassName, long context, long flags);
    [EventAttribute("12")]
public void TaskRCWRefCountInc(long objectID, int refCount);
    [EventAttribute("13")]
public void TaskRCWRefCountDec(long objectID, int refCount);
    [EventAttribute("11")]
public void TaskRCWFinalization(long objectID, int refCount);
    [EventAttribute("14")]
public void TaskRCWQueryInterfaceFailure(long objectID, long context, Guid interfaceIId, int reason);
    [EventAttribute("15")]
public void TaskRCWQueryInterface(long objectID, long context, Guid interfaceIId, long typeRawValue);
    [EventAttribute("20")]
public void TaskCCWCreation(long objectID, long targetObjectID, long typeRawValue);
    [EventAttribute("21")]
public void TaskCCWFinalization(long objectID, long refCount);
    [EventAttribute("22")]
public void TaskCCWRefCountInc(long objectID, long refCount);
    [EventAttribute("23")]
public void TaskCCWRefCountDec(long objectID, long refCount);
    [EventAttribute("24")]
public void TaskCCWQueryRuntimeClassName(long objectID, string runtimeClassName);
    [EventAttribute("30")]
public void TaskCCWQueryInterfaceFailure(long objectID, Guid interfaceIId);
    [EventAttribute("31")]
public void TaskCCWQueryInterface(long objectID, long typeRawValue);
    [EventAttribute("33")]
public void TaskCCWResolveFailure(long objectID, long interfaceAddress, Guid interfaceIId, int rejectedReason);
    [EventAttribute("40")]
public void TaskJupiterGarbageCollect();
    [EventAttribute("41")]
public void TaskJupiterDisconnectRCWsInCurrentApartment();
    [EventAttribute("42")]
public void TaskJupiterAddMemoryPressure(long memorySize);
    [EventAttribute("43")]
public void TaskJupiterRemoveMemoryPressure(long memorySize);
    [EventAttribute("44")]
public void TaskJupiterCreateManagedReference(long IUnknown, long objectType);
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.InteropExtensions : object {
    public static double ToNativeOleDate(DateTime dateTime);
    public static DateTime FromNativeOleDate(double nativeOleDate);
    public static void InitializeHandle(SafeHandle safeHandle, IntPtr win32Handle);
    public static void PinObjectAndCall(object obj, Action`1<IntPtr> del);
    public static void CopyToManaged(IntPtr source, Array destination, int startIndex, int length);
    public static void CopyToNative(Array array, int startIndex, IntPtr destination, int length);
    [ExtensionAttribute]
public static int GetElementSize(Array array);
    [ExtensionAttribute]
public static bool IsBlittable(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsElementTypeBlittable(Array array);
    [ExtensionAttribute]
public static bool IsGenericType(RuntimeTypeHandle handle);
    public static bool IsClass(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static IntPtr GetNativeFunctionPointer(Delegate del);
    [ExtensionAttribute]
public static IntPtr GetFunctionPointer(Delegate del, RuntimeTypeHandle& typeOfFirstParameterIfInstanceDelegate);
    [ExtensionAttribute]
public static IntPtr GetRawFunctionPointerForOpenStaticDelegate(Delegate del);
    [ExtensionAttribute]
public static IntPtr GetRawValue(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsOfType(object obj, RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle handle);
    public static Type GetTypeFromHandle(IntPtr typeHandle);
    public static Type GetTypeFromHandle(RuntimeTypeHandle typeHandle);
    [ExtensionAttribute]
public static int GetValueTypeSize(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsValueType(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsEnum(RuntimeTypeHandle handle);
    public static bool AreTypesAssignable(RuntimeTypeHandle sourceHandle, RuntimeTypeHandle targetHandle);
    public static void Memcpy(IntPtr destination, IntPtr source, int bytesToCopy);
    public static bool RuntimeRegisterGcCalloutForGCStart(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterGcCalloutForGCEnd(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterGcCalloutForAfterMarkPhase(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterRefCountedHandleCallback(IntPtr pCalloutMethod, RuntimeTypeHandle pTypeFilter);
    public static void RuntimeUnregisterRefCountedHandleCallback(IntPtr pCalloutMethod, RuntimeTypeHandle pTypeFilter);
    public static IntPtr RuntimeHandleAllocRefCounted(object value);
    public static void RuntimeHandleSet(IntPtr handle, object value);
    public static void RuntimeHandleFree(IntPtr handlePtr);
    public static IntPtr RuntimeHandleAllocDependent(object primary, object secondary);
    public static bool RuntimeIsPromoted(object obj);
    public static void RuntimeHandleSetDependentSecondary(IntPtr handle, object secondary);
    public static T UncheckedCast(object obj);
    public static bool IsArray(RuntimeTypeHandle type);
    public static RuntimeTypeHandle GetArrayElementType(RuntimeTypeHandle arrayType);
    [ExtensionAttribute]
public static RuntimeTypeHandle GetTypeHandle(object target);
    public static bool IsInstanceOf(object obj, RuntimeTypeHandle typeHandle);
    public static bool IsInstanceOfClass(object obj, RuntimeTypeHandle classTypeHandle);
    public static bool IsInstanceOfInterface(object obj, RuntimeTypeHandle interfaceTypeHandle);
    public static bool GuidEquals(Guid& left, Guid& right);
    public static bool ComparerEquals(T left, T right);
    public static object RuntimeNewObject(RuntimeTypeHandle typeHnd);
    internal static int wcslen(Char* ptr);
    [ExtensionAttribute]
public static void UnsafeCopyTo(StringBuilder stringBuilder, Char* destination);
    [ExtensionAttribute]
public static void ReplaceBuffer(StringBuilder stringBuilder, Char* newBuffer);
    [ExtensionAttribute]
public static void ReplaceBuffer(StringBuilder stringBuilder, Char[] newBuffer);
    [ExtensionAttribute]
public static Char[] GetBuffer(StringBuilder stringBuilder, Int32& len);
    public static IntPtr RuntimeHandleAllocVariable(object value, UInt32 type);
    public static UInt32 RuntimeHandleGetVariableType(IntPtr handle);
    public static void RuntimeHandleSetVariableType(IntPtr handle, UInt32 type);
    public static UInt32 RuntimeHandleCompareExchangeVariableType(IntPtr handle, UInt32 oldType, UInt32 newType);
    public static void SetExceptionErrorCode(Exception exception, int hr);
    public static Exception CreateDataMisalignedException(string message);
    public static Delegate CreateDelegate(RuntimeTypeHandle typeHandleForDelegate, IntPtr ldftnResult, object thisObject, bool isStatic, bool isVirtual, bool isOpen);
    public static void AddExceptionDataForRestrictedErrorInfo(Exception ex, string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject);
    public static bool TryGetRestrictedErrorObject(Exception ex, Object& restrictedErrorObject);
    public static bool TryGetRestrictedErrorDetails(Exception ex, String& restrictedError, String& restrictedErrorReference, String& restrictedCapabilitySid);
    public static TypeInitializationException CreateTypeInitializationException(string message);
    public static IntPtr GetObjectID(object obj);
    public static bool RhpETWShouldWalkCom();
    public static void RhpETWLogLiveCom(int eventType, IntPtr CCWHandle, IntPtr objectID, IntPtr typeRawValue, IntPtr IUnknown, IntPtr VTable, int comRefCount, int jupiterRefCount, int flags);
    [ExtensionAttribute]
public static bool SupportsReflection(Type type);
    public static void SuppressReentrantWaits();
    public static void RestoreReentrantWaits();
    public static IntPtr GetCriticalHandle(CriticalHandle criticalHandle);
    public static void SetCriticalHandle(CriticalHandle criticalHandle, IntPtr handle);
}
[GuidAttribute("9e365e57-48b2-4160-956f-c7385120bbfc")]
public interface System.Runtime.InteropServices.IUriRuntimeClass {
}
[GuidAttribute("44a9796f-723e-4fdf-a218-033e75b0c084")]
public interface System.Runtime.InteropServices.IUriRuntimeClassFactory {
}
internal class System.Runtime.InteropServices.LightweightList`1 : ValueType {
    private T[] m_array;
    private int m_countAndLock;
    private static int InitialCapacity;
    private void AssertLockHeld();
    private int AcquireLockAndGetCount();
    private void ReleaseLockAndSetCount(int newCount);
    private void SetArrayElement(int index, T value);
    private void GetArrayAndCount(T[]& array, Int32& count);
    public void Add(T value);
    public Enumerator<T> GetEnumerator();
}
internal class System.Runtime.InteropServices.ListCustomPropertyProviderProxy : object {
    private IList m_target;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal ListCustomPropertyProviderProxy(IList target);
    public sealed virtual object GetTarget();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.Runtime.InteropServices.MarshalAdapter : object {
    public static IntPtr GetIUnknownForObject(object o);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static bool IsComObject(object o);
    public static int ReleaseComObject(object o);
    public static int FinalReleaseComObject(object o);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
}
internal static class System.Runtime.InteropServices.MarshalImpl : object {
    public static IntPtr GetIUnknownForObject(object o);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static IntPtr GetComInterfaceForObject(object o, Type t);
    public static bool IsComObject(object o);
    public static int ReleaseComObject(object o);
    public static int FinalReleaseComObject(object o);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.McgAccessorAttribute : Attribute {
    public McgAccessorAttribute(McgAccessorKind accessorKind, string name);
}
public enum System.Runtime.InteropServices.McgAccessorKind : Enum {
    public int value__;
    public static McgAccessorKind PropertyGet;
    public static McgAccessorKind PropertySet;
    public static McgAccessorKind EventAdd;
    public static McgAccessorKind EventRemove;
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgAdditionalClassData : ValueType {
    public int ClassDataIndex;
    public FixupRuntimeTypeHandle FixupClassType;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle get_ClassType();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgBoxingData : ValueType {
    public FixupRuntimeTypeHandle FixupManagedClassType;
    public FixupRuntimeTypeHandle FixupCLRBoxingWrapperType;
    public IntPtr BoxingStub;
    public IntPtr UnboxingStub;
    public short PropertyType;
    public RuntimeTypeHandle ManagedClassType { get; }
    public RuntimeTypeHandle CLRBoxingWrapperType { get; }
    public RuntimeTypeHandle get_ManagedClassType();
    public RuntimeTypeHandle get_CLRBoxingWrapperType();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgCCWFactoryInfoEntry : ValueType {
    public FixupRuntimeTypeHandle FixupFactoryType;
    public RuntimeTypeHandle FactoryType { get; }
    public RuntimeTypeHandle get_FactoryType();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgClassData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public McgClassFlags Flags;
    public FixupRuntimeTypeHandle FixupBaseClassType;
    public short BaseClassIndex;
    public FixupRuntimeTypeHandle FixupDefaultInterfaceType;
    public short DefaultInterfaceIndex;
    public RuntimeTypeHandle ClassType { get; }
    internal GCPressureRange GCPressureRange { get; }
    internal ComMarshalingType MarshalingType { get; }
    public RuntimeTypeHandle BaseClassType { get; }
    public RuntimeTypeHandle DefaultInterfaceType { get; }
    public RuntimeTypeHandle get_ClassType();
    internal GCPressureRange get_GCPressureRange();
    internal ComMarshalingType get_MarshalingType();
    public RuntimeTypeHandle get_BaseClassType();
    public RuntimeTypeHandle get_DefaultInterfaceType();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.McgClassFlags : Enum {
    public int value__;
    public static McgClassFlags None;
    public static McgClassFlags MarshalingBehavior_Inhibit;
    public static McgClassFlags MarshalingBehavior_Free;
    public static McgClassFlags MarshalingBehavior_Standard;
    public static McgClassFlags MarshalingBehavior_Mask;
    public static McgClassFlags GCPressureRange_WinRT_Default;
    public static McgClassFlags GCPressureRange_WinRT_Low;
    public static McgClassFlags GCPressureRange_WinRT_Medium;
    public static McgClassFlags GCPressureRange_WinRT_High;
    public static McgClassFlags GCPressureRange_Mask;
    public static McgClassFlags NotComObject;
    public static McgClassFlags IsSealed;
    public static McgClassFlags IsWinRT;
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgCollectionData : ValueType {
    public FixupRuntimeTypeHandle FixupCollectionType;
    public FixupRuntimeTypeHandle FixupFirstType;
    public FixupRuntimeTypeHandle FixupSecondType;
    public RuntimeTypeHandle CollectionType { get; }
    public RuntimeTypeHandle FirstType { get; }
    public RuntimeTypeHandle SecondType { get; }
    public RuntimeTypeHandle get_CollectionType();
    public RuntimeTypeHandle get_FirstType();
    public RuntimeTypeHandle get_SecondType();
}
[AttributeUsageAttribute("4108")]
public class System.Runtime.InteropServices.McgComCallableAttribute : Attribute {
}
internal static class System.Runtime.InteropServices.McgComHelpers : object {
    internal static string GetRuntimeClassName(object obj);
    internal static string GetRuntimeClassName(IntPtr pWinRTItf);
    internal static bool SeekStreamToBeginning(IntPtr pStream);
    internal static bool SetStreamSize(IntPtr pStream, ulong lSize);
    internal static void SafeReleaseStream(IntPtr pStream);
    internal static bool IsFreeThreaded(IntPtr pUnknown);
    internal static Void* CachedAlloc(int size, IntPtr& cache);
    internal static void CachedFree(Void* block, IntPtr& cache);
    internal static object UnboxManagedWrapperIfBoxed(object target);
    internal static object ComInterfaceToComObject(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSigature, ContextCookie expectedContext, CreateComObjectFlags flags);
    internal static object ComInterfaceToComObjectInternal(IntPtr pComItf, IntPtr pComIdentityIUnknown, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, ContextCookie expectedContext, CreateComObjectFlags flags);
    private static object ComInterfaceToComObjectInternal_NoCache(IntPtr pComItf, IntPtr pComIdentityIUnknown, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, ContextCookie expectedContext, CreateComObjectFlags flags, String& className);
    internal static __ComGenericInterfaceDispatcher CreateGenericComDispatcher(RuntimeTypeHandle genericDispatcherDef, RuntimeTypeHandle[] genericArguments, __ComObject comThisPointer);
    private static __ComObject CreateComObjectInternal(RuntimeTypeHandle classType, IntPtr pComItf);
    internal static object ComInterfaceToObjectInternal(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, CreateComObjectFlags flags);
    private static object ComInterfaceToObjectInternal_NoManagedUnboxing(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, CreateComObjectFlags flags);
    internal static IntPtr ObjectToComInterfaceInternal(object obj, RuntimeTypeHandle typeHnd);
    internal static IntPtr ManagedObjectToComInterface(object obj, RuntimeTypeHandle interfaceType);
    internal static IntPtr ManagedObjectToComInterface(object obj, Guid& iid);
    private static IntPtr ManagedObjectToComInterfaceInternal(object obj, Guid& iid, RuntimeTypeHandle interfaceType);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.InteropServices.McgGeneratedAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Runtime.InteropServices.McgGeneratedMarshallingCodeAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.McgGeneratedNativeCallCodeAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgGenericArgumentMarshalInfo : ValueType {
    public UInt32 ElementSize;
    public FixupRuntimeTypeHandle FixupElementClassType;
    public FixupRuntimeTypeHandle FixupElementInterfaceType;
    public FixupRuntimeTypeHandle FixupAsyncOperationType;
    public FixupRuntimeTypeHandle FixupIteratorType;
    public FixupRuntimeTypeHandle FixupVectorViewType;
    public RuntimeTypeHandle AsyncOperationType { get; }
    public RuntimeTypeHandle ElementClassType { get; }
    public RuntimeTypeHandle ElementInterfaceType { get; }
    public RuntimeTypeHandle IteratorType { get; }
    public RuntimeTypeHandle VectorViewType { get; }
    public RuntimeTypeHandle get_AsyncOperationType();
    public RuntimeTypeHandle get_ElementClassType();
    public RuntimeTypeHandle get_ElementInterfaceType();
    public RuntimeTypeHandle get_IteratorType();
    public RuntimeTypeHandle get_VectorViewType();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgHashcodeVerifyEntry : ValueType {
    public FixupRuntimeTypeHandle FixupTypeHandle;
    public UInt32 HashCode;
    public RuntimeTypeHandle TypeHandle { get; }
    public RuntimeTypeHandle get_TypeHandle();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgInterfaceData : ValueType {
    public FixupRuntimeTypeHandle FixupItfType;
    public FixupRuntimeTypeHandle FixupDispatchClassType;
    public FixupRuntimeTypeHandle FixupDynamicAdapterClassType;
    public Guid ItfGuid;
    public McgInterfaceFlags Flags;
    public short MarshalIndex;
    public IntPtr CcwVtable;
    public IntPtr DelegateInvokeStub;
    public RuntimeTypeHandle ItfType { get; public set; }
    public RuntimeTypeHandle DispatchClassType { get; }
    public RuntimeTypeHandle DynamicAdapterClassType { get; }
    internal bool IsIInspectable { get; }
    internal bool IsIInspectableOrDelegate { get; }
    public RuntimeTypeHandle get_ItfType();
    public void set_ItfType(RuntimeTypeHandle value);
    public RuntimeTypeHandle get_DispatchClassType();
    public RuntimeTypeHandle get_DynamicAdapterClassType();
    internal bool get_IsIInspectable();
    internal bool get_IsIInspectableOrDelegate();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.McgInterfaceFlags : Enum {
    public byte value__;
    public static McgInterfaceFlags None;
    public static McgInterfaceFlags isIInspectable;
    public static McgInterfaceFlags isDelegate;
    public static McgInterfaceFlags isInternal;
    public static McgInterfaceFlags useSharedCCW;
    public static McgInterfaceFlags SharedCCWMask;
    public static McgInterfaceFlags useSharedCCW_IVector;
    public static McgInterfaceFlags useSharedCCW_IVectorView;
    public static McgInterfaceFlags useSharedCCW_IIterable;
    public static McgInterfaceFlags useSharedCCW_IIterator;
    public static McgInterfaceFlags useSharedCCW_AsyncOperationCompletedHandler;
    public static McgInterfaceFlags useSharedCCW_IVectorBlittable;
    public static McgInterfaceFlags useSharedCCW_IVectorViewBlittable;
    public static McgInterfaceFlags useSharedCCW_IIteratorBlittable;
}
[AttributeUsageAttribute("4")]
internal class System.Runtime.InteropServices.McgInternalTypeAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class System.Runtime.InteropServices.McgIntrinsicsAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.McgMarshal : object {
    public static void StringToHStringReference(Char* pchPinnedSourceString, string sourceString, HSTRING_HEADER* pHeader, HSTRING* phString);
    public static string HStringToString(IntPtr hString);
    public static string HStringToString(HSTRING hString);
    public static void FreeHString(IntPtr pHString);
    public static IntPtr ActivateInstance(string typeName);
    public static HSTRING StringToHString(string sourceString);
    internal static int StringToHStringNoNullCheck(string sourceString, HSTRING* hstring);
    public static HSTRING StringToHStringForField(string sourceString);
    public static void SaveLastWin32Error();
    public static void ClearLastWin32Error();
    public static bool GuidEquals(Guid& left, Guid& right);
    public static bool ComparerEquals(T left, T right);
    public static T CreateClass();
    public static bool IsEnum(object obj);
    public static bool IsComObject(Type type);
    internal static bool IsComObject(object obj);
    public static T FastCast(object value);
    public static double ToNativeOleDate(DateTime dateTime);
    public static DateTime FromNativeOleDate(double nativeOleDate);
    public static void InitializeHandle(SafeHandle safeHandle, IntPtr win32Handle);
    public static bool IsOfType(object obj, RuntimeTypeHandle handle);
    public static Type TypeNameToType(HSTRING nativeTypeName, int nativeTypeKind);
    internal static Type TypeNameToType(string nativeTypeName, int nativeTypeKind);
    public static void TypeToTypeName(Type type, HSTRING& nativeTypeName, Int32& nativeTypeKind);
    internal static string TypeToTypeName(RuntimeTypeHandle typeHandle, Int32& nativeTypeKind);
    [CLSCompliantAttribute("False")]
public static void StringBuilderToUnicodeString(StringBuilder stringBuilder, UInt16* destination);
    [CLSCompliantAttribute("False")]
public static void UnicodeStringToStringBuilder(UInt16* newBuffer, StringBuilder stringBuilder);
    [CLSCompliantAttribute("False")]
public static void StringBuilderToAnsiString(StringBuilder stringBuilder, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void AnsiStringToStringBuilder(Byte* newBuffer, StringBuilder stringBuilder);
    [CLSCompliantAttribute("False")]
public static string AnsiStringToString(Byte* pchBuffer);
    [CLSCompliantAttribute("False")]
public static Byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void ByValWideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, int expectedCharCount, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void ByValAnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    [CLSCompliantAttribute("False")]
public static void WideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void AnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar);
    public static char AnsiCharToWideChar(byte nativeValue);
    [CLSCompliantAttribute("False")]
public static void StringToByValAnsiString(string str, Byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static string ByValAnsiStringToString(Byte* pchBuffer, int charCount);
    [CLSCompliantAttribute("False")]
public static int AddRef(__ComObject obj);
    [CLSCompliantAttribute("False")]
public static int Release(__ComObject obj);
    public static int ComAddRef(IntPtr pComItf);
    internal static int ComRelease_StdCall(IntPtr pComItf);
    public static int ComRelease(IntPtr pComItf);
    public static int ComSafeRelease(IntPtr pComItf);
    public static int FinalReleaseComObject(object o);
    [CLSCompliantAttribute("False")]
public static __ComObject GetActivationFactory(string className, RuntimeTypeHandle factoryIntf);
    public static object ThisPointerToTargetObject(IntPtr pUnk);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject_NoUnboxing(IntPtr pComItf, RuntimeTypeHandle interfaceType);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject(IntPtr pComItf, RuntimeTypeHandle interfaceType);
    private static object ComInterfaceToObjectInternal(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature);
    public static IntPtr ComQueryInterfaceNoThrow(IntPtr pComItf, Guid& iid);
    public static IntPtr ComQueryInterfaceNoThrow(IntPtr pComItf, Guid& iid, Int32& hr);
    internal static int ComQueryInterfaceWithHR(IntPtr pComItf, Guid& iid, IntPtr& ppv);
    public static IntPtr GetCCWVTableCopy(Void* pVtbl, IntPtr& pNativeVtbl, int size);
    [CLSCompliantAttribute("False")]
public static IntPtr ObjectToComInterface(object obj, RuntimeTypeHandle typeHnd);
    public static IntPtr ObjectToIInspectable(object obj);
    private static bool DelegateTargetMethodEquals(Delegate del, IntPtr pfn);
    public static IntPtr DelegateToComInterface(Delegate del, RuntimeTypeHandle typeHnd);
    public static Delegate ComInterfaceToDelegate(IntPtr pComItf, RuntimeTypeHandle typeHnd);
    public static void ObjectArrayToComInterfaceArray(UInt32 len, IntPtr* dst, Object[] src, RuntimeTypeHandle typeHnd);
    public static IntPtr* ObjectArrayToComInterfaceArrayAlloc(Object[] src, RuntimeTypeHandle typeHnd, UInt32& len);
    [CLSCompliantAttribute("False")]
public static IntPtr GetOuterIInspectableForManagedObject(__ComObject managedObject);
    [CLSCompliantAttribute("False")]
public static IntPtr ManagedObjectToComInterface(object obj, RuntimeTypeHandle interfaceType);
    public static object IInspectableToObject(IntPtr pComItf);
    public static IntPtr CoCreateInstanceEx(Guid clsid, string server);
    public static IntPtr CoCreateInstanceEx(Guid clsid);
    public static void ReleaseRCWsInCurrentApartment();
    public static int GetTotalComObjectCount();
    public static IEnumerable`1<__ComObject> GetAllComObjects();
    public static int GetHRForExceptionWinRT(Exception ex);
    public static int GetHRForException(Exception ex);
    public static void ThrowOnExternalCallFailed(int hr, RuntimeTypeHandle typeHnd);
    public static Exception GetExceptionForHR(int hr, bool isWinRTScenario);
    public static IntPtr GetInterface(__ComObject obj, RuntimeTypeHandle typeHnd);
    public static object GetDynamicAdapter(__ComObject obj, RuntimeTypeHandle requestedType, RuntimeTypeHandle existingType);
    public static object GetDynamicAdapter(__ComObject obj, RuntimeTypeHandle requestedType);
    public static IntPtr GetStubForPInvokeDelegate(RuntimeTypeHandle delegateType, Delegate dele);
    public static Delegate GetPInvokeDelegateForStub(IntPtr pStub, RuntimeTypeHandle delegateType);
    public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer();
    public static T GetCurrentCalleeDelegate();
    public static object UnboxIfBoxed(object target);
    public static object UnboxIfBoxed(object target, string className);
    internal static object BoxIfBoxable(object target);
    internal static object BoxIfBoxable(object target, RuntimeTypeHandle typeHandleOverride);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.InteropServices.McgModule : object {
    private int m_mcgDataModulePriority;
    private StringPool m_stringPool;
    private McgInterfaceData[] m_interfaceData;
    private CCWTemplateData[] m_ccwTemplateData;
    private RuntimeTypeHandle[] m_supportedInterfaceList;
    private McgClassData[] m_classData;
    private McgBoxingData[] m_boxingData;
    private McgAdditionalClassData[] m_additionalClassData;
    private McgCollectionData[] m_collectionData;
    private McgPInvokeDelegateData[] m_pinvokeDelegateData;
    private McgCCWFactoryInfoEntry[] m_ccwFactories;
    private McgStructMarshalData[] m_structMarshalData;
    private McgUnsafeStructFieldOffsetData[] m_unsafeStructOffsetData;
    private McgGenericArgumentMarshalInfo[] m_genericArgumentMarshalInfo;
    private McgHashcodeVerifyEntry[] m_hashcodeVerifyData;
    private FixedHashTable m_guidMap;
    public static RuntimeTypeHandle s_DependencyReductionTypeRemovedTypeHandle;
    private StringMap m_interfaceNameMap;
    private StringMap m_classNameMap;
    private StringMap m_additionalClassNameMap;
    private StringMap m_ccwTemplateDataNameMap;
    private StringMap m_ccwFactoriesNameMap;
    private StringMap m_boxingDataNameMap;
    private StringMap m_typeNameMarshalingDataNameMap;
    private StringMap m_unsafeStructFieldNameMap;
    private StringMap m_unsafeStructDataNameMap;
    private static Guid s_IID_IClassFactory;
    public int ModulePriority { get; }
    public McgModule(int mcgDataModulePriority, McgInterfaceData[] interfaceData, CCWTemplateData[] ccwTemplateData, FixupRuntimeTypeHandle[] supportedInterfaceList, McgClassData[] classData, McgBoxingData[] boxingData, McgAdditionalClassData[] additionalClassData, McgCollectionData[] collectionData, McgPInvokeDelegateData[] pinvokeDelegateData, McgCCWFactoryInfoEntry[] ccwFactories, McgStructMarshalData[] structMarshalData, McgUnsafeStructFieldOffsetData[] unsafeStructFieldOffsetData, McgGenericArgumentMarshalInfo[] genericArgumentMarshalInfo, McgHashcodeVerifyEntry[] hashcodeVerifyData);
    private static McgModule();
    public int get_ModulePriority();
    private NativeReader NewHashtableReader(Byte[] dataArray);
    public void SetThunk(int index, IntPtr thunk);
    public void SetStringPool(Byte[] dictionary, Byte[] strings, UInt16[] index);
    public void SetinterfaceDataNameIndices(UInt16[] nameIndices);
    public void SetclassDataNameIndices(UInt16[] nameIndices);
    public void SetadditionalClassDataNameIndices(UInt16[] nameIndices);
    public void SetccwFactoriesNameIndices(UInt16[] nameIndices);
    public void SetccwTemplateDataNameIndices(UInt16[] nameIndices);
    public void SetboxingDataNameIndices(UInt16[] nameIndices);
    public void SettypeNameMarshalingDataNameIndices(UInt16[] nameIndices);
    public void SetinterfaceDataNameIndices(UInt32[] nameIndices);
    public void SetclassDataNameIndices(UInt32[] nameIndices);
    public void SetadditionalClassDataNameIndices(UInt32[] nameIndices);
    public void SetccwFactoriesNameIndices(UInt32[] nameIndices);
    public void SetccwTemplateDataNameIndices(UInt32[] nameIndices);
    public void SetboxingDataNameIndices(UInt32[] nameIndices);
    public void SettypeNameMarshalingDataNameIndices(UInt32[] nameIndices);
    public void SetstructMarshalDataNameIndices(UInt16[] nameIndices);
    public void SetstructMarshalDataNameIndices(UInt32[] nameIndices);
    public void SetunsafeStructFieldOffsetDataNameIndices(UInt16[] nameIndices);
    public void SetunsafeStructFieldOffsetDataNameIndices(UInt32[] nameIndices);
    internal bool TryGetCCWRuntimeClassName(int slot, String& ccwRuntimeClassName);
    internal bool TryGetStructFieldOffset(McgStructMarshalData structMarshalData, string fieldName, UInt32& offset);
    internal McgInterfaceData[] GetAllInterfaceData();
    internal CCWTemplateData[] GetAllCCWTemplateData();
    internal McgClassData[] GetAllClassData();
    internal McgCollectionData[] GetAllCollectionData();
    internal McgBoxingData[] GetAllBoxingData();
    internal int GetInterfaceDataCount();
    internal int GetCCWTemplateDataCount();
    internal int GetClassDataCount();
    internal int GetCollectionDataCount();
    internal int GetBoxingDataCount();
    internal RuntimeTypeHandle GetTypeFromGuid(Guid& guid);
    internal bool TryGetInterfaceTypeNameByIndex(int slot, String& name);
    internal bool TryGetClassTypeNameByIndex(int slot, String& name);
    internal Type GetTypeFromName(string name, Boolean& isWinRT);
    internal bool TryGetClassFromNameInClassData(string name, RuntimeTypeHandle& classType);
    internal bool TryGetClassFromNameInAdditionalClassData(string name, RuntimeTypeHandle& classType);
    private RuntimeTypeHandle ComputeClosestClassForClassIndex(int index);
    internal bool TryGetInterfaceTypeFromName(string name, RuntimeTypeHandle& interfaceType);
    internal McgInterfaceData GetInterfaceDataByIndex(int index);
    internal McgClassData GetClassDataByIndex(int index);
    internal CCWTemplateData GetCCWTemplateDataByIndex(int index);
    internal McgCollectionData GetCollectionDataByIndex(int index);
    internal McgBoxingData GetBoxingDataByIndex(int index);
    internal bool TryGetUnboxingStub(string className, IntPtr& unboxingStub);
    internal bool TryGetPInvokeDelegateData(RuntimeTypeHandle typeHandle, McgPInvokeDelegateData& pinvokeDelegateData);
    internal bool TryGetStructMarshalData(RuntimeTypeHandle structTypeHandle, McgStructMarshalData& structMarshalData);
    internal bool TryGetStructWinRTName(RuntimeTypeHandle structTypeHandle, String& structWinRTName);
    internal RuntimeTypeHandle FindTypeSupportDynamic(Func`2<RuntimeTypeHandle, bool> predicate);
    internal bool TryGetBaseType(int ccwTemplateIndex, RuntimeTypeHandle& baseType);
    internal bool TryGetImplementedInterfaces(int ccwTemplateIndex, IEnumerable`1& interfaces);
    internal bool TryGetIsWinRTType(int ccwTemplateIndex, Boolean& isWinRTType);
    internal bool TryGetTypeHandleForICollecton(int slot, RuntimeTypeHandle& firstTypeHandle, RuntimeTypeHandle& secondTypeHandle);
    internal bool TryGetGenericArgumentMarshalInfo(int slot, McgGenericArgumentMarshalInfo& mcgGenericArgumentMarshalInfo);
    public int DllGetClassObjectImpl(Guid rclsid, Guid riid, IntPtr* ppv);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.McgModuleManager : object {
    internal static int NUM_BITS_FOR_MAX_MODULES;
    internal static int MAX_MODULES;
    private static McgModule[] s_modules;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_moduleCount;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToInterfaceIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToCCWTemplateIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToClassIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToCollectionIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToBoxingIndexMap;
    private static InternalModule s_internalModule;
    [CompilerGeneratedAttribute]
private static bool <UseDynamicInterop>k__BackingField;
    public static bool UseDynamicInterop { get; public set; }
    internal static void Initialize();
    [CompilerGeneratedAttribute]
public static bool get_UseDynamicInterop();
    [CompilerGeneratedAttribute]
public static void set_UseDynamicInterop(bool value);
    public static void Register(McgModule module);
    private static void Add(McgModule module);
    private static void InsertDataIntoDictionary(Dictionary`2<RuntimeTypeHandle, int> map, RuntimeTypeHandle typeHandle, int moduleIndex, int typeIndex);
    public static void LateInitialize();
    internal static bool TryGetClassTypeFromName(string name, RuntimeTypeHandle& classType);
    internal static bool TryGetInterfaceTypeFromName(string name, RuntimeTypeHandle& interfaceType);
    internal static string GetTypeName(RuntimeTypeHandle type, Boolean& isWinRT);
    internal static Type GetTypeFromName(string name, Boolean& isWinRT);
    internal static IEnumerable`1<RuntimeTypeHandle> GetTypesFromGuid(Guid& guid);
    private static bool GetIndicesFromMap(Dictionary`2<RuntimeTypeHandle, int> map, RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& typeIndex);
    internal static bool GetIndicesForInterface(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& interfaceIndex);
    internal static bool GetIndicesForClass(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& classIndex);
    internal static bool GetIndicesForCCWTemplate(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& ccwTemplateIndex);
    internal static bool GetIndicesForCollection(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& collecitonIndex);
    internal static bool GetIndicesForBoxing(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& boxingIndex);
    internal static McgInterfaceData GetInterfaceDataByIndex(int moduleIndex, int interfaceIndex);
    internal static McgClassData GetClassDataByIndex(int moduleIndex, int classIndex);
    internal static CCWTemplateData GetCCWTemplateDataByIndex(int moduleIndex, int ccwTemplateIndex);
    internal static IEnumerable`1<RuntimeTypeHandle> GetImplementedInterfacesByIndex(int moduleIndex, int ccwTemplateIndex);
    internal static bool TryGetTypeHandleForICollecton(RuntimeTypeHandle interfaceTypeHandle, RuntimeTypeHandle& firstTypeHandle, RuntimeTypeHandle& secondTypeHandle);
    internal static RuntimeTypeHandle FindTypeSupportDynamic(Func`2<RuntimeTypeHandle, bool> predicate);
    internal static bool TryGetCCWRuntimeClassName(RuntimeTypeHandle ccwTypeHandle, String& ccwRuntimeClassName);
    internal static bool TryGetBaseType(RuntimeTypeHandle ccwType, RuntimeTypeHandle& baseType);
    internal static bool TryGetImplementedInterfaces(RuntimeTypeHandle ccwType, IEnumerable`1& interfaces);
    internal static bool TryGetIsWinRTType(RuntimeTypeHandle ccwType, Boolean& isWinRTType);
    internal static bool TryGetStructUnsafeStructType(RuntimeTypeHandle structureTypeHandle, RuntimeTypeHandle& unsafeStructType);
    internal static bool TryGetStructUnmarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& unmarshalStub);
    internal static bool TryGetStructMarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& marshalStub);
    internal static bool TryGetDestroyStructureStub(RuntimeTypeHandle structureTypeHandle, IntPtr& destroyStructureStub, Boolean& hasInvalidLayout);
    internal static bool TryGetStructMarshalData(RuntimeTypeHandle structureTypeHandle, McgStructMarshalData& structMarshalData);
    internal static bool TryGetStructWinRTName(RuntimeTypeHandle structTypeHandle, String& structWinRTName);
    internal static bool TryGetStructFieldOffset(RuntimeTypeHandle structureTypeHandle, string fieldName, Boolean& structExists, UInt32& offset);
    internal static bool TryGetBoxingWrapperType(RuntimeTypeHandle typeHandle, object target, RuntimeTypeHandle& boxingWrapperType, Int32& boxingPropertyType, IntPtr& boxingStub);
    internal static bool TryGetUnboxingStub(string className, IntPtr& unboxingStub);
    internal static bool GetPInvokeDelegateData(RuntimeTypeHandle delegateType, McgPInvokeDelegateData& pinvokeDelegateData);
    internal static bool TryGetGenericArgumentMarshalInfo(RuntimeTypeHandle interfaceType, McgGenericArgumentMarshalInfo& mcgGenericArgumentMarshalInfo);
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgPInvokeDelegateData : ValueType {
    public FixupRuntimeTypeHandle FixupDelegate;
    public IntPtr ReverseStub;
    public IntPtr ReverseOpenStaticDelegateStub;
    public IntPtr ForwardDelegateCreationStub;
    public RuntimeTypeHandle Delegate { get; }
    public RuntimeTypeHandle get_Delegate();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.McgPInvokeMarshalStubAttribute : Attribute {
    public McgPInvokeMarshalStubAttribute(string assemblyName, string typeName, string methodName);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.McgRedirectedMethodAttribute : Attribute {
    public McgRedirectedMethodAttribute(string assemblyQualifiedTypeName, string methodName);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.InteropServices.McgRedirectedTypeAttribute : Attribute {
    public McgRedirectedTypeAttribute(string assemblyQualifiedTypeName);
}
public class System.Runtime.InteropServices.McgRemovedType : object {
}
[AttributeUsageAttribute("8")]
public class System.Runtime.InteropServices.McgRootsTypeAttribute : Attribute {
    public McgRootsTypeAttribute(Type rootedType);
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgStructMarshalData : ValueType {
    public FixupRuntimeTypeHandle FixupSafeStructType;
    public FixupRuntimeTypeHandle FixupUnsafeStructType;
    public IntPtr MarshalStub;
    public IntPtr UnmarshalStub;
    public IntPtr DestroyStructureStub;
    public McgStructMarshalFlags Flags;
    public int FieldOffsetStartIndex;
    public int NumOfFields;
    public RuntimeTypeHandle SafeStructType { get; }
    public RuntimeTypeHandle UnsafeStructType { get; }
    public bool HasInvalidLayout { get; }
    public RuntimeTypeHandle get_SafeStructType();
    public RuntimeTypeHandle get_UnsafeStructType();
    public bool get_HasInvalidLayout();
}
public enum System.Runtime.InteropServices.McgStructMarshalFlags : Enum {
    public int value__;
    public static McgStructMarshalFlags None;
    public static McgStructMarshalFlags HasInvalidLayout;
}
internal static class System.Runtime.InteropServices.McgTypeHelpers : object {
    private static Type[] s_wellKnownTypes;
    private static String[] s_wellKnownTypeNames;
    private static string PseudonymPrefix;
    private static Dictionary`2<string, Type> s_fakeTypeMap;
    private static Lock s_fakeTypeMapLock;
    private static Dictionary`2<RuntimeTypeHandle, Type> s_realToFakeTypeMap;
    private static McgTypeHelpers();
    internal static bool IsWinRTPrimitiveType(RuntimeTypeHandle typeHandle, String& typeName);
    internal static bool IsWinRTPrimitiveType(string typeName, RuntimeTypeHandle& typeHandle);
    internal static void TypeToTypeName(RuntimeTypeHandle typeHandle, String& typeName, TypeKind& typeKind);
    private static string GetCustomTypeName(RuntimeTypeHandle type);
    private static string GetPseudonymForType(RuntimeTypeHandle type, bool useFake);
    private static Type StringToCustomType(string s);
    public static string GetDiagnosticMessageForMissingType(RuntimeTypeHandle interfaceType);
    private static string ConstructGenericTypeFullName(string genericTypeDefinitionFullName, String[] genericTypeArguments);
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgTypeNameMarshalingData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle get_ClassType();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.McgUnsafeStructFieldOffsetData : ValueType {
    public UInt32 Offset;
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.InteropServices.McgWindowsRuntimeVersionAttribute : Attribute {
    public McgWindowsRuntimeVersionAttribute(int version);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public string EntryPoint;
    public CallingConvention CallingConvention;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.NativeCallableInternalAttribute : Attribute {
    public string EntryPoint;
    public CallingConvention CallingConvention;
}
public abstract class System.Runtime.InteropServices.NativeFunctionPointerWrapper : object {
    private IntPtr m_nativeFunctionPointer;
    public IntPtr NativeFunctionPointer { get; }
    public NativeFunctionPointerWrapper(IntPtr nativeFunctionPointer);
    public IntPtr get_NativeFunctionPointer();
}
[CLSCompliantAttribute("False")]
public class System.Runtime.InteropServices.PInvokeMarshal : object {
    [ThreadStaticAttribute]
internal static int s_lastWin32Error;
    private static long HIWORDMASK;
    public static int GetLastWin32Error();
    public static void SetLastWin32Error(int errorCode);
    public static void SaveLastWin32Error();
    public static IntPtr GetStubForPInvokeDelegate(Delegate del);
    public static Delegate GetPInvokeDelegateForStub(IntPtr pStub, RuntimeTypeHandle delegateType);
    public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer();
    public static IntPtr MemAlloc(IntPtr cb);
    public static void MemFree(IntPtr hglobal);
    public static IntPtr MemReAlloc(IntPtr pv, IntPtr cb);
    public static IntPtr CoTaskMemAlloc(UIntPtr bytes);
    public static void CoTaskMemFree(IntPtr allocatedMemory);
    public static IntPtr CoTaskMemReAlloc(IntPtr pv, IntPtr cb);
    public static T GetCurrentCalleeDelegate();
    public static void StringBuilderToUnicodeString(StringBuilder stringBuilder, UInt16* destination);
    public static void UnicodeStringToStringBuilder(UInt16* newBuffer, StringBuilder stringBuilder);
    public static void StringBuilderToAnsiString(StringBuilder stringBuilder, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    public static void AnsiStringToStringBuilder(Byte* newBuffer, StringBuilder stringBuilder);
    public static string AnsiStringToString(Byte* pchBuffer);
    public static Byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar);
    public static void ByValWideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, int expectedCharCount, bool bestFit, bool throwOnUnmappableChar);
    public static void ByValAnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static void WideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    public static void AnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar);
    public static char AnsiCharToWideChar(byte nativeValue);
    public static void StringToByValAnsiString(string str, Byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar, bool truncate);
    public static string ByValAnsiStringToString(Byte* pchBuffer, int charCount);
    private static int GetAnsiStringLen(Byte* pchBuffer);
    private static Byte* StringToAnsiString(Char* pManaged, int lenUnicode, Byte* pNative, bool terminateWithNull, bool bestFit, bool throwOnUnmappableChar);
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    public static void CopyToNative(Array source, int startIndex, IntPtr destination, int length);
    private static bool CalculateStringLength(Byte* pchBuffer, Int32& ansiBufferLen, Int32& unicodeBufferLen);
    private static bool IsWin32Atom(IntPtr ptr);
    private static bool IsNotWin32Atom(IntPtr ptr);
    public static void ClearLastWin32Error();
    public static int ConvertMultiByteToWideChar(Byte* buffer, int ansiLength, Char* pWChar, int uniLength);
    public static int ConvertWideCharToMultiByte(Char* wideCharStr, int wideCharLen, Byte* multiByteStr, int multiByteLen);
    public static int ConvertWideCharToMultiByte(Char* wideCharStr, int wideCharLen, Byte* multiByteStr, int multiByteLen, bool bestFit, bool throwOnUnmappableChar);
    public static int GetByteCount(Char* wStr, int wideStrLen);
    public static int GetCharCount(Byte* multiByteStr, int multiByteLen);
    public static int GetSystemMaxDBCSCharSize();
}
internal static class System.Runtime.InteropServices.RCWWalker : object {
    private static DependentHandleList s_dependentHandleList;
    private static IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) s_pGCManager;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_bInitialized;
    private static bool s_globalPeggingOn;
    private static bool s_gcStarted;
    private static __com_ICLRServices s_clrServices;
    private static __com_IFindDependentWrappers s_findDependentWrapperCallbackObject;
    internal static __ComObject s_currentComObjectToWalk;
    internal static bool IsGlobalPeggingOn { get; }
    private static RCWWalker();
    [GCCallbackAttribute]
internal static bool get_IsGlobalPeggingOn();
    private static void Initialize(__com_IJupiterObject* pJupiterObject);
    [GCCallbackAttribute]
private static void InitializeImpl();
    internal static void OnJupiterRCWCreated(__ComObject comObject);
    internal static void AfterJupiterRCWCreated(__ComObject comObject);
    internal static void AfterAddRef(__ComObject comObject);
    internal static void BeforeRelease(__ComObject comObject);
    [GCCallbackAttribute]
internal static bool WalkRCWs();
    [GCCallbackAttribute]
internal static bool WalkOneRCW(__ComObject comObject);
    [GCCallbackAttribute]
internal static void LogRCWs();
    [GCCallbackAttribute]
internal static __com_IFindDependentWrappers* GetDependentWrapperCallbackObject();
    [GCCallbackAttribute]
internal static int OnDependentWrapperCallback(ComCallableObject ccw);
    [GCCallbackAttribute]
internal static int AfterMarkPhase(int nCondemnedGeneration);
    [GCCallbackAttribute]
internal static int OnGCStarted(int nCondemnedGeneration);
    [GCCallbackAttribute]
private static bool NeedToWalkRCWs();
    [GCCallbackAttribute]
internal static void OnGCStartedWorker();
    [GCCallbackAttribute]
internal static int OnGCFinished(int nCondemnedGeneration);
    [GCCallbackAttribute]
private static void OnGCFinishedWorker();
}
internal class System.Runtime.InteropServices.RuntimeTypeHandleMap : FixedHashTable {
    private Func`2<int, RuntimeTypeHandle> m_getHandle;
    internal RuntimeTypeHandleMap(int size, Func`2<int, RuntimeTypeHandle> getHandle);
    internal int Lookup(RuntimeTypeHandle handle);
}
internal class System.Runtime.InteropServices.SimpleComInterfaceCacheItem : ValueType {
    private IntPtr ptr;
    private RuntimeTypeHandle typeHandle;
    private bool hasValue;
    private bool HasValue { get; }
    private bool get_HasValue();
    internal bool Assign(IntPtr pComPtr, RuntimeTypeHandle handle);
    internal bool TryGetPtr(IntPtr& retIntPtr);
    internal bool TryGetType(RuntimeTypeHandle& retInterface);
    internal IntPtr GetPtr();
    internal bool IsMatchingEntry(IntPtr pComPtr, RuntimeTypeHandle interfaceType);
    internal bool IsCastableEntry(RuntimeTypeHandle interfaceType, IntPtr& pComPtr, RuntimeTypeHandle& entryType);
    internal bool TryReadCachedNativeInterface(RuntimeTypeHandle interfaceType, IntPtr& pComPtr);
}
[McgComCallableAttribute]
internal class System.Runtime.InteropServices.StandardCustomPropertyProviderProxy : object {
    private object m_target;
    internal StandardCustomPropertyProviderProxy(object target);
    public sealed virtual object GetTarget();
}
internal class System.Runtime.InteropServices.STATSTG_UnsafeType : ValueType {
    public IntPtr pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
internal abstract class System.Runtime.InteropServices.StringMap : object {
    private int m_size;
    private FixedHashTable m_map;
    internal StringMap(int size);
    internal abstract virtual string GetString(int i);
    internal abstract virtual int GetStringHash(int i);
    internal abstract virtual bool IsStringEqual(string name, int i);
    internal int FindString(string name);
}
internal class System.Runtime.InteropServices.StringMap16 : StringMap {
    private StringPool m_pool;
    private UInt16[] m_indices;
    internal StringMap16(StringPool pool, UInt16[] indices);
    internal virtual string GetString(int i);
    internal virtual int GetStringHash(int i);
    internal virtual bool IsStringEqual(string name, int i);
}
internal class System.Runtime.InteropServices.StringMap32 : StringMap {
    private StringPool m_pool;
    private UInt32[] m_indices;
    internal StringMap32(StringPool pool, UInt32[] indices);
    internal virtual string GetString(int i);
    internal virtual int GetStringHash(int i);
    internal virtual bool IsStringEqual(string name, int i);
}
internal class System.Runtime.InteropServices.StringPool : object {
    private Byte[] m_typeNamespaces;
    private Byte[] m_typeNames;
    private UInt16[] m_indices;
    internal static byte Escape_Start;
    internal static byte Unicode_Mark;
    private static int Hash_Init;
    internal StringPool(Byte[] typeNamespaces, Byte[] typeNames, UInt16[] indices);
    internal string GetString(UInt32 nameIdx);
    internal static int HashAccumulate(int hash, char val);
    internal static int StableStringHash(string str);
    internal int StableStringHash(UInt32 nameIdx);
    internal bool IsStringEqual(string name, UInt32 nameIdx);
}
public static class System.Runtime.InteropServices.Toolbox : object {
    public static int IListThunk(IList`1<T> list, IList_Oper oper, int index, Object& item);
    public static object IListBlittableThunk(IList`1<T> list, IList_Oper oper, Int32& index, T& item);
    internal static bool EnsureIndexInt32(UInt32 index, UInt32 listCapacity, Int32& hr);
    public static int IReadOnlyListThunk(IReadOnlyList`1<T> list, IList_Oper oper, int index, T& item);
    public static object IReadOnlyListBlittableThunk(IReadOnlyList`1<T> list, IList_Oper oper, Int32& index, T& item);
}
internal enum System.Runtime.InteropServices.TrustLevel : Enum {
    public int value__;
    public static TrustLevel BaseTrust;
    public static TrustLevel PartialTrust;
    public static TrustLevel FullTrust;
}
[ExtensionAttribute]
internal static class System.Runtime.InteropServices.TypeHandleExtensions : object {
    private static IntPtr[] SharedCCWList;
    private static TypeHandleExtensions();
    [ExtensionAttribute]
internal static string GetDisplayName(RuntimeTypeHandle handle);
    [ExtensionAttribute]
internal static bool IsComClass(RuntimeTypeHandle handle);
    [ExtensionAttribute]
internal static bool IsIJupiterObject(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool IsIInspectable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool HasInterfaceData(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool IsSupportIInspectable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool HasDynamicAdapterClass(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDynamicAdapterClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static Guid GetInterfaceGuid(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetCcwVtableThunk(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetCcwVtable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static int GetMarshalIndex(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static McgInterfaceFlags GetInterfaceFlags(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDispatchClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetDelegateInvokeStub(RuntimeTypeHandle winrtDelegateType);
    [ExtensionAttribute]
internal static GCPressureRange GetGCPressureRange(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static bool IsSealed(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static ComMarshalingType GetMarshalingType(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDefaultInterface(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static string GetWinRTTypeName(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetIteratorType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetElementClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetElementInterfaceType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetVectorViewType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetAsyncOperationType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static int GetByteSize(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static string GetCCWRuntimeClassName(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static bool IsCCWTemplateSupported(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static bool IsCCWWinRTType(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static IEnumerable`1<RuntimeTypeHandle> GetImplementedInterfaces(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetBaseClass(RuntimeTypeHandle ccwType);
    private static void GetIIDsImpl(RuntimeTypeHandle typeHandle, List`1<Guid> iids);
    [ExtensionAttribute]
internal static List`1<Guid> GetIIDs(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static string StructWinRTName(RuntimeTypeHandle structType);
    [ExtensionAttribute]
internal static bool IsInvalid(RuntimeTypeHandle typeHandle);
}
internal enum System.Runtime.InteropServices.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Custom;
}
internal class System.Runtime.InteropServices.TypeName : ValueType {
    public HSTRING Name;
    public TypeKind Kind;
}
public static class System.Runtime.InteropServices.TypeOfHelper : object {
    private static void RuntimeTypeHandleOf_DidntGetTransformedAway();
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4, string arg5);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6);
    public static Type TypeOf(string typeName);
}
public class System.Runtime.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    internal bool IsEmpty { get; }
    internal sbyte AsI1 { get; internal set; }
    internal short AsI2 { get; internal set; }
    internal int AsI4 { get; internal set; }
    internal long AsI8 { get; internal set; }
    internal byte AsUi1 { get; internal set; }
    internal ushort AsUi2 { get; internal set; }
    internal UInt32 AsUi4 { get; internal set; }
    internal ulong AsUi8 { get; internal set; }
    internal int AsInt { get; internal set; }
    internal UInt32 AsUint { get; internal set; }
    internal bool AsBool { get; internal set; }
    internal float AsR4 { get; internal set; }
    internal double AsR8 { get; internal set; }
    internal decimal AsDecimal { get; internal set; }
    internal string AsBstr { get; internal set; }
    internal object AsUnknown { get; internal set; }
    public Variant(object value);
    public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    internal bool get_IsEmpty();
    internal sbyte get_AsI1();
    internal void set_AsI1(sbyte value);
    internal short get_AsI2();
    internal void set_AsI2(short value);
    internal int get_AsI4();
    internal void set_AsI4(int value);
    internal long get_AsI8();
    internal void set_AsI8(long value);
    internal byte get_AsUi1();
    internal void set_AsUi1(byte value);
    internal ushort get_AsUi2();
    internal void set_AsUi2(ushort value);
    internal UInt32 get_AsUi4();
    internal void set_AsUi4(UInt32 value);
    internal ulong get_AsUi8();
    internal void set_AsUi8(ulong value);
    internal int get_AsInt();
    internal void set_AsInt(int value);
    internal UInt32 get_AsUint();
    internal void set_AsUint(UInt32 value);
    internal bool get_AsBool();
    internal void set_AsBool(bool value);
    internal float get_AsR4();
    internal void set_AsR4(float value);
    internal double get_AsR8();
    internal void set_AsR8(double value);
    internal decimal get_AsDecimal();
    internal void set_AsDecimal(decimal value);
    internal string get_AsBstr();
    internal void set_AsBstr(string value);
    internal object get_AsUnknown();
    internal void set_AsUnknown(object value);
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactoryInternal {
    public abstract virtual object ActivateInstance();
}
public interface System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory {
    public abstract virtual void RunClassConstructor();
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_VariantTypeNotSupported { get; }
    internal static string Arg_InvalidThreshold { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeStringPtrNotAtom { get; }
    internal static string Arg_NeedNonNegNumRequired { get; }
    internal static string Arg_NotIsomorphic { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SizeOfNoTypeSizeInfo { get; }
    internal static string Arg_SizeOfNonValueType { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_ObjNotComObject { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Null_HString { get; }
    internal static string BadMarshalField_Null_HString { get; }
    internal static string ArrayWithOffsetOverflow { get; }
    internal static string InvalidOperation_HCCountOverflow { get; }
    internal static string StructArrayTooLarge { get; }
    internal static string CustomPropertyProvider_DataBindingError { get; }
    internal static string CustomPropertyProvider_MissingMetadata { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_MethodAccessException_WithMethodName { get; }
    internal static string Arg_RemovedTypeInstantiated { get; }
    internal static string Arg_NotImplementedInNonCoreApiSet { get; }
    internal static string Arg_DelegateTypeNotRecognized { get; }
    internal static string Arg_NoMarshalCreatedObjectUsedOutOfTreadContext { get; }
    internal static string Arg_UnexpectedTypeKind { get; }
    internal static string Arg_UnrecognizedTypeName { get; }
    internal static string Arg_InvalidCustomTypeNameValue { get; }
    internal static string Argument_MustHaveLayoutOrBeBlittable { get; }
    internal static string TypeNameMarshalling_MissingMetadata { get; }
    internal static string Excep_EnumNotStarted { get; }
    internal static string Excep_EnumEnded { get; }
    internal static string Excep_EnumFailedVersion { get; }
    internal static string Excep_NotSupported { get; }
    internal static string Excep_CollectionBackingListTooLarge { get; }
    internal static string Excep_KeyNotFound { get; }
    internal static string Excep_KeyCollectionSet { get; }
    internal static string Excep_ValueCollectionSet { get; }
    internal static string Excep_InsufficientSpaceToCopyCollection { get; }
    internal static string Excep_IndexOutOfArrayBounds { get; }
    internal static string Excep_CannotRemoveFromEmptyCollection { get; }
    internal static string Excep_IndexLargerThanMaxValue { get; }
    internal static string Excep_IndexOutOfRange { get; }
    internal static string Excep_AddingDuplicate { get; }
    internal static string Excep_FromHResult { get; }
    internal static string Excep_InvalidMarshalAs_Param { get; }
    internal static string Excep_InvalidMarshalAs_Field { get; }
    internal static string Excep_InvalidMarshalAs_Return { get; }
    internal static string Excep_InvalidComObject_NoRCW_Wrapper { get; }
    internal static string StructMarshalling_MissingInteropData { get; }
    internal static string DelegateMarshalling_MissingInteropData { get; }
    internal static string ComTypeMarshalling_MissingInteropData { get; }
    internal static string Not_Enough_Thunks { get; }
    internal static string Arg_NativeToManagedCall { get; }
    internal static string Arg_NeedsDefaultCtor { get; }
    internal static string Arg_OutSafeHandleAsFieldNotSupported { get; }
    internal static string PropertyValue_InvalidCoersion { get; }
    internal static string PropertyValue_InvalidCast { get; }
    internal static string Arg_MustBeDelegateType { get; }
    internal static string Arg_CriticalHandleCannotBeAbstract { get; }
    internal static string Arg_CriticalHandleMustHaveDefaultCtor { get; }
    internal static string Arg_CriticalHandleReverse { get; }
    internal static string Arg_OutCriticalHandleAsFieldNotSupported { get; }
    internal static string Argument_OffsetOfFieldNotFound { get; }
    internal static string Argument_StructMustNotBeValueClass { get; }
    internal static string Argument_NeedNonGenericObject { get; }
    internal static string InvalidCast_WinRT { get; }
    internal static string InvalidCast_Com { get; }
    internal static string MissingMetadataType { get; }
    internal static string DirectUI_Empty { get; }
    internal static string PInvoke_GetProcAddress_NoName { get; }
    internal static string PInvoke_LoadLib { get; }
    internal static string PInvoke_GetProcAddress { get; }
    internal static string TypeNotDelegate { get; }
    internal static string WrongSizeArrayInNStruct { get; }
    internal static string Arg_InteropMarshalUnmappableChar { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_VariantTypeNotSupported();
    internal static string get_Arg_InvalidThreshold();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeStringPtrNotAtom();
    internal static string get_Arg_NeedNonNegNumRequired();
    internal static string get_Arg_NotIsomorphic();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SizeOfNoTypeSizeInfo();
    internal static string get_Arg_SizeOfNonValueType();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_ObjNotComObject();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Null_HString();
    internal static string get_BadMarshalField_Null_HString();
    internal static string get_ArrayWithOffsetOverflow();
    internal static string get_InvalidOperation_HCCountOverflow();
    internal static string get_StructArrayTooLarge();
    internal static string get_CustomPropertyProvider_DataBindingError();
    internal static string get_CustomPropertyProvider_MissingMetadata();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_MethodAccessException_WithMethodName();
    internal static string get_Arg_RemovedTypeInstantiated();
    internal static string get_Arg_NotImplementedInNonCoreApiSet();
    internal static string get_Arg_DelegateTypeNotRecognized();
    internal static string get_Arg_NoMarshalCreatedObjectUsedOutOfTreadContext();
    internal static string get_Arg_UnexpectedTypeKind();
    internal static string get_Arg_UnrecognizedTypeName();
    internal static string get_Arg_InvalidCustomTypeNameValue();
    internal static string get_Argument_MustHaveLayoutOrBeBlittable();
    internal static string get_TypeNameMarshalling_MissingMetadata();
    internal static string get_Excep_EnumNotStarted();
    internal static string get_Excep_EnumEnded();
    internal static string get_Excep_EnumFailedVersion();
    internal static string get_Excep_NotSupported();
    internal static string get_Excep_CollectionBackingListTooLarge();
    internal static string get_Excep_KeyNotFound();
    internal static string get_Excep_KeyCollectionSet();
    internal static string get_Excep_ValueCollectionSet();
    internal static string get_Excep_InsufficientSpaceToCopyCollection();
    internal static string get_Excep_IndexOutOfArrayBounds();
    internal static string get_Excep_CannotRemoveFromEmptyCollection();
    internal static string get_Excep_IndexLargerThanMaxValue();
    internal static string get_Excep_IndexOutOfRange();
    internal static string get_Excep_AddingDuplicate();
    internal static string get_Excep_FromHResult();
    internal static string get_Excep_InvalidMarshalAs_Param();
    internal static string get_Excep_InvalidMarshalAs_Field();
    internal static string get_Excep_InvalidMarshalAs_Return();
    internal static string get_Excep_InvalidComObject_NoRCW_Wrapper();
    internal static string get_StructMarshalling_MissingInteropData();
    internal static string get_DelegateMarshalling_MissingInteropData();
    internal static string get_ComTypeMarshalling_MissingInteropData();
    internal static string get_Not_Enough_Thunks();
    internal static string get_Arg_NativeToManagedCall();
    internal static string get_Arg_NeedsDefaultCtor();
    internal static string get_Arg_OutSafeHandleAsFieldNotSupported();
    internal static string get_PropertyValue_InvalidCoersion();
    internal static string get_PropertyValue_InvalidCast();
    internal static string get_Arg_MustBeDelegateType();
    internal static string get_Arg_CriticalHandleCannotBeAbstract();
    internal static string get_Arg_CriticalHandleMustHaveDefaultCtor();
    internal static string get_Arg_CriticalHandleReverse();
    internal static string get_Arg_OutCriticalHandleAsFieldNotSupported();
    internal static string get_Argument_OffsetOfFieldNotFound();
    internal static string get_Argument_StructMustNotBeValueClass();
    internal static string get_Argument_NeedNonGenericObject();
    internal static string get_InvalidCast_WinRT();
    internal static string get_InvalidCast_Com();
    internal static string get_MissingMetadataType();
    internal static string get_DirectUI_Empty();
    internal static string get_PInvoke_GetProcAddress_NoName();
    internal static string get_PInvoke_LoadLib();
    internal static string get_PInvoke_GetProcAddress();
    internal static string get_TypeNotDelegate();
    internal static string get_WrongSizeArrayInNStruct();
    internal static string get_Arg_InteropMarshalUnmappableChar();
    internal static Type get_ResourceType();
}
public class System.Threading.Lock : object {
    private object _lock;
    public void Acquire();
    public void Release();
}
