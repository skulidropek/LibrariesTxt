internal static class Microsoft.ServiceFabric.Services.Client.ClientRequestTracker : object {
    internal static string CallContextKey;
    public static bool IsPresent();
    public static bool TryGet(String& callContextValue);
    public static void Set(string callContextValue);
}
public class Microsoft.ServiceFabric.Services.Client.CreateFabricClientDelegate : MulticastDelegate {
    public CreateFabricClientDelegate(object object, IntPtr method);
    public virtual FabricClient Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual FabricClient EndInvoke(IAsyncResult result);
}
public interface Microsoft.ServiceFabric.Services.Client.IServicePartitionResolver {
    public abstract virtual Task`1<ResolvedServicePartition> ResolveAsync(Uri serviceUri, ServicePartitionKey partitionKey, TimeSpan resolveTimeoutPerTry, TimeSpan maxRetryBackoffInterval, CancellationToken cancellationToken);
    public abstract virtual Task`1<ResolvedServicePartition> ResolveAsync(ResolvedServicePartition previousRsp, TimeSpan resolveTimeoutPerTry, TimeSpan maxRetryBackoffInterval, CancellationToken cancellationToken);
}
public class Microsoft.ServiceFabric.Services.Client.ServicePartitionKey : object {
    public static ServicePartitionKey Singleton;
    private ServicePartitionKind servicePartitionKind;
    private object value;
    public ServicePartitionKind Kind { get; }
    public object Value { get; }
    public ServicePartitionKey(long partitionKey);
    public ServicePartitionKey(string partitionKey);
    private static ServicePartitionKey();
    public ServicePartitionKind get_Kind();
    public object get_Value();
}
public class Microsoft.ServiceFabric.Services.Client.ServicePartitionResolver : object {
    public static TimeSpan DefaultResolveTimeout;
    public static TimeSpan DefaultMaxRetryBackoffInterval;
    private static string TraceType;
    private static object StaticLock;
    private static ServicePartitionResolver defaultResolver;
    private static RandomGenerator randomGenerator;
    private object thisLock;
    private CreateFabricClientDelegate createFabricClient;
    private CreateFabricClientDelegate recreateFabricClient;
    private FabricClient fabricClient;
    private ConcurrentDictionary`2<Uri, bool> registrationCache;
    [CompilerGeneratedAttribute]
private bool <UseNotification>k__BackingField;
    internal bool UseNotification { get; internal set; }
    public ServicePartitionResolver(CreateFabricClientDelegate createFabricClient, CreateFabricClientDelegate recreateFabricClient);
    public ServicePartitionResolver(CreateFabricClientDelegate createFabricClient);
    public ServicePartitionResolver(String[] connectionEndpoints);
    public ServicePartitionResolver(FabricClientSettings settings, String[] connectionEndpoints);
    public ServicePartitionResolver(SecurityCredentials credential, String[] connectionEndpoints);
    public ServicePartitionResolver(SecurityCredentials credential, FabricClientSettings settings, String[] connectionEndpoints);
    private static ServicePartitionResolver();
    [CompilerGeneratedAttribute]
internal bool get_UseNotification();
    [CompilerGeneratedAttribute]
internal void set_UseNotification(bool value);
    public static void SetDefault(ServicePartitionResolver defaultServiceResolver);
    public static ServicePartitionResolver GetDefault();
    public Task`1<ResolvedServicePartition> ResolveAsync(Uri serviceUri, ServicePartitionKey partitionKey, CancellationToken cancellationToken);
    public sealed virtual Task`1<ResolvedServicePartition> ResolveAsync(Uri serviceUri, ServicePartitionKey partitionKey, TimeSpan resolveTimeoutPerTry, TimeSpan maxRetryBackoffInterval, CancellationToken cancellationToken);
    public Task`1<ResolvedServicePartition> ResolveAsync(ResolvedServicePartition previousRsp, CancellationToken cancellationToken);
    public sealed virtual Task`1<ResolvedServicePartition> ResolveAsync(ResolvedServicePartition previousRsp, TimeSpan resolveTimeoutPerTry, TimeSpan maxRetryBackoffInterval, CancellationToken cancellationToken);
    private static Task`1<ResolvedServicePartition> ResolveSingletonPartitionAsync(FabricClient client, Uri serviceName, ResolvedServicePartition previousRsp, TimeSpan timeout, CancellationToken cancellationToken);
    private static Task`1<ResolvedServicePartition> ResolveNamedPartitionAsync(FabricClient client, Uri serviceName, string partitionKey, ResolvedServicePartition previousRsp, TimeSpan timeout, CancellationToken cancellationToken);
    private static Task`1<ResolvedServicePartition> ResolveInt64PartitionAsync(FabricClient client, Uri serviceName, long partitionKey, ResolvedServicePartition previousRsp, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Client.ServicePartitionResolver/<ResolveHelperAsync>d__30")]
private Task`1<ResolvedServicePartition> ResolveHelperAsync(Func`5<FabricClient, ResolvedServicePartition, TimeSpan, CancellationToken, Task`1<ResolvedServicePartition>> resolveFunc, ResolvedServicePartition previousRsp, TimeSpan resolveTimeout, TimeSpan maxRetryInterval, CancellationToken cancellationToken, Uri serviceUri);
    private FabricClient GetClient();
    private void ReportFaulted(FabricClient client);
}
[ExtensionAttribute]
public static class Microsoft.ServiceFabric.Services.Client.ServicePartitionResolverExtensions : object {
    [ExtensionAttribute]
public static ServicePartitionResolver DisableNotification(ServicePartitionResolver partitionResolver);
}
internal static class Microsoft.ServiceFabric.Services.Common.DebugUtility : object {
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultDebugAttachWaitDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <DefaultDebugAttachCheckDuration>k__BackingField;
    public static TimeSpan DefaultDebugAttachWaitDuration { get; public set; }
    public static TimeSpan DefaultDebugAttachCheckDuration { get; public set; }
    private static DebugUtility();
    [CompilerGeneratedAttribute]
public static TimeSpan get_DefaultDebugAttachWaitDuration();
    [CompilerGeneratedAttribute]
public static void set_DefaultDebugAttachWaitDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_DefaultDebugAttachCheckDuration();
    [CompilerGeneratedAttribute]
public static void set_DefaultDebugAttachCheckDuration(TimeSpan value);
    public static void WaitForDebuggerAttach();
    public static void WaitForDebuggerAttach(TimeSpan waitDuration);
    public static void WaitForDebuggerAttach(TimeSpan waitDuration, TimeSpan checkDelay);
}
internal class Microsoft.ServiceFabric.Services.Common.ExclusiveFileStream : object {
    private static int MaxAttempts;
    private static int MaxRetryIntervalMillis;
    private static int MinRetryIntervalMillis;
    private static Random Rand;
    [CompilerGeneratedAttribute]
private FileStream <Value>k__BackingField;
    public FileStream Value { get; private set; }
    private ExclusiveFileStream(FileStream stream);
    private static ExclusiveFileStream();
    [CompilerGeneratedAttribute]
public FileStream get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(FileStream value);
    public static ExclusiveFileStream Acquire(string path, FileMode fileMode, FileShare fileShare, FileAccess fileAccess);
    public sealed virtual void Dispose();
}
internal static class Microsoft.ServiceFabric.Services.Common.IdUtil : object {
    internal static int ComputeId(MethodInfo methodInfo);
    internal static int ComputeId(Type type);
    internal static int ComputeIdWithCRC(Type type);
    internal static int ComputeIdWithCRC(MethodInfo methodInfo);
    internal static int ComputeIdWithCRC(string typeName);
    internal static int ComputeId(string typeName, string typeNamespace);
    internal static int HashCombine(int newKey, int currentKey);
}
internal class Microsoft.ServiceFabric.Services.Common.RwLock : object {
    private ReaderWriterLockSlim rwLock;
    public IDisposable AcquireWriteLock();
    public IDisposable AcquireReadLock();
}
internal static class Microsoft.ServiceFabric.Services.Common.SerializationUtility : object {
    public static Byte[] Serialize(DataContractSerializer serializer, object msg);
    public static object Deserialize(DataContractSerializer serializer, Byte[] buffer);
}
internal static class Microsoft.ServiceFabric.Services.Common.TaskDone : object {
    private static Task`1<bool> DoneConstant;
    public static Task Done { get; }
    private static TaskDone();
    public static Task get_Done();
}
internal static class Microsoft.ServiceFabric.Services.Common.TaskDone`1 : object {
    private static Task`1<T> DoneConstant;
    public static Task`1<T> Done { get; }
    private static TaskDone`1();
    public static Task`1<T> get_Done();
}
internal class Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientCache`1 : object {
    private static string TraceType;
    private string traceId;
    private ConcurrentDictionary`2<Guid, PartitionClientCache<TCommunicationClient>> clientCache;
    private Timer cacheCleanupTimer;
    private double cleanupTimerIntervalSeconds;
    private int cleanupTimerMaxRandomizationInterval;
    private Random random;
    public CommunicationClientCache`1(string traceId);
    public CommunicationClientCacheEntry`1<TCommunicationClient> GetOrAddClientCacheEntry(Guid partitionId, ResolvedServiceEndpoint endpoint, string listenerName, ResolvedServicePartition rsp);
    public bool TryGetClientCacheEntry(Guid partitionId, ResolvedServiceEndpoint endpoint, string listenerName, CommunicationClientCacheEntry`1& cacheEntry);
    public void ClearClientCacheEntries(Guid partitionId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private TimeSpan GetNextCleanupTimerDueTimeSeconds();
    private PartitionClientCache<TCommunicationClient> CreatePartitionClientCache(Guid partitionId);
    private void CacheCleanupTimerCallback();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(object state);
}
internal class Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientCacheEntry`1 : object {
    private ResolvedServiceEndpoint endpoint;
    private string address;
    private ResolvedServicePartition rsp;
    private TCommunicationClient client;
    private WeakReference clientWRef;
    private bool isInCache;
    [CompilerGeneratedAttribute]
private SemaphoreSlim <Semaphore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListenerName>k__BackingField;
    public SemaphoreSlim Semaphore { get; private set; }
    public string ListenerName { get; public set; }
    public ResolvedServicePartition Rsp { get; public set; }
    public TCommunicationClient Client { get; public set; }
    public ResolvedServiceEndpoint Endpoint { get; public set; }
    public bool IsInCache { get; public set; }
    [CompilerGeneratedAttribute]
public SemaphoreSlim get_Semaphore();
    [CompilerGeneratedAttribute]
private void set_Semaphore(SemaphoreSlim value);
    [CompilerGeneratedAttribute]
public string get_ListenerName();
    [CompilerGeneratedAttribute]
public void set_ListenerName(string value);
    public ResolvedServicePartition get_Rsp();
    public void set_Rsp(ResolvedServicePartition value);
    public TCommunicationClient get_Client();
    public void set_Client(TCommunicationClient value);
    public ResolvedServiceEndpoint get_Endpoint();
    public void set_Endpoint(ResolvedServiceEndpoint value);
    public bool get_IsInCache();
    public void set_IsInCache(bool value);
    public bool IsCommunicationClientValid();
    public string GetEndpoint();
    private string GetEndpointAddressForNamedEndpoint();
}
public class Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientEventArgs : CommunicationClientEventArgs`1<ICommunicationClient> {
}
public class Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private TCommunicationClient <Client>k__BackingField;
    public TCommunicationClient Client { get; public set; }
    [CompilerGeneratedAttribute]
public TCommunicationClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(TCommunicationClient value);
}
public abstract class Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1 : object {
    private static string TraceType;
    private static Task completedTask;
    private static TimeSpan defaultDelay;
    private IServicePartitionResolver servicePartitionResolver;
    private List`1<IExceptionHandler> exceptionHandlers;
    private CommunicationClientCache`1<TCommunicationClient> cache;
    private string traceId;
    private object randomLock;
    private bool fireConnectEvents;
    private Random random;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> ClientConnected;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> ClientDisconnected;
    public IServicePartitionResolver ServiceResolver { get; }
    public IEnumerable`1<IExceptionHandler> ExceptionHandlers { get; }
    protected string TraceId { get; }
    protected CommunicationClientFactoryBase`1(IServicePartitionResolver servicePartitionResolver, IEnumerable`1<IExceptionHandler> exceptionHandlers, string traceId);
    protected CommunicationClientFactoryBase`1(bool fireConnectEvents, IServicePartitionResolver servicePartitionResolver, IEnumerable`1<IExceptionHandler> exceptionHandlers, string traceId);
    private static CommunicationClientFactoryBase`1();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ClientConnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ClientConnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ClientDisconnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ClientDisconnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    public IServicePartitionResolver get_ServiceResolver();
    public IEnumerable`1<IExceptionHandler> get_ExceptionHandlers();
    protected string get_TraceId();
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<GetClientAsync>d__24")]
public sealed virtual Task`1<TCommunicationClient> GetClientAsync(Uri serviceUri, ServicePartitionKey partitionKey, TargetReplicaSelector targetReplicaSelector, string listenerName, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<GetClientAsync>d__25")]
public sealed virtual Task`1<TCommunicationClient> GetClientAsync(ResolvedServicePartition previousRsp, TargetReplicaSelector targetReplica, string listenerName, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<ReportOperationExceptionAsync>d__26")]
public sealed virtual Task`1<OperationRetryControl> ReportOperationExceptionAsync(TCommunicationClient client, ExceptionInformation exceptionInformation, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
    public virtual void Dispose();
    internal void OnClientDisconnected(TCommunicationClient faultedClient);
    internal void OnClientConnected(TCommunicationClient newClient);
    protected abstract virtual bool ValidateClient(TCommunicationClient client);
    protected abstract virtual bool ValidateClient(string endpoint, TCommunicationClient client);
    protected abstract virtual Task`1<TCommunicationClient> CreateClientAsync(string endpoint, CancellationToken cancellationToken);
    protected virtual Task OpenClient(TCommunicationClient client, CancellationToken cancellationToken);
    protected abstract virtual void AbortClient(TCommunicationClient client);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<CreateClientWithRetriesAsync>d__35")]
private Task`1<TCommunicationClient> CreateClientWithRetriesAsync(ResolvedServicePartition previousRsp, TargetReplicaSelector targetReplicaSelector, string listenerName, OperationRetrySettings retrySettings, bool doInitialResolve, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<CreateNewClientAsync>d__36")]
private Task`1<TCommunicationClient> CreateNewClientAsync(string listenerName, string requestId, ResolvedServicePartition previousRsp, CommunicationClientCacheEntry`1<TCommunicationClient> cacheEntry, CancellationToken cancellationToken);
    private bool ShouldCreateNewClient(CommunicationClientCacheEntry`1<TCommunicationClient> cacheEntry);
    private bool HandleReportedException(ExceptionInformation exceptionInformation, OperationRetrySettings retrySettings, ExceptionHandlingResult& result);
    private bool TryHandleException(ExceptionInformation exceptionInformation, OperationRetrySettings retrySettings, ExceptionHandlingResult& result);
    private ResolvedServiceEndpoint GetEndpoint(ResolvedServicePartition rsp, TargetReplicaSelector targetReplica);
    private bool ValidateClientCacheEntry(CommunicationClientCacheEntry`1<TCommunicationClient> cacheEntry, ResolvedServicePartition previousRsp, string requestId, ResolvedServiceEndpoint endpoint, string listenerName, int currentRetryCount, TCommunicationClient& client);
    private int NextRandom(int upperBound);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.CommunicationClientFactoryBase`1/<GetAndLockClientCacheEntryAsync>d__43")]
private Task`1<CommunicationClientCacheEntry`1<TCommunicationClient>> GetAndLockClientCacheEntryAsync(Guid partitionId, ResolvedServiceEndpoint endpoint, string listenerName, ResolvedServicePartition rsp, CancellationToken cancellationToken);
    private bool ValidateLockedClientCacheEntry(CommunicationClientCacheEntry`1<TCommunicationClient> cacheEntry, ResolvedServicePartition rsp, TCommunicationClient& client);
    private int GenerateSeed();
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ConstantRetryPolicy : object {
    private static Random Rand;
    private TimeSpan maxRetryBackoffIntervalOnNonTransientErrors;
    private int maxRetryCountOnNonTransientErrors;
    private TimeSpan maxRetryBackoffIntervalOnTransientErrors;
    private int totalNumberOfRetries;
    private TimeSpan clientRetryTimeout;
    public int TotalNumberOfRetries { get; }
    public TimeSpan ClientRetryTimeout { get; }
    public TimeSpan MaxRetryBackoffIntervalOnNonTransientErrors { get; }
    public TimeSpan MaxRetryBackoffIntervalOnTransientErrors { get; }
    public int MaxRetryCountOnNonTransientErrors { get; }
    public ConstantRetryPolicy(TimeSpan maxRetryBackoffIntervalOnTransientErrors, TimeSpan maxRetryBackoffIntervalOnNonTransientErrors, int maxRetryCount, int maxRetryCountOnNonTransientErrors, TimeSpan clientRetryTimeout);
    private static ConstantRetryPolicy();
    public sealed virtual int get_TotalNumberOfRetries();
    public sealed virtual TimeSpan get_ClientRetryTimeout();
    public TimeSpan get_MaxRetryBackoffIntervalOnNonTransientErrors();
    public TimeSpan get_MaxRetryBackoffIntervalOnTransientErrors();
    public int get_MaxRetryCountOnNonTransientErrors();
    public sealed virtual TimeSpan GetNextRetryDelay(RetryDelayParameters retryDelayParameters);
}
public abstract class Microsoft.ServiceFabric.Services.Communication.Client.ExceptionHandlingResult : object {
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ExceptionHandlingRetryResult : ExceptionHandlingResult {
    private static Random Rand;
    private bool isTransient;
    private OperationRetrySettings retrySettings;
    private string exceptionId;
    private TimeSpan retryDelay;
    private int maxRetryCount;
    public bool IsTransient { get; }
    public string ExceptionId { get; }
    public int MaxRetryCount { get; }
    public TimeSpan RetryDelay { get; }
    public ExceptionHandlingRetryResult(Exception exception, bool isTransient, TimeSpan retryDelay, int maxRetryCount);
    public ExceptionHandlingRetryResult(string exceptionId, bool isTransient, TimeSpan retryDelay, int maxRetryCount);
    public ExceptionHandlingRetryResult(Exception exception, bool isTransient, OperationRetrySettings retrySettings, int maxRetryCount);
    internal ExceptionHandlingRetryResult(Exception exception, bool isTransient, OperationRetrySettings retrySettings);
    private static ExceptionHandlingRetryResult();
    public bool get_IsTransient();
    public string get_ExceptionId();
    public int get_MaxRetryCount();
    public TimeSpan get_RetryDelay();
    public TimeSpan GetRetryDelay(int retryAttempt);
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ExceptionHandlingThrowResult : ExceptionHandlingResult {
    [CompilerGeneratedAttribute]
private Exception <ExceptionToThrow>k__BackingField;
    public Exception ExceptionToThrow { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_ExceptionToThrow();
    [CompilerGeneratedAttribute]
public void set_ExceptionToThrow(Exception value);
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ExceptionInformation : object {
    private Exception exception;
    private TargetReplicaSelector targetReplica;
    public Exception Exception { get; }
    public TargetReplicaSelector TargetReplica { get; }
    public ExceptionInformation(Exception exception);
    public ExceptionInformation(Exception exception, TargetReplicaSelector targetReplica);
    public Exception get_Exception();
    public TargetReplicaSelector get_TargetReplica();
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ExponentialRetryPolicy : object {
    private static RandomGenerator RandomGenerator;
    private TimeSpan maxRetryJitter;
    [CompilerGeneratedAttribute]
private static int <MaxDelayMultiplier>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <SameDelayRequestCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalNumberOfRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ClientRetryTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BaseRetryDelay>k__BackingField;
    public static int MaxDelayMultiplier { get; public set; }
    public static int SameDelayRequestCounter { get; public set; }
    public int TotalNumberOfRetries { get; }
    public TimeSpan ClientRetryTimeout { get; }
    public TimeSpan BaseRetryDelay { get; public set; }
    public ExponentialRetryPolicy(int defaultMaxRetryCount, TimeSpan clientRetryTimeout);
    internal ExponentialRetryPolicy(int defaultMaxRetryCount, TimeSpan maxRetryJitter, TimeSpan clientRetryTimeout);
    private static ExponentialRetryPolicy();
    [CompilerGeneratedAttribute]
public static int get_MaxDelayMultiplier();
    [CompilerGeneratedAttribute]
public static void set_MaxDelayMultiplier(int value);
    [CompilerGeneratedAttribute]
public static int get_SameDelayRequestCounter();
    [CompilerGeneratedAttribute]
public static void set_SameDelayRequestCounter(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TotalNumberOfRetries();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ClientRetryTimeout();
    [CompilerGeneratedAttribute]
public TimeSpan get_BaseRetryDelay();
    [CompilerGeneratedAttribute]
public void set_BaseRetryDelay(TimeSpan value);
    public sealed virtual TimeSpan GetNextRetryDelay(RetryDelayParameters retryDelayParameters);
}
public interface Microsoft.ServiceFabric.Services.Communication.Client.ICommunicationClient {
    public ResolvedServicePartition ResolvedServicePartition { get; public set; }
    public string ListenerName { get; public set; }
    public ResolvedServiceEndpoint Endpoint { get; public set; }
    public abstract virtual ResolvedServicePartition get_ResolvedServicePartition();
    public abstract virtual void set_ResolvedServicePartition(ResolvedServicePartition value);
    public abstract virtual string get_ListenerName();
    public abstract virtual void set_ListenerName(string value);
    public abstract virtual ResolvedServiceEndpoint get_Endpoint();
    public abstract virtual void set_Endpoint(ResolvedServiceEndpoint value);
}
public interface Microsoft.ServiceFabric.Services.Communication.Client.ICommunicationClientFactory`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ClientConnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ClientConnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ClientDisconnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ClientDisconnected(EventHandler`1<CommunicationClientEventArgs`1<TCommunicationClient>> value);
    public abstract virtual Task`1<TCommunicationClient> GetClientAsync(Uri serviceUri, ServicePartitionKey partitionKey, TargetReplicaSelector targetReplicaSelector, string listenerName, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
    public abstract virtual Task`1<TCommunicationClient> GetClientAsync(ResolvedServicePartition previousRsp, TargetReplicaSelector targetReplicaSelector, string listenerName, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
    public abstract virtual Task`1<OperationRetryControl> ReportOperationExceptionAsync(TCommunicationClient client, ExceptionInformation exceptionInformation, OperationRetrySettings retrySettings, CancellationToken cancellationToken);
}
public interface Microsoft.ServiceFabric.Services.Communication.Client.IExceptionHandler {
    public abstract virtual bool TryHandleException(ExceptionInformation exceptionInformation, OperationRetrySettings retrySettings, ExceptionHandlingResult& result);
}
public interface Microsoft.ServiceFabric.Services.Communication.Client.IRetryPolicy {
    public int TotalNumberOfRetries { get; }
    public TimeSpan ClientRetryTimeout { get; }
    public abstract virtual int get_TotalNumberOfRetries();
    public abstract virtual TimeSpan get_ClientRetryTimeout();
    public abstract virtual TimeSpan GetNextRetryDelay(RetryDelayParameters retryDelayParameters);
}
public interface Microsoft.ServiceFabric.Services.Communication.Client.IServicePartitionClient`1 {
    public Uri ServiceUri { get; }
    public ServicePartitionKey PartitionKey { get; }
    public TargetReplicaSelector TargetReplicaSelector { get; }
    public string ListenerName { get; }
    public ICommunicationClientFactory`1<TCommunicationClient> Factory { get; }
    public abstract virtual Uri get_ServiceUri();
    public abstract virtual ServicePartitionKey get_PartitionKey();
    public abstract virtual TargetReplicaSelector get_TargetReplicaSelector();
    public abstract virtual string get_ListenerName();
    public abstract virtual ICommunicationClientFactory`1<TCommunicationClient> get_Factory();
    public abstract virtual bool TryGetLastResolvedServicePartition(ResolvedServicePartition& resolvedServicePartition);
}
public class Microsoft.ServiceFabric.Services.Communication.Client.OperationRetryControl : object {
    [CompilerGeneratedAttribute]
private bool <ShouldRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTransient>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<int, TimeSpan> <GetRetryDelay>k__BackingField;
    public bool ShouldRetry { get; public set; }
    public bool IsTransient { get; public set; }
    public TimeSpan RetryDelay { get; public set; }
    public string ExceptionId { get; public set; }
    public int MaxRetryCount { get; public set; }
    public Exception Exception { get; public set; }
    public Func`2<int, TimeSpan> GetRetryDelay { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShouldRetry();
    [CompilerGeneratedAttribute]
public void set_ShouldRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTransient();
    [CompilerGeneratedAttribute]
public void set_IsTransient(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_ExceptionId();
    [CompilerGeneratedAttribute]
public void set_ExceptionId(string value);
    [CompilerGeneratedAttribute]
public int get_MaxRetryCount();
    [CompilerGeneratedAttribute]
public void set_MaxRetryCount(int value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public Func`2<int, TimeSpan> get_GetRetryDelay();
    [CompilerGeneratedAttribute]
public void set_GetRetryDelay(Func`2<int, TimeSpan> value);
}
public class Microsoft.ServiceFabric.Services.Communication.Client.OperationRetrySettings : object {
    private IRetryPolicy retryPolicy;
    public TimeSpan MaxRetryBackoffIntervalOnTransientErrors { get; }
    public TimeSpan MaxRetryBackoffIntervalOnNonTransientErrors { get; }
    public int DefaultMaxRetryCountForTransientErrors { get; }
    public int DefaultMaxRetryCountForNonTransientErrors { get; }
    public TimeSpan ClientRetryTimeout { get; }
    public IRetryPolicy RetryPolicy { get; }
    public OperationRetrySettings(TimeSpan clientRetryTimeout);
    public OperationRetrySettings(IRetryPolicy retryPolicy);
    public OperationRetrySettings(TimeSpan maxRetryBackoffIntervalOnTransientErrors, TimeSpan maxRetryBackoffIntervalOnNonTransientErrors, int defaultMaxRetryCountForTransientErrors, int defaultMaxRetryCountForNonTransientErrors);
    public TimeSpan get_MaxRetryBackoffIntervalOnTransientErrors();
    public TimeSpan get_MaxRetryBackoffIntervalOnNonTransientErrors();
    public int get_DefaultMaxRetryCountForTransientErrors();
    public int get_DefaultMaxRetryCountForNonTransientErrors();
    public TimeSpan get_ClientRetryTimeout();
    public IRetryPolicy get_RetryPolicy();
}
internal class Microsoft.ServiceFabric.Services.Communication.Client.RandomGenerator : object {
    private object randomLock;
    private Random rand;
    public double NextDouble();
}
internal class Microsoft.ServiceFabric.Services.Communication.Client.ResolvedServicePartitionClient : object {
    [CompilerGeneratedAttribute]
private ResolvedServicePartition <Rsp>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommunicationClient <Client>k__BackingField;
    public ResolvedServicePartition Rsp { get; public set; }
    public ICommunicationClient Client { get; public set; }
    public ResolvedServicePartitionClient(ResolvedServicePartitionClient other);
    [CompilerGeneratedAttribute]
public ResolvedServicePartition get_Rsp();
    [CompilerGeneratedAttribute]
public void set_Rsp(ResolvedServicePartition value);
    [CompilerGeneratedAttribute]
public ICommunicationClient get_Client();
    [CompilerGeneratedAttribute]
public void set_Client(ICommunicationClient value);
}
public class Microsoft.ServiceFabric.Services.Communication.Client.RetryDelayParameters : object {
    private int retryAttempt;
    private bool isTransient;
    public bool IsTransient { get; }
    public int RetryAttempt { get; }
    public RetryDelayParameters(int retryAttempt, bool isTransient);
    public bool get_IsTransient();
    public int get_RetryAttempt();
}
public class Microsoft.ServiceFabric.Services.Communication.Client.ServicePartitionClient`1 : object {
    private static string TraceType;
    private ICommunicationClientFactory`1<TCommunicationClient> communicationClientFactory;
    private SemaphoreSlim communicationClientLock;
    private Uri serviceUri;
    private ServicePartitionKey partitionKey;
    private TargetReplicaSelector targetReplicaSelector;
    private string listenerName;
    private OperationRetrySettings retrySettings;
    private TCommunicationClient communicationClient;
    private ResolvedServicePartition modreq(System.Runtime.CompilerServices.IsVolatile) lastRsp;
    public ICommunicationClientFactory`1<TCommunicationClient> Factory { get; }
    public Uri ServiceUri { get; }
    public ServicePartitionKey PartitionKey { get; }
    public TargetReplicaSelector TargetReplicaSelector { get; }
    public string ListenerName { get; }
    public ServicePartitionClient`1(ICommunicationClientFactory`1<TCommunicationClient> communicationClientFactory, Uri serviceUri, ServicePartitionKey partitionKey, TargetReplicaSelector targetReplicaSelector, string listenerName, OperationRetrySettings retrySettings);
    public sealed virtual ICommunicationClientFactory`1<TCommunicationClient> get_Factory();
    public sealed virtual Uri get_ServiceUri();
    public sealed virtual ServicePartitionKey get_PartitionKey();
    public sealed virtual TargetReplicaSelector get_TargetReplicaSelector();
    public sealed virtual string get_ListenerName();
    public sealed virtual bool TryGetLastResolvedServicePartition(ResolvedServicePartition& resolvedServicePartition);
    public virtual Task`1<TResult> InvokeWithRetryAsync(Func`2<TCommunicationClient, Task`1<TResult>> func, Type[] doNotRetryExceptionTypes);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.ServicePartitionClient`1/<InvokeWithRetryAsync>d__23`1")]
public virtual Task`1<TResult> InvokeWithRetryAsync(Func`2<TCommunicationClient, Task`1<TResult>> func, CancellationToken cancellationToken, Type[] doNotRetryExceptionTypes);
    public Task InvokeWithRetryAsync(Func`2<TCommunicationClient, Task> func, Type[] doNotRetryExceptionTypes);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.ServicePartitionClient`1/<InvokeWithRetryAsync>d__25")]
public Task InvokeWithRetryAsync(Func`2<TCommunicationClient, Task> func, CancellationToken cancellationToken, Type[] doNotRetryExceptionTypes);
    [ObsoleteAttribute("Use InvokeWithRetryAsync Api instead ")]
public TResult InvokeWithRetry(Func`2<TCommunicationClient, TResult> func, Type[] doNotRetryExceptionTypes);
    [ObsoleteAttribute("Use InvokeWithRetryAsync Api instead ")]
public void InvokeWithRetry(Action`1<TCommunicationClient> func, Type[] doNotRetryExceptionTypes);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.ServicePartitionClient`1/<GetCommunicationClientAsync>d__28")]
private Task`1<TCommunicationClient> GetCommunicationClientAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Communication.Client.ServicePartitionClient`1/<ResetCommunicationClientAsync>d__29")]
private Task ResetCommunicationClientAsync();
}
public enum Microsoft.ServiceFabric.Services.Communication.Client.TargetReplicaSelector : Enum {
    public int value__;
    public static TargetReplicaSelector Default;
    public static TargetReplicaSelector RandomInstance;
    public static TargetReplicaSelector PrimaryReplica;
    public static TargetReplicaSelector RandomReplica;
    public static TargetReplicaSelector RandomSecondaryReplica;
}
internal class Microsoft.ServiceFabric.Services.Communication.Client.Utility : object {
    internal static bool ShouldRetryOperation(string currentExceptionId, int maxRetryCount, String& lastSeenExceptionId, Int32& currentRetryCount);
}
internal class Microsoft.ServiceFabric.Services.Communication.Runtime.CommunicationListenerInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommunicationListener <Listener>k__BackingField;
    internal string Name { get; internal set; }
    internal ICommunicationListener Listener { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal ICommunicationListener get_Listener();
    [CompilerGeneratedAttribute]
internal void set_Listener(ICommunicationListener value);
}
public interface Microsoft.ServiceFabric.Services.Communication.Runtime.ICommunicationListener {
    public abstract virtual Task`1<string> OpenAsync(CancellationToken cancellationToken);
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
    public abstract virtual void Abort();
}
public class Microsoft.ServiceFabric.Services.Communication.Runtime.ServiceInstanceListener : object {
    public static string DefaultName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<StatelessServiceContext, ICommunicationListener> <CreateCommunicationListener>k__BackingField;
    public string Name { get; private set; }
    public Func`2<StatelessServiceContext, ICommunicationListener> CreateCommunicationListener { get; private set; }
    public ServiceInstanceListener(Func`2<StatelessServiceContext, ICommunicationListener> createCommunicationListener, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Func`2<StatelessServiceContext, ICommunicationListener> get_CreateCommunicationListener();
    [CompilerGeneratedAttribute]
private void set_CreateCommunicationListener(Func`2<StatelessServiceContext, ICommunicationListener> value);
}
public class Microsoft.ServiceFabric.Services.Communication.Runtime.ServiceReplicaListener : object {
    public static string DefaultName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ListenOnSecondary>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<StatefulServiceContext, ICommunicationListener> <CreateCommunicationListener>k__BackingField;
    public string Name { get; private set; }
    public bool ListenOnSecondary { get; private set; }
    public Func`2<StatefulServiceContext, ICommunicationListener> CreateCommunicationListener { get; private set; }
    public ServiceReplicaListener(Func`2<StatefulServiceContext, ICommunicationListener> createCommunicationListener, string name, bool listenOnSecondary);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_ListenOnSecondary();
    [CompilerGeneratedAttribute]
private void set_ListenOnSecondary(bool value);
    [CompilerGeneratedAttribute]
public Func`2<StatefulServiceContext, ICommunicationListener> get_CreateCommunicationListener();
    [CompilerGeneratedAttribute]
private void set_CreateCommunicationListener(Func`2<StatefulServiceContext, ICommunicationListener> value);
}
[DataContractAttribute]
public class Microsoft.ServiceFabric.Services.Communication.ServiceEndpointCollection : object {
    [DataMemberAttribute]
private Dictionary`2<string, string> endpoints;
    private object endpointsLock;
    public ServiceEndpointCollection(string listenerName, string endpointAddress);
    public static bool TryParseEndpointsString(string endpointsString, ServiceEndpointCollection& serviceEndpoints);
    public void AddEndpoints(ServiceEndpointCollection newEndpoints);
    public void AddEndpoint(string listenerName, string endpointAddress);
    public bool TryGetFirstEndpointAddress(String& endpointAddress);
    public bool TryGetEndpointAddress(string listenerName, String& endpointAddress);
    public virtual string ToString();
    public IReadOnlyDictionary`2<string, string> ToReadOnlyDictionary();
    private void AddEndpointCallerHoldsLock(string listenerName, string endpointAddress);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext c);
}
public class Microsoft.ServiceFabric.Services.Communication.ServiceException : Exception {
    [CompilerGeneratedAttribute]
private string <ActualExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActualExceptionStackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ActualExceptionData>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ServiceException> <ActualInnerExceptions>k__BackingField;
    public string ActualExceptionType { get; private set; }
    public string ActualExceptionStackTrace { get; public set; }
    public Dictionary`2<string, string> ActualExceptionData { get; public set; }
    public List`1<ServiceException> ActualInnerExceptions { get; public set; }
    public ServiceException(string actualExceptionType, string message);
    [CompilerGeneratedAttribute]
public string get_ActualExceptionType();
    [CompilerGeneratedAttribute]
private void set_ActualExceptionType(string value);
    [CompilerGeneratedAttribute]
public string get_ActualExceptionStackTrace();
    [CompilerGeneratedAttribute]
public void set_ActualExceptionStackTrace(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ActualExceptionData();
    [CompilerGeneratedAttribute]
public void set_ActualExceptionData(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public List`1<ServiceException> get_ActualInnerExceptions();
    [CompilerGeneratedAttribute]
public void set_ActualInnerExceptions(List`1<ServiceException> value);
}
[DataContractAttribute]
internal class Microsoft.ServiceFabric.Services.Communication.ServiceExceptionData : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [DataMemberAttribute]
public string Type { get; private set; }
    [DataMemberAttribute]
public string Message { get; private set; }
    public ServiceExceptionData(string type, string message);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
internal static class Microsoft.ServiceFabric.Services.Constants : object {
    public static string ServiceCommunicationNamespace;
}
internal static class Microsoft.ServiceFabric.Services.CRC64 : object {
    private static UInt64[] Crc64Table;
    private static CRC64();
    public static ulong ToCRC64(Byte[] value);
    public static ulong ToCRC64(Byte[][] values);
    public static string ToCrc64String(Byte[] value);
}
internal class Microsoft.ServiceFabric.Services.LogContext : object {
    internal static string LogContextKey;
    [CompilerGeneratedAttribute]
private Guid <RequestId>k__BackingField;
    public Guid RequestId { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_RequestId();
    [CompilerGeneratedAttribute]
public void set_RequestId(Guid value);
    public static bool IsPresent();
    public static bool TryGet(LogContext& logContext);
    public static void Set(LogContext logContext);
    public static void Clear();
    public static Guid GetRequestIdOrDefault();
}
internal interface Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica {
    unknown IReadOnlyDictionary`2<string, string> Addresses {public set; }
    unknown IStatefulServicePartition Partition {public set; }
    public abstract virtual void set_Addresses(IReadOnlyDictionary`2<string, string> value);
    public abstract virtual void set_Partition(IStatefulServicePartition value);
    public abstract virtual IStateProviderReplica CreateStateProviderReplica();
    public abstract virtual IEnumerable`1<ServiceReplicaListener> CreateServiceReplicaListeners();
    public abstract virtual Task RunAsync(CancellationToken cancellationToken);
    public abstract virtual Task OnOpenAsync(ReplicaOpenMode openMode, CancellationToken cancellationToken);
    public abstract virtual Task OnChangeRoleAsync(ReplicaRole newRole, CancellationToken cancellationToken);
    public abstract virtual Task OnCloseAsync(CancellationToken cancellationToken);
    public abstract virtual void OnAbort();
}
internal interface Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance {
    unknown IReadOnlyDictionary`2<string, string> Addresses {public set; }
    unknown IStatelessServicePartition Partition {public set; }
    public abstract virtual void set_Addresses(IReadOnlyDictionary`2<string, string> value);
    public abstract virtual void set_Partition(IStatelessServicePartition value);
    public abstract virtual IEnumerable`1<ServiceInstanceListener> CreateServiceInstanceListeners();
    public abstract virtual Task RunAsync(CancellationToken cancellationToken);
    public abstract virtual Task OnOpenAsync(CancellationToken cancellationToken);
    public abstract virtual Task OnCloseAsync(CancellationToken cancellationToken);
    public abstract virtual void OnAbort();
}
internal class Microsoft.ServiceFabric.Services.Runtime.RuntimeContext : object {
    private static object SharedContextLock;
    private static RuntimeContext sharedContext;
    [CompilerGeneratedAttribute]
private FabricRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private ICodePackageActivationContext <CodePackageContext>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeContext <NodeContext>k__BackingField;
    public FabricRuntime Runtime { get; private set; }
    public ICodePackageActivationContext CodePackageContext { get; private set; }
    public NodeContext NodeContext { get; private set; }
    private static RuntimeContext();
    [CompilerGeneratedAttribute]
public FabricRuntime get_Runtime();
    [CompilerGeneratedAttribute]
private void set_Runtime(FabricRuntime value);
    [CompilerGeneratedAttribute]
public ICodePackageActivationContext get_CodePackageContext();
    [CompilerGeneratedAttribute]
private void set_CodePackageContext(ICodePackageActivationContext value);
    [CompilerGeneratedAttribute]
public NodeContext get_NodeContext();
    [CompilerGeneratedAttribute]
private void set_NodeContext(NodeContext value);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.RuntimeContext/<GetOrCreateAsync>d__14")]
public static Task`1<RuntimeContext> GetOrCreateAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[EventSourceAttribute]
internal class Microsoft.ServiceFabric.Services.Runtime.ServiceFrameworkEventSource : EventSource {
    internal static ServiceFrameworkEventSource Writer;
    private static ServiceFrameworkEventSource();
    [NonEventAttribute]
internal void StatefulRunAsyncInvocation(StatefulServiceContext serviceContext);
    [NonEventAttribute]
internal void StatefulRunAsyncCancellation(StatefulServiceContext serviceContext, TimeSpan slowCancellationTimeMillis);
    [NonEventAttribute]
internal void StatefulRunAsyncCompletion(StatefulServiceContext serviceContext, bool wasCanceled);
    [NonEventAttribute]
internal void StatefulRunAsyncSlowCancellation(StatefulServiceContext serviceContext, TimeSpan actualCancellationTimeMillis, TimeSpan slowCancellationTimeMillis);
    [NonEventAttribute]
internal void StatefulRunAsyncFailure(StatefulServiceContext serviceContext, bool wasCanceled, Exception exception);
    [NonEventAttribute]
internal void StatelessRunAsyncInvocation(StatelessServiceContext serviceContext);
    [NonEventAttribute]
internal void StatelessRunAsyncCancellation(StatelessServiceContext serviceContext, TimeSpan slowCancellationTimeMillis);
    [NonEventAttribute]
internal void StatelessRunAsyncCompletion(StatelessServiceContext serviceContext, bool wasCanceled);
    [NonEventAttribute]
internal void StatelessRunAsyncSlowCancellation(StatelessServiceContext serviceContext, TimeSpan actualCancellationTimeMillis, TimeSpan slowCancellationTimeMillis);
    [NonEventAttribute]
internal void StatelessRunAsyncFailure(StatelessServiceContext serviceContext, bool wasCanceled, Exception exception);
    [EventAttribute("1")]
private void StatefulRunAsyncInvocation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long replicaId);
    [EventAttribute("2")]
private void StatefulRunAsyncCancellation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long replicaId, double slowCancellationTimeMillis);
    [EventAttribute("3")]
private void StatefulRunAsyncCompletion(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long replicaId, bool wasCanceled);
    [EventAttribute("4")]
private void StatefulRunAsyncSlowCancellation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long replicaId, double actualCancellationTimeMillis, double slowCancellationTimeMillis);
    [EventAttribute("5")]
private void StatefulRunAsyncFailure(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long replicaId, bool wasCanceled, string exception);
    [EventAttribute("6")]
private void StatelessRunAsyncInvocation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long instanceId);
    [EventAttribute("7")]
private void StatelessRunAsyncCancellation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long instanceId, double slowCancellationTimeMillis);
    [EventAttribute("8")]
private void StatelessRunAsyncCompletion(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long instanceId, bool wasCanceled);
    [EventAttribute("9")]
private void StatelessRunAsyncSlowCancellation(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long instanceId, double actualCancellationTimeMillis, double slowCancellationTimeMillis);
    [EventAttribute("10")]
private void StatelessRunAsyncFailure(string applicationTypeName, string applicationName, string serviceTypeName, string serviceName, string partitionId, long instanceId, bool wasCanceled, string exception);
}
internal class Microsoft.ServiceFabric.Services.Runtime.ServiceHelper : object {
    internal static string ApiStartTraceTypeSuffix;
    internal static string ApiFinishTraceTypeSuffix;
    internal static string ApiErrorTraceTypeSuffix;
    internal static string ApiSlowTraceTypeSuffix;
    internal static TimeSpan RunAsyncExpectedCancellationTimeSpan;
    internal static TimeSpan CommunicationListenerExpectedCloseTimeSpan;
    private static string RunAsyncHealthSourceId;
    private static string CommunicationListenerHealthSourceId;
    private static string RunAsyncHealthUnhandledExceptionProperty;
    private static string RunAsyncHealthSlowCanecellationProperty;
    private static string CommunicationListenerSlowCloseProperty;
    private static int MaxHealthDescriptionLength;
    private static TimeSpan RunAsyncUnexpectedExceptionHealthInfoTtl;
    private static TimeSpan RunAsyncSlowCancellationHealthInfoTtl;
    private static TimeSpan CommunicationListenerSlowCloseHealthInfoTtl;
    private string traceType;
    private string traceId;
    public ServiceHelper(string traceType, string traceId);
    private static ServiceHelper();
    internal static void ObserveExceptionIfAny(Task tsk);
    internal void HandleRunAsyncUnexpectedFabricException(IServicePartition partition, FabricException fex);
    internal void HandleRunAsyncUnexpectedException(IServicePartition partition, Exception ex);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.ServiceHelper/<AwaitAsyncTaskWithHealthReporting>d__21")]
internal Task AwaitAsyncTaskWithHealthReporting(IServicePartition partition, Task taskToAwait, TimeSpan expectedCancellationTime, Action reportHealthFunc);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.ServiceHelper/<AwaitCloseCommunicationListerWithHealthReporting>d__22")]
internal Task AwaitCloseCommunicationListerWithHealthReporting(IServicePartition partition, Task closeCommunicationListenerTask, string communicationListenerName);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.ServiceHelper/<AwaitRunAsyncWithHealthReporting>d__23")]
internal Task AwaitRunAsyncWithHealthReporting(IServicePartition partition, Task runAsyncTask);
    private static string TrimToLength(string str, int length);
    private static HealthInformation GetRunAsyncUnexpectedExceptionHealthInformation(Exception e);
    private static HealthInformation GetRunAsyncSlowCancellationHealthInformation(string description);
    private static HealthInformation GetCommunicationListenerSlowCloseHealthInformation(string description);
    private void ReportPartitionHealth(IServicePartition partition, HealthInformation healthInformation);
    private void ReportRunAsyncSlowCancellationHealth(IServicePartition partition, string description);
    private void ReportRunAsyncUnexpectedExceptionHealth(IServicePartition partition, Exception unexpectedException);
    private void ReportCommunicationListenerSlowCloseHealth(IServicePartition partition, string description);
}
public static class Microsoft.ServiceFabric.Services.Runtime.ServiceRuntime : object {
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.ServiceRuntime/<RegisterServiceAsync>d__0")]
public static Task RegisterServiceAsync(string serviceTypeName, Func`2<StatelessServiceContext, StatelessService> serviceFactory, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.ServiceRuntime/<RegisterServiceAsync>d__1")]
public static Task RegisterServiceAsync(string serviceTypeName, Func`2<StatefulServiceContext, StatefulServiceBase> serviceFactory, TimeSpan timeout, CancellationToken cancellationToken);
}
public abstract class Microsoft.ServiceFabric.Services.Runtime.StatefulService : StatefulServiceBase {
    private IReliableStateManager stateManager;
    public IReliableStateManager StateManager { get; }
    protected StatefulService(StatefulServiceContext serviceContext);
    protected StatefulService(StatefulServiceContext serviceContext, IReliableStateManagerReplica reliableStateManagerReplica);
    public IReliableStateManager get_StateManager();
}
public abstract class Microsoft.ServiceFabric.Services.Runtime.StatefulServiceBase : object {
    private RestoreContext restoreContext;
    private StatefulServiceContext serviceContext;
    private IStateProviderReplica stateProviderReplica;
    private IReadOnlyDictionary`2<string, string> addresses;
    [CompilerGeneratedAttribute]
private IStatefulServicePartition <Partition>k__BackingField;
    public StatefulServiceContext Context { get; }
    unknown IStatefulServicePartition Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.Partition {private set; }
    unknown IReadOnlyDictionary`2<string, string> Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.Addresses {private set; }
    internal IStateProviderReplica StateProviderReplica { get; }
    protected StatefulServiceContext ServiceContext { get; }
    protected IStatefulServicePartition Partition { get; private set; }
    protected StatefulServiceBase(StatefulServiceContext serviceContext, IStateProviderReplica stateProviderReplica);
    public StatefulServiceContext get_Context();
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.set_Partition(IStatefulServicePartition value);
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.set_Addresses(IReadOnlyDictionary`2<string, string> value);
    internal IStateProviderReplica get_StateProviderReplica();
    protected StatefulServiceContext get_ServiceContext();
    [CompilerGeneratedAttribute]
protected IStatefulServicePartition get_Partition();
    [CompilerGeneratedAttribute]
private void set_Partition(IStatefulServicePartition value);
    public Task BackupAsync(BackupDescription backupDescription);
    public Task BackupAsync(BackupDescription backupDescription, TimeSpan timeout, CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.RunAsync(CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.OnChangeRoleAsync(ReplicaRole newRole, CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.OnCloseAsync(CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.OnAbort();
    private sealed virtual override IEnumerable`1<ServiceReplicaListener> Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.CreateServiceReplicaListeners();
    private sealed virtual override IStateProviderReplica Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.CreateStateProviderReplica();
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatefulUserServiceReplica.OnOpenAsync(ReplicaOpenMode openMode, CancellationToken cancellationToken);
    protected IReadOnlyDictionary`2<string, string> GetAddresses();
    protected virtual IEnumerable`1<ServiceReplicaListener> CreateServiceReplicaListeners();
    protected virtual Task OnOpenAsync(ReplicaOpenMode openMode, CancellationToken cancellationToken);
    protected virtual Task OnChangeRoleAsync(ReplicaRole newRole, CancellationToken cancellationToken);
    protected virtual Task RunAsync(CancellationToken cancellationToken);
    protected virtual Task OnCloseAsync(CancellationToken cancellationToken);
    protected virtual void OnAbort();
    protected virtual Task`1<bool> OnDataLossAsync(RestoreContext restoreCtx, CancellationToken cancellationToken);
    protected virtual Task OnRestoreCompletedAsync(CancellationToken cancellationToken);
    private Task`1<bool> OnDataLossAsync(CancellationToken cancellationToken);
}
internal class Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter : object {
    private static string TraceType;
    private static int PrimaryStatusCheckRetryIntervalInMillis;
    private string traceId;
    private ServiceHelper serviceHelper;
    private StatefulServiceContext serviceContext;
    private IStatefulUserServiceReplica userServiceReplica;
    private IStateProviderReplica stateProviderReplica;
    private IStatefulServicePartition servicePartition;
    private IEnumerable`1<ServiceReplicaListener> replicaListeners;
    private IList`1<CommunicationListenerInfo> communicationListenersInfo;
    private ServiceEndpointCollection endpointCollection;
    private CancellationTokenSource runAsynCancellationTokenSource;
    private Task executeRunAsyncTask;
    internal IList`1<CommunicationListenerInfo> Test_CommunicationListeners { get; }
    internal StatefulServiceReplicaAdapter(StatefulServiceContext context, IStatefulUserServiceReplica userServiceReplica);
    internal IList`1<CommunicationListenerInfo> get_Test_CommunicationListeners();
    private sealed virtual override object System.Fabric.IInternalStatefulServiceReplica.GetStatus();
    private sealed virtual override void System.Fabric.IStatefulServiceReplica.Initialize(StatefulServiceInitializationParameters initializationParameters);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<System-Fabric-IStatefulServiceReplica-OpenAsync>d__18")]
private sealed virtual override Task`1<IReplicator> System.Fabric.IStatefulServiceReplica.OpenAsync(ReplicaOpenMode openMode, IStatefulServicePartition partition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<System-Fabric-IStatefulServiceReplica-ChangeRoleAsync>d__19")]
private sealed virtual override Task`1<string> System.Fabric.IStatefulServiceReplica.ChangeRoleAsync(ReplicaRole newRole, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<System-Fabric-IStatefulServiceReplica-CloseAsync>d__20")]
private sealed virtual override Task System.Fabric.IStatefulServiceReplica.CloseAsync(CancellationToken cancellationToken);
    private sealed virtual override void System.Fabric.IStatefulServiceReplica.Abort();
    internal bool Test_IsRunAsyncTaskRunning();
    private Task ScheduleRunAsync(CancellationToken runAsyncCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<ExecuteRunAsync>d__24")]
private Task ExecuteRunAsync(CancellationToken runAsyncCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<CancelRunAsync>d__25")]
private Task CancelRunAsync();
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<WaitForWriteStatusAsync>d__26")]
private Task`1<bool> WaitForWriteStatusAsync(CancellationToken cancellationToken);
    private void AddCommunicationListener(CommunicationListenerInfo communicationListenerInfo);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<OpenCommunicationListenersAsync>d__28")]
private Task`1<ServiceEndpointCollection> OpenCommunicationListenersAsync(ReplicaRole replicaRole, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaAdapter/<CloseCommunicationListenersAsync>d__29")]
private Task CloseCommunicationListenersAsync(CancellationToken cancellationToken);
    private void AbortCommunicationListeners();
}
internal class Microsoft.ServiceFabric.Services.Runtime.StatefulServiceReplicaFactory : object {
    private Func`2<StatefulServiceContext, StatefulServiceBase> serviceFactory;
    private RuntimeContext runtimeContext;
    public StatefulServiceReplicaFactory(RuntimeContext runtimeContext, Func`2<StatefulServiceContext, StatefulServiceBase> serviceFactory);
    private sealed virtual override IStatefulServiceReplica System.Fabric.IStatefulServiceFactory.CreateReplica(string serviceTypeName, Uri serviceName, Byte[] initializationData, Guid partitionId, long replicaId);
    public sealed virtual void Dispose();
}
public abstract class Microsoft.ServiceFabric.Services.Runtime.StatelessService : object {
    private StatelessServiceContext serviceContext;
    private IReadOnlyDictionary`2<string, string> addresses;
    [CompilerGeneratedAttribute]
private IStatelessServicePartition <Partition>k__BackingField;
    public StatelessServiceContext Context { get; }
    unknown IReadOnlyDictionary`2<string, string> Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.Addresses {private set; }
    unknown IStatelessServicePartition Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.Partition {private set; }
    protected IStatelessServicePartition Partition { get; private set; }
    protected StatelessService(StatelessServiceContext serviceContext);
    public StatelessServiceContext get_Context();
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.set_Addresses(IReadOnlyDictionary`2<string, string> value);
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.set_Partition(IStatelessServicePartition value);
    [CompilerGeneratedAttribute]
protected IStatelessServicePartition get_Partition();
    [CompilerGeneratedAttribute]
private void set_Partition(IStatelessServicePartition value);
    private sealed virtual override IEnumerable`1<ServiceInstanceListener> Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.CreateServiceInstanceListeners();
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.OnOpenAsync(CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.RunAsync(CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.OnCloseAsync(CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.ServiceFabric.Services.Runtime.IStatelessUserServiceInstance.OnAbort();
    protected IReadOnlyDictionary`2<string, string> GetAddresses();
    protected virtual IEnumerable`1<ServiceInstanceListener> CreateServiceInstanceListeners();
    protected virtual Task OnOpenAsync(CancellationToken cancellationToken);
    protected virtual Task RunAsync(CancellationToken cancellationToken);
    protected virtual Task OnCloseAsync(CancellationToken cancellationToken);
    protected virtual void OnAbort();
}
internal class Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter : object {
    private static string TraceType;
    private string traceId;
    private ServiceHelper serviceHelper;
    private StatelessServiceContext serviceContext;
    private IStatelessUserServiceInstance userServiceInstance;
    private IStatelessServicePartition servicePartition;
    private IEnumerable`1<ServiceInstanceListener> instanceListeners;
    private IList`1<CommunicationListenerInfo> communicationListenersInfo;
    private ServiceEndpointCollection endpointCollection;
    private CancellationTokenSource runAsynCancellationTokenSource;
    private Task executeRunAsyncTask;
    internal StatelessServiceInstanceAdapter(StatelessServiceContext context, IStatelessUserServiceInstance userServiceInstance);
    private sealed virtual override void System.Fabric.IStatelessServiceInstance.Initialize(StatelessServiceInitializationParameters initializationParameters);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<System-Fabric-IStatelessServiceInstance-OpenAsync>d__13")]
private sealed virtual override Task`1<string> System.Fabric.IStatelessServiceInstance.OpenAsync(IStatelessServicePartition partition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<System-Fabric-IStatelessServiceInstance-CloseAsync>d__14")]
private sealed virtual override Task System.Fabric.IStatelessServiceInstance.CloseAsync(CancellationToken cancellationToken);
    private sealed virtual override void System.Fabric.IStatelessServiceInstance.Abort();
    internal bool Test_IsRunAsyncTaskRunning();
    private Task ScheduleRunAsync(CancellationToken runAsyncCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<ExecuteRunAsync>d__18")]
private Task ExecuteRunAsync(CancellationToken runAsyncCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<CancelRunAsync>d__19")]
private Task CancelRunAsync();
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<OpenCommunicationListenersAsync>d__20")]
private Task`1<ServiceEndpointCollection> OpenCommunicationListenersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceAdapter/<CloseCommunicationListenersAsync>d__21")]
private Task CloseCommunicationListenersAsync(CancellationToken cancellationToken);
    private void AddCommunicationListener(CommunicationListenerInfo communicationListenerInfo);
    private void AbortCommunicationListeners();
}
internal class Microsoft.ServiceFabric.Services.Runtime.StatelessServiceInstanceFactory : object {
    private Func`2<StatelessServiceContext, StatelessService> serviceFactory;
    private RuntimeContext runtimeContext;
    public StatelessServiceInstanceFactory(RuntimeContext runtimeContext, Func`2<StatelessServiceContext, StatelessService> serviceFactory);
    private sealed virtual override IStatelessServiceInstance System.Fabric.IStatelessServiceFactory.CreateInstance(string serviceTypeName, Uri serviceName, Byte[] initializationData, Guid partitionId, long instanceId);
    public sealed virtual void Dispose();
}
[EventSourceAttribute]
internal class Microsoft.ServiceFabric.Services.ServiceEventSource : ServiceFabricEventSource {
    internal static ServiceEventSource Instance;
    private static int ServiceLifecycleEventId;
    private static int CommunicationListenerUsageEventId;
    private static int ServiceRemotingUsageEventId;
    private static string ServiceLifecycleEventTraceFormat;
    private static string CommunicationListenerUsageEventTraceFormat;
    private static string ServiceRemotingUsageEventTraceFormat;
    private static ServiceEventSource();
    [NonEventAttribute]
internal void WriteErrorWithId(string type, string id, string format, Object[] args);
    [NonEventAttribute]
internal void WriteWarning(string type, string format, Object[] args);
    [NonEventAttribute]
internal void WriteWarningWithId(string type, string id, string format, Object[] args);
    [NonEventAttribute]
internal void WriteInfo(string type, string format, Object[] args);
    [NonEventAttribute]
internal void WriteInfoWithId(string type, string id, string format, Object[] args);
    [NonEventAttribute]
internal void WriteNoise(string type, string format, Object[] args);
    [NonEventAttribute]
internal void WriteNoiseWithId(string type, string id, string format, Object[] args);
    [NonEventAttribute]
internal void ServiceLifecycleEventWrapper(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaOrInstanceId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, string lifecycleEvent, string serviceKind);
    [NonEventAttribute]
internal void CommunicationListenerUsageEventWrapper(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, string communicationListenerType);
    [NonEventAttribute]
internal void ServiceRemotingUsageEventWrapper(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, bool isSecure, string remotingVersion, string communicationListenerType, string exceptionSerializationTechnique);
    [EventAttribute("1")]
private void InfoText(string id, string type, string message);
    [EventAttribute("2")]
private void WarningText(string id, string type, string message);
    [EventAttribute("3")]
private void ErrorText(string id, string type, string message);
    [EventAttribute("4")]
private void NoiseText(string id, string type, string message);
    [EventAttribute("5")]
private void ServiceLifecycleEvent(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaOrInstanceId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, string lifecycleEvent, string serviceKind);
    [EventAttribute("6")]
private void CommunicationListenerUsageEvent(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, string communicationListenerType);
    [EventAttribute("7")]
private void ServiceRemotingUsageEvent(string type, string clusterOsType, string runtimePlatform, string partitionId, string replicaId, string serviceName, string serviceTypeName, string applicationName, string applicationTypeName, bool isSecure, string remotingVersion, string communicationListenerType, string exceptionSerializationTechnique);
}
public static class Microsoft.ServiceFabric.Services.ServiceNameFormat : object {
    public static string GetEndpointName(Type serviceInterfaceType);
    internal static string GetName(Type serviceInterfaceType);
    internal static string GetName(string serviceInterfaceTypeName);
}
public static class Microsoft.ServiceFabric.Services.ServiceTelemetry : object {
    internal static void StatefulServiceInitializeEvent(StatefulServiceContext context);
    internal static void StatefulServiceReplicaCloseEvent(StatefulServiceContext context);
    internal static void StatelessServiceInitializeEvent(StatelessServiceContext context);
    internal static void StatelessServiceInstanceCloseEvent(StatelessServiceContext context);
    internal static void CommunicationListenerUsageEvent(ServiceContext context, string communicationListenerType);
    internal static void FabricTransportServiceRemotingV1Event(ServiceContext context, bool isSecure, string exceptionSerializationTechnique);
    internal static void FabricTransportServiceRemotingV2Event(ServiceContext context, bool isSecure, string exceptionSerializationTechnique);
    private static void StatefulServiceLifecycleEvent(StatefulServiceContext context, string lifecycleEvent);
    private static void StatelessServiceLifecycleEvent(StatelessServiceContext context, string lifecycleEvent);
    private static void FabricTransportServiceRemotingEvent(ServiceContext context, string remotingVersion, bool isSecure, string exceptionSerializationTechnique);
}
internal static class Microsoft.ServiceFabric.Services.ServiceTrace : object {
    private static ServiceEventSource source;
    internal static ServiceEventSource Source { get; private set; }
    private static ServiceTrace();
    internal static ServiceEventSource get_Source();
    private static void set_Source(ServiceEventSource value);
    internal static string GetTraceIdForReplica(Guid partitionId, long replicaId);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.ServiceFabric.Services.SR : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_ConnectionDenied { get; }
    internal static string ErrorCommunicationTargetSelectorEndpointNotFound { get; }
    internal static string ErrorCommunicationTargetSelectorInvalidStateful { get; }
    internal static string ErrorCommunicationTargetSelectorInvalidStateless { get; }
    internal static string ErrorConfigFileNotFound { get; }
    internal static string ErrorConfigPackageNotFound { get; }
    internal static string ErrorInvalidAddress { get; }
    internal static string ErrorInvalidPartitionEndpointAddress { get; }
    internal static string ErrorListenerAlreadyExists { get; }
    internal static string ErrorListenerNameNotSpecified { get; }
    internal static string ErrorPartitionNamedEndpointNotFound { get; }
    internal static string ErrorParttionInstanceInvalidAddress { get; }
    internal static string ErrorSectionNameNotFound { get; }
    internal static string ErrorServiceDoesNotExist { get; }
    internal static string ErrorServiceMethodDispatcher_InterfaceNotFound { get; }
    internal static string ErrorServiceTooBusy { get; }
    internal static string event_StatefulRunAsyncCancellation { get; }
    internal static string event_StatefulRunAsyncCompletion { get; }
    internal static string event_StatefulRunAsyncFailure { get; }
    internal static string event_StatefulRunAsyncInvocation { get; }
    internal static string event_StatefulRunAsyncSlowCancellation { get; }
    internal static string event_StatelessRunAsyncCancellation { get; }
    internal static string event_StatelessRunAsyncCompletion { get; }
    internal static string event_StatelessRunAsyncFailure { get; }
    internal static string event_StatelessRunAsyncInvocation { get; }
    internal static string event_StatelessRunAsyncSlowCancellation { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_ConnectionDenied();
    internal static string get_ErrorCommunicationTargetSelectorEndpointNotFound();
    internal static string get_ErrorCommunicationTargetSelectorInvalidStateful();
    internal static string get_ErrorCommunicationTargetSelectorInvalidStateless();
    internal static string get_ErrorConfigFileNotFound();
    internal static string get_ErrorConfigPackageNotFound();
    internal static string get_ErrorInvalidAddress();
    internal static string get_ErrorInvalidPartitionEndpointAddress();
    internal static string get_ErrorListenerAlreadyExists();
    internal static string get_ErrorListenerNameNotSpecified();
    internal static string get_ErrorPartitionNamedEndpointNotFound();
    internal static string get_ErrorParttionInstanceInvalidAddress();
    internal static string get_ErrorSectionNameNotFound();
    internal static string get_ErrorServiceDoesNotExist();
    internal static string get_ErrorServiceMethodDispatcher_InterfaceNotFound();
    internal static string get_ErrorServiceTooBusy();
    internal static string get_event_StatefulRunAsyncCancellation();
    internal static string get_event_StatefulRunAsyncCompletion();
    internal static string get_event_StatefulRunAsyncFailure();
    internal static string get_event_StatefulRunAsyncInvocation();
    internal static string get_event_StatefulRunAsyncSlowCancellation();
    internal static string get_event_StatelessRunAsyncCancellation();
    internal static string get_event_StatelessRunAsyncCompletion();
    internal static string get_event_StatelessRunAsyncFailure();
    internal static string get_event_StatelessRunAsyncInvocation();
    internal static string get_event_StatelessRunAsyncSlowCancellation();
}
internal static class Microsoft.ServiceFabric.Services.TelemetryConstants : object {
    internal static string ServiceLifecycleEventName;
    internal static string ServiceRemotingUsageEventName;
    internal static string CommunicationListenerUsageEventName;
    internal static string ClusterOSWindows;
    internal static string ClusterOSLinux;
    internal static string DotNetStandard;
    internal static string DotNetFramework;
    internal static string LifecycleEventOpened;
    internal static string LifecycleEventClosed;
    internal static string StatefulServiceKind;
    internal static string StatelessServiceKind;
    internal static string RemotingVersionV1;
    internal static string RemotingVersionV2;
    internal static string FabricTransportCommunicationListener;
    internal static string WCFCommunicationListener;
    internal static string ASPNetCoreCommunicationListener;
    internal static string OsType;
    internal static string RuntimePlatform;
    private static TelemetryConstants();
}
