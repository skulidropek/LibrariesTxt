internal static class System.Fabric.Common.AppTrace : object {
    private static ExtensionsEvents traceSource;
    public static ExtensionsEvents TraceSource { get; }
    private static AppTrace();
    public static ExtensionsEvents get_TraceSource();
}
internal class System.Fabric.Common.ExpressionException : Exception {
    public ExpressionException(string message);
    public ExpressionException(string message, Exception inner);
}
internal class System.Fabric.Common.FabricAssemblyResolver : object {
    public static string DataImplAssemblyName;
    public static String[] KnownDlls;
    private static FabricAssemblyResolver();
    public static Assembly ResolveAssembly(string assemblyName);
}
internal class System.Fabric.Common.FabricAverageCount64PerformanceCounterWriter : FabricPerformanceCounterWriter {
    internal FabricAverageCount64PerformanceCounterWriter(FabricPerformanceCounterSetInstance instance, string counterName, string baseCounterName);
    internal void UpdateCounterValue(long delta);
}
internal abstract class System.Fabric.Common.FabricBaselessPerformanceCounterWriter : object {
    protected FabricPerformanceCounter Counter;
    protected bool IsInitialized { get; }
    protected FabricBaselessPerformanceCounterWriter(FabricPerformanceCounterSetInstance instance, string counterName);
    protected virtual bool get_IsInitialized();
}
internal class System.Fabric.Common.FabricDirectory : object {
    internal static void CreateDirectory(string path);
    internal static String[] GetDirectories(string path);
    internal static String[] GetDirectories(string path, string pattern);
    internal static String[] GetDirectories(string path, string pattern, SearchOption option);
    internal static String[] GetDirectories(string path, string pattern, bool getFullPath, SearchOption option);
    internal static String[] GetFiles(string path);
    internal static String[] GetFiles(string path, string pattern);
    internal static String[] GetFiles(string path, string pattern, SearchOption option);
    internal static String[] GetFiles(string path, string pattern, bool getFullPath, SearchOption option);
    internal static void Copy(string src, string des, bool overwrite);
    internal static void Rename(string src, string des, bool overwrite);
    internal static bool Exists(string path);
    internal static void Delete(string path);
    internal static void Delete(string path, bool recursive);
    internal static void Delete(string path, bool recursive, bool deleteReadOnlyFiles);
    internal static bool IsSymbolicLink(string path);
    private static void CreateHelper(string path);
    private static String[] GetDirectoriesHelper(string path, string pattern, bool getFullPath, SearchOption option);
    private static String[] GetFilesHelper(string path, string pattern, bool getFullPath, SearchOption option);
    private static void CopyHelper(string src, string des, bool overwrite);
    private static void RenameHelper(string src, string des, bool overwrite);
    private static bool ExistsHelper(string path);
    private static void DeleteHelper(string path, bool recursive, bool deleteReadOnlyFiles);
    private static bool IsSymbolicLinkHelper(string path);
}
internal class System.Fabric.Common.FabricEnvironment : object {
    public static string GetRoot();
    public static string GetRoot(string machineName);
    public static string GetBinRoot();
    public static string GetBinRoot(string machineName);
    public static string GetCodePath();
    public static string GetCodePath(string machineName);
    public static string GetDataRoot();
    public static string GetDataRoot(string machineName);
    public static string GetLogRoot();
    public static string GetLogRoot(string machineName);
    public static void SetFabricRoot(string root);
    public static void SetFabricRoot(string root, string machineName);
    public static void SetFabricBinRoot(string binRoot);
    public static void SetFabricBinRoot(string binRoot, string machineName);
    public static void SetFabricCodePath(string codePath);
    public static void SetFabricCodePath(string codePath, string machineName);
    public static void SetDataRoot(string dataRoot);
    public static void SetDataRoot(string dataRoot, string machineName);
    public static void SetLogRoot(string logRoot);
    public static void SetLogRoot(string logRoot, string machineName);
    public static void SetEnableCircularTraceSession(bool enableCircularTraceSession);
    public static void SetEnableCircularTraceSession(bool enableCircularTraceSession, string machineName);
    public static void SetEnableUnsupportedPreviewFeatures(bool enableUnsupportedPreviewFeatures, string machineName);
    public static void SetIsSFVolumeDiskServiceEnabled(bool isSFVolumeDiskServiceEnabled, string machineName);
    public static void SetDisableKernelDriver(bool disableKernelDriver, string machineName);
    public static void SetFabricTraceFileSizeInMB(UInt32 fabricTraceFileSizeInMB, string machineName);
    public static void SetLeaseTraceFileSizeInMB(UInt32 leaseTraceFileSizeInMB, string machineName);
    public static bool GetEnableCircularTraceSession();
    public static bool GetEnableCircularTraceSession(string machineName);
    private static string GetRootHelper(string machineName);
    private static string GetBinRootHelper(string machineName);
    private static string GetCodePathHelper(string machineName);
    private static string GetDataRootHelper(string machineName);
    private static string GetLogRootHelper(string machineName);
    private static void SetFabricRootHelper(string root, string machineName);
    private static void SetFabricBinRootHelper(string binRoot, string machineName);
    private static void SetFabricCodePathHelper(string codePath, string machineName);
    private static void SetDataRootHelper(string dataRoot, string machineName);
    private static void SetLogRootHelper(string logRoot, string machineName);
    private static void SetEnableCircularTraceSessionHelper(bool enableCircularTraceSession, string machineName);
    private static void SetFabricTraceFileSizeInMBHelper(UInt32 fabricTraceFileSizeInMB, string machineName);
    private static void SetLeaseTraceFileSizeInMBHelper(UInt32 leaseTraceFileSizeInMB, string machineName);
    private static void SetEnableUnsupportedPreviewFeaturesHelper(bool enableUnsupportedPreviewFeatures, string machineName);
    private static void SetIsSFVolumeDiskServiceEnabledHelper(bool isSFVolumeDiskServiceEnabled, string machineName);
    private static void SetDisableKernelDriverHelper(bool disableKernelDriver, string machineName);
    private static bool GetEnableCircularTraceSessionHelper(string machineName);
}
internal class System.Fabric.Common.FabricFile : object {
    public static bool SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, FileInformation& FileInformation, int dwBufferSize);
    public static bool SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, FILE_BASIC_INFO& FileBasicInformation, int dwBufferSize);
    internal static IntPtr NtQueryInformationFile(SafeHandle FileHandle, IO_STATUS_BLOCK& IoStatusBlock, IntPtr pInfoBlock, UInt32 length, FILE_INFORMATION_CLASS fileInformation);
    internal static FileStream Create(string path);
    internal static FileStream Open(string path, FileMode fileMode);
    internal static FileStream Open(string path, FileMode fileMode, FileAccess fileAccess);
    internal static FileStream Open(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    internal static FileStream Open(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int cacheSize, FileOptions fileOptions);
    internal static void Copy(string src, string des, bool overwrite);
    internal static void Move(string src, string des);
    internal static bool Exists(string path);
    internal static void Delete(string path);
    internal static void SetLastWriteTime(string path, DateTime lastWriteTime);
    internal static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    internal static bool CreateHardLink(string fileName, string existingFileName);
    internal static void Delete(string path, bool deleteReadonly);
    internal static long GetSize(string path);
    internal static DateTime GetLastWriteTime(string path);
    internal static string GetVersionInfo(string path);
    internal static void RemoveReadOnlyAttribute(string path);
    private static void CopyHelper(string src, string des, bool overwrite);
    private static void MoveHelper(string src, string des);
    private static void UpdateFilePermission(string filePath);
    private static FileStream OpenHelper(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare);
    private static FileStream OpenHelper(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int cacheSize, FileOptions fileOptions);
    private static void SetLastWriteTimeHelper(string path, long lastWriteTime);
    private static bool ExistsHelper(string path);
    private static void RemoveReadOnlyAttributeHelper(string path);
    private static void ReplaceHelper(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    private static bool CreateHardLinkHelper(string fileName, string existingFileName);
    private static long GetSizeHelper(string path);
    private static DateTime GetLastWriteTimeHelper(string path);
    private static string GetVersionInfoHelper(string path);
    private static void DeleteHelper(string path, bool deleteReadonly);
    private static FABRIC_FILE_MODE ToNative(FileMode mode);
    private static FABRIC_FILE_ACCESS ToNative(FileAccess access);
    private static FABRIC_FILE_SHARE ToNative(FileShare share);
    private static FABRIC_FILE_ATTRIBUTES ToNative(FileOptions options);
}
internal class System.Fabric.Common.FabricNumberOfItems64PerformanceCounterWriter : FabricBaselessPerformanceCounterWriter {
    internal FabricNumberOfItems64PerformanceCounterWriter(FabricPerformanceCounterSetInstance instance, string counterName);
    internal void UpdateCounterValue(long delta);
}
internal class System.Fabric.Common.FabricPath : object {
    internal static string GetUncPath(string path);
    internal static string GetDirectoryName(string path);
    internal static string GetFullPath(string path);
    private static string GetUncPathHelper(string path);
    private static string GetDirectoryNameHelper(string path);
    private static string GetFullPathHelper(string path);
}
internal class System.Fabric.Common.FabricPerformanceCounter : SafeHandle {
    public bool IsInvalid { get; }
    public FabricPerformanceCounter(IntPtr instanceHandle, int index);
    public void Increment();
    public void Decrement();
    public void IncrementBy(long val);
    public long GetValue();
    public void SetValue(long val);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal enum System.Fabric.Common.FabricPerformanceCounterCategoryType : Enum {
    public int value__;
    public static FabricPerformanceCounterCategoryType Unknown;
    public static FabricPerformanceCounterCategoryType SingleInstance;
    public static FabricPerformanceCounterCategoryType MultiInstance;
}
internal class System.Fabric.Common.FabricPerformanceCounterDefinition : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private FabricPerformanceCounterType <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Attributes>k__BackingField;
    public int Id { get; private set; }
    public int BaseId { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }
    public FabricPerformanceCounterType CounterType { get; private set; }
    public string Symbol { get; private set; }
    public IEnumerable`1<string> Attributes { get; private set; }
    public FabricPerformanceCounterDefinition(int id, int baseId, string name, string description, FabricPerformanceCounterType counterType, string symbol, IEnumerable`1<string> attributes);
    public FabricPerformanceCounterDefinition(int id, string name, string description, FabricPerformanceCounterType counterType, string symbol);
    public FabricPerformanceCounterDefinition(int id, int baseId, string name, string description, FabricPerformanceCounterType counterType, string symbol);
    public FabricPerformanceCounterDefinition(int id, string name, string description, FabricPerformanceCounterType counterType, string symbol, IEnumerable`1<string> attributes);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_BaseId();
    [CompilerGeneratedAttribute]
private void set_BaseId(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public FabricPerformanceCounterType get_CounterType();
    [CompilerGeneratedAttribute]
private void set_CounterType(FabricPerformanceCounterType value);
    [CompilerGeneratedAttribute]
public string get_Symbol();
    [CompilerGeneratedAttribute]
private void set_Symbol(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(IEnumerable`1<string> value);
}
internal class System.Fabric.Common.FabricPerformanceCounterInterop : object {
    public static IntPtr CreateCounterSet(FabricPerformanceCounterSetDefinition counterSetDefinition, IEnumerable`1<FabricPerformanceCounterDefinition> counters);
    public static void DeleteCounterSet(IntPtr counterSetHandle);
    public static IntPtr CreateCounterSetInstance(IntPtr counterSetHandle, string instanceName);
    public static void SetCounterRefValue(IntPtr counterInstanceHandle, int id, IntPtr counterAddress);
    public static void DeleteCounterSetInstance(IntPtr counterInstanceHandle);
}
internal class System.Fabric.Common.FabricPerformanceCounterSet : SafeHandle {
    public FabricPerformanceCounterSetDefinition CounterSetDefinition;
    internal IntPtr CounterSetDefinitionPtr;
    internal Dictionary`2<string, int> CounterNameToId;
    public bool IsInvalid { get; }
    public FabricPerformanceCounterSet(FabricPerformanceCounterSetDefinition setDefinition, IEnumerable`1<FabricPerformanceCounterDefinition> counters);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    public FabricPerformanceCounterSetInstance CreateCounterSetInstance(string instanceName);
}
internal class System.Fabric.Common.FabricPerformanceCounterSetDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private FabricPerformanceCounterCategoryType <CategoryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Symbol>k__BackingField;
    public string Name { get; private set; }
    public string Description { get; private set; }
    public FabricPerformanceCounterCategoryType CategoryType { get; private set; }
    public Guid Guid { get; private set; }
    public string Symbol { get; private set; }
    public FabricPerformanceCounterSetDefinition(string name, string description, FabricPerformanceCounterCategoryType categoryType, Guid guid, string symbol);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public FabricPerformanceCounterCategoryType get_CategoryType();
    [CompilerGeneratedAttribute]
private void set_CategoryType(FabricPerformanceCounterCategoryType value);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
private void set_Guid(Guid value);
    [CompilerGeneratedAttribute]
public string get_Symbol();
    [CompilerGeneratedAttribute]
private void set_Symbol(string value);
}
internal class System.Fabric.Common.FabricPerformanceCounterSetInstance : SafeHandle {
    private Dictionary`2<string, FabricPerformanceCounter> counterNameToCounter;
    public bool IsInvalid { get; }
    internal FabricPerformanceCounterSetInstance(FabricPerformanceCounterSet counterSet, string instanceName);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    public FabricPerformanceCounter GetPerformanceCounter(string counterName);
}
internal enum System.Fabric.Common.FabricPerformanceCounterType : Enum {
    public int value__;
    public static FabricPerformanceCounterType NumberOfItemsHEX32;
    public static FabricPerformanceCounterType NumberOfItemsHEX64;
    public static FabricPerformanceCounterType NumberOfItems32;
    public static FabricPerformanceCounterType NumberOfItems64;
    public static FabricPerformanceCounterType CounterDelta32;
    public static FabricPerformanceCounterType CounterDelta64;
    public static FabricPerformanceCounterType SampleCounter;
    public static FabricPerformanceCounterType CountPerTimeInterval32;
    public static FabricPerformanceCounterType CountPerTimeInterval64;
    public static FabricPerformanceCounterType RateOfCountsPerSecond32;
    public static FabricPerformanceCounterType RateOfCountsPerSecond64;
    public static FabricPerformanceCounterType RawFraction;
    public static FabricPerformanceCounterType CounterTimer;
    public static FabricPerformanceCounterType Timer100Ns;
    public static FabricPerformanceCounterType SampleFraction;
    public static FabricPerformanceCounterType CounterTimerInverse;
    public static FabricPerformanceCounterType Timer100NsInverse;
    public static FabricPerformanceCounterType CounterMultiTimer;
    public static FabricPerformanceCounterType CounterMultiTimer100Ns;
    public static FabricPerformanceCounterType CounterMultiTimerInverse;
    public static FabricPerformanceCounterType CounterMultiTimer100NsInverse;
    public static FabricPerformanceCounterType AverageTimer32;
    public static FabricPerformanceCounterType ElapsedTime;
    public static FabricPerformanceCounterType AverageCount64;
    public static FabricPerformanceCounterType SampleBase;
    public static FabricPerformanceCounterType AverageBase;
    public static FabricPerformanceCounterType RawBase;
    public static FabricPerformanceCounterType CounterMultiBase;
}
internal abstract class System.Fabric.Common.FabricPerformanceCounterWriter : FabricBaselessPerformanceCounterWriter {
    protected FabricPerformanceCounter CounterBase;
    protected bool IsInitialized { get; }
    protected FabricPerformanceCounterWriter(FabricPerformanceCounterSetInstance instance, string counterName, string baseCounterName);
    protected virtual bool get_IsInitialized();
}
internal static class System.Fabric.Common.FabricServiceModel : object {
    public static NodeId GetNodeIdFromNodeName(string nodeName, string rolesForWhichToUseV1Generator, bool useV2NodeIdGenerator, string nodeIdGeneratorVersion);
    private static NodeId GetNodeIdFromNodeNameHelper(string nodeName, string rolesForWhichToUseV1Generator, bool useV2NodeIdGenerator, string nodeIdGeneratorVersion);
}
internal static class System.Fabric.Common.FxCop : object {
}
internal interface System.Fabric.Common.IConfigStore {
    public bool IgnoreUpdateFailures { get; public set; }
    public abstract virtual ICollection`1<string> GetSections(string partialSectionName);
    public abstract virtual ICollection`1<string> GetKeys(string sectionName, string partialKeyName);
    public abstract virtual string ReadUnencryptedString(string sectionName, string keyName);
    public abstract virtual string ReadString(string sectionName, string keyName, Boolean& isEncrypted);
    public abstract virtual bool get_IgnoreUpdateFailures();
    public abstract virtual void set_IgnoreUpdateFailures(bool value);
}
internal interface System.Fabric.Common.IConfigStore2 {
    public abstract virtual ICollection`1<string> GetAllKeys(string sectionName);
}
internal interface System.Fabric.Common.IConfigStoreUpdateHandler {
    public abstract virtual bool OnUpdate(string sectionName, string keyName);
    public abstract virtual bool CheckUpdate(string sectionName, string keyName, string value, bool isEncrypted);
}
internal interface System.Fabric.Common.IConfigStoreUpdateHandler2 {
    public abstract virtual bool IsOverrideAllowed(string sectionName, string keyName, bool force);
}
internal interface System.Fabric.Common.IFabricPerformanceCountersDefinition {
    public abstract virtual Dictionary`2<FabricPerformanceCounterSetDefinition, IEnumerable`1<FabricPerformanceCounterDefinition>> GetCounterSets();
}
internal class System.Fabric.Common.ItemList`1 : Collection`1<TItem> {
    [CompilerGeneratedAttribute]
private bool <MayContainNullValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MayContainDuplicates>k__BackingField;
    private bool MayContainNullValues { get; private set; }
    private bool MayContainDuplicates { get; private set; }
    public ItemList`1(IList`1<TItem> list);
    public ItemList`1(bool mayContainNullValues, bool mayContainDuplicates);
    public ItemList`1(bool mayContainNullValues, bool mayContainDuplicates, IList`1<TItem> list);
    [CompilerGeneratedAttribute]
private bool get_MayContainNullValues();
    [CompilerGeneratedAttribute]
private void set_MayContainNullValues(bool value);
    [CompilerGeneratedAttribute]
private bool get_MayContainDuplicates();
    [CompilerGeneratedAttribute]
private void set_MayContainDuplicates(bool value);
    public IList`1<TItem> AsReadOnly();
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void SetItem(int index, TItem item);
    private void ValidateInsertOrAdd(int index, TItem item);
}
internal class System.Fabric.Common.NativeConfigStore : object {
    private IFabricConfigStore2 nativeConfigStore;
    public bool IgnoreUpdateFailures { get; public set; }
    private NativeConfigStore(IFabricConfigStore2 nativeConfigStore);
    public static NativeConfigStore FabricGetConfigStore();
    public static NativeConfigStore FabricGetConfigStore(IConfigStoreUpdateHandler2 updateHandler);
    public static SecureString DecryptText(string encryptedValue);
    public static SecureString DecryptText(string encryptedValue, StoreLocation storeLocation);
    public static string EncryptText(string text, string certThumbPrint, string certStoreName);
    public static string EncryptText(string text, string certThumbPrint, string certStoreName, StoreLocation certStoreLocation, string algorithmOid);
    public static string EncryptTextByCertFile(string text, string certFilePath, string algorithmOid);
    public sealed virtual ICollection`1<string> GetSections(string partialSectionName);
    public sealed virtual ICollection`1<string> GetKeys(string sectionName, string partialKeyName);
    public sealed virtual ICollection`1<string> GetAllKeys(string sectionName);
    public sealed virtual string ReadUnencryptedString(string sectionName, string keyName);
    public bool ReadUnencryptedBool(string sectionName, string keyName, ExtensionsEvents traceSource, string traceType, bool throwIfInvalid);
    public sealed virtual string ReadString(string sectionName, string keyName, Boolean& isEncrypted);
    public sealed virtual bool get_IgnoreUpdateFailures();
    public sealed virtual void set_IgnoreUpdateFailures(bool value);
    private static NativeConfigStore CreateHelper(IFabricConfigStoreUpdateHandler2 updateHandler);
    private static SecureString DecryptTextHelper(string encryptedValue, StoreLocation storeLocation);
    private static string EncryptTextHelper(string text, string certThumbPrint, string certStoreName, StoreLocation storeLocation, string algorithmOid);
    private static string EncryptValueHelper(string text, string certFilePath, string algorithmOid);
    private string ReadStringHelper(string sectionName, string keyName, Boolean& isEncrypted);
    private ICollection`1<string> GetKeysHelper(string sectionName, string partialKeyName);
    private ICollection`1<string> GetSectionsHelper(string partialSectionName);
    private bool get_IgnoreUpdateFailuresHelper();
    private void set_IgnoreUpdateFailuresHelper(bool value);
    [CompilerGeneratedAttribute]
private bool <get_IgnoreUpdateFailures>b__16_0();
}
internal static class System.Fabric.Common.NativeHelper : object {
    public static string SERVICE_ACCOUNT_PASSWORD;
    private static NativeHelper();
    public static bool LogonUser(string userName, string domainName, IntPtr password, LogonType logonType, LogonProvider logonProvider, IntPtr& token);
    public static bool CloseHandle(IntPtr handle);
    public static UInt32 MsiOpenDatabase(string szDatabasePath, IntPtr phPersist, IntPtr& phDatabase);
    public static int MsiDatabaseOpenViewW(IntPtr hDatabase, string szQuery, IntPtr& phView);
    public static int MsiViewExecute(IntPtr hView, IntPtr hRecord);
    public static UInt32 MsiViewFetch(IntPtr hView, IntPtr& hRecord);
    public static int MsiRecordGetString(IntPtr hRecord, int iField, StringBuilder szValueBuf, Int32& pcchValueBuf);
    public static IntPtr MsiCreateRecord(UInt32 cParams);
    public static UInt32 MsiCloseHandle(IntPtr hAny);
    public static IntPtr FCICreate(CabError erf, FCIFilePlacedMethod filePlaced, MemAllocMethod malloc, MemFreeMethod free, FCIOpenMethod open, FCIReadMethod read, FCIWriteMethod write, FCICloseMethod close, FCISeekMethod seek, FCIDeleteMethod delete, FCIGetTempFileMethod getTempFile, CompressionInfo cab, IntPtr data);
    public static bool FCIAddFile(IntPtr fciHandle, string sourceFileName, string destFileName, bool execute, FCIGetNextCabMethod getNextCabinet, FCIStatusMethod status, FCIGetOpenInfoMethod getOpenInfo, short compressionFlags);
    public static bool FCIFlushCabinet(IntPtr fciHandle, bool getNextCab, FCIGetNextCabMethod getNextCabinet, FCIStatusMethod status);
    public static bool FCIFlushFolder(IntPtr fciHandle, FCIGetNextCabMethod getNextCabinet, FCIStatusMethod status);
    public static bool FCIDestroy(IntPtr fciHandle);
    public static PdhStatus PdhValidatePath(string counterPath);
}
internal class System.Fabric.Common.ReleaseAssert : object {
    private static string TraceSource;
    public static void Assert(bool cond, string msg);
    public static void Assert(bool cond, string format, T arg0);
    public static void Assert(bool cond, string format, T arg0, U arg1);
    public static void Assert(bool cond, string format, T arg0, U arg1, V arg2);
    public static void AssertIfNot(bool cond, string format, Object[] args);
    public static void AssertIf(bool cond, string format, Object[] args);
    public static void AssertIfNull(object argument, string argumentName);
    public static void Failfast(string format, Object[] args);
    public static void Fail(string format, Object[] args);
    public static void IsTrue(bool condition, string format, Object[] args);
    public static void IsTrue(bool condition, string format);
    public static void IsTrue(bool condition, string format, T1 t1);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3, T4 t4);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7);
    public static void IsTrue(bool condition, string format, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8);
    public static void IsTrue(bool condition);
}
[ExtensionAttribute]
internal static class System.Fabric.Common.Requires : object {
    [ExtensionAttribute]
public static void ThrowIfNull(object argument, string argumentName);
    [ExtensionAttribute]
public static void ThrowIfNullOrWhiteSpace(string argument, string argumentName);
    public static void CheckUInt32ArgumentLimits(long argument, string argumentName);
    public static void CheckPercentageArgument(byte argument, string argumentName);
    [ExtensionAttribute]
private static void Throw(Exception exception);
    public static ArgumentRequirements`1<T> Argument(string name, T value);
}
internal class System.Fabric.Common.SynchronizedBufferPool`1 : object {
    private static int MaxSize;
    private Func`1<T> itemFactory;
    private SynchronizedPool`1<T> innerPool;
    public SynchronizedBufferPool`1(Func`1<T> itemFactory, int limit);
    public void OnClear();
    public T Take();
    internal void Return(T item);
}
internal class System.Fabric.Common.SynchronizedPool`1 : object {
    private static int maxPendingEntries;
    private static int maxPromotionFailures;
    private static int maxReturnsBeforePromotion;
    private static int maxThreadItemsPerProcessor;
    private Entry[] entries;
    private GlobalPool<T> globalPool;
    private int maxCount;
    private PendingEntry[] pending;
    private int promotionFailures;
    private object ThisLock { get; }
    public SynchronizedPool`1(int maxCount);
    private object get_ThisLock();
    public void Clear();
    private void HandlePromotionFailure(int thisThreadID);
    private bool PromoteThread(int thisThreadID);
    private void RecordReturnToGlobalPool(int thisThreadID);
    private void RecordTakeFromGlobalPool(int thisThreadID);
    public bool Return(T value);
    private bool ReturnToPerThreadPool(int thisThreadID, T value);
    private bool ReturnToGlobalPool(int thisThreadID, T value);
    public T Take();
    private T TakeFromPerThreadPool(int thisThreadID);
    private T TakeFromGlobalPool(int thisThreadID);
}
internal class System.Fabric.Common.TimeoutHelper : object {
    private DateTime deadline;
    public TimeoutHelper(TimeSpan timeout);
    public static bool HasExpired(TimeoutHelper timeoutHelper);
    public TimeSpan GetRemainingTime();
    public void ThrowIfExpired();
}
internal class System.Fabric.Common.Tracing.AgeBasedCache`2 : object {
    public static int MaxCacheCount;
    public static int DefaultCleanupDurationInSec;
    public static int MaxNoActivityLifeSpanForTimerInSec;
    private static AgeBasedCache`2 modreq(System.Runtime.CompilerServices.IsVolatile) singleInstance;
    private static object syncRoot;
    private TimeSpan noActivityLifeSpanForTimer;
    private bool disposed;
    private DateTimeOffset lastTimeOfAddOrUpdateToCache;
    private IDictionary`2<TKey, CacheValue`1<TKey, TValue, TValue>> store;
    private Timer clearCacheTimer;
    private ReaderWriterLockSlim rwLock;
    private TimeSpan cacheCleanDuration;
    private Action onTimerInactivated;
    public static AgeBasedCache`2<TKey, TValue> DefaultInstance { get; }
    public long Count { get; }
    private AgeBasedCache`2(TimeSpan durationBetweenCacheCleans, TimeSpan maxTimerInactivity, Action timerInactivated);
    private static AgeBasedCache`2();
    public static AgeBasedCache`2<TKey, TValue> get_DefaultInstance();
    internal static AgeBasedCache`2<TKey, TValue> CreateInstanceForTestingOnly(TimeSpan durationBetweenCacheCleans, TimeSpan maxTimerInactivity, Action timerInactivated);
    public sealed virtual bool TryAddOrUpdate(TKey key, TValue value, TimeSpan itemLife, Action`1<TValue> onExpireCallback);
    public sealed virtual void RemoveIfPresent(TKey key);
    public sealed virtual long get_Count();
    public sealed virtual void Clear();
    private void RemoveExpiredValues(object state);
    private void RemoveUnlocked(TKey key);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal enum System.Fabric.Common.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
    public static EventChannel Audit;
    public static EventChannel Telemetry;
}
internal class System.Fabric.Common.Tracing.EventConstants : object {
    public static string AnalysisCategory;
    public static string ChaosCategory;
    public static string CorrelationCategory;
    public static string LifeCycle;
    public static string FailureCategory;
}
internal class System.Fabric.Common.Tracing.EventData : ValueType {
    internal ulong DataPointer;
    internal UInt32 Size;
    internal int Reserved;
}
internal class System.Fabric.Common.Tracing.EventDataArrayBuilder : ValueType {
    internal static int TraceEventMaximumSize;
    internal static int BasicTypeAllocationBufferSize;
    private EventData* eventData;
    private UInt32 totalEventSize;
    private EventData* eventDataPtr;
    private Byte* currentBuffer;
    internal EventDataArrayBuilder(EventData* eventData, Byte* dataBuffer);
    internal void AddEventData(Variant variant);
    private void AddStringEventData(Variant variant, int index);
    internal bool AddEventDataWithTruncation(int argCount, Variant& v1, Variant& v2, Variant& v3, Variant& v4, Variant& v5, Variant& v6, Variant& v7, Variant& v8, Variant& v9, Variant& v10, Variant& v11, Variant& v12, Variant& v13, Variant& v14, Variant& v15, Variant& v16);
    private void RemoveStringEventData(int index);
    internal bool TruncateStringVariants(Variant& v0, Variant& v1, Variant& v2, Variant& v3, Variant& v4, Variant& v5, Variant& v6, Variant& v7, Variant& v8, Variant& v9, Variant& v10, Variant& v11, Variant& v12, Variant& v13, Variant& v14, Variant& v15);
    internal EventData* ToEventDataArray(Char* v0, Char* v1, Char* v2, Char* v3, Char* v4, Char* v5, Char* v6, Char* v7, Char* v8, Char* v9, Char* v10, Char* v11, Char* v12, Char* v13, Char* v14, Char* v15);
    internal bool IsValid();
    private void SetStringDataPointers(Char* v0, Char* v1, Char* v2, Char* v3, Char* v4, Char* v5, Char* v6, Char* v7, Char* v8, Char* v9, Char* v10, Char* v11, Char* v12, Char* v13, Char* v14, Char* v15);
    private static void EncodeVariant(Variant data, EventData* dataDescriptor, Byte* dataBuffer);
    private int GetAverageStringVariantLength(Variant& v0, Variant& v1, Variant& v2, Variant& v3, Variant& v4, Variant& v5, Variant& v6, Variant& v7, Variant& v8, Variant& v9, Variant& v10, Variant& v11, Variant& v12, Variant& v13, Variant& v14, Variant& v15);
    private void TruncateStringVariant(Variant& v, int index, int averageStringVariantLength);
    private int GetOverflow();
}
[AttributeUsageAttribute("64")]
internal class System.Fabric.Common.Tracing.EventExtendedMetadataAttribute : Attribute {
    public static IList`1<MetadataField> MetadataFields;
    [CompilerGeneratedAttribute]
private TableEntityKind <TableEntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicEventName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public TableEntityKind TableEntityKind { get; public set; }
    public string PublicEventName { get; public set; }
    public string Category { get; public set; }
    public EventExtendedMetadataAttribute(TableEntityKind table, string publicEventName, string category);
    private static EventExtendedMetadataAttribute();
    [CompilerGeneratedAttribute]
public TableEntityKind get_TableEntityKind();
    [CompilerGeneratedAttribute]
public void set_TableEntityKind(TableEntityKind value);
    [CompilerGeneratedAttribute]
public string get_PublicEventName();
    [CompilerGeneratedAttribute]
public void set_PublicEventName(string value);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
}
[EventSourceAttribute]
internal class System.Fabric.Common.Tracing.FabricEvents : FabricEventSource {
    private static Lazy`1<FabricEvents> SingletonEvents;
    [CompilerGeneratedAttribute]
private static IVariantEventWriter <VariantEventWriterOverride>k__BackingField;
    public static FabricEvents Events { get; }
    private static IVariantEventWriter VariantEventWriterOverride { get; public set; }
    private static FabricEvents();
    public static FabricEvents get_Events();
    [CompilerGeneratedAttribute]
public static void set_VariantEventWriterOverride(IVariantEventWriter value);
    [CompilerGeneratedAttribute]
private static IVariantEventWriter get_VariantEventWriterOverride();
    [EventAttribute("59394")]
public void SystemFabric_InfoText(string id, string type, string message);
    [EventAttribute("59393")]
public void SystemFabric_WarningText(string id, string type, string message);
    [EventAttribute("59392")]
public void SystemFabric_ErrorText(string id, string type, string message);
    [EventAttribute("59395")]
public void SystemFabric_NoiseText(string id, string type, string message);
    [EventAttribute("65026")]
public void ServiceFramework_InfoText(string id, string type, string message);
    [EventAttribute("65025")]
public void ServiceFramework_WarningText(string id, string type, string message);
    [EventAttribute("65024")]
public void ServiceFramework_ErrorText(string id, string type, string message);
    [EventAttribute("65027")]
public void ServiceFramework_NoiseText(string id, string type, string message);
    [NonEventAttribute]
internal EventTask GetEventTask(string taskName);
    [NonEventAttribute]
protected virtual ReadOnlyDictionary`2<string, EventTask> GenerateTaskMap();
}
internal abstract class System.Fabric.Common.Tracing.FabricEventSource : EventSource {
    protected ReadOnlyDictionary`2<int, TraceEvent> eventDescriptors;
    protected ReadOnlyDictionary`2<string, EventTask> taskMap;
    [CompilerGeneratedAttribute]
private bool <IsManagedSystemServiceEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedClusterName>k__BackingField;
    public bool IsManagedSystemServiceEvent { get; private set; }
    public string ManagedClusterName { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsManagedSystemServiceEvent();
    [CompilerGeneratedAttribute]
private void set_IsManagedSystemServiceEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ManagedClusterName();
    [CompilerGeneratedAttribute]
private void set_ManagedClusterName(string value);
    [NonEventAttribute]
internal string GetEventTaskName(EventTask eventTask);
    [NonEventAttribute]
protected abstract virtual ReadOnlyDictionary`2<string, EventTask> GenerateTaskMap();
    [NonEventAttribute]
protected ReadOnlyDictionary`2<int, TraceEvent> GenerateEventDescriptors(IVariantEventWriter variantEventWriter);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12);
    [NonEventAttribute]
protected static void WriteEvent(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12, Variant param13);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12);
    [NonEventAttribute]
private static void WriteEventInternal(TraceEvent eventDescriptor, Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12, Variant param13);
    [NonEventAttribute]
public sealed virtual void VariantWrite(GenericEventDescriptor& genericEventDescriptor, int argCount, Variant v1, Variant v2, Variant v3, Variant v4, Variant v5, Variant v6, Variant v7, Variant v8, Variant v9, Variant v10, Variant v11, Variant v12, Variant v13, Variant v14, Variant v15, Variant v16);
    [NonEventAttribute]
public sealed virtual bool IsEnabled(byte level, long keywords);
    public static EventChannel ChannelToUse(EventAttribute eventAttribute, EventExtendedMetadataAttribute extended);
    public static string FormatStringToUse(EventAttribute eventAttribute, EventExtendedMetadataAttribute extended);
    private static ushort GetFormatArgumentsCount(string format);
    private static string ShiftFormatArguments(string format, ushort indicesDifference);
}
internal static class System.Fabric.Common.Tracing.FabricEventSourceConstants : object {
    public static string OperationalChannelTableNameSuffix;
    public static string OperationalChannelEventNameFormat;
}
internal class System.Fabric.Common.Tracing.GenericEventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public GenericEventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
}
internal interface System.Fabric.Common.Tracing.ICache`2 {
    public long Count { get; }
    public abstract virtual bool TryAddOrUpdate(TKey key, TValue value, TimeSpan itemLife, Action`1<TValue> onExpireCallback);
    public abstract virtual void RemoveIfPresent(TKey key);
    public abstract virtual long get_Count();
    public abstract virtual void Clear();
}
internal interface System.Fabric.Common.Tracing.IGenericEventSink {
    public abstract virtual void SetPath(string filename);
    public abstract virtual void SetOption(string option);
    public abstract virtual void Write(string processName, string v1, string v2, EventLevel informational, string formattedMessage);
}
internal interface System.Fabric.Common.Tracing.IVariantEventWriter {
    public bool IsManagedSystemServiceEvent { get; }
    public string ManagedClusterName { get; }
    public abstract virtual void VariantWrite(GenericEventDescriptor& genericEventDescriptor, int argCount, Variant v0, Variant v1, Variant v2, Variant v3, Variant v4, Variant v5, Variant v6, Variant v7, Variant v8, Variant v9, Variant v10, Variant v11, Variant v12, Variant v13, Variant v14, Variant v15);
    public abstract virtual bool IsEnabled(byte level, long keywords);
    public abstract virtual bool get_IsManagedSystemServiceEvent();
    public abstract virtual string get_ManagedClusterName();
}
[FlagsAttribute]
internal enum System.Fabric.Common.Tracing.Position : Enum {
    public int value__;
    public static Position None;
    public static Position Zero;
    public static Position One;
    public static Position Two;
    public static Position Three;
    public static Position Four;
    public static Position Five;
    public static Position Six;
    public static Position Seven;
    public static Position Eight;
    public static Position Nine;
    public static Position Ten;
    public static Position Eleven;
    public static Position Twelve;
    public static Position Thirteen;
}
[AttributeUsageAttribute("64")]
internal class System.Fabric.Common.Tracing.ProvisionalMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Position <PositionOfIdElements>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProvisionalTimeInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <PositionToExcludeFromTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlushAndClose>k__BackingField;
    public Position PositionOfIdElements { get; public set; }
    public UInt32 ProvisionalTimeInMs { get; public set; }
    public Position PositionToExcludeFromTrace { get; public set; }
    public bool FlushAndClose { get; public set; }
    [CompilerGeneratedAttribute]
public Position get_PositionOfIdElements();
    [CompilerGeneratedAttribute]
public void set_PositionOfIdElements(Position value);
    [CompilerGeneratedAttribute]
public UInt32 get_ProvisionalTimeInMs();
    [CompilerGeneratedAttribute]
public void set_ProvisionalTimeInMs(UInt32 value);
    [CompilerGeneratedAttribute]
public Position get_PositionToExcludeFromTrace();
    [CompilerGeneratedAttribute]
public void set_PositionToExcludeFromTrace(Position value);
    [CompilerGeneratedAttribute]
public bool get_FlushAndClose();
    [CompilerGeneratedAttribute]
public void set_FlushAndClose(bool value);
}
internal static class System.Fabric.Common.Tracing.TraceConfig : object {
    private static string SectionName;
    private static string TraceEtwSectionName;
    private static string TraceFileSectionName;
    private static string TraceConsoleSectionName;
    private static string TraceLevelKey;
    private static string TraceSamplingKey;
    private static string TraceProvisionalFeatureStatus;
    private static string FiltersKey;
    private static string PathKey;
    private static string OptionKey;
    private static Char[] FilterValueSeparatorArray;
    private static object SyncLock;
    private static ConfigUpdateHandler UpdateHandler;
    private static ReadOnlyCollection`1<TraceSinkFilter> SinkFilters;
    private static IConfigReader configReader;
    [CompilerGeneratedAttribute]
private static Action`1<TraceSinkType> OnFilterUpdate;
    private static TraceConfig();
    [CompilerGeneratedAttribute]
public static void add_OnFilterUpdate(Action`1<TraceSinkType> value);
    [CompilerGeneratedAttribute]
public static void remove_OnFilterUpdate(Action`1<TraceSinkType> value);
    public static void InitializeFromConfigStore(bool forceUpdate);
    public static void InitializeFromConfigStore(IConfigReader configReaderOverride);
    public static void SetDefaultLevel(TraceSinkType sinkType, EventLevel level);
    public static void SetDefaultSamplingRatio(TraceSinkType sinkType, double samplingRatio);
    public static bool AddFilter(TraceSinkType sinkType, string filter);
    public static bool RemoveFilter(TraceSinkType sinkType, string source);
    public static bool GetEventEnabledStatus(TraceSinkType sinkType, EventLevel level, EventTask taskId, string eventName);
    public static int GetEventSamplingRatio(TraceSinkType sinkType, EventLevel level, EventTask taskId, string eventName);
    public static bool GetEventProvisionalFeatureStatus(TraceSinkType sinkType);
    private static bool InternalAddFilter(TraceSinkType sinkType, string filter);
    private static TraceSinkFilter[] CreateSinkFilters();
    private static void SetDefaultConfigFilters(IReadOnlyList`1<TraceSinkFilter> filters);
    private static EventLevel ConvertLevel(int level);
    private static int ConvertSamplingRatio(double ratio);
    private static void InitializeTraceLevel(IConfigReader configStore, string configSection, TraceSinkType sinkType);
    private static void InitializeTraceProvisionalFeatureStatus(IConfigReader configStore, string configSection, TraceSinkType sinkType);
    private static void InitializeTraceSamplingRatio(IConfigReader configStore, string configSection, TraceSinkType sinkType);
    private static void InitializeFilters(IConfigReader configStore, string configSection, TraceSinkType sinkType);
    private static void InitializeTraceSink(string section);
    private static void InitializeEtwTrace(IConfigReader configStore);
    private static void InitializeTextTrace(IConfigReader configStore);
    private static void InitializeConsoleTrace(IConfigReader configStore);
    private static bool InternalRemoveFilter(TraceSinkType sinkType, string taskName);
    private static bool InternalAddFilter(TraceSinkType sink, string taskName, string eventName, EventLevel level, int samplingRatio);
}
internal class System.Fabric.Common.Tracing.TraceConsoleEventSink : object {
    private static object SyncLock;
    private static TraceConsoleEventSink();
    public sealed virtual void SetOption(string option);
    public sealed virtual void SetPath(string filename);
    public sealed virtual void Write(string processName, string v1, string v2, EventLevel informational, string formattedMessage);
}
internal static class System.Fabric.Common.Tracing.TraceConsoleSink : object {
    private static object SyncLock;
    private static TraceConsoleSink();
    public static void Write(EventLevel level, string text);
}
internal class System.Fabric.Common.Tracing.TraceEvent : object {
    public static ushort MaxFieldsPerEvent;
    public static ulong AdminChannelKeywordMask;
    public static ulong DebugChannelKeywordMask;
    public static ulong OperationalChannelKeywordMask;
    private static byte version;
    private static string FabricTracesTestKeywordEnvironmentVariable;
    private static ulong TestKeyword;
    private static int samplingCount;
    private IVariantEventWriter variantEventWriter;
    private EventTask taskId;
    private string taskName;
    private string eventName;
    private EventLevel level;
    private string format;
    private Boolean[] filterStates;
    internal bool hasId;
    internal int typeFieldIndex;
    private GenericEventDescriptor descriptor;
    private int samplingRatio;
    private bool isProvisionalFeatureEnabled;
    private bool isProvisionalEvent;
    private AgeBasedCache`2<VariantId, Variant[]> provisionalCache;
    private ProvisionalMetadataAttribute provisionalData;
    private Int32[] idPositions;
    private Int32[] toExcludePosition;
    public EventExtendedMetadataAttribute ExtendedMetadata;
    public string Message { get; }
    public string EventName { get; }
    public EventLevel Level { get; }
    public EventTask TaskId { get; }
    private bool IsProvisionalEnabled { get; }
    public TraceEvent(IVariantEventWriter variantEventWriter, EventTask taskId, ushort eventId, string eventName, EventLevel level, EventOpcode opcode, EventChannel channel, EventKeywords keywords, string format, bool hasId, ProvisionalMetadataAttribute provisionalAttribute, int typeFieldIndex, EventExtendedMetadataAttribute extendedMetadataAttribute);
    private static TraceEvent();
    public string get_Message();
    public string get_EventName();
    public EventLevel get_Level();
    public EventTask get_TaskId();
    private bool get_IsProvisionalEnabled();
    public void UpdateSinkEnabledStatus(TraceSinkType sinkType, bool enabled);
    public void UpdateSinkSamplingRatio(TraceSinkType sinkType, int newSamplingRatio);
    public void UpdateProvisionalFeatureStatus(TraceSinkType sinkType, bool isEnabled);
    private static ulong InitializeTestKeyword();
    public bool AreFlatSinksEnabled();
    public void WriteToFlatEventSinks(Variant[] variants);
    public bool IsEtwSinkEnabled();
    public void WriteToEtwSink();
    public void WriteToEtwSink(Variant param0);
    public void WriteToEtwSink(Variant param0, Variant param1);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12);
    public void WriteToEtwSink(Variant param0, Variant param1, Variant param2, Variant param3, Variant param4, Variant param5, Variant param6, Variant param7, Variant param8, Variant param9, Variant param10, Variant param11, Variant param12, Variant param13);
    private void PopulatePositions();
    private static Int32[] GetSetPositions(Position positions);
    private void WriteProvisional(Variant[] variants);
    private void FlushProvisional(Variant[] variants);
    private static Variant[] ExceptPositions(Variant[] variants, Int32[] indexToRemove);
    public static int GetSetBitCount(int value);
    private bool IsFileSinkEnabled();
    private bool IsConsoleSinkEnabled();
}
internal class System.Fabric.Common.Tracing.TraceFilterDescription : object {
    private EventTask traceTaskId;
    private string traceEventName;
    private EventLevel level;
    private int samplingRatio;
    public EventLevel Level { get; }
    public int SamplingRatio { get; }
    public TraceFilterDescription(EventTask taskId, string eventName, EventLevel level, int samplingRatio);
    public EventLevel get_Level();
    public int get_SamplingRatio();
    public bool Matches(EventTask taskId, string eventName);
    public int StaticCheck(EventTask taskId, string eventName);
}
internal class System.Fabric.Common.Tracing.TraceSinkFilter : object {
    private static bool DefaultProvisionalFeatureState;
    private TraceSinkType sinkType;
    private List`1<TraceFilterDescription> filters;
    private EventLevel defaultLevel;
    private int defaultSamplingRatio;
    private bool isProvisionalFeatureEnabledForCurrentSinkType;
    public TraceSinkType SinkType { get; }
    public bool ProvisionalFeatureStatus { get; public set; }
    public EventLevel DefaultLevel { get; public set; }
    public int DefaultSamplingRatio { get; public set; }
    public TraceSinkFilter(TraceSinkType sinkType, EventLevel defaultLevel);
    public TraceSinkType get_SinkType();
    public bool get_ProvisionalFeatureStatus();
    public void set_ProvisionalFeatureStatus(bool value);
    public EventLevel get_DefaultLevel();
    public void set_DefaultLevel(EventLevel value);
    public int get_DefaultSamplingRatio();
    public void set_DefaultSamplingRatio(int value);
    public void AddFilter(EventTask taskId, string eventName, EventLevel level, int samplingRatio);
    public void RemoveFilter(EventTask taskId, string eventName);
    public void ClearFilters();
    public bool StaticCheck(EventLevel level, EventTask taskId, string eventName, Int32& samplingRatio);
}
internal enum System.Fabric.Common.Tracing.TraceSinkType : Enum {
    public byte value__;
    public static TraceSinkType ETW;
    public static TraceSinkType TextFile;
    public static TraceSinkType Console;
    public static TraceSinkType Max;
}
internal static class System.Fabric.Common.Tracing.TraceTextFileSink : object {
    private static int MaxFilesToKeep;
    private static string Extension;
    private static string DefaultTraceType;
    private static object SyncLock;
    private static bool isEnabled;
    private static string option;
    private static DateTime segmentTime;
    private static List`1<TraceWriterInfo> traceWriters;
    internal static bool IsEnabled { get; }
    private static TraceTextFileSink();
    internal static bool get_IsEnabled();
    public static void SetPath(string traceType, string path);
    public static void SetPath(string path);
    public static void SetOption(string option);
    internal static void Write(string taskName, string eventName, string id, EventLevel level, string text);
    private static void SetPathInternal(string traceType, string path);
    private static string ConvertLevelToString(EventLevel level);
    private static void CloseTraceWriters();
    private static void CloseTraceWriter(TraceWriterInfo twi);
    private static void Close(TraceWriterInfo twi);
    private static void Close();
    private static void CalculateSegmentTime(DateTime now);
    private static void Open(TraceWriterInfo twi);
    private static UInt32 GetCurrentThreadId();
}
internal static class System.Fabric.Common.Tracing.TraceViaNative : object {
    public static void WriteUnstructured(string taskName, string eventName, string id, ushort level, string text);
}
internal class System.Fabric.Common.Tracing.Variant : ValueType {
    private static int SizeOfGuid;
    private ValuesVariant val;
    private string str;
    private byte size;
    private VariantType variantType;
    internal UInt32 Size { get; }
    private Variant(ValuesVariant val, string str, byte size, VariantType variantType);
    internal UInt32 get_Size();
    public static Variant op_Implicit(bool value);
    public static Variant op_Implicit(byte value);
    public static Variant op_Implicit(sbyte value);
    public static Variant op_Implicit(short value);
    public static Variant op_Implicit(ushort value);
    public static Variant op_Implicit(int value);
    public static Variant op_Implicit(UInt32 value);
    public static Variant op_Implicit(long value);
    public static Variant op_Implicit(ulong value);
    public static Variant op_Implicit(double value);
    public static Variant op_Implicit(Guid value);
    public static Variant op_Implicit(DateTime value);
    public static Variant op_Implicit(string value);
    public sealed virtual bool Equals(Variant other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool IsString();
    internal bool IsDefaultValue();
    internal string ConvertToString();
    internal bool ConvertToBoolean();
    internal byte ConvertToByte();
    internal sbyte ConvertToSByte();
    internal short ConvertToInt16();
    internal ushort ConvertToUInt16();
    internal int ConvertToInt32();
    internal UInt32 ConvertToUInt32();
    internal long ConvertToInt64();
    internal ulong ConvertToUInt64();
    internal Guid ConvertToGuid();
    internal DateTime ConvertToDateTime();
    internal object ToObject();
}
internal class System.Fabric.Common.Tracing.VariantId : object {
    private Variant[] variantArgs;
    private int currentIndex;
    public VariantId(int count);
    public void AddIdElement(Variant oneVariant);
    public sealed virtual bool Equals(VariantId other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal interface System.Fabric.INativeCredentialConverter {
    public abstract virtual IntPtr ToNative(PinCollection pin);
}
internal class System.Fabric.Interop.AsyncCallOutAdapter2`1 : object {
    private string functionTag;
    private Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc;
    private Func`2<IFabricAsyncOperationContext, TResult> endFunc;
    private InteropExceptionTracePolicy tracePolicy;
    private SharedNativeObject`1<IFabricAsyncOperationContext> nativeContext;
    private TaskCompletionSource`1<TResult> tcs;
    private bool runContinuationsAsynchronously;
    private string traceId;
    private IDisposable cancellationTokenRegistration;
    private bool isCompleted;
    private bool wasCancelled;
    private AsyncCallOutAdapter2`1(string functionTag, Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, InteropExceptionTracePolicy tracePolicy, bool runContinuationsAsynchronously);
    public static Task`1<TResult> WrapNativeAsyncInvoke(string functionTag, Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, bool runContinuationsAsynchronously);
    private Task`1<TResult> Start(CancellationToken cancellationToken);
    private void RegisterForCancellation(CancellationToken token);
    private void RegisterForCancellation(IFabricAsyncOperationContext context, CancellationToken token);
    private void Finish(IFabricAsyncOperationContext context, bool expectedCompletedSynchronously);
    private void DisposeCancelCallbackRegistrationOnAsyncOperationCompletion();
    private void FailTask(Exception e);
    private void Cancel();
    private void Cancel(IFabricAsyncOperationContext context);
    private sealed virtual override void System.Fabric.Interop.NativeCommon.IFabricAsyncOperationCallback.Invoke(IFabricAsyncOperationContext context);
    private void InitializeSharedContext(IFabricAsyncOperationContext context);
    private void TraceException(Exception ex, string format, Object[] args);
    [CompilerGeneratedAttribute]
private void <Start>b__13_0(IFabricAsyncOperationContext inner);
    [CompilerGeneratedAttribute]
private void <System.Fabric.Interop.NativeCommon.IFabricAsyncOperationCallback.Invoke>b__21_0(IFabricAsyncOperationContext inner);
}
internal class System.Fabric.Interop.AsyncTaskCallInAdapter : object {
    private Task callbackContinuation;
    private Task userTask;
    private InteropApi interopApi;
    private string functionTag;
    private int completedSynchronously;
    private IFabricAsyncOperationCallback nativeCallback;
    private CancellationTokenSource cancellationTokenSource;
    private int wasEndCalled;
    [CompilerGeneratedAttribute]
private static ReleaseComObjectWrapper <ReleaseComObjectWrapperInstance>k__BackingField;
    internal static ReleaseComObjectWrapper ReleaseComObjectWrapperInstance { get; internal set; }
    private static AsyncTaskCallInAdapter();
    public AsyncTaskCallInAdapter(IFabricAsyncOperationCallback callback, Task userTask, InteropApi interopApi, CancellationTokenSource cancellationTokenSource, string functionTag);
    [CompilerGeneratedAttribute]
internal static ReleaseComObjectWrapper get_ReleaseComObjectWrapperInstance();
    [CompilerGeneratedAttribute]
internal static void set_ReleaseComObjectWrapperInstance(ReleaseComObjectWrapper value);
    public static void End(IFabricAsyncOperationContext nativeContext);
    public static TResult End(IFabricAsyncOperationContext nativeContext);
    public sealed virtual sbyte CompletedSynchronously();
    public sealed virtual sbyte IsCompleted();
    public sealed virtual IFabricAsyncOperationCallback get_Callback();
    public sealed virtual void Cancel();
    private static AsyncTaskCallInAdapter EndHelper(IFabricAsyncOperationContext nativeContext);
    private void ProcessNativeCallback();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(Task t);
}
internal class System.Fabric.Interop.InteropApi : object {
    public static InteropApi Default;
    [CompilerGeneratedAttribute]
private bool <CopyExceptionDetailsToThreadErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldIncludeStackTraceInThreadErrorMessage>k__BackingField;
    public bool CopyExceptionDetailsToThreadErrorMessage { get; public set; }
    public bool ShouldIncludeStackTraceInThreadErrorMessage { get; public set; }
    private static InteropApi();
    [CompilerGeneratedAttribute]
public bool get_CopyExceptionDetailsToThreadErrorMessage();
    [CompilerGeneratedAttribute]
public void set_CopyExceptionDetailsToThreadErrorMessage(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldIncludeStackTraceInThreadErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludeStackTraceInThreadErrorMessage(bool value);
    public void HandleException(Exception ex);
    private static string GetExceptionInfoString(Type type, int HResult);
    private static string GetErrorStackTrace(Exception ex);
    private static string CreateThreadErrorMessage(Exception ex, bool includeStackTrace);
}
internal static class System.Fabric.Interop.InteropExceptionMap : object {
    [CompilerGeneratedAttribute]
private static IDictionary`2<int, Func`3<Exception, string, Exception>> <NativeToManagedConversion>k__BackingField;
    public static IDictionary`2<int, Func`3<Exception, string, Exception>> NativeToManagedConversion { get; private set; }
    private static InteropExceptionMap();
    [CompilerGeneratedAttribute]
public static IDictionary`2<int, Func`3<Exception, string, Exception>> get_NativeToManagedConversion();
    [CompilerGeneratedAttribute]
private static void set_NativeToManagedConversion(IDictionary`2<int, Func`3<Exception, string, Exception>> value);
}
internal enum System.Fabric.Interop.InteropExceptionTracePolicy : Enum {
    public int value__;
    public static InteropExceptionTracePolicy None;
    public static InteropExceptionTracePolicy Info;
    public static InteropExceptionTracePolicy Warning;
    public static InteropExceptionTracePolicy WarningExceptInfoForTransient;
    public static InteropExceptionTracePolicy Default;
}
internal interface System.Fabric.Interop.IPinNode {
    public abstract virtual IntPtr AddrOfPinnedObject();
}
internal static class System.Fabric.Interop.Kernel32Types : object {
}
internal static class System.Fabric.Interop.NativeClient : object {
    internal static IFabricPropertyManagementClient2 FabricCreateClient(ushort connectionStringsSize, IntPtr connectionStrings, Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateLocalClient(Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateClient2(ushort connectionStringsSize, IntPtr connectionStrings, IFabricServiceNotificationEventHandler notificationhandler, Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateLocalClient2(IFabricServiceNotificationEventHandler notificationhandler, Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateClient3(ushort connectionStringsSize, IntPtr connectionStrings, IFabricServiceNotificationEventHandler notificationhandler, IFabricClientConnectionEventHandler connectionHandler, Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateLocalClient3(IFabricServiceNotificationEventHandler notificationhandler, IFabricClientConnectionEventHandler connectionHandler, Guid& iid);
    internal static IFabricPropertyManagementClient2 FabricCreateLocalClient4(IFabricServiceNotificationEventHandler notificationhandler, IFabricClientConnectionEventHandler connectionHandler, FABRIC_CLIENT_ROLE clientRole, Guid& iid);
    internal static IFabricGetRollingUpgradeMonitoringPolicyResult FabricGetDefaultRollingUpgradeMonitoringPolicy();
}
internal static class System.Fabric.Interop.NativeCommon : object {
    internal static IFabricConfigStore2 FabricGetConfigStore(Guid& riid, IFabricConfigStoreUpdateHandler2 updateHandler);
    internal static IFabricStringResult FabricEncryptText(IntPtr text, IntPtr certThumbPrint, IntPtr certStoreName, FABRIC_X509_STORE_LOCATION certStoreLocation, IntPtr algorithmOid);
    internal static IFabricStringResult FabricEncryptText2(IntPtr text, IntPtr certFilePath, IntPtr algorithmOid);
    internal static IFabricStringResult FabricDecryptText(IntPtr encryptedValue, FABRIC_X509_STORE_LOCATION certStoreLocation);
    internal static sbyte FabricIsValidExpression(IntPtr expression);
    internal static IFabricStringResult FabricGetRoot2(IntPtr machineName);
    internal static IFabricStringResult FabricGetRoot();
    internal static IFabricStringResult FabricGetBinRoot2(IntPtr machineName);
    internal static IFabricStringResult FabricGetBinRoot();
    internal static IFabricStringResult FabricGetCodePath2(IntPtr machineName);
    internal static IFabricStringResult FabricGetCodePath();
    internal static IFabricStringResult FabricGetDataRoot2(IntPtr machineName);
    internal static IFabricStringResult FabricGetDataRoot();
    internal static IFabricStringResult FabricGetLogRoot2(IntPtr machineName);
    internal static IFabricStringResult FabricGetLogRoot();
    internal static void FabricDirectoryCreate(IntPtr path);
    internal static IFabricStringListResult FabricDirectoryGetDirectories(IntPtr path, IntPtr pattern, sbyte getFullPath, sbyte topDirectoryOnly);
    internal static IFabricStringListResult FabricDirectoryGetFiles(IntPtr path, IntPtr pattern, sbyte getFullPath, sbyte topDirectoryOnly);
    internal static void FabricDirectoryCopy(IntPtr src, IntPtr des, sbyte overwrite);
    internal static void FabricDirectoryRename(IntPtr src, IntPtr des, sbyte overwrite);
    internal static void FabricDirectoryExists(IntPtr path, SByte& isExisted);
    internal static void FabricDirectoryDelete(IntPtr path, sbyte recursive, sbyte deleteReadOnlyFiles);
    internal static void FabricDirectoryIsSymbolicLink(IntPtr path, SByte& result);
    internal static void FabricSetRoot2(IntPtr root, IntPtr machineName);
    internal static void FabricSetRoot(IntPtr root);
    internal static void FabricSetBinRoot2(IntPtr binRoot, IntPtr machineName);
    internal static void FabricSetBinRoot(IntPtr binRoot);
    internal static void FabricSetCodePath2(IntPtr codePath, IntPtr machineName);
    internal static void FabricSetCodePath(IntPtr codePath);
    internal static void FabricSetDataRoot2(IntPtr dataRoot, IntPtr machineName);
    internal static void FabricSetDataRoot(IntPtr dataRoot);
    internal static void FabricSetLogRoot2(IntPtr logRoot, IntPtr machineName);
    internal static void FabricSetLogRoot(IntPtr logRoot);
    internal static IFabricStringResult FabricGetLastErrorMessage();
    internal static long FabricSetLastErrorMessage(IntPtr message);
    internal static void FabricFileOpen(IntPtr path, FABRIC_FILE_MODE fileMode, FABRIC_FILE_ACCESS fileAccess, FABRIC_FILE_SHARE fileShare, IntPtr& fileHandle);
    internal static void FabricFileOpenEx(IntPtr path, FABRIC_FILE_MODE fileMode, FABRIC_FILE_ACCESS fileAccess, FABRIC_FILE_SHARE fileShare, FABRIC_FILE_ATTRIBUTES fileAttributes, IntPtr& fileHandle);
    internal static void FabricFileCopy(IntPtr src, IntPtr des, sbyte overwrite);
    internal static void FabricFileMove(IntPtr src, IntPtr des);
    internal static void FabricFileExists(IntPtr path, SByte& isExisted);
    internal static void FabricFileDelete(IntPtr path, sbyte deleteReadonly);
    internal static void FabricFileRemoveReadOnlyAttribute(IntPtr path);
    internal static void FabricFileReplace(IntPtr replacedFileName, IntPtr replacementFileName, IntPtr backupFileName, sbyte ignoreMergeErrors);
    internal static void FabricFileCreateHardLink(IntPtr fileName, IntPtr existingFileName, SByte& succeeded);
    internal static void FabricFileGetSize(IntPtr path, Int64& size);
    internal static void FabricFileGetLastWriteTime(IntPtr path, NativeFILETIME& lastWriteTime);
    internal static IFabricStringResult FabricFileGetVersionInfo(IntPtr path);
    internal static IFabricStringResult FabricGetUncPath(IntPtr path);
    internal static IFabricStringResult FabricGetDirectoryName(IntPtr path);
    internal static IFabricStringResult FabricGetFullPath(IntPtr path);
    internal static void FabricGetNodeIdFromNodeName(IntPtr nodeName, IntPtr rolesForWhichToUseV1Generator, sbyte useV2NodeIdGenerator, IntPtr nodeIdGeneratorVersion, FABRIC_NODE_ID& nodeId);
    internal static void WriteManagedTrace(IntPtr taskName, IntPtr eventName, IntPtr id, ushort level, IntPtr text);
    internal static void CabExtractFiltered(IntPtr cabPath, IntPtr extractPath, IntPtr filters, sbyte inclusive);
    internal static sbyte IsCabFile(IntPtr cabPath);
    internal static void FabricPerfCounterCreateCounterSet(IntPtr counterSetInitializer, IntPtr& counterSetHandle);
    internal static void FabricPerfCounterCreateCounterSetInstance(IntPtr hCounterSet, IntPtr instanceName, IntPtr& counterSetInstanceHandle);
    internal static void FabricPerfCounterSetPerformanceCounterRefValue(IntPtr hCounterSetInstance, int id, IntPtr counterAddress);
    internal static void FabricPerfCounterDeleteCounterSetInstance(IntPtr hCounterSetInstance);
    internal static void FabricPerfCounterDeleteCounterSet(IntPtr hCounterSet);
    internal static void GenerateSelfSignedCertAndImportToStore(IntPtr subName, IntPtr storeName, IntPtr profile, IntPtr DNS, NativeFILETIME expireDate);
    internal static void GenerateSelfSignedCertAndSaveAsPFX(IntPtr subName, IntPtr fileName, IntPtr password, IntPtr DNS, NativeFILETIME expireDate);
    internal static void DeleteCertificateFromStore(IntPtr certName, IntPtr store, IntPtr profile, sbyte isExactMatch);
    internal static void VerifyFileSignature(IntPtr filename, SByte& isValid);
    internal static void FabricSetEnableCircularTraceSession(bool enableCircularTraceSession);
    internal static void FabricSetEnableCircularTraceSession2(bool enableCircularTraceSession, IntPtr machineName);
    internal static bool FabricGetEnableCircularTraceSession();
    internal static bool FabricGetEnableCircularTraceSession2(IntPtr machineName);
    internal static void FabricSetFabricTraceFileSizeInMB(UInt32 fabricTraceFileSizeInMB);
    internal static void FabricSetFabricTraceFileSizeInMB2(UInt32 fabricTraceFileSizeInMB, IntPtr machineName);
    internal static UInt32 FabricGetFabricTraceFileSizeInMB();
    internal static UInt32 FabricGetFabricTraceFileSizeInMB2(IntPtr machineName);
    internal static void FabricSetLeaseTraceFileSizeInMB(UInt32 leaseTraceFileSizeInMB);
    internal static void FabricSetLeaseTraceFileSizeInMB2(UInt32 leaseTraceFileSizeInMB, IntPtr machineName);
    internal static UInt32 FabricGetLeaseTraceFileSizeInMB();
    internal static UInt32 FabricGetLeaseTraceFileSizeInMB2(IntPtr machineName);
    internal static void FabricSetEnableUnsupportedPreviewFeatures(bool enableUnsupportedPreviewFeatures);
    internal static void FabricSetEnableUnsupportedPreviewFeatures2(bool enableUnsupportedPreviewFeatures, IntPtr machineName);
    internal static void FabricSetIsSFVolumeDiskServiceEnabled(bool isSFVolumeDiskServiceEnabled);
    internal static void FabricSetIsSFVolumeDiskServiceEnabled2(bool isSFVolumeDiskServiceEnabled, IntPtr machineName);
    internal static void FabricSetDisableKernelDriver(bool disableKernelDriver);
    internal static void FabricSetDisableKernelDriver2(bool disableKernelDriver, IntPtr machineName);
}
internal static class System.Fabric.Interop.NativeRuntime : object {
    internal static IFabricAsyncOperationContext FabricBeginCreateRuntime(Guid& riid, IFabricProcessExitHandler exitHandler, UInt32 timeoutMilliseconds, IFabricAsyncOperationCallback callback);
    internal static IFabricRuntime FabricEndCreateRuntime(IFabricAsyncOperationContext context);
    internal static IFabricRuntime FabricCreateRuntime(Guid& riid);
    internal static IFabricAsyncOperationContext FabricBeginGetActivationContext(Guid& riid, UInt32 timeoutMilliseconds, IFabricAsyncOperationCallback callback);
    internal static IFabricCodePackageActivationContext6 FabricEndGetActivationContext(IFabricAsyncOperationContext context);
    internal static IFabricCodePackageActivationContext6 FabricGetActivationContext(Guid& riid);
    internal static IFabricAsyncOperationContext FabricBeginGetNodeContext(UInt32 timeoutMilliseconds, IFabricAsyncOperationCallback callback);
    internal static IFabricNodeContextResult2 FabricEndGetNodeContext(IFabricAsyncOperationContext context);
    internal static IFabricNodeContextResult2 FabricGetNodeContext();
    internal static IFabricReplicatorSettingsResult FabricLoadReplicatorSettings(IFabricCodePackageActivationContext codePackageActivationContext, IntPtr configurationPackageName, IntPtr sectionName);
    internal static IFabricEseLocalStoreSettingsResult FabricLoadEseLocalStoreSettings(IFabricCodePackageActivationContext codePackageActivationContext, IntPtr configurationPackageName, IntPtr sectionName);
    internal static IFabricSecurityCredentialsResult FabricLoadSecurityCredentials(IFabricCodePackageActivationContext codePackageActivationContext, IntPtr configurationPackageName, IntPtr sectionName);
    internal static IFabricKeyValueStoreReplica4 FabricCreateKeyValueStoreReplica4(Guid& riid, IntPtr storeName, Guid partitionId, long replicaId, IntPtr serviceName, IntPtr fabricReplicatorSettings, FABRIC_LOCAL_STORE_KIND localStoreKind, IntPtr localStorageSettings, IFabricStoreEventHandler storeEventHandler, IFabricSecondaryEventHandler secondaryEventHandler, FABRIC_KEY_VALUE_STORE_NOTIFICATION_MODE notificationMode);
    internal static IFabricKeyValueStoreReplica8 FabricCreateKeyValueStoreReplica5(Guid& riid, IntPtr storeName, Guid partitionId, long replicaId, IntPtr serviceName, IntPtr fabricReplicatorSettings, IntPtr kvsSettings, FABRIC_LOCAL_STORE_KIND localStoreKind, IntPtr localStorageSettings, IFabricStoreEventHandler storeEventHandler, IFabricSecondaryEventHandler secondaryEventHandler);
    internal static IFabricKeyValueStoreReplica8 FabricCreateKeyValueStoreReplica_V2(Guid& riid, Guid partitionId, long replicaId, IntPtr storeSettings, IntPtr replicatorSettings, IFabricStoreEventHandler storeEventHandler, IFabricSecondaryEventHandler secondaryEventHandler);
    internal static int FabricBeginReplicate3(IntPtr fabricInternalManagedReplicator, int count, IntPtr buffersAddress, IntPtr endReplicateCallbackPtr, IntPtr tcsHandlePtr, Int64& sequenceNumber);
    internal static IntPtr FabricGetDataFromOperationData(IntPtr operationData, UInt32& countAllocatedByNative);
    internal static IFabricAsyncOperationContext FabricBeginGetCodePackageActivator(Guid& riid, UInt32 timeoutMilliseconds, IFabricAsyncOperationCallback callback);
    internal static IFabricCodePackageActivator2 FabricEndGetCodePackageActivator(IFabricAsyncOperationContext context);
    internal static IFabricCodePackageActivator2 FabricGetCodePackageActivator(Guid& riid);
}
internal static class System.Fabric.Interop.NativeRuntimeInternal : object {
    internal static IFabricKeyValueStoreReplicaSettingsResult GetFabricKeyValueStoreReplicaDefaultSettings();
    internal static IFabricKeyValueStoreReplicaSettings_V2Result GetFabricKeyValueStoreReplicaDefaultSettings_V2(IntPtr workingDirectory, IntPtr sharedLogDirectory, IntPtr sharedLogFileName, Guid sharedLogGuid);
    internal static IFabricSharedLogSettingsResult GetFabricSharedLogDefaultSettings(IntPtr workingDirectory, IntPtr sharedLogDirectory, IntPtr sharedLogFileName, Guid sharedLogGuid);
    internal static IFabricSecurityCredentialsResult FabricLoadClusterSecurityCredentials();
    internal static IFabricStringResult FabricGetRuntimeDllVersion();
}
internal static class System.Fabric.Interop.NativeTypes : object {
    internal static long FABRIC_INVALID_ATOMIC_GROUP_ID;
    internal static long FABRIC_INVALID_SEQUENCE_NUMBER;
    internal static long FABRIC_AUTO_SEQUENCE_NUMBER;
    internal static long FABRIC_INVALID_INSTANCE_ID;
    internal static ulong FABRIC_INVALID_NODE_INSTANCE_ID;
    internal static UInt32 FABRIC_INVALID_OPERATION_INDEX;
    internal static long FABRIC_IGNORE_SEQUENCE_NUMBER_CHECK;
    internal static UInt32 FABRIC_HEALTH_REPORT_INFINITE_TTL;
    internal static string FABRIC_SECURITY_ROLE_NAME_AUTHENTICATED_USERS;
    internal static string FABRIC_SECURITY_ROLE_NAME_ADMINISTRATOR;
    internal static UInt32 FABRIC_INFINITE_DURATION;
    private static Byte[] EmptyByteArray;
    private static NativeFILETIME MinNativeFILETIME;
    private static NativeTypes();
    public static DateTime FromNativeFILETIME(NativeFILETIME filetime);
    public static DateTime FromNativeTicks(long ticks);
    public static Nullable`1<DateTime> FromNullableNativeFILETIME(NativeFILETIME filetime);
    public static NativeFILETIME ToNativeFILETIME(DateTime dateTime);
    public static long ToNativeTicks(DateTime dateTime);
    public static sbyte ToBOOLEAN(bool flag);
    public static bool FromBOOLEAN(sbyte flag);
    public static Byte[] FromNativeBytes(IntPtr p, UInt32 size);
    public static Tuple`2<UInt32, IntPtr> ToNativeBytes(PinCollection pin, Byte[] data);
    public static string FromNativeString(IFabricStringResult result);
    public static SecureString FromNativeToSecureString(IFabricStringResult nativeResult);
    public static SecureString FromNativeToSecureString(IntPtr nativeString);
    public static string FromNativeString(IntPtr p);
    public static string FromNativeStringPointer(IntPtr p);
    public static IDictionary`2<string, string> FromNativeStringMap(IFabricStringMapResult nativeResult);
    internal static IDictionary`2<string, string> FromNativeStringPairList(IntPtr nativePtr);
    internal static IntPtr ToNativeStringPairList(PinCollection pin, IDictionary`2<string, string> stringPairList);
    public static Uri FromNativeUri(IntPtr p);
    public static List`1<string> FromNativeStringList(FABRIC_STRING_LIST stringList);
    public static List`1<string> FromNativeStringList(IntPtr nativePtr);
    public static IntPtr ToNativeStringList(PinCollection pin, IList`1<string> stringList);
    public static IntPtr ToNativeStringPointerArray(PinCollection pin, IList`1<string> stringList);
    private static int GetNativeStringLength(IntPtr stringIntPtr);
    public static NodeId FromNativeNodeId(FABRIC_NODE_ID nativeNodeId);
    public static FABRIC_NODE_ID ToNativeNodeId(NodeId nodeId);
}
internal static class System.Fabric.Interop.NTTypes : object {
}
internal class System.Fabric.Interop.PinArray : object {
    private SafePinHandle arrayHandle;
    private IPinNode[] nodes;
    private IntPtr[] pinnedItems;
    public int Count { get; }
    public PinArray(IEnumerable enumerable, PinCallback pinCallback);
    public int get_Count();
    public sealed virtual IntPtr AddrOfPinnedObject();
    public sealed virtual void Dispose();
    private int CountItems(IEnumerable enumerable);
}
internal class System.Fabric.Interop.PinBlittable : object {
    private SafePinHandle handle;
    private object item;
    private IntPtr address;
    public PinBlittable(object item);
    public PinBlittable(Uri uri);
    public static PinBlittable Create(object item);
    public static PinBlittable Create(Uri uri);
    public sealed virtual IntPtr AddrOfPinnedObject();
    public sealed virtual void Dispose();
}
internal class System.Fabric.Interop.PinCollection : Collection`1<IPinNode> {
    public IntPtr AddBlittable(object item);
    public IntPtr AddObject(IPinNode pin);
    public IntPtr AddObject(string pin);
    public IntPtr AddObject(Uri uri);
    public IntPtr AddObject(SecureString secureString);
    public virtual IntPtr AddrOfPinnedObject();
    public sealed virtual void Dispose();
}
internal class System.Fabric.Interop.SafePinHandle : SafeHandle {
    public bool IsInvalid { get; }
    public SafePinHandle(object target);
    public virtual bool get_IsInvalid();
    public IntPtr AddrOfPinnedObject();
    protected virtual bool ReleaseHandle();
}
internal class System.Fabric.Interop.SecureStringPinNode : object {
    private IntPtr stringPtr;
    public SecureStringPinNode(SecureString secureString);
    protected virtual override void Finalize();
    public sealed virtual IntPtr AddrOfPinnedObject();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class System.Fabric.Interop.SharedNativeObject`1 : object {
    private T sharedNativeObject;
    private ReferenceCount<T> referenceCount;
    private string typeName;
    private string traceType;
    public SharedNativeObject`1(string traceType);
    public bool TryInitialize(T nativeObject);
    public T TryAcquire();
    public void Release();
    public void TryAcquireAndInvoke(Action`1<T> action);
    private long GetCurrentCount();
}
internal class System.Fabric.Interop.StringCollectionResult : ItemList`1<string> {
    private StringCollectionResult(bool mayContainDuplicates);
    internal static StringCollectionResult FromNative(IFabricStringListResult innerCollection);
    internal static StringCollectionResult FromNative(IFabricStringListResult innerCollection, bool mayContainDuplicates);
}
internal class System.Fabric.Interop.StringListResult : object {
    private PinCollection pinCollection;
    private UInt32 count;
    private IntPtr items;
    public StringListResult(IList`1<string> list);
    public sealed virtual IntPtr GetStrings(UInt32& itemCount);
}
internal class System.Fabric.Interop.StringResult : object {
    private IPinNode pin;
    public StringResult(string s);
    public static string FromNative(IFabricStringResult nativeResult);
    public static SecureString FromNativeToSecureString(IFabricStringResult nativeResult);
    public sealed virtual IntPtr get_String();
}
internal static class System.Fabric.Interop.Utility : object {
    private static double MaxValidTimeSpanMilliseconds;
    public static void ReleaseFail(string format, Object[] args);
    public static void ReleaseAssert(bool cond, string format, Object[] args);
    public static UInt32 ToMilliseconds(TimeSpan timespan, string argumentName);
    public static Exception TranslateCOMExceptionToManaged(COMException e, string functionTag);
    public static COMException TryTranslateExceptionToCOM(Exception e);
    public static Exception TryTranslateManagedExceptionToCOM(Exception e);
    public static Exception TranslateArgumentException(ArgumentException e);
    private static string GetErrorDetails();
    public static void TryTranslateManagedExceptionToCOMAndThrow(Exception e);
    public static IFabricAsyncOperationContext WrapNativeAsyncMethodImplementation(Func`2<CancellationToken, Task> func, IFabricAsyncOperationCallback callback, string functionTag);
    public static IFabricAsyncOperationContext WrapNativeAsyncMethodImplementation(Func`2<CancellationToken, Task> func, IFabricAsyncOperationCallback callback, string functionTag, InteropApi interopApi);
    public static TResult WrapNativeSyncMethodImplementation(Func`1<TResult> func, string functionTag);
    public static TResult WrapNativeSyncMethodImplementation(Func`1<TResult> func, string functionTag, InteropApi interopApi);
    public static void WrapNativeSyncMethodImplementation(Action action, string functionTag);
    public static void WrapNativeSyncMethodImplementation(Action action, string functionTag, InteropApi interopApi);
    public static Task WrapNativeAsyncInvokeInMTA(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Action`1<IFabricAsyncOperationContext> endFunc, CancellationToken cancellationToken, string functionTag);
    public static Task WrapNativeAsyncInvokeInMTA(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Action`1<IFabricAsyncOperationContext> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, string functionTag);
    public static Task`1<TResult> WrapNativeAsyncInvokeInMTA(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, CancellationToken cancellationToken, string functionTag);
    public static Task`1<TResult> WrapNativeAsyncInvokeInMTA(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, string functionTag);
    public static Task WrapNativeAsyncInvoke(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Action`1<IFabricAsyncOperationContext> endFunc, CancellationToken cancellationToken, string functionTag);
    public static Task WrapNativeAsyncInvoke(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Action`1<IFabricAsyncOperationContext> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, string functionTag);
    public static Task`1<TResult> WrapNativeAsyncInvoke(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, CancellationToken cancellationToken, string functionTag);
    public static Task`1<TResult> WrapNativeAsyncInvoke(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, string functionTag);
    public static Task`1<TResult> WrapNativeAsyncInvoke(Func`2<IFabricAsyncOperationCallback, IFabricAsyncOperationContext> beginFunc, Func`2<IFabricAsyncOperationContext, TResult> endFunc, InteropExceptionTracePolicy tracePolicy, CancellationToken cancellationToken, bool runContinuationsAsynchronously, string functionTag);
    public static void WrapNativeSyncInvokeInMTA(Action action, string functionTag);
    public static TResult WrapNativeSyncInvokeInMTA(Func`1<TResult> func, string functionTag);
    public static void WrapNativeSyncInvoke(Action action, string functionTag, string functionArgs);
    public static TResult WrapNativeSyncInvoke(Func`1<TResult> func, string functionTag, string functionArgs);
    public static void SafeReleaseComObject(object obj);
    public static void SafeFinalReleaseComObject(object obj);
    public static Task`1<TResult> CreateCompletedTask(TResult result);
    private static TResult RunInMTA(Func`1<TResult> func);
    private static void RunInMTA(Action action);
    internal static T ReadXml(string fileName, string schemaFile);
    internal static T ReadXmlString(string xmlString, string schemaFile);
    internal static T ReadXml(string fileName);
    internal static T ReadXml(XmlReader reader);
}
internal class System.Fabric.KeyValueStoreReplica_V2 : KeyValueStoreReplica {
    [CompilerGeneratedAttribute]
private KeyValueStoreReplicaSettings_V2 <KeyValueStoreReplicaSettings_V2>k__BackingField;
    public KeyValueStoreReplicaSettings_V2 KeyValueStoreReplicaSettings_V2 { get; private set; }
    public SecondaryNotificationMode NotificationMode { get; }
    public KeyValueStoreReplica_V2(string workingDirectory, string storeDirectory, string storeName, Guid partitionId);
    public KeyValueStoreReplica_V2(ReplicatorSettings replicatorSettings, KeyValueStoreReplicaSettings_V2 kvsSettings);
    private KeyValueStoreReplica_V2(string storeName, ReplicatorSettings replicatorSettings, KeyValueStoreReplicaSettings_V2 kvsSettings);
    public KeyValueStoreReplica_V2(string storeNames);
    [CompilerGeneratedAttribute]
public KeyValueStoreReplicaSettings_V2 get_KeyValueStoreReplicaSettings_V2();
    [CompilerGeneratedAttribute]
private void set_KeyValueStoreReplicaSettings_V2(KeyValueStoreReplicaSettings_V2 value);
    public virtual SecondaryNotificationMode get_NotificationMode();
    public void Initialize_OverrideNativeKeyValueStore(StatefulServiceInitializationParameters initParams);
}
internal class System.Fabric.KeyValueStoreReplicaSettings_V2 : object {
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private SharedLogSettings <SharedLogSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private SecondaryNotificationMode <SecondaryNotificationMode>k__BackingField;
    public string WorkingDirectory { get; private set; }
    public SharedLogSettings SharedLogSettings { get; private set; }
    public SecondaryNotificationMode SecondaryNotificationMode { get; public set; }
    public KeyValueStoreReplicaSettings_V2(string workingDirectory);
    public KeyValueStoreReplicaSettings_V2(string workingDirectory, string sharedLogDirectory, string sharedLogFileName, Guid sharedLogGuid);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
private void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public SharedLogSettings get_SharedLogSettings();
    [CompilerGeneratedAttribute]
private void set_SharedLogSettings(SharedLogSettings value);
    [CompilerGeneratedAttribute]
public SecondaryNotificationMode get_SecondaryNotificationMode();
    [CompilerGeneratedAttribute]
public void set_SecondaryNotificationMode(SecondaryNotificationMode value);
    private void LoadFromConfigHelper(string workingDirectory, string sharedLogDirectory, string sharedLogFileName, Guid sharedLogGuid);
    internal IntPtr ToNative(PinCollection pin);
    private void FromNative(IntPtr nativeSettingsPtr);
}
internal class System.Fabric.NativeClaimsCredentialConverter : object {
    private ClaimsCredentials claimsCredentials;
    public NativeClaimsCredentialConverter(ClaimsCredentials securityCredentials);
    public sealed virtual IntPtr ToNative(PinCollection pin);
}
internal class System.Fabric.NativeNoneCredentialConverter : object {
    public sealed virtual IntPtr ToNative(PinCollection pin);
}
internal class System.Fabric.NativeWindowsCredentialConverter : object {
    private WindowsCredentials windowsCredentials;
    public NativeWindowsCredentialConverter(WindowsCredentials windowsCredentials);
    public sealed virtual IntPtr ToNative(PinCollection pin);
}
internal class System.Fabric.NativeX509CredentialConverter : object {
    private X509Credentials x509Credentials;
    internal NativeX509CredentialConverter(X509Credentials x509Credentials);
    public sealed virtual IntPtr ToNative(PinCollection pin);
    private static FABRIC_X509_STORE_LOCATION ToNativeStoreLocation(StoreLocation storeLocation);
    private static FABRIC_X509_FIND_TYPE ToNativeX509FindType(X509FindType findType);
}
internal class System.Fabric.ReadOnlyOperationData : object {
    private IFabricOperationData nativeOperationData;
    internal IFabricOperationData NativeOperationData { get; }
    internal ReadOnlyOperationData(IFabricOperationData operationData);
    internal IFabricOperationData get_NativeOperationData();
    [IteratorStateMachineAttribute("System.Fabric.ReadOnlyOperationData/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<ArraySegment`1<byte>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static ArraySegment`1<byte> GetSegment(IntPtr buffer, int index);
}
[ExtensionAttribute]
internal static class System.Fabric.SecurityCredentialExtension : object {
    [ExtensionAttribute]
internal static IntPtr ToNative(SecurityCredentials securityCredentials, PinCollection pin);
}
internal class System.Fabric.SharedLogSettings : object {
    [CompilerGeneratedAttribute]
private string <ContainerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LogSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumNumberStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumRecordSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CreateFlags>k__BackingField;
    public string ContainerPath { get; public set; }
    public Guid ContainerId { get; public set; }
    public long LogSizeInBytes { get; public set; }
    public int MaximumNumberStreams { get; public set; }
    public int MaximumRecordSize { get; public set; }
    public int CreateFlags { get; public set; }
    public SharedLogSettings(string workingDirectory);
    public SharedLogSettings(string workingDirectory, string sharedLogDirectory, string sharedLogFileName, Guid sharedLogGuid);
    internal SharedLogSettings(IntPtr nativeSettingsPtr);
    [CompilerGeneratedAttribute]
public string get_ContainerPath();
    [CompilerGeneratedAttribute]
public void set_ContainerPath(string value);
    [CompilerGeneratedAttribute]
public Guid get_ContainerId();
    [CompilerGeneratedAttribute]
public void set_ContainerId(Guid value);
    [CompilerGeneratedAttribute]
public long get_LogSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_LogSizeInBytes(long value);
    [CompilerGeneratedAttribute]
public int get_MaximumNumberStreams();
    [CompilerGeneratedAttribute]
public void set_MaximumNumberStreams(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumRecordSize();
    [CompilerGeneratedAttribute]
public void set_MaximumRecordSize(int value);
    [CompilerGeneratedAttribute]
public int get_CreateFlags();
    [CompilerGeneratedAttribute]
public void set_CreateFlags(int value);
    private void LoadFromConfigHelper(string workingDirectory, string sharedLogDirectory, string sharedLogFileName, Guid sharedLogGuid);
    internal IntPtr ToNative(PinCollection pin);
    private void FromNative(IntPtr nativeSettingsPtr);
}
