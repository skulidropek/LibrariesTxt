internal static class AssemblyVersionInfo : object {
    public static string VersionString;
    public static int MajorVersion;
    public static int MinorVersion;
    public static int BuildVersion;
    public static int SPLevel;
    public static string ProductVersionString;
    public static string ProductNameString;
    public static string SqlEngineUsageMetricsRoleGuidString;
    public static string ProductNameBrandingString;
    public static string LongProductNameBrandingString;
    public static string ProductNameShortcutBrandingString;
    public static string ProductCodeNameString;
    public static string VersionLocationString;
    public static string FileVersionSuffix;
    public static string ProductVersionLocationString;
    public static string VersionHelpKeywordPrefix;
    public static string VersionHelpSettingsToken;
    public static string SetupSupportFolder;
    public static string ProductLicenseFile;
    public static string SqlProductFamilyCode;
    public static string ProductUpdateCategory;
    public static string ProductDiscoveryId;
    public static string SqlInstanceIDPrefix;
    public static string AsInstanceIDPrefix;
    public static string RsInstanceIDPrefix;
    public static string MaxMaintenanceVersion;
    public static UInt32 evalTimeBombValue;
    public static UInt32 currentReleaseTimeBombValue;
    public static string WerEventNameSetupMsi;
    public static string WerEventNameSetupConfig;
    public static string ASUsageMetricsRoleGuidString;
    public static string SqlMajorFileVersion;
    public static string LicenseLink;
    public static string VersionHelpNamespace;
    public static string VersionBIDSHelpNamespace;
    public static string VisualStudioShellVersion;
    public static string VisualStudio2012ShellVersion;
    public static string MroBaselineRuntimeVersion;
    public static string MpoBaselineRuntimeVersion;
}
internal static class Microsoft.SqlServer.Types.Aggregates : object {
    public static T Execute(IAggregate`1<T> aggregate, IEnumerable`1<T> operands);
}
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute("1")]
internal class Microsoft.SqlServer.Types.ArrayPinner : object {
    private bool _disposed;
    private GCHandle _gchArray;
    public Array PinnedArray { get; }
    public ArrayPinner(Array a);
    public IntPtr AddressOfPinnedArray();
    public Array get_PinnedArray();
    public sealed virtual void Dispose();
}
internal class Microsoft.SqlServer.Types.CollectionAggregate : ValueType {
    private static int NO_SRID;
    private static int ERROR;
    private int _srid;
    private GeoDataBuilder _builder;
    private bool _stripZM;
    private bool _stripTopLevelCollection;
    private bool _stripEmpty;
    public int Srid { get; }
    public bool IsNull { get; }
    public void Init(Flags flags);
    public void Accumulate(GeoData g, int srid);
    public void AccumulateForGeometryConvexHull(GeoData g, int srid);
    public void AccumulateForGeographyConvexHull(GeoData g, int srid);
    public void Reset(int srid);
    public void Merge(CollectionAggregate group);
    public int get_Srid();
    public bool get_IsNull();
    public GeoData Terminate();
    public void Read(BinaryReader r);
    public void Write(BinaryWriter w);
}
internal enum Microsoft.SqlServer.Types.CompareBMP : Enum {
    public int value__;
    public static CompareBMP x_cmpEq;
    public static CompareBMP x_cmpGt;
    public static CompareBMP x_cmpLt;
}
internal static class Microsoft.SqlServer.Types.Constants : object {
    internal static int SEVERITY_ERROR;
    internal static int FACILITY_ITF;
}
internal class Microsoft.SqlServer.Types.Context : ValueType {
    private OpenGisType _type;
    private OpenGisType _container;
    private int _depth;
    private int _figures;
    private bool _figureStarted;
    private FigureAttributes _currentRing;
    public OpenGisType Type { get; }
    public OpenGisType Container { get; }
    public bool IsFirstFigure { get; }
    public bool HasFigureStarted { get; }
    public int Figures { get; }
    public FigureAttributes CurrentRing { get; }
    public void Begin(OpenGisType type);
    public void BeginFigure();
    public void AddLine();
    public void EndFigure();
    public void AddArc();
    public void StartSegment();
    public void StartRing(FigureAttributes type);
    public void End();
    public OpenGisType get_Type();
    public OpenGisType get_Container();
    public bool get_IsFirstFigure();
    public bool get_HasFigureStarted();
    public int get_Figures();
    public FigureAttributes get_CurrentRing();
}
internal class Microsoft.SqlServer.Types.CoordinateReversingGeoDataSink : object {
    private GeoDataSink _sink;
    public CoordinateReversingGeoDataSink(GeoDataSink sink);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
}
internal class Microsoft.SqlServer.Types.CStages : ValueType {
    public static ushort N_STAGES;
    public static ushort NAMESPACE_PREFIX_STAGE;
    public static ushort ATTRIBUTE_STAGE;
    public static ushort FIRST_NEGATIVE_STAGE;
    public static ushort FIRST_POSITIVE_STAGE;
    public static ushort LAST_POSITIVE_STAGE;
    public static Stage[] stages;
    public static Byte[] decode;
    private static CStages();
    public static ushort GetStage(long ord);
}
internal enum Microsoft.SqlServer.Types.ECellAttribute : Enum {
    public byte value__;
    public static ECellAttribute InteriorCell;
    public static ECellAttribute PartiallyCoveredCell;
    public static ECellAttribute TouchedCell;
}
internal class Microsoft.SqlServer.Types.EllipsoidParameters : ValueType {
    public double semi_major;
    public double semi_minor;
    public EllipsoidParameters(double major, double minor);
    public double GetMinCurvature();
    public double GetMaxCurvature();
    public double GetEccentricity();
}
internal class Microsoft.SqlServer.Types.Enumerable : object {
    private IEnumerator m_enumerator;
    public Enumerable(IEnumerator enumerator);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.SqlServer.Types.ErrorMessageProvider : object {
    public static void CopyMemory(IntPtr dest, IntPtr src, int count);
    private static string GetResourceFormatString(string resourceName);
    private static void CopyOutputMessage(string message, IntPtr pMessage, IntPtr pcbMessage);
    internal static void FormatErrorMessage(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage);
    internal static void FormatErrorMessageDoubleArg(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage, IntPtr pArg1);
    internal static void FormatErrorMessageDoubleStringArg(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage, IntPtr pArg1, IntPtr pcwsArg2, IntPtr cwsArg2);
    internal static void FormatErrorMessageIntArg(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage, IntPtr pArg1);
    internal static void FormatErrorMessageStringIntIntArg(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage, IntPtr pcwsArg1, IntPtr cwsArg1, IntPtr pArg2, IntPtr pArg3);
    internal static void FormatErrorMessageIntWCharArg(IntPtr pcwsResourceName, IntPtr cwsResourceName, IntPtr pMessage, IntPtr pcbMessage, IntPtr pArg1, IntPtr pArg2);
    internal static void FormatExceptionMessage(IntPtr pcwsExceptionType, IntPtr cwsExceptionType, IntPtr pMessage, IntPtr pcbMessage);
}
internal class Microsoft.SqlServer.Types.Figure : ValueType {
    public int pointOffset;
    public FigureAttributes figureAttribute;
    public Figure(int pointOffset, FigureAttributes figureAttribute);
}
internal enum Microsoft.SqlServer.Types.FigureAttributes : Enum {
    public byte value__;
    public static FigureAttributes None;
    public static FigureAttributes Line;
    public static FigureAttributes Arc;
    public static FigureAttributes Curve;
}
internal enum Microsoft.SqlServer.Types.FigureAttributesKatmai : Enum {
    public byte value__;
    public static FigureAttributesKatmai InteriorRing;
    public static FigureAttributesKatmai Stroke;
    public static FigureAttributesKatmai ExteriorRing;
}
[FlagsAttribute]
internal enum Microsoft.SqlServer.Types.Flags : Enum {
    public int value__;
    public static Flags None;
    public static Flags StripZM;
    public static Flags StripTopLevelCollection;
    public static Flags StripEmpty;
}
internal class Microsoft.SqlServer.Types.ForwardingGeoDataSink : object {
    private GeoDataSink _sink1;
    private GeoDataSink _sink2;
    public ForwardingGeoDataSink(GeoDataSink sink1, GeoDataSink sink2);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
}
internal class Microsoft.SqlServer.Types.GeoData : ValueType {
    private Point[] m_points;
    private Double[] m_zValues;
    private Double[] m_mValues;
    private Figure[] m_figures;
    private Shape[] m_shapes;
    private Segment[] m_segments;
    private bool m_fValid;
    private bool m_isLargerThanAHemisphere;
    private bool m_isKatmaiCompatible;
    public static int MaxGeometryCollectionDepth;
    public int NumGeometries { get; }
    public int NumInteriorRing { get; }
    public int NumRings { get; }
    public GeoData ExteriorRing { get; }
    public PointZM StartPoint { get; }
    public PointZM EndPoint { get; }
    public double X { get; }
    public double Y { get; }
    public double Z { get; }
    public double M { get; }
    public GeoData(PointZM p);
    public GeoData(OpenGisType type);
    public GeoData(int cPoints, int cFigures, int cShapes);
    public GeoData(Point[] points, Figure[] figures, Shape[] shapes);
    public GeoData(Point[] points, Figure[] figures, Shape[] shapes, Double[] zValues, Double[] mValues);
    public GeoData(Point[] points, Figure[] figures, Shape[] shapes, Double[] zValues, Double[] mValues, Segment[] mSegments);
    public GeoData(int cPoints, int cFigures, int cShapes, int cSegments);
    public GeoData(int cPoints, int cFigures, int cShapes, int cZValues, int cMValues);
    public GeoData(int cPoints, int cFigures, int cShapes, int cZValues, int cMValues, int cSegments);
    public GeoData(Point p);
    private static GeoData();
    private void CreateArrays(int cPoints, int cFigures, int cShapes, int cZValues, int cMValues, int cSegments);
    public int IndexOfShapeOfNextGeometry(int iShapeOfStartGeometry);
    public int IndexOfLastShapeOfGeometry(int iShape);
    public Shape GetShape(int iShape);
    public void SetShape(int iShape, Shape s);
    public int IndexOfNthChildShape(int iShape);
    public int IndexOfLastChildShape(int iShape);
    public Figure GetFigure(int iFigure);
    public Figure GetFigure(int iShape, int iFigure);
    public void SetFigure(int iFigure, Figure f);
    public int IndexOfFirstFigure(int iShape);
    public int IndexOfLastFigure(int iShape);
    public int GetFigureCount();
    public int GetFigureCount(int iShape);
    public SegmentType GetSegmentType(int iSegment);
    public int IndexOfFirstSegment(int iFigure);
    public int IndexOfLastSegment(int iFigure);
    public int IndexOfFirstPoint(int iFigure);
    public int IndexOfFirstPoint(int iShape, int iFigure);
    public int IndexOfLastPoint(int iFigure);
    public int IndexOfLastPoint(int iShape, int iFigure);
    public int GetPointCount();
    public int GetPointCount(int iShape, int iFigure);
    public int GetPointCount(int iFigure);
    public Point GetPoint(int iShape, int iFigure, int iPoint);
    public Point GetPoint(int iFigure, int iPoint);
    public Point GetPoint(int iPoint);
    public bool IsRealPoint();
    public bool HasZ(int first, int last);
    public bool HasZ();
    public bool HasM(int first, int last);
    public bool HasM();
    public OpenGisType GetGType(int iShape);
    public OpenGisType GetGType();
    public bool GetIsValid();
    public void SetIsValid(bool fValid);
    public bool GetIsFullGlobe();
    public bool GetIsKatmaiCompatible();
    public void SetIsKatmaiCompatible(bool value);
    public bool GetIsLargerThanAHemisphere();
    public void SetIsLargerThanAHemisphere(bool value);
    public bool ContainsCurvedShapes();
    public void Read(BinaryReader r, SerializationVersion maxVersion, string strUnexpectedVersion, bool isGeography);
    public void Read(BinaryReader r, bool isGeography);
    public sealed virtual void Read(BinaryReader r);
    public int GetNextCurveFigure(int indexOflastCurveFigure);
    public void ReadCommon(BinaryReader r, bool geometryChecks, bool geographyChecks);
    public void ReadSegments(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
    public int get_NumGeometries();
    public GeoData GetGeometryN(int nGeometry);
    public int get_NumInteriorRing();
    public int get_NumRings();
    public GeoData GetInteriorRingN(int nRing);
    public GeoData GetRingN(int nRing);
    public GeoData get_ExteriorRing();
    public PointZM GetPointN(int nPoint);
    public PointZM get_StartPoint();
    public PointZM get_EndPoint();
    public double get_X();
    public double get_Y();
    public double get_Z();
    public double get_M();
    public GeoData GetCurveN(int n);
    private void CopyPointArrays(GeoData g, int sourceStartOffset, int destinationStartOffset, int count);
    private GeoData AsRing(int iFigure);
    private GeoData AsLineString(int nFigure);
    private GeoData AsCircularString(int nFigure);
    private GeoData AsCompoundCurve(int nFigure);
    private GeoData GetLineStringN(int startPoint);
    private GeoData GetCircularStringN(int startPoint);
    private GeoData AsGeometry(int nShape);
    public bool IsClosed();
    public bool IsClosed(int iFigure);
    public bool IsClosed(int iShape, int iFigure);
    public bool GeodeticIsClosed();
    public bool GeodeticIsClosed(int iFigure);
    public Point[] GetPoints();
    public Figure[] GetFigures();
    public Shape[] GetShapes();
    public Double[] GetZValues();
    public Double[] GetMValues();
    public Segment[] GetSegments();
    public int GetShapeCount();
    public int GetZValuesCount();
    public int GetMValuesCount();
    public int GetSegmentCount();
    public bool IsEmptyAndNoChildShapes();
    public bool IsEmpty(int iShape);
    public bool IsEmpty();
    public bool ContainsChildShapes(int iShape);
    public bool ContainsChildShapes();
    public bool IsFillable();
    public static void SeparateBounds(Double& pMinX, Double& pMinY, Double& pMaxX, Double& pMaxY);
    public int GetDimension();
    public int GetDimension(int iShape);
    public bool GetAsPoint(Double& x, Double& y);
    public static GeoData ConstructRectangle(double MinX, double MinY, double MaxX, double MaxY);
    public void AssertValid();
    public void Populate(GeoDataSink sink);
    public void PopulateRaw(GeoDataSink sink);
    private void PopulateLineFigure(int figure, GeoDataSink sink);
    private void PopulateLineFigures(int shape, GeoDataSink sink);
    private void PopulateArcFigure(int figure, GeoDataSink sink);
    private int PopulateCurveFigure(int figure, GeoDataSink sink, int firstSegment);
    private int PopulateCurvePolygon(int shape, GeoDataSink sink, int firstSegment);
    private int PopulateShape(int shape, GeoDataSink sink, int firstSegment);
    private Nullable`1<double> GetZ(int point);
    private Nullable`1<double> GetM(int point);
    private void SinkBeginFigure(int point, GeoDataSink sink);
    private void SinkAddLine(int point, GeoDataSink sink);
    private void SinkAddCircularString(int point, GeoDataSink sink);
}
internal class Microsoft.SqlServer.Types.GeoDataBuilder : object {
    private static GeoData ms_emptyGeoData;
    private static GeoData ms_fullGlobeGeoData;
    private List`1<Point> m_points;
    private bool m_ignoreZM;
    private List`1<double> m_zValues;
    private List`1<double> m_mValues;
    private List`1<Segment> m_segments;
    private List`1<Figure> m_figures;
    private List`1<Shape> m_shapes;
    private Stack`1<int> m_stackParents;
    private BuilderState m_state;
    private SegmentType m_nextSegment;
    private FigureAttributes m_nextFigureAttribute;
    public static GeoData EmptyGeoData { get; }
    public static GeoData FullGlobeGeoData { get; }
    public GeoData ConstructedGeoData { get; }
    private static GeoDataBuilder();
    public GeoDataBuilder(bool ignoreZM);
    public static GeoData get_EmptyGeoData();
    public static GeoData get_FullGlobeGeoData();
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public void BeginFigure();
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public void AddLine(Point point);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    private void AssignFigureToShape(int iFigureIndex, int iShapeIndex);
    private void AddPoint(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    private void AddPointProperty(List`1& list, Nullable`1<double> d);
    public GeoData get_ConstructedGeoData();
    private void EnsureState(BuilderState state);
    private void TransitionState(BuilderState from, BuilderState to);
    private void TransitionState(BuilderState from1, BuilderState from2, BuilderState to);
}
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute("1")]
internal class Microsoft.SqlServer.Types.GeoDataPinner : object {
    private ArrayPinner _pointsPinner;
    private ArrayPinner _zvaluesPinner;
    private ArrayPinner _mvaluesPinner;
    private ArrayPinner _figuresPinner;
    private ArrayPinner _shapesPinner;
    private ArrayPinner _segmentsPinner;
    private byte _isValid;
    private byte _isLargerThanAHemisphere;
    private bool _disposed;
    public GeoMarshalData Pin(GeoData geo);
    public void SetIsLargerThanAHemisphere(byte isLargerThanAHemisphere);
    public GeoData GetGeoData();
    public void Release();
    public sealed virtual void Dispose();
}
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute("1")]
internal class Microsoft.SqlServer.Types.GeoDataPinningAllocator : object {
    private AllocAndPinGeometryDelegate _allocDelegate;
    private SetIsLargerThanAHemisphereDelegate _largeThanAHemisphereDelegate;
    private GCHandle _gchGeoDataPinner;
    private bool _disposed;
    public GeoData Geometry { get; }
    public sealed virtual void Dispose();
    public static void AllocAndPinGeometry(int cPoints, int cFigures, int cShapes, int cSegments, GeoDataPinningAllocator self, GeoMarshalData& allocatedGeometry);
    private GeoMarshalData AllocAndPinGeometry(int cPoints, int cFigures, int cShapes, int cSegments);
    public static void SetIsLargerThanAHemisphere(byte isLargerThanAHemisphere, GeoDataPinningAllocator self);
    private void SetIsLargerThanAHemisphere(byte isLargerThanAHemisphere);
    public GeoData get_Geometry();
}
internal interface Microsoft.SqlServer.Types.GeoDataSink {
    public abstract virtual void SetSrid(int srid);
    public abstract virtual void BeginGeo(OpenGisType type);
    public abstract virtual void BeginFigure(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void AddLine(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void AddCircularArc(double latitude1, double longitude1, Nullable`1<double> z1, Nullable`1<double> m1, double latitude2, double longitude2, Nullable`1<double> z2, Nullable`1<double> m2);
    public abstract virtual void AddSegment(SegmentType type);
    public abstract virtual void StartRing(FigureAttributes type);
    public abstract virtual void EndFigure();
    public abstract virtual void EndGeo();
    public abstract virtual void Finish();
}
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeographyCollectionAggregate : object {
    private CollectionAggregate _collection;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeography g);
    public void Merge(GeographyCollectionAggregate group);
    public sealed virtual SqlGeography Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeographyConvexHullAggregate : object {
    private CollectionAggregate _collection;
    private bool _fullglobe;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeography g);
    public void Merge(GeographyConvexHullAggregate group);
    public sealed virtual SqlGeography Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeographyEnvelopeAggregate : object {
    private static double MinimalBufferExtent;
    private Sphere _sphere;
    private int _srid;
    private bool _failed;
    private static double s_toDegrees;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeography g);
    public void Merge(GeographyEnvelopeAggregate group);
    public sealed virtual SqlGeography Terminate();
}
internal class Microsoft.SqlServer.Types.GeographyMarkupLanguageReader : object {
    private static string _gmlNamespace;
    private static string _fullGlobeNamespace;
    private GeoDataSink _sink;
    private XmlReader _reader;
    private int points;
    private int arcPoints;
    private double firstX;
    private double firstY;
    private bool startSegment;
    private double lastX;
    private double lastY;
    public GeographyMarkupLanguageReader(XmlReader reader, GeoDataSink sink);
    public void Read(int srid);
    private bool ReadStartOrEmptyElement(string element);
    private bool IsStartElement(string element);
    private bool IsFullGlobeElement();
    private bool IsEndElement(string element);
    private void ReadEndElement();
    private void ParseGmlGeometry();
    private void ParseGmlPointShape();
    private void ParseGmlPointPropertyElement(bool allowEmpty);
    private void ParseGmlArcPointPropertyElement();
    private void ParseGmlPointElement(bool allowEmpty);
    private void ParseGmlPosElement(bool allowEmpty);
    private void ParseArcGmlPosElement();
    private void ParseGmlLineStringShape();
    private void ParseGmlLineString();
    private void ParseGmlArcStringShape();
    private void ParseGmlArcString();
    private void ParseGmlArcShape();
    private void ParseGmlCompositeCurveShape();
    private void ParseGmlCompositeCurveFigure();
    private bool IsPosListStart();
    private void ParsePosList(bool allowEmpty);
    private void ParseArcPosList(bool allowEmpty);
    private void ParseGmlPosListElement(bool allowEmpty);
    private void ParseGmlPolygonShape();
    private void ParseGmlExteriorLinearRingElement();
    private void ParseGmlInteriorLinearRingElement(int ringNumber);
    private void ParseGmlLinearRingElement();
    private void ParseGmlPolygonPatchShape();
    private void ParseGmlExteriorRingElement();
    private void ParseGmlInteriorRingElement(int ringNumber);
    private void ParseGmlRingElement();
    private void ParseMultiItemElement(string header, string member, string members, ItemParserDelegate parseItem);
    private void ParseGmlMultiPointShape();
    private void ParseGmlMultiCurveShape();
    private void ParseGmlMultiSurfaceShape();
    private void ParseGmlMultiGeometryShape();
    private void ParseGmlFullGlobeElement();
    private void BeginFigure();
    private void StartArc();
    private void StartSegment(SegmentType type);
    private void AddPoint(double x, double y);
    private void EndArc();
    private void EndFigure();
}
internal class Microsoft.SqlServer.Types.GeographyMarkupLanguageWriter : object {
    private XmlWriter _writer;
    private static string _gmlNamespace;
    private static string _fullGlobeNamespace;
    private Context _context;
    private double _lastX;
    private double _lastY;
    public GeographyMarkupLanguageWriter(XmlWriter writer);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    private void WritePoint(double x, double y);
    private void StartElement(string name);
    private void EndElement();
}
internal class Microsoft.SqlServer.Types.GeographyOutputSink : ValueType {
    private IGeographySink _sink;
    private IGeographySink110 _sink110;
    public GeographyOutputSink(IGeographySink sink);
    public GeographyOutputSink(IGeographySink110 sink);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double latitude1, double longitude1, Nullable`1<double> z1, Nullable`1<double> m1, double latitude2, double longitude2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
}
public class Microsoft.SqlServer.Types.GeographyTessellationFunction : object {
    [SqlFunctionAttribute]
public static IEnumerable InitMethod(SqlGeography geographyObject, int densityGrid0, int densityGrid1, int densityGrid2, int densityGrid3, int cardinality, int tessellationMode, SqlDouble distanceBuffer);
    public static void FillRow(object obj, SqlBytes& cellId, Int16& cellAttributes, Int32& spatialReferenceId);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeographyUnionAggregate : object {
    private CollectionAggregate _collection;
    private bool _fullglobe;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeography g);
    public void Merge(GeographyUnionAggregate group);
    public sealed virtual SqlGeography Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
internal class Microsoft.SqlServer.Types.GeographyValidator : Validator {
    internal static double MaxLongitude;
    internal static double MaxLatitude;
    protected virtual void ValidateSrid(int srid);
    protected virtual void ValidatePoint(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    internal static bool IsLatitudeValid(double latitude);
    internal static bool IsLongitudeValid(double longitude);
    private static bool AreLongitudesEqual(double a, double b);
    protected virtual bool AcceptsFullGlobe();
    protected virtual void ValidatePolygonRing(int iRing, int cPoints, double firstX, double firstY, double lastX, double lastY);
}
internal class Microsoft.SqlServer.Types.GeoMarshalData : ValueType {
    public IntPtr points;
    public int cPoints;
    public IntPtr zValues;
    public IntPtr mValues;
    public IntPtr figures;
    public int cFigures;
    public IntPtr shapes;
    public int cShapes;
    public IntPtr segments;
    public int cSegments;
    public byte isValid;
    public byte isLargerThanAHemisphere;
}
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeometryCollectionAggregate : object {
    private CollectionAggregate _collection;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeometry g);
    public void Merge(GeometryCollectionAggregate group);
    public sealed virtual SqlGeometry Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeometryConvexHullAggregate : object {
    private CollectionAggregate _collection;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeometry g);
    public void Merge(GeometryConvexHullAggregate group);
    public sealed virtual SqlGeometry Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeometryEnvelopeAggregate : object {
    private static int NO_SRID;
    private double _minX;
    private double _maxX;
    private double _minY;
    private double _maxY;
    private int _srid;
    private bool _failed;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeometry g);
    private void Update(double minX, double minY, double maxX, double maxY);
    public void Merge(GeometryEnvelopeAggregate group);
    public sealed virtual SqlGeometry Terminate();
}
internal class Microsoft.SqlServer.Types.GeometryOutputSink : ValueType {
    private IGeometrySink _sink;
    private IGeometrySink110 _sink110;
    public GeometryOutputSink(IGeometrySink sink);
    public GeometryOutputSink(IGeometrySink110 sink);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
}
public class Microsoft.SqlServer.Types.GeometryTessellationFunction : object {
    [SqlFunctionAttribute]
public static IEnumerable InitMethod(SqlGeometry geometryObject, double rootX, double rootY, double maxX, double maxY, int densityGrid0, int densityGrid1, int densityGrid2, int densityGrid3, int cardinality, int tessellationMode, SqlDouble distanceBuffer);
    public static void FillRow(object obj, SqlBytes& cellId, Int16& cellAttributes, Int32& spatialReferenceId);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedAggregateAttribute]
public class Microsoft.SqlServer.Types.GeometryUnionAggregate : object {
    private CollectionAggregate _collection;
    public sealed virtual void Init();
    public sealed virtual void Accumulate(SqlGeometry g);
    public void Merge(GeometryUnionAggregate group);
    public sealed virtual SqlGeometry Terminate();
    public sealed virtual void Read(BinaryReader r);
    public sealed virtual void Write(BinaryWriter w);
}
internal class Microsoft.SqlServer.Types.GeometryValidator : Validator {
    protected virtual void ValidateSrid(int srid);
    internal static bool IsSridValid(int srid);
    protected virtual void ValidatePolygonRing(int iRing, int cPoints, double firstX, double firstY, double lastX, double lastY);
}
internal enum Microsoft.SqlServer.Types.GL_HResult : Enum {
    public int value__;
    public static GL_HResult GL_E_GEODETIC_RESULT_EXCEEDS_HEMISPHERE;
    public static GL_HResult GL_E_GEODETIC_ANTIPODAL_ARGUMENTS;
    public static GL_HResult GL_E_GEODETIC_BUFFER_WRAPS_AROUND;
}
internal class Microsoft.SqlServer.Types.GLArgumentException : ArgumentException {
    private GL_HResult _errorCode;
    public GL_HResult Result { get; }
    public GLArgumentException(GL_HResult errorCode, string message);
    public GL_HResult get_Result();
}
[SecurityTreatAsSafeAttribute]
[SecurityCriticalAttribute("1")]
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.SqlServer.Types.GLNativeMethods : object {
    private static string GlLibraryName;
    private static int IntersectionPatternMatrixLength;
    private static int DefaultClrFeatureSwitches;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<GLLibraryState, string> State;
    private static GLNativeMethods();
    private static IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, UInt32 dwFlags);
    private static string CombineErrorCodes(int lastWin32Error, int previousHResult);
    private static void ThowIfGLNativeLibraryNotLoaded();
    private static void SetClrFeatureSwitchMap(int clrFeatureSwitchMap);
    private static GL_HResult Combine(CombineMode combineMode, GeoMarshalData g1, GeoMarshalData g2, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult ConvexHull(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult Equals(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Intersects(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Touches(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Crosses(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Contains(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Overlaps(GeoMarshalData g1, GeoMarshalData g2, Boolean& result);
    private static GL_HResult Relate(GeoMarshalData g1, GeoMarshalData g2, Int32[] intersectionPatternMatrix);
    private static GL_HResult Length(GeoMarshalData g, Double& result);
    private static GL_HResult Area(GeoMarshalData g, Double& result);
    private static GL_HResult Centroid(GeoMarshalData g, Point& result);
    private static GL_HResult PointOnSurface(GeoMarshalData g, Point& result);
    private static GL_HResult IsSimple(GeoMarshalData g, Boolean& result);
    private static GL_HResult Buffer(GeoMarshalData g, double distance, double tolerance, bool returnCurves, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult SimpleBuffer(GeoMarshalData g, double distance, double tolerance, bool fPerfromMakeValid, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult Distance(GeoMarshalData g1, GeoMarshalData g2, Double& result);
    private static GL_HResult IsValid(GeoMarshalData g, Boolean& result);
    private static GL_HResult IsValidDetailed(GeoMarshalData g, ValidityState& state, UInt32& detail1, UInt32& detail2, UInt32& entry);
    private static GL_HResult MakeValid(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult Boundary(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult PlanarReduce(GeoMarshalData g, double tolerance, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult CurveToLineWithTolerance(GeoMarshalData g, double tolerance, bool relative, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult Envelope(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GetBounds(GeoMarshalData g, Double& minX, Double& minY, Double& maxX, Double& maxY);
    private static GL_HResult GeodeticIsValid(GeoMarshalData g, double eccentricity, bool forceKatmai, Boolean& result, Boolean& isSmallerThanAHemisphere);
    private static GL_HResult GeodeticIsValidDetailed(GeoMarshalData g, double eccentricity, ValidityState& state, UInt32& detail1, UInt32& detail2, UInt32& entry);
    private static GL_HResult GeodeticMakeValid(GeoMarshalData g, double eccentricity, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GeodeticArea(GeoMarshalData g, EllipsoidParameters ellipsoidParameters, Double& result);
    private static GL_HResult GeodeticLength(GeoMarshalData g, EllipsoidParameters ellipsoidParameters, Double& result);
    private static GL_HResult GeodeticDistance(GeoMarshalData g1, GeoMarshalData g2, EllipsoidParameters ellipsoidParameters, double tolerance, bool relative, Double& result);
    private static GL_HResult GeodeticCombine(CombineMode combineMode, GeoMarshalData g1, GeoMarshalData g2, double eccentricity, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GeodeticEquals(GeoMarshalData g1, GeoMarshalData g2, double eccentricity, Boolean& result);
    private static GL_HResult GeodeticIntersects(GeoMarshalData g1, GeoMarshalData g2, double eccentricity, Boolean& result);
    private static GL_HResult GeodeticContains(GeoMarshalData g1, GeoMarshalData g2, double eccentricity, Boolean& result);
    private static GL_HResult GeodeticOverlaps(GeoMarshalData g1, GeoMarshalData g2, double eccentricity, Boolean& result);
    private static GL_HResult GeodeticBuffer(GeoMarshalData g, EllipsoidParameters ellipsoidParameters, double distance, double tolerance, bool returnCurves, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GeodeticReduce(GeoMarshalData g, EllipsoidParameters ellipsoidParameters, double tolerance, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GeodeticAngleExtent(GeoMarshalData g, double eccentricity, Double& result);
    private static GL_HResult GeodeticCapCenter(GeoMarshalData g, double eccentricity, Point& result);
    private static GL_HResult GeodeticConvexHull(GeoMarshalData g, double eccentricity, GeoDataPinningAllocator resultAllocator);
    private static GL_HResult GeodeticCurveToLineWithTolerance(GeoMarshalData g, EllipsoidParameters ellipsoidParameters, double tolerance, bool relative, GeoDataPinningAllocator resultAllocator);
    private static void ThrowExceptionForHr(GL_HResult errorCode);
    public static void SetClrFeatureSwitches(int clrFeatureSwitchMap);
    private static GeoData Combine(CombineMode combineMode, GeoData g1, GeoData g2);
    public static GeoData Buffer(GeoData g, double distance, double tolerance, bool returnCurves);
    public static GeoData SimpleBuffer(GeoData g, double distance, double tolerance);
    public static GeoData ConvexHull(GeoData g);
    public static GeoData Intersection(GeoData g1, GeoData g2);
    public static GeoData Union(GeoData g1, GeoData g2);
    public static GeoData Difference(GeoData g1, GeoData g2);
    public static GeoData SymDifference(GeoData g1, GeoData g2);
    public static bool Equals(GeoData g1, GeoData g2);
    public static bool Intersects(GeoData g1, GeoData g2);
    public static bool Touches(GeoData g1, GeoData g2);
    public static bool Crosses(GeoData g1, GeoData g2);
    public static bool Contains(GeoData g1, GeoData g2);
    public static bool Overlaps(GeoData g1, GeoData g2);
    public static bool Relate(GeoData g1, GeoData g2, string intersectionPatternMatrix);
    public static Int32[] GetIntersectionPatternMatrix(GeoData g1, GeoData g2);
    public static double Length(GeoData g);
    public static double Area(GeoData g);
    public static GeoData Centroid(GeoData g);
    public static GeoData PointOnSurface(GeoData g);
    public static bool IsSimple(GeoData g);
    public static double Distance(GeoData g1, GeoData g2);
    private static GL_HResult GetGridCoverage(GeoMarshalData g, double rGridMinX, double rGridMinY, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, int cGridRows, int cGridColumns, IntPtr ptrBoolAmbiguouslyTouched, IntPtr ptrBoolTouched, IntPtr ptrBoolContained, Boolean& fGeometryExceedsGrid);
    public static void GetGridCoverage(GeoData g, double rGridMinX, double rGridMinY, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, Boolean[0...,0...] ambiguouslyTouched, Boolean[0...,0...] touched, Boolean[0...,0...] contained, Boolean& fGeometryExceedsGrid);
    private static GL_HResult GeodeticGridCoverage(GeoMarshalData g, double eccentricity, double rGridMinXNorth, double rGridMinYNorth, double rGridMinXSouth, double rGridMinYSouth, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, int cGridRows, int cGridColumns, bool fStitchNorthernMinRow, bool fStitchNorthernMaxRow, bool fStitchNorthernMinCol, bool fStitchNorthernMaxCol, IntPtr ptrBoolAmbiguouslyTouchedNorth, IntPtr ptrBoolTouchedNorth, IntPtr ptrBoolContainedNorth, IntPtr ptrBoolAmbiguouslyTouchedSouth, IntPtr ptrBoolTouchedSouth, IntPtr ptrBoolContainedSouth);
    public static void GeodeticGridCoverage(GeoData g, double eccentricity, double rGridMinXNorth, double rGridMinYNorth, double rGridMinXSouth, double rGridMinYSouth, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, bool fStitchNorthernMinRow, bool fStitchNorthernMaxRow, bool fStitchNorthernMinCol, bool fStitchNorthernMaxCol, Boolean* pointer_ambiguouslyTouchedNorth, Boolean* pointer_touchedNorth, Boolean* pointer_containedNorth, Boolean* pointer_ambiguouslyTouchedSouth, Boolean* pointer_touchedSouth, Boolean* pointer_containedSouth, int gridRows, int gridColumns);
    public static bool IsValid(GeoData g);
    public static void IsValidDetailed(GeoData g, ValidityState& state, UInt32& detail1, UInt32& detail2, UInt32& entry);
    public static GeoData MakeValid(GeoData g);
    public static GeoData Boundary(GeoData g);
    public static GeoData Reduce(GeoData g, double tolerance);
    public static GeoData CurveToLineWithTolerance(GeoData g, double tolerance, bool relative);
    public static GeoData Envelope(GeoData g);
    public static void GetBounds(GeoData g, Double& minX, Double& minY, Double& maxX, Double& maxY);
    public static bool GeodeticIsValid(GeoData& g, double eccentricity, bool forceKatmai);
    public static void GeodeticIsValidDetailed(GeoData g, double eccentricity, ValidityState& state, UInt32& detail1, UInt32& detail2, UInt32& entry);
    public static GeoData GeodeticMakeValid(GeoData g, double eccentricity);
    public static double GeodeticArea(GeoData g, EllipsoidParameters ellipsoidParameters);
    public static double GeodeticLength(GeoData g, EllipsoidParameters ellipsoidParameters);
    public static double GeodeticDistance(GeoData g1, GeoData g2, EllipsoidParameters ellipsoidParameters, double tolerance, bool relative);
    private static GeoData GeodeticCombine(CombineMode combineMode, GeoData g1, GeoData g2, double eccentricity);
    public static GeoData GeodeticIntersection(GeoData g1, GeoData g2, double eccentricity);
    public static GeoData GeodeticUnion(GeoData g1, GeoData g2, double eccentricity);
    public static GeoData GeodeticDifference(GeoData g1, GeoData g2, double eccentricity);
    public static GeoData GeodeticSymDifference(GeoData g1, GeoData g2, double eccentricity);
    public static bool GeodeticEquals(GeoData g1, GeoData g2, double eccentricity);
    public static bool GeodeticIntersects(GeoData g1, GeoData g2, double eccentricity);
    public static bool GeodeticContains(GeoData g1, GeoData g2, double eccentricity);
    public static bool GeodeticOverlaps(GeoData g1, GeoData g2, double eccentricity);
    public static GeoData GeodeticReduce(GeoData g, EllipsoidParameters ellipsoidParameters, double tolerance);
    public static GeoData GeodeticBuffer(GeoData g, EllipsoidParameters ellipsoidParameters, double distance, double tolerance, bool returnCurves);
    public static double GeodeticAngleExtent(GeoData g, double eccentricity);
    public static Point GeodeticCapCenter(GeoData g, double eccentricity);
    public static GeoData GeodeticConvexHull(GeoData g, double eccentricity);
    public static GeoData GeodeticCurveToLineWithTolerance(GeoData g, EllipsoidParameters ellipsoidParameters, double tolerance, bool relative);
    private static GL_HResult ShortestLine(GeoMarshalData g1, GeoMarshalData g2, GeoDataPinningAllocator resultAllocator);
    public static GeoData ShortestLineTo(GeoData g1, GeoData g2);
    private static GL_HResult GeodeticShortestLine(GeoMarshalData g1, GeoMarshalData g2, EllipsoidParameters ellipsoidParameters, GeoDataPinningAllocator resultAllocator);
    public static GeoData GeodeticShortestLineTo(GeoData g1, GeoData g2, EllipsoidParameters ellipsoidParameters);
    private static GL_HResult UpdateGeodeticEnvelope(GeoMarshalData g, double eccentricity, Sphere& sphere);
    public static void UpdateGeodeticEnvelope(GeoData g, double eccentricity, Sphere& sphere);
    private static GL_HResult GeodeticCapUnionPriv(Sphere& sphere, Sphere sphere2);
    public static void GeodeticCapUnion(Sphere& sphere, Sphere sphere2);
    private static GL_HResult GeodeticTile(GeoMarshalData g, double eccentricity, double scale, bool north, bool south, GeoDataPinningAllocator resultAllocator);
    public static GeoData GeodeticTile(GeoData g, double eccentricity, double scale, bool north, bool south);
    private static GL_HResult Tessellate(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    public static GeoData Tessellate(GeoData g);
    private static GL_HResult GeodeticTessellate(GeoMarshalData g, double eccentricity, GeoDataPinningAllocator resultAllocator);
    public static GeoData GeodeticTessellate(GeoData g, double eccentricity);
    private static GL_HResult Identity(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    public static GeoData Identity(GeoData g);
    private static GL_HResult SingleSideReduce(GeoMarshalData g, double relativeAreaDelta, bool fPerfromMakeValid, GeoDataPinningAllocator resultAllocator);
    public static GeoData SingleSideReduce(GeoData g, double relativeAreaDelta);
    public static double GeodeticPointDistance(Point p1, Point p2, EllipsoidParameters ep);
    private static GL_HResult Outline(GeoMarshalData g, GeoDataPinningAllocator resultAllocator);
    public static GeoData Outline(GeoData g);
    private static GeoMarshalData MakeUnsafeGeoMarshalData(GeoData g, Point* p_points, Double* p_zValues, Double* p_mValues, Figure* p_figures, Shape* p_shapes, Segment* p_segments);
}
internal class Microsoft.SqlServer.Types.GridCell : object {
    public int id;
    public byte attribute;
    public Byte[] wkb;
    public GridCell(int id, byte attribute, Byte[] wkb);
}
[CLSCompliantAttribute("True")]
public class Microsoft.SqlServer.Types.HierarchyIdException : Exception {
    protected HierarchyIdException(SerializationInfo info, StreamingContext context);
    public HierarchyIdException(string message, Exception innerException);
    public HierarchyIdException(string message);
}
internal interface Microsoft.SqlServer.Types.IAggregate`1 {
    public abstract virtual void Init();
    public abstract virtual void Accumulate(T operand);
    public abstract virtual T Terminate();
}
[CLSCompliantAttribute("True")]
[ObsoleteAttribute("IGeographySink is obsolete, use IGeographySink110 instead.")]
public interface Microsoft.SqlServer.Types.IGeographySink {
    public abstract virtual void SetSrid(int srid);
    public abstract virtual void BeginGeography(OpenGisGeographyType type);
    public abstract virtual void BeginFigure(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void AddLine(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void EndFigure();
    public abstract virtual void EndGeography();
}
[CLSCompliantAttribute("True")]
public interface Microsoft.SqlServer.Types.IGeographySink110 {
    public abstract virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
}
[CLSCompliantAttribute("True")]
[ObsoleteAttribute("IGeometrySink is obsolete, use IGeometrySink110 instead.")]
public interface Microsoft.SqlServer.Types.IGeometrySink {
    public abstract virtual void SetSrid(int srid);
    public abstract virtual void BeginGeometry(OpenGisGeometryType type);
    public abstract virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public abstract virtual void EndFigure();
    public abstract virtual void EndGeometry();
}
[CLSCompliantAttribute("True")]
public interface Microsoft.SqlServer.Types.IGeometrySink110 {
    public abstract virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
}
internal class Microsoft.SqlServer.Types.InverseProjection : object {
    private IGeographySink sink;
    private double lastX;
    private double lastY;
    public static long SizeX;
    public static long SizeY;
    private static double s_toDegrees;
    public InverseProjection(IGeographySink sink);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeometry(OpenGisGeometryType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeometry();
    public static Vector3 Convert(double x, double y);
    private static double Latitude(Vector3 v);
    private static double Longitude(Vector3 v);
    public static SqlGeography Unproject(SqlGeometry geom);
}
public interface Microsoft.SqlServer.Types.ISqlSpatialGridIndexable {
    [SqlMethodAttribute]
public abstract virtual void GetGridCoverage(bool isTopmostGrid, double rGridMinX, double rGridMinY, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, int cGridRows, int cGridColumns, Boolean[0...,0...] touched, Boolean[0...,0...] contained, Int32& cCellsTouched, Int32& cCellsContained, Boolean& fGeometryExceedsGrid, Boolean& fHasAmbiguousTouchedCells);
    public abstract virtual void GetBoundingBoxCorners(Double& minX, Double& minY, Double& maxX, Double& maxY);
    [SqlMethodAttribute]
public abstract virtual ISqlSpatialGridIndexable BufferForDistanceQuery(double distance, Boolean& disableInternalFiltering);
    [SqlMethodAttribute]
public abstract virtual ISqlSpatialGridIndexable InteriorBufferForDistanceQuery(double distance);
}
[ExtensionAttribute]
internal static class Microsoft.SqlServer.Types.ListExtensions : object {
    private static bool isGracefulOomHandlingSet;
    private static bool gracefulOomHandling;
    private static int x_fSpatialMaxClrArraySizeHandling;
    public static int Limit;
    public static bool FGracefulOomHandling { get; }
    public static bool get_FGracefulOomHandling();
    [ExtensionAttribute]
public static void AddSafe(List`1<T> list, T obj);
    [ExtensionAttribute]
public static int GetMaxCapacity(List`1<T> list);
    [ExtensionAttribute]
public static int GetObjectSize(List`1<T> list);
}
internal static class Microsoft.SqlServer.Types.ManagedDataUtil : object {
    internal static bool IsLineSegment(SegmentType t);
    internal static bool IsOpenGisTypeCollection(OpenGisType t);
    internal static bool IsOn(SerializationProperties value, SerializationProperties flag);
    internal static SerializationProperties Set(SerializationProperties value, SerializationProperties flag);
    internal static bool IsOff(SerializationProperties value, SerializationProperties flag);
}
[CLSCompliantAttribute("True")]
public enum Microsoft.SqlServer.Types.OpenGisGeographyType : Enum {
    public int value__;
    public static OpenGisGeographyType Point;
    public static OpenGisGeographyType LineString;
    public static OpenGisGeographyType Polygon;
    public static OpenGisGeographyType MultiPoint;
    public static OpenGisGeographyType MultiLineString;
    public static OpenGisGeographyType MultiPolygon;
    public static OpenGisGeographyType GeometryCollection;
    public static OpenGisGeographyType CircularString;
    public static OpenGisGeographyType CompoundCurve;
    public static OpenGisGeographyType CurvePolygon;
    public static OpenGisGeographyType FullGlobe;
}
[CLSCompliantAttribute("True")]
public enum Microsoft.SqlServer.Types.OpenGisGeometryType : Enum {
    public int value__;
    public static OpenGisGeometryType Point;
    public static OpenGisGeometryType LineString;
    public static OpenGisGeometryType Polygon;
    public static OpenGisGeometryType MultiPoint;
    public static OpenGisGeometryType MultiLineString;
    public static OpenGisGeometryType MultiPolygon;
    public static OpenGisGeometryType GeometryCollection;
    public static OpenGisGeometryType CircularString;
    public static OpenGisGeometryType CompoundCurve;
    public static OpenGisGeometryType CurvePolygon;
}
internal enum Microsoft.SqlServer.Types.OpenGisType : Enum {
    public byte value__;
    public static OpenGisType Unknown;
    public static OpenGisType Point;
    public static OpenGisType LineString;
    public static OpenGisType Polygon;
    public static OpenGisType MultiPoint;
    public static OpenGisType MultiLineString;
    public static OpenGisType MultiPolygon;
    public static OpenGisType GeometryCollection;
    public static OpenGisType CircularString;
    public static OpenGisType CompoundCurve;
    public static OpenGisType CurvePolygon;
    public static OpenGisType FullGlobe;
}
internal static class Microsoft.SqlServer.Types.OpenGisTypes : object {
    private static String[] labels;
    private static OpenGisTypes();
    public static string ToString(OpenGisType type);
    public static OpenGisType ParseLabel(string input);
    public static OpenGisGeometryType AsOpenGisGeometryType(OpenGisType type);
    public static OpenGisType AsOpenGisType(OpenGisGeometryType type);
    public static OpenGisGeographyType AsOpenGisGeographyType(OpenGisType type);
    public static OpenGisType AsOpenGisType(OpenGisGeographyType type);
    public static bool IsMultiType(OpenGisType type);
    public static OpenGisType GetMultiType(OpenGisType type);
    public static bool IsCollection(OpenGisType type);
    public static bool IsPolygon(OpenGisType type);
}
internal class Microsoft.SqlServer.Types.OrdPath : object {
    public SubType m_subType;
    public Byte[] m_bytes;
    public ushort m_bitLength;
    public UInt32 m_level;
    public UInt32 m_parsedLevels;
    public UInt32 m_parentBitLengthIndex;
    public UInt16[] m_bitOffsets;
    public OrdPath(OrdPath ordPath);
    public OrdPath(Byte[] bytes, UInt32 byteLength);
    public OrdPath(string chDottedString);
    public OrdPath(long rank);
    public void InitFromString(string chDottedString);
    public OrdPath CopyPropertiesFrom(OrdPath other);
    public void InitArrays();
    public void Init(Byte[] bytes, UInt32 byteLength);
    public static bool op_Equality(OrdPath ordP1, OrdPath ordP2);
    public static bool op_Inequality(OrdPath ordP1, OrdPath ordP2);
    public static bool op_GreaterThan(OrdPath ordP1, OrdPath ordP2);
    public static bool op_LessThan(OrdPath ordP1, OrdPath ordP2);
    public static bool op_GreaterThanOrEqual(OrdPath ordP1, OrdPath ordP2);
    public static bool op_LessThanOrEqual(OrdPath ordP1, OrdPath ordP2);
    public bool IsEqual(Byte[] bytes, UInt32 byteLength);
    public void SetToRoot();
    public bool IsRoot();
    public UInt32 GetLevel();
    public static bool SetToAncestor(Byte[] bytes, UInt32& byteLength, UInt32 levelsUp);
    public void SetToAncestor(OrdPathMark mark);
    public void SetToAncestor(UInt32 levelsUp);
    public void SetToDescendantLimit();
    public bool IsAncestorOf(OrdPath descendant, bool fSelfIsAncestor);
    public bool IsAncestorOf(Byte[] bytes, UInt32 byteLength, bool fSelfIsAncestor);
    public bool IsValid();
    public bool IsDescendantLimit();
    public Byte[] GetBinary(UInt32& byteLength);
    public virtual string ToString();
    public OrdPathMark GetMark();
    public void ComputeBitLength(UInt32 byteLength);
    public void GetBits(ushort startBit, ushort nBits, Byte& bits);
    public void GetBits(ushort startBit, ushort nBits, UInt64& bits);
    public void AppendBits(UInt16& bitOffset, ulong x, ushort nBits);
    public void ParseCodeBits(UInt16& startBit, UInt32& stage);
    public void ExtractComponent(UInt16& bitOffset, SComponent& component, levelType& type);
    public void ExtractOrdComponent(UInt16& bitOffset, Int64& ord, levelType& type);
    public void ExtractOrdComponentFake(OrdPath parent, bool fLeft, UInt16& bitOffset, Int64& ord, levelType& type);
    public void ExtractOrd(UInt16& bitOffset, UInt32 stage, Int64& ord);
    public void WriteComponent(UInt16& bitOffset, SComponent& component, levelType type);
    public void WriteNamespacePrefix(UInt16& bitOffset, long ord, int lNID);
    public void WriteAttribute(UInt16& bitOffset, long ord, int lNID);
    public void WriteOrd(UInt16& bitOffset, long ord);
    public void WriteOrdComponent(UInt16& bitOffset, long ord, levelType type);
    public void ParseTheBinary();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.SqlServer.Types.OrdPathMark : ValueType {
    public ushort m_usBitLength;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.SqlServer.Types.ordpathres : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentNotSqlHierarchyId { get; }
    internal static string BadOrdpath { get; }
    internal static string BadOrdpathString { get; }
    internal static string ChildOrder { get; }
    internal static string NegativeInput { get; }
    internal static string NonNullInput { get; }
    internal static string NotAChild { get; }
    internal static string NullInput { get; }
    internal static string NullRefInput { get; }
    internal static string OrdpathTooLong { get; }
    internal static string ReparentArgs { get; }
    internal static string ResultTooLong { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentNotSqlHierarchyId();
    internal static string get_BadOrdpath();
    internal static string get_BadOrdpathString();
    internal static string get_ChildOrder();
    internal static string get_NegativeInput();
    internal static string get_NonNullInput();
    internal static string get_NotAChild();
    internal static string get_NullInput();
    internal static string get_NullRefInput();
    internal static string get_OrdpathTooLong();
    internal static string get_ReparentArgs();
    internal static string get_ResultTooLong();
}
internal static class Microsoft.SqlServer.Types.OrdPathUtil : object {
    internal static CompareBMP BitCompare(Byte[] bytes1, Byte[] bytes2, UInt32 bitLength);
    internal static int memcmp(Byte[] arr1, Byte[] arr2, UInt32 length);
}
internal class Microsoft.SqlServer.Types.Point : ValueType {
    public double x;
    public double y;
    public Point(double X, double Y);
    public static bool op_Equality(Point p1, Point p2);
    public static bool op_Inequality(Point p1, Point p2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.SqlServer.Types.PointZM : ValueType {
    public double x;
    public double y;
    public double z;
    public double m;
    public PointZM(double X, double Y, double Z, double M);
}
internal class Microsoft.SqlServer.Types.ReorientSink : object {
    private GeoDataBuilder _builder;
    private GeoDataBuilder _sink;
    private bool _invertGeography;
    private bool _inMultiPolygon;
    private bool _postponeCurrent;
    private int _srid;
    private double GetEccentricity();
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double latitude1, double longitude1, Nullable`1<double> z1, Nullable`1<double> m1, double latitude2, double longitude2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    public GeoData ConstructedGeoData();
}
internal class Microsoft.SqlServer.Types.SComponent : ValueType {
    public ESType type;
    public long ord;
    public int lNID;
}
internal class Microsoft.SqlServer.Types.Segment : ValueType {
    public SegmentType type;
    public Segment(SegmentType Type);
}
internal enum Microsoft.SqlServer.Types.SegmentType : Enum {
    public byte value__;
    public static SegmentType Line;
    public static SegmentType Arc;
    public static SegmentType FirstLine;
    public static SegmentType FirstArc;
}
[FlagsAttribute]
internal enum Microsoft.SqlServer.Types.SerializationProperties : Enum {
    public byte value__;
    public static SerializationProperties None;
    public static SerializationProperties HasZValues;
    public static SerializationProperties HasMValues;
    public static SerializationProperties IsValid;
    public static SerializationProperties IsSinglePoint;
    public static SerializationProperties IsSingleLineSegment;
    public static SerializationProperties IsLargerThanAHemisphere;
}
internal enum Microsoft.SqlServer.Types.SerializationVersion : Enum {
    public byte value__;
    public static SerializationVersion Katmai_CTP4;
    public static SerializationVersion SQL11_Fullglobe;
}
internal class Microsoft.SqlServer.Types.Shape : ValueType {
    public int figureOffset;
    public int parentOffset;
    public OpenGisType type;
    public Shape(int figureOffset, int parentOffset, OpenGisType type);
}
public static class Microsoft.SqlServer.Types.SpaceFillingCurve : object {
    [CLSCompliantAttribute("False")]
public static ulong Hilbert(int order, UInt32 x, UInt32 y);
    [CLSCompliantAttribute("False")]
public static void ReverseHilbert(int order, ulong hilbert, UInt32& ox, UInt32& oy);
}
internal class Microsoft.SqlServer.Types.SpatialAdaptiveGridSettings : object {
    public static int cGridDepth;
    public static UInt16[] s_GridSizes;
    public static int cMaxTessellationCard;
    public static UInt32 cCandidateTessellationCard;
    public static double MethodOpToIndexOpPrecisionFactor;
    public static Byte[0...,0...] s_LabelForHexaGrid;
    public static Byte[0...,0...] s_LabelForOctaGrid;
    public static Byte[0...,0...] s_LabelForQuadGrid;
    public static Byte[0...,0...] s_LabelForDiGrid;
    public static Boolean[0...,0...] s_ValidityConfigs;
    public static int LowWatermark;
    public static int HighWaterMark;
    private static SpatialAdaptiveGridSettings();
    public static byte BLabel(ushort gridDensity, ushort row, ushort col);
}
public class Microsoft.SqlServer.Types.SpatialGridCoverage : object {
    [SqlFunctionAttribute]
public static IEnumerable Planar(SqlGeometry geometry, double rootX, double rootY, double maxX, double maxY, int rows, int columns);
    [SqlFunctionAttribute]
public static IEnumerable Geodetic(SqlGeography geography, int rows, int columns);
    [IteratorStateMachineAttribute("Microsoft.SqlServer.Types.SpatialGridCoverage/<GridCoverage>d__2")]
private static IEnumerable GridCoverage(ISqlSpatialGridIndexable obj, double rootX, double rootY, double width, double height, int rows, int columns, bool unproject);
    private static GridCell GetRootCell(double rootX, double rootY, double width, double height);
    public static void FillRow(object obj, Int32& id, Byte& attribute, Byte[]& wkb);
    private static SqlGeometry CreateBox(OpenGisGeometryType type, double xmin, double ymin, double width, double height);
}
internal static class Microsoft.SqlServer.Types.SpatialGridSettings : object {
    public static int cCellIdBytes;
    public static int cBitsPerGrid;
    private static int cBitsForDepth;
    public static int cGridDepth;
    public static int cMinGridDepth;
    public static int cGridSize;
    public static int cGridSizeSquared;
    public static int cIndexResolutionBits;
    public static int cIndexResolution;
    public static int cMaxTessellationCard;
    public static double MethodOpToIndexOpPrecisionFactor;
    public static int LowWatermark;
    public static int HighWaterMark;
    public static ulong AddDepthToLabel(ulong label, int depth);
    public static ulong AddDepthToLabelLimit(ulong label, int depth);
    public static int RemoveGridFromLabel(UInt64& label);
    public static int RemoveDepthFromLabel(UInt64& label);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.SqlServer.Types.SpatialRes : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string StrAntipodalEdge { get; }
    internal static string StrArcNeedToHaveEqualZ { get; }
    internal static string StrBufferPassedIllegalDistance { get; }
    internal static string StrBufferWithTolerancePassedIllegalTolerance { get; }
    internal static string StrBufferWouldWrapAround { get; }
    internal static string StrCircularStringNeedsThreePoints { get; }
    internal static string StrCompoundCurveMismatch { get; }
    internal static string StrCompoundCurveNeedsTwoPoints { get; }
    internal static string StrCurveToLinePassedIllegalTolerance { get; }
    internal static string StrEmptyTextError { get; }
    internal static string StrExpectedNumber { get; }
    internal static string StrFullGlobeCannotBePartOfGeometryCollection { get; }
    internal static string StrFullGlobeCannotHaveElements { get; }
    internal static string StrGenericTextError { get; }
    internal static string StrGenericWKBError { get; }
    internal static string StrGeographyCoordinatesLatitudeIsNotValid { get; }
    internal static string StrGeographyCoordinatesLongitudeIsNotValid { get; }
    internal static string StrGeographyInputIsNotValid { get; }
    internal static string StrGeographySridIsNotValid { get; }
    internal static string StrGLLibraryNotLoaded { get; }
    internal static string StrGmlArcMustHaveExactlyThreePoints { get; }
    internal static string StrGmlMayNotHaveAttributes { get; }
    internal static string StrGmlMustHaveSingleTag { get; }
    internal static string StrGmlMustHaveValidTag { get; }
    internal static string StrIncompatibleGeographySinks { get; }
    internal static string StrIncompatibleGeometrySinks { get; }
    internal static string StrInstanceIsNotValid { get; }
    internal static string StrInstanceOfPassedIllegalType { get; }
    internal static string StrInvalidAntipodalEdge { get; }
    internal static string StrInvalidBoundingBox { get; }
    internal static string StrInvalidDegeneratePolygon { get; }
    internal static string StrInvalidDegeneratesToPoint { get; }
    internal static string StrInvalidEdgeOverlap { get; }
    internal static string StrInvalidEdgeOverlapSameCurve { get; }
    internal static string StrInvalidEntry { get; }
    internal static string StrInvalidExteriorRing { get; }
    internal static string StrInvalidGeographyInputHemisphere { get; }
    internal static string StrInvalidGeographyRingOutOfPlace { get; }
    internal static string StrInvalidGeometryRingOutOfPlace { get; }
    internal static string StrInvalidIsolatedPoint { get; }
    internal static string StrInvalidOpenRing { get; }
    internal static string StrInvalidPolygon { get; }
    internal static string StrInvalidRedundantRing { get; }
    internal static string StrInvalidRingOverlap { get; }
    internal static string StrInvalidSplitRing { get; }
    internal static string StrInvalidSplitRingUnknown { get; }
    internal static string StrInvalidType { get; }
    internal static string StrInvalidUnknown { get; }
    internal static string StrLinearRingHasTooFewPoints { get; }
    internal static string StrLineStringNeedsTwoPoints { get; }
    internal static string StrListCapacityExceeded { get; }
    internal static string StrNestingOverflow { get; }
    internal static string StrNoMoreCallsExpected { get; }
    internal static string StrPlatformNotSupported { get; }
    internal static string StrPointCoordinateIsNotValid { get; }
    internal static string StrPolygonExteriorRingHasTooFewPoints { get; }
    internal static string StrPolygonExteriorRingNotARing { get; }
    internal static string StrPolygonInteriorRingHasTooFewPoints { get; }
    internal static string StrPolygonInteriorRingNotARing { get; }
    internal static string StrPolygonRingHasTooFewPoints { get; }
    internal static string StrPolygonRingNotARing { get; }
    internal static string StrPosListHasOddCoordinates { get; }
    internal static string StrPosListIsEmpty { get; }
    internal static string StrPosMustHaveTwoCoordinates { get; }
    internal static string StrReducePassedIllegalTolerance { get; }
    internal static string StrSetSridMismatch { get; }
    internal static string StrSingleSideReducePassedIllegalAreaDelta { get; }
    internal static string StrSridOutOfRange { get; }
    internal static string StrSTCurveNIndexTooSmall { get; }
    internal static string StrSTGeometryNIndexTooSmall { get; }
    internal static string StrSTInteriorRingNIndexTooSmall { get; }
    internal static string StrSTPointNIndexTooSmall { get; }
    internal static string StrSTRelatePassedIntersectionPatternMatrixWithIncorrectSize { get; }
    internal static string StrSTRelatePassedIntersectionPatternMatrixWithNotValidCharacter { get; }
    internal static string StrUnexpectedCall { get; }
    internal static string StrUnexpectedCall2 { get; }
    internal static string StrUnexpectedEndOfInput { get; }
    internal static string StrUnexpectedVersion { get; }
    internal static string StrUnknownLabelInWKT { get; }
    internal static string StrUnrecognizedToken { get; }
    internal static string StrValid { get; }
    internal static string StrWrongCompatibilityLevel { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_StrAntipodalEdge();
    internal static string get_StrArcNeedToHaveEqualZ();
    internal static string get_StrBufferPassedIllegalDistance();
    internal static string get_StrBufferWithTolerancePassedIllegalTolerance();
    internal static string get_StrBufferWouldWrapAround();
    internal static string get_StrCircularStringNeedsThreePoints();
    internal static string get_StrCompoundCurveMismatch();
    internal static string get_StrCompoundCurveNeedsTwoPoints();
    internal static string get_StrCurveToLinePassedIllegalTolerance();
    internal static string get_StrEmptyTextError();
    internal static string get_StrExpectedNumber();
    internal static string get_StrFullGlobeCannotBePartOfGeometryCollection();
    internal static string get_StrFullGlobeCannotHaveElements();
    internal static string get_StrGenericTextError();
    internal static string get_StrGenericWKBError();
    internal static string get_StrGeographyCoordinatesLatitudeIsNotValid();
    internal static string get_StrGeographyCoordinatesLongitudeIsNotValid();
    internal static string get_StrGeographyInputIsNotValid();
    internal static string get_StrGeographySridIsNotValid();
    internal static string get_StrGLLibraryNotLoaded();
    internal static string get_StrGmlArcMustHaveExactlyThreePoints();
    internal static string get_StrGmlMayNotHaveAttributes();
    internal static string get_StrGmlMustHaveSingleTag();
    internal static string get_StrGmlMustHaveValidTag();
    internal static string get_StrIncompatibleGeographySinks();
    internal static string get_StrIncompatibleGeometrySinks();
    internal static string get_StrInstanceIsNotValid();
    internal static string get_StrInstanceOfPassedIllegalType();
    internal static string get_StrInvalidAntipodalEdge();
    internal static string get_StrInvalidBoundingBox();
    internal static string get_StrInvalidDegeneratePolygon();
    internal static string get_StrInvalidDegeneratesToPoint();
    internal static string get_StrInvalidEdgeOverlap();
    internal static string get_StrInvalidEdgeOverlapSameCurve();
    internal static string get_StrInvalidEntry();
    internal static string get_StrInvalidExteriorRing();
    internal static string get_StrInvalidGeographyInputHemisphere();
    internal static string get_StrInvalidGeographyRingOutOfPlace();
    internal static string get_StrInvalidGeometryRingOutOfPlace();
    internal static string get_StrInvalidIsolatedPoint();
    internal static string get_StrInvalidOpenRing();
    internal static string get_StrInvalidPolygon();
    internal static string get_StrInvalidRedundantRing();
    internal static string get_StrInvalidRingOverlap();
    internal static string get_StrInvalidSplitRing();
    internal static string get_StrInvalidSplitRingUnknown();
    internal static string get_StrInvalidType();
    internal static string get_StrInvalidUnknown();
    internal static string get_StrLinearRingHasTooFewPoints();
    internal static string get_StrLineStringNeedsTwoPoints();
    internal static string get_StrListCapacityExceeded();
    internal static string get_StrNestingOverflow();
    internal static string get_StrNoMoreCallsExpected();
    internal static string get_StrPlatformNotSupported();
    internal static string get_StrPointCoordinateIsNotValid();
    internal static string get_StrPolygonExteriorRingHasTooFewPoints();
    internal static string get_StrPolygonExteriorRingNotARing();
    internal static string get_StrPolygonInteriorRingHasTooFewPoints();
    internal static string get_StrPolygonInteriorRingNotARing();
    internal static string get_StrPolygonRingHasTooFewPoints();
    internal static string get_StrPolygonRingNotARing();
    internal static string get_StrPosListHasOddCoordinates();
    internal static string get_StrPosListIsEmpty();
    internal static string get_StrPosMustHaveTwoCoordinates();
    internal static string get_StrReducePassedIllegalTolerance();
    internal static string get_StrSetSridMismatch();
    internal static string get_StrSingleSideReducePassedIllegalAreaDelta();
    internal static string get_StrSridOutOfRange();
    internal static string get_StrSTCurveNIndexTooSmall();
    internal static string get_StrSTGeometryNIndexTooSmall();
    internal static string get_StrSTInteriorRingNIndexTooSmall();
    internal static string get_StrSTPointNIndexTooSmall();
    internal static string get_StrSTRelatePassedIntersectionPatternMatrixWithIncorrectSize();
    internal static string get_StrSTRelatePassedIntersectionPatternMatrixWithNotValidCharacter();
    internal static string get_StrUnexpectedCall();
    internal static string get_StrUnexpectedCall2();
    internal static string get_StrUnexpectedEndOfInput();
    internal static string get_StrUnexpectedVersion();
    internal static string get_StrUnknownLabelInWKT();
    internal static string get_StrUnrecognizedToken();
    internal static string get_StrValid();
    internal static string get_StrWrongCompatibilityLevel();
}
internal class Microsoft.SqlServer.Types.SpatialTessellationConfiguration : object {
    private UInt16[] m_GridDensityForEachLevel;
    public ECellLabellingScheme m_LabellingScheme;
    public SpatialTessellationConfiguration(ECellLabellingScheme labellingScheme, UInt16[] densityOfGrids);
    public ushort UsGridSize(ushort depth);
    public ushort UsGridDensity(ushort depth);
}
internal class Microsoft.SqlServer.Types.SpatialTessellationEnumerator : object {
    private ISqlSpatialGridIndexable m_SourceObject;
    private ISqlSpatialGridIndexable m_RegionForInternalFiltering;
    private SpatialTessellationConfiguration m_TessellationConfig;
    private Queue m_PartialCellCoverageQueue;
    private SpatialTessellationRange m_CurrentSpatialTessellationRange;
    private SpatialTessellationOutputCellStream m_OutStream;
    private UInt32 m_CurrentCandidateCount;
    private EProcessState m_ProcessingState;
    private bool m_IsUnsafeObject;
    private bool m_TreatRootCellAsParentOfTopGrid;
    private bool m_fDisableInternalFiltering;
    private Boolean[0...,0...] m_TouchedCells;
    private Boolean[0...,0...] m_PartiallyCoveredCells;
    private Boolean[0...,0...] m_ContainedCells;
    private Boolean[0...,0...][] m_TouchedCellsForAllGrids;
    private Boolean[0...,0...][] m_PartiallyCoveredCellsForAllGrids;
    private Boolean[0...,0...][] m_ContainedCellsForAllGrids;
    private double m_FuzzX;
    private double m_FuzzY;
    public object Current { get; }
    public SpatialTessellationEnumerator(ISqlSpatialGridIndexable sourceObject, bool isValid, bool isSafeRootCellObject, bool isIncludeRootCellAlways, int srid, double gridRootX, double gridRootY, double gridWidth, double gridHeight, UInt16[] densityForEachGridLevel, ECellLabellingScheme labellingScheme, int maxCellsInTessellationOutput, SqlDouble distanceBuffer, bool enableFuzz);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    private bool IsTooLargeUnsafeObject(PartiallyCoveredCell partiallyCoveredCandidateCell);
    public void Process();
    private void GetGridCoverage(PartiallyCoveredCell partiallyCoveredCandidateCell, ushort gridSize, Int32& totalCellsTouched, Int32& totalCellsPartiallyCovered, Int32& totalCellsContained, Boolean& geometryExceedsGrid);
    private void ProcessContainedCells(PartiallyCoveredCell partiallyCoveredCandidateCell, ushort gridSize, int totalCells);
    private void ProcessPartiallyCoveredCells(PartiallyCoveredCell partiallyCoveredCandidateCell, ushort gridSize, int totalCells, bool isLeafGrid, bool disableIntermediateFiltering, double cellWidth, double cellHeight);
    private void ProcessTouchedCells(PartiallyCoveredCell partiallyCoveredCandidateCell, ushort gridSize, int totalCells, bool isLeafGrid, double cellWidth, double cellHeight);
}
public class Microsoft.SqlServer.Types.SpatialTessellationFunction : object {
    private static bool FQueryWindow(int options);
    private static bool FGenerateCoverage(int options);
    private static bool FUseFuzz(int options);
    [SqlFunctionAttribute]
public static IEnumerable Planar(SqlGeometry geometry, double rootX, double rootY, double maxX, double maxY, int cardinality, int maxDepth, int options, SqlDouble distanceBuffer);
    [SqlFunctionAttribute]
public static IEnumerable Geodetic(SqlGeography geography, int cardinality, int maxDepth, int options, SqlDouble distanceBuffer);
    public static void FillRow(object obj, Byte[]& cellId, Byte& cellAttributes, Byte[]& cellIdLimit, Byte[]& wkbCoverage);
    private static Byte[] ULongToByteArray(ulong label, int cBytes);
    public static string GetId(object obj);
    public static int GetAttribute(object obj);
    public static SqlGeometry GetCoverage(object obj);
    public static bool GetIsAncestor(object obj);
}
internal class Microsoft.SqlServer.Types.SpatialTessellationRange : object {
    public static ECellCoverageAttr[] s_CandidateModeChildCellAttr;
    public UInt32 m_CellStartRange;
    public UInt32 m_CellEndRange;
    public SqlBytes m_VarBinaryCellLabel;
    public ECellCoverageAttr m_ECellCoverageAttr;
    public int m_SpatialReferenceId;
    public SpatialTessellationRange(UInt32 cellStartRange, UInt32 cellEndRange, ECellCoverageAttr cellCoverage, int SpatialReferenceId);
    public SpatialTessellationRange(SqlBytes cellLabel, ECellCoverageAttr cellCoverage, int SpatialReferenceId);
    private static SpatialTessellationRange();
    public static bool op_Equality(SpatialTessellationRange a, SpatialTessellationRange b);
    public static bool op_Inequality(SpatialTessellationRange a, SpatialTessellationRange b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.SqlServer.Types.SpatialTessellationRangeCollection : object {
    private SpatialTessellationEnumerator m_enumerator;
    public SpatialTessellationRangeCollection(ISqlSpatialGridIndexable sourceObj, bool isValid, bool isSafeRootCellObject, bool isIncludeRootCellAlways, int srid, double rootOfGridX, double rootOfGridY, double gridWidth, double gridHeight, UInt16[] gridDensityArray, ECellLabellingScheme labellingScheme, int maxCellsInTessellationOutput, SqlDouble distanceBuffer, bool useFuzz);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.SqlServer.Types.Sphere : ValueType {
    public double x;
    public double y;
    public double z;
    public double extent;
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedTypeAttribute]
public class Microsoft.SqlServer.Types.SqlGeography : object {
    internal static int DefaultSrid;
    private static double DefaultTolerance;
    private static double MinimalRelativeBufferDistance;
    private GeoData _geometry;
    private bool _isNull;
    private int _srid;
    private static String[] _allowedTypeNames;
    private static String[][] _ancestorTypeNames;
    private static long WORKSPACE_BOUND;
    internal static double GeodeticTiledProjectionRoot;
    internal static double GeodeticTiledProjectionExtent;
    internal static double GeodeticTessellationHemispherseOffsetInGlobalSpace;
    internal static double GeodeticTessellationRootX;
    internal static double GeodeticTessellationRootY;
    internal static double GeodeticTessellationWidth;
    internal static double GeodeticTessellationHeight;
    private static int SQL11CompatLevel;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isClrFeatureSwitchMapSet;
    private static object _lockObject;
    public bool IsNull { get; }
    public static SqlGeography Null { get; }
    internal GeoData GeoData { get; }
    internal int Srid { get; internal set; }
    public SqlInt32 STSrid { get; public set; }
    public SqlDouble Lat { get; }
    public SqlDouble Long { get; }
    public SqlDouble Z { get; }
    public SqlDouble M { get; }
    public bool HasZ { get; }
    public bool HasM { get; }
    internal bool IsFullGlobe { get; }
    internal SqlGeography(bool fNull);
    internal SqlGeography(int srid);
    internal SqlGeography(PointZM p, int srid);
    internal SqlGeography(Point p, int srid);
    internal SqlGeography(GeoData g, int srid);
    private static SqlGeography();
    internal static SqlGeography Construct(GeoData g, int srid);
    [SqlMethodAttribute]
public sealed virtual bool get_IsNull();
    [SqlMethodAttribute]
public sealed virtual void Read(BinaryReader r);
    [SqlMethodAttribute]
public sealed virtual void Write(BinaryWriter w);
    private EllipsoidParameters GetEllipsoidParameters();
    private double GetEccentricity();
    internal void ThrowIfInvalid();
    [SqlMethodAttribute]
public static SqlGeography GeomFromGml(SqlXml xml, int srid);
    [SqlMethodAttribute]
public SqlXml AsGml();
    [SqlMethodAttribute]
public static SqlGeography get_Null();
    [SqlMethodAttribute]
public virtual string ToString();
    [SqlMethodAttribute]
public static SqlGeography Parse(SqlString s);
    internal GeoData get_GeoData();
    internal int get_Srid();
    internal void set_Srid(int value);
    private static void ThrowIfArgumentNull(object argument, string argumentName);
    [SqlMethodAttribute]
public static SqlGeography Point(double latitude, double longitude, int srid);
    internal static GeoData ParseText(OpenGisType type, SqlChars taggedText, int srid);
    internal static SqlGeography GeographyFromText(OpenGisType type, SqlChars taggedText, int srid);
    internal static SqlGeography GeographyFromBinary(OpenGisType type, SqlBytes wkbGeography, int srid);
    [SqlMethodAttribute]
public static SqlGeography STGeomFromText(SqlChars geometryTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STPointFromText(SqlChars pointTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STLineFromText(SqlChars lineStringTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STPolyFromText(SqlChars polygonTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMPointFromText(SqlChars multiPointTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMLineFromText(SqlChars multiLineStringTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMPolyFromText(SqlChars multiPolygonTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STGeomCollFromText(SqlChars geometryCollectionTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeography STGeomFromWKB(SqlBytes wkbGeometry, int srid);
    [SqlMethodAttribute]
public static SqlGeography STPointFromWKB(SqlBytes wkbPoint, int srid);
    [SqlMethodAttribute]
public static SqlGeography STLineFromWKB(SqlBytes wkbLineString, int srid);
    [SqlMethodAttribute]
public static SqlGeography STPolyFromWKB(SqlBytes wkbPolygon, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMPointFromWKB(SqlBytes wkbMultiPoint, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMLineFromWKB(SqlBytes wkbMultiLineString, int srid);
    [SqlMethodAttribute]
public static SqlGeography STMPolyFromWKB(SqlBytes wkbMultiPolygon, int srid);
    [SqlMethodAttribute]
public static SqlGeography STGeomCollFromWKB(SqlBytes wkbGeometryCollection, int srid);
    public SqlBytes Serialize();
    public static SqlGeography Deserialize(SqlBytes bytes);
    [SqlMethodAttribute]
public SqlInt32 get_STSrid();
    [SqlMethodAttribute]
public void set_STSrid(SqlInt32 value);
    [SqlMethodAttribute]
public SqlInt32 STDimension();
    [SqlMethodAttribute]
public SqlString STGeometryType();
    [SqlMethodAttribute]
public SqlChars STAsText();
    [SqlMethodAttribute]
public SqlChars AsTextZM();
    private string ToWellKnownText(bool writePointZM);
    [SqlMethodAttribute]
public SqlBytes STAsBinary();
    [SqlMethodAttribute]
public SqlBytes AsBinaryZM();
    private SqlBytes ToWellKnownBinary(bool writeZ, bool writeM);
    [SqlMethodAttribute]
public SqlBoolean STIsEmpty();
    [SqlMethodAttribute]
public SqlBoolean STEquals(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STDisjoint(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STIntersects(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STOverlaps(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STWithin(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STContains(SqlGeography other);
    [SqlMethodAttribute]
public SqlDouble STDistance(SqlGeography other);
    [SqlMethodAttribute]
public SqlGeography STBuffer(double distance);
    [SqlMethodAttribute]
public SqlGeography STIntersection(SqlGeography other);
    [SqlMethodAttribute]
public SqlGeography STUnion(SqlGeography other);
    [SqlMethodAttribute]
public SqlGeography STDifference(SqlGeography other);
    [SqlMethodAttribute]
public SqlGeography STSymDifference(SqlGeography other);
    [SqlMethodAttribute]
public SqlBoolean STIsValid();
    [SqlMethodAttribute]
public SqlGeography NullOnInvalid();
    [SqlMethodAttribute]
public string IsValidDetailed();
    [SecuritySafeCriticalAttribute]
private bool IsValidExpensive(bool forceKatmai);
    [SqlMethodAttribute]
public SqlDouble STArea();
    [SqlMethodAttribute]
public SqlBoolean STIsClosed();
    [SqlMethodAttribute]
public SqlDouble STLength();
    [SqlMethodAttribute]
public SqlInt32 STNumPoints();
    [SqlMethodAttribute]
public SqlGeography STPointN(int n);
    [SqlMethodAttribute]
public SqlInt32 STNumCurves();
    [SqlMethodAttribute]
public SqlGeography STCurveN(int n);
    [SqlMethodAttribute]
public SqlGeography STStartPoint();
    [SqlMethodAttribute]
public SqlGeography STEndPoint();
    [SqlMethodAttribute]
public SqlInt32 STNumGeometries();
    [SqlMethodAttribute]
public SqlGeography STGeometryN(int n);
    [SqlMethodAttribute]
public SqlGeography STConvexHull();
    [SqlMethodAttribute]
public SqlGeography STCurveToLine();
    [SqlMethodAttribute]
public SqlGeography ShortestLineTo(SqlGeography other);
    [SqlMethodAttribute]
public SqlGeography MakeValid();
    [SqlMethodAttribute]
public SqlGeography Reduce(double tolerance);
    private bool IsPoint();
    [SqlMethodAttribute]
public SqlDouble get_Lat();
    [SqlMethodAttribute]
public SqlDouble get_Long();
    [SqlMethodAttribute]
public SqlDouble get_Z();
    [SqlMethodAttribute]
public SqlDouble get_M();
    [SqlMethodAttribute]
public bool get_HasZ();
    [SqlMethodAttribute]
public bool get_HasM();
    [SqlMethodAttribute]
public SqlInt32 NumRings();
    [SqlMethodAttribute]
public SqlGeography RingN(int n);
    [SqlMethodAttribute]
public SqlBoolean InstanceOf(string geometryType);
    [SqlMethodAttribute]
public SqlGeography BufferWithTolerance(double distance, double tolerance, bool relative);
    [SqlMethodAttribute]
public SqlGeography BufferWithCurves(double distance);
    [SqlMethodAttribute]
internal bool get_IsFullGlobe();
    [SqlMethodAttribute]
public SqlBoolean Filter(SqlGeography other);
    [SqlMethodAttribute]
public int MinDbCompatibilityLevel();
    [SqlMethodAttribute]
public SqlGeography CurveToLineWithTolerance(double tolerance, bool relative);
    [SqlMethodAttribute]
private sealed virtual override void Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.GetGridCoverage(bool isTopmostGrid, double rGridMinX, double rGridMinY, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, int cGridRows, int cGridColumns, Boolean[0...,0...] touched, Boolean[0...,0...] contained, Int32& cCellsTouched, Int32& cCellsContained, Boolean& fGeometryExceedsGrid, Boolean& fHasAmbiguousTouchedCells);
    private sealed virtual override void Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.GetBoundingBoxCorners(Double& minX, Double& minY, Double& maxX, Double& maxY);
    [SqlMethodAttribute]
private sealed virtual override ISqlSpatialGridIndexable Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.BufferForDistanceQuery(double distance, Boolean& disableIntermediateFiltering);
    [ObsoleteAttribute("Populate(IGeographySink) method is obsolete, use Populate(IGeographySink110) instead.")]
public void Populate(IGeographySink sink);
    public void Populate(IGeographySink110 sink);
    private void InternalPopulate(GeoDataSink sink);
    [SqlMethodAttribute]
private sealed virtual override ISqlSpatialGridIndexable Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.InteriorBufferForDistanceQuery(double distance);
    [SqlMethodAttribute]
public SqlDouble EnvelopeAngle();
    [SqlMethodAttribute]
public SqlGeography EnvelopeCenter();
    [SqlMethodAttribute]
public SqlGeography ReorientObject();
    internal static bool IsKatmaiCompatLevel();
    internal static void UpdateClrFeatureSwitchMap();
    internal static int ClrFeatureSwitchMap();
}
[CLSCompliantAttribute("True")]
public class Microsoft.SqlServer.Types.SqlGeographyBuilder : object {
    private int _srid;
    private GeoDataSink _validator;
    private GeoDataBuilder _builder;
    public SqlGeography ConstructedGeography { get; }
    public virtual void SetSrid(int srid);
    public virtual void BeginGeography(OpenGisGeographyType type);
    public virtual void BeginFigure(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public virtual void AddLine(double latitude, double longitude, Nullable`1<double> z, Nullable`1<double> m);
    public virtual void AddCircularArc(double latitude1, double longitude1, Nullable`1<double> z1, Nullable`1<double> m1, double latitude2, double longitude2, Nullable`1<double> z2, Nullable`1<double> m2);
    public virtual void EndFigure();
    public virtual void EndGeography();
    public virtual SqlGeography get_ConstructedGeography();
    public void BeginFigure(double latitude, double longitude);
    public void AddLine(double latitude, double longitude);
    public void AddCircularArc(double latitude1, double longitude1, double latitude2, double longitude2);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedTypeAttribute]
public class Microsoft.SqlServer.Types.SqlGeometry : object {
    internal static int DefaultSrid;
    private static int NullSrid;
    private static int MinSrid;
    private static int MaxSrid;
    private static double DefaultSimpleBufferTolerance;
    private static double DefaultBufferTolerance;
    private static double MinimalRelativeBufferDistance;
    private GeoData _geometry;
    private bool _isNull;
    private int _srid;
    private static String[] _allowedTypeNames;
    private static String[][] _ancestorTypeNames;
    public bool IsNull { get; }
    public static SqlGeometry Null { get; }
    internal GeoData GeoData { get; }
    internal int Srid { get; internal set; }
    public SqlInt32 STSrid { get; public set; }
    public SqlDouble STX { get; }
    public SqlDouble STY { get; }
    public SqlDouble Z { get; }
    public SqlDouble M { get; }
    public bool HasZ { get; }
    public bool HasM { get; }
    internal SqlGeometry(bool fNull);
    internal SqlGeometry(int srid);
    internal SqlGeometry(PointZM p, int srid);
    internal SqlGeometry(GeoData g, int srid);
    private static SqlGeometry();
    internal static SqlGeometry Construct(GeoData g, int srid);
    [SqlMethodAttribute]
public sealed virtual bool get_IsNull();
    [SqlMethodAttribute]
public sealed virtual void Read(BinaryReader r);
    [SqlMethodAttribute]
public sealed virtual void Write(BinaryWriter w);
    internal void ThrowIfInvalid();
    [SqlMethodAttribute]
public static SqlGeometry GeomFromGml(SqlXml xml, int srid);
    [SqlMethodAttribute]
public SqlXml AsGml();
    [SqlMethodAttribute]
public static SqlGeometry get_Null();
    [SqlMethodAttribute]
public virtual string ToString();
    [SqlMethodAttribute]
public static SqlGeometry Parse(SqlString s);
    internal GeoData get_GeoData();
    internal int get_Srid();
    internal void set_Srid(int value);
    private static void ThrowIfArgumentNull(object argument, string argumentName);
    [SqlMethodAttribute]
public static SqlGeometry Point(double x, double y, int srid);
    internal static SqlGeometry GeometryFromText(OpenGisType type, SqlChars text, int srid);
    internal static SqlGeometry GeometryFromBinary(OpenGisType type, SqlBytes binary, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STGeomFromText(SqlChars geometryTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STPointFromText(SqlChars pointTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STLineFromText(SqlChars lineStringTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STPolyFromText(SqlChars polygonTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMPointFromText(SqlChars multiPointTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMLineFromText(SqlChars multiLineStringTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMPolyFromText(SqlChars multiPolygonTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STGeomCollFromText(SqlChars geometryCollectionTaggedText, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STGeomFromWKB(SqlBytes wkbGeometry, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STPointFromWKB(SqlBytes wkbPoint, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STLineFromWKB(SqlBytes wkbLineString, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STPolyFromWKB(SqlBytes wkbPolygon, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMPointFromWKB(SqlBytes wkbMultiPoint, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMLineFromWKB(SqlBytes wkbMultiLineString, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STMPolyFromWKB(SqlBytes wkbMultiPolygon, int srid);
    [SqlMethodAttribute]
public static SqlGeometry STGeomCollFromWKB(SqlBytes wkbGeometryCollection, int srid);
    public SqlBytes Serialize();
    public static SqlGeometry Deserialize(SqlBytes bytes);
    [SqlMethodAttribute]
public SqlInt32 get_STSrid();
    [SqlMethodAttribute]
public void set_STSrid(SqlInt32 value);
    [SqlMethodAttribute]
public SqlInt32 STDimension();
    [SqlMethodAttribute]
public SqlString STGeometryType();
    [SqlMethodAttribute]
public SqlGeometry STEnvelope();
    [SqlMethodAttribute]
public SqlChars STAsText();
    [SqlMethodAttribute]
public SqlChars AsTextZM();
    private string ToWellKnownText(bool writePointZM);
    [SqlMethodAttribute]
public SqlBytes STAsBinary();
    [SqlMethodAttribute]
public SqlBytes AsBinaryZM();
    private SqlBytes ToWellKnownBinary(bool writeZ, bool writeM);
    [SqlMethodAttribute]
public SqlBoolean STIsEmpty();
    [SqlMethodAttribute]
public SqlBoolean STIsSimple();
    [SqlMethodAttribute]
public SqlGeometry STBoundary();
    [SqlMethodAttribute]
public SqlBoolean STEquals(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STRelate(SqlGeometry other, string intersectionPatternMatrix);
    [SqlMethodAttribute]
public SqlBoolean STDisjoint(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STIntersects(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STTouches(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STCrosses(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STWithin(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STContains(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STOverlaps(SqlGeometry other);
    [SqlMethodAttribute]
public SqlDouble STDistance(SqlGeometry other);
    [SqlMethodAttribute]
public SqlGeometry STBuffer(double distance);
    [SqlMethodAttribute]
public SqlGeometry STConvexHull();
    [SqlMethodAttribute]
public SqlGeometry STIntersection(SqlGeometry other);
    [SqlMethodAttribute]
public SqlGeometry STUnion(SqlGeometry other);
    [SqlMethodAttribute]
public SqlGeometry STDifference(SqlGeometry other);
    [SqlMethodAttribute]
public SqlGeometry STSymDifference(SqlGeometry other);
    [SqlMethodAttribute]
public SqlBoolean STIsValid();
    [SqlMethodAttribute]
public SqlGeometry NullOnInvalid();
    [SqlMethodAttribute]
public string IsValidDetailed();
    [SecuritySafeCriticalAttribute]
private bool IsValidExpensive();
    [SqlMethodAttribute]
public SqlDouble STArea();
    [SqlMethodAttribute]
public SqlGeometry STPointOnSurface();
    [SqlMethodAttribute]
public SqlBoolean STIsClosed();
    [SqlMethodAttribute]
public SqlBoolean STIsRing();
    [SqlMethodAttribute]
public SqlDouble STLength();
    [SqlMethodAttribute]
public SqlInt32 STNumPoints();
    [SqlMethodAttribute]
public SqlGeometry STPointN(int n);
    [SqlMethodAttribute]
public SqlInt32 STNumCurves();
    [SqlMethodAttribute]
public SqlGeometry STCurveN(int n);
    [SqlMethodAttribute]
public SqlGeometry STStartPoint();
    [SqlMethodAttribute]
public SqlGeometry STEndPoint();
    private bool IsPoint();
    [SqlMethodAttribute]
public SqlDouble get_STX();
    [SqlMethodAttribute]
public SqlDouble get_STY();
    [SqlMethodAttribute]
public SqlDouble get_Z();
    [SqlMethodAttribute]
public SqlDouble get_M();
    [SqlMethodAttribute]
public bool get_HasZ();
    [SqlMethodAttribute]
public bool get_HasM();
    [SqlMethodAttribute]
public SqlGeometry STCentroid();
    [SqlMethodAttribute]
public SqlGeometry STExteriorRing();
    [SqlMethodAttribute]
public SqlInt32 STNumInteriorRing();
    [SqlMethodAttribute]
public SqlGeometry STInteriorRingN(int n);
    [SqlMethodAttribute]
public SqlInt32 STNumGeometries();
    [SqlMethodAttribute]
public SqlGeometry STGeometryN(int n);
    [SqlMethodAttribute]
public SqlGeometry STCurveToLine();
    [SqlMethodAttribute]
public SqlBoolean InstanceOf(string geometryType);
    [SqlMethodAttribute]
public SqlGeometry BufferWithTolerance(double distance, double tolerance, bool relative);
    [SqlMethodAttribute]
public SqlGeometry BufferWithCurves(double distance);
    [SqlMethodAttribute]
public SqlGeometry MakeValid();
    [SqlMethodAttribute]
public SqlGeometry ShortestLineTo(SqlGeometry other);
    [SqlMethodAttribute]
public SqlGeometry Reduce(double tolerance);
    [SqlMethodAttribute]
public int MinDbCompatibilityLevel();
    [SqlMethodAttribute]
public SqlBoolean Filter(SqlGeometry other);
    private sealed virtual override void Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.GetGridCoverage(bool isTopmostGrid, double rGridMinX, double rGridMinY, double rGridWidth, double rGridHeight, double rFuzzX, double rFuzzY, int cGridRows, int cGridColumns, Boolean[0...,0...] touched, Boolean[0...,0...] contained, Int32& cCellsTouched, Int32& cCellsContained, Boolean& fGeometryExceedsGrid, Boolean& fHasAmbiguousTouchedCells);
    private sealed virtual override void Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.GetBoundingBoxCorners(Double& minX, Double& minY, Double& maxX, Double& maxY);
    private double GetDiagonalDistance();
    [SqlMethodAttribute]
private sealed virtual override ISqlSpatialGridIndexable Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.BufferForDistanceQuery(double distance, Boolean& disableInternalFiltering);
    [ObsoleteAttribute("Populate(IGeometrySink) method is obsolete, use Populate(IGeometrySink110) instead.")]
public void Populate(IGeometrySink sink);
    public void Populate(IGeometrySink110 sink);
    private void InternalPopulate(GeoDataSink sink);
    [SqlMethodAttribute]
private sealed virtual override ISqlSpatialGridIndexable Microsoft.SqlServer.Types.ISqlSpatialGridIndexable.InteriorBufferForDistanceQuery(double distance);
    [SqlMethodAttribute]
public SqlGeometry CurveToLineWithTolerance(double tolerance, bool relative);
    internal static void UpdateClrFeatureSwitchMap();
}
[CLSCompliantAttribute("True")]
public class Microsoft.SqlServer.Types.SqlGeometryBuilder : object {
    private int _srid;
    private GeoDataSink _validator;
    private GeoDataBuilder _builder;
    public SqlGeometry ConstructedGeometry { get; }
    public virtual void SetSrid(int srid);
    public virtual void BeginGeometry(OpenGisGeometryType type);
    public virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public virtual void EndFigure();
    public virtual void EndGeometry();
    public virtual SqlGeometry get_ConstructedGeometry();
    public void BeginFigure(double x, double y);
    public void AddLine(double x, double y);
    public void AddCircularArc(double x1, double y1, double x2, double y2);
}
[CLSCompliantAttribute("True")]
[SqlUserDefinedTypeAttribute]
public class Microsoft.SqlServer.Types.SqlHierarchyId : ValueType {
    private OrdPath ordpath;
    private static SqlHierarchyId sm_null;
    public static SqlHierarchyId Null { get; }
    public bool IsNull { get; }
    private static SqlHierarchyId();
    [SqlMethodAttribute]
public static SqlHierarchyId GetRoot();
    [SqlMethodAttribute]
public SqlHierarchyId GetDescendant(SqlHierarchyId child1, SqlHierarchyId child2);
    [SqlMethodAttribute]
public SqlBoolean IsDescendantOf(SqlHierarchyId parent);
    [SqlMethodAttribute]
public SqlInt16 GetLevel();
    [SqlMethodAttribute]
public SqlHierarchyId GetAncestor(int n);
    [SqlMethodAttribute]
public SqlHierarchyId GetReparentedValue(SqlHierarchyId oldRoot, SqlHierarchyId newRoot);
    [SqlMethodAttribute]
private SqlHierarchyId DescendantLimit();
    [SqlMethodAttribute]
public static SqlHierarchyId get_Null();
    [SqlMethodAttribute]
public static SqlHierarchyId Parse(SqlString input);
    public static SqlBoolean op_Equality(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public static SqlBoolean op_Inequality(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public static SqlBoolean op_LessThan(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public static SqlBoolean op_GreaterThan(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public static SqlBoolean op_LessThanOrEqual(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public static SqlBoolean op_GreaterThanOrEqual(SqlHierarchyId hid1, SqlHierarchyId hid2);
    public sealed virtual int CompareTo(object obj);
    public int CompareTo(SqlHierarchyId hid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SqlMethodAttribute]
public virtual string ToString();
    [SqlMethodAttribute]
public sealed virtual bool get_IsNull();
    [SqlMethodAttribute]
public sealed virtual void Read(BinaryReader r);
    [SqlMethodAttribute]
public sealed virtual void Write(BinaryWriter w);
}
internal class Microsoft.SqlServer.Types.SridInfo : object {
    public int spatial_reference_id;
    public string authority_name;
    public int authorized_spatial_reference_id;
    public string well_known_text;
    public string unit_of_measure;
    public double unit_conversion_factor;
    public double semi_major_axis;
    public double semi_minor_axis;
    public SridInfo(int spatial_reference_id, string authority_name, int authorized_spatial_reference_id, string well_known_text, string unit_of_measure, double unit_conversion_factor, double semi_major_axis, double semi_minor_axis);
}
internal class Microsoft.SqlServer.Types.SridList : object {
    private static SortedList`2<int, SridInfo> _sridList;
    private static int _null;
    public static int Null { get; }
    private static SridList();
    public static int get_Null();
    [SqlFunctionAttribute]
public static IEnumerable InitMethod();
    public static void FillRow(object obj, Int32& spatial_reference_id, String& authority_name, Int32& authorized_spatial_reference_id, String& well_known_text, String& unit_of_measure, Double& unit_conversion_factor);
    public static bool SridExists(int srid);
    public static EllipsoidParameters GetEllipsoidParameters(int srid);
}
internal class Microsoft.SqlServer.Types.Stage : ValueType {
    public ushort ordLength;
    public ushort ordLengthExpanded;
    public ushort code;
    public ushort codeLength;
    public ushort totalLength;
    public long highOrd;
    public long lowOrd;
}
internal class Microsoft.SqlServer.Types.TessellationEnumerator : object {
    private ISqlSpatialGridIndexable m_SourceObject;
    private ISqlSpatialGridIndexable m_RegionForInternalFiltering;
    private Queue m_PartialCellCoverageQueue;
    private TessellationRange m_CurrentTessellationRange;
    private SpatialTessellationOutputCellStream m_OutStream;
    private int m_CurrentCandidateCount;
    private EProcessState m_ProcessingState;
    private bool m_IsUnsafeObject;
    private bool m_fDisableInternalFiltering;
    private Boolean[0...,0...] m_TouchedCells;
    private Boolean[0...,0...] m_PartiallyCoveredCells;
    private Boolean[0...,0...] m_ContainedCells;
    private double m_FuzzX;
    private double m_FuzzY;
    private bool m_IntervalMode;
    private int m_MaxLevel;
    private int m_MaxOutputCells;
    public object Current { get; }
    public TessellationEnumerator(ISqlSpatialGridIndexable sourceObject, double gridRootX, double gridRootY, double gridWidth, double gridHeight, int maxOutputCells, SqlDouble distanceBuffer, bool intervalMode, int maxLevel, bool generateCoverage, bool useFuzz, bool enableReduce);
    private PartiallyCoveredCell ReduceCell(PartiallyCoveredCell cell);
    public static ulong GetLabelForPoint(double gridRootX, double gridRootY, double gridWidth, double gridHeight, double x, double y);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    private bool IsTooLargeUnsafeObject(PartiallyCoveredCell candidateCell);
    public void Process();
    private void GetGridCoverage(PartiallyCoveredCell candidateCell, int gridSize, Int32& totalCellsTouched, Int32& totalCellsPartiallyCovered, Int32& totalCellsContained, Boolean& geometryExceedsGrid);
    private void ProcessContainedCells(PartiallyCoveredCell candidateCell, int gridSize, int totalCells);
    private void ProcessPartiallyCoveredCells(PartiallyCoveredCell candidateCell, int gridSize, int totalCells, bool outputCells, double cellWidth, double cellHeight);
    private void ProcessTouchedCells(PartiallyCoveredCell candidateCell, int gridSize, int totalCells, bool outputCells, double cellWidth, double cellHeight);
}
internal class Microsoft.SqlServer.Types.TessellationRange : object {
    public ulong m_CellLabel;
    public ulong m_CellLabelLimit;
    public ECellAttribute m_ECellAttribute;
    public SqlGeometry m_Coverage;
    public bool m_IsAncestor;
    public TessellationRange(ulong cellLabel, ulong cellLabelLimit, ECellAttribute cellCoverage, SqlGeometry coverage, bool isAncestor);
}
internal static class Microsoft.SqlServer.Types.TiledProjection : object {
    private static double WORSPACE_BOUND;
    private static double m_sqrt3;
    private static double m_sqrtThird;
    private static double m_sqrt2Thirds;
    private static double M_SQRT2;
    private static double m_extent;
    private static double m_scale;
    private static double m_inverseConstantTerm;
    private static TiledProjection();
    public static Vector3 InverseProject(double x, double y);
}
internal abstract class Microsoft.SqlServer.Types.Validator : object {
    private string _name;
    private Stack`1<State> _stack;
    private Transition _transition;
    private int _srid;
    protected double _firstX;
    protected double _firstY;
    protected double _lastX;
    protected double _lastY;
    protected Nullable`1<double> _lastZ;
    protected int _pointCount;
    protected int _depth;
    private int _ringCount;
    public Validator(string name);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    private void Execute(Transition transition);
    private void Call(State state);
    private void Return();
    private void Jump(State state);
    protected virtual void ValidateSrid(int srid);
    protected virtual void ValidatePoint(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    protected abstract virtual void ValidatePolygonRing(int iRing, int cPoints, double firstX, double firstY, double lastX, double lastY);
    internal static bool IsPointValid(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    internal static bool IsFinite(double a);
    private void Expected(Transition what);
    private void Expected(Transition what, Transition what2);
    private void Expected(Transition what, Transition what2, Transition what3);
    private string ToString(Transition a);
    protected virtual bool AcceptsFullGlobe();
}
internal class Microsoft.SqlServer.Types.ValidityDetails : object {
    private static UInt32 GetNextUint(UInt32 u);
    private static string ConstructMessage(ValidityState state, UInt32 detail1ZeroBased, UInt32 detail2ZeroBased, bool geography);
    public static string GetMessage(ValidityState state, UInt32 detail1, UInt32 detail2, UInt32 entry, bool geography);
}
public enum Microsoft.SqlServer.Types.ValidityState : Enum {
    public int value__;
    public static ValidityState Valid;
    public static ValidityState InvalidUnknown;
    public static ValidityState InvalidIsolatedPoint;
    public static ValidityState InvalidRingOverlap;
    public static ValidityState InvalidSplitRing;
    public static ValidityState InvalidDegeneratesToPoint;
    public static ValidityState InvalidDegeneratePolygon;
    public static ValidityState InvalidOpenRing;
    public static ValidityState InvalidRedundantRing;
    public static ValidityState InvalidInconsistentOrientation;
    public static ValidityState InvalidExteriorRing;
    public static ValidityState InvalidRingOutOfPlace;
    public static ValidityState InvalidEdgeOverlap;
    public static ValidityState InvalidPolygon;
    public static ValidityState InvalidAntipodalEdge;
}
internal class Microsoft.SqlServer.Types.Vector3 : ValueType {
    public double x;
    public double y;
    public double z;
    public Vector3(double x, double y, double z);
}
internal class Microsoft.SqlServer.Types.WellKnownBinaryReader : object {
    private static UInt32 MinAlternativeWKBTypeValue;
    private static UInt32 MaxAlternativeWKBTypeValue;
    private static UInt32 ZRange;
    private static UInt32 MRange;
    private static UInt32 ZMRange;
    private SqlBytes _bytes;
    private GeoDataSink _sink;
    private int _currentIndex;
    public WellKnownBinaryReader(SqlBytes bytes, GeoDataSink sink);
    public void Read(OpenGisType type, int srid);
    private void ParseWkb(OpenGisType type);
    private void ParseWkbPointWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ParseWkbLineStringWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ParseWkbPolygonWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ParseWkbMultiPointWithoutHeader(ByteOrder byteOrder);
    private void ParseWkbMultiLineStringWithoutHeader(ByteOrder byteOrder);
    private void ParseWkbMultiPolygonWithoutHeader(ByteOrder byteOrder);
    private void ParseWkbGeometryCollectionWithoutHeader(ByteOrder byteOrder);
    private void ParseWkbFullGlobeWithoutHeader(ByteOrder byteOrder);
    private void ParseWkbCircularStringWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ParseWkbCompoundCurveWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ParseWkbCurvePolygonWithoutHeader(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadFirstPoint(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadNextPoint(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadNextArc(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadLinearRing(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadLineStringPoints(ByteOrder byteOrder, UInt32 cPoints, bool readZ, bool readM);
    private void ReadArcRing(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadCircularStringPoints(ByteOrder byteOrder, UInt32 cPoints, bool readZ, bool readM);
    private void ReadCurveRing(ByteOrder byteOrder, bool readZ, bool readM);
    private void ReadCompoundCurve(ByteOrder byteOrder, UInt32 cSubCurves, bool readZ, bool readM);
    private ByteOrder ReadHeader(OpenGisType geoTypeExpected, Boolean& readZ, Boolean& readM);
    private bool ReadIsArcHeader(ByteOrder byteOrder, Boolean& readZ, Boolean& readM);
    private UInt32 ReadUInt32(ByteOrder byteOrder);
    private double ReadDouble(ByteOrder byteOrder);
    private Nullable`1<double> ReadOptDouble(ByteOrder byteOrder);
    private byte ReadByte();
    private Byte[] ReadBytes(int n, ByteOrder byteOrder);
    private OpenGisType ReadType(ByteOrder byteOrder, Boolean& readZ, Boolean& readM);
    private static void ToMachineEndianess(Byte[] buffer, ByteOrder byteOrder);
}
internal class Microsoft.SqlServer.Types.WellKnownBinaryWriter : object {
    public static UInt32 FullGlobeByte;
    private Stream _stream;
    private BinaryWriter _writer;
    private Context _context;
    private bool _writeZ;
    private bool _writeM;
    private Stack`1<long> _offsets;
    private Stack`1<UInt32> _counts;
    private double _pointX;
    private double _pointY;
    private double _lastX;
    private double _lastY;
    private Nullable`1<double> _pointZ;
    private Nullable`1<double> _pointM;
    private Nullable`1<double> _lastZ;
    private Nullable`1<double> _lastM;
    public WellKnownBinaryWriter(Stream stream, bool writeZ, bool writeM);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    private void Increment();
    private void Push(UInt32 count);
    private void Pop();
    private void WriteCount(UInt32 count);
    private void WritePoint(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    private void WriteHeader(OpenGisType t);
}
internal class Microsoft.SqlServer.Types.WellKnownTextReader : object {
    private GeoDataSink _sink;
    private SqlChars _chars;
    private char _current;
    private int _nextIndex;
    private int _streamLength;
    private bool _readEndOfStream;
    private char Current { get; }
    private int Length { get; }
    private bool CanRead { get; }
    public WellKnownTextReader(SqlChars chars, GeoDataSink sink);
    public void Read(OpenGisType type, int srid);
    private void ParseTaggedText(OpenGisType type);
    private void ParsePointText(bool parseParentheses);
    private void ParseLineStringText();
    private void ParsePolygonText();
    private void ParseMultiPointText();
    private void ParseMultiLineStringText();
    private void ParseMultiPolygonText();
    private void ParseGeometryCollectionText();
    private void ParseCircularStringText();
    private void ParseCompoundCurveText();
    private void ParseCurvePolygonText();
    private void ParseRingText(int i);
    private void SkipWhiteSpaces();
    private char get_Current();
    private int get_Length();
    private bool get_CanRead();
    private bool CanReadNChars(int c);
    private string ReadNChars(int c);
    private bool ReadChar();
    private string PeekNChars(int n);
    private bool CurrentIsDoubleSeparator();
    private double RecognizeDouble();
    private Nullable`1<double> RecognizeOptionalDouble();
    private bool RecognizeEmptyGeometry();
    private bool RecognizeOptionalKeyword(string keyword);
    private bool RecognizeOptionalToken(char token);
    private void RecognizeToken(char token);
    private void RecognizeToken(string token);
    private bool RecognizeOptionalToken(string token);
    private bool RecognizeArcOrLineStart();
}
internal class Microsoft.SqlServer.Types.WellKnownTextWriter : object {
    private TextWriter _writer;
    private bool _writePointZM;
    private Context _context;
    private int _shapes;
    private double _lastX;
    private double _lastY;
    private Nullable`1<double> _lastZ;
    private Nullable`1<double> _lastM;
    public WellKnownTextWriter(TextWriter writer, bool writePointZM);
    public sealed virtual void SetSrid(int srid);
    public sealed virtual void BeginGeo(OpenGisType type);
    public sealed virtual void BeginFigure(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddLine(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
    public sealed virtual void AddCircularArc(double x1, double y1, Nullable`1<double> z1, Nullable`1<double> m1, double x2, double y2, Nullable`1<double> z2, Nullable`1<double> m2);
    public sealed virtual void AddSegment(SegmentType type);
    public sealed virtual void StartRing(FigureAttributes type);
    public sealed virtual void EndFigure();
    public sealed virtual void EndGeo();
    public sealed virtual void Finish();
    private void WritePoint(double x, double y, Nullable`1<double> z, Nullable`1<double> m);
}
internal class Microsoft.SqlServer.Types.WordTwoBytes : ValueType {
    public ushort wTwoBytes;
    public TwoBytes bytes;
}
internal class Microsoft.SqlServer.Types.XmlIdGenerator : object {
    private OrdPath m_ordpathCurrent;
    private ushort m_ordcount;
    private long m_rightLimit;
    private static int x_cMAX_XMLDT_Depth;
    private Ord[] m_ords;
    private OrdPathMark m_omParent;
    private bool m_fFakeLevelGenerated;
    private long m_rightLimit2;
    private bool m_fHaveNextID;
    private static XmlIdGenerator();
    public void Init(OrdPath pordpathParent, OrdPath pordpathLeft, OrdPath pordpathRight);
    public OrdPath GetNextID();
}
