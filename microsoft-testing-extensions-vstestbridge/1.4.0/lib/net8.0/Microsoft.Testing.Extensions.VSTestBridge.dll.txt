internal interface Microsoft.Testing.Extensions.VSTestBridge.Capabilities.IVSTestFlattenedTestNodesReportCapability {
    public bool IsSupported { get; }
    public abstract virtual bool get_IsSupported();
}
public class Microsoft.Testing.Extensions.VSTestBridge.Capabilities.VSTestBridgeExtensionBaseCapabilities : object {
    [NullableAttribute("1")]
private static string MultiRequestSupport;
    [NullableAttribute("1")]
private static string VSTestProviderSupport;
    [CompilerGeneratedAttribute]
private bool <Microsoft.Testing.Extensions.VSTestBridge.Capabilities.IVSTestFlattenedTestNodesReportCapability.IsSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Microsoft.Testing.Extensions.TrxReport.Abstractions.ITrxReportCapability.IsSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrxEnabled>k__BackingField;
    private bool Microsoft.Testing.Extensions.VSTestBridge.Capabilities.IVSTestFlattenedTestNodesReportCapability.IsSupported { get; }
    private bool Microsoft.Testing.Extensions.TrxReport.Abstractions.ITrxReportCapability.IsSupported { get; }
    public bool IsTrxEnabled { get; private set; }
    [CompilerGeneratedAttribute]
private sealed virtual override bool Microsoft.Testing.Extensions.VSTestBridge.Capabilities.IVSTestFlattenedTestNodesReportCapability.get_IsSupported();
    [CompilerGeneratedAttribute]
private sealed virtual override bool Microsoft.Testing.Extensions.TrxReport.Abstractions.ITrxReportCapability.get_IsSupported();
    [CompilerGeneratedAttribute]
public bool get_IsTrxEnabled();
    [CompilerGeneratedAttribute]
private void set_IsTrxEnabled(bool value);
    private sealed virtual override void Microsoft.Testing.Extensions.TrxReport.Abstractions.ITrxReportCapability.Enable();
    [NullableContextAttribute("1")]
private sealed virtual override bool Microsoft.Testing.Platform.Capabilities.TestFramework.INamedFeatureCapability.IsSupported(string featureName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.CommandLine.RunSettingsCommandLineOptionsProvider : object {
    public static string RunSettingsOptionName;
    private IFileSystem _fileSystem;
    [CompilerGeneratedAttribute]
private string <Uid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Uid { get; }
    public string Version { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public RunSettingsCommandLineOptionsProvider(IExtension extension);
    internal RunSettingsCommandLineOptionsProvider(IExtension extension, IFileSystem fileSystem);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Uid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    public sealed virtual Task`1<bool> IsEnabledAsync();
    public sealed virtual IReadOnlyCollection`1<CommandLineOption> GetCommandLineOptions();
    public sealed virtual Task`1<ValidationResult> ValidateOptionArgumentsAsync(CommandLineOption commandOption, String[] arguments);
    public sealed virtual Task`1<ValidationResult> ValidateCommandLineOptionsAsync(ICommandLineOptions commandLineOptions);
    private bool CanReadFile(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.CommandLine.TestCaseFilterCommandLineOptionsProvider : object {
    public static string TestCaseFilterOptionName;
    [CompilerGeneratedAttribute]
private string <Uid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Uid { get; }
    public string Version { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public TestCaseFilterCommandLineOptionsProvider(IExtension extension);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Uid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    public sealed virtual Task`1<bool> IsEnabledAsync();
    public sealed virtual IReadOnlyCollection`1<CommandLineOption> GetCommandLineOptions();
    public sealed virtual Task`1<ValidationResult> ValidateOptionArgumentsAsync(CommandLineOption commandOption, String[] arguments);
    public sealed virtual Task`1<ValidationResult> ValidateCommandLineOptionsAsync(ICommandLineOptions commandLineOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.CommandLine.TestRunParametersCommandLineOptionsProvider : object {
    public static string TestRunParameterOptionName;
    [CompilerGeneratedAttribute]
private string <Uid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Uid { get; }
    public string Version { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public TestRunParametersCommandLineOptionsProvider(IExtension extension);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Uid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    public sealed virtual Task`1<bool> IsEnabledAsync();
    public sealed virtual IReadOnlyCollection`1<CommandLineOption> GetCommandLineOptions();
    public sealed virtual Task`1<ValidationResult> ValidateCommandLineOptionsAsync(ICommandLineOptions commandLineOptions);
    public sealed virtual Task`1<ValidationResult> ValidateOptionArgumentsAsync(CommandLineOption commandOption, String[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.Configurations.RunSettingsConfigurationProvider : object {
    private string _runsettings;
    [CompilerGeneratedAttribute]
private string <Uid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Uid { get; }
    public string Version { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public RunSettingsConfigurationProvider(string runSettings);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Uid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    public sealed virtual Task`1<bool> IsEnabledAsync();
    public sealed virtual Task LoadAsync();
    public sealed virtual bool TryGet(string key, String& value);
    public sealed virtual IConfigurationProvider Build();
}
internal static class Microsoft.Testing.Extensions.VSTestBridge.Constants : object {
    [NullableAttribute("1")]
public static string ExecutorUri;
}
internal static class Microsoft.Testing.Extensions.VSTestBridge.Helpers.DebugUtils : object {
    [NullableAttribute("1")]
private static string VSTestBridgeAttachDebuggerEnvVar;
    public static void LaunchAttachDebugger();
}
[ExtensionAttribute]
internal static class Microsoft.Testing.Extensions.VSTestBridge.Helpers.SynchronousAwaiter : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Await(Task valueTask, bool busyWait);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Testing.Extensions.VSTestBridge.Helpers.TestApplicationBuilderExtensions : object {
    [ExtensionAttribute]
public static void AddTestCaseFilterService(ITestApplicationBuilder builder, IExtension extension);
    [ExtensionAttribute]
public static void AddRunSettingsService(ITestApplicationBuilder builder, IExtension extension);
    [ExtensionAttribute]
public static void AddTestRunParametersService(ITestApplicationBuilder builder, IExtension extension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.Condition : object {
    public static string DefaultPropertyName;
    public static Operation DefaultOperation;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Operation <Operation>k__BackingField;
    internal string Name { get; }
    internal string Value { get; }
    internal Operation Operation { get; }
    internal Condition(string name, Operation operation, string value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal string get_Value();
    [CompilerGeneratedAttribute]
internal Operation get_Operation();
    internal bool Evaluate(Func`2<string, object> propertyValueProvider);
    internal static Condition Parse(string conditionString);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
private static void ThrownFormatExceptionForInvalidCondition(string conditionString);
    internal bool ValidForProperties(IEnumerable`1<string> properties, Func`2<string, TestProperty> propertyProvider);
    private bool ValidForContainsOperation(Func`2<string, TestProperty> propertyProvider);
    private static Operation GetOperator(string operationString);
    private String[] GetPropertyValue(Func`2<string, object> propertyValueProvider);
    internal static IEnumerable`1<string> TokenizeFilterConditionString(string str);
    [IteratorStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.Condition/<<TokenizeFilterConditionString>g__TokenizeFilterConditionStringWorker|19_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TokenizeFilterConditionString>g__TokenizeFilterConditionStringWorker|19_0(string s);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.ContextAdapterBase : object {
    [CompilerGeneratedAttribute]
private FilterExpressionWrapper <FilterExpressionWrapper>k__BackingField;
    protected FilterExpressionWrapper FilterExpressionWrapper { get; protected set; }
    [NullableContextAttribute("1")]
public ContextAdapterBase(ICommandLineOptions commandLineOptions);
    [CompilerGeneratedAttribute]
protected FilterExpressionWrapper get_FilterExpressionWrapper();
    [CompilerGeneratedAttribute]
protected void set_FilterExpressionWrapper(FilterExpressionWrapper value);
    public sealed virtual ITestCaseFilterExpression GetTestCaseFilter(IEnumerable`1<string> supportedProperties, Func`2<string, TestProperty> propertyProvider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.DiscoveryContextAdapter : ContextAdapterBase {
    [CompilerGeneratedAttribute]
private IRunSettings <RunSettings>k__BackingField;
    public IRunSettings RunSettings { get; }
    [NullableContextAttribute("1")]
public DiscoveryContextAdapter(ICommandLineOptions commandLineOptions, IRunSettings runSettings);
    [CompilerGeneratedAttribute]
public sealed virtual IRunSettings get_RunSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FastFilter : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ISet`1<string>> <FilterProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilteredOutWhenMatched>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Regex <PropertyValueRegex>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PropertyValueRegexReplacement>k__BackingField;
    internal ImmutableDictionary`2<string, ISet`1<string>> FilterProperties { get; }
    internal bool IsFilteredOutWhenMatched { get; }
    [NullableAttribute("2")]
internal Regex PropertyValueRegex { get; internal set; }
    [NullableAttribute("2")]
internal string PropertyValueRegexReplacement { get; internal set; }
    internal FastFilter(ImmutableDictionary`2<string, ISet`1<string>> filterProperties, Operation filterOperation, Operator filterOperator);
    [CompilerGeneratedAttribute]
internal ImmutableDictionary`2<string, ISet`1<string>> get_FilterProperties();
    [CompilerGeneratedAttribute]
internal bool get_IsFilteredOutWhenMatched();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Regex get_PropertyValueRegex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_PropertyValueRegex(Regex value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_PropertyValueRegexReplacement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_PropertyValueRegexReplacement(string value);
    internal String[] ValidForProperties(IEnumerable`1<string> properties);
    internal bool Evaluate(Func`2<string, object> propertyValueProvider);
    private string ApplyRegex(string value);
    private static bool TryGetPropertyValue(string name, Func`2<string, object> propertyValueProvider, String& singleValue, String[]& multiValues);
    internal static Builder CreateBuilder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FilterExpression : object {
    private static string TestCaseFilterFormatException;
    [NullableAttribute("2")]
private Condition _condition;
    [NullableAttribute("2")]
private FilterExpression _left;
    [NullableAttribute("2")]
private FilterExpression _right;
    private bool _areJoinedByAnd;
    private FilterExpression(FilterExpression left, FilterExpression right, bool areJoinedByAnd);
    private FilterExpression(Condition condition);
    private FilterExpression And(FilterExpression filter);
    private FilterExpression Or(FilterExpression filter);
    private static void ProcessOperator(Stack`1<FilterExpression> filterStack, Operator op);
    internal String[] ValidForProperties(IEnumerable`1<string> properties, Func`2<string, TestProperty> propertyProvider);
    internal static FilterExpression Parse(string filterString, FastFilter& fastFilter);
    private T IterateFilterExpression(Func`3<FilterExpression, Stack`1<T>, T> getNodeValue);
    internal bool Evaluate(Func`2<string, object> propertyValueProvider);
    internal static IEnumerable`1<string> TokenizeFilterExpressionString(string str);
    [GeneratedRegexAttribute("\(\s*\)")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
private static Regex GetEmptyParenthesisPattern();
    [IteratorStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FilterExpression/<<TokenizeFilterExpressionString>g__TokenizeFilterExpressionStringHelper|14_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TokenizeFilterExpressionString>g__TokenizeFilterExpressionStringHelper|14_0(string s);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FilterExpressionWrapper : object {
    private FilterExpression _filterExpression;
    internal FastFilter _fastFilter;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FilterString>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterOptions <FilterOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParseError>k__BackingField;
    [MemberNotNullWhenAttribute("True", "_fastFilter")]
private bool UseFastFilter { get; }
    [NullableAttribute("1")]
public string FilterString { get; }
    public FilterOptions FilterOptions { get; }
    public string ParseError { get; }
    [NullableContextAttribute("1")]
public FilterExpressionWrapper(string filterString, FilterOptions options);
    [NullableContextAttribute("1")]
public FilterExpressionWrapper(string filterString);
    [MemberNotNullWhenAttribute("True", "_fastFilter")]
private bool get_UseFastFilter();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FilterString();
    [CompilerGeneratedAttribute]
public FilterOptions get_FilterOptions();
    [CompilerGeneratedAttribute]
public string get_ParseError();
    public String[] ValidForProperties(IEnumerable`1<string> supportedProperties, Func`2<string, TestProperty> propertyProvider);
    public bool Evaluate(Func`2<string, object> propertyValueProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FrameworkHandlerAdapter : object {
    [NullableAttribute("2")]
private IFrameworkHandle _frameworkHandle;
    private ILogger`1<FrameworkHandlerAdapter> _logger;
    private IMessageBus _messageBus;
    private VSTestBridgedTestFrameworkBase _adapterExtensionBase;
    private TestSessionContext _session;
    private IClientInfo _clientInfo;
    private CancellationToken _cancellationToken;
    private bool _isTrxEnabled;
    private MessageLoggerAdapter _comboMessageLogger;
    private string _testAssemblyPath;
    public bool EnableShutdownAfterTestRun { get; public set; }
    public FrameworkHandlerAdapter(VSTestBridgedTestFrameworkBase adapterExtensionBase, TestSessionContext session, IClientInfo clientInfo, String[] testAssemblyPaths, ITestApplicationModuleInfo testApplicationModuleInfo, ILoggerFactory loggerFactory, IMessageBus messageBus, IOutputDevice outputDevice, bool isTrxEnabled, CancellationToken cancellationToken, IFrameworkHandle frameworkHandle);
    public sealed virtual bool get_EnableShutdownAfterTestRun();
    public sealed virtual void set_EnableShutdownAfterTestRun(bool value);
    [NullableContextAttribute("2")]
public sealed virtual int LaunchProcessWithDebuggerAttached(string filePath, string workingDirectory, string arguments, IDictionary`2<string, string> environmentVariables);
    public sealed virtual void RecordAttachments(IList`1<AttachmentSet> attachmentSets);
    public sealed virtual void RecordEnd(TestCase testCase, TestOutcome outcome);
    public sealed virtual void RecordResult(TestResult testResult);
    public sealed virtual void RecordStart(TestCase testCase);
    public sealed virtual void SendMessage(TestMessageLevel testMessageLevel, string message);
    [AsyncStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.FrameworkHandlerAdapter/<PublishAttachmentsAsync>d__20")]
private Task PublishAttachmentsAsync(IEnumerable`1<AttachmentSet> attachments, TestNode testNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.MessageLoggerAdapter : object {
    [NullableAttribute("2")]
private IMessageLogger _messageLogger;
    private ILogger`1<MessageLoggerAdapter> _logger;
    private IOutputDevice _outputDevice;
    private IExtension _extension;
    private string Microsoft.Testing.Platform.Extensions.IExtension.Uid { get; }
    private string Microsoft.Testing.Platform.Extensions.IExtension.Version { get; }
    private string Microsoft.Testing.Platform.Extensions.IExtension.DisplayName { get; }
    private string Microsoft.Testing.Platform.Extensions.IExtension.Description { get; }
    public MessageLoggerAdapter(ILoggerFactory loggerFactory, IOutputDevice outputDevice, IExtension extension, IMessageLogger messageLogger);
    private sealed virtual override string Microsoft.Testing.Platform.Extensions.IExtension.get_Uid();
    private sealed virtual override string Microsoft.Testing.Platform.Extensions.IExtension.get_Version();
    private sealed virtual override string Microsoft.Testing.Platform.Extensions.IExtension.get_DisplayName();
    private sealed virtual override string Microsoft.Testing.Platform.Extensions.IExtension.get_Description();
    public sealed virtual void SendMessage(TestMessageLevel testMessageLevel, string message);
    private sealed virtual override Task`1<bool> Microsoft.Testing.Platform.Extensions.IExtension.IsEnabledAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.ObjectModelConverters : object {
    private static TestProperty OriginalExecutorUriProperty;
    private static ObjectModelConverters();
    [ExtensionAttribute]
public static TestNode ToTestNode(TestCase testCase, bool isTrxEnabled, IClientInfo client);
    private static void CopyVSTestProperties(IEnumerable`1<TestProperty> testProperties, TestNode testNode, TestCase testCase, Func`2<TestProperty, object> getPropertyValue, bool isTrxEnabled, IClientInfo client);
    [ExtensionAttribute]
public static TestNode ToTestNode(TestResult testResult, bool isTrxEnabled, IClientInfo client);
    [ExtensionAttribute]
private static void AddOutcome(TestNode testNode, TestResult testResult);
    [ExtensionAttribute]
internal static void FixUpTestCase(TestCase testCase, string testAssemblyPath);
    private static bool TryParseFullyQualifiedType(string fullyQualifiedName, String& fullyQualifiedType);
}
internal enum Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.Operation : Enum {
    public int value__;
    public static Operation Equal;
    public static Operation NotEqual;
    public static Operation Contains;
    public static Operation NotContains;
}
internal enum Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.Operator : Enum {
    public int value__;
    public static Operator None;
    public static Operator Or;
    public static Operator And;
    public static Operator OpenBrace;
    public static Operator CloseBrace;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.RunContextAdapter : ContextAdapterBase {
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InIsolation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDataCollectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestRunDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRunSettings <RunSettings>k__BackingField;
    public bool KeepAlive { get; }
    public bool InIsolation { get; }
    public bool IsDataCollectionEnabled { get; }
    public bool IsBeingDebugged { get; }
    public string TestRunDirectory { get; }
    public string SolutionDirectory { get; }
    public IRunSettings RunSettings { get; }
    [NullableContextAttribute("1")]
public RunContextAdapter(ICommandLineOptions commandLineOptions, IRunSettings runSettings);
    [NullableContextAttribute("1")]
public RunContextAdapter(ICommandLineOptions commandLineOptions, IRunSettings runSettings, TestNodeUid[] testNodeUids);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_KeepAlive();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InIsolation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDataCollectionEnabled();
    public sealed virtual bool get_IsBeingDebugged();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TestRunDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SolutionDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual IRunSettings get_RunSettings();
    [NullableContextAttribute("1")]
private static string CreateFilter(TestNodeUid[] testNodesUid);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.RunSettingsAdapter : object {
    [CompilerGeneratedAttribute]
private string <SettingsXml>k__BackingField;
    public string SettingsXml { get; }
    [NullableContextAttribute("1")]
public RunSettingsAdapter(ICommandLineOptions commandLineOptions, IFileSystem fileSystem, IConfiguration configuration, IClientInfo client, ILoggerFactory loggerFactory, IMessageLogger messageLogger);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SettingsXml();
    public sealed virtual ISettingsProvider GetSettings(string settingsName);
    [NullableContextAttribute("1")]
private static void WarnOnUnsupportedEntries(XDocument document, IMessageLogger messageLogger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.RunSettingsPatcher : object {
    private static Char[] TestRunParameterSeparator;
    private static RunSettingsPatcher();
    public static XDocument Patch(string runSettingsXml, IConfiguration configuration, IClientInfo client, ICommandLineOptions commandLineOptions);
    private static XDocument PatchSettingsWithDefaults(string runSettingsXml, bool isDesignMode, IConfiguration configuration);
    private static void AddPatchingCommentIfNeeded(XElement element, Boolean& isPatchingCommentAdded);
    private static void PatchTestRunParameters(XDocument runSettingsDocument, ICommandLineOptions commandLineOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.TestCaseDiscoverySinkAdapter : object {
    [NullableAttribute("2")]
private ITestCaseDiscoverySink _testCaseDiscoverySink;
    private ILogger`1<TestCaseDiscoverySinkAdapter> _logger;
    private IMessageBus _messageBus;
    private bool _isTrxEnabled;
    private IClientInfo _clientInfo;
    private VSTestBridgedTestFrameworkBase _adapterExtension;
    private TestSessionContext _session;
    private CancellationToken _cancellationToken;
    [NullableAttribute("2")]
private string _testAssemblyPath;
    public TestCaseDiscoverySinkAdapter(VSTestBridgedTestFrameworkBase adapterExtension, TestSessionContext session, String[] testAssemblyPaths, ITestApplicationModuleInfo testApplicationModuleInfo, ILoggerFactory loggerFactory, IMessageBus messageBus, bool isTrxEnabled, IClientInfo clientInfo, CancellationToken cancellationToken, ITestCaseDiscoverySink testCaseDiscoverySink);
    public sealed virtual void SendTestCase(TestCase discoveredTest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.TestCaseFilterExpression : object {
    private FilterExpressionWrapper _filterWrapper;
    private bool _validForMatch;
    public string TestCaseFilterValue { get; }
    public TestCaseFilterExpression(FilterExpressionWrapper filterWrapper);
    public sealed virtual string get_TestCaseFilterValue();
    public String[] ValidForProperties(IEnumerable`1<string> supportedProperties, Func`2<string, TestProperty> propertyProvider);
    public sealed virtual bool MatchTestCase(TestCase testCase, Func`2<string, object> propertyValueProvider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.VSTestException : Exception {
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    public string StackTrace { get; }
    public VSTestException(string message, string stackTrace);
    [CompilerGeneratedAttribute]
public virtual string get_StackTrace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Testing.Extensions.VSTestBridge.ObjectModel.VSTestProperty : object {
    [CompilerGeneratedAttribute]
private TestProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private TestCase <TestCase>k__BackingField;
    public TestProperty Property { get; }
    public TestCase TestCase { get; }
    public VSTestProperty(TestProperty property, TestCase testCase);
    [CompilerGeneratedAttribute]
public TestProperty get_Property();
    [CompilerGeneratedAttribute]
public TestCase get_TestCase();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Testing.Extensions.VSTestBridge.Requests.VSTestDiscoverTestExecutionRequest : DiscoverTestExecutionRequest {
    [CompilerGeneratedAttribute]
private String[] <AssemblyPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiscoveryContext <DiscoveryContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageLogger <MessageLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private ITestCaseDiscoverySink <DiscoverySink>k__BackingField;
    public VSTestTestExecutionFilter VSTestFilter { get; }
    public String[] AssemblyPaths { get; }
    public IDiscoveryContext DiscoveryContext { get; }
    public IMessageLogger MessageLogger { get; }
    public ITestCaseDiscoverySink DiscoverySink { get; }
    internal VSTestDiscoverTestExecutionRequest(TestSessionContext session, VSTestTestExecutionFilter executionFilter, String[] assemblyPaths, IDiscoveryContext discoveryContext, IMessageLogger messageLogger, ITestCaseDiscoverySink discoverySink);
    public VSTestTestExecutionFilter get_VSTestFilter();
    [CompilerGeneratedAttribute]
public String[] get_AssemblyPaths();
    [CompilerGeneratedAttribute]
public IDiscoveryContext get_DiscoveryContext();
    [CompilerGeneratedAttribute]
public IMessageLogger get_MessageLogger();
    [CompilerGeneratedAttribute]
public ITestCaseDiscoverySink get_DiscoverySink();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Testing.Extensions.VSTestBridge.Requests.VSTestDiscoverTestExecutionRequestFactory : object {
    private ITestFrameworkCapabilities _testFrameworkCapabilities;
    private ITestFramework _testFrameworkAdapter;
    private ICommandLineOptions _commandLineService;
    private String[] _assemblyPaths;
    private VSTestTestExecutionFilter _testExecutionFilter;
    private IDiscoveryContext _discoveryContext;
    private IMessageLogger _messageLogger;
    private ITestCaseDiscoverySink _discoverySink;
    internal VSTestDiscoverTestExecutionRequestFactory(ITestFrameworkCapabilities testFrameworkCapabilities, ITestFramework testFrameworkAdapter, ICommandLineOptions commandLineService, String[] assemblyPaths, VSTestTestExecutionFilter testExecutionFilter, IDiscoveryContext discoveryContext, IMessageLogger messageLogger, ITestCaseDiscoverySink discoverySink);
    private sealed virtual override Task`1<TestExecutionRequest> Microsoft.Testing.Platform.Requests.ITestExecutionRequestFactory.CreateRequestAsync(TestSessionContext session);
    public static VSTestDiscoverTestExecutionRequest CreateRequest(DiscoverTestExecutionRequest discoverTestExecutionRequest, VSTestBridgedTestFrameworkBase adapterExtension, String[] testAssemblyPaths, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Testing.Extensions.VSTestBridge.Requests.VSTestRunTestExecutionRequest : RunTestExecutionRequest {
    [CompilerGeneratedAttribute]
private String[] <AssemblyPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IRunContext <RunContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkHandle <FrameworkHandle>k__BackingField;
    public VSTestTestExecutionFilter VSTestFilter { get; }
    public String[] AssemblyPaths { get; }
    public IRunContext RunContext { get; }
    public IFrameworkHandle FrameworkHandle { get; }
    public VSTestRunTestExecutionRequest(TestSessionContext session, VSTestTestExecutionFilter executionFilter, String[] assemblyPaths, IRunContext runContext, IFrameworkHandle frameworkHandle);
    public VSTestTestExecutionFilter get_VSTestFilter();
    [CompilerGeneratedAttribute]
public String[] get_AssemblyPaths();
    [CompilerGeneratedAttribute]
public IRunContext get_RunContext();
    [CompilerGeneratedAttribute]
public IFrameworkHandle get_FrameworkHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Testing.Extensions.VSTestBridge.Requests.VSTestRunTestExecutionRequestFactory : object {
    private ITestFrameworkCapabilities _testFrameworkCapabilities;
    private ITestFramework _testFrameworkAdapter;
    private ICommandLineOptions _commandLineService;
    private String[] _assemblyPaths;
    private VSTestTestExecutionFilter _testExecutionFilter;
    private IRunContext _runContext;
    private IFrameworkHandle _frameworkHandle;
    internal VSTestRunTestExecutionRequestFactory(ITestFrameworkCapabilities testFrameworkCapabilities, ITestFramework testFrameworkAdapter, ICommandLineOptions commandLineService, String[] assemblyPaths, VSTestTestExecutionFilter testExecutionFilter, IRunContext runContext, IFrameworkHandle frameworkHandle);
    private sealed virtual override Task`1<TestExecutionRequest> Microsoft.Testing.Platform.Requests.ITestExecutionRequestFactory.CreateRequestAsync(TestSessionContext session);
    public static VSTestRunTestExecutionRequest CreateRequest(RunTestExecutionRequest runTestExecutionRequest, VSTestBridgedTestFrameworkBase adapterExtension, String[] testAssemblyPaths, CancellationToken cancellationToken);
}
public class Microsoft.Testing.Extensions.VSTestBridge.Requests.VSTestTestExecutionFilter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ImmutableArray`1<TestCase>> <TestCases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ImmutableArray`1<TestCase>> TestCases { get; }
    internal VSTestTestExecutionFilter(ImmutableArray`1<TestCase> testCases);
    [CompilerGeneratedAttribute]
public Nullable`1<ImmutableArray`1<TestCase>> get_TestCases();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Testing.Extensions.VSTestBridge.Resources.ExtensionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MissingRunSettingsAttribute { get; }
    internal static string RunsettingsFileCannotBeRead { get; }
    internal static string RunsettingsFileDoesNotExist { get; }
    internal static string RunSettingsOptionDescription { get; }
    internal static string TestCaseFilterOptionDescription { get; }
    internal static string TestRunParameterOptionArgumentIsNotParameter { get; }
    internal static string TestRunParameterOptionDescription { get; }
    internal static string UnsupportedRunconfigurationSetting { get; }
    internal static string UnsupportedRunsettingsDatacollectors { get; }
    internal static string UnsupportedRunsettingsLoggers { get; }
    internal static string VSTestBridgedTestFrameworkSessionAlreadyCreatedErrorMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MissingRunSettingsAttribute();
    internal static string get_RunsettingsFileCannotBeRead();
    internal static string get_RunsettingsFileDoesNotExist();
    internal static string get_RunSettingsOptionDescription();
    internal static string get_TestCaseFilterOptionDescription();
    internal static string get_TestRunParameterOptionArgumentIsNotParameter();
    internal static string get_TestRunParameterOptionDescription();
    internal static string get_UnsupportedRunconfigurationSetting();
    internal static string get_UnsupportedRunsettingsDatacollectors();
    internal static string get_UnsupportedRunsettingsLoggers();
    internal static string get_VSTestBridgedTestFrameworkSessionAlreadyCreatedErrorMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Testing.Extensions.VSTestBridge.SynchronizedSingleSessionVSTestBridgedTestFramework : VSTestBridgedTestFrameworkBase {
    private IExtension _extension;
    private Func`1<IEnumerable`1<Assembly>> _getTestAssemblies;
    private CountdownEvent _incomingRequestCounter;
    private bool _isDisposed;
    private Nullable`1<SessionUid> _sessionUid;
    public string Uid { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public string Version { get; }
    protected SynchronizedSingleSessionVSTestBridgedTestFramework(IExtension extension, Func`1<IEnumerable`1<Assembly>> getTestAssemblies, IServiceProvider serviceProvider, ITestFrameworkCapabilities capabilities);
    public sealed virtual string get_Uid();
    public sealed virtual string get_DisplayName();
    public sealed virtual string get_Description();
    public sealed virtual string get_Version();
    [AsyncStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.SynchronizedSingleSessionVSTestBridgedTestFramework/<IsEnabledAsync>d__14")]
public virtual Task`1<bool> IsEnabledAsync();
    public sealed virtual Task`1<CreateTestSessionResult> CreateTestSessionAsync(CreateTestSessionContext context);
    [AsyncStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.SynchronizedSingleSessionVSTestBridgedTestFramework/<CloseTestSessionAsync>d__16")]
public sealed virtual Task`1<CloseTestSessionResult> CloseTestSessionAsync(CloseTestSessionContext context);
    protected virtual void Dispose(bool disposing);
    protected sealed virtual Task DiscoverTestsAsync(VSTestDiscoverTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected abstract virtual Task SynchronizedDiscoverTestsAsync(VSTestDiscoverTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected sealed virtual Task RunTestsAsync(VSTestRunTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected abstract virtual Task SynchronizedRunTestsAsync(VSTestRunTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected sealed virtual Task ExecuteRequestAsync(TestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.SynchronizedSingleSessionVSTestBridgedTestFramework/<ExecuteRequestWithRequestCountGuardAsync>d__24")]
private Task ExecuteRequestWithRequestCountGuardAsync(Func`1<Task> asyncFunc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Testing.Extensions.VSTestBridge.VSTestBridgedTestFrameworkBase : object {
    [CompilerGeneratedAttribute]
private Type[] <DataTypesProduced>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrxEnabled>k__BackingField;
    public string Uid { get; }
    public string Version { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public Type[] DataTypesProduced { get; }
    protected internal IServiceProvider ServiceProvider { get; }
    protected internal bool IsTrxEnabled { get; }
    protected VSTestBridgedTestFrameworkBase(IServiceProvider serviceProvider, ITestFrameworkCapabilities capabilities);
    public abstract virtual string get_Uid();
    public abstract virtual string get_Version();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_DataTypesProduced();
    [CompilerGeneratedAttribute]
protected internal IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
protected internal bool get_IsTrxEnabled();
    public abstract virtual Task`1<bool> IsEnabledAsync();
    [AsyncStateMachineAttribute("Microsoft.Testing.Extensions.VSTestBridge.VSTestBridgedTestFrameworkBase/<ExecuteRequestAsync>d__19")]
public sealed virtual Task ExecuteRequestAsync(ExecuteRequestContext context);
    public abstract virtual Task`1<CreateTestSessionResult> CreateTestSessionAsync(CreateTestSessionContext context);
    public abstract virtual Task`1<CloseTestSessionResult> CloseTestSessionAsync(CloseTestSessionContext context);
    protected abstract virtual Task ExecuteRequestAsync(TestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected abstract virtual Task DiscoverTestsAsync(VSTestDiscoverTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    protected abstract virtual Task RunTestsAsync(VSTestRunTestExecutionRequest request, IMessageBus messageBus, CancellationToken cancellationToken);
    private VSTestDiscoverTestExecutionRequest UpdateDiscoverRequest(VSTestDiscoverTestExecutionRequest discoverRequest, IMessageBus messageBus, CancellationToken cancellationToken);
    private VSTestRunTestExecutionRequest UpdateRunRequest(VSTestRunTestExecutionRequest runRequest, IMessageBus messageBus, CancellationToken cancellationToken);
}
internal static class Microsoft.Testing.Extensions.VSTestBridge.VSTestTestNodeProperties : object {
    [NullableAttribute("1")]
internal static string Prefix;
    [NullableAttribute("1")]
public static string OriginalExecutorUriPropertyName;
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F89651DCCDBEA905C5F203FA8C3C3159ECD1757E3ACED45DFB8DEFFEDB3B5A842__GetEmptyParenthesisPattern_0 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F89651DCCDBEA905C5F203FA8C3C3159ECD1757E3ACED45DFB8DEFFEDB3B5A842__GetEmptyParenthesisPattern_0 Instance;
    private static <RegexGenerator_g>F89651DCCDBEA905C5F203FA8C3C3159ECD1757E3ACED45DFB8DEFFEDB3B5A842__GetEmptyParenthesisPattern_0();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.31311")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F89651DCCDBEA905C5F203FA8C3C3159ECD1757E3ACED45DFB8DEFFEDB3B5A842__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    private static <RegexGenerator_g>F89651DCCDBEA905C5F203FA8C3C3159ECD1757E3ACED45DFB8DEFFEDB3B5A842__Utilities();
}
