[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeCoverage.Core.ConsoleOutputPathGenerator : object {
    [NullableContextAttribute("1")]
public sealed virtual string GenerateOutputPath(string requestedOutputPath, string defaultExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Constants : object {
    public static ushort CurrentCodeCoverageSchemaVersion;
    public static UInt32 CodeCoverageFileHeaderMagic;
    public static UInt32 CodeCoverageStreamHeaderMagic;
    public static string GlobalCacheId;
    public static string GlobalMutexPrefixId;
    [CompilerGeneratedAttribute]
private static Guid <ModulesSkippedStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <ModuleDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <CoverageDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <PerSnapshotCoverageDataStreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Guid <SnapshotTagsDataStreamType>k__BackingField;
    public static string CoverageFileExtension;
    public static string CoverageFileBackupExtension;
    public static string ModuleCoverageFileExtension;
    public static string ModuleCoverageFileBackupExtension;
    public static string ModuleBufferFileExtension;
    public static string CoverageXmlFileExtension;
    public static string CoberturaFileExtension;
    public static string XmlFileExtension;
    public static string ExeFileExtension;
    public static string DefaultGeneratorName;
    public static string CoberturaGeneratorName;
    public static string CoverageGeneratorName;
    public static string VanguardX86ProfilerConfigVariable;
    public static string VanguardX64ProfilerConfigVariable;
    public static string VanguardARM64ProfilerConfigVariable;
    public static string CoreclrProfilerPathVariable32;
    public static string CoreclrProfilerPathVariable64;
    public static string CoreclrProfilerPathVariableARM64;
    public static string CoreclrEnableProfilingVariable;
    public static string CoreclrProfilerVariable;
    public static string CorProfilerPathVariable;
    public static string CorProfilerPathVariable32;
    public static string CorProfilerPathVariable64;
    public static string CorProfilerPathVariableARM64;
    public static string CorEnableProfilingVariable;
    public static string CorProfilerVariable;
    public static string VanguardInstrumentationMethodGuid;
    public static string ClrInstrumentationEngineProfilerGuid;
    public static string CodeCoverageSessionNameVariable;
    public static string CodeCoveragePipePathVariable;
    public static string VanguardSkipEngineInitializationVariable;
    public static string CodeCoveragePipeCountVariable;
    public static string PathEnvironmentVariable;
    public static string ClrIeLogLevelVariable;
    public static string ClrIeDisableCodeSignatureValidationVariable;
    public static string ClrieFileLogPathVariable;
    public static string DefaultOutputWithoutExtensions;
    public static string DefaultOutput;
    public static string LogLevelError;
    public static string LogLevelInfo;
    public static string LogLevelVerbose;
    public static string CoberturaConditionTypeSwitch;
    public static string CoberturaConditionTypeJump;
    public static int MaxTaskCount;
    internal static int MaxNumberOfServerInstances;
    public static int DefaultTimeout;
    public static int MaxFilePathLength;
    public static string CodeCoverageFeatureFlag;
    public static string VANGUARD_DOTNETCOVERAGECONSOLE_DEBUG;
    public static string VANGUARD_CODECOVERAGECONSOLE_DEBUG;
    public static string VANGUARD_DATACOLLECTOR_DEBUG;
    public static Guid ModulesSkippedStreamType { get; }
    public static Guid ModuleDataStreamType { get; }
    public static Guid CoverageDataStreamType { get; }
    public static Guid PerSnapshotCoverageDataStreamType { get; }
    public static Guid SnapshotTagsDataStreamType { get; }
    private static Constants();
    [CompilerGeneratedAttribute]
public static Guid get_ModulesSkippedStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_ModuleDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_CoverageDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_PerSnapshotCoverageDataStreamType();
    [CompilerGeneratedAttribute]
public static Guid get_SnapshotTagsDataStreamType();
}
public enum Microsoft.CodeCoverage.Core.CoverageMergeOperation : Enum {
    public int value__;
    public static CoverageMergeOperation MergeSimilarFormats;
    public static CoverageMergeOperation MergeToCoverage;
    public static CoverageMergeOperation MergeToXml;
    public static CoverageMergeOperation MergeToCobertura;
}
public enum Microsoft.CodeCoverage.Core.CoverageReportType : Enum {
    public int value__;
    public static CoverageReportType Coverage;
    public static CoverageReportType Xml;
    public static CoverageReportType Cobertura;
    public static CoverageReportType CoverageV2;
}
public enum Microsoft.CodeCoverage.Core.CoverageStatus : Enum {
    public int value__;
    public static CoverageStatus yes;
    public static CoverageStatus partial;
    public static CoverageStatus no;
}
public enum Microsoft.CodeCoverage.Core.FunctionSkipReason : Enum {
    public int value__;
    public static FunctionSkipReason too_small;
    public static FunctionSkipReason too_large;
    public static FunctionSkipReason source_excluded;
    public static FunctionSkipReason name_excluded;
    public static FunctionSkipReason excluded_inline;
    public static FunctionSkipReason has_external_branch;
    public static FunctionSkipReason is_duplicate;
    public static FunctionSkipReason attribute_excluded;
    public static FunctionSkipReason no_line_information;
    public static FunctionSkipReason instrumentation_failure;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.Helpers : object {
    public static CoverageMergeOperation ToCoverageMergeOperation(CoverageReportType coverageReportType);
    public static string GetGlobalCachePath(string cachePath);
    public static string GetCachePath(string cachePath, string correlationId);
    public static string GetMutexName(string correlationId, string hash);
    public static string GetMutexName(string hash);
    public static IList`1<ValueTuple`3<string, CoverageReportType, object>> GetCoverageReports(IList`1<string> inputFiles, bool skipInvalidFiles, CancellationToken token);
    public static ValueTuple`2<CoverageReportType, object> GetCoverageReport(string path, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoverageReportsAsync>d__9")]
public static Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputPath, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoverageReportsAsync>d__10")]
public static Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoverageFilesAsync>d__11`1")]
public static Task`1<T> MergeCoverageFilesAsync(Queue`1<ValueTuple`2<string, T>> queue, GetCoverageFile`1<T> getCoverageFile, MergeCoverageFiles`1<T> mergeCoverageFiles, CancellationToken token, bool skipInvalidFiles, int taskCount);
    public static Byte[] ToBytesArray(string value);
    public static string CalculateStringSha256(string input);
    public static string ConvertToString(Byte[] hashBytes);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoverageFilesAsync>d__15`1")]
private static Task MergeCoverageFilesAsync(Queue`1<ValueTuple`2<string, T>> queue, GetCoverageFile`1<T> getCoverageFile, MergeCoverageFiles`1<T> mergeCoverageFiles, bool skipInvalidFiles, object lockObject, CancellationToken token);
    private static bool PrepareMergeTaskInput(Queue`1<ValueTuple`2<string, T>> queue, object lockObject, ValueTuple`2& input1, ValueTuple`2& input2);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeSimilarFormatsAsync>d__17")]
private static Task`1<IList`1<string>> MergeSimilarFormatsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, bool skipInvalidFiles, int taskCount, CancellationToken token);
    private static string RemoveFileExtension(string outputPath, string extension);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeReportsAsync>d__19")]
private static Task`1<string> MergeReportsAsync(string outputPath, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    private static string GenerateOutputPath(string coverageFilePath, CoverageMergeOperation mergeOperation);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoberturaAsync>d__21")]
private static Task`1<CoberturaFile> MergeCoberturaAsync(IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Core.Helpers/<MergeCoverageAsync>d__22")]
private static Task`1<CoverageData> MergeCoverageAsync(IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, bool skipInvalidFiles, int taskCount, CancellationToken token, bool loadAllModuleData);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.Core.ILogger {
    public abstract virtual void LogWarning(string message);
    public abstract virtual void LogError(string message);
    public abstract virtual void LogInfo(string message);
    public abstract virtual void LogVerbose(string message);
    public abstract virtual void LogError(Exception exceptionToTrace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Core.IO.BinaryMessageReader : object {
    [CompilerGeneratedAttribute]
private BinaryReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveTag>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CurrentTag>k__BackingField;
    public BinaryReader Reader { get; }
    public long CurrentPosition { get; }
    public long End { get; }
    public long Start { get; }
    protected bool HaveTag { get; protected set; }
    protected UInt32 CurrentTag { get; protected set; }
    public BinaryMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync);
    [CompilerGeneratedAttribute]
public BinaryReader get_Reader();
    public long get_CurrentPosition();
    [CompilerGeneratedAttribute]
public long get_End();
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
protected bool get_HaveTag();
    [CompilerGeneratedAttribute]
protected void set_HaveTag(bool value);
    [CompilerGeneratedAttribute]
protected UInt32 get_CurrentTag();
    [CompilerGeneratedAttribute]
protected void set_CurrentTag(UInt32 value);
    public virtual bool HasMessage(ushort messageTag);
    public void Sync();
    public bool CanRead();
    internal static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> elementReader);
    internal void ThrowIfInvalidTag(ushort messageTag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Core.IO.BinaryMessageWriter : object {
    private static IMessagePositionWriter GetMessagePositionWriter(BinaryWriter writer, int schemaVersion, ushort messageTag);
    public static void WriteTestCoverageDataMessage(BinaryWriter writer, TestCoverageDataMessage message, int schemaVersion);
    public static void WriteModuleBufferMessage(BinaryWriter writer, ModuleBufferMessage message, int schemaVersion);
    public static void WriteModuleInstrumentedMessage(BinaryWriter writer, ModuleInstrumentedMessage message, int schemaVersion);
    public static void WriteFunctionInstrumentedMessage(BinaryWriter writer, FunctionInstrumentedMessage message, int schemaVersion);
    public static void WriteFunctionSkippedMessage(BinaryWriter writer, FunctionSkippedMessage message, int schemaVersion);
    public static void WriteBlockLineDataMessage(BinaryWriter writer, BlockLineDataMessage message);
    public static void WriteSourceFileDataMessage(BinaryWriter writer, SourceFileDataMessage message, int schemaVersion);
    public static void WriteModuleSkippedMessage(BinaryWriter writer, ModuleSkippedMessage message, int schemaVersion);
    public static void WriteSnapshotIdsDataMessage(BinaryWriter writer, SnapshotIdsDataMessage message, int schemaVersion);
    public static void WriteCoverageBufferHashMessage(BinaryWriter writer, CoverageBufferHashMessage message, int schemaVersion);
    public static void WriteSnapshotTagsDataMessage(BinaryWriter writer, SnapshotTagsDataMessage message, int schemaVersion);
    public static void WriteNotSupportedMessage(BinaryWriter writer, NotSupportedMessage message, int schemaVersion);
    public static void WriteSuccessMessage(BinaryWriter writer);
    public static void WriteRegisterClientMessage(BinaryWriter writer, RegisterClientMessage message);
    public static void WriteRegisterClientResponseMessage(BinaryWriter writer);
    public static void WriteCreateStreamMessage(BinaryWriter writer, CreateStreamMessage message);
    public static void WriteCreateStreamResponseMessage(BinaryWriter writer, CreateStreamResponseMessage message);
    public static void WriteWriteStreamMessage(BinaryWriter writer, WriteStreamMessage message);
    public static void WriteCloseStreamMessage(BinaryWriter writer, CloseStreamMessage message);
    public static void WriteClientErrorMessage(BinaryWriter writer, ClientErrorMessage message);
    public static void WriteShutdownMessage(BinaryWriter writer);
    public static void WriteWriteStreamBuffersMessage(BinaryWriter writer, WriteStreamBuffersMessage message);
    public static void WriteConfigLoggerMessage(BinaryWriter writer);
    public static void WriteGetCoverageDataMessage(BinaryWriter writer, GetCoverageDataMessage message);
    public static void WriteInitializeClientMessage(BinaryWriter writer, InitializeClientMessage message);
    public static void WriteInitializeClientResponseMessage(BinaryWriter writer, InitializeClientResponseMessage message);
    public static void WriteLoadModuleDataMessage(BinaryWriter writer, LoadModuleDataMessage message);
    public static void WriteInstrumentedModuleMessage(BinaryWriter writer, InstrumentedModuleMessage message);
    public static void WriteInstrumentedFunctionMessage(BinaryWriter writer, InstrumentedFunctionMessage message);
    public static void WritePreloadModuleDataMessage(BinaryWriter writer, PreloadModuleDataMessage message);
    public static void WritePreloadModuleDataResponseMessage(BinaryWriter writer, PreloadModuleDataResponseMessage message);
    public static void WriteGetInformationMessage(BinaryWriter writer, GetInformationMessage message);
    public static void WriteGetInformationResponseMessage(BinaryWriter writer, GetInformationResponseMessage message);
    public static void WriteShutdownLoggerMessage(BinaryWriter writer);
    public static void WriteInstrumentationStatisticsMessage(BinaryWriter writer, InstrumentationStatisticsMessage message);
    public static void WriteCacheMessage(BinaryWriter writer, CacheMessage message);
    public static void WriteFetchNativeModuleDataMessage(BinaryWriter writer, FetchCacheMessage message);
    public static void WriteSnapshotMessage(BinaryWriter writer, SnapshotMessage message);
    public static void WriteFilePathsMessage(BinaryWriter writer, FilePathsMessage message);
    private static void WriteBufferMessage(BinaryWriter writer, BufferMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.CoverageFileMessageReader : BinaryMessageReader {
    private int _schemaVersion;
    private bool _readMessageSize;
    private UInt32 _currentMessageSize;
    public CoverageFileMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync, int schemaVersion);
    public virtual bool HasMessage(ushort messageTag);
    public void SkipCurrentMessage();
    public TestCoverageDataMessage ReadTestCoverageDataMessage();
    public ModuleBufferMessage ReadModuleBufferMessage();
    public ModuleInstrumentedMessage ReadModuleInstrumentedMessage();
    public SourceFileDataMessage ReadSourceFileDataMessage();
    public FunctionInstrumentedMessage ReadFunctionInstrumentedMessage();
    private static BlockLineDataMessage ReadBlockLineDataMessage(BinaryReader reader);
    public FunctionSkippedMessage ReadFunctionSkippedMessage();
    public ModuleSkippedMessage ReadModuleSkippedMessage();
    public SnapshotIdsDataMessage ReadSnapshotIdsDataMessage();
    public CoverageBufferHashMessage ReadCoverageBufferHashMessage();
    public SnapshotTagsDataMessage ReadSnapshotTagsInformationDataMessage();
    [CompilerGeneratedAttribute]
private SnapshotTag <ReadSnapshotTagsInformationDataMessage>b__16_0(BinaryReader r);
}
internal class Microsoft.CodeCoverage.Core.IO.FileHeader : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MessageSchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamsCount>k__BackingField;
    public UInt32 Magic { get; public set; }
    public ushort MessageSchemaVersion { get; public set; }
    public UInt32 StreamsCount { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Magic();
    [CompilerGeneratedAttribute]
public void set_Magic(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ushort get_MessageSchemaVersion();
    [CompilerGeneratedAttribute]
public void set_MessageSchemaVersion(ushort value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamsCount();
    [CompilerGeneratedAttribute]
public void set_StreamsCount(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.InterprocessMessageReader : BinaryMessageReader {
    public InterprocessMessageReader(BinaryReader reader, long startOffset, long endOffset, bool sync);
    public SuccessMessage ReadSuccessMessage();
    public RegisterClientMessage ReadRegisterClientMessage();
    public RegisterClientResponseMessage ReadRegisterClientResponseMessage();
    public CreateStreamMessage ReadCreateStreamMessage();
    public CreateStreamResponseMessage ReadCreateStreamResponseMessage();
    public WriteStreamMessage ReadWriteStreamMessage();
    public CloseStreamMessage ReadCloseStreamMessage();
    public ClientErrorMessage ReadClientErrorMessage();
    public ShutdownMessage ReadShutdownMessage();
    public WriteStreamBuffersMessage ReadWriteStreamBuffersMessage();
    public ConfigLoggerMessage ReadConfigLoggerMessage();
    public GetCoverageDataMessage ReadGetCoverageDataMessage();
    public InitializeClientMessage ReadInitializeClientMessage();
    public InitializeClientResponseMessage ReadInitializeClientResponseMessage();
    public LoadModuleDataMessage ReadLoadModuleDataMessage();
    public InstrumentedModuleMessage ReadInstrumentedModuleMessage();
    public InstrumentedFunctionMessage ReadInstrumentedFunctionMessage();
    public PreloadModuleDataMessage ReadPreloadModuleDataMessage();
    public PreloadModuleDataResponseMessage ReadPreloadModuleDataResponseMessage();
    public GetInformationMessage ReadGetInformationMessage();
    public GetInformationResponseMessage ReadGetInformationResponseMessage();
    public ShutdownLoggerMessage ReadShutdownLoggerMessage();
    public InstrumentationStatisticsMessage ReadInstrumentationStatisticsMessage();
    public CacheMessage ReadCacheMessage();
    public FetchCacheMessage ReadFetchCacheMessage();
    public SnapshotMessage ReadSnapshotMessage();
    public FilePathsMessage ReadFilePathsMessage();
    internal static BufferMessage ReadBufferMessage(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.IO.IoHelpers : object {
    [ExtensionAttribute]
internal static Guid ReadGuid(BinaryReader reader);
    internal static Char[] ReadChars(BinaryReader reader, int count);
    internal static Char[] ReadChars(BinaryReader reader);
    internal static Byte[] ReadBytes(BinaryReader reader, int count);
    internal static Byte[] ReadBytes(BinaryReader reader);
    internal static string ReadString(BinaryReader reader);
    internal static T[] ReadArray(BinaryReader reader, Func`2<BinaryReader, T> returnItemFunction);
    internal static string ReadStringBytes(BinaryReader reader);
    [ExtensionAttribute]
internal static void Write(BinaryWriter writer, Guid guid);
    internal static void WriteBytes(BinaryWriter writer, Byte[] buffer);
    internal static void WriteString(BinaryWriter writer, string text, bool addLength);
    internal static void WriteStringBytes(BinaryWriter writer, string text, bool addLength);
    internal static void WriteFileHeader(BinaryWriter writer, UInt32 fileHeaderMagic, ushort schemaVersion, UInt32 streamsCount);
    internal static void WriteStreamHeader(BinaryWriter writer, UInt32 streamHeaderMagic, Guid streamType, Guid identifier, UInt32 streamSize, long streamPosition);
    internal static void WriteStreamHeader(BinaryWriter writer, StreamHeader streamHeader);
    internal static void WriteStreamHeader(BinaryWriter writer, UInt32 streamHeaderMagic, Guid streamType, Guid identifier, UInt32 streamSize);
}
internal class Microsoft.CodeCoverage.Core.IO.MessagePosition : ValueType {
    [CompilerGeneratedAttribute]
private long <StartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TagPosition>k__BackingField;
    public long StartPosition { get; public set; }
    public long TagPosition { get; public set; }
    public MessagePosition(long StartPosition, long TagPosition);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_StartPosition();
    [CompilerGeneratedAttribute]
public void set_StartPosition(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TagPosition();
    [CompilerGeneratedAttribute]
public void set_TagPosition(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MessagePosition left, MessagePosition right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MessagePosition left, MessagePosition right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MessagePosition other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Int64& StartPosition, Int64& TagPosition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.IO.RawStream : ValueType {
    [CompilerGeneratedAttribute]
private StreamHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public StreamHeader Header { get; public set; }
    public Byte[] Data { get; public set; }
    public RawStream(StreamHeader Header, Byte[] Data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StreamHeader get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(StreamHeader value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RawStream left, RawStream right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RawStream left, RawStream right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RawStream other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(StreamHeader& Header, Byte[]& Data);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.CodeCoverage.Core.IO.StreamHeader : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Magic>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamSize>k__BackingField;
    public UInt32 Magic { get; public set; }
    public Guid StreamType { get; public set; }
    public Guid Identifier { get; public set; }
    public UInt32 StreamSize { get; public set; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Magic();
    [CompilerGeneratedAttribute]
public void set_Magic(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamSize();
    [CompilerGeneratedAttribute]
public void set_StreamSize(UInt32 value);
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamHeader left, StreamHeader right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamHeader left, StreamHeader right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamHeader other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeCoverage.Core.IO.XmlObjectSerializer : object {
    private static XmlWriterSettings XmlWriterSettings;
    private static XmlWriterSettings XmlWriterSettingsWithoutDeclaration;
    private static XmlObjectSerializer();
    public static void Write(string path, T source);
    public static void Write(string path, T source, bool skipNamespace);
    public static string Serialize(T source, bool skipNamespace);
    [NullableContextAttribute("2")]
public static bool TryRead(string path, T& result);
    public static T Read(string path);
    public static T Deserialize(XNode document);
    private static void Serialize(T source, bool skipNamespace, XmlSerializer serializer, XmlWriter writer);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Core.IOutputPathGenerator {
    public abstract virtual string GenerateOutputPath(string requestedOutputPath, string defaultExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.BufferMessage : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    public static ushort MessageTag;
    public Byte[] Buffer { get; public set; }
    public BufferMessage(Byte[] Buffer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public void set_Buffer(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BufferMessage left, BufferMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BufferMessage left, BufferMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BufferMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Byte[]& Buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CacheMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferMessage[] <Cache>k__BackingField;
    public static ushort MessageTag;
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public BufferMessage[] Cache { get; public set; }
    public CacheMessage(Guid Key, string Prefix, BufferMessage[] Cache);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BufferMessage[] get_Cache();
    [CompilerGeneratedAttribute]
public void set_Cache(BufferMessage[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CacheMessage left, CacheMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CacheMessage left, CacheMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CacheMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Key, String& Prefix, BufferMessage[]& Cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.ClientErrorMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ErrorCode>k__BackingField;
    public static ushort MessageTag;
    public string Message { get; public set; }
    public String[] Arguments { get; public set; }
    public UInt32 ErrorCode { get; public set; }
    public ClientErrorMessage(string Message, String[] Arguments, UInt32 ErrorCode);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(String[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ClientErrorMessage left, ClientErrorMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ClientErrorMessage left, ClientErrorMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ClientErrorMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Message, String[]& Arguments, UInt32& ErrorCode);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.CloseStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public bool Discard { get; public set; }
    public CloseStreamMessage(UInt32 StreamId, bool Discard);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CloseStreamMessage left, CloseStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CloseStreamMessage left, CloseStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CloseStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId, Boolean& Discard);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ConfigLoggerMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConfigLoggerMessage left, ConfigLoggerMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConfigLoggerMessage left, ConfigLoggerMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConfigLoggerMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CreateStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoClose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public static ushort MessageTag;
    public Guid StreamType { get; public set; }
    public Guid Identifier { get; public set; }
    public bool AutoClose { get; public set; }
    public string BufferName { get; public set; }
    public UInt32 BufferSize { get; public set; }
    public string BufferHeader { get; public set; }
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public CreateStreamMessage(Guid StreamType, Guid Identifier, bool AutoClose, string BufferName, UInt32 BufferSize, string BufferHeader, Guid Key, string Prefix);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AutoClose();
    [CompilerGeneratedAttribute]
public void set_AutoClose(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHeader();
    [CompilerGeneratedAttribute]
public void set_BufferHeader(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateStreamMessage left, CreateStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateStreamMessage left, CreateStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& StreamType, Guid& Identifier, Boolean& AutoClose, String& BufferName, UInt32& BufferSize, String& BufferHeader, Guid& Key, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.CreateStreamResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public string BufferName { get; public set; }
    public bool Discard { get; public set; }
    public CreateStreamResponseMessage(UInt32 StreamId, string BufferName, bool Discard);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CreateStreamResponseMessage left, CreateStreamResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CreateStreamResponseMessage left, CreateStreamResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CreateStreamResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId, String& BufferName, Boolean& Discard);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.FetchCacheMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public static ushort MessageTag;
    public Guid Key { get; public set; }
    public string Prefix { get; public set; }
    public FetchCacheMessage(Guid Key, string Prefix);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FetchCacheMessage left, FetchCacheMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FetchCacheMessage left, FetchCacheMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FetchCacheMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Key, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.FilePathsMessage : ValueType {
    [CompilerGeneratedAttribute]
private String[] <FilePaths>k__BackingField;
    public static ushort MessageTag;
    public String[] FilePaths { get; public set; }
    public FilePathsMessage(String[] FilePaths);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_FilePaths();
    [CompilerGeneratedAttribute]
public void set_FilePaths(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FilePathsMessage left, FilePathsMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FilePathsMessage left, FilePathsMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FilePathsMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String[]& FilePaths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    public static ushort MessageTag;
    public string OutputFilePath { get; public set; }
    public GetCoverageDataMessage(string OutputFilePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetCoverageDataMessage left, GetCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetCoverageDataMessage left, GetCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& OutputFilePath);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetInformationMessage : ValueType {
    [CompilerGeneratedAttribute]
private InformationType <InformationType>k__BackingField;
    public static ushort MessageTag;
    public InformationType InformationType { get; public set; }
    public GetInformationMessage(InformationType InformationType);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InformationType get_InformationType();
    [CompilerGeneratedAttribute]
public void set_InformationType(InformationType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetInformationMessage left, GetInformationMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetInformationMessage left, GetInformationMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetInformationMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(InformationType& InformationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.GetInformationResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public static ushort MessageTag;
    public string Information { get; public set; }
    public GetInformationResponseMessage(string Information);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
public void set_Information(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GetInformationResponseMessage left, GetInformationResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GetInformationResponseMessage left, GetInformationResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GetInformationResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Information);
}
internal enum Microsoft.CodeCoverage.Core.Messages.Control.InformationType : Enum {
    public int value__;
    public static InformationType DataCollector;
    public static InformationType CodeCoverage;
    public static InformationType LoggerProcessId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InitializeClientMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessOwnerSid>k__BackingField;
    public static ushort MessageTag;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public string Path { get; public set; }
    public string ProcessOwnerSid { get; public set; }
    public InitializeClientMessage(UInt32 SchemaVersion, UInt32 ProcessId, string Path, string ProcessOwnerSid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessOwnerSid();
    [CompilerGeneratedAttribute]
public void set_ProcessOwnerSid(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InitializeClientMessage left, InitializeClientMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InitializeClientMessage left, InitializeClientMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InitializeClientMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& SchemaVersion, UInt32& ProcessId, String& Path, String& ProcessOwnerSid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InitializeClientResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CommunicationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public static ushort MessageTag;
    public bool IsCodeCoverageEnabled { get; public set; }
    public UInt32 CommunicationTimeout { get; public set; }
    public string Path { get; public set; }
    public InitializeClientResponseMessage(bool IsCodeCoverageEnabled, UInt32 CommunicationTimeout, string Path);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public void set_IsCodeCoverageEnabled(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CommunicationTimeout();
    [CompilerGeneratedAttribute]
public void set_CommunicationTimeout(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InitializeClientResponseMessage left, InitializeClientResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InitializeClientResponseMessage left, InitializeClientResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InitializeClientResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsCodeCoverageEnabled, UInt32& CommunicationTimeout, String& Path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentationStatisticsMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CoverageBufferId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Dynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Managed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mixed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PortablePdb>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Instrumented>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Failed>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Elapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    public static ushort MessageTag;
    public Guid Id { get; public set; }
    public Guid CoverageBufferId { get; public set; }
    public string Path { get; public set; }
    public bool Dynamic { get; public set; }
    public bool Managed { get; public set; }
    public bool Mixed { get; public set; }
    public bool PortablePdb { get; public set; }
    public UInt32 ModuleSize { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public UInt32 Instrumented { get; public set; }
    public UInt32 Skipped { get; public set; }
    public UInt32 Failed { get; public set; }
    public UInt32 Elapsed { get; public set; }
    public String[] Properties { get; public set; }
    public InstrumentationStatisticsMessage(Guid Id, Guid CoverageBufferId, string Path, bool Dynamic, bool Managed, bool Mixed, bool PortablePdb, UInt32 ModuleSize, UInt32 ModuleLinkTime, UInt32 Instrumented, UInt32 Skipped, UInt32 Failed, UInt32 Elapsed, String[] Properties);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_CoverageBufferId();
    [CompilerGeneratedAttribute]
public void set_CoverageBufferId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Dynamic();
    [CompilerGeneratedAttribute]
public void set_Dynamic(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Managed();
    [CompilerGeneratedAttribute]
public void set_Managed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Mixed();
    [CompilerGeneratedAttribute]
public void set_Mixed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PortablePdb();
    [CompilerGeneratedAttribute]
public void set_PortablePdb(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleSize();
    [CompilerGeneratedAttribute]
public void set_ModuleSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Instrumented();
    [CompilerGeneratedAttribute]
public void set_Instrumented(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Failed();
    [CompilerGeneratedAttribute]
public void set_Failed(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Elapsed();
    [CompilerGeneratedAttribute]
public void set_Elapsed(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentationStatisticsMessage left, InstrumentationStatisticsMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentationStatisticsMessage left, InstrumentationStatisticsMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentationStatisticsMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Id, Guid& CoverageBufferId, String& Path, Boolean& Dynamic, Boolean& Managed, Boolean& Mixed, Boolean& PortablePdb, UInt32& ModuleSize, UInt32& ModuleLinkTime, UInt32& Instrumented, UInt32& Skipped, UInt32& Failed, UInt32& Elapsed, String[]& Properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentedFunctionMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<UInt32> <FunctionBlocks>k__BackingField;
    public static ushort MessageTag;
    public UInt32 MetadataToken { get; public set; }
    public UInt32 Offset { get; public set; }
    public IList`1<UInt32> FunctionBlocks { get; public set; }
    public InstrumentedFunctionMessage(UInt32 MetadataToken, UInt32 Offset, IList`1<UInt32> FunctionBlocks);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<UInt32> get_FunctionBlocks();
    [CompilerGeneratedAttribute]
public void set_FunctionBlocks(IList`1<UInt32> value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentedFunctionMessage left, InstrumentedFunctionMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentedFunctionMessage left, InstrumentedFunctionMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentedFunctionMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& MetadataToken, UInt32& Offset, IList`1& FunctionBlocks);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.InstrumentedModuleMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BufferSize>k__BackingField;
    public static ushort MessageTag;
    public string BufferName { get; public set; }
    public UInt32 BufferSize { get; public set; }
    public InstrumentedModuleMessage(string BufferName, UInt32 BufferSize);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [CompilerGeneratedAttribute]
public void set_BufferName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstrumentedModuleMessage left, InstrumentedModuleMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstrumentedModuleMessage left, InstrumentedModuleMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstrumentedModuleMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& BufferName, UInt32& BufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.LoadModuleDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    public static ushort MessageTag;
    public string ModulePath { get; public set; }
    public LoadModuleDataMessage(string ModulePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LoadModuleDataMessage left, LoadModuleDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LoadModuleDataMessage left, LoadModuleDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(LoadModuleDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& ModulePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.PreloadModuleDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    public static ushort MessageTag;
    public string ModulePath { get; public set; }
    public PreloadModuleDataMessage(string ModulePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PreloadModuleDataMessage left, PreloadModuleDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PreloadModuleDataMessage left, PreloadModuleDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreloadModuleDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& ModulePath);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.PreloadModuleDataResponseMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsSupported>k__BackingField;
    public static ushort MessageTag;
    public bool IsSupported { get; public set; }
    public PreloadModuleDataResponseMessage(bool IsSupported);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsSupported();
    [CompilerGeneratedAttribute]
public void set_IsSupported(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PreloadModuleDataResponseMessage left, PreloadModuleDataResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PreloadModuleDataResponseMessage left, PreloadModuleDataResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreloadModuleDataResponseMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsSupported);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.RegisterClientMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessOwnerSid>k__BackingField;
    public static ushort MessageTag;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public string ProcessOwnerSid { get; public set; }
    public RegisterClientMessage(UInt32 SchemaVersion, UInt32 ProcessId, string ProcessOwnerSid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProcessOwnerSid();
    [CompilerGeneratedAttribute]
public void set_ProcessOwnerSid(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RegisterClientMessage left, RegisterClientMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RegisterClientMessage left, RegisterClientMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegisterClientMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& SchemaVersion, UInt32& ProcessId, String& ProcessOwnerSid);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.RegisterClientResponseMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RegisterClientResponseMessage left, RegisterClientResponseMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RegisterClientResponseMessage left, RegisterClientResponseMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegisterClientResponseMessage other);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ShutdownLoggerMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ShutdownLoggerMessage left, ShutdownLoggerMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ShutdownLoggerMessage left, ShutdownLoggerMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ShutdownLoggerMessage other);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.ShutdownMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ShutdownMessage left, ShutdownMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ShutdownMessage left, ShutdownMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ShutdownMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.SnapshotMessage : ValueType {
    [CompilerGeneratedAttribute]
private bool <Reset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    public static ushort MessageTag;
    public bool Reset { get; public set; }
    public string OutputFilePath { get; public set; }
    public string TagId { get; public set; }
    public string TagName { get; public set; }
    public SnapshotMessage(bool Reset, string OutputFilePath, string TagId, string TagName);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Reset();
    [CompilerGeneratedAttribute]
public void set_Reset(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TagId();
    [CompilerGeneratedAttribute]
public void set_TagId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
public void set_TagName(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotMessage left, SnapshotMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotMessage left, SnapshotMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Boolean& Reset, String& OutputFilePath, String& TagId, String& TagName);
}
public class Microsoft.CodeCoverage.Core.Messages.Control.SuccessMessage : ValueType {
    public static ushort MessageTag;
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SuccessMessage left, SuccessMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SuccessMessage left, SuccessMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SuccessMessage other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.Control.WriteStreamBuffersMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetBuffers>k__BackingField;
    public static ushort MessageTag;
    public Guid StreamType { get; public set; }
    public string BufferHeader { get; public set; }
    public bool ResetBuffers { get; public set; }
    public WriteStreamBuffersMessage(Guid StreamType, string BufferHeader, bool ResetBuffers);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public void set_StreamType(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHeader();
    [CompilerGeneratedAttribute]
public void set_BufferHeader(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ResetBuffers();
    [CompilerGeneratedAttribute]
public void set_ResetBuffers(bool value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WriteStreamBuffersMessage left, WriteStreamBuffersMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WriteStreamBuffersMessage left, WriteStreamBuffersMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(WriteStreamBuffersMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& StreamType, String& BufferHeader, Boolean& ResetBuffers);
}
internal class Microsoft.CodeCoverage.Core.Messages.Control.WriteStreamMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    public static ushort MessageTag;
    public UInt32 StreamId { get; public set; }
    public WriteStreamMessage(UInt32 StreamId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WriteStreamMessage left, WriteStreamMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WriteStreamMessage left, WriteStreamMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(WriteStreamMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StreamId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.CoverageData.ModuleBufferMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    public static ushort MessageTag;
    public string Name { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public ModuleBufferMessage(string Name, UInt32 ModuleLinkTime);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleBufferMessage left, ModuleBufferMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleBufferMessage left, ModuleBufferMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleBufferMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Name, UInt32& ModuleLinkTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.CoverageData.TestCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <TestId>k__BackingField;
    public static ushort MessageTag;
    public string TestId { get; public set; }
    public TestCoverageDataMessage(string TestId);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TestId();
    [CompilerGeneratedAttribute]
public void set_TestId(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TestCoverageDataMessage left, TestCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TestCoverageDataMessage left, TestCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TestCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& TestId);
}
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.BlockLineDataMessage : object {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <BlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    public UInt32 BlockIndex { get; public set; }
    public UInt32 SourceId { get; public set; }
    public UInt32 StartLine { get; public set; }
    public UInt32 StartColumn { get; public set; }
    public UInt32 EndLine { get; public set; }
    public UInt32 EndColumn { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_BlockIndex();
    [CompilerGeneratedAttribute]
public void set_BlockIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(UInt32 value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.FunctionInstrumentedMessage : object {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FunctionRva>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockLineDataMessage[] <LineData>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UInt32 FunctionId { get; public set; }
    public UInt32 FunctionRva { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public UInt32 StartBlockIndex { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string NamespaceName { get; public set; }
    public BlockLineDataMessage[] LineData { get; public set; }
    [CompilerGeneratedAttribute]
protected FunctionInstrumentedMessage(FunctionInstrumentedMessage original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UInt32 get_FunctionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FunctionId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_FunctionRva();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FunctionRva(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MetadataToken(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
public void set_StartBlockIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public BlockLineDataMessage[] get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(BlockLineDataMessage[] value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FunctionInstrumentedMessage left, FunctionInstrumentedMessage right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FunctionInstrumentedMessage left, FunctionInstrumentedMessage right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(FunctionInstrumentedMessage other);
    [CompilerGeneratedAttribute]
public virtual FunctionInstrumentedMessage <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.FunctionSkippedMessage : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <FunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OriginalFunctionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public static ushort MessageTag;
    public UInt32 FunctionId { get; public set; }
    public UInt32 OriginalFunctionId { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public FunctionSkipReason SkipReason { get; public set; }
    public string Name { get; public set; }
    public string TypeName { get; public set; }
    public string ExceptionMessage { get; public set; }
    public FunctionSkippedMessage(UInt32 FunctionId, UInt32 OriginalFunctionId, UInt32 MetadataToken, FunctionSkipReason SkipReason, string Name, string TypeName, string ExceptionMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_FunctionId();
    [CompilerGeneratedAttribute]
public void set_FunctionId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_OriginalFunctionId();
    [CompilerGeneratedAttribute]
public void set_OriginalFunctionId(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FunctionSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(FunctionSkipReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FunctionSkippedMessage left, FunctionSkippedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FunctionSkippedMessage left, FunctionSkippedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FunctionSkippedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& FunctionId, UInt32& OriginalFunctionId, UInt32& MetadataToken, FunctionSkipReason& SkipReason, String& Name, String& TypeName, String& ExceptionMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.ModuleInstrumentedMessage : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <ModuleIdentifierBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CoverageBufferId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    public static ushort MessageTag;
    public Byte[] ModuleIdentifierBytes { get; public set; }
    public Guid CoverageBufferId { get; public set; }
    public string Path { get; public set; }
    public UInt32 ModuleSize { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    public string TargetFramework { get; public set; }
    public string Configuration { get; public set; }
    public string Architecture { get; public set; }
    public string ModuleIdentifier { get; }
    public ModuleInstrumentedMessage(Byte[] ModuleIdentifierBytes, Guid CoverageBufferId, string Path, UInt32 ModuleSize, UInt32 ModuleLinkTime, string TargetFramework, string Configuration, string Architecture);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_ModuleIdentifierBytes();
    [CompilerGeneratedAttribute]
public void set_ModuleIdentifierBytes(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_CoverageBufferId();
    [CompilerGeneratedAttribute]
public void set_CoverageBufferId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleSize();
    [CompilerGeneratedAttribute]
public void set_ModuleSize(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Architecture();
    [CompilerGeneratedAttribute]
public void set_Architecture(string value);
    public string get_ModuleIdentifier();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleInstrumentedMessage left, ModuleInstrumentedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleInstrumentedMessage left, ModuleInstrumentedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleInstrumentedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Byte[]& ModuleIdentifierBytes, Guid& CoverageBufferId, String& Path, UInt32& ModuleSize, UInt32& ModuleLinkTime, String& TargetFramework, String& Configuration, String& Architecture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.NotSupportedMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public static ushort MessageTag;
    public string Message { get; public set; }
    public NotSupportedMessage(string Message);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NotSupportedMessage left, NotSupportedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NotSupportedMessage left, NotSupportedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NotSupportedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModuleData.SourceFileDataMessage : object {
    public static ushort MessageTag;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ChecksumType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    public UInt32 SourceId { get; public set; }
    public string Path { get; public set; }
    public UInt32 ChecksumType { get; public set; }
    public Byte[] Checksum { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Path(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ChecksumType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumType(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Checksum(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.ModulesSkipped.ModuleSkippedMessage : ValueType {
    [CompilerGeneratedAttribute]
private ModuleSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    public static ushort MessageTag;
    public ModuleSkipReason SkipReason { get; public set; }
    public string Path { get; public set; }
    public string ExceptionMessage { get; public set; }
    public ModuleSkippedMessage(ModuleSkipReason SkipReason, string Path, string ExceptionMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(ModuleSkipReason value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleSkippedMessage left, ModuleSkippedMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleSkippedMessage left, ModuleSkippedMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleSkippedMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleSkipReason& SkipReason, String& Path, String& ExceptionMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.PerSnapshotCoverageData.CoverageBufferHashMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <HashName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferHash>k__BackingField;
    public static ushort MessageTag;
    public string HashName { get; public set; }
    public string BufferHash { get; public set; }
    public CoverageBufferHashMessage(string HashName, string BufferHash);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_HashName();
    [CompilerGeneratedAttribute]
public void set_HashName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BufferHash();
    [CompilerGeneratedAttribute]
public void set_BufferHash(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageBufferHashMessage left, CoverageBufferHashMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CoverageBufferHashMessage left, CoverageBufferHashMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageBufferHashMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& HashName, String& BufferHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.PerSnapshotCoverageData.SnapshotIdsDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private String[] <SnapshotIds>k__BackingField;
    public static ushort MessageTag;
    public String[] SnapshotIds { get; public set; }
    public SnapshotIdsDataMessage(String[] SnapshotIds);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_SnapshotIds();
    [CompilerGeneratedAttribute]
public void set_SnapshotIds(String[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotIdsDataMessage left, SnapshotIdsDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotIdsDataMessage left, SnapshotIdsDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotIdsDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String[]& SnapshotIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.Messages.SnapshotTagsData.SnapshotTagsDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private SnapshotTag[] <SnapshotTags>k__BackingField;
    public static ushort MessageTag;
    public SnapshotTag[] SnapshotTags { get; public set; }
    public SnapshotTagsDataMessage(SnapshotTag[] SnapshotTags);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SnapshotTag[] get_SnapshotTags();
    [CompilerGeneratedAttribute]
public void set_SnapshotTags(SnapshotTag[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotTagsDataMessage left, SnapshotTagsDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotTagsDataMessage left, SnapshotTagsDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotTagsDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(SnapshotTag[]& SnapshotTags);
}
public enum Microsoft.CodeCoverage.Core.ModuleSkipReason : Enum {
    public int value__;
    public static ModuleSkipReason no_symbols;
    public static ModuleSkipReason path_is_excluded;
    public static ModuleSkipReason public_key_token_is_excluded;
    public static ModuleSkipReason company_name_is_excluded;
    public static ModuleSkipReason optimized_or_instrumented;
    public static ModuleSkipReason has_fixed_base;
    public static ModuleSkipReason nothing_instrumented;
    public static ModuleSkipReason instrumentation_failure;
    public static ModuleSkipReason configuration_changed;
    public static ModuleSkipReason module_compiler_generated;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Core.NullLogger : object {
    public sealed virtual void LogError(string message);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogWarning(string message);
}
public enum Microsoft.CodeCoverage.Core.SourceFileCheckSumType : Enum {
    public UInt32 value__;
    public static SourceFileCheckSumType Unknown;
    public static SourceFileCheckSumType Md5;
    public static SourceFileCheckSumType Sha1;
    public static SourceFileCheckSumType Sha256;
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.SourceFileCheckSumTypeConverter : object {
    private static Guid SourceHashMD5;
    private static Guid SourceHashSHA1;
    private static Guid SourceHashSHA256;
    private static SourceFileCheckSumTypeConverter();
    [ExtensionAttribute]
internal static SourceFileCheckSumType ToSourceFileCheckSumType(Guid checkSumType);
    [ExtensionAttribute]
internal static SourceFileCheckSumType ToSourceFileCheckSumType(UInt32 checkSumType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.Core.StringUtils : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaClass : CoverageDetails {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaMethod[] <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaLine[] <Lines>k__BackingField;
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("filename")]
public string Filename { get; public set; }
    [XmlArrayAttribute("methods")]
[XmlArrayItemAttribute("method")]
public CoberturaMethod[] Methods { get; public set; }
    [XmlArrayAttribute("lines")]
[XmlArrayItemAttribute("line")]
public CoberturaLine[] Lines { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public void set_Filename(string value);
    [CompilerGeneratedAttribute]
public CoberturaMethod[] get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(CoberturaMethod[] value);
    [CompilerGeneratedAttribute]
public CoberturaLine[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(CoberturaLine[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaClassExtensions : object {
    [ExtensionAttribute]
public static void PopulateClassLines(CoberturaClass coberturaClass);
    [ExtensionAttribute]
public static CoberturaClass[] ToArray(Dictionary`2<ValueTuple`2<string, string>, CoberturaClass> input);
    [CompilerGeneratedAttribute]
internal static void <PopulateClassLines>g__AddCondition|0_1(CoberturaCondition condition, <>c__DisplayClass0_0& , <>c__DisplayClass0_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaCondition : object {
    [CompilerGeneratedAttribute]
private int <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Coverage>k__BackingField;
    [XmlIgnoreAttribute]
internal CoberturaConditionInternalData InternalData;
    [XmlAttributeAttribute("number")]
public int Number { get; public set; }
    [XmlAttributeAttribute("type")]
public string Type { get; public set; }
    [XmlAttributeAttribute("coverage")]
public string Coverage { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(int value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Coverage();
    [CompilerGeneratedAttribute]
public void set_Coverage(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.CoberturaConditionInternalData : ValueType {
    private UInt32[] _targetOffsetsOrHits;
    private UInt32 _offsetOrHit;
    public int CoveredBranches { get; }
    public int Branches { get; }
    public void Initialize(UInt32 offset, UInt32[] targetOffsets);
    public int get_CoveredBranches();
    public int get_Branches();
    public void AddTargetOffset(UInt32 targetOffset);
    public void PopulateCoverageStatus(Byte[] buffer);
    public bool TryMerge(CoberturaConditionInternalData other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaConditionsHelper : object {
    private static Regex _conditionRegex;
    private static CoberturaConditionsHelper();
    public static string ToLineConditionCoverage(int coveredBranchesCount, int branchesCount);
    public static bool TryParseLineConditionCoverage(string conditionCoverage, Int32& coveredBranchesCount, Int32& branchesCount);
    public static string ToConditionCoverage(int coveredBranchesCount, int branchesCount);
    public static double ToConditionCoveragePercentage(int coveredBranchesCount, int branchesCount);
    public static string ToConditionCoverage(double coverage);
    public static bool TryParseConditionCoverage(string conditionCoverageString, Double& conditionCoverage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlRootAttribute("coverage")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaFile : CoverageDetails {
    private static string FileVersion;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CoberturaPackage> <Packages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LinesValid>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BranchesValid>k__BackingField;
    [XmlAttributeAttribute("version")]
public string Version { get; public set; }
    [XmlAttributeAttribute("timestamp")]
public long Timestamp { get; public set; }
    [XmlArrayAttribute("sources")]
[XmlArrayItemAttribute("source")]
public String[] Sources { get; public set; }
    [XmlArrayAttribute("packages")]
[XmlArrayItemAttribute("package")]
public List`1<CoberturaPackage> Packages { get; public set; }
    [XmlAttributeAttribute("lines-covered")]
public long LinesCovered { get; public set; }
    [XmlAttributeAttribute("lines-valid")]
public long LinesValid { get; public set; }
    [XmlAttributeAttribute("branches-covered")]
public long BranchesCovered { get; public set; }
    [XmlAttributeAttribute("branches-valid")]
public long BranchesValid { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public String[] get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(String[] value);
    [CompilerGeneratedAttribute]
public List`1<CoberturaPackage> get_Packages();
    [CompilerGeneratedAttribute]
public void set_Packages(List`1<CoberturaPackage> value);
    [CompilerGeneratedAttribute]
public long get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(long value);
    [CompilerGeneratedAttribute]
public long get_LinesValid();
    [CompilerGeneratedAttribute]
public void set_LinesValid(long value);
    [CompilerGeneratedAttribute]
public long get_BranchesCovered();
    [CompilerGeneratedAttribute]
public void set_BranchesCovered(long value);
    [CompilerGeneratedAttribute]
public long get_BranchesValid();
    [CompilerGeneratedAttribute]
public void set_BranchesValid(long value);
    public bool ShouldSerializeLinesCovered();
    public bool ShouldSerializeLinesValid();
    public bool ShouldSerializeBranchesCovered();
    public bool ShouldSerializeBranchesValid();
    public bool ShouldSerializeComplexity();
    public bool ShouldSerializeSources();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility : object {
    [NullableContextAttribute("2")]
public static bool TryReadCoberturaFile(string path, CoberturaFile& coberturaFile);
    public static CoverageFile ToCoverageFile(CoberturaFile coberturaFile);
    private static ModuleWrapper ToModuleWrapper(CoberturaPackage package, String[] sources);
    private static string CalculateClassPath(string fileName, String[] sources);
    private static ValueTuple`2<FunctionInstrumentedMessage, Byte[]> ToFunctionInstrumentedMessage(CoberturaMethod method, string typeName, string namespaceName, UInt32 startBlockIndex, UInt32 functionId, UInt32 sourceId);
    private static SourceFileDataMessage ToSourceFileDataMessage(string path, Dictionary`2<string, UInt32> sourceFiles);
    internal static ValueTuple`2<string, string> PopulateClassProperties(CoberturaClass coberturaClass);
    internal static void AddPackage(CoberturaFile coberturaFile, CoberturaPackage coberturaPackage, CancellationToken token);
    public static CoberturaFile MergeCoberturaFiles(IList`1<string> files, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility/<MergeCoberturaFilesAsync>d__9")]
public static Task`1<CoberturaFile> MergeCoberturaFilesAsync(IList`1<ValueTuple`2<string, CoberturaFile>> files, CancellationToken token, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility/<MergeCoberturaFilesAsync>d__10")]
public static Task`1<CoberturaFile> MergeCoberturaFilesAsync(IList`1<string> files, CancellationToken token, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Cobertura.CoberturaFileUtility/<Merge>d__11")]
private static Task`1<CoberturaFile> Merge(bool skipInvalidFiles, int taskCount, Queue`1<ValueTuple`2<string, CoberturaFile>> queue, CancellationToken token);
    [NullableContextAttribute("2")]
private static CoberturaFile GetCoverageFile(ValueTuple`2<string, CoberturaFile> file, bool skipInvalidFiles, CancellationToken token);
    internal static CoberturaFile Merge(CoberturaFile file1, CoberturaFile file2, bool skipInvalidFiles, CancellationToken token);
    internal static void Merge(CoberturaPackage target, String[] targetSources, CoberturaPackage source, String[] sourceSources, Boolean& includeSourcesFromSourcePackage, CancellationToken token);
    internal static void Merge(CoberturaClass target, CoberturaClass source, CancellationToken token);
    internal static void Merge(CoberturaMethod target, CoberturaMethod source, CancellationToken token);
    internal static void Merge(CoberturaLine targetLine, CoberturaLine line);
    private static bool CanBeFastMerged(CoberturaMethod target, CoberturaMethod source);
    private static bool TryMergeConditions(CoberturaLine targetLine, CoberturaLine line);
    private static bool TryMergeConditionsUsingInternalData(CoberturaLine targetLine, CoberturaLine line);
    private static bool TryRegenerateConditionsStats(CoberturaLine line, CoberturaConditionStatistics[] lineStats, int coveredBranches, int branches);
    private static void InvalidateAllLineStatistics(CoberturaConditionStatistics[] lineStats);
    private static bool AreConditionsMergable(CoberturaCondition targetCondition, CoberturaCondition lineCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaLine : object {
    [CompilerGeneratedAttribute]
private int <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hits>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConditionCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaCondition[] <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<UInt32> <Offset>k__BackingField;
    [XmlAttributeAttribute("number")]
public int Number { get; public set; }
    [XmlAttributeAttribute("hits")]
public int Hits { get; public set; }
    [XmlIgnoreAttribute]
public bool Branch { get; public set; }
    [XmlAttributeAttribute("branch")]
public string BranchString { get; public set; }
    [XmlAttributeAttribute("condition-coverage")]
public string ConditionCoverage { get; public set; }
    [XmlArrayAttribute("conditions")]
[XmlArrayItemAttribute("condition")]
public CoberturaCondition[] Conditions { get; public set; }
    [XmlIgnoreAttribute]
public ISet`1<UInt32> Offset { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Number();
    [CompilerGeneratedAttribute]
public void set_Number(int value);
    [CompilerGeneratedAttribute]
public int get_Hits();
    [CompilerGeneratedAttribute]
public void set_Hits(int value);
    [CompilerGeneratedAttribute]
public bool get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(bool value);
    public string get_BranchString();
    public void set_BranchString(string value);
    [CompilerGeneratedAttribute]
public string get_ConditionCoverage();
    [CompilerGeneratedAttribute]
public void set_ConditionCoverage(string value);
    [CompilerGeneratedAttribute]
public CoberturaCondition[] get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(CoberturaCondition[] value);
    [CompilerGeneratedAttribute]
public ISet`1<UInt32> get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(ISet`1<UInt32> value);
    public bool ShouldSerializeConditions();
    public bool ShouldSerializeConditionCoverage();
}
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaLineExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CoberturaLine[] ToSortedArray(IDictionary`2<int, CoberturaLine> input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaMethod : CoverageDetails {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaLine[] <Lines>k__BackingField;
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("signature")]
public string Signature { get; public set; }
    [XmlArrayAttribute("lines")]
[XmlArrayItemAttribute("line")]
public CoberturaLine[] Lines { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    [CompilerGeneratedAttribute]
public CoberturaLine[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(CoberturaLine[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Cobertura.CoberturaPackage : CoverageDetails {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CoberturaClass[] <Classes>k__BackingField;
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlArrayAttribute("classes")]
[XmlArrayItemAttribute("class")]
public CoberturaClass[] Classes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CoberturaClass[] get_Classes();
    [CompilerGeneratedAttribute]
public void set_Classes(CoberturaClass[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.CoberturaPackageBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<string, string>, CoberturaMethodArrayWithIndex> _methodsMap;
    private CoberturaMethodElement[] _methods;
    private int _methodsSize;
    public CoberturaPackageBuilder(int classesCapacity, int methodsCapacity);
    public void AddMethod(string namespaceName, string typeName, string filename, CoberturaMethod method);
    public CoberturaClass[] GetClasses();
    private void AddMethod(string name, string filename, CoberturaMethod method);
}
public static class Microsoft.CodeCoverage.IO.Cobertura.CoberturaStatisticsCalculator : object {
    [NullableContextAttribute("1")]
public static void CalculateStatistics(CoberturaFile coverage);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaPackage package);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaClass class);
    internal static ValueTuple`4<int, int, int, int> CalculateStatistics(CoberturaMethod method);
}
public abstract class Microsoft.CodeCoverage.IO.Cobertura.CoverageDetails : object {
    [CompilerGeneratedAttribute]
private double <LineRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BranchRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Complexity>k__BackingField;
    [XmlAttributeAttribute("line-rate")]
public double LineRate { get; public set; }
    [XmlAttributeAttribute("branch-rate")]
public double BranchRate { get; public set; }
    [XmlAttributeAttribute("complexity")]
public double Complexity { get; public set; }
    [CompilerGeneratedAttribute]
public double get_LineRate();
    [CompilerGeneratedAttribute]
public void set_LineRate(double value);
    [CompilerGeneratedAttribute]
public double get_BranchRate();
    [CompilerGeneratedAttribute]
public void set_BranchRate(double value);
    [CompilerGeneratedAttribute]
public double get_Complexity();
    [CompilerGeneratedAttribute]
public void set_Complexity(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Cobertura.MinimalSequencePointsFinder`1 : object {
    private Dictionary`2<T, Dictionary`2<int, int>> _mapping;
    [NullableAttribute("2")]
private Dictionary`2<int, int> _currentMappingForSourceFile;
    public MinimalSequencePointsFinder`1(int capacity);
    [MemberNotNullAttribute("_currentMappingForSourceFile")]
public void SetSourceFile(T sourceFile);
    public void AddSequencePoint(int startLine, int endLine);
    public bool IsMinimal(int lineNumber, int startLine, int endLine);
}
internal class Microsoft.CodeCoverage.IO.Coverage.BasicBlockInfo : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CoverageStatus>k__BackingField;
    public UInt32 Left { get; public set; }
    public UInt32 Right { get; public set; }
    public UInt32 CoverageStatus { get; public set; }
    public BasicBlockInfo(UInt32 left, UInt32 right, UInt32 coverageStatus);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(UInt32 value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual int CompareTo(BasicBlockInfo other);
}
public class Microsoft.CodeCoverage.IO.Coverage.BlockCoverageStatistics : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <BlocksCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlocksNotCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesPartiallyCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesNotCovered>k__BackingField;
    public UInt32 BlocksCovered { get; public set; }
    public UInt32 BlocksNotCovered { get; public set; }
    public UInt32 LinesCovered { get; public set; }
    public UInt32 LinesPartiallyCovered { get; public set; }
    public UInt32 LinesNotCovered { get; public set; }
    public BlockCoverageStatistics(UInt32 BlocksCovered, UInt32 BlocksNotCovered, UInt32 LinesCovered, UInt32 LinesPartiallyCovered, UInt32 LinesNotCovered);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BlocksCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BlocksNotCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksNotCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesPartiallyCovered();
    [CompilerGeneratedAttribute]
public void set_LinesPartiallyCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LinesNotCovered();
    [CompilerGeneratedAttribute]
public void set_LinesNotCovered(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BlockCoverageStatistics left, BlockCoverageStatistics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BlockCoverageStatistics left, BlockCoverageStatistics right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BlockCoverageStatistics other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(UInt32& BlocksCovered, UInt32& BlocksNotCovered, UInt32& LinesCovered, UInt32& LinesPartiallyCovered, UInt32& LinesNotCovered);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.BlockLineData : object {
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageStatus <CoverageStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    [XmlIgnoreAttribute]
internal UInt32 Index { get; internal set; }
    [XmlAttributeAttribute("source_id")]
public UInt32 SourceId { get; public set; }
    [XmlAttributeAttribute("covered")]
public CoverageStatus CoverageStatus { get; public set; }
    [XmlAttributeAttribute("start_line")]
public UInt32 StartLine { get; public set; }
    [XmlAttributeAttribute("start_column")]
public UInt32 StartColumn { get; public set; }
    [XmlAttributeAttribute("end_line")]
public UInt32 EndLine { get; public set; }
    [XmlAttributeAttribute("end_column")]
public UInt32 EndColumn { get; public set; }
    [CompilerGeneratedAttribute]
internal virtual UInt32 get_Index();
    [CompilerGeneratedAttribute]
internal virtual void set_Index(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public CoverageStatus get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(CoverageStatus value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(UInt32 value);
    public virtual string ToString();
    public sealed virtual int CompareTo(BlockLineData other);
    public static bool op_Equality(BlockLineData left, BlockLineData right);
    public static bool op_Inequality(BlockLineData left, BlockLineData right);
    public virtual bool Equals(object obj);
    private bool Equals(BlockLineData other);
    public static bool op_LessThan(BlockLineData left, BlockLineData right);
    public static bool op_LessThanOrEqual(BlockLineData left, BlockLineData right);
    public static bool op_GreaterThan(BlockLineData left, BlockLineData right);
    public static bool op_GreaterThanOrEqual(BlockLineData left, BlockLineData right);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.CoverageBufferData : object {
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`3<Guid, long, long> <CoverageBufferLocation>k__BackingField;
    public string ModuleName { get; public set; }
    public UInt32 ModuleLinkTime { get; public set; }
    internal Byte[] CoverageBuffer { get; internal set; }
    internal Guid Identifier { get; internal set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
internal ValueTuple`3<Guid, long, long> CoverageBufferLocation { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ModuleLinkTime();
    [CompilerGeneratedAttribute]
public void set_ModuleLinkTime(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal Guid get_Identifier();
    [CompilerGeneratedAttribute]
internal void set_Identifier(Guid value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal ValueTuple`3<Guid, long, long> get_CoverageBufferLocation();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal void set_CoverageBufferLocation(ValueTuple`3<Guid, long, long> value);
    public static bool op_Equality(CoverageBufferData left, CoverageBufferData right);
    public static bool op_Inequality(CoverageBufferData left, CoverageBufferData right);
    public virtual bool Equals(object obj);
    private bool Equals(CoverageBufferData other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.CoverageData : object {
    [CompilerGeneratedAttribute]
private IList`1<ModuleWrapper> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SkippedModule> <SkippedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <TestIds>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<SnapshotTag> <SnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SnapshotTag> <SnapshotTagsInformationMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> <CoveragePerSnapshotMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<ValueTuple`2<long, long>> <SkippedModuleLocations>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> <CoverageDataLocations>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> <ModuleDataLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ModuleInstrumentedMessage> <ModuleIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, List`1<ModuleHandle>> <ModuleHandles>k__BackingField;
    public IList`1<ModuleWrapper> Modules { get; }
    public IList`1<SkippedModule> SkippedModules { get; }
    public IList`1<string> TestIds { get; }
    internal ISet`1<SnapshotTag> SnapshotTags { get; }
    internal bool HasPerTestData { get; }
    internal List`1<SnapshotTag> SnapshotTagsInformationMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> CoveragePerSnapshotMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<ValueTuple`2<long, long>> SkippedModuleLocations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> CoverageDataLocations { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> ModuleDataLocations { get; }
    internal IDictionary`2<string, ModuleInstrumentedMessage> ModuleIds { get; }
    internal IDictionary`2<string, List`1<ModuleHandle>> ModuleHandles { get; }
    [CompilerGeneratedAttribute]
public IList`1<ModuleWrapper> get_Modules();
    [CompilerGeneratedAttribute]
public IList`1<SkippedModule> get_SkippedModules();
    [CompilerGeneratedAttribute]
public IList`1<string> get_TestIds();
    [CompilerGeneratedAttribute]
internal ISet`1<SnapshotTag> get_SnapshotTags();
    internal bool get_HasPerTestData();
    [CompilerGeneratedAttribute]
internal List`1<SnapshotTag> get_SnapshotTagsInformationMessages();
    [CompilerGeneratedAttribute]
internal Dictionary`2<Guid, Dictionary`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>>> get_CoveragePerSnapshotMessages();
    [CompilerGeneratedAttribute]
internal IList`1<ValueTuple`2<long, long>> get_SkippedModuleLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> get_CoverageDataLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> get_ModuleDataLocations();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, ModuleInstrumentedMessage> get_ModuleIds();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, List`1<ModuleHandle>> get_ModuleHandles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageFile : object {
    internal static ushort MaximumMessageSchemaVersion;
    private ICoverageFileReader _coverageFileReader;
    private ICoverageFileWriter _coverageFileWriter;
    private ICoverageFileConfiguration _coverageFileConfiguration;
    public CoverageFile(ICoverageFileReader coverageFileReader, ICoverageFileWriter coverageFileWriter, ICoverageFileConfiguration coverageFileConfiguration);
    public static bool IsValidCoverageFile(string path);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFile/<ReadCoverageFileAsync>d__6")]
public Task`1<CoverageFileMessages> ReadCoverageFileAsync(string path, CancellationToken cancellationToken);
    public CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFile/<WriteAsync>d__8")]
public Task WriteAsync(string path, CoverageFileMessages coverageFileMessages, ushort schemaVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFile/<SplitCoverageFileAsync>d__9")]
public Task SplitCoverageFileAsync(string path, string outputFolder, ushort schemaVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFile/<MergeSplitCoverageFiles>d__10")]
public Task`1<string> MergeSplitCoverageFiles(string covxFile, IList`1<string> coverageBufferFiles, ushort schemaVersion, CancellationToken cancellationToken, bool skipInvalidFiles);
    private ValueTuple`2<CoverageBufferData, Byte[]> MergeCovBufferFiles(IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CoverageFileConfiguration configuration, CancellationToken cancellationToken);
    private static Byte[] MergeCoverageBufferData(IEnumerable`1<CoverageBufferData> buffersData, bool skipInvalidFiles);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageFileConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <ReadModules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSkippedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadSnapshotsData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCoverageBufferFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixCoverageBuffersMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoverageFileConfiguration <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoverageFileConfiguration <NoSkippedData>k__BackingField;
    public bool ReadModules { get; public set; }
    public bool ReadSkippedModules { get; public set; }
    public bool ReadSkippedFunctions { get; public set; }
    public bool ReadSnapshotsData { get; public set; }
    public bool GenerateCoverageBufferFiles { get; public set; }
    public bool FixCoverageBuffersMismatch { get; public set; }
    public int MaxDegreeOfParallelism { get; public set; }
    internal static CoverageFileConfiguration Default { get; }
    internal static CoverageFileConfiguration NoSkippedData { get; }
    private static CoverageFileConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadModules();
    [CompilerGeneratedAttribute]
public void set_ReadModules(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedModules();
    [CompilerGeneratedAttribute]
public void set_ReadSkippedModules(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_ReadSkippedFunctions(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSnapshotsData();
    [CompilerGeneratedAttribute]
public void set_ReadSnapshotsData(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_GenerateCoverageBufferFiles();
    [CompilerGeneratedAttribute]
public void set_GenerateCoverageBufferFiles(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FixCoverageBuffersMismatch();
    [CompilerGeneratedAttribute]
public void set_FixCoverageBuffersMismatch(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxDegreeOfParallelism();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
internal static CoverageFileConfiguration get_Default();
    [CompilerGeneratedAttribute]
internal static CoverageFileConfiguration get_NoSkippedData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageFileMessages : object {
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<ModuleMessages> <ModulesMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ModuleSkippedMessage> <SkippedModuleMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<Guid, Byte[]> <CoverageBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<SnapshotTagsDataMessage> <SnapshotTagsDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<PerSnapshotCoverageDataMessage> <PerSnapshotCoverageDataMessages>k__BackingField;
    public ConcurrentBag`1<ModuleMessages> ModulesMessages { get; public set; }
    public ConcurrentDictionary`2<string, ModuleSkippedMessage> SkippedModuleMessages { get; }
    public ConcurrentDictionary`2<Guid, Byte[]> CoverageBuffers { get; public set; }
    public ConcurrentBag`1<SnapshotTagsDataMessage> SnapshotTagsDataMessages { get; }
    public ConcurrentBag`1<PerSnapshotCoverageDataMessage> PerSnapshotCoverageDataMessages { get; }
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<ModuleMessages> get_ModulesMessages();
    [CompilerGeneratedAttribute]
public void set_ModulesMessages(ConcurrentBag`1<ModuleMessages> value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ModuleSkippedMessage> get_SkippedModuleMessages();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<Guid, Byte[]> get_CoverageBuffers();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffers(ConcurrentDictionary`2<Guid, Byte[]> value);
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<SnapshotTagsDataMessage> get_SnapshotTagsDataMessages();
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<PerSnapshotCoverageDataMessage> get_PerSnapshotCoverageDataMessages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageFileReader : object {
    private ICoverageHeaderReader _headerReader;
    private ICoverageMessagesReader _messagesReaderV1;
    private ICoverageMessagesReader _messagesReaderV2;
    private IMessagesProcessor _messagesProcessor;
    [NullableAttribute("2")]
private ILogger _logger;
    public CoverageFileReader(ICoverageHeaderReader headerReader, ICoverageMessagesReader messagesReaderV1, ICoverageMessagesReader messagesReaderV2, IMessagesProcessor messagesProcessor, ILogger logger);
    private ICoverageMessagesReader GetMessagesReader(ushort schemaVersion);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFileReader/<ReadCoverageFileAsync>d__7")]
public sealed virtual Task`1<CoverageFileMessages> ReadCoverageFileAsync(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual CoverageFileMessages ReadCoverageFile(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken cancellationToken);
    private void ProcessStream(ICoverageMessagesReader reader, StreamHeader streamHeader, Byte[] bytes, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void ProcessSkippedModuleStream(ICoverageMessagesReader reader, Byte[] bytes, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
    private void ProcessCoverageData(ICoverageMessagesReader reader, Byte[] streamBytes, Guid coverageBufferId, CoverageFileMessages coverageFileMessages);
    private void ProcessModuleDataStream(ICoverageMessagesReader reader, Byte[] bytes, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void ProcessPerSnapshotCoverageDataStream(ICoverageMessagesReader reader, Byte[] bytes, Guid identifier, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
    private void ProcessSnapshotTagsDataStream(ICoverageMessagesReader reader, Byte[] bytes, CoverageFileMessages coverageFileMessages, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageFileWriter : object {
    private ICoverageMessagesWriter _coverageMessagesWriterV1;
    private ICoverageMessagesWriter _coverageMessagesWriterV2;
    private IMessagesProcessor _messagesProcessor;
    [NullableAttribute("2")]
private ILogger _logger;
    public CoverageFileWriter(ICoverageMessagesWriter messagesWriterV1, ICoverageMessagesWriter messagesWriterV2, IMessagesProcessor messagesProcessor, ILogger logger);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFileWriter/<WriteAsync>d__5")]
public sealed virtual Task WriteAsync(string path, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFileWriter/<WriteSplitCoverageFilesAsync>d__6")]
public sealed virtual Task`1<IList`1<string>> WriteSplitCoverageFilesAsync(string outputFolder, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFileWriter/<WriteSplitCoverageFile>d__7")]
private Task WriteSplitCoverageFile(string outputFolder, ushort schemaVersion, ConcurrentBag`1<string> outputFiles, ModuleMessages module, Byte[] coverageBuffer, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void CheckPrerequisites(string path, int schemaVersion);
    private ICoverageMessagesWriter GetMessagesWriter(ushort schemaVersion);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.CoverageFileWriter/<WriteModules>d__10")]
private Task WriteModules(ICoverageMessagesWriter messagesWriter, CoverageFileMessages coverageFileMessages, ConcurrentBag`1<Byte[]> streamBytes, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    private void WriteModule(ICoverageMessagesWriter messagesWriter, ModuleMessages module, ConcurrentBag`1<Byte[]> streamBytes, CancellationToken cancellationToken);
    private void WriteModuleCoverageData(ICoverageMessagesWriter messagesWriter, Guid coverageBufferId, Byte[] coverageBuffer, ConcurrentBag`1<Byte[]> streamBytes, CancellationToken cancellationToken);
    private void WriteSkippedModuleData(ICoverageMessagesWriter messagesWriter, ICollection`1<ModuleSkippedMessage> moduleMessages, ConcurrentBag`1<Byte[]> streamBytes, CancellationToken cancellationToken);
    private void WritePerSnapshotData(ICoverageMessagesWriter messagesWriter, CoverageFileMessages coverageFileMessages, ConcurrentBag`1<Byte[]> streamBytes, CancellationToken cancellationToken);
    private void WriteStream(Guid streamType, Guid identifier, ConcurrentBag`1<Byte[]> streamBytes, Action`1<BinaryWriter> writeStreamData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageHeaderReader : object {
    [NullableAttribute("2")]
private ILogger _logger;
    [NullableContextAttribute("2")]
public CoverageHeaderReader(ILogger logger);
    public sealed virtual FileHeader ReadFileHeader(BinaryReader reader);
    public sealed virtual StreamHeader ReadStreamHeader(BinaryReader reader);
    public sealed virtual CoverageStreamHandle[] ReadStreamHeaders(BinaryReader reader, UInt32 streamsCount, CancellationToken cancellationToken);
    public sealed virtual Byte[] ReadStreamBytes(BinaryReader reader, CoverageStreamHandle streamHeader);
    private void ValidateFileHeader(FileHeader fileHeader);
    private void ValidateStreamHeader(StreamHeader streamHeader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesReader : object {
    [NullableAttribute("2")]
private ILogger _logger;
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
protected CoverageMessagesReader(ILogger logger);
    protected abstract virtual ushort get_SchemaVersion();
    public sealed virtual IList`1<ModuleSkippedMessage> ReadSkippedModules(Byte[] bytes, CancellationToken cancellationToken);
    public sealed virtual ModuleMessages ReadModuleData(Byte[] bytes, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public sealed virtual Byte[] ReadCoverageData(Byte[] bytes);
    public sealed virtual PerSnapshotCoverageDataMessage ReadPerSnapshotCoverageData(Byte[] bytes, Guid identifier, CancellationToken cancellationToken);
    public sealed virtual SnapshotTagsDataMessage ReadSnapshotTagsData(Byte[] bytes, CancellationToken cancellationToken);
    public sealed virtual CoverageBufferData ReadCoverageBufferData(Byte[] bytes, Guid identifier);
    private TResult ReadData(Byte[] bytes, Func`2<CoverageFileMessageReader, TResult> action);
}
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesReaderV1 : CoverageMessagesReader {
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesReaderV1(ILogger logger);
    protected virtual ushort get_SchemaVersion();
}
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesReaderV2 : CoverageMessagesReader {
    protected ushort SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesReaderV2(ILogger logger);
    protected virtual ushort get_SchemaVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesWriter : object {
    [NullableAttribute("2")]
private ILogger _logger;
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
protected CoverageMessagesWriter(ILogger logger);
    protected abstract virtual int get_SchemaVersion();
    public sealed virtual void WriteModulesSkippedStream(BinaryWriter writer, IEnumerable`1<ModuleSkippedMessage> moduleMessages, CancellationToken cancellationToken);
    public sealed virtual void WriteCoverageDataStream(BinaryWriter writer, Byte[] coverageBuffer, CancellationToken cancellationToken);
    public sealed virtual void WriteModuleDataStream(BinaryWriter writer, ModuleMessages module, CancellationToken cancellationToken);
    public sealed virtual void WritePerSnapshotCoverageDataStream(BinaryWriter writer, PerSnapshotCoverageDataMessage perSnapshotCoverageDataMessage, CancellationToken cancellationToken);
    public sealed virtual void WriteSnapshotTagsDataStream(BinaryWriter writer, SnapshotTagsDataMessage tests, CancellationToken cancellationToken);
}
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesWriterV1 : CoverageMessagesWriter {
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesWriterV1(ILogger logger);
    protected virtual int get_SchemaVersion();
}
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageMessagesWriterV2 : CoverageMessagesWriter {
    protected int SchemaVersion { get; }
    [NullableContextAttribute("2")]
public CoverageMessagesWriterV2(ILogger logger);
    protected virtual int get_SchemaVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeCoverage.IO.Coverage.CoverageStatistics : object {
    [CompilerGeneratedAttribute]
private UInt32 <BlocksCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlocksNotCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesPartiallyCovered>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinesNotCovered>k__BackingField;
    [XmlAttributeAttribute("block_coverage")]
public string BlockCoverage { get; public set; }
    [XmlAttributeAttribute("line_coverage")]
public string LineCoverage { get; public set; }
    [XmlAttributeAttribute("blocks_covered")]
public UInt32 BlocksCovered { get; public set; }
    [XmlAttributeAttribute("blocks_not_covered")]
public UInt32 BlocksNotCovered { get; public set; }
    [XmlAttributeAttribute("lines_covered")]
public UInt32 LinesCovered { get; public set; }
    [XmlAttributeAttribute("lines_partially_covered")]
public UInt32 LinesPartiallyCovered { get; public set; }
    [XmlAttributeAttribute("lines_not_covered")]
public UInt32 LinesNotCovered { get; public set; }
    public string get_BlockCoverage();
    public void set_BlockCoverage(string value);
    public string get_LineCoverage();
    public void set_LineCoverage(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlocksCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlocksNotCovered();
    [CompilerGeneratedAttribute]
public void set_BlocksNotCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesCovered();
    [CompilerGeneratedAttribute]
public void set_LinesCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesPartiallyCovered();
    [CompilerGeneratedAttribute]
public void set_LinesPartiallyCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinesNotCovered();
    [CompilerGeneratedAttribute]
public void set_LinesNotCovered(UInt32 value);
    internal void ResetStatistics();
}
internal class Microsoft.CodeCoverage.IO.Coverage.CoverageStreamHandle : ValueType {
    [CompilerGeneratedAttribute]
private StreamHeader <StreamHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    public StreamHeader StreamHeader { get; public set; }
    public long Start { get; public set; }
    public CoverageStreamHandle(StreamHeader StreamHeader, long Start);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public StreamHeader get_StreamHeader();
    [CompilerGeneratedAttribute]
public void set_StreamHeader(StreamHeader value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageStreamHandle left, CoverageStreamHandle right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CoverageStreamHandle left, CoverageStreamHandle right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageStreamHandle other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(StreamHeader& StreamHeader, Int64& Start);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Function : CoverageStatistics {
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BlockLineData> <LineData>k__BackingField;
    [XmlAttributeAttribute("id")]
public UInt32 Id { get; public set; }
    [XmlIgnoreAttribute]
public UInt32 MetadataToken { get; public set; }
    [XmlAttributeAttribute("token")]
public string TokenString { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("namespace")]
public string NamespaceName { get; public set; }
    [XmlAttributeAttribute("type_name")]
public string TypeName { get; public set; }
    [XmlArrayAttribute("ranges")]
[XmlArrayItemAttribute("range")]
public List`1<BlockLineData> LineData { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    public string get_TokenString();
    public void set_TokenString(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public List`1<BlockLineData> get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(List`1<BlockLineData> value);
    public bool ShouldSerializeNamespaceName();
    public bool ShouldSerializeTokenString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.FunctionWrapper : object {
    private static UInt32 PartiallyCovered;
    private static UInt32 Covered;
    private static UInt32 NotCovered;
    private static UInt32 Unknown;
    [CompilerGeneratedAttribute]
private Function <Function>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockLineData[] <LineDataOriginal>k__BackingField;
    public Function Function { get; public set; }
    public UInt32 Id { get; public set; }
    public UInt32 MetadataToken { get; public set; }
    public string Name { get; public set; }
    public string NamespaceName { get; public set; }
    public string TypeName { get; public set; }
    public UInt32 StartBlockIndex { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public BlockLineData[] LineDataOriginal { get; public set; }
    [CompilerGeneratedAttribute]
public Function get_Function();
    [CompilerGeneratedAttribute]
public void set_Function(Function value);
    public UInt32 get_Id();
    public void set_Id(UInt32 value);
    public UInt32 get_MetadataToken();
    public void set_MetadataToken(UInt32 value);
    public string get_Name();
    public void set_Name(string value);
    public string get_NamespaceName();
    public void set_NamespaceName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
public void set_StartBlockIndex(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
public BlockLineData[] get_LineDataOriginal();
    [CompilerGeneratedAttribute]
public void set_LineDataOriginal(BlockLineData[] value);
    internal void Merge(Byte[] buffer, UInt32 offset, UInt32 count);
    public void CalculateStatistics();
    private UInt32[] CalculateStatistics(IList`1<BasicBlockInfo> blockInfos);
    private bool FasterAlgorithm(IList`1<BasicBlockInfo> blockInfos, UInt32[]& statistics);
    private UInt32[] SlowerAlgorithm(IList`1<BasicBlockInfo> blockInfos);
    private bool IsCovered(UInt32 blockIndex);
}
public interface Microsoft.CodeCoverage.IO.Coverage.ICoverageFileConfiguration {
    public bool ReadModules { get; }
    public bool ReadSkippedModules { get; }
    public bool ReadSkippedFunctions { get; }
    public bool ReadSnapshotsData { get; }
    public bool GenerateCoverageBufferFiles { get; }
    public bool FixCoverageBuffersMismatch { get; }
    public int MaxDegreeOfParallelism { get; }
    public abstract virtual bool get_ReadModules();
    public abstract virtual bool get_ReadSkippedModules();
    public abstract virtual bool get_ReadSkippedFunctions();
    public abstract virtual bool get_ReadSnapshotsData();
    public abstract virtual bool get_GenerateCoverageBufferFiles();
    public abstract virtual bool get_FixCoverageBuffersMismatch();
    public abstract virtual int get_MaxDegreeOfParallelism();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.ICoverageFileReader {
    public abstract virtual CoverageFileMessages ReadCoverageFile(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Task`1<CoverageFileMessages> ReadCoverageFileAsync(string path, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.ICoverageFileWriter {
    public abstract virtual Task WriteAsync(string path, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<string>> WriteSplitCoverageFilesAsync(string outputFolder, ushort schemaVersion, CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.ICoverageHeaderReader {
    public abstract virtual FileHeader ReadFileHeader(BinaryReader reader);
    public abstract virtual StreamHeader ReadStreamHeader(BinaryReader reader);
    public abstract virtual CoverageStreamHandle[] ReadStreamHeaders(BinaryReader reader, UInt32 streamsCount, CancellationToken cancellationToken);
    public abstract virtual Byte[] ReadStreamBytes(BinaryReader reader, CoverageStreamHandle streamHeader);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.ICoverageMessagesReader {
    public abstract virtual IList`1<ModuleSkippedMessage> ReadSkippedModules(Byte[] bytes, CancellationToken cancellationToken);
    public abstract virtual ModuleMessages ReadModuleData(Byte[] bytes, ICoverageFileConfiguration coverageFileConfiguration, CancellationToken cancellationToken);
    public abstract virtual Byte[] ReadCoverageData(Byte[] bytes);
    public abstract virtual PerSnapshotCoverageDataMessage ReadPerSnapshotCoverageData(Byte[] bytes, Guid identifier, CancellationToken cancellationToken);
    public abstract virtual SnapshotTagsDataMessage ReadSnapshotTagsData(Byte[] bytes, CancellationToken cancellationToken);
    public abstract virtual CoverageBufferData ReadCoverageBufferData(Byte[] bytes, Guid identifier);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.ICoverageMessagesWriter {
    public abstract virtual void WriteModulesSkippedStream(BinaryWriter writer, IEnumerable`1<ModuleSkippedMessage> moduleMessages, CancellationToken cancellationToken);
    public abstract virtual void WriteCoverageDataStream(BinaryWriter writer, Byte[] coverageBuffer, CancellationToken cancellationToken);
    public abstract virtual void WriteModuleDataStream(BinaryWriter writer, ModuleMessages module, CancellationToken cancellationToken);
    public abstract virtual void WritePerSnapshotCoverageDataStream(BinaryWriter writer, PerSnapshotCoverageDataMessage perSnapshotCoverageDataMessages, CancellationToken cancellationToken);
    public abstract virtual void WriteSnapshotTagsDataStream(BinaryWriter writer, SnapshotTagsDataMessage tests, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeCoverage.IO.Coverage.MessagesHelpers : object {
    [ExtensionAttribute]
public static UInt32 UpdateStartBlockIndex(FunctionInstrumentedMessage message, UInt32 newStartBlockIndex);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<ModuleMessages>> GroupByModuleIdentifierOrDefault(CoverageFileMessages coverageFileMessages);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.MessagesHelpers/<GetModuleData>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ModuleMessagesData> GetModuleData(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
public static CoverageReport ToCoverageReportData(CoverageFileMessages coverageFileMessages);
    private static SkippedModuleData[] ToSkippedModuleReportData(CoverageFileMessages coverageFileMessages);
    private static SnapshotTag[] ToSnapshotTags(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
private static ModuleData[] ToModuleReportData(CoverageFileMessages coverageFileMessages);
    [ExtensionAttribute]
private static ModuleData ToModuleReportData(ModuleMessagesData moduleData);
    [ExtensionAttribute]
private static Dictionary`2<UInt32, SourceFileData> ToSourceFiles(IList`1<SourceFileDataMessage> messages);
    [ExtensionAttribute]
private static FunctionData[] ToFunctions(ModuleMessagesData moduleData, ModuleData module, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    [ExtensionAttribute]
internal static MultiBlockLineData[] ToMultiBlockLineData(FunctionInstrumentedMessage message, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    internal static MultiBlockLineData[] MergeMultiBlockLineData(IEnumerable`1<MultiBlockLineData> lines);
    [ExtensionAttribute]
private static SkippedFunctionData[] ToSkippedFunctions(IList`1<FunctionSkippedMessage> messages);
    private static void PopulatePerSnapshotCoverageBuffers(CoverageFileMessages coverageFileMessages, Guid identifier, ModuleData module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Module : CoverageStatistics {
    private bool _includeSkippedFunctions;
    private string _id;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdString>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Function> <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedFunction> <SkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SourceFile> <SourceFiles>k__BackingField;
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("path")]
public string Path { get; public set; }
    [XmlIgnoreAttribute]
public string TargetFramework { get; public set; }
    [XmlIgnoreAttribute]
public string Architecture { get; public set; }
    [XmlIgnoreAttribute]
public string Configuration { get; public set; }
    [XmlIgnoreAttribute]
public string Id { get; public set; }
    [XmlAttributeAttribute("id")]
public string IdString { get; public set; }
    [XmlArrayAttribute("functions")]
[XmlArrayItemAttribute("function")]
public List`1<Function> Functions { get; public set; }
    [XmlArrayAttribute("skipped_functions")]
[XmlArrayItemAttribute("skipped_function")]
public List`1<SkippedFunction> SkippedFunctions { get; public set; }
    [XmlArrayAttribute("source_files")]
[XmlArrayItemAttribute("source_file")]
public List`1<SourceFile> SourceFiles { get; public set; }
    public Module(string id, bool includeSkippedFunctions);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public string get_Architecture();
    [CompilerGeneratedAttribute]
public void set_Architecture(string value);
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    public string get_Id();
    public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_IdString();
    [CompilerGeneratedAttribute]
public void set_IdString(string value);
    [CompilerGeneratedAttribute]
public List`1<Function> get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(List`1<Function> value);
    [CompilerGeneratedAttribute]
public List`1<SkippedFunction> get_SkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_SkippedFunctions(List`1<SkippedFunction> value);
    [CompilerGeneratedAttribute]
public List`1<SourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(List`1<SourceFile> value);
    public bool ShouldSerializeSkipFunctions();
    public bool ShouldSerializeSourceFiles();
    public bool ShouldSerializeSkippedFunctions();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.ModuleHandle : object {
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <End>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RawData>k__BackingField;
    internal ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    [NullableAttribute("1")]
internal string Path { get; }
    internal long Start { get; }
    internal long End { get; }
    internal long Offset { get; }
    internal Byte[] CoverageBuffer { get; internal set; }
    internal string Hash { get; internal set; }
    internal Byte[] RawData { get; internal set; }
    [NullableContextAttribute("1")]
internal ModuleHandle(string path, ModuleInstrumentedMessage moduleInstrumentedMessage, long start, long end, long offset);
    [CompilerGeneratedAttribute]
internal ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal long get_Start();
    [CompilerGeneratedAttribute]
internal long get_End();
    [CompilerGeneratedAttribute]
internal long get_Offset();
    [CompilerGeneratedAttribute]
internal Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
internal string get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_RawData();
    [CompilerGeneratedAttribute]
internal void set_RawData(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.ModuleMessages : ValueType {
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionInstrumentedMessage> <FunctionInstrumentedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FunctionSkippedMessage> <FunctionSkippedMessages>k__BackingField;
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; public set; }
    public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; public set; }
    public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; public set; }
    public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; public set; }
    public ModuleMessages(ModuleInstrumentedMessage ModuleInstrumentedMessage, IList`1<SourceFileDataMessage> SourceFileDataMessages, IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages, IList`1<FunctionSkippedMessage> FunctionSkippedMessages);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
public void set_ModuleInstrumentedMessage(ModuleInstrumentedMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public void set_SourceFileDataMessages(IList`1<SourceFileDataMessage> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [CompilerGeneratedAttribute]
public void set_FunctionInstrumentedMessages(IList`1<FunctionInstrumentedMessage> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [CompilerGeneratedAttribute]
public void set_FunctionSkippedMessages(IList`1<FunctionSkippedMessage> value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleMessages left, ModuleMessages right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleMessages left, ModuleMessages right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleMessages other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleInstrumentedMessage& ModuleInstrumentedMessage, IList`1& SourceFileDataMessages, IList`1& FunctionInstrumentedMessages, IList`1& FunctionSkippedMessages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.ModuleMessagesData : object {
    [CompilerGeneratedAttribute]
private ModuleMessages <ModuleMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ModuleMessages ModuleMessages { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public ModuleMessagesData(ModuleMessages ModuleMessages, Byte[] CoverageBuffer);
    [CompilerGeneratedAttribute]
protected ModuleMessagesData(ModuleMessagesData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ModuleMessages get_ModuleMessages();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ModuleMessages(ModuleMessages value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleMessagesData left, ModuleMessagesData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ModuleMessagesData left, ModuleMessagesData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ModuleMessagesData other);
    [CompilerGeneratedAttribute]
public virtual ModuleMessagesData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ModuleMessages& ModuleMessages, Byte[]& CoverageBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.ModuleWrapper : object {
    private UInt32 _nextSourceFileId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<ValueTuple`2<UInt32, UInt32>, FunctionInstrumentedMessage> _functionInstrumentedMessagesMap;
    private IDictionary`2<UInt32, FunctionSkippedMessage> _functionSkippedMessagesMap;
    private IDictionary`2<string, UInt32> _sourcePathToIdMap;
    private IDictionary`2<UInt32, SourceFile> _sourceFiles;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<ValueTuple`2<UInt32, UInt32>, SkippedFunction> _skippedFunctions;
    private Byte[] _emptyCoverageBuffer;
    [CompilerGeneratedAttribute]
private Module <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<ValueTuple`2<UInt32, UInt32>, FunctionWrapper> <FunctionWrappers>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <CoverageBuffers>k__BackingField;
    public Module Module { get; public set; }
    public string Id { get; public set; }
    public string IdString { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    public string TargetFramework { get; public set; }
    public string Architecture { get; public set; }
    public string Configuration { get; public set; }
    public UInt32 BlocksCovered { get; public set; }
    public UInt32 BlocksNotCovered { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public UInt32 BlockCount { get; public set; }
    public List`1<Function> Functions { get; public set; }
    public List`1<SkippedFunction> SkippedFunctions { get; public set; }
    public List`1<SourceFile> SourceFiles { get; public set; }
    internal ICollection`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    internal IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<ValueTuple`2<UInt32, UInt32>, FunctionWrapper> FunctionWrappers { get; }
    public UInt32 ImageLinkTime { get; }
    public UInt32 ImageSize { get; }
    internal ModuleInstrumentedMessage ModuleInstrumentedMessage { get; internal set; }
    internal ICollection`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    internal IDictionary`2<string, Byte[]> CoverageBuffers { get; }
    internal ModuleWrapper(string id, bool includeSkippedFunctions, ModuleInstrumentedMessage moduleInstrumentedMessage);
    [CompilerGeneratedAttribute]
public Module get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(Module value);
    public string get_Id();
    public void set_Id(string value);
    public string get_IdString();
    public void set_IdString(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Path();
    public void set_Path(string value);
    public string get_TargetFramework();
    public void set_TargetFramework(string value);
    public string get_Architecture();
    public void set_Architecture(string value);
    public string get_Configuration();
    public void set_Configuration(string value);
    public UInt32 get_BlocksCovered();
    public void set_BlocksCovered(UInt32 value);
    public UInt32 get_BlocksNotCovered();
    public void set_BlocksNotCovered(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
public void set_BlockCount(UInt32 value);
    public List`1<Function> get_Functions();
    public void set_Functions(List`1<Function> value);
    public List`1<SkippedFunction> get_SkippedFunctions();
    public void set_SkippedFunctions(List`1<SkippedFunction> value);
    public List`1<SourceFile> get_SourceFiles();
    public void set_SourceFiles(List`1<SourceFile> value);
    internal ICollection`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [CompilerGeneratedAttribute]
internal IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public IDictionary`2<ValueTuple`2<UInt32, UInt32>, FunctionWrapper> get_FunctionWrappers();
    public UInt32 get_ImageLinkTime();
    public UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
internal ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [CompilerGeneratedAttribute]
internal void set_ModuleInstrumentedMessage(ModuleInstrumentedMessage value);
    internal ICollection`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, Byte[]> get_CoverageBuffers();
    public void ClearObjects();
    public ValueTuple`2<SourceFile, bool> AddSourceFile(string path, SourceFileCheckSumType checksumType, Byte[] checksum);
    public SourceFile GetSourceFile(UInt32 id);
    public ValueTuple`2<SkippedFunction, bool> AddSkippedFunction(bool checkInFunctions, UInt32 functionId, UInt32 originalFunctionId, UInt32 metadataToken, FunctionSkipReason functionSkipReason, string name, string typeName, string exceptionMessage);
    internal void RemoveSkippedFunction(UInt32 functionId, UInt32 metadataToken);
    internal ValueTuple`2<FunctionWrapper, bool> AddFunction(UInt32 functionId, UInt32 metadataToken, string name, string typeName, string namespaceName, UInt32 blockCount);
    internal ValueTuple`2<FunctionWrapper, bool> AddFunction(FunctionWrapper function);
    internal void AddFunctionSkippedMessage(FunctionSkippedMessage message);
    internal Nullable`1<FunctionSkippedMessage> GetFunctionSkippedMessage(UInt32 functionId);
    internal void ClearFunctionSkippedMessages();
    internal void AddFunctionInstrumentedMessage(FunctionInstrumentedMessage message);
    [NullableContextAttribute("2")]
internal FunctionInstrumentedMessage GetFunctionInstrumentedMessage(UInt32 functionId, UInt32 metadataToken);
    internal void RemoveFunctionInstrumentedMessage(UInt32 functionId, UInt32 metadataToken);
    internal void UpdateFunctionInstrumentedMessage(FunctionInstrumentedMessage message);
    internal Byte[] GetCoverageBuffer(IList`1<string> testIds);
    internal Byte[] GetCoverageBuffer(SnapshotTag snapshotTag);
    public void CalculateStatistics();
    private void PopulateObjectsFromMessages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.PerSnapshotCoverageDataMessage : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotIdsDataMessage <SnapshotIds>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageBufferHashMessage <BufferHashMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    public Guid Identifier { get; public set; }
    public SnapshotIdsDataMessage SnapshotIds { get; public set; }
    public CoverageBufferHashMessage BufferHashMessage { get; public set; }
    public Byte[] CoverageBuffer { get; public set; }
    public PerSnapshotCoverageDataMessage(Guid Identifier, SnapshotIdsDataMessage SnapshotIds, CoverageBufferHashMessage BufferHashMessage, Byte[] CoverageBuffer);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SnapshotIdsDataMessage get_SnapshotIds();
    [CompilerGeneratedAttribute]
public void set_SnapshotIds(SnapshotIdsDataMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CoverageBufferHashMessage get_BufferHashMessage();
    [CompilerGeneratedAttribute]
public void set_BufferHashMessage(CoverageBufferHashMessage value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
public void set_CoverageBuffer(Byte[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PerSnapshotCoverageDataMessage left, PerSnapshotCoverageDataMessage right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PerSnapshotCoverageDataMessage left, PerSnapshotCoverageDataMessage right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PerSnapshotCoverageDataMessage other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(Guid& Identifier, SnapshotIdsDataMessage& SnapshotIds, CoverageBufferHashMessage& BufferHashMessage, Byte[]& CoverageBuffer);
}
internal class Microsoft.CodeCoverage.IO.Coverage.Processor.CoverageBufferAdjuster : object {
    [NullableContextAttribute("1")]
public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
    [NullableContextAttribute("1")]
internal Byte[] AdjustCoverageBuffer(ModuleMessages moduleMessages, Byte[] coverageBuffer);
}
internal class Microsoft.CodeCoverage.IO.Coverage.Processor.DuplicateModuleRemover : object {
    [NullableContextAttribute("1")]
public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.Coverage.Processor.IMessagesProcessor {
    public abstract virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.Processor.MessagesProcessor : object {
    private IMessagesProcessor[] _messagesProcessors;
    public MessagesProcessor(IMessagesProcessor[] messagesProcessors);
    public static MessagesProcessor GetDefaultMessageProcessor();
    public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.Coverage.Processor.ModuleDataMerger : object {
    public sealed virtual CoverageFileMessages Process(CoverageFileMessages coverageFileMessages, ICoverageFileConfiguration coverageFileConfiguration);
    private IEnumerable`1<ModuleMessagesData> GetModuleData(ConcurrentDictionary`2<Guid, Byte[]> coverageBuffers, IList`1<ModuleMessages> modules);
    private ModuleMessagesData GetModuleData(ConcurrentDictionary`2<Guid, Byte[]> coverageBuffers, ModuleMessages moduleMessages);
    private bool ContainsUniqueFunctionsOnly(IList`1<ModuleMessagesData> modules);
    internal ModuleMessagesData MergeModules(IList`1<ModuleMessagesData> modules);
    private static Dictionary`2<ValueTuple`2<UInt32, int>, UInt32> MergeSourceFiles(IList`1<ModuleMessagesData> modules, UniqueModuleMessages finalMessages);
    private static Byte[] MergeFunctions(IList`1<ModuleMessagesData> modules, UniqueModuleMessages messages, Dictionary`2<ValueTuple`2<UInt32, int>, UInt32> oldIdToNewIdMap);
    private static void MergeSkippedFunctions(IList`1<ModuleMessagesData> modules, UniqueModuleMessages messages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.CoverageLineData : object {
    [CompilerGeneratedAttribute]
private UInt32 <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private CoverageStatus <CoverageStatus>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [XmlAttributeAttribute("start_line")]
public UInt32 StartLine { get; public set; }
    [XmlAttributeAttribute("start_column")]
public UInt32 StartColumn { get; public set; }
    [XmlAttributeAttribute("end_line")]
public UInt32 EndLine { get; public set; }
    [XmlAttributeAttribute("end_column")]
public UInt32 EndColumn { get; public set; }
    [XmlAttributeAttribute("covered")]
public CoverageStatus CoverageStatus { get; public set; }
    public CoverageLineData(UInt32 StartLine, UInt32 StartColumn, UInt32 EndLine, UInt32 EndColumn);
    internal CoverageLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, CoverageStatus coverageStatus);
    [CompilerGeneratedAttribute]
protected CoverageLineData(CoverageLineData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UInt32 get_StartLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_StartColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StartColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndLine(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_EndColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EndColumn(UInt32 value);
    [CompilerGeneratedAttribute]
public CoverageStatus get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(CoverageStatus value);
    internal void MergeCoverageStatus(CoverageStatus otherCoverageStatus);
    public virtual bool Equals(CoverageLineData other);
    public virtual int GetHashCode();
    internal static int CompareTo(CoverageLineData first, CoverageLineData second);
    public sealed virtual int CompareTo(CoverageLineData other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageLineData left, CoverageLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CoverageLineData left, CoverageLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual CoverageLineData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(UInt32& StartLine, UInt32& StartColumn, UInt32& EndLine, UInt32& EndColumn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.CoverageReport : ValueType {
    [CompilerGeneratedAttribute]
private ModuleData[] <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private SnapshotTag[] <SnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedModuleData[] <SkippedModules>k__BackingField;
    public ModuleData[] Modules { get; public set; }
    public SnapshotTag[] SnapshotTags { get; public set; }
    public SkippedModuleData[] SkippedModules { get; public set; }
    public CoverageReport(ModuleData[] Modules, SnapshotTag[] SnapshotTags, SkippedModuleData[] SkippedModules);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ModuleData[] get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(ModuleData[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SnapshotTag[] get_SnapshotTags();
    [CompilerGeneratedAttribute]
public void set_SnapshotTags(SnapshotTag[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SkippedModuleData[] get_SkippedModules();
    [CompilerGeneratedAttribute]
public void set_SkippedModules(SkippedModuleData[] value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CoverageReport left, CoverageReport right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CoverageReport left, CoverageReport right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageReport other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ModuleData[]& Modules, SnapshotTag[]& SnapshotTags, SkippedModuleData[]& SkippedModules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.FunctionData : CoverageStatistics {
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiBlockLineData[] <LineData>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StartBlockIndex>k__BackingField;
    [XmlAttributeAttribute("id")]
public UInt32 Id { get; public set; }
    [XmlIgnoreAttribute]
public UInt32 MetadataToken { get; public set; }
    [XmlAttributeAttribute("token")]
public string TokenString { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("namespace")]
public string NamespaceName { get; public set; }
    [XmlAttributeAttribute("type_name")]
public string TypeName { get; public set; }
    [XmlArrayAttribute("ranges")]
[XmlArrayItemAttribute("range")]
public MultiBlockLineData[] LineData { get; public set; }
    [XmlIgnoreAttribute]
internal UInt32 BlockCount { get; internal set; }
    [XmlIgnoreAttribute]
internal UInt32 StartBlockIndex { get; internal set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    public string get_TokenString();
    public void set_TokenString(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public MultiBlockLineData[] get_LineData();
    [CompilerGeneratedAttribute]
public void set_LineData(MultiBlockLineData[] value);
    [CompilerGeneratedAttribute]
internal UInt32 get_BlockCount();
    [CompilerGeneratedAttribute]
internal void set_BlockCount(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_StartBlockIndex();
    [CompilerGeneratedAttribute]
internal void set_StartBlockIndex(UInt32 value);
    public bool ShouldSerializeNamespaceName();
    public bool ShouldSerializeTokenString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.ModuleData : CoverageStatistics {
    private Byte[] _emptyCoverageBuffer;
    [CompilerGeneratedAttribute]
private Byte[] <CoverageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Byte[]> <CoverageBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageLinkTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionData[] <Functions>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileData[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedFunctionData[] <SkippedFunctions>k__BackingField;
    internal Byte[] CoverageBuffer { get; }
    internal IDictionary`2<string, Byte[]> CoverageBuffers { get; }
    [XmlIgnoreAttribute]
internal string Id { get; }
    [XmlAttributeAttribute("id")]
public string IdString { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("path")]
public string Path { get; public set; }
    [XmlIgnoreAttribute]
internal UInt32 ImageLinkTime { get; internal set; }
    [XmlIgnoreAttribute]
internal UInt32 ImageSize { get; internal set; }
    [XmlArrayAttribute("functions")]
[XmlArrayItemAttribute("function")]
public FunctionData[] Functions { get; public set; }
    [XmlArrayAttribute("source_files")]
[XmlArrayItemAttribute("source_file")]
public SourceFileData[] SourceFiles { get; public set; }
    [XmlArrayAttribute("skipped_functions")]
[XmlArrayItemAttribute("skipped_function")]
public SkippedFunctionData[] SkippedFunctions { get; public set; }
    public ModuleData(string id, string name, UInt32 imageLinkTime, UInt32 imageSize, Byte[] coverageBuffer);
    [CompilerGeneratedAttribute]
internal Byte[] get_CoverageBuffer();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, Byte[]> get_CoverageBuffers();
    [CompilerGeneratedAttribute]
internal string get_Id();
    [CompilerGeneratedAttribute]
public string get_IdString();
    [CompilerGeneratedAttribute]
public void set_IdString(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ImageLinkTime();
    [CompilerGeneratedAttribute]
internal void set_ImageLinkTime(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ImageSize();
    [CompilerGeneratedAttribute]
internal void set_ImageSize(UInt32 value);
    [CompilerGeneratedAttribute]
public FunctionData[] get_Functions();
    [CompilerGeneratedAttribute]
public void set_Functions(FunctionData[] value);
    [CompilerGeneratedAttribute]
public SourceFileData[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(SourceFileData[] value);
    [CompilerGeneratedAttribute]
public SkippedFunctionData[] get_SkippedFunctions();
    [CompilerGeneratedAttribute]
public void set_SkippedFunctions(SkippedFunctionData[] value);
    public void ApplyDefaultCoverage();
    public void ApplySnapshotCoverage(SnapshotTag[] snapshotTags);
    internal Byte[] GetCoverageBuffer(SnapshotTag snapshotTag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.MultiBlockLineData : CoverageLineData {
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IList`1<UInt32> <AdditionalBlockIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileData <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [XmlIgnoreAttribute]
internal UInt32 Index { get; internal set; }
    [NullableAttribute("2")]
internal IList`1<UInt32> AdditionalBlockIndexes { get; internal set; }
    internal IEnumerable`1<UInt32> BlockIndexes { get; }
    [XmlIgnoreAttribute]
internal SourceFileData SourceFile { get; internal set; }
    [XmlAttributeAttribute("source_id")]
public UInt32 SourceId { get; public set; }
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, UInt32 blockIndex, CoverageStatus coverageStatus);
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, SourceFileData sourceFile, CoverageStatus coverageStatus);
    public MultiBlockLineData(UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn, UInt32 blockIndex, SourceFileData sourceFile);
    [CompilerGeneratedAttribute]
private MultiBlockLineData(MultiBlockLineData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
internal UInt32 get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(UInt32 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IList`1<UInt32> get_AdditionalBlockIndexes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_AdditionalBlockIndexes(IList`1<UInt32> value);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.IO.Coverage.Report.MultiBlockLineData/<get_BlockIndexes>d__15")]
internal IEnumerable`1<UInt32> get_BlockIndexes();
    [CompilerGeneratedAttribute]
internal SourceFileData get_SourceFile();
    [CompilerGeneratedAttribute]
internal void set_SourceFile(SourceFileData value);
    public UInt32 get_SourceId();
    public void set_SourceId(UInt32 value);
    public virtual string ToString();
    public sealed virtual int CompareTo(MultiBlockLineData other);
    public sealed virtual bool Equals(MultiBlockLineData other);
    public static bool op_LessThan(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_LessThanOrEqual(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_GreaterThan(MultiBlockLineData left, MultiBlockLineData right);
    public static bool op_GreaterThanOrEqual(MultiBlockLineData left, MultiBlockLineData right);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MultiBlockLineData left, MultiBlockLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MultiBlockLineData left, MultiBlockLineData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CoverageLineData other);
    [CompilerGeneratedAttribute]
public virtual CoverageLineData <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SkippedFunctionData : object {
    [NullableAttribute("2")]
private string _tokenString;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OriginalId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionSkipReason <FunctionSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [XmlAttributeAttribute("id")]
public UInt32 Id { get; public set; }
    [XmlAttributeAttribute("original_id")]
public UInt32 OriginalId { get; public set; }
    [XmlIgnoreAttribute]
public UInt32 MetadataToken { get; public set; }
    [XmlAttributeAttribute("token")]
public string TokenString { get; public set; }
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("type_name")]
public string TypeName { get; public set; }
    [XmlAttributeAttribute("reason")]
public FunctionSkipReason FunctionSkipReason { get; public set; }
    [XmlAttributeAttribute("exception_message")]
public string ExceptionMessage { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_OriginalId();
    [CompilerGeneratedAttribute]
public void set_OriginalId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(UInt32 value);
    public string get_TokenString();
    public void set_TokenString(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public FunctionSkipReason get_FunctionSkipReason();
    [CompilerGeneratedAttribute]
public void set_FunctionSkipReason(FunctionSkipReason value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    public bool ShouldSerializeOriginalId();
    public bool ShouldSerializeExceptionMessage();
    public bool ShouldSerializeTokenString();
    public static bool op_Equality(SkippedFunctionData left, SkippedFunctionData right);
    public static bool op_Inequality(SkippedFunctionData left, SkippedFunctionData right);
    public virtual bool Equals(object obj);
    private bool Equals(SkippedFunctionData other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlRootAttribute("skipped_module")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SkippedModuleData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [XmlAttributeAttribute("name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("path")]
public string Path { get; public set; }
    [XmlAttributeAttribute("reason")]
public ModuleSkipReason SkipReason { get; public set; }
    [XmlAttributeAttribute("exception_message")]
public string ExceptionMessage { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public ModuleSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(ModuleSkipReason value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    public bool ShouldSerializeExceptionMessage();
    public static bool op_Equality(SkippedModuleData left, SkippedModuleData right);
    public static bool op_Inequality(SkippedModuleData left, SkippedModuleData right);
    public virtual bool Equals(object obj);
    private bool Equals(SkippedModuleData other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.SourceFileData : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileCheckSumType <ChecksumType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Checksum>k__BackingField;
    internal static SourceFileData EmptySourceFile { get; }
    internal bool IsValid { get; }
    [XmlAttributeAttribute("id")]
public UInt32 Id { get; public set; }
    [XmlAttributeAttribute("path")]
public string Path { get; public set; }
    [XmlIgnoreAttribute]
public SourceFileCheckSumType ChecksumType { get; public set; }
    [XmlAttributeAttribute("checksum_type")]
public string ChecksumTypeString { get; public set; }
    [XmlIgnoreAttribute]
public Byte[] Checksum { get; public set; }
    [XmlAttributeAttribute("checksum")]
public string ChecksumString { get; public set; }
    public SourceFileData(string path);
    public SourceFileData(UInt32 id, string path, SourceFileCheckSumType checksumType, Byte[] checksum);
    internal static SourceFileData get_EmptySourceFile();
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public SourceFileCheckSumType get_ChecksumType();
    [CompilerGeneratedAttribute]
public void set_ChecksumType(SourceFileCheckSumType value);
    public string get_ChecksumTypeString();
    public void set_ChecksumTypeString(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(Byte[] value);
    public string get_ChecksumString();
    public void set_ChecksumString(string value);
    public bool ShouldSerializeChecksumTypeString();
    public bool ShouldSerializeChecksumString();
    public static bool op_Equality(SourceFileData left, SourceFileData right);
    public static bool op_Inequality(SourceFileData left, SourceFileData right);
    public virtual bool Equals(object obj);
    private bool Equals(SourceFileData other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlRootAttribute("results")]
public class Microsoft.CodeCoverage.IO.Coverage.Report.XmlFileData : object {
    [CompilerGeneratedAttribute]
private ModuleData[] <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private SkippedModuleData[] <SkippedModules>k__BackingField;
    [XmlArrayAttribute("modules")]
[XmlArrayItemAttribute("module")]
public ModuleData[] Modules { get; public set; }
    [XmlArrayAttribute("skipped_modules")]
[XmlArrayItemAttribute("skipped_module")]
public SkippedModuleData[] SkippedModules { get; public set; }
    [CompilerGeneratedAttribute]
public ModuleData[] get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(ModuleData[] value);
    [CompilerGeneratedAttribute]
public SkippedModuleData[] get_SkippedModules();
    [CompilerGeneratedAttribute]
public void set_SkippedModules(SkippedModuleData[] value);
    public bool ShouldSerializeModules();
    public bool ShouldSerializeSkippedModules();
}
internal class Microsoft.CodeCoverage.IO.Coverage.Segment : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CoverageStatus>k__BackingField;
    public UInt32 Left { get; public set; }
    public bool Span { get; public set; }
    public UInt32 CoverageStatus { get; public set; }
    public Segment(UInt32 left, bool span);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Span();
    [CompilerGeneratedAttribute]
public void set_Span(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_CoverageStatus();
    [CompilerGeneratedAttribute]
public void set_CoverageStatus(UInt32 value);
    public sealed virtual int CompareTo(Segment other);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class Microsoft.CodeCoverage.IO.Coverage.SkippedFunction : SkippedFunctionData {
}
[XmlRootAttribute("skipped_module")]
public class Microsoft.CodeCoverage.IO.Coverage.SkippedModule : SkippedModuleData {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.SnapshotTag : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private static SnapshotTag <AllSnapshotTags>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public String[] Properties { get; public set; }
    public static SnapshotTag AllSnapshotTags { get; }
    public SnapshotTag(string Id, string Name, String[] Properties);
    [CompilerGeneratedAttribute]
protected SnapshotTag(SnapshotTag original);
    private static SnapshotTag();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public static SnapshotTag get_AllSnapshotTags();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SnapshotTag left, SnapshotTag right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SnapshotTag left, SnapshotTag right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SnapshotTag other);
    [CompilerGeneratedAttribute]
public virtual SnapshotTag <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String[]& Properties);
}
public class Microsoft.CodeCoverage.IO.Coverage.SourceFile : SourceFileData {
    [NullableContextAttribute("1")]
public SourceFile(UInt32 id, string path, SourceFileCheckSumType checksumType, Byte[] checksum);
}
internal class Microsoft.CodeCoverage.IO.Coverage.SplitCoverageFileConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <ReadSkippedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixCoverageBuffersMismatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCoverageBufferFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfParallelism>k__BackingField;
    public bool ReadModules { get; }
    public bool ReadSkippedModules { get; }
    public bool ReadSnapshotsData { get; }
    public bool ReadSkippedFunctions { get; }
    public bool FixCoverageBuffersMismatch { get; }
    public bool GenerateCoverageBufferFiles { get; }
    public int MaxDegreeOfParallelism { get; }
    [NullableContextAttribute("1")]
public SplitCoverageFileConfiguration(ICoverageFileConfiguration coverageFileConfiguration);
    public sealed virtual bool get_ReadModules();
    public sealed virtual bool get_ReadSkippedModules();
    public sealed virtual bool get_ReadSnapshotsData();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ReadSkippedFunctions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FixCoverageBuffersMismatch();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_GenerateCoverageBufferFiles();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxDegreeOfParallelism();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.Coverage.StatisticsCalculator : object {
    public static void CalculateStatistics(FunctionData function, Byte[] coverageBuffer);
    internal static BlockCoverageStatistics GetStatistics(Byte[] coverageBuffer, IList`1<MultiBlockLineData> lines);
    internal static ValueTuple`2<UInt32, UInt32> GetBlocksStatistics(Byte[] coverageBuffer, IEnumerable`1<MultiBlockLineData> lines);
    internal static BlockCoverageStatistics GetLinesStatistics(IList`1<MultiBlockLineData> lines, UInt32 blocksCovered, UInt32 blocksNotCovered);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Coverage.TestCaseInformation : SnapshotTag {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public TestCaseInformation(string Id, string Name, String[] Properties);
    [CompilerGeneratedAttribute]
protected TestCaseInformation(TestCaseInformation original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestCaseInformation left, TestCaseInformation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestCaseInformation left, TestCaseInformation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SnapshotTag other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestCaseInformation other);
    [CompilerGeneratedAttribute]
public virtual SnapshotTag <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String[]& Properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.CoverageBufferFile : CoverageFileBase {
    private CoverageBufferData _coverageBufferData;
    private CoverageBufferFile(string path);
    public static CoverageBufferData Read(string path);
    public static CoverageBufferData ReadCoverageBufferFile(string path, CancellationToken token);
    protected virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
    private void RecordCoverageDataStream(CoverageFileMessageReader reader, Guid identifier);
    private Byte[] GetCoverageBuffer(BinaryReader reader);
    internal static void WriteModuleCoverageBufferData(string outputFolder, ModuleWrapper module, Byte[] coverageBuffer);
    internal static void WriteModuleCoverageBufferData(string outputFolder, string moduleName, UInt32 imageLinkTime, UInt32 blockCount, Guid coverageBufferId, Byte[] coverageBuffer);
    internal static void WriteModuleCoverageBufferData(string outputPath, string moduleName, UInt32 imageLinkTime, Guid coverageBufferId, Byte[] coverageBuffer);
    private static void WriteBufferData(BinaryWriter writer, ModuleBufferMessage message, Byte[] coverageBuffer, Guid coverageBufferId);
    internal static Byte[] MergeCoverageBuffer(IEnumerable`1<string> bufferFiles, bool skipInvalidFiles, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.CoverageFile : CoverageFileBase {
    private bool _cacheCoverageMessages;
    [CompilerGeneratedAttribute]
private CoverageData <CoverageData>k__BackingField;
    internal CoverageData CoverageData { get; private set; }
    internal CoverageFile(CoverageData coverageData);
    [NullableContextAttribute("2")]
private CoverageFile(string path, bool cacheCoverageMessages);
    [CompilerGeneratedAttribute]
internal CoverageData get_CoverageData();
    [CompilerGeneratedAttribute]
private void set_CoverageData(CoverageData value);
    public long GetModuleCoverageBufferOffset(string moduleName, UInt32 moduleLinkTime);
    public void UpdateModuleCoverageBuffer(long offset, Byte[] coverageBuffer);
    public static string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<MergeCoverageBufferFilesAsync>d__11")]
public static Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token, bool skipInvalidFiles);
    private static string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public static CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int maxTaskCount, bool loadAllModuleData);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<MergeCoverageFilesAsync>d__14")]
public static Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token, bool skipInvalidFiles, int taskCount, bool loadAllModuleData);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<MergeCoverageFilesAsync>d__15")]
internal static Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<ValueTuple`2<string, CoverageFile>> files, CancellationToken token, bool skipInvalidFiles, int taskCount, bool loadAllModuleData);
    [NullableContextAttribute("2")]
internal static CoverageFile GetCoverageFile(ValueTuple`2<string, CoverageFile> file, bool skipInvalidFiles, CancellationToken token);
    private static CoverageFile Merge(CoverageFile file1, CoverageFile file2, bool skipInvalidFiles, CancellationToken token);
    private static void MergeModules(CoverageFile file1, CoverageFile file2, CoverageFile target, bool skipInvalidFiles, CancellationToken token);
    private static void AddModule(CoverageFile file, CoverageFile target, string moduleId, bool skipInvalidFiles);
    private static void MergeModule(CoverageFile target, ModuleWrapper module1, ModuleWrapper module2, CancellationToken token);
    private static void MergeModuleCoverageBuffer(CoverageFile target, ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, CancellationToken token);
    private static Byte[] MergeFunctionsCoverageBuffer(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2);
    private static UInt32 MergeFunctionMessages(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, List`1<Byte[]> finalCoverageBufferList, UInt32 functionStartIndex, bool mergeCommonMessages, bool addMissingMessagesToModule2);
    private static Byte[] GetBiggerCoverageBuffer(ModuleWrapper module1, ModuleWrapper module2, Byte[] coverageBuffer1, Byte[] coverageBuffer2, FunctionInstrumentedMessage message1, FunctionInstrumentedMessage message2, UInt32 functionBufferCount);
    private static void UpdateSourceIds(ModuleWrapper module1, ModuleWrapper module2, FunctionInstrumentedMessage message2);
    private static void MergeSkippedModules(CoverageFile file1, CoverageFile file2, CoverageFile target, CancellationToken token);
    private static void MergeModuleHandles(string moduleId1, ModuleHandle moduleHandle1, CoverageFile file1, CoverageFile file2, BinaryReader reader1, BinaryReader reader2, bool skipInvalidFiles, bool allowMergeWithSameId);
    private static bool AreEqualByHash(ModuleHandle moduleHandle1, ModuleHandle moduleHandle2, BinaryReader reader1, BinaryReader reader2);
    private static bool TryMergeCoverageBuffers(ModuleHandle moduleHandle1, ModuleHandle moduleHandle2, CoverageFile file1, CoverageFile file2, BinaryReader reader1, BinaryReader reader2, bool skipInvalidFiles);
    private static void MergeTestListData(CoverageData coverageData1, CoverageData coverageData2, CoverageData target);
    private static void MergePerTestData(CoverageData coverageData1, CoverageData coverageData2, CoverageData target);
    internal static CoverageData ReadCoverageFile(string path, SnapshotTag[] snapshotTags);
    internal static SnapshotTag[] ReadTestCases(string path);
    public static CoverageData Read(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    public static CoverageData Read(string path, IList`1<string> testIds, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<ReadAsync>d__36")]
public static Task`1<CoverageData> ReadAsync(string path, CancellationToken token, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<ReadAsync>d__37")]
public static Task`1<CoverageData> ReadAsync(string path, CancellationToken token, IList`1<string> testIds, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool cacheCoverageMessages, bool readModuleHandles);
    private static CoverageFile ReadCoverageFile(string path, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool readModuleHandles, bool cacheCoverageMessages, IList`1<string> testIds, bool readOnlyTestList, CancellationToken token);
    internal static CoverageFile ReadCoverageFile(string path, BinaryReader reader, bool cacheCoverageMessages, bool readModules, bool readSkippedFunctions, bool readSkippedModules, bool readModuleHandles, IList`1<string> testIds, bool readOnlyTestList, CancellationToken token);
    protected virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
    private void RecordTestListInformationDataStreamType(CoverageFileMessageReader reader, String[] orderedTestIds);
    private void RecordPerTestCodeCoverageDataStream(CoverageFileMessageReader reader, Guid identifier, String[] orderedTestIds);
    private void RecordCoverageDataStream(CoverageFileMessageReader reader, Guid identifier);
    private void RecordModuleStream(CoverageFileMessageReader reader, bool readModuleHandles);
    internal static void GetSkippedModule(CoverageFileMessageReader reader, IList`1<SkippedModule> modules, string filePath);
    private static void ReadModuleData(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<string, IList`1<ValueTuple`2<long, long>>> moduleDataLocations, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer);
    private static IList`1<FunctionWrapper> ReadModuleStream(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, long streamEnd, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer);
    private static IList`1<FunctionWrapper> ReadModuleStream(string path, BinaryReader reader, ModuleWrapper module, IList`1<string> testIds, bool readSkippedFunctions, bool cacheCoverageMessages, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations, Byte[] coverageBuffer, CoverageFileMessageReader stream);
    internal static void LoadRawData(ModuleHandle moduleHandle);
    internal static void LoadRawData(ModuleHandle moduleHandle, BinaryReader reader);
    internal static void CalculateRawDataHash(ModuleHandle moduleHandle, BinaryReader binaryReader);
    [NullableContextAttribute("2")]
internal Byte[] GetCoverageBuffer(Guid coverageBufferId, bool skipInvalidFiles, BinaryReader binaryReader);
    private static Byte[] GetCoverageBuffer(string path, BinaryReader reader, Guid coverageBufferId, IList`1<string> testIds, IDictionary`2<Guid, IList`1<ValueTuple`3<string, long, long>>> coverageDataLocations);
    private static Byte[] MergeCoverageBuffer(string path, BinaryReader reader, long start, long blockCount, Byte[] buffer);
    internal static void ReadSourceFile(CoverageFileMessageReader reader, ModuleWrapper module, IDictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static void ReadSourceFile(SourceFileDataMessage message, ModuleWrapper module, IDictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static FunctionWrapper ReadFunction(CoverageFileMessageReader reader, ModuleWrapper module, Byte[] coverageBuffer, Dictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static FunctionWrapper ReadFunction(FunctionInstrumentedMessage message, ModuleWrapper module, Byte[] coverageBuffer, Dictionary`2<UInt32, UInt32> sourceIdMap, bool cacheCoverageMessages);
    internal static void ReadSkippedMessage(CoverageFileMessageReader reader, ModuleWrapper module, bool readSkippedFunctions, bool cacheCoverageMessages);
    internal static void ReadSkippedMessage(FunctionSkippedMessage message, ModuleWrapper module, bool readSkippedFunctions, bool cacheCoverageMessages);
    private void LoadAllModuleData(bool readSkippedFunctions, bool skipInvalidFiles);
    private void LoadAllCoverageBuffers(bool skipInvalidFiles);
    internal static void LoadAllRawData(CoverageData coverageData);
    private void LoadModuleData(string moduleId, bool readSkippedFunctions, bool skipInvalidFiles);
    private void ReadModule(BinaryReader reader, bool readSkippedFunctions, IList`1<string> testIds, string moduleId);
    private void ReadSkippedModules(BinaryReader reader);
    private void ReadModules(BinaryReader reader, bool readSkippedFunctions, IList`1<string> testIds);
    public static void SplitCoverageFile(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFile/<SplitCoverageFileAsync>d__69")]
public static Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    private static void SplitCoverageFile(CoverageData coverageData, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    internal static void Write(string path, CoverageData coverageData);
    internal static void Write(string path, CoverageData coverageData, CancellationToken token);
    private static void Write(BinaryWriter writer, CoverageData coverageData, CancellationToken token);
    private static void WriteInstrumentedModuleData(BinaryWriter writer, ModuleWrapper module);
    private static void WriteInstrumentedModuleData(BinaryWriter writer, ModuleHandle moduleHandle);
    private static void WriteModuleCoverageData(BinaryWriter writer, Guid coverageBufferId, Byte[] coverageBuffer);
    private static void WriteSingleSkippedModuleToFile(string outputFolder, SkippedModule module, ConcurrentDictionary`2<string, byte> writtenModules);
    private static void WriteSkippedModuleData(BinaryWriter writer, SkippedModule module);
    private static void WriteSingleModuleToFile(string outputFolder, ModuleWrapper module, ConcurrentDictionary`2<string, byte> writtenModules, bool generateCoverageBufferFiles);
    private static void WriteInstrumentedModule(string outputFolder, ModuleWrapper module, Byte[] coverageBuffer, bool generateCoverageBufferFiles);
    private static Byte[] GetAdjustedCoverageBuffer(ModuleWrapper module, Byte[] coverageBuffer);
    private static void WriteSnapshotTagsData(BinaryWriter writer, SnapshotTag[] snapshotTags);
    private static void WritePerSnapshotData(BinaryWriter writer, Guid identifier, KeyValuePair`2<CoverageBufferHashMessage, ValueTuple`2<List`1<string>, Byte[]>> perTestCoverageData);
    [CompilerGeneratedAttribute]
internal static void <MergeSkippedModules>g__MergeSkippedModule|26_0(CoverageFile file, CoverageFile target, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <MergeTestListData>g__MergeTestListData|30_0(CoverageData coverageData, CoverageData target);
    [CompilerGeneratedAttribute]
internal static void <MergePerTestData>g__MergePerTestData|31_0(CoverageData coverageData, CoverageData target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.IO.CoverageFileBase : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    [NullableContextAttribute("2")]
protected CoverageFileBase(string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    protected virtual void ReadFile(BinaryReader reader, CancellationToken token, bool readModuleHandles, bool readOnlyTestList, IList`1<string> testIds);
    protected abstract virtual void ProcessStreamHeader(StreamHeader streamHeader, BinaryReader reader, bool readModuleHandles, bool readOnlyTestList, String[] orderedTestIds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.CoverageFileConverter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileConverter/<ToXmlFileAsync>d__0")]
public static Task ToXmlFileAsync(string path, string outputPath, bool includeSkippedFunctions, bool includeSkippedModules, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileConverter/<ToCoverageXmlFileAsync>d__1")]
public static Task`1<CoverageXmlFile> ToCoverageXmlFileAsync(string path, bool includeSkippedFunctions, bool includeSkippedModules, CancellationToken token);
    internal static void WriteXmlFile(string path, CoverageData coverageData, bool includeSkippedModules, CancellationToken token);
    internal static void WriteXmlFile(string path, CoverageXmlFile coverageXmlFile);
    internal static CoverageXmlFile ToXml(CoverageData coverageData, bool includeSkippedModules, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileConverter/<ToCoberturaFileAsync>d__5")]
public static Task ToCoberturaFileAsync(string path, string outputPath, CancellationToken token);
    internal static void WriteToCoberturaFile(string path, CoverageData coverageData, CancellationToken token);
    internal static CoberturaFile ToCobertura(CoverageData coverageData, CancellationToken token);
    private static ValueTuple`2<MinimalSequencePointsFinder`1<UInt32>, int> BuildMinimalSequencePointsFinderAndCalculateMaxNumberOfMethods(ModuleWrapper module);
    private static void AddMethod(Function function, CoberturaPackageBuilder packageBuilder, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder, ModuleWrapper module, CancellationToken token);
    private static CoberturaLine[] CalculateLines(List`1<BlockLineData> lineData, UInt32 sourceId, MinimalSequencePointsFinder`1<UInt32> minimalSequencePointsFinder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.CoverageFileUtility : object {
    public sealed virtual bool IsValidCoverageFile(string path);
    public sealed virtual CoverageData ReadCoverageFile(string path);
    public sealed virtual CoverageData ReadCoverageFile(string path, IList`1<string> testIds);
    public sealed virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages);
    public sealed virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds);
    public sealed virtual TestCaseInformation[] ReadTestCases(string path);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, IList`1<string> testIds, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, CancellationToken token);
    public sealed virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds, CancellationToken token);
    public sealed virtual void WriteCoverageFile(string path, CoverageData coverageData);
    public sealed virtual void SplitCoverageFile(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<SplitCoverageFileAsync>d__12")]
public sealed virtual Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    public sealed virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles);
    public sealed virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageBufferFilesAsync>d__15")]
public sealed virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageBufferFilesAsync>d__16")]
public sealed virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, int taskCount);
    public sealed virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int taskCount);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__21")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__22")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__23")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageFilesAsync>d__24")]
public sealed virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public sealed virtual void ConvertCoverageFile(string path, string outputPath, bool includeSkippedFunctions, bool includeSkippedModules);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<GetCoverageReportAsync>d__26")]
public sealed virtual Task`1<ValueTuple`2<CoverageReportType, object>> GetCoverageReportAsync(string path, bool skipInvalidFile, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__27")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__28")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__29")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> inputFiles, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__31")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__32")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtility/<MergeCoverageReportsAsync>d__33")]
public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public sealed virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.CoverageFileUtilityV2 : object {
    private ICoverageFileConfiguration _fileConfiguration;
    private CoverageFile _coverageFile;
    public CoverageFileUtilityV2(ICoverageFileConfiguration coverageFileConfiguration);
    public CoverageFileUtilityV2(ICoverageFileConfiguration coverageFileConfiguration, ILogger logger);
    public sealed virtual bool IsValidCoverageFile(string path);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ReadCoverageFileAsync>d__5")]
public sealed virtual Task`1<CoverageReport> ReadCoverageFileAsync(string path, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<string> GetUniqueSourceFiles(CoverageReport coverageReport);
    public sealed virtual IList`1<CoverageLineData> GetCoverageLines(string sourceFile, CoverageReport coverageReport);
    public sealed virtual XmlFileData ReadXmlCoverageFile(string path);
    public sealed virtual void WriteXmlCoverageFile(string path, XmlFileData report);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ToXmlFileAsync>d__10")]
public sealed virtual Task ToXmlFileAsync(string path, string outputPath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.IO.CoverageFileUtilityV2/<ToXmlFileAsync>d__11")]
public sealed virtual Task`1<XmlFileData> ToXmlFileAsync(string path, CancellationToken cancellationToken);
    private static XmlFileData ToXmlFileData(CoverageReport report);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlRootAttribute("results")]
public class Microsoft.CodeCoverage.IO.CoverageXmlFile : object {
    [CompilerGeneratedAttribute]
private List`1<Module> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedModule> <SkippedModules>k__BackingField;
    [XmlArrayAttribute("modules")]
[XmlArrayItemAttribute("module")]
public List`1<Module> Modules { get; public set; }
    [XmlArrayAttribute("skipped_modules")]
[XmlArrayItemAttribute("skipped_module")]
public List`1<SkippedModule> SkippedModules { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Module> get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(List`1<Module> value);
    [CompilerGeneratedAttribute]
public List`1<SkippedModule> get_SkippedModules();
    [CompilerGeneratedAttribute]
public void set_SkippedModules(List`1<SkippedModule> value);
    public bool ShouldSerializeModules();
    public bool ShouldSerializeSkippedModules();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.IO.CoverageXmlFileUtility : object {
    public static XmlFileData ReadXmlFile(string path, ICoverageFileConfiguration coverageFileConfiguration);
    public static void WriteXmlCoverageFile(string path, XmlFileData report, ICoverageFileConfiguration coverageFileConfiguration);
    public static bool TryReadCoverageXmlFile(string path, CoverageXmlFile& coverageXmlFile);
    public static CoverageFile ToCoverageFile(CoverageXmlFile coverageXmlFile);
    private static ModuleWrapper ToModuleWrapper(Module module);
    private static ValueTuple`2<FunctionInstrumentedMessage, Byte[]> ToFunctionInstrumentedMessage(Function function, UInt32 startBlockIndex);
    private static FunctionSkippedMessage ToFunctionSkippedMessage(SkippedFunction skippedFunction);
    private static SourceFileDataMessage ToSourceFileDataMessage(SourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Exceptions.CoverageFileException : VanguardException {
    public CoverageFileException(string path);
    public CoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Exceptions.InvalidBufferCountException : VanguardException {
    public InvalidBufferCountException(string message);
    public InvalidBufferCountException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Exceptions.InvalidCoverageFileException : VanguardException {
    public InvalidCoverageFileException(string path);
    public InvalidCoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Exceptions.UnsupportedCoverageFileException : VanguardException {
    public UnsupportedCoverageFileException(string path);
    public UnsupportedCoverageFileException(string path, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeCoverage.IO.Exceptions.VanguardException : Exception {
    public VanguardException(string message);
    public VanguardException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.IO.FunctionHasher : object {
    public sealed virtual string SHA256Hash(FunctionInstrumentedMessage message);
    private void FillStream(BinaryWriter writer, FunctionInstrumentedMessage message);
    private void WriteBlockLineDataMessage(BinaryWriter writer, BlockLineDataMessage message, UInt32 startBlockIndex);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.IO.ICoverageFileUtility {
    public abstract virtual bool IsValidCoverageFile(string path);
    public abstract virtual CoverageData ReadCoverageFile(string path);
    public abstract virtual CoverageData ReadCoverageFile(string path, IList`1<string> testIds);
    public abstract virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages);
    public abstract virtual CoverageData ReadCoverageFile(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds);
    public abstract virtual TestCaseInformation[] ReadTestCases(string path);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, IList`1<string> testIds, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, CancellationToken token);
    public abstract virtual Task`1<CoverageData> ReadCoverageFileAsync(string path, bool readModules, bool readSkippedMessages, bool readSkippedModules, bool cacheCoverageMessages, IList`1<string> testIds, CancellationToken token);
    public abstract virtual void WriteCoverageFile(string path, CoverageData coverageData);
    public abstract virtual void SplitCoverageFile(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles);
    public abstract virtual Task SplitCoverageFileAsync(string path, string outputFolder, bool writeSkippedModules, bool generateCoverageBufferFiles, CancellationToken token);
    public abstract virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles);
    public abstract virtual string MergeCoverageBufferFiles(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles);
    public abstract virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, CancellationToken token);
    public abstract virtual Task`1<string> MergeCoverageBufferFilesAsync(string covxFile, IList`1<string> coverageBufferFiles, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, int taskCount);
    public abstract virtual CoverageData MergeCoverageFiles(IList`1<string> files, bool skipInvalidFiles, int taskCount);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, int taskCount, CancellationToken token);
    public abstract virtual Task`1<CoverageData> MergeCoverageFilesAsync(IList`1<string> files, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public abstract virtual void ConvertCoverageFile(string path, string outputPath, bool includeSkippedModules, bool includeSkippedFunctions);
    public abstract virtual Task`1<ValueTuple`2<CoverageReportType, object>> GetCoverageReportAsync(string path, bool skipInvalidFile, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<string> files, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, int taskCount, CancellationToken token);
    public abstract virtual Task`1<IList`1<string>> MergeCoverageReportsAsync(string outputFilename, IList`1<ValueTuple`3<string, CoverageReportType, object>> reports, CoverageMergeOperation mergeOperation, bool skipInvalidFiles, int taskCount, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeCoverage.IO.ICoverageFileUtilityV2 {
    public abstract virtual bool IsValidCoverageFile(string path);
    public abstract virtual Task`1<CoverageReport> ReadCoverageFileAsync(string path, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<string> GetUniqueSourceFiles(CoverageReport coverageReport);
    public abstract virtual IList`1<CoverageLineData> GetCoverageLines(string sourceFile, CoverageReport coverageReport);
    public abstract virtual XmlFileData ReadXmlCoverageFile(string path);
    public abstract virtual void WriteXmlCoverageFile(string path, XmlFileData report);
    public abstract virtual Task ToXmlFileAsync(string path, string outputPath, CancellationToken cancellationToken);
    public abstract virtual Task`1<XmlFileData> ToXmlFileAsync(string path, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.IO.IFunctionHasher {
    public abstract virtual string SHA256Hash(FunctionInstrumentedMessage message);
}
internal static class Microsoft.CodeCoverage.IO.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string AllTests { get; }
    internal static string CodeCoverageLoggingDisabled { get; }
    internal static string CoverageFileException { get; }
    internal static string FailedToCreateDirectory { get; }
    internal static string FailedToCreateFile { get; }
    internal static string InvalidBlockIndexExceptionMessage { get; }
    internal static string InvalidCoverageFileException { get; }
    internal static string OffsetOutOfRangeExceptionMessage { get; }
    internal static string UnsupportedCoverageFileException { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_AllTests();
    internal static string get_CodeCoverageLoggingDisabled();
    internal static string get_CoverageFileException();
    internal static string get_FailedToCreateDirectory();
    internal static string get_FailedToCreateFile();
    internal static string get_InvalidBlockIndexExceptionMessage();
    internal static string get_InvalidCoverageFileException();
    internal static string get_OffsetOutOfRangeExceptionMessage();
    internal static string get_UnsupportedCoverageFileException();
}
[ExtensionAttribute]
public static class Microsoft.CodeCoverage.IO.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetFileName(string path);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
