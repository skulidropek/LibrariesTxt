internal static class MarginNames : object {
    internal static string strDebuggerMargin;
    internal static string strSearchMargin;
}
internal class Microsoft.IntelliTrace.Concord.Client.Client : object {
    private static int MAX_PATH;
    public sealed virtual void OnThreadCreate(DkmThread thread, DkmWorkList workList, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnThreadExit(DkmThread thread, int exitCode, DkmEventDescriptor eventDescriptor);
    private static void SendThreadExitInformation(ulong id, DkmThread thread, DkmGetThreadDisplayPropertiesAsyncResult result);
    public sealed virtual void OnThreadNameChange(DkmThread thread, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
    private static string GetDocumentUrl(ISymUnmanagedDocument document);
    public sealed virtual DkmCustomMessage SendHigher(DkmCustomMessage customMessage);
    private static SymbolState GetOrCreateSymbolState(DkmProcess process);
    private static int GetToken(DkmCustomMessage message);
    private static DkmCustomMessage CreateResponse(DkmCustomMessage original, object param1, object param2);
}
internal class Microsoft.IntelliTrace.Concord.ConcordComponentInitializer : object {
    private IntPtr _handle;
    public ConcordComponentInitializer(Guid componentGuid);
    public IDisposable InitializeThread();
}
internal class Microsoft.IntelliTrace.Concord.DtStackFrameCachedArray : DkmDataItem {
    private List`1<DT_CALLSTACKFRAMES> _cachedFrames;
    public int Count { get; }
    public int get_Count();
    public static DtStackFrameCachedArray GetCachedArray(DkmProcess process);
    public void ResetForDkmThread(DkmThread thread);
    public void Clear();
    public sealed virtual IEnumerator`1<DT_CALLSTACKFRAMES> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.IntelliTrace.Concord.ExceptionDetailsState : DkmDataItem {
    [CompilerGeneratedAttribute]
private DkmExceptionInformation <_exceptionInformation>k__BackingField;
    public DkmExceptionInformation _exceptionInformation { get; }
    public ExceptionDetailsState(DkmExceptionInformation exceptionInformation);
    [CompilerGeneratedAttribute]
public DkmExceptionInformation get__exceptionInformation();
}
internal class Microsoft.IntelliTrace.Concord.ExceptionHandler.ExceptionHandler : object {
    private static ulong INVALID_CORDB_ADDRESS;
    private int _exceptionId;
    private object _exceptionSnapshotLock;
    private IDictionary`2<Guid, List`1<ExceptionInformation>> _thrownExceptions;
    private IDictionary`2<Guid, IDictionary`2<UInt32, List`1<ExceptionInformation>>> _exceptionsWithSnapshots;
    private ConcurrentDictionary`2<Guid, DkmInspectionSession> _inspectionSessions;
    public sealed virtual void OnDebugMonitorException(DkmExceptionInformation exception, DkmWorkList workList, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnClrDebugMonitorExceptionCaught(DkmClrCaughtExceptionInformation caughtException, DkmWorkList workList, DkmEventDescriptorS eventDescriptor);
    public sealed virtual DkmCustomMessage SendLower(DkmCustomMessage customMessage);
    public sealed virtual void OnProcessSnapshotRemoved(DkmProcess dkmProcess, DkmProcessSnapshot processSnapshot, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnProcessExit(DkmProcess process, int exitCode, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnProcessContinue(DkmProcess process);
    private int GetStackExceptionIndex(DkmThread thread, ulong startAddress, ulong endAddress, Int32& isUserCode);
    private string GetWinRtErrorDescription(DkmProcess currentProcess, DkmExceptionInformation exception);
    private bool HaveSnapshotForException(int exceptionId, DkmExceptionInformation dkmException, DkmThread dkmThread);
    public sealed virtual DkmProcessSnapshot TakeSnapshot(DkmProcess process, ulong timeStamp, DkmThread stoppingThread);
    public sealed virtual DkmProcessSnapshot GetSourceSnapshot(DkmProcess process);
    public sealed virtual void RemoveSnapshots(DkmProcess process);
    private static ulong GetExceptionObjectAddress(DkmExceptionDetails exceptionDetails);
}
internal class Microsoft.IntelliTrace.Concord.ExceptionHandler.NativeExceptionHandler : object {
    public sealed virtual void OnDebugMonitorException(DkmExceptionInformation exception, DkmWorkList workList, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnProcessContinue(DkmProcess process);
}
[ExtensionAttribute]
internal static class Microsoft.IntelliTrace.Concord.Extensions : object {
    [ExtensionAttribute]
public static DkmClrRuntimeInstance GetClrRuntimeInstance(DkmThread thread);
    [ExtensionAttribute]
public static DkmClrRuntimeInstance GetClrRuntimeInstance(DkmProcess process);
    [ExtensionAttribute]
public static bool HasSpecificVersion(MODULE_VERSION_SPEC version);
    [ExtensionAttribute]
public static bool IsGreaterVersion(MODULE_VERSION_SPEC version, MODULE_VERSION_SPEC other);
    [ExtensionAttribute]
public static bool IsLesserVersion(MODULE_VERSION_SPEC version, MODULE_VERSION_SPEC other);
    private static bool IsAnyVersion(UInt32 version);
    [ExtensionAttribute]
public static ulong ProcessPerfomanceCounterId(DkmEventDescriptor eventDescriptor);
}
internal class Microsoft.IntelliTrace.Concord.Integration.AdviseEventArgs : object {
    [CompilerGeneratedAttribute]
private bool <IsAdvise>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugEngineAlert <EngineAlert>k__BackingField;
    public bool IsAdvise { get; private set; }
    public IDebugEngineAlert EngineAlert { get; private set; }
    public AdviseEventArgs(bool isAdvise, IDebugEngineAlert engineAlert);
    [CompilerGeneratedAttribute]
public bool get_IsAdvise();
    [CompilerGeneratedAttribute]
private void set_IsAdvise(bool value);
    [CompilerGeneratedAttribute]
public IDebugEngineAlert get_EngineAlert();
    [CompilerGeneratedAttribute]
private void set_EngineAlert(IDebugEngineAlert value);
}
internal enum Microsoft.IntelliTrace.Concord.Integration.BreakpointState : Enum {
    public int value__;
    public static BreakpointState Unknown;
    public static BreakpointState InitialEntry;
    public static BreakpointState InitialEntryNative;
    public static BreakpointState InitialExit;
    public static BreakpointState ResolvedEntry;
    public static BreakpointState ResolvedExit;
}
internal class Microsoft.IntelliTrace.Concord.Integration.BreakpointUpdateResult : object {
    [CompilerGeneratedAttribute]
private bool <BreakpointUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContinueAlert>k__BackingField;
    public bool BreakpointUpdated { get; public set; }
    public bool ContinueAlert { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_BreakpointUpdated();
    [CompilerGeneratedAttribute]
public void set_BreakpointUpdated(bool value);
    [CompilerGeneratedAttribute]
public bool get_ContinueAlert();
    [CompilerGeneratedAttribute]
public void set_ContinueAlert(bool value);
}
internal class Microsoft.IntelliTrace.Concord.Integration.DebugEngineConnectionPointAdapter : object {
    [CompilerGeneratedAttribute]
private IDebugTargetDataProvider <TargetDataProvider>k__BackingField;
    private bool _unadvised;
    private DkmProcess _process;
    private ConcordComponentInitializer _componentInitializer;
    [CompilerGeneratedAttribute]
private EventHandler`1<AdviseEventArgs> AdviseChanged;
    public IDebugTargetDataProvider TargetDataProvider { get; private set; }
    public DkmProcess Process { get; internal set; }
    public DebugEngineConnectionPointAdapter(ConcordComponentInitializer componentInit);
    [CompilerGeneratedAttribute]
public IDebugTargetDataProvider get_TargetDataProvider();
    [CompilerGeneratedAttribute]
private void set_TargetDataProvider(IDebugTargetDataProvider value);
    [CompilerGeneratedAttribute]
public void add_AdviseChanged(EventHandler`1<AdviseEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdviseChanged(EventHandler`1<AdviseEventArgs> value);
    public sealed virtual DkmProcess get_Process();
    internal void set_Process(DkmProcess value);
    public sealed virtual int Advise(IDebugEngineAlert pClientAlertSink);
    public sealed virtual int GetDebugSymbolProviderDirect(Object& ppSymbolProviderDirect);
    public sealed virtual int GetDebugTargetDataProvider(IDebugTargetDataProvider& ppDebugTargetDataProvider);
    public sealed virtual int UnAdvise();
    private void OnAdviseChanged(AdviseEventArgs e);
    private void CheckAdviseState(string name);
    public sealed virtual void Dispose();
}
internal class Microsoft.IntelliTrace.Concord.Integration.DebugEngineNotifyPointServiceAdapter : object {
    private NP_INSTALL_REQUEST[] _installRequests;
    private HashSet`1<ulong> _resolvedAddressTable;
    [CompilerGeneratedAttribute]
private DkmProcess <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugEngineAlert <EngineAlerts>k__BackingField;
    public DkmProcess Process { get; internal set; }
    private IDebugEngineAlert EngineAlerts { get; private set; }
    public DebugEngineNotifyPointServiceAdapter(DebugEngineConnectionPointAdapter connectionAdapter);
    private static int GetRetInstructionOffsets(PROCESSOR_ARCHITECTURE architecture, Byte[] code, UInt32 codeLength, COR_DEBUG_IL_TO_NATIVE_MAP[] map, UInt32 mapLength, UInt32[] offsets, UInt32& offsetLengths);
    [CompilerGeneratedAttribute]
public DkmProcess get_Process();
    [CompilerGeneratedAttribute]
internal void set_Process(DkmProcess value);
    [CompilerGeneratedAttribute]
private IDebugEngineAlert get_EngineAlerts();
    [CompilerGeneratedAttribute]
private void set_EngineAlerts(IDebugEngineAlert value);
    private void ConnectionAdapter_AdviseChanged(object sender, AdviseEventArgs e);
    public sealed virtual int GetNotifyPointBindCount(UInt32 notifyPointId, UInt32& cBindInstances);
    public sealed virtual int GetNotifyPointBoundInfo(UInt32 notifyPointId, UInt32 dwBindId, NP_BOUNDINFO[] pBoundInfo);
    public sealed virtual int InstallNotifyPoints(UInt32 ctNotifiyInstallRequests, NP_INSTALL_REQUEST[] rgNotifyInstallRequests);
    public void BindToModule(DkmClrModuleInstance module);
    public void UnbindFromModule(DkmClrModuleInstance module);
    public BreakpointUpdateResult UpdateBreakpoint(DkmRuntimeInstructionBreakpoint breakpoint, DkmThread thread);
    private void InstallBreakpoint(DkmClrModuleInstance module, NP_INSTALL_REQUEST installRequest);
    private static void UpdateBreakpointAddress(DkmRuntimeInstructionBreakpoint originalBreakpoint, ICorDebugCode code, UInt32 nativeOffset);
    private static void CreateBreakpoint(DkmClrModuleInstance module, int token, UInt32 nativeOffset, UInt32 ilOffset, NotifyPointState notifyPointState, CPUInstruction cpuAddress);
    private static int GetRetInstructionOffsets(DkmThread thread, ICorDebugCode code, UInt32[]& offsets);
    private static ICorDebugCode GetCurrentFunctionCode(DkmThread thread);
    private static bool MatchVersion(DkmClrModuleInstance moduleInstance, MODULE_VERSION_SPEC minVersion, MODULE_VERSION_SPEC maxVersion);
    private static MODULE_VERSION_SPEC GetVersionSpec(DkmModuleVersion version);
    private static COR_DEBUG_IL_TO_NATIVE_MAP[] ConvertInteropMapType(COR_DEBUG_IL_TO_NATIVE_MAP[] map);
    private void SendDiagnosticEventBindingFailure(DkmThread thread, UInt32 notifyId, DiagnosticEventBindingFailureReason reason, int hr);
    public sealed virtual int UnInstallNotifyPoints(UInt32 ctNotifyPointIds, UInt32[] rgNotifyPointIds);
    private bool IsWellKnownModule(NP_INSTALL_REQUEST request);
}
internal class Microsoft.IntelliTrace.Concord.Integration.DebugEngineTargetDataProviderAdapter : object {
    [CompilerGeneratedAttribute]
private DkmProcess <Process>k__BackingField;
    private DtStackFrameCachedArray _cachedFrames;
    private Interpreter _cachedInterpreter;
    private object _instanceLock;
    private bool _disposed;
    private bool _isAppxPackage;
    [CompilerGeneratedAttribute]
private ConcordComponentInitializer <ComponentInitializer>k__BackingField;
    private DkmProcess Process { get; private set; }
    private ConcordComponentInitializer ComponentInitializer { get; private set; }
    private Interpreter Interpreter { get; }
    public DebugEngineTargetDataProviderAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer);
    [CompilerGeneratedAttribute]
private DkmProcess get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(DkmProcess value);
    [CompilerGeneratedAttribute]
private ConcordComponentInitializer get_ComponentInitializer();
    [CompilerGeneratedAttribute]
private void set_ComponentInitializer(ConcordComponentInitializer value);
    public sealed virtual void Dispose();
    private Interpreter get_Interpreter();
    public void OnAppDomainCreated(DkmClrAppDomain appDomain);
    public void OnAppDomainUnloaded(DkmClrAppDomain appDomain);
    public sealed virtual int ExecuteDataQueries(UInt32 tid, DataQuery dataQuery, ExceptionNotifyData exceptionData, UInt32 cbMaxResults, Byte[] pDataResults, UInt32& pcbResults);
    public sealed virtual int ExecuteProgrammableDataQuery(UInt32 tid, object pProgrammableDataQuery);
    public sealed virtual int GetCallstack(UInt32 tid, int ctCallstack, DT_CALLSTACKFRAMES[]& rgFrames, UInt32& pctFramesSharedWithPrevious);
    private static CorDebugRegister GetRegister(UInt32 parameterIndex, bool isFloatingPoint);
    private void ThrowIfDisposed();
}
internal class Microsoft.IntelliTrace.Concord.Integration.ModuleBreakpointState : DkmDataItem {
    [CompilerGeneratedAttribute]
private IList`1<DkmRuntimeInstructionBreakpoint> <Breakpoints>k__BackingField;
    private IList`1<DkmRuntimeInstructionBreakpoint> Breakpoints { get; private set; }
    [CompilerGeneratedAttribute]
private IList`1<DkmRuntimeInstructionBreakpoint> get_Breakpoints();
    [CompilerGeneratedAttribute]
private void set_Breakpoints(IList`1<DkmRuntimeInstructionBreakpoint> value);
    public void AddBreakpoint(DkmRuntimeInstructionBreakpoint breakpoint);
    public void RemoveBreakpoint(DkmRuntimeInstructionBreakpoint breakpoint);
    public void RemoveBreakpoints(Func`2<DkmRuntimeInstructionBreakpoint, bool> predicate);
    public void RemoveAll();
}
internal class Microsoft.IntelliTrace.Concord.Integration.NotifyPointState : DkmDataItem {
    [CompilerGeneratedAttribute]
private BreakpointState <BreakpointType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGeneric>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NotifyPointId>k__BackingField;
    public BreakpointState BreakpointType { get; public set; }
    public bool IsGeneric { get; private set; }
    public UInt32 NotifyPointId { get; private set; }
    public bool RequiresUpdate { get; }
    public NotifyPointState(UInt32 id, BreakpointState bpState, bool isGeneric);
    [CompilerGeneratedAttribute]
public BreakpointState get_BreakpointType();
    [CompilerGeneratedAttribute]
public void set_BreakpointType(BreakpointState value);
    [CompilerGeneratedAttribute]
public bool get_IsGeneric();
    [CompilerGeneratedAttribute]
private void set_IsGeneric(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_NotifyPointId();
    [CompilerGeneratedAttribute]
private void set_NotifyPointId(UInt32 value);
    public bool get_RequiresUpdate();
}
internal class Microsoft.IntelliTrace.Concord.Integration.SimpleCorEvaluator : object {
    private static string EnumClassName;
    private static string EnumValueFieldName;
    private ICorDebugValue _rootValue;
    public SimpleCorEvaluator(ICorDebugValue value);
    public int ExecuteDataQuery(QueryInput dq, String[] fields, BlobPacker packer);
    private void Pack(ICorDebugValue debugValue, ElementType corType, int depth, BlobPacker packer, int maxByteSize);
    private static bool IsSimpleType(ElementType corType);
    private static bool IsNull(ICorDebugReferenceValue referenceValue);
    private static ICorDebugType GetExactType(ICorDebugValue value);
    private static ElementType GetExactCorType(ICorDebugValue value);
    private static int GetClassName(ICorDebugType debugType, String& className);
    private static int EvaluateTransition(string fieldName, ElementType corType, ICorDebugValue value, ICorDebugValue& next);
    private static int EvaluateComplexTypeTransition(string fieldName, ICorDebugValue value, ICorDebugValue& nextValue);
    private static int ResolveField(ICorDebugValue value, string fieldName, UInt32& fieldToken, ICorDebugClass& actualClassValue);
}
internal class Microsoft.IntelliTrace.Concord.Integration.Symbols.DebugEngineSymbolProviderDirectAdapter : SymUnmanagedAdapter {
    public DebugEngineSymbolProviderDirectAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int GetCurrentModulesInfo(UInt32& pCount, Guid[] ppGuids, UInt32[] pADIds, UInt32[] pCurrentState, Object[] ppCDModItfs);
    public sealed virtual int GetCurrentModulesState(UInt32& pState, UInt32& count);
    public sealed virtual int GetMetaDataImport(Guid& guid, UInt32 appID, Object& ppImport);
    public sealed virtual int GetSymUnmanagedReader(UInt32 ulAppDomainID, Guid guidModule, Object& ppSymUnmanagedReader);
    public sealed virtual int GetAppIDFromAddress(IDebugAddress pAddress, UInt32& pAppID);
    public sealed virtual int GetMethodFromAddress(IDebugAddress pAddress, Guid& pGuid, UInt32& pAppID, Int32& pTokenClass, Int32& pTokenMethod, UInt32& pdwOffset, UInt32& pdwVersion);
}
internal class Microsoft.IntelliTrace.Concord.Integration.Symbols.SendResult`1 : object {
    [CompilerGeneratedAttribute]
private int <HResult>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    public int HResult { get; private set; }
    public T Data { get; private set; }
    public bool Succeeded { get; }
    public SendResult`1(int hr);
    public SendResult`1(int hr, T data);
    [CompilerGeneratedAttribute]
public int get_HResult();
    [CompilerGeneratedAttribute]
private void set_HResult(int value);
    [CompilerGeneratedAttribute]
public T get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(T value);
    public bool get_Succeeded();
}
internal abstract class Microsoft.IntelliTrace.Concord.Integration.Symbols.SymUnmanagedAdapter : object {
    [CompilerGeneratedAttribute]
private DkmProcess <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcordComponentInitializer <ComponentInitializer>k__BackingField;
    protected DkmProcess Process { get; private set; }
    protected ConcordComponentInitializer ComponentInitializer { get; private set; }
    public SymUnmanagedAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer);
    [CompilerGeneratedAttribute]
protected DkmProcess get_Process();
    [CompilerGeneratedAttribute]
private void set_Process(DkmProcess value);
    [CompilerGeneratedAttribute]
protected ConcordComponentInitializer get_ComponentInitializer();
    [CompilerGeneratedAttribute]
private void set_ComponentInitializer(ConcordComponentInitializer value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected SendResult`1<T> SendHigher(int code, object parameter1, object parameter2);
}
internal class Microsoft.IntelliTrace.Concord.Integration.Symbols.SymUnmanagedDocumentAdapter : SymUnmanagedTokenAdapter {
    public SymUnmanagedDocumentAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer, int token);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int GetLanguage(Guid& pRetVal);
    public sealed virtual int FindClosestLine(int line, Int32& pRetVal);
    public sealed virtual int GetDocumentType(Guid& pRetVal);
    public sealed virtual int GetLanguageVendor(Guid& pRetVal);
    public sealed virtual int GetSourceLength(Int32& pRetVal);
    public sealed virtual int GetSourceRange(int startLine, int startColumn, int endLine, int endColumn, int cSourceBytes, Int32& pcSourceBytes, Byte[] source);
    public sealed virtual int HasEmbeddedSource(Boolean& pRetVal);
    public sealed virtual int GetUrl(int bufferLength, Int32& count, Char[] url);
    public sealed virtual int GetChecksumAlgorithmId(Guid& algorithm);
    public sealed virtual int GetChecksum(int bufferLength, Int32& count, Byte[] checksum);
}
internal class Microsoft.IntelliTrace.Concord.Integration.Symbols.SymUnmanagedMethodAdapter : SymUnmanagedTokenAdapter {
    public SymUnmanagedMethodAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer, int token);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int GetSequencePointCount(Int32& retVal);
    public sealed virtual int GetSequencePoints(int cPoints, Int32& pcPoints, Int32[] offsets, ISymUnmanagedDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public sealed virtual int GetToken(Int32& pToken);
    public sealed virtual int GetOffset(ISymUnmanagedDocument document, int line, int column, Int32& retVal);
    public sealed virtual int GetRanges(ISymUnmanagedDocument document, int line, int column, int cRanges, Int32& pcRanges, Int32[] ranges);
    public sealed virtual int GetSourceStartEnd(ISymUnmanagedDocument[] docs, Int32[] lines, Int32[] columns, Boolean& retVal);
    public sealed virtual int GetRootScope(ISymUnmanagedScope& scope);
    public sealed virtual int GetScopeFromOffset(int offset, ISymUnmanagedScope& scope);
    public sealed virtual int GetParameters(int bufferLength, Int32& count, ISymUnmanagedVariable[] parameters);
    public sealed virtual int GetNamespace(ISymUnmanagedNamespace& namespace);
}
internal class Microsoft.IntelliTrace.Concord.Integration.Symbols.SymUnmanagedReaderAdapter : SymUnmanagedTokenAdapter {
    public SymUnmanagedReaderAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer, int token);
    protected virtual void Dispose(bool disposing);
    public sealed virtual int GetDocuments(int bufferLength, Int32& count, ISymUnmanagedDocument[] documents);
    public sealed virtual int GetUserEntryPoint(Int32& methodToken);
    public sealed virtual int GetMethod(int methodToken, ISymUnmanagedMethod& method);
    public sealed virtual int GetMethodByVersion(int methodToken, int version, ISymUnmanagedMethod& method);
    public sealed virtual int GetVariables(int methodToken, int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public sealed virtual int GetGlobalVariables(int bufferLength, Int32& count, ISymUnmanagedVariable[] variables);
    public sealed virtual int GetMethodFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, ISymUnmanagedMethod& method);
    public sealed virtual int GetSymAttribute(int methodToken, string name, int bufferLength, Int32& count, Byte[] customDebugInformation);
    public sealed virtual int GetNamespaces(int bufferLength, Int32& count, ISymUnmanagedNamespace[] namespaces);
    public sealed virtual int Initialize(object metadataImporter, string fileName, string searchPath, IStream stream);
    public sealed virtual int UpdateSymbolStore(string fileName, IStream stream);
    public sealed virtual int ReplaceSymbolStore(string fileName, IStream stream);
    public sealed virtual int GetSymbolStoreFileName(int bufferLength, Int32& count, Char[] name);
    public sealed virtual int GetMethodsFromDocumentPosition(ISymUnmanagedDocument document, int line, int column, int bufferLength, Int32& count, ISymUnmanagedMethod[] methods);
    public sealed virtual int GetDocumentVersion(ISymUnmanagedDocument document, Int32& version, Boolean& isCurrent);
    public sealed virtual int GetDocument(string url, Guid language, Guid languageVendor, Guid documentType, ISymUnmanagedDocument& document);
    public sealed virtual int GetMethodVersion(ISymUnmanagedMethod method, Int32& version);
    public sealed virtual int GetMethodByVersionPreRemap(int methodToken, int version, ISymUnmanagedMethod& method);
    public sealed virtual int GetSymAttributePreRemap(int methodToken, string name, int bufferLength, Int32& count, Byte[] customDebugInformation);
    public sealed virtual int GetMethodsInDocument(ISymUnmanagedDocument document, int bufferLength, Int32& count, ISymUnmanagedMethod[] methods);
    public sealed virtual int GetSourceServerData(Int32& length, Byte*& data);
}
internal abstract class Microsoft.IntelliTrace.Concord.Integration.Symbols.SymUnmanagedTokenAdapter : SymUnmanagedAdapter {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; private set; }
    protected SymUnmanagedTokenAdapter(DkmProcess process, ConcordComponentInitializer componentInitializer, int token);
    [CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(int value);
    protected SendResult`1<T> SendHigher(int code, object parameter);
}
internal class Microsoft.IntelliTrace.Concord.IntelliTraceProcessState : DkmDataItem {
    private DebugEngineConnectionPointAdapter _connection;
    private DebugEngineNotifyPointServiceAdapter _npService;
    private int _funcEvalCounter;
    private NotifyPointAlerts _alerts;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _alertEnabled;
    private ConcordComponentInitializer _componentInitializer;
    public bool AlertEnabled { get; private set; }
    public IDebugEngineConnectionPoint EngineConnection { get; }
    public INotifyPointService NotifyPointService { get; }
    public NotifyPointAlerts NotifyPointAlerts { get; }
    public bool IsInFuncEval { get; }
    public bool get_AlertEnabled();
    private void set_AlertEnabled(bool value);
    public IDebugEngineConnectionPoint get_EngineConnection();
    public INotifyPointService get_NotifyPointService();
    public NotifyPointAlerts get_NotifyPointAlerts();
    protected virtual void OnClose();
    public void AlertModuleLoad(ulong id, IModuleInstance moduleInstance);
    public void AlertModuleUnload(ulong id, IModuleInstance moduleInstance);
    public void AlertSymbolLoad(ulong id, DkmModuleInstance moduleInstance);
    public BreakpointUpdateResult UpdateBreakpoint(DkmRuntimeInstructionBreakpoint breakpoint, DkmThread thread);
    public void AssociateWithDkmProcess(DkmProcess process);
    public void IncrementFuncEval();
    public void DecrementFuncEval();
    public bool get_IsInFuncEval();
    [CompilerGeneratedAttribute]
private void <.ctor>b__15_0(object sender, AdviseEventArgs e);
}
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.IntelliTrace.Concord.IRestrictedErrorInfo {
    public abstract virtual int GetErrorDetails(String& description, Int32& hresult, String& restrictedDescription, String& capabilitySid);
    public abstract virtual int GetReference(String& reference);
}
internal class Microsoft.IntelliTrace.Concord.MetadataHelper : object {
    [CompilerGeneratedAttribute]
private IMetaDataImport2 <Metadata>k__BackingField;
    public IMetaDataImport2 Metadata { get; private set; }
    public MetadataHelper(ICorDebugModule module);
    public MetadataHelper(DkmClrModuleInstance module);
    [CompilerGeneratedAttribute]
public IMetaDataImport2 get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(IMetaDataImport2 value);
    public bool IsGeneric(UInt32 methodToken);
    public string GetClassName(UInt32 token);
    public int FindField(UInt32 classToken, string fieldName, UInt32& fieldToken);
    public UInt32 GetBaseClassToken(UInt32 classToken, Boolean& isTypeDef);
    public IList`1<UInt32> FindMethodTokens(string className, string methodName);
    internal void Invalidate();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal static class Microsoft.IntelliTrace.Concord.NativeMethods : object {
    public static int RoResolveRestrictedErrorInfoReference(string reference, IRestrictedErrorInfo& errorInfo);
}
internal class Microsoft.IntelliTrace.Concord.NotifyPoints.NotifyPointAlerts : object {
    [CompilerGeneratedAttribute]
private IDebugEngineAlert <EngineAlert>k__BackingField;
    private IDebugEngineAlert EngineAlert { get; private set; }
    public NotifyPointAlerts(IDebugEngineAlert engineAlert);
    [CompilerGeneratedAttribute]
private IDebugEngineAlert get_EngineAlert();
    [CompilerGeneratedAttribute]
private void set_EngineAlert(IDebugEngineAlert value);
    public void AlertEntry(ulong id, IThread thread);
    public void AlertBreakpoint(ulong id, IThread thread);
    public void AlertStepComplete(ulong id, IThread thread);
    public void AlertAsyncBreak(ulong id, IThread thread);
    public void AlertStopException(ulong id, IThread thread);
    public void AlertBreakMode(ulong id, IThread thread, NOTIFY_STOP_TYPE stopType);
    public void AlertContinue(IProcess process);
    public void AlertThreadCreate(ulong id, ThreadInformation threadInfo);
    public void AlertThreadDestroy(ulong id, ThreadInformation threadInfo);
    public void AlertModuleLoad(ulong id, IModuleInstance moduleInstance);
    public void AlertModuleUnLoad(ulong id, IModuleInstance moduleInstance);
    public void AlertSymbolLoad(ulong id, IModuleInstance moduleInstance);
    public void AlertNotifyPoint(ulong id, IRuntimeInstructionBreakpoint breakpoint, IThread thread);
    public void AlertThreadNameChange(ulong id, ThreadInformation threadInfo);
    public void AlertException(ulong id, UInt32 threadId, ExceptionNotifyData exceptionData);
    public void AlertBeforeContinueExecution(IThread thread);
    [ConditionalAttribute("DEBUG")]
private void AssertAlertSuccessful(int hr);
    private static string GetPriorityName(int priority);
}
internal class Microsoft.IntelliTrace.Concord.NotifyPoints.NotifyPointManager : object {
    private ConcurrentDictionary`2<Guid, IntelliTraceProcessState> _processStates;
    private ConcurrentDictionary`2<Guid, IntelliTraceProcessState> InitialProcessStates { get; }
    public sealed virtual void OnModuleInstanceLoad(DkmModuleInstance moduleInstance, DkmWorkList workList, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnModuleInstanceUnload(DkmModuleInstance moduleInstance, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnRuntimeBreakpoint(DkmRuntimeBreakpoint runtimeBreakpoint, DkmThread thread, bool hasException, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnStepComplete(DkmStepper stepper, DkmThread thread, bool hasException, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnAsyncBreakComplete(DkmProcess process, DkmAsyncBreakStatus status, DkmThread thread, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnEmbeddedBreakpointHit(DkmThread thread, DkmInstructionAddress instructionAddress, bool showAsException, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnExceptionTriggerHit(DkmExceptionTriggerHit hit, DkmEventDescriptorS eventDescriptor);
    public sealed virtual void OnInterceptExceptionCompleted(DkmThread thread, ulong cookie, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnEntryPoint(DkmProcess process, DkmThread thread, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnProcessContinue(DkmProcess process);
    public sealed virtual void OnFuncEvalStarting(DkmThread thread, DkmFuncEvalFlags flags, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnFuncEvalCompleted(DkmThread thread, DkmFuncEvalFlags flags, DkmEventDescriptor eventDescriptor);
    private static IntelliTraceProcessState GetProcessState(DkmProcess process);
    public sealed virtual void OnModuleSymbolsLoaded(DkmModuleInstance moduleInstance, DkmModule module, bool isReload, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
    public sealed virtual void BeforeContinueExecution(DkmThread thread);
    public sealed virtual void OnAppDomainCreated(DkmClrAppDomain appDomain, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
    public sealed virtual void OnAppDomainUnloaded(DkmClrAppDomain appDomain, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
    private ConcurrentDictionary`2<Guid, IntelliTraceProcessState> get_InitialProcessStates();
    public sealed virtual DkmCustomMessage SendLower(DkmCustomMessage customMessage);
    public sealed virtual DkmCustomMessage SendHigher(DkmCustomMessage customMessage);
    public sealed virtual void OnProcessCreate(DkmProcess process, DkmWorkList workList, DkmEventDescriptor eventDescriptor);
}
internal static class Microsoft.IntelliTrace.Concord.THREAD_CATEGORY : object {
    public static int Unknown;
}
internal static class Microsoft.IntelliTrace.Concord.THREAD_PRIORITY : object {
    public static int Normal;
    public static int AboveNormal;
    public static int BelowNormal;
    public static int Highest;
    public static int Idle;
    public static int Lowest;
    public static int TimeCritical;
}
internal class Microsoft.IntelliTrace.Concord.ThreadInformation : object {
    [CompilerGeneratedAttribute]
private string <ThreadName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <EventId>k__BackingField;
    public string ThreadName { get; public set; }
    public UInt32 ThreadId { get; public set; }
    public int Priority { get; public set; }
    public UInt32 Category { get; public set; }
    public ulong EventId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ThreadName();
    [CompilerGeneratedAttribute]
public void set_ThreadName(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(UInt32 value);
    [CompilerGeneratedAttribute]
public ulong get_EventId();
    [CompilerGeneratedAttribute]
public void set_EventId(ulong value);
    public Byte[] Serialize();
    public void Deserialize(Byte[] data);
}
internal static class Microsoft.IntelliTrace.Concord.Util : object {
    [ConditionalAttribute("DEBUG")]
public static void Log(string format, Object[] args);
}
internal interface Microsoft.IntelliTrace.Concord.Wrappers.IModuleInstance {
    public UInt32 AppDomainId { get; }
    public ulong BaseAddress { get; }
    public string FullName { get; }
    public bool IsUserCode { get; }
    public Guid Mvid { get; }
    public IProcess Process { get; }
    public bool IsOptimized { get; }
    public DkmClrModuleInstance Instance { get; }
    public abstract virtual UInt32 get_AppDomainId();
    public abstract virtual ulong get_BaseAddress();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsUserCode();
    public abstract virtual Guid get_Mvid();
    public abstract virtual IProcess get_Process();
    public abstract virtual bool get_IsOptimized();
    public abstract virtual DkmClrModuleInstance get_Instance();
}
internal interface Microsoft.IntelliTrace.Concord.Wrappers.IProcess {
    public bool IsJustMyCodeEnabled { get; }
    public abstract virtual bool get_IsJustMyCodeEnabled();
}
internal interface Microsoft.IntelliTrace.Concord.Wrappers.IRuntimeInstructionBreakpoint {
    public IModuleInstance ModuleInstance { get; }
    public NotifyPointState NotifyPointState { get; }
    public abstract virtual IModuleInstance get_ModuleInstance();
    public abstract virtual NotifyPointState get_NotifyPointState();
}
internal interface Microsoft.IntelliTrace.Concord.Wrappers.IThread {
    public UInt32 Id { get; }
    public IProcess Process { get; }
    public abstract virtual UInt32 get_Id();
    public abstract virtual IProcess get_Process();
}
internal class Microsoft.IntelliTrace.Concord.Wrappers.WrappedModuleInstance : object {
    private DkmClrModuleInstance _moduleInstance;
    public string FullName { get; }
    public UInt32 AppDomainId { get; }
    public Guid Mvid { get; }
    public bool IsUserCode { get; }
    public ulong BaseAddress { get; }
    public IProcess Process { get; }
    public bool IsOptimized { get; }
    public DkmClrModuleInstance Instance { get; }
    public WrappedModuleInstance(DkmModuleInstance moduleInstance);
    public sealed virtual string get_FullName();
    public sealed virtual UInt32 get_AppDomainId();
    public sealed virtual Guid get_Mvid();
    public sealed virtual bool get_IsUserCode();
    public sealed virtual ulong get_BaseAddress();
    public sealed virtual IProcess get_Process();
    public sealed virtual bool get_IsOptimized();
    public sealed virtual DkmClrModuleInstance get_Instance();
}
internal class Microsoft.IntelliTrace.Concord.Wrappers.WrappedProcess : object {
    private DkmProcess _process;
    public bool IsJustMyCodeEnabled { get; }
    public WrappedProcess(DkmProcess process);
    public sealed virtual bool get_IsJustMyCodeEnabled();
}
internal class Microsoft.IntelliTrace.Concord.Wrappers.WrappedRuntimeInstructionBreakpoint : object {
    private DkmRuntimeInstructionBreakpoint _breakpoint;
    public IModuleInstance ModuleInstance { get; }
    public NotifyPointState NotifyPointState { get; }
    public WrappedRuntimeInstructionBreakpoint(DkmRuntimeInstructionBreakpoint breakpoint);
    public sealed virtual IModuleInstance get_ModuleInstance();
    public sealed virtual NotifyPointState get_NotifyPointState();
}
internal class Microsoft.IntelliTrace.Concord.Wrappers.WrappedThread : object {
    private DkmThread _thread;
    public UInt32 Id { get; }
    public IProcess Process { get; }
    public WrappedThread(DkmThread thread);
    public sealed virtual UInt32 get_Id();
    public sealed virtual IProcess get_Process();
}
internal static class PackageGuids : object {
    internal static Guid guidIntelliTracePackage;
    internal static Guid guidIntelliTraceCmdSet;
    internal static Guid guidIntelliTraceHubExtensionCmdSet;
    internal static Guid guidDetailsEditorFactory;
    internal static Guid guidAD7Engine;
    internal static Guid guidTraceDebugEngine;
    internal static Guid guidCustomDebuggerEventHandlerService;
    internal static Guid guidNativeEngine;
    internal static string strIntelliTracePackageGuid;
    internal static string strSolutionExplorerToolWindowGuid;
    internal static string strDebugLaunchHookGuid;
    internal static string strEditorFactoryChooserGuid;
    internal static string strToolsOptionsAdvancedGuid;
    internal static string strToolsOptionsDiagnosticEventsGuid;
    internal static string strToolsOptionsGeneralGuid;
    internal static string strToolsOptionsModulesGuid;
    internal static string strTraceLogEditorFactoryGuid;
    internal static string strDetailsEditorFactoryGuid;
    internal static string strDebugEngineGuid;
    internal static string strProgramProviderGuid;
    internal static string strCustomDebuggerEventHandlerServiceGuid;
    internal static string strSnapshotDebuggerEventHandlerServiceGuid;
    private static PackageGuids();
}
internal static class VsComponentMessageCodes : object {
    internal static UInt32 GetTraceAttachSettings;
}
