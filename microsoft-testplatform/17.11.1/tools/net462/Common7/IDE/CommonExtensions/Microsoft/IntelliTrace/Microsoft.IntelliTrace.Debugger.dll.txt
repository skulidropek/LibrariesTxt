internal static class MarginNames : object {
    internal static string strDebuggerMargin;
    internal static string strSearchMargin;
}
internal enum Microsoft.VisualStudio.Debugger.Interop.enum_DBG_ATTRIB_FLAGS_extended : Enum {
    public ulong value__;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_NONE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ALL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_OBJ_IS_EXPANDABLE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_OBJ_HAS_ID;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_OBJ_CAN_HAVE_ID;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_READONLY;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_ERROR;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_SIDE_EFFECT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_OVERLOADED_CONTAINER;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_BOOLEAN;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_BOOLEAN_TRUE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_INVALID;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_NAT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_AUTOEXPANDED;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_TIMEOUT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_RAW_STRING;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_CUSTOM_VIEWER;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_NONE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_PUBLIC;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_PRIVATE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_PROTECTED;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_FINAL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_ACCESS_ALL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_STORAGE_NONE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_STORAGE_GLOBAL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_STORAGE_STATIC;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_STORAGE_REGISTER;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_STORAGE_ALL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_NONE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_VIRTUAL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_CONSTANT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_SYNCHRONIZED;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_VOLATILE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TYPE_ALL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_DATA;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_METHOD;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_PROPERTY;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_CLASS;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_BASECLASS;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_INTERFACE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_INNERCLASS;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_MOSTDERIVEDCLASS;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_CHILD_ALL;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_MULTI_CUSTOM_VIEWERS;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_EVENT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_VALUE_RETURN_VALUE;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_TRACEPOINT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_EXCEPTIONEVENT;
    public static enum_DBG_ATTRIB_FLAGS_extended DBG_ATTRIB_UNIMPORTANTEVENT;
}
public enum Microsoft.VisualStudio.Debugger.Interop.enum_PROCESS_PROPERTY_TYPE : Enum {
    public int value__;
    public static enum_PROCESS_PROPERTY_TYPE None;
    public static enum_PROCESS_PROPERTY_TYPE PROCESS_PROPERTY_COMMAND_LINE;
    public static enum_PROCESS_PROPERTY_TYPE PROCESS_PROPERTY_CURRENT_DIRECTORY;
    public static enum_PROCESS_PROPERTY_TYPE PROCESS_PROPERTY_ENVIRONMENT_VARIABLES;
}
[GuidAttribute("230A0071-62EF-4CAE-AAC0-8988C37024BF")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.VisualStudio.Debugger.Interop.IDebugProcessQueryProperties {
    public abstract virtual int QueryProperty(enum_PROCESS_PROPERTY_TYPE dwPropType, Object& pvarPropValue);
    public abstract virtual int QueryProperties(UInt32 celt, enum_PROCESS_PROPERTY_TYPE[] rgdwPropTypes, Object[] rgtPropValues);
}
internal class Microsoft.VisualStudio.TraceDebugger.AggregateProperty : RootProperty {
    protected List`1<Property> _children;
    internal AggregateProperty(IFormatter formatter, EngineLock engineLock, List`1<Property> children);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.ArgumentDeserializerCache : object {
    private Dictionary`2<BindingHandle, IArgumentsDeserializer> _cache;
    private Debuggee _debuggee;
    public ArgumentDeserializerCache(Debuggee debuggee);
    public IArgumentsDeserializer GetOrCreateArgumentDeserializer(NotifyType notifyType);
    private static bool TrySafeLoad(string assemblyPath, Assembly& safeAssembly);
}
internal class Microsoft.VisualStudio.TraceDebugger.ArrayProperty : LeafProperty {
    protected Symbol _field;
    protected ArrayType _type;
    protected string _typeName;
    protected string _argTypeName;
    protected ArrayData _data;
    protected Int32[] _lengths;
    protected int _expectedElements;
    protected List`1<Property> _elements;
    protected bool _elementsFetched;
    public bool IsReturnValue { get; }
    public ArrayProperty(IFormatter formatter, EngineLock engineLock, Symbol field, ArrayData value, bool isOutParam);
    public virtual bool get_IsReturnValue();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetArgTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    protected virtual void AddNotCollectedProperty(List`1<Property> elements);
}
internal class Microsoft.VisualStudio.TraceDebugger.BeforeContinueExecutionNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal BeforeContinueExecutionNotifyEvent(UInt32 tid);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.BreakEvent : DebugEvent`1<IDebugBreakEvent2> {
    internal BreakEvent(Engine engine, Program program, Thread thread);
}
internal class Microsoft.VisualStudio.TraceDebugger.CallTree : ComMarshal {
    private Debuggee _debuggee;
    private int _loggerTid;
    private ulong _rootId;
    private EngineLock _engineLock;
    private UInt32 _syncCount;
    private List`1<TreeNode> _knownHandles;
    private Dictionary`2<EventHandle, TreeNode> _treeNodes;
    [CompilerGeneratedAttribute]
private bool <IsJustMyCodeOn>k__BackingField;
    internal Debuggee Debuggee { get; }
    internal bool IsJustMyCodeOn { get; private set; }
    internal int ThreadLoggerId { get; }
    internal CallTree(Thread thread, Debuggee debuggee);
    internal Debuggee get_Debuggee();
    [CompilerGeneratedAttribute]
internal bool get_IsJustMyCodeOn();
    [CompilerGeneratedAttribute]
private void set_IsJustMyCodeOn(bool value);
    internal int get_ThreadLoggerId();
    private int _GetRootNodeId(UInt64& pRootId);
    private int _GetLiveNodeId(UInt64& pLiveId);
    private int _GetNodeInfo(ulong nodeId, NODEINFO_FLAGS flags, UInt32 radix, NODEINFO[] pInfo);
    private int _EnumChildren(ulong parentId, NODEINFO_FLAGS flags, UInt32 radix, Guid guidFilter, IBidiEnumChildNodeInfo100& ppEnum);
    private int _EnumStackAtNode(ulong leafId, NODEINFO_FLAGS flags, UInt32 radix, IEnumDebugNodeInfo100& ppEnum);
    private int _EnumStackAtTimeContext(IDebugTimeContext100 pLeafContext, NODEINFO_FLAGS flags, UInt32 radix, IEnumDebugNodeInfo100& ppEnum);
    private int _GetTimeContextOfNode(ulong nodeId, IDebugTimeContext100& pTimeContext);
    private int _GetTimeContextOfSearchResult(UInt32 searchInstanceId, UInt32 resultId, IDebugTimeContext100& pTimeContext);
    private int _GetDebugProperty(ulong nodeId, IDebugProperty3& pProperty);
    private int _GetDebugPropertyAtTimeContext(IDebugTimeContext100 pLeafContext, IDebugProperty3& pProperty);
    private int _GetCodeContextOfNode(ulong nodeId, IDebugCodeContext3& pCodeContext);
    private int _GetCallTreeStepper(ulong startNode, IDebugCallTreeStepper100& ppStepper);
    private int _GetNotifyPointInfo(ulong nodeId, Int32& isNotifyNode, NP_INSTALL_REQUEST[] pNotifyInfo, String& bstrMethodId);
    private List`1<TreeNode> BuildStack(ulong leafId);
    private List`1<TreeNode> BuildStack(IDebugTimeContext100 pLeafContext);
    private EventHandle FindHandleAtOrdinal(ulong ordinal);
    private List`1<TreeNode> BuildStack(EventHandle leaf);
    internal bool ShouldBeFiltered(TreeNode parent, EventHandle child);
    internal void RegisterNode(TreeNode treeNode);
    internal TreeNode GetTreeNode(ulong nodeId);
    internal int CheckValidNode(ulong nodeId);
    internal TreeNode AddEventHandleToNodeList(EventHandle eh, bool transitionCallsite);
    public sealed virtual int GetRootNodeId(UInt64& pRootId);
    public sealed virtual int GetLiveNodeId(UInt64& pLiveId);
    public sealed virtual int GetNodeInfo(ulong nodeId, NODEINFO_FLAGS dwFieldSpec, UInt32 nRadix, NODEINFO[] rgelt);
    public sealed virtual int EnumChildren(ulong parentId, NODEINFO_FLAGS dwFieldSpec, UInt32 nRadix, Guid& guidFilter, IBidiEnumChildNodeInfo100& ppEnum);
    public sealed virtual int EnumStackAtNode(ulong leafId, NODEINFO_FLAGS dwFieldSpec, UInt32 nRadix, IEnumDebugNodeInfo100& ppEnum);
    public sealed virtual int EnumStackAtTimeContext(IDebugTimeContext100 pLeafContext, NODEINFO_FLAGS dwFieldSpec, UInt32 nRadix, IEnumDebugNodeInfo100& ppEnum);
    public sealed virtual int GetTimeContextOfNode(ulong nodeId, IDebugTimeContext100& pTimeContext);
    public sealed virtual int GetTimeContextOfSearchResult(UInt32 searchInstanceId, UInt32 resultId, IDebugTimeContext100& pTimeContext);
    public sealed virtual int GetDebugProperty(ulong nodeId, IDebugProperty3& pProperty);
    public sealed virtual int GetDebugPropertyAtTimeContext(IDebugTimeContext100 pLeafContext, IDebugProperty3& pProperty);
    public sealed virtual int GetCodeContextOfNode(ulong nodeId, IDebugCodeContext3& pCodeContext);
    public sealed virtual int GetCallTreeStepper(ulong startNode, IDebugCallTreeStepper100& ppStepper);
    public sealed virtual int GetNotifyPointInfo(ulong nodeId, Int32& isNotifyNode, NP_INSTALL_REQUEST[] installedNotifyPoint, String& methodId);
}
internal class Microsoft.VisualStudio.TraceDebugger.CallTreeStepper : ComMarshal {
    private Debuggee _debuggee;
    private StepCursor _cursor;
    private StepperImpl _stepperImpl;
    private EngineLock _engineLock;
    private UInt32 _syncCount;
    private Nullable`1<StepCursor> _backin;
    private Nullable`1<StepCursor> _backover;
    private Nullable`1<StepCursor> _backout;
    private Nullable`1<StepCursor> _forwardin;
    private Nullable`1<StepCursor> _forwardout;
    private Nullable`1<StepCursor> _forwardover;
    internal CallTreeStepper(Debuggee debuggee, EventHandle startNode);
    private int _SetStepFlags(TREE_STEP_FLAGS flags);
    private int _CanStep(TREE_STEP_DIRECTION direction, TREE_STEP_TYPE type);
    private int _Step(TREE_STEP_DIRECTION direction, TREE_STEP_TYPE type, IDebugTimeContext100& ppTimeContext);
    public sealed virtual int SetStepFlags(TREE_STEP_FLAGS flags);
    public sealed virtual int CanStep(TREE_STEP_DIRECTION direction, TREE_STEP_TYPE type);
    public sealed virtual int Step(TREE_STEP_DIRECTION direction, TREE_STEP_TYPE type, IDebugTimeContext100& ppTimeContext);
}
[DebuggerDisplayAttribute("ClassProperty: Variable Name = { GetFullName(10) }")]
internal class Microsoft.VisualStudio.TraceDebugger.ClassProperty : Property {
    protected Symbol _field;
    protected TypeDefType _type;
    protected ClassData _data;
    protected List`1<Property> _children;
    protected bool _childrenFetched;
    protected string _typeName;
    protected string _argTypeName;
    protected Property _underlyingNullableProperty;
    public bool IsReturnValue { get; }
    public ClassProperty(IFormatter formatter, EngineLock engineLock, Symbol field, ClassData value, bool isOutParam);
    public virtual bool get_IsReturnValue();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetArgTypeName(UInt32 dwRadix);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    protected virtual Symbol GetBaseSymbol(TypeDefType baseType);
    protected void EnsureChildren();
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    protected bool IsClassKeyword(string name);
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
    protected virtual Property ExpressionEvaluateHelper(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.CodeContext : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private string _funcName;
    private DocumentContext _docContext;
    private CodeContext _location;
    private SourceSearchPolicy _searchPolicy;
    private string FunctionName { get; }
    public CodeContext(Debuggee debuggee, CodeContext location, SourceSearchPolicy searchPolicy);
    private string get_FunctionName();
    private int _Add(ulong dwCount, IDebugMemoryContext2& ppMemCxt);
    private int _Compare(enum_CONTEXT_COMPARE Compare, IDebugMemoryContext2[] rgpMemoryContextSet, UInt32 dwMemoryContextSetLen, UInt32& pdwMemoryContext);
    private int _GetDocumentContext(IDebugDocumentContext2& ppSrcCxt);
    private int _GetInfo(enum_CONTEXT_INFO_FIELDS dwFields, CONTEXT_INFO[] pinfo);
    private int _GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    private int _GetModule(IDebugModule2& ppModule);
    private int _GetName(String& pbstrName);
    private int _GetProcess(IDebugProcess2& ppProcess);
    private int _Subtract(ulong dwCount, IDebugMemoryContext2& ppMemCxt);
    public sealed virtual int Add(ulong dwCount, IDebugMemoryContext2& ppMemCxt);
    public sealed virtual int Compare(enum_CONTEXT_COMPARE Compare, IDebugMemoryContext2[] rgpMemoryContextSet, UInt32 dwMemoryContextSetLen, UInt32& pdwMemoryContext);
    public sealed virtual int GetDocumentContext(IDebugDocumentContext2& ppSrcCxt);
    public sealed virtual int GetInfo(enum_CONTEXT_INFO_FIELDS dwFields, CONTEXT_INFO[] pinfo);
    public sealed virtual int GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    public sealed virtual int GetModule(IDebugModule2& ppModule);
    public sealed virtual int GetName(String& pbstrName);
    public sealed virtual int GetProcess(IDebugProcess2& ppProcess);
    public sealed virtual int Subtract(ulong dwCount, IDebugMemoryContext2& ppMemCxt);
}
internal static class Microsoft.VisualStudio.TraceDebugger.ConcordIntegration : object {
    public static void GetSiblingInterfaces(Guid processId, IDebugEngineConnectionPoint& deConnection, INotifyPointService& npService);
    public static DkmTransportConnection GetLocalConnection();
}
internal static class Microsoft.VisualStudio.TraceDebugger.Constants : object {
    internal static Guid TraceLaunchSettingsCallbackId;
    internal static Guid guidEnableFilter;
    private static Constants();
}
internal class Microsoft.VisualStudio.TraceDebugger.CSFormatter : Formatter {
    public DebugLanguage Language { get; }
    public virtual DebugLanguage get_Language();
    protected virtual string FormatType(PrimitiveType type, string typePrefix, string suffix);
    protected virtual string GetSimpleTypeName(TypeDefType type);
    protected virtual string GetTypePrefix(Symbol symbol);
    protected virtual string GetCharValue(char value);
    public virtual string FormatString(string value, UInt32 radix, bool partialData);
    public virtual string FormatKeyword(FormatterKeyword keyword);
    protected sealed virtual void GetMethodAttributeAsPrefixOrPostfix(MethodType method, String& methodPrefixPostfix, Boolean& isPostfix);
}
internal class Microsoft.VisualStudio.TraceDebugger.DataUnavailableException : Exception {
    public DataUnavailableException(string message, TimeoutException innerException);
    protected DataUnavailableException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.TraceDebugger.DebugEnumerator`1 : ComMarshal {
    protected T[] m_items;
    protected int m_index;
    protected DebugEnumerator`1(T[] items);
    private int _GetCount(UInt32& count);
    protected int _Next(UInt32 count, T[] items, UInt32& countFetched);
    private int _Reset();
    private int _Skip(UInt32 count);
    public sealed virtual int GetCount(UInt32& count);
    public sealed virtual int Next(UInt32 count, T[] items, UInt32& countFetched);
    public sealed virtual int Reset();
    public sealed virtual int Skip(UInt32 count);
    [CompilerGeneratedAttribute]
private int <Reset>b__7_0();
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.DebugEvent`1 : ComMarshal {
    protected Engine _engine;
    protected Program _program;
    protected Thread _thread;
    protected enum_EVENTATTRIBUTES _attributes;
    internal DebugEvent`1(Engine engine, Program program, Thread thread);
    internal DebugEvent`1(Engine engine, Program program, Thread thread, enum_EVENTATTRIBUTES attributes);
    public sealed virtual int GetAttributes(UInt32& attributes);
    internal void SendEvent();
    private Guid GetEventId();
}
internal class Microsoft.VisualStudio.TraceDebugger.Debuggee : object {
    private object _thisLock;
    private bool _cleaned;
    private DebuggeeState _state;
    private Engine _engine;
    private Program _program;
    private Guid _programId;
    private TimeContext _currentContext;
    private TraceLog _log;
    private IDebugEngineConnectionPoint _debugEngineConnection;
    private INotifyPointService _notifyService;
    private LoggerManager _loggerManager;
    private SymbolDispenser _symbolDispenser;
    private Dictionary`2<UInt32, WeakReference> _searchIdToResults;
    private UInt32 _nextSearchId;
    private bool _fLiveDebugging;
    private IDebugProcess2 _SDMProcess;
    private Task`1<bool> _logInitializeTask;
    private CancellationTokenSource _cancellationTokenSource;
    private List`1<Thread> _threads;
    private List`1<Module> _modules;
    private bool _areModulesStale;
    private bool _requiresSync;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFilePath>k__BackingField;
    private DebuggerEventRecorder _recorder;
    [CompilerGeneratedAttribute]
private EngineNotifyHandler <NotifyHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceLogGlobalState <TraceLogGlobalState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DataUnavailable>k__BackingField;
    private Lazy`1<ArgumentDeserializerCache> _lazyArgumentDeserializerCache;
    internal LoggerManager LoggerManager { get; }
    internal IDebugProcess2 SDMProcess { get; internal set; }
    internal string PDQDirectory { get; }
    internal Guid ProgramId { get; internal set; }
    internal Program Program { get; internal set; }
    internal Engine Engine { get; }
    internal IDebugEngineConnectionPoint DebugEngineConnection { get; internal set; }
    internal TraceLog Log { get; }
    internal bool IsJustMyCodeOn { get; }
    internal bool IsLive { get; }
    internal TimeContext CurrentTimeContext { get; private set; }
    internal string LoggerName { get; internal set; }
    internal string LogFilePath { get; private set; }
    internal DebuggerEventRecorder Recorder { get; }
    internal EngineNotifyHandler NotifyHandler { get; private set; }
    private TraceLogGlobalState TraceLogGlobalState { get; private set; }
    internal bool DataUnavailable { get; private set; }
    internal ArgumentDeserializerCache ArgumentDeserializerCache { get; }
    internal bool IsInstrEnabled { get; }
    private bool InHistoricalMode { get; }
    private DebuggeeState State { get; private set; }
    internal Debuggee(Engine engine);
    internal LoggerManager get_LoggerManager();
    internal IDebugProcess2 get_SDMProcess();
    internal void set_SDMProcess(IDebugProcess2 value);
    internal string get_PDQDirectory();
    internal Guid get_ProgramId();
    internal void set_ProgramId(Guid value);
    internal Program get_Program();
    internal void set_Program(Program value);
    internal Engine get_Engine();
    internal IDebugEngineConnectionPoint get_DebugEngineConnection();
    internal void set_DebugEngineConnection(IDebugEngineConnectionPoint value);
    internal TraceLog get_Log();
    internal bool get_IsJustMyCodeOn();
    internal bool get_IsLive();
    internal TimeContext get_CurrentTimeContext();
    private void set_CurrentTimeContext(TimeContext value);
    [CompilerGeneratedAttribute]
internal string get_LoggerName();
    [CompilerGeneratedAttribute]
internal void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
internal string get_LogFilePath();
    [CompilerGeneratedAttribute]
private void set_LogFilePath(string value);
    internal DebuggerEventRecorder get_Recorder();
    [CompilerGeneratedAttribute]
internal EngineNotifyHandler get_NotifyHandler();
    [CompilerGeneratedAttribute]
private void set_NotifyHandler(EngineNotifyHandler value);
    [CompilerGeneratedAttribute]
private TraceLogGlobalState get_TraceLogGlobalState();
    [CompilerGeneratedAttribute]
private void set_TraceLogGlobalState(TraceLogGlobalState value);
    [CompilerGeneratedAttribute]
internal bool get_DataUnavailable();
    [CompilerGeneratedAttribute]
private void set_DataUnavailable(bool value);
    internal ArgumentDeserializerCache get_ArgumentDeserializerCache();
    internal void Launch(string logFilePath);
    internal void Resume(IDebugProcess2 pProcess, int launchThreadId, long launchOrdinal);
    internal void Attach(IDebugProgram2 sdmProgram, string loggerName, IDebugEngineConnectionPoint debugEngineConnection, INotifyPointService npService, Task`1<bool> loggerAttachTask, _CollectionPlan collectionPlan);
    internal void Continue(IDebugThread2 pThread);
    internal void Terminate();
    internal void TerminateProcess();
    internal void Stop();
    internal void Detach();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.TraceDebugger.Debuggee/<CleanupSession>d__85")]
private void CleanupSession(bool cleanupProgram);
    internal void CleanupSession(Program& program, Engine& engine);
    internal void DisposeAllDebugEngineConnections();
    internal int SetTimeContext(IDebugTimeContext100 timeContext);
    internal UInt32 SetSearchResult(SearchHistoricalExecution searchHistoricalExecution);
    internal bool TryGetSearchResult(UInt32 searchInstanceId, UInt32 resultId, SearchResult& searchResult);
    internal void OnLoggerError();
    internal bool GetLoggerProcessInfo(Int32& processID, Int64& processCreationTime);
    internal bool get_IsInstrEnabled();
    internal string GetModuleName(Guid mvid);
    internal int EnumThreads(IEnumDebugThreads2& ppEnum);
    internal int EnumModules(IEnumDebugModules2& ppEnum);
    internal Thread GetThread(int loggerTid);
    internal bool EnsureThreadCheckpointed(int osTid, int loggerTid);
    internal ProgramSymbols GetProgramSymbols();
    internal ModuleSymbols GetModuleSymbols(Guid mvid);
    internal bool TryGetModuleSymbols(Guid mvid, ModuleSymbols& syms);
    private void EnsureSymbolDispenser();
    private bool get_InHistoricalMode();
    private void EnsureThreads(TimeContext currentContext);
    internal List`1<Thread> GetThreadList();
    private void EnsureModules();
    internal List`1<Module> GetModules();
    internal Module GetModule(Guid mvid);
    public EventHandle GetParent(EventHandle handle);
    internal List`1<StackFrame> GetStackFrames(Thread t, EventHandle handle);
    private bool TryGetBindingCallStackInfo(NotifyNode node, EventHandle handle, Int32& frameSkipCount, IEnumerable`1& framesToAdd);
    private Nullable`1<CodeContext> FindAlternateStackFrame(IndependentData data, ProgrammableDataQuerySpec queryspec);
    internal void SetModuleSymbols(ModuleSymbols syms);
    internal void HandleEnteringBreakMode(bool isInstrumentationEnabled);
    internal void ClearCache();
    private void SyncLog();
    private DebuggeeState get_State();
    private void set_State(DebuggeeState value);
    public bool EnsureLogInitialized();
    private bool IsCurrentProcessStopped();
    [CompilerGeneratedAttribute]
private ArgumentDeserializerCache <.ctor>b__22_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.DebuggerEventRecorder : object {
    private static Byte[] _localDispatchBuffer;
    private static int PdqTruncationSizeCount;
    private LoggerManager _loggerManager;
    private IDebugTargetDataProvider _debugTargetDataProvider;
    private long _prevStopEventCounter;
    private INotifyPointService _npService;
    private Debuggee _debuggee;
    private Dictionary`2<Guid, ModuleInfo> _modules;
    private IDebugEngineConnectionPoint _debugEngineConnection;
    private int _fakeModuleId;
    private bool _isInstrEnabled;
    private IMessageMemory2 _memory;
    private DkmTransportConnection _transportConnection;
    private static int notifyPointCount;
    private static int notifyPointCheckpointRate;
    private Dictionary`2<int, HeuristicNotifyPointSpecification> _notifyPointIdentityTable;
    private bool _disposed;
    private Dictionary`2<int, _StackFrame[]> _stackPerThread;
    private bool _suspendedInEnterBreak;
    private bool _pendingSideLoad;
    private HashSet`1<UInt32> _sideLoadedAppDomainIds;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _needFlushCache;
    private List`1<DebuggerEventCacheItem> _cachedEvents;
    internal bool IsInstrEnabled { get; }
    private DkmTransportConnection TransportConnection { get; }
    private DkmProcess Process { get; }
    internal DebuggerEventRecorder(Debuggee debuggee, LoggerManager loggerManager, IDebugEngineConnectionPoint debugEngineConnection, INotifyPointService npService);
    private static DebuggerEventRecorder();
    internal bool get_IsInstrEnabled();
    private DkmTransportConnection get_TransportConnection();
    private DkmProcess get_Process();
    internal void InstallCollectionPlan(_CollectionPlan cp, INotifyPointService npService);
    internal void FlushCache();
    private void EnsureDebugTargetDataProvider();
    internal void HandleThreadSwitch(int osTid, int loggerTid);
    internal void HandleSymbolLoad(SymbolLoadNotifyEvent symbolLoadNotifyEvent);
    internal void HandleModuleLoad(ModuleLoadNotifyEvent moduleLoadNotifyEvent);
    private void HandleSymbolLoadEventInternal(Guid moduleId, long eventCounter, UInt32 appDomainId);
    internal void HandleModuleUnload(ModuleUnloadNotifyEvent moduleUnloadNotifyEvent);
    internal void HandleProgramDestroy(ProgramDestroyNotifyEvent programDestroyNotifyEvent);
    internal void HandleEnteringBreakMode(EnteringBreakModeNotifyEvent enteringBreakModeNotifyEvent);
    internal void HandleExitingBreakMode(ExitingBreakModeNotifyEvent exitingBreakModeNotifyEvent);
    internal void HandleExceptionNotify(ExceptionNotifyEvent exceptionNotifyEvent);
    internal int HandleDisambiguateNotifyPoint(UInt32 notifyPointId, object pMetadata, UInt32 ctMethodTokens, UInt32[] rgdwMethodTokens, UInt32& pdwMatchingMethodToken);
    internal void HandleThreadCreate(ThreadCreateNotifyEvent threadCreateNotifyEvent);
    internal void HandleThreadNameChange(ThreadNameChangeNotifyEvent threadNameChangeNotifyEvent);
    internal void HandleThreadDestroy(ThreadDestroyNotifyEvent threadDestroyNotifyEvent);
    internal void HandleNotifyPoint(NotifyPointNotifyEvent notifyPointNotifyEvent);
    internal void HandleBeforeContinueExecution(BeforeContinueExecutionNotifyEvent beforeContinueExecutionNotifyEvent);
    internal string GetModuleName(Guid mvid);
    private int GetIntelliTraceToken(Guid mvid, int metadataToken);
    private void DispatchCatchHandlerFoundNotifyPointHandlers(HeuristicNotifyPointSpecification hps, UInt32 osTid, int eventId, long ordinal, ulong id, ExceptionNotifyData data);
    internal void DispatchDataQuery(DataQuery dq, IDebugTargetDataProvider debugTargetDataProvider, UInt32 osTid, ExceptionNotifyData optionalData, Byte[]& results, UInt32& cbResults);
    private void DispatchDataQuery(bool isReturn, DataQuery dataQuery, ProgrammableDataQuerySpec programmableDataQuerySpec, IDebugTargetDataProvider debugTargetDataProvider, UInt32 osTid, string categoryId, ExceptionNotifyData optionalExceptionData, Byte[]& results, UInt32& cbResults, Boolean& error);
    private Byte[] DispatchDataQuery(HeuristicNotifyPointSpecification hps, UInt32 osTid, ExceptionNotifyData optionalData);
    private void DispatchCheckpoint(UInt32 osTid, long ordinal);
    private void DispatchNotifyPointHandlers(HeuristicNotifyPointSpecification hps, UInt32 osTid, int eventId, string eventName, long ordinal, ulong id, ExceptionNotifyData optionalExceptionData);
    private void DispatchThreadCreateNotifyPointHandlers(ThreadCreateNotifyEvent threadCreateNotifyEvent);
    private void DispatchThreadNameChangeNotifyPointHandlers(ThreadNameChangeNotifyEvent threadNameChangeNotifyEvent);
    private void DispatchThreadDestroyNotifyPointHandlers(ThreadDestroyNotifyEvent threadDestroyNotifyEvent);
    private _StackFrame[] GetNotifyPointCallstack(UInt32 osTid, bool isBracketEvent, bool isExceptionEvent, UInt32& ctFramesInCommon, Int32[]& callstackModuleTokens);
    internal void RecordUiState(_UIContents uiMsg);
    protected void Dispose(bool disposing);
    public sealed virtual void Dispose();
    internal void TrySuspendCollection(bool fBumpSyncCount);
    internal void ResumeCollection();
    private void ComputeCommonStackFrameCount(_NotifyPointData npData, _StackFrame[]& uncommonFrames, Int32& commonStackFrameCount);
    private void SendNotifyPoint(_NotifyPointData npData, Int32[] evtStackModuleIds, IContinuousEventExtraData extraData);
    private void SendSyncMessage(_OrdinalInfo ordinalInfo);
    private void SendNotifyPointMessage(_NotifyPointData npData, Int32[] evtStackModuleIds, IContinuousEventExtraData extraData);
    private void SendContinuousNotifyPoint(Byte[] bytes, Int32[] evtStackModuleIds, IContinuousEventExtraData extraData);
    private void SendContinuousSymbolLoad(int moduleId);
    private void SendContinuousThreadCreate(int threadId, string threadName);
    private void SendContinuousThreadNameChange(int threadId, string threadName);
    private void SendContinuousThreadDestroy(int threadId);
    private void SendPdqTruncationTelemetry(string categoryId, int originalLength);
    private void SendSideLoadStop(int threadId, int stopCode);
    private void SendSideLoadHiddenEntry(int threadId);
    private void SendSideLoad(int threadId);
    private void SendMessageToLogger(MsgHandle msgHandle, int msgLen);
    private void WriteMessageToLogger(MsgHandle msgHandle, int msgLen);
    private void ThrowIfDisposed();
    private static long UncheckedConvertToLong(ulong value);
}
internal class Microsoft.VisualStudio.TraceDebugger.DebugInterfaceEnumerator`2 : DebugEnumerator`1<T> {
    protected DebugInterfaceEnumerator`2(T[] items);
    private int _Next(UInt32 count, I[] items, UInt32& countFetched);
    public sealed virtual int Next(UInt32 count, I[] items, UInt32& countFetched);
}
internal enum Microsoft.VisualStudio.TraceDebugger.DebugLanguage : Enum {
    public int value__;
    public static DebugLanguage CSharp;
    public static DebugLanguage Basic;
    public static DebugLanguage CPlusPlus;
    public static DebugLanguage None;
}
internal class Microsoft.VisualStudio.TraceDebugger.DebugProperty : ComMarshal {
    private Property _prop;
    private EngineLock _engineLock;
    private UInt32 _syncCount;
    public DebugProperty(Property prop, EngineLock engineLock);
    private int _GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, UInt32 dwTimeout, IDebugReference2[] rgpArgs, UInt32 dwArgCount, DEBUG_PROPERTY_INFO[] pPropertyInfo);
    private int _EnumChildren(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, Guid& guidFilter, enum_DBG_ATTRIB_FLAGS dwAttribFilter, string pszNameFilter, UInt32 dwTimeout, IEnumDebugPropertyInfo2& ppEnum);
    private int _CreateObjectID();
    private int _DestroyObjectID();
    private int _GetCustomViewerCount(UInt32& pcelt);
    private int _GetCustomViewerList(UInt32 celtSkip, UInt32 celtRequested, DEBUG_CUSTOM_VIEWER[] rgViewers, UInt32& pceltFetched);
    private int _GetDerivedMostProperty(IDebugProperty2& ppDerivedMost);
    private int _GetExtendedInfo(Guid& guidExtendedInfo, Object& pExtendedInfo);
    private int _GetMemoryBytes(IDebugMemoryBytes2& ppMemoryBytes);
    private int _GetMemoryContext(IDebugMemoryContext2& ppMemory);
    private int _GetParent(IDebugProperty2& ppParent);
    private int _GetReference(IDebugReference2& ppReference);
    private int _GetSize(UInt32& pdwSize);
    private int _GetStringCharLength(UInt32& pLen);
    private int _SetValueAsReference(IDebugReference2[] rgpArgs, UInt32 dwArgCount, IDebugReference2 pValue, UInt32 dwTimeout);
    private int _SetValueAsString(string pszValue, UInt32 dwRadix, UInt32 dwTimeout);
    private int _SetValueAsStringWithError(string pszValue, UInt32 dwRadix, UInt32 dwTimeout, String& errorString);
    private int _GetStringChars(UInt32 buflen, UInt16[] rgString, UInt32& pceltFetched);
    internal DEBUG_PROPERTY_INFO GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, UInt32 dwTimeout);
    internal DEBUG_PROPERTY_INFO GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, UInt32 dwTimeout, bool showDeclaredTypeForArgs);
    internal List`1<DEBUG_PROPERTY_INFO> EnumChildren(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, Guid& guidFilter, enum_DBG_ATTRIB_FLAGS dwAttribFilter, string pszNameFilter, UInt32 dwTimeout);
    public sealed virtual int GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, UInt32 dwTimeout, IDebugReference2[] rgpArgs, UInt32 dwArgCount, DEBUG_PROPERTY_INFO[] pPropertyInfo);
    public sealed virtual int EnumChildren(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix, Guid& guidFilter, enum_DBG_ATTRIB_FLAGS dwAttribFilter, string pszNameFilter, UInt32 dwTimeout, IEnumDebugPropertyInfo2& ppEnum);
    public sealed virtual int CreateObjectID();
    public sealed virtual int DestroyObjectID();
    public sealed virtual int GetCustomViewerCount(UInt32& pcelt);
    public sealed virtual int GetCustomViewerList(UInt32 celtSkip, UInt32 celtRequested, DEBUG_CUSTOM_VIEWER[] rgViewers, UInt32& pceltFetched);
    public sealed virtual int GetDerivedMostProperty(IDebugProperty2& ppDerivedMost);
    public sealed virtual int GetExtendedInfo(Guid& guidExtendedInfo, Object& pExtendedInfo);
    public sealed virtual int GetMemoryBytes(IDebugMemoryBytes2& ppMemoryBytes);
    public sealed virtual int GetMemoryContext(IDebugMemoryContext2& ppMemory);
    public sealed virtual int GetParent(IDebugProperty2& ppParent);
    public sealed virtual int GetReference(IDebugReference2& ppReference);
    public sealed virtual int GetSize(UInt32& pdwSize);
    public sealed virtual int GetStringCharLength(UInt32& pLen);
    public sealed virtual int SetValueAsReference(IDebugReference2[] rgpArgs, UInt32 dwArgCount, IDebugReference2 pValue, UInt32 dwTimeout);
    public sealed virtual int SetValueAsString(string pszValue, UInt32 dwRadix, UInt32 dwTimeout);
    public sealed virtual int SetValueAsStringWithError(string pszValue, UInt32 dwRadix, UInt32 dwTimeout, String& errorString);
    public sealed virtual int GetStringChars(UInt32 buflen, UInt16[] rgString, UInt32& pceltFetched);
    [CompilerGeneratedAttribute]
private int <CreateObjectID>b__27_0();
    [CompilerGeneratedAttribute]
private int <DestroyObjectID>b__28_0();
}
internal static class Microsoft.VisualStudio.TraceDebugger.DiagnosticLogging : object {
    private static TraceSwitch s_trace;
    public static TraceSwitch Tracing { get; }
    private static DiagnosticLogging();
    public static TraceSwitch get_Tracing();
}
internal class Microsoft.VisualStudio.TraceDebugger.DocumentContext : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private string _filename;
    private TEXT_POSITION _begin;
    private TEXT_POSITION _end;
    private CodeContext _location;
    private SourceSearchPolicy _searchPolicy;
    private DocumentContext(Debuggee debuggee, CodeContext location, SourceSearchPolicy searchPolicy);
    internal static DocumentContext Construct(Debuggee debuggee, CodeContext location, SourceSearchPolicy searchPolicy);
    private bool FetchData();
    private int _GetName(enum_GETNAME_TYPE gnType, String& pbstrFileName);
    private int _GetStatementRange(TEXT_POSITION[] pBegPosition, TEXT_POSITION[] pEndPosition);
    private int _GetDocument(IDebugDocument2& ppDocument);
    private int _Compare(enum_DOCCONTEXT_COMPARE Compare, IDebugDocumentContext2[] rgpDocContextSet, UInt32 dwDocContextSetLen, UInt32& pdwDocContext);
    private int _EnumCodeContexts(IEnumDebugCodeContexts2& ppEnumCodeCxts);
    private int _GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    private int _GetSourceRange(TEXT_POSITION[] pBegPosition, TEXT_POSITION[] pEndPosition);
    private int _Seek(int nCount, IDebugDocumentContext2& ppDocContext);
    public int _GetChecksumAndAlgorithmId(Guid& pRetVal, UInt32 cMaxBytes, Byte[] pChecksum, UInt32& pcNumBytes);
    public sealed virtual int GetName(enum_GETNAME_TYPE gnType, String& pbstrFileName);
    public sealed virtual int GetStatementRange(TEXT_POSITION[] pBegPosition, TEXT_POSITION[] pEndPosition);
    public sealed virtual int GetDocument(IDebugDocument2& ppDocument);
    public sealed virtual int Compare(enum_DOCCONTEXT_COMPARE Compare, IDebugDocumentContext2[] rgpDocContextSet, UInt32 dwDocContextSetLen, UInt32& pdwDocContext);
    public sealed virtual int EnumCodeContexts(IEnumDebugCodeContexts2& ppEnumCodeCxts);
    public sealed virtual int GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    public sealed virtual int GetSourceRange(TEXT_POSITION[] pBegPosition, TEXT_POSITION[] pEndPosition);
    public sealed virtual int Seek(int nCount, IDebugDocumentContext2& ppDocContext);
    public sealed virtual int GetChecksumAndAlgorithmId(Guid& pRetVal, UInt32 cMaxBytes, Byte[] pChecksum, UInt32& pcNumBytes);
}
internal class Microsoft.VisualStudio.TraceDebugger.DumpProgramNode : ProgramNode {
    internal Guid _programId;
    public DumpProgramNode(AD_PROCESS_ID hostPID, string loggerName);
    public int _OnAttach(Guid& guidProgramId);
    public sealed virtual int OnAttach(Guid& guidProgramId);
}
[ComVisibleAttribute("True")]
[GuidAttribute("cc8487da-137a-4983-b3d5-7e303de3c7de")]
public class Microsoft.VisualStudio.TraceDebugger.Engine : ComMarshal {
    private Guid _engineId;
    private string _registryRoot;
    private IDebugEventCallback2 _callback;
    private Debuggee _debuggee;
    private int _launchThreadId;
    private long _launchOrdinal;
    private bool _fTdlogDebugging;
    private EngineLock _engineLock;
    [CompilerGeneratedAttribute]
private bool <IsJustMyCodeOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionSymbolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <UICulture>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolLocator140 <SymbolLocator>k__BackingField;
    internal int QueueProcessingTid;
    internal EngineLock EngineLock { get; }
    internal bool IsJustMyCodeOn { get; internal set; }
    internal string SessionSymbolPath { get; internal set; }
    internal string RegistryRoot { get; }
    internal CultureInfo UICulture { get; private set; }
    internal ISymbolLocator140 SymbolLocator { get; private set; }
    internal EngineLock get_EngineLock();
    [CompilerGeneratedAttribute]
internal bool get_IsJustMyCodeOn();
    [CompilerGeneratedAttribute]
internal void set_IsJustMyCodeOn(bool value);
    [CompilerGeneratedAttribute]
internal string get_SessionSymbolPath();
    [CompilerGeneratedAttribute]
internal void set_SessionSymbolPath(string value);
    internal string get_RegistryRoot();
    [CompilerGeneratedAttribute]
internal CultureInfo get_UICulture();
    [CompilerGeneratedAttribute]
private void set_UICulture(CultureInfo value);
    [CompilerGeneratedAttribute]
internal ISymbolLocator140 get_SymbolLocator();
    [CompilerGeneratedAttribute]
private void set_SymbolLocator(ISymbolLocator140 value);
    private int _Attach(IDebugProgram2[] rgpPrograms, IDebugProgramNode2[] rgpProgramNodes, UInt32 celtPrograms, IDebugEventCallback2 pCallback, enum_ATTACH_REASON dwReason);
    private int _CauseBreak();
    private int _ContinueFromSynchronousEvent(IDebugEvent2 pEvent);
    private int _DestroyProgram(IDebugProgram2 pProgram);
    private int _EnumPrograms(IEnumDebugPrograms2& ppEnum);
    private int _GetEngineId(Guid& pguidEngine);
    private int _LoadSymbols();
    private int _RemoveAllSetExceptions(Guid& guidType);
    private int _RemoveSetException(EXCEPTION_INFO[] pException);
    private int _SetAllExceptions(enum_EXCEPTION_STATE dwState);
    private int _SetEngineGuid(Guid& guidEngine);
    private int _SetException(EXCEPTION_INFO[] pException);
    private int _SetJustMyCodeState(int fUpdate, UInt32 dwModules, JMC_CODE_SPEC[] rgJMCSpec);
    private int _SetLocale(ushort wLangID);
    private int _SetMetric(string pszMetric, object varValue);
    private int _SetRegistryRoot(string pszRegistryRoot);
    private int _SetSymbolPath(string szSymbolSearchPath, string szSymbolCachePath, UInt32 Flags);
    private int _CanTerminateProcess(IDebugProcess2 pProcess);
    private int _LaunchSuspended(string pszServer, IDebugPort2 pPort, string pszExe, string pszArgs, string pszDir, string bstrEnv, string pszOptions, enum_LAUNCH_FLAGS dwLaunchFlags, UInt32 hStdInput, UInt32 hStdOutput, UInt32 hStdError, IDebugEventCallback2 pCallback, IDebugProcess2& ppProcess);
    private int _ResumeProcess(IDebugProcess2 pProcess);
    private int _TerminateProcess(IDebugProcess2 pProcess);
    internal int EnsureSymbolLocatorInitialized();
    internal void SendEvent(Program program, Thread thread, DebugEvent`1<T> debugEvent, Guid& eventId, enum_EVENTATTRIBUTES attributes);
    internal void SetJMCState(IDebugEventCallback2 callback);
    public sealed virtual int Attach(IDebugProgram2[] rgpPrograms, IDebugProgramNode2[] rgpProgramNodes, UInt32 celtPrograms, IDebugEventCallback2 pCallback, enum_ATTACH_REASON dwReason);
    public sealed virtual int CauseBreak();
    public sealed virtual int ContinueFromSynchronousEvent(IDebugEvent2 pEvent);
    public sealed virtual int CreatePendingBreakpoint(IDebugBreakpointRequest2 pBPRequest, IDebugPendingBreakpoint2& ppPendingBP);
    public sealed virtual int DestroyProgram(IDebugProgram2 pProgram);
    public sealed virtual int EnumPrograms(IEnumDebugPrograms2& ppEnum);
    public sealed virtual int GetEngineId(Guid& pguidEngine);
    public sealed virtual int LoadSymbols();
    public sealed virtual int RemoveAllSetExceptions(Guid& guidType);
    public sealed virtual int RemoveSetException(EXCEPTION_INFO[] pException);
    public sealed virtual int SetAllExceptions(enum_EXCEPTION_STATE dwState);
    public sealed virtual int SetEngineGuid(Guid& guidEngine);
    public sealed virtual int SetException(EXCEPTION_INFO[] pException);
    public sealed virtual int SetJustMyCodeState(int fUpdate, UInt32 dwModules, JMC_CODE_SPEC[] rgJMCSpec);
    public sealed virtual int SetLocale(ushort wLangID);
    public sealed virtual int SetMetric(string pszMetric, object varValue);
    public sealed virtual int SetRegistryRoot(string pszRegistryRoot);
    public sealed virtual int SetSymbolPath(string szSymbolSearchPath, string szSymbolCachePath, UInt32 Flags);
    public sealed virtual int CanTerminateProcess(IDebugProcess2 pProcess);
    public sealed virtual int LaunchSuspended(string pszServer, IDebugPort2 pPort, string pszExe, string pszArgs, string pszDir, string bstrEnv, string pszOptions, enum_LAUNCH_FLAGS dwLaunchFlags, UInt32 hStdInput, UInt32 hStdOutput, UInt32 hStdError, IDebugEventCallback2 pCallback, IDebugProcess2& ppProcess);
    public sealed virtual int ResumeProcess(IDebugProcess2 pProcess);
    public sealed virtual int TerminateProcess(IDebugProcess2 pProcess);
    [CompilerGeneratedAttribute]
private int <CauseBreak>b__54_0();
    [CompilerGeneratedAttribute]
private int <LoadSymbols>b__60_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.EngineCreateEvent : DebugEvent`1<IDebugEngineCreateEvent2> {
    internal EngineCreateEvent(Engine engine);
    public sealed virtual int GetEngine(IDebugEngine2& engine);
}
internal class Microsoft.VisualStudio.TraceDebugger.EngineLock : object {
    [CompilerGeneratedAttribute]
private bool <IsTerminated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLoggerSuspended>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SyncCount>k__BackingField;
    internal bool IsTerminated { get; internal set; }
    internal bool IsLoggerSuspended { get; internal set; }
    internal UInt32 SyncCount { get; private set; }
    [CompilerGeneratedAttribute]
internal bool get_IsTerminated();
    [CompilerGeneratedAttribute]
internal void set_IsTerminated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsLoggerSuspended();
    [CompilerGeneratedAttribute]
internal void set_IsLoggerSuspended(bool value);
    [CompilerGeneratedAttribute]
internal UInt32 get_SyncCount();
    [CompilerGeneratedAttribute]
private void set_SyncCount(UInt32 value);
    internal void IncrementSyncCount();
    internal int CheckConsistency(UInt32 syncRequest);
}
internal class Microsoft.VisualStudio.TraceDebugger.EngineNotifyHandler : object {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private LoggerManager _loggerManager;
    internal EngineNotifyHandler(Debuggee debuggee, LoggerManager loggerManager);
    public sealed virtual int AlertSymbolLoad(ulong id, string strModulePath, Guid& moduleId, UInt32 appDomainId, ulong baseAddress);
    public sealed virtual int AlertModuleLoad(ulong id, string strModulePath, Guid& moduleId, UInt32 appDomainId, ulong baseAddress, bool isUserCode);
    public sealed virtual int AlertModuleUnload(ulong id, Guid& moduleId, UInt32 appDomainId);
    public sealed virtual int AlertThreadCreate(ulong id, UInt32 dwTid, string strPriorityName, string strName, UInt32 dwCategory);
    public sealed virtual int AlertThreadNameChange(ulong id, UInt32 dwTid, string strName, UInt32 dwCategory);
    public sealed virtual int AlertThreadDestroy(ulong id, UInt32 dwTid);
    public sealed virtual int AlertProgramDestroy();
    public sealed virtual int AlertEnteringBreakMode(ulong id, UInt32 tid, NOTIFY_STOP_TYPE stopType);
    public sealed virtual int AlertExitingBreakMode();
    public sealed virtual int AlertException(ulong id, UInt32 tid, ExceptionNotifyData exceptionData);
    public sealed virtual int AlertNotifyPoint(ulong id, UInt32 tid, Guid& moduleId, UInt32 appDomainId, UInt32 notifyPointId);
    public sealed virtual int DisambiguateNotifyPoint(UInt32 notifyPointId, object pMetadata, UInt32 ctMethodTokens, UInt32[] rgdwMethodTokens, UInt32& pdwMatchingMethodToken);
    public sealed virtual int AlertBeforeContinueExecution(UInt32 tid);
    private int _AlertSymbolLoad(ulong id, string strModulePath, Guid& moduleId, UInt32 appDomainId, ulong baseAddress);
    private int _AlertModuleLoad(ulong id, string strModulePath, Guid& moduleId, UInt32 appDomainId, ulong baseAddress, bool fUserCode);
    private int _AlertModuleUnload(ulong id, Guid& moduleId, UInt32 appDomainId);
    private int _AlertThreadCreate(ulong id, UInt32 dwTid, string strPriorityName, string strName, UInt32 dwCategory);
    private int _AlertThreadNameChange(ulong id, UInt32 dwTid, string strName, UInt32 dwCategory);
    private int _AlertThreadDestroy(ulong id, UInt32 dwTid);
    private int _AlertProgramDestroy();
    private int _AlertEnteringBreakMode(ulong id, UInt32 tid, NOTIFY_STOP_TYPE stopType);
    private int _AlertExitingBreakMode();
    private int _AlertException(ulong id, UInt32 tid, ExceptionNotifyData exceptionData);
    private int _AlertNotifyPoint(ulong id, UInt32 tid, Guid& moduleId, UInt32 appDomainId, UInt32 notifyPointId);
    private int _DisambiguateNotifyPoint(UInt32 notifyPointId, object pMetadata, UInt32 ctMethodTokens, UInt32[] rgdwMethodTokens, UInt32& pdwMatchingMethodToken);
    private int _AlertBeforeContinueExecution(UInt32 tid);
    private int ExecuteWithEngineLock(Func`1<int> action);
    private int HandleNotifyEventWithEngineLock(Func`1<NotifyEvent> createNotifyEvent);
    private int HandleNotifyEvent(Func`1<NotifyEvent> createNotifyEvent);
    [CompilerGeneratedAttribute]
private int <AlertProgramDestroy>b__6_0();
    [CompilerGeneratedAttribute]
private int <AlertExitingBreakMode>b__8_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.EnteringBreakModeNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal NOTIFY_STOP_TYPE _stopType;
    internal EnteringBreakModeNotifyEvent(long eventCounter, ulong id, UInt32 tid, NOTIFY_STOP_TYPE stopType);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.EnumProperty : LeafProperty {
    private Symbol _field;
    protected TypeDefType _type;
    protected PrimitiveType _enumType;
    private PrimitiveData _data;
    public bool IsReturnValue { get; }
    public EnumProperty(IFormatter formatter, EngineLock engineLock, Symbol field, PrimitiveData value, bool isOutParam);
    public virtual bool get_IsReturnValue();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
}
internal class Microsoft.VisualStudio.TraceDebugger.ErrorProperty : Property {
    private string _name;
    private string _message;
    public ErrorProperty(string name, string message);
    public ErrorProperty(string message);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
}
internal class Microsoft.VisualStudio.TraceDebugger.ExceptionNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal ExceptionNotifyData _exceptionData;
    internal ExceptionNotifyEvent(long eventCounter, ulong id, UInt32 tid, ExceptionNotifyData exceptionData);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.ExitingBreakModeNotifyEvent : NotifyEvent {
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
public class Microsoft.VisualStudio.TraceDebugger.Expression : ComMarshal {
    private Property _property;
    private UInt32 _radix;
    private string _szExpression;
    private static Regex s_CSRegex;
    private static Regex s_VBRegex;
    private static Regex s_IgnorableExprRegex;
    private static Dictionary`2<string, int> s_ExceptionList;
    private static string s_tracepointData;
    private static Expression();
    internal Expression(string pszCode, UInt32 nRadix, Property property);
    internal int _Abort();
    internal int _EvaluateAsync(enum_EVALFLAGS dwFlags, IDebugEventCallback2 pExprCallback);
    internal int _EvaluateSync(enum_EVALFLAGS dwFlags, UInt32 dwTimeout, IDebugEventCallback2 pExprCallback, IDebugProperty2& ppResult);
    private ParseResult ParseExpression(string szExpression, DebugLanguage language);
    private bool IsIndependentPropName(string szExpression);
    private Property EvaluateHelper(int depth, String[] names, Property prop, UInt32 dwTimeout);
    public sealed virtual int Abort();
    public sealed virtual int EvaluateAsync(enum_EVALFLAGS dwFlags, IDebugEventCallback2 pExprCallback);
    public sealed virtual int EvaluateSync(enum_EVALFLAGS dwFlags, UInt32 dwTimeout, IDebugEventCallback2 pExprCallback, IDebugProperty2& ppResult);
    [CompilerGeneratedAttribute]
private int <Abort>b__17_0();
}
public class Microsoft.VisualStudio.TraceDebugger.ExpressionContext : ComMarshal {
    private Property _prop;
    internal ExpressionContext(Property prop);
    internal int _GetName(String& pbstrName);
    internal int _ParseText(string pszCode, enum_PARSEFLAGS dwFlags, UInt32 nRadix, IDebugExpression2& ppExpr, String& pbstrError, UInt32& pichError);
    public sealed virtual int GetName(String& pbstrName);
    public sealed virtual int ParseText(string pszCode, enum_PARSEFLAGS dwFlags, UInt32 nRadix, IDebugExpression2& ppExpr, String& pbstrError, UInt32& pichError);
}
internal class Microsoft.VisualStudio.TraceDebugger.ExternalFrame : StackFrame {
    [CompilerGeneratedAttribute]
private StackFrame <VirtualLocation>k__BackingField;
    internal StackFrame VirtualLocation { get; internal set; }
    [CompilerGeneratedAttribute]
internal StackFrame get_VirtualLocation();
    [CompilerGeneratedAttribute]
internal void set_VirtualLocation(StackFrame value);
    internal virtual FRAMEINFO GetInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix);
    protected virtual int _EnumProperties(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 nRadix, Guid& guidFilter, UInt32 dwTimeout, UInt32& pcelt, IEnumDebugPropertyInfo2& ppEnum);
    protected virtual int _GetCodeContext(IDebugCodeContext2& ppCodeCxt);
    protected virtual int _GetDebugProperty(IDebugProperty2& ppProperty);
    protected virtual int _GetDocumentContext(IDebugDocumentContext2& ppCxt);
    protected virtual int _GetExpressionContext(IDebugExpressionContext2& ppExprCxt);
    protected virtual int _GetInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix, FRAMEINFO[] pFrameInfo);
    protected virtual int _GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    protected virtual int _GetName(String& pbstrName);
    protected virtual int _GetPhysicalStackRange(UInt64& paddrMin, UInt64& paddrMax);
    protected virtual int _GetThread(IDebugThread2& ppThread);
    protected virtual int _GetUnwindCodeContext(IDebugCodeContext2& ppCodeContext);
    protected virtual int _InterceptCurrentException(enum_INTERCEPT_EXCEPTION_ACTION dwFlags, UInt64& pqwCookie);
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.Formatter : BuiltinDataTypeFormatter {
    private static ushort NUMBER_GUID_CHILD;
    private static ushort NUMBER_DECIMAL_CHILD;
    private static ushort NUMBER_DATETIME_CHILD;
    private static ushort NUMBER_TIMESPAN_CHILD;
    public DebugLanguage Language { get; }
    public abstract virtual DebugLanguage get_Language();
    public virtual string FormatClass(TypeDefType type, ClassData data, ClassProperty prop, UInt32 radix);
    public virtual string FormatArrayType(Symbol symbol, ArrayType array, bool useRuntimeType, UInt32 radix);
    protected void AppendArrayElementTypeName(StringBuilder sb, Symbol symbol, Type elementType, bool useRuntimeType, UInt32 radix);
    protected void AppendArrayRank(StringBuilder sb, int rank, Type elementType, bool useRuntimeType, UInt32 radix);
    public virtual string FormatArray(ArrayType type, Int32[] dimensions, ArrayData arrayData, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.FrameInfoEnumerator : DebugEnumerator`1<FRAMEINFO> {
    internal FrameInfoEnumerator(FRAMEINFO[] frameInfos);
    private int _Clone(IEnumDebugFrameInfo2& clone);
    public sealed virtual int Clone(IEnumDebugFrameInfo2& clone);
}
internal static class Microsoft.VisualStudio.TraceDebugger.FunctionInfoBuilder : object {
    internal static ArgInfo[] GetArgs(MethodProperty methodProp, UInt32 radix);
    internal static string ConcatArgs(ArgInfo[] args, bool fIncludeNames, bool fIncludeTypes, bool fIncludeValues);
    internal static string FormatMethodExit(string funcName);
    internal static string FormatMethodEnter(string funcName);
    internal static string FormatFunction(NODEINFO_FLAGS formatFlags, string funcName, string module, string retType, ArgInfo[] args);
}
internal interface Microsoft.VisualStudio.TraceDebugger.IFormatter {
    public DebugLanguage Language { get; }
    public abstract virtual DebugLanguage get_Language();
    public abstract virtual string FormatDataUnavailable(LogData data);
    public abstract virtual string FormatKeyword(FormatterKeyword keyword);
    public abstract virtual string FormatSymbol(Symbol symbol, bool isOutParam, UInt32 radix);
    public abstract virtual string FormatMethodName(MethodType method, FormatterMethodOptions options);
    public abstract virtual string FormatType(Symbol symbol, Type type, UInt32 radix);
    public abstract virtual string FormatArrayType(Symbol symbol, ArrayType array, bool useRuntimeType, UInt32 radix);
    public abstract virtual string FormatPrimitive(PrimitiveType type, PrimitiveData data, UInt32 radix);
    public abstract virtual string FormatString(string value, UInt32 radix, bool partialData);
    public abstract virtual string FormatClass(TypeDefType type, ClassData data, ClassProperty prop, UInt32 radix);
    public abstract virtual string FormatArray(ArrayType type, Int32[] dimensions, ArrayData arrayData, UInt32 radix);
    public abstract virtual string FormatPointer(int value);
    public abstract virtual string FormatPointer(long value);
    public abstract virtual string GetMethodName(string methodName);
}
internal class Microsoft.VisualStudio.TraceDebugger.IndependentEventDetailProperty : Property {
    private string _name;
    private string _value;
    private string _type;
    internal IndependentEventDetailProperty(string name, string value, string typeName);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
}
internal class Microsoft.VisualStudio.TraceDebugger.IndependentProperty : RootProperty {
    private static char SpaceSeparator;
    private static char CommaSeparator;
    private static string EqualsSign;
    private static string ArgumentFieldSeparator;
    private static string ArgumentObjectSeparator;
    private LogData _data;
    [CompilerGeneratedAttribute]
private long <EventTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <ActivityId>k__BackingField;
    private MethodProperty _methodProperty;
    public NotifyType _notifyType;
    public Debuggee _debuggee;
    public EventHandle _eventHandle;
    private int _frameIndex;
    private int _dataRecordedThread;
    private static Dictionary`2<EventType, enum_DBG_ATTRIB_FLAGS_extended> _eventTypeAttributeMap;
    public IndependentData IndependentData { get; }
    public MethodData MethodData { get; }
    public long EventTime { get; private set; }
    public Nullable`1<Guid> ActivityId { get; private set; }
    private static IndependentProperty();
    private IndependentProperty(IFormatter formatter, EngineLock engineLock, Debuggee debuggee, LogData data, NotifyType notifyType, int frameIndex, int osTid, long eventTime, Nullable`1<Guid> activityId, EventHandle evtHandle);
    internal IndependentProperty(IFormatter formatter, EngineLock engineLock, Debuggee debuggee, LogData data, int notifyId, int osTid, long eventTime, Nullable`1<Guid> activityId, EventHandle evtHandle);
    internal IndependentProperty(IFormatter formatter, EngineLock engineLock, Debuggee debuggee, MethodData data, int notifyId, int osTid, CodeContext location, long eventTime, Nullable`1<Guid> activityId, EventHandle evtHandle);
    internal IndependentProperty(IFormatter formatter, EngineLock engineLock, IndependentProperty leafStackFrameProperty, int frameIndex, int osTid);
    public IndependentData get_IndependentData();
    public MethodData get_MethodData();
    [CompilerGeneratedAttribute]
public long get_EventTime();
    [CompilerGeneratedAttribute]
private void set_EventTime(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_ActivityId();
    [CompilerGeneratedAttribute]
private void set_ActivityId(Nullable`1<Guid> value);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 radix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    private bool IsExceptionEvent();
    private bool IsExceptionThrown();
    private bool IsExceptionCaught();
    public string GetShortDescription(NotifyNode node, DiagnosticEvent npEvt, SourceSearchPolicy searchPolicy);
    public string GetLongDescription();
    public string GetDebugLocation(NotifyNode node, DiagnosticEvent npEvt, SourceSearchPolicy searchPolicy);
    public EventType GetEventType();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceDebugger.IndependentProperty/<GetSupplementalArgumentProperties>d__44")]
public IEnumerable`1<Property> GetSupplementalArgumentProperties();
    private List`1<Tuple`2<object, bool>> GetDataValues();
    private string GetCategoryName();
    private bool DataCollectedFromSameFrame(DebuggerInteractionEvent evt);
    private void GetSpecificChildren(List`1<Property> children, UI_ELEMENT elemtype);
    private void GetUIEventChildren(DebuggerInteractionEvent uievent, Dictionary`2<string, RecordedProperty> properties, bool mergeOnly);
    private void AppendDataQueriesAsChildProperties(List`1<Property> properties, bool includeCallStackInfo);
    private string FormatDebuggerEventName(NotifyNode node, SourceSearchPolicy searchPolicy);
    private string GetModuleName(EventHandle eventHandle);
    private string GetModuleName(DiagnosticEvent evt);
    private string GetModuleName(NotifyNode node);
    private string FormatDebuggerEventName(DiagnosticEvent npEvt, SourceSearchPolicy searchPolicy);
    private enum_DBG_ATTRIB_FLAGS_extended GetEventTypeAttribute(EventType type);
    private IFormattable GetFormattedChildByIndex(int index);
    private List`1<Property> GetAllChildren(Guid& guidFilter);
}
internal static class Microsoft.VisualStudio.TraceDebugger.LanguageHelper : object {
    private static Dictionary`2<Guid, DebugLanguage> s_languageIds;
    private static LanguageHelper();
    public static LanguageInfo GetLanguageInfoOfMethod(Debuggee debuggee, MethodContext context);
    public static string GetLanguageName(DebugLanguage langId);
    public static IFormatter GetFormatter(Debuggee debuggee, MethodContext location);
    public static IFormatter GetFormatter(ModuleSymbols modSyms, int methodToken);
    private static IFormatter GetFormatter(DebugLanguage id);
}
internal class Microsoft.VisualStudio.TraceDebugger.LanguageInfo : ValueType {
    internal DebugLanguage Id;
    internal Guid Guid;
    internal string Name;
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.LeafProperty : Property {
    protected LeafProperty(IFormatter formatter, EngineLock engineLock, bool isOutParam);
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.LineInfoHelper : object {
    private Debuggee _debuggee;
    private Nullable`1<int> _aspNetEventId;
    internal LineInfoHelper(Debuggee debuggee, bool isASPNetUserCode);
    internal bool IsEventHandleInUserCode(EventHandle eventHandle);
    private bool IsNodeHandleInUserCode(EventHandle eventHandle);
    private bool IsECHandleInUserCode(EventHandle eventHandle);
    private bool CanStepIn(EventHandle evt);
    internal EventHandle GetNextCallsiteInStatement(EventHandle current);
    internal EventHandle GetPreviousCallsiteInStatement(EventHandle current);
    internal EventHandle[] GetSiblingsOnStatement(EventHandle current);
    internal EventHandle[] GetSiblingsOnStatement(EventHandle current, EventHandle& firstSibling, EventHandle& lastSibling);
    internal EventHandle GetSiblingOnNextStatement(EventHandle current);
    internal EventHandle GetSiblingOnPreviousStatement(EventHandle current);
}
internal class Microsoft.VisualStudio.TraceDebugger.LoadCompleteEvent : DebugEvent`1<IDebugLoadCompleteEvent2> {
    internal LoadCompleteEvent(Engine engine, Program program);
    internal LoadCompleteEvent(Engine engine, Program program, Thread thread);
}
internal class Microsoft.VisualStudio.TraceDebugger.LoggerManager : object {
    private TraceLogger _traceLogger;
    private bool _traceLoggerStopped;
    private IntelliTraceFileBase _traceLogFile;
    private QueuedIpcPipeClient _processIpcClient;
    private NamedCounter _eventCounter;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public IntelliTraceFileBase StreamDispenser { get; }
    internal QueuedIpcPipeClient ProcessIpcClient { get; }
    internal NamedCounter EventCounter { get; internal set; }
    internal bool IsInitialized { get; private set; }
    public IntelliTraceFileBase get_StreamDispenser();
    internal QueuedIpcPipeClient get_ProcessIpcClient();
    internal NamedCounter get_EventCounter();
    internal void set_EventCounter(NamedCounter value);
    [CompilerGeneratedAttribute]
internal bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public void InitializeAttach(string loggerName);
    public void InitializeLaunch(string logFilePath);
    public long GetNewEventOrdinal();
    public int GetNewIntelliTraceToken();
    public bool SuspendCollection();
    public void ResumeCollection();
    public IList`1<string> GetErrors();
    public void CheckpointCollection(Byte* pData, int msgLen);
    public bool GetLoggerProcessInfo(Int32& processID, Int64& processCreationTime);
    public void StopLogger();
    public void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.TraceDebugger.MessageEvent : DebugEvent`1<IDebugMessageEvent2> {
    private string _message;
    internal MessageEvent(Engine engine, string message);
    internal MessageEvent(Engine engine, Program program, string message);
    internal MessageEvent(Engine engine, Program program, Thread thread, string message);
    public sealed virtual int GetMessage(enum_MESSAGETYPE[] pMessageType, String& pbstrMessage, UInt32& pdwType, String& pbstrHelpFileName, UInt32& pdwHelpId);
    public sealed virtual int SetResponse(UInt32 dwResponse);
}
internal class Microsoft.VisualStudio.TraceDebugger.MessageProperty : LeafProperty {
    protected string _name;
    protected string _message;
    public MessageProperty(string name, string message);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
}
[DebuggerDisplayAttribute("MethodProperty: MethodName = { GetFullName(10) }")]
internal class Microsoft.VisualStudio.TraceDebugger.MethodProperty : RootProperty {
    protected MethodData _inData;
    protected MethodData _outData;
    protected string _name;
    protected string _type;
    protected string _value;
    private bool _isExitEvent;
    private List`1<Property> _inParams;
    private List`1<Property> _outParams;
    private Property _this;
    private Property _retVal;
    private static string EqualsSign;
    protected MethodType _methodType;
    internal MethodType MethodType { get; }
    internal bool IsDataCollected { get; }
    internal MethodProperty(IFormatter formatter, EngineLock engineLock, ModuleSymbols symbols, CodeContext location, MethodData inData, MethodData outData, bool isExitEvent);
    internal MethodProperty(IFormatter formatter, EngineLock engineLock, Debuggee debuggee, CodeContext location, MethodData inData, MethodData outData, bool isExitEvent);
    internal MethodProperty(IFormatter formatter, EngineLock engineLock, Debuggee debuggee, CodeContext location);
    public string GetLanguage(UInt32 radix);
    protected virtual string GetMethodName();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 radix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
    internal MethodType get_MethodType();
    internal virtual bool get_IsDataCollected();
    internal List`1<Property> GetChildren(Filter filter);
    private void EnsureParameters();
}
internal class Microsoft.VisualStudio.TraceDebugger.Module : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private Guid _mvid;
    private string _path;
    private long _baseLoadAddress;
    private ModuleData _mdata;
    private UInt32 _loadOrder;
    private static Dictionary`2<Guid, ModulePdbInfo> _pdbInfoMap;
    internal string ModuleName { get; }
    internal Guid Mvid { get; }
    internal ModuleData Data { get; }
    internal Module(Debuggee debuggee, ModuleData logModule, UInt32 loadOrder);
    private static Module();
    internal string get_ModuleName();
    internal Guid get_Mvid();
    internal ModuleData get_Data();
    private int _GetInfo(enum_MODULE_INFO_FIELDS dwFields, MODULE_INFO[] pinfo);
    private int _GetSymbolInfo(enum_SYMBOL_SEARCH_INFO_FIELDS dwFields, MODULE_SYMBOL_SEARCH_INFO[] pinfo);
    private int _IsUserCode(Int32& pfUser);
    private bool HasDebugInfo();
    private int _LoadSymbols();
    private string GetPdbPath();
    private string LocatePdb(EmbeddedSymbolInfo symInfo);
    private int _ReloadSymbols_Deprecated(string pszUrlToSymbols, String& pbstrDebugMessage);
    private int _SetJustMyCodeState(int fIsUserCode);
    private int _GetSourceServerData(UInt32& pDataByteCount, IntPtr& ppData);
    private int _GetAppDomainInfo(UInt32& pAppDomainId, String& pbstrAppDomainName);
    internal int LoadSymbols(ProgramSymbols programSymbols, ISymbolContextProvider symbolContextProvider, bool searchForPdb);
    public sealed virtual int GetInfo(enum_MODULE_INFO_FIELDS dwFields, MODULE_INFO[] pinfo);
    public sealed virtual int GetSymbolInfo(enum_SYMBOL_SEARCH_INFO_FIELDS dwFields, MODULE_SYMBOL_SEARCH_INFO[] pinfo);
    public sealed virtual int IsUserCode(Int32& pfUser);
    public sealed virtual int LoadSymbols();
    public sealed virtual int ReloadSymbols_Deprecated(string pszUrlToSymbols, String& pbstrDebugMessage);
    public sealed virtual int SetJustMyCodeState(int fIsUserCode);
    public sealed virtual int GetSourceServerData(UInt32& pDataByteCount, IntPtr& ppData);
    public sealed virtual int GetAppDomainInfo(UInt32& pAppDomainId, String& pbstrAppDomainName);
    [CompilerGeneratedAttribute]
private int <LoadSymbols>b__31_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.ModuleEnumerator : DebugInterfaceEnumerator`2<Module, IDebugModule2> {
    internal ModuleEnumerator(Module[] modules);
    private int _Clone(IEnumDebugModules2& clone);
    public sealed virtual int Clone(IEnumDebugModules2& clone);
}
internal class Microsoft.VisualStudio.TraceDebugger.ModuleLoadEvent : DebugEvent`1<IDebugModuleLoadEvent2> {
    private Module _module;
    private bool _loading;
    internal ModuleLoadEvent(Engine engine, Program program, Thread thread, Module module, bool loading);
    public sealed virtual int GetModule(IDebugModule2& module, String& debugMessage, Int32& loading);
}
internal class Microsoft.VisualStudio.TraceDebugger.ModuleLoadNotifyEvent : NotifyEvent {
    internal Guid _moduleId;
    internal UInt32 _appDomainId;
    internal string _modulePath;
    internal bool _fUserCode;
    internal ulong _baseAddress;
    internal ModuleLoadNotifyEvent(long eventCounter, ulong id, Guid moduleId, UInt32 appDomainId, string modulePath, ulong baseAddress, bool fUserCode);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.ModuleUnloadNotifyEvent : NotifyEvent {
    internal Guid _moduleId;
    internal UInt32 _appDomainId;
    internal ModuleUnloadNotifyEvent(long eventCounter, ulong id, Guid moduleId, UInt32 appDomainId);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.NodeInfoBuilder : object {
    private NODEINFO_FLAGS _flags;
    private UInt32 _radix;
    private ITreeNode _node;
    private Property _prop;
    private Debuggee _debuggee;
    private EventHandle _originalEvt;
    private bool _fIsNotifyPoint;
    private bool _fIsRoot;
    private int _threadLoggerId;
    internal NodeInfoBuilder(EventHandle root, int threadLoggerId, Debuggee debuggee, NODEINFO_FLAGS flags, UInt32 radix);
    internal static void FindCallSite(EventHandle& evt, ITreeNode& node);
    internal NODEINFO Build();
    private static bool FlagSet(NODEINFO_FLAGS bitField, NODEINFO_FLAGS flag);
    private PROTEUS_EVENT_TYPE GetNodeType();
    private NODEINFO_FLAGS_VALUES GetFlags();
    private string GetReturnType();
    private string GetLanguage();
    private string GetModule();
    private string GetFunction();
    private static string ReplaceLowerCase(Match m);
    private string GetShortName();
    private string FormatNotify(ITreeNode node);
    private string GetEventCategoryId(ITreeNode node);
}
internal class Microsoft.VisualStudio.TraceDebugger.NodeInfoEnumerator : DebugEnumerator`1<NODEINFO> {
    internal NodeInfoEnumerator(NODEINFO[] frameInfos);
    private int _Clone(IEnumDebugNodeInfo100& clone);
    public sealed virtual int Clone(IEnumDebugNodeInfo100& clone);
}
internal class Microsoft.VisualStudio.TraceDebugger.NotCollectedProperty : MessageProperty {
    private NotCollectedData _data;
    private Symbol _field;
    private DataNotCollectedType _type;
    public bool IsReturnValue { get; }
    public NotCollectedProperty(Symbol field);
    public NotCollectedProperty(string elementName);
    public NotCollectedProperty(int dimension, Int32[] lengths, int totalElements);
    public virtual bool get_IsReturnValue();
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.NotifyEvent : object {
    internal long _eventCounter;
    internal ulong _id;
    protected NotifyEvent(long eventCounter, ulong id);
    internal abstract virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.NotifyPointNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal Guid _moduleId;
    internal UInt32 _appDomainId;
    internal int _notifyPointId;
    internal NotifyPointNotifyEvent(long eventCounter, ulong id, UInt32 tid, Guid moduleId, UInt32 appDomainId, UInt32 notifyPointId);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.PointerProperty : LeafProperty {
    private Symbol _field;
    protected PointerType _type;
    private ScalarData`1<int> _data32;
    private ScalarData`1<long> _data64;
    public bool IsReturnValue { get; }
    public PointerProperty(IFormatter formatter, EngineLock engineLock, Symbol field, bool isOutParam);
    public PointerProperty(IFormatter formatter, EngineLock engineLock, Symbol field, ScalarData`1<int> value, bool isOutParam);
    public PointerProperty(IFormatter formatter, EngineLock engineLock, Symbol field, ScalarData`1<long> value, bool isOutParam);
    public virtual bool get_IsReturnValue();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
}
internal class Microsoft.VisualStudio.TraceDebugger.PrimitiveProperty : LeafProperty {
    protected PrimitiveData _data;
    private string _stringValue;
    protected Symbol _field;
    protected PrimitiveType _type;
    [CompilerGeneratedAttribute]
private bool <IsPartialData>k__BackingField;
    public bool IsReturnValue { get; }
    public bool IsPartialData { get; }
    public PrimitiveProperty(IFormatter formatter, EngineLock engineLock, Symbol field, PrimitiveData value, bool isOutParam);
    public virtual bool get_IsReturnValue();
    [CompilerGeneratedAttribute]
public bool get_IsPartialData();
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 radix);
    public virtual string GetArgTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual object GetDataValue();
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
}
internal class Microsoft.VisualStudio.TraceDebugger.Program : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private TraceEventQuery _cachedTraceEventQuery;
    internal Program(Debuggee debuggee);
    private int _Attach(IDebugEventCallback2 pCallback);
    private int _CanDetach();
    private int _CauseBreak();
    private int _Continue(IDebugThread2 pThread);
    private int _Detach();
    private int _EnumCodeContexts(IDebugDocumentPosition2 pDocPos, IEnumDebugCodeContexts2& ppEnum);
    private int _EnumCodePaths(string pszHint, IDebugCodeContext2 pStart, IDebugStackFrame2 pFrame, int fSource, IEnumCodePaths2& ppEnum, IDebugCodeContext2& ppSafety);
    private int _EnumModules(IEnumDebugModules2& ppEnum);
    private int _EnumThreads(IEnumDebugThreads2& ppEnum);
    private int _Execute();
    private int _ExecuteOnThread(IDebugThread2 pThread);
    private int _GetDebugProperty(IDebugProperty2& ppProperty);
    private int _GetDisassemblyStream(enum_DISASSEMBLY_STREAM_SCOPE dwScope, IDebugCodeContext2 pCodeContext, IDebugDisassemblyStream2& ppDisassemblyStream);
    private int _GetENCUpdate(Object& ppUpdate);
    private int _GetEngineInfo(String& pbstrEngine, Guid& pguidEngine);
    private int _GetMemoryBytes(IDebugMemoryBytes2& ppMemoryBytes);
    private int _GetName(String& pbstrName);
    private int _GetProcess(IDebugProcess2& ppProcess);
    private int _GetProgramId(Guid& pguidProgramId);
    private int _Step(IDebugThread2 pThread, enum_STEPKIND sk, enum_STEPUNIT Step);
    private int _Terminate();
    private int _WriteDump(enum_DUMPTYPE DUMPTYPE, string pszDumpUrl);
    private int _Stop();
    private int _WatchForExpressionEvaluationOnThread(IDebugProgram2 pOriginatingProgram, UInt32 dwTid, UInt32 dwEvalFlags, IDebugEventCallback2 pExprCallback, int fWatch);
    private int _WatchForThreadStep(IDebugProgram2 pOriginatingProgram, UInt32 dwTid, int fWatch, UInt32 dwFrame);
    private int _SetTimeContext(IDebugTimeContext100 pTimeContext);
    private int _GetCurrentTimeContext(IDebugTimeContext100& ppTimeContext);
    private int _GetCallTree(UInt32 tid, IDebugCallTree100& ppCallTree);
    private int _GetHistoricalThreads(UInt32 celt, HistoricalThreadInfo[] rgpNodes, UInt32& pceltFetched);
    private int _GetHistoricalThreadsCount(UInt32& pCount);
    private int _GetSearchQueryTransport(IDebugSearchQueryTransport100& ppSearchQueryTransport);
    private int _GetTraceEventQuery(TRACEEVENTQUERY_CREATION_FLAG flag, UInt32 ctQueryBytes, Byte[] pQuery, IDebugTraceEventQuery100& ppEventQuery);
    private int _GetTraceSettings(IDebugTraceSettings100& ppSettings);
    private int _RecordUIState(UInt32 ctUIStates, UI_FRAME_MONIKER[] frameMoniker, UI_ELEMENT_STATE[] rgElementStates);
    private static _UIContents GetElementStateMessage(UI_FRAME_MONIKER frameMoniker, UI_ELEMENT_STATE uiElementState);
    public sealed virtual int Attach(IDebugEventCallback2 pCallback);
    public sealed virtual int CanDetach();
    public sealed virtual int CauseBreak();
    public sealed virtual int Continue(IDebugThread2 pThread);
    public sealed virtual int Detach();
    public sealed virtual int EnumCodeContexts(IDebugDocumentPosition2 pDocPos, IEnumDebugCodeContexts2& ppEnum);
    public sealed virtual int EnumCodePaths(string pszHint, IDebugCodeContext2 pStart, IDebugStackFrame2 pFrame, int fSource, IEnumCodePaths2& ppEnum, IDebugCodeContext2& ppSafety);
    public sealed virtual int EnumModules(IEnumDebugModules2& ppEnum);
    public sealed virtual int EnumThreads(IEnumDebugThreads2& ppEnum);
    public sealed virtual int Execute();
    public sealed virtual int ExecuteOnThread(IDebugThread2 pThread);
    public sealed virtual int GetDebugProperty(IDebugProperty2& ppProperty);
    public sealed virtual int GetDisassemblyStream(enum_DISASSEMBLY_STREAM_SCOPE dwScope, IDebugCodeContext2 pCodeContext, IDebugDisassemblyStream2& ppDisassemblyStream);
    public sealed virtual int GetENCUpdate(Object& ppUpdate);
    public sealed virtual int GetEngineInfo(String& pbstrEngine, Guid& pguidEngine);
    public sealed virtual int GetMemoryBytes(IDebugMemoryBytes2& ppMemoryBytes);
    public sealed virtual int GetName(String& pbstrName);
    public sealed virtual int GetProcess(IDebugProcess2& ppProcess);
    public sealed virtual int GetProgramId(Guid& pguidProgramId);
    public sealed virtual int Step(IDebugThread2 pThread, enum_STEPKIND sk, enum_STEPUNIT Step);
    public sealed virtual int Terminate();
    public sealed virtual int WriteDump(enum_DUMPTYPE DUMPTYPE, string pszDumpUrl);
    public sealed virtual int Stop();
    public sealed virtual int WatchForExpressionEvaluationOnThread(IDebugProgram2 pOriginatingProgram, UInt32 dwTid, UInt32 dwEvalFlags, IDebugEventCallback2 pExprCallback, int fWatch);
    public sealed virtual int WatchForThreadStep(IDebugProgram2 pOriginatingProgram, UInt32 dwTid, int fWatch, UInt32 dwFrame);
    public sealed virtual int SetTimeContext(IDebugTimeContext100 pTimeContext);
    public sealed virtual int GetCurrentTimeContext(IDebugTimeContext100& ppTimeContext);
    public sealed virtual int GetCallTree(UInt32 tid, IDebugCallTree100& ppCallTree);
    public sealed virtual int GetHistoricalThreads(UInt32 celt, HistoricalThreadInfo[] rgpNodes, UInt32& pceltFetched);
    public sealed virtual int GetHistoricalThreadsCount(UInt32& pCount);
    public sealed virtual int GetSearchQueryTransport(IDebugSearchQueryTransport100& ppSearchQueryTransport);
    public sealed virtual int GetTraceEventQuery(TRACEEVENTQUERY_CREATION_FLAG flag, UInt32 ctQueryBytes, Byte[] pQuery, IDebugTraceEventQuery100& ppEventQuery);
    public sealed virtual int GetTraceSettings(IDebugTraceSettings100& ppSettings);
    public sealed virtual int RecordUIState(UInt32 ctUIStates, UI_FRAME_MONIKER[] frameMoniker, UI_ELEMENT_STATE[] rgElementStates);
    [CompilerGeneratedAttribute]
private int <CanDetach>b__40_0();
    [CompilerGeneratedAttribute]
private int <CauseBreak>b__41_0();
    [CompilerGeneratedAttribute]
private int <Detach>b__43_0();
    [CompilerGeneratedAttribute]
private int <Execute>b__48_0();
    [CompilerGeneratedAttribute]
private int <Terminate>b__59_0();
    [CompilerGeneratedAttribute]
private int <Stop>b__61_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.ProgramCreateEvent : DebugEvent`1<IDebugProgramCreateEvent2> {
    internal ProgramCreateEvent(Engine engine, Program program);
}
internal class Microsoft.VisualStudio.TraceDebugger.ProgramDestroyEvent : DebugEvent`1<IDebugProgramDestroyEvent2> {
    internal ProgramDestroyEvent(Engine engine, Program program);
    public sealed virtual int GetExitCode(UInt32& exitCode);
}
internal class Microsoft.VisualStudio.TraceDebugger.ProgramDestroyNotifyEvent : NotifyEvent {
    internal ProgramDestroyNotifyEvent(long eventCounter, ulong id);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.ProgramNode : ComMarshal {
    private AD_PROCESS_ID _hostPID;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDebugEngineConnectionPoint <DebugEngineConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private INotifyPointService <NotifyService>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<bool> <LoggerAttachTask>k__BackingField;
    [CompilerGeneratedAttribute]
private _CollectionPlan <CollectionPlan>k__BackingField;
    public string LoggerName { get; }
    public IDebugEngineConnectionPoint DebugEngineConnection { get; }
    public INotifyPointService NotifyService { get; }
    public Task`1<bool> LoggerAttachTask { get; }
    public _CollectionPlan CollectionPlan { get; }
    public ProgramNode(AD_PROCESS_ID hostPID, string loggerName, IDebugEngineConnectionPoint debugEngineConnection, INotifyPointService npService, Task`1<bool> attachTask, _CollectionPlan collectionPlan);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public IDebugEngineConnectionPoint get_DebugEngineConnection();
    [CompilerGeneratedAttribute]
public INotifyPointService get_NotifyService();
    [CompilerGeneratedAttribute]
public Task`1<bool> get_LoggerAttachTask();
    [CompilerGeneratedAttribute]
public _CollectionPlan get_CollectionPlan();
    private int _GetEngineInfo(String& engineName, Guid& engineId);
    private int _GetHostName(enum_GETHOSTNAME_TYPE dwHostNameType, String& pbstrHostName);
    private int _GetHostPid(AD_PROCESS_ID[] hostProcessId);
    private int _GetProgramName(String& pbstrProgramName);
    private int _Attach_V7(IDebugProgram2 pMDMProgram, IDebugEventCallback2 pCallback, UInt32 dwReason);
    private int _DetachDebugger_V7();
    private int _GetHostMachineName_V7(String& pbstrHostMachineName);
    public sealed virtual int GetEngineInfo(String& engineName, Guid& engineId);
    public sealed virtual int GetHostName(enum_GETHOSTNAME_TYPE dwHostNameType, String& pbstrHostName);
    public sealed virtual int GetHostPid(AD_PROCESS_ID[] hostProcessId);
    public sealed virtual int GetProgramName(String& pbstrProgramName);
    public sealed virtual int Attach_V7(IDebugProgram2 pMDMProgram, IDebugEventCallback2 pCallback, UInt32 dwReason);
    public sealed virtual int DetachDebugger_V7();
    public sealed virtual int GetHostMachineName_V7(String& pbstrHostMachineName);
    [CompilerGeneratedAttribute]
private int <DetachDebugger_V7>b__29_0();
}
[ComVisibleAttribute("True")]
[GuidAttribute("5b85b6a6-cbff-4f31-be1d-6fe7f849e7d9")]
internal class Microsoft.VisualStudio.TraceDebugger.ProgramProvider : ComMarshal {
    [CompilerGeneratedAttribute]
private IDebugProgramProvider2 <ProgramProviderInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgramProviderType <ProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LanguageId>k__BackingField;
    private IDebugProgramProvider2 ProgramProviderInstance { get; private set; }
    private ProgramProviderType ProviderType { get; private set; }
    private ushort LanguageId { get; private set; }
    [CompilerGeneratedAttribute]
private IDebugProgramProvider2 get_ProgramProviderInstance();
    [CompilerGeneratedAttribute]
private void set_ProgramProviderInstance(IDebugProgramProvider2 value);
    [CompilerGeneratedAttribute]
private ProgramProviderType get_ProviderType();
    [CompilerGeneratedAttribute]
private void set_ProviderType(ProgramProviderType value);
    [CompilerGeneratedAttribute]
private ushort get_LanguageId();
    [CompilerGeneratedAttribute]
private void set_LanguageId(ushort value);
    private void ResolveInstance(IDebugDefaultPort2 port);
    public sealed virtual int GetProviderProcessData(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, PROVIDER_PROCESS_DATA[] pProcess);
    public sealed virtual int GetProviderProgramNode(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, Guid& guidEngine, ulong programId, IDebugProgramNode2& ppProgramNode);
    public sealed virtual int SetLocale(ushort wLangID);
    public sealed virtual int WatchForProviderEvents(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, Guid& guidLaunchingEngine, IDebugPortNotify2 pEventCallback);
}
public class Microsoft.VisualStudio.TraceDebugger.ProgramProviderImpl : ComMarshal {
    private static int LoggerStartTimeout;
    private static int LoggerAttachTimeout;
    private Process _debuggeeProc;
    private IDebugPortNotify2 _portNotify;
    private TraceLogger _logger;
    private string _loggerName;
    private bool _doLoggerStop;
    private IDebugEngineConnectionPoint _debugEngineConnection;
    private INotifyPointService _npService;
    private EventWaitHandle _attachReadyEvent;
    private EventWaitHandle _attachCompleteEvent;
    private CancellationTokenSource _cancellationTokenSource;
    private NamedCounter _namedCounter;
    private _CollectionPlan _collectionPlan;
    private static ProgramProviderImpl();
    private int _GetProviderProcessData(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, PROVIDER_PROCESS_DATA[] pProcess);
    private int _GetProviderProgramNode(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, Guid& guidEngine, ulong programId, IDebugProgramNode2& ppProgramNode);
    private int _SetLocale(ushort wLangID);
    private int _WatchForProviderEvents(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, Guid& guidLaunchingEngine, IDebugPortNotify2 pEventCallback);
    private void FetchSiblingEngineInterfaces(IDebugProcess2 process, IDebugEngineConnectionPoint& debugEngineConnection, INotifyPointService& npService);
    private void InitAttachReadyCompleteEvents(TraceLogger logger);
    private bool LoadCallbackOptions(IDebugPortNotify2 pEventCallback, SettingsCallbackOptions& callbackOptions);
    private bool IsVSHostAttach(IDebugPortNotify2 pEventCallback);
    private bool LoadCallbackOptionsForAttach(Guid guidLaunchingEngine, IDebugProcess2 process, IDebugPortNotify2 pEventCallback, SettingsCallbackOptions& callbackOptions);
    private LoggingConfig CreateLoggingConfig();
    private bool LaunchLogger(TraceLogger logger, SettingsCallbackOptions callbackOptions);
    private bool TryAttach(int timeout, CancellationToken token);
    private void AddProgramNode(Task`1<bool> attachTask);
    private string PrepareLoggerName(TraceLogger logger, SettingsCallbackOptions callbackOptions, _CollectionPlan collectionPlan);
    public sealed virtual int GetProviderProcessData(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, PROVIDER_PROCESS_DATA[] pProcess);
    public sealed virtual int GetProviderProgramNode(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, Guid& guidEngine, ulong programId, IDebugProgramNode2& ppProgramNode);
    public sealed virtual int SetLocale(ushort wLangID);
    public sealed virtual int WatchForProviderEvents(enum_PROVIDER_FLAGS Flags, IDebugDefaultPort2 pPort, AD_PROCESS_ID ProcessId, CONST_GUID_ARRAY EngineFilter, Guid& guidLaunchingEngine, IDebugPortNotify2 pEventCallback);
    [CompilerGeneratedAttribute]
private void <_WatchForProviderEvents>b__18_1();
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.Property : object {
    protected DebugProperty _debugProp;
    protected bool _isOutParam;
    protected IFormatter _formatter;
    protected EngineLock _engineLock;
    public DebugLanguage DebugLanguage { get; }
    internal bool IsDataCollected { get; }
    public bool IsReturnValue { get; }
    protected Property(IFormatter formatter, EngineLock engineLock, bool isOutParam);
    public DebugProperty GetDebugProperty();
    public abstract virtual string GetFullName(UInt32 radix);
    public abstract virtual string GetName(UInt32 radix);
    public abstract virtual string GetTypeName(UInt32 dwRadix);
    public abstract virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public abstract virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual string GetArgTypeName(UInt32 dwRadix);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual List`1<Property> GetChildren(Guid& filter);
    public virtual object GetDataValue();
    public DebugLanguage get_DebugLanguage();
    internal virtual bool get_IsDataCollected();
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
    protected virtual Property ExpressionEvaluateHelper(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
    protected Property GetPropertyForExpression(string expression, string name);
    protected void GetAttribsHelper(FieldFlags fieldFlags, enum_DBG_ATTRIB_FLAGS& flag);
    protected object GetPrimitiveValue(PrimitiveType type, PrimitiveData data);
    [ConditionalAttribute("DEBUG")]
internal void Dump();
    [ConditionalAttribute("DEBUG")]
private void Dump(int depth);
    public virtual bool get_IsReturnValue();
    protected static bool IsSymbolReturnValue(Symbol symbol);
}
internal static class Microsoft.VisualStudio.TraceDebugger.PropertyFactory : object {
    internal static IndependentProperty CreatePropertyForNotify(NPEventData npEventData, Debuggee debuggee);
    internal static Property CreatePropertyForNode(EventHandle leafEvt, Debuggee debuggee, bool fParentLanguage);
    internal static Property CreatePropertyForStatement(EventHandle leafEvt, Debuggee debuggee, Thread thread, int frameIndex, int dataRecordedThread);
    private static bool IsBreakEventProperty(Property property);
    private static bool HasCallStackInfoFramesToAdd(Property property);
    private static IndependentProperty CreatePropertyForNotifyHelper(IFormatter formatter, EventHandle evtHandle, Debuggee debuggee, int notifyId, int threadId, Nullable`1<CodeContext> location, long eventTime, Nullable`1<Guid> activityId);
    private static Property CreatePropertyForNodeHelper(IFormatter formatter, EventHandle leafEvt, Debuggee debuggee, bool fParentLanguage, bool fIncludeCallsToUninstrumented);
    internal static Property CreatePropertyForValue(IFormatter formatter, EngineLock engineLock, Symbol field, LogData value);
    internal static Property CreatePropertyForValue(IFormatter formatter, EngineLock engineLock, Symbol field, LogData value, bool outParam);
    internal static Property CreatePropertyForValue(IFormatter formatter, EngineLock engineLock, Symbol field, LogData value, bool outParam, bool topLevel);
}
internal class Microsoft.VisualStudio.TraceDebugger.PropertyInfoEnumerator : DebugEnumerator`1<DEBUG_PROPERTY_INFO> {
    internal PropertyInfoEnumerator(DEBUG_PROPERTY_INFO[] propertyInfos);
    private int _Next(UInt32 count, DEBUG_PROPERTY_INFO[] items, UInt32& countFetched);
    public sealed virtual int Next(UInt32 count, DEBUG_PROPERTY_INFO[] items, UInt32& countFetched);
    private int _Clone(IEnumDebugPropertyInfo2& clone);
    public sealed virtual int Clone(IEnumDebugPropertyInfo2& clone);
}
internal class Microsoft.VisualStudio.TraceDebugger.RecordedProperty : RootProperty {
    private IDataElement _dataElement;
    private List`1<Property> _children;
    private string _parentName;
    private List`1<RecordedProperty> _alternates;
    internal RecordedProperty(IFormatter formatter, EngineLock engineLock, IDataElement dataElement, string parentName);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual List`1<Property> GetChildren(Guid& guidFilter);
    private void EnsureChildren();
    private void GetMergedChildren(Dictionary`2<string, RecordedProperty> properties);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    internal void Merge(RecordedProperty alternate);
}
internal class Microsoft.VisualStudio.TraceDebugger.RemoteProperty : ClassProperty {
    public RemoteProperty(IFormatter formatter, EngineLock engineLock, Symbol field, RemoteData value, bool isOutParam);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
}
internal class Microsoft.VisualStudio.TraceDebugger.ResolvedTimeContext : ComMarshal {
    private TimeContext _timeContext;
    private Thread _thread;
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    internal ResolvedTimeContext(TimeContext timeContext, Thread thread, Debuggee debuggee);
    private int _GetCanonicalValue(UInt64& pullCanonical);
    private int _GetFriendlyValue(DateTime[] pdFriendly);
    private int _Resolve(IDebugResolvedTimeContext100& ppResolvedTimeContext);
    private int _GetThread(IDebugThread2& ppThread);
    internal EventHandle GetClosestEvent();
    public sealed virtual int GetCanonicalValue(UInt64& pullCanonical);
    public sealed virtual int GetFriendlyValue(DateTime[] pdFriendly);
    public sealed virtual int Resolve(IDebugResolvedTimeContext100& ppResolvedTimeContext);
    public sealed virtual int GetThread(IDebugThread2& ppThread);
}
internal class Microsoft.VisualStudio.TraceDebugger.RootNode : TransitionCallsiteNode {
    internal RootNode(EventHandle root, CallTree callTree);
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.RootProperty : Property {
    protected RootProperty(IFormatter formatter, EngineLock engineLock);
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
}
public class Microsoft.VisualStudio.TraceDebugger.SearchHistoricalExecution : ComMarshal {
    private Debuggee _debuggee;
    private SearchTracker _tracker;
    private List`1<SearchResult> _results;
    private UInt32 _searchId;
    internal SearchHistoricalExecution(Debuggee debuggee);
    private int _SearchHistoricalLog(UInt32 ctQueryBytes, Byte[] pQuery, ISearchHistoricalExecutionCallback100 pCallback);
    private SearchTracker UpdateTracker(SearchCommand sc);
    private Predicate`1<SearchResults> GetContinuePredicate(SearchCommand sc);
    private SearchQueryImpl GetQueryImpl(SearchCommand sc);
    internal int GetSearchResultId(SearchResult sr);
    internal bool TryGetSearchResultId(UInt32 resultId, SearchResult& searchResult);
    public sealed virtual int SearchHistoricalLog(UInt32 ctQueryBytes, Byte[] pQuery, ISearchHistoricalExecutionCallback100 pCallback);
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.SearchQueryImpl : object {
    internal abstract virtual void QueryImpl(IntelliTraceEvent evt, SearchResults results, SearchTracker tracker);
}
internal class Microsoft.VisualStudio.TraceDebugger.SearchResult : object {
    private EventHandle _eventHandle;
    internal EventHandle EventHandle { get; }
    internal SearchResult(EventHandle eventHandle);
    internal EventHandle get_EventHandle();
}
internal class Microsoft.VisualStudio.TraceDebugger.SettingsCallbackOptions : ValueType {
    [CompilerGeneratedAttribute]
private string <CollectionPlanPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoggerName>k__BackingField;
    [CompilerGeneratedAttribute]
private CLR_VERSION <ClrVersion>k__BackingField;
    public string CollectionPlanPath { get; public set; }
    public string LoggerName { get; public set; }
    public CLR_VERSION ClrVersion { get; public set; }
    public bool LoggerRequired { get; }
    [CompilerGeneratedAttribute]
public string get_CollectionPlanPath();
    [CompilerGeneratedAttribute]
public void set_CollectionPlanPath(string value);
    [CompilerGeneratedAttribute]
public string get_LoggerName();
    [CompilerGeneratedAttribute]
public void set_LoggerName(string value);
    [CompilerGeneratedAttribute]
public CLR_VERSION get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(CLR_VERSION value);
    public bool get_LoggerRequired();
}
internal class Microsoft.VisualStudio.TraceDebugger.SourceLocationQueryImpl : SearchQueryImpl {
    private List`1<TargetMethod> _targetMethods;
    public SourceLocationQueryImpl(LocationQuery query, SearchContext context, Debuggee debuggee, SearchHistoricalExecution searchInstance);
    internal virtual void QueryImpl(IntelliTraceEvent evt, SearchResults results, SearchTracker tracker);
}
internal class Microsoft.VisualStudio.TraceDebugger.StackFrame : ComMarshal {
    private EventHandle _callEvent;
    private CodeContext _location;
    private Debuggee _debuggee;
    private Thread _thread;
    private EngineLock _engineLock;
    private UInt32 _syncCount;
    private Property _methodProperty;
    private CodeContext _codeContext;
    private int _dataRecordedThread;
    private int _frameIndex;
    private bool _fakeUserCode;
    private bool _overrideNodeInfo;
    private SourceSearchPolicy _searchPolicy;
    internal StackFrame(Debuggee d, Thread t, EventHandle callEvent);
    internal StackFrame(Debuggee d, Thread t, EventHandle callEvent, int frameIndex);
    private StackFrame(Debuggee d, Thread t, EventHandle callEvent, int frameIndex, Nullable`1<CodeContext> location, bool overrideNodeInfo);
    internal static StackFrame CreateAlternateStackFrame(Debuggee d, Thread t, EventHandle callEvent, int frameIndex, CodeContext location, bool overrideNodeInfo);
    internal CodeContext GetCodeContext();
    internal Property GetProperty();
    internal virtual FRAMEINFO GetInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix);
    protected void AssignFrameField(enum_FRAMEINFO_FLAGS dwFieldSpec, enum_FRAMEINFO_FLAGS flagToTest, FRAMEINFO& info, Action setField);
    private string GetFunctionNameFromLocation(NODEINFO_FLAGS flags);
    private NODEINFO_FLAGS ConvertFrameInfoFlags(enum_FRAMEINFO_FLAGS inFlags);
    protected virtual int _GetThread(IDebugThread2& ppThread);
    protected virtual int _GetInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix, FRAMEINFO[] pFrameInfo);
    protected virtual int _GetDebugProperty(IDebugProperty2& ppProperty);
    protected virtual int _GetCodeContext(IDebugCodeContext2& ppCodeCxt);
    protected virtual int _GetDocumentContext(IDebugDocumentContext2& ppCxt);
    protected virtual int _GetName(String& pbstrName);
    protected virtual int _GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    protected virtual int _GetExpressionContext(IDebugExpressionContext2& ppExprCxt);
    protected virtual int _GetPhysicalStackRange(UInt64& paddrMin, UInt64& paddrMax);
    protected virtual int _GetUnwindCodeContext(IDebugCodeContext2& ppCodeContext);
    protected virtual int _InterceptCurrentException(enum_INTERCEPT_EXCEPTION_ACTION dwFlags, UInt64& pqwCookie);
    protected virtual int _EnumProperties(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 nRadix, Guid& guidFilter, UInt32 dwTimeout, UInt32& pcelt, IEnumDebugPropertyInfo2& ppEnum);
    public sealed virtual int GetThread(IDebugThread2& ppThread);
    public sealed virtual int GetInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix, FRAMEINFO[] pFrameInfo);
    public sealed virtual int GetDebugProperty(IDebugProperty2& ppProperty);
    public sealed virtual int GetCodeContext(IDebugCodeContext2& ppCodeCxt);
    public sealed virtual int GetDocumentContext(IDebugDocumentContext2& ppCxt);
    public sealed virtual int GetName(String& pbstrName);
    public sealed virtual int GetLanguageInfo(String& pbstrLanguage, Guid& pguidLanguage);
    public sealed virtual int GetExpressionContext(IDebugExpressionContext2& ppExprCxt);
    public sealed virtual int GetPhysicalStackRange(UInt64& paddrMin, UInt64& paddrMax);
    public sealed virtual int GetUnwindCodeContext(IDebugCodeContext2& ppCodeContext);
    public sealed virtual int InterceptCurrentException(enum_INTERCEPT_EXCEPTION_ACTION dwFlags, UInt64& pqwCookie);
    public sealed virtual int EnumProperties(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 nRadix, Guid& guidFilter, UInt32 dwTimeout, UInt32& pcelt, IEnumDebugPropertyInfo2& ppEnum);
}
internal class Microsoft.VisualStudio.TraceDebugger.StaleProperty : Property {
    private Property _innerProperty;
    internal bool IsDataCollected { get; }
    public StaleProperty(Property innerProperty);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual string GetArgTypeName(UInt32 dwRadix);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual List`1<Property> GetChildren(Guid& filter);
    public virtual object GetDataValue();
    internal virtual bool get_IsDataCollected();
    public virtual Property ExpressionEvaluate(int depth, string expression, String[] names, UInt32 dwTimeout, UInt32 radix);
}
[GeneratedCodeAttribute("Microsoft.Build.Tasks.StronglyTypedResourceBuilder", "15.1.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.TraceDebugger.StringTable : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AD7ProgramName { get; }
    internal static string ArgumentsStringTruncated { get; }
    internal static string CycleWarning { get; }
    internal static string DataRemoted { get; }
    internal static string DataUncollected { get; }
    internal static string DeadThread { get; }
    internal static string DebuggerHiddenEntryEventMessage { get; }
    internal static string DebugOutputMessage { get; }
    internal static string DiagnosticEventNameWithMethod { get; }
    internal static string DiagnosticEventNameWithSettingsName { get; }
    internal static string DynamicModule { get; }
    internal static string EngineName { get; }
    internal static string Error { get; }
    internal static string ExternalCodeNodeName { get; }
    internal static string FailedToCollectArgumentValueMessage { get; }
    internal static string FrameFormattingError { get; }
    internal static string FutureThread { get; }
    internal static string InternalErrorString { get; }
    internal static string LiveThread { get; }
    internal static string MethodEnterPrefixName { get; }
    internal static string MethodExitPrefixName { get; }
    internal static string ModLoadFormatString { get; }
    internal static string ModLoadVerb { get; }
    internal static string ModUnloadVerb { get; }
    internal static string NotCollectedMsg { get; }
    internal static string NotCollectedName { get; }
    internal static string NotCollectedValue { get; }
    internal static string NotSupportedMsg { get; }
    internal static string StalePropertyValue { get; }
    internal static string TerminatingHistoricalDebugging { get; }
    internal static string ThreadSwitchNodeName { get; }
    internal static string TransitionNodeName { get; }
    internal static string TreeRootFormattedNodeName { get; }
    internal static string TreeRootNodeName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AD7ProgramName();
    internal static string get_ArgumentsStringTruncated();
    internal static string get_CycleWarning();
    internal static string get_DataRemoted();
    internal static string get_DataUncollected();
    internal static string get_DeadThread();
    internal static string get_DebuggerHiddenEntryEventMessage();
    internal static string get_DebugOutputMessage();
    internal static string get_DiagnosticEventNameWithMethod();
    internal static string get_DiagnosticEventNameWithSettingsName();
    internal static string get_DynamicModule();
    internal static string get_EngineName();
    internal static string get_Error();
    internal static string get_ExternalCodeNodeName();
    internal static string get_FailedToCollectArgumentValueMessage();
    internal static string get_FrameFormattingError();
    internal static string get_FutureThread();
    internal static string get_InternalErrorString();
    internal static string get_LiveThread();
    internal static string get_MethodEnterPrefixName();
    internal static string get_MethodExitPrefixName();
    internal static string get_ModLoadFormatString();
    internal static string get_ModLoadVerb();
    internal static string get_ModUnloadVerb();
    internal static string get_NotCollectedMsg();
    internal static string get_NotCollectedName();
    internal static string get_NotCollectedValue();
    internal static string get_NotSupportedMsg();
    internal static string get_StalePropertyValue();
    internal static string get_TerminatingHistoricalDebugging();
    internal static string get_ThreadSwitchNodeName();
    internal static string get_TransitionNodeName();
    internal static string get_TreeRootFormattedNodeName();
    internal static string get_TreeRootNodeName();
}
internal class Microsoft.VisualStudio.TraceDebugger.SymbolDispenser : object {
    private SymbolProviderDirect _symDirect;
    private ProgramSymbols _symbols;
    private object _symlock;
    private Debuggee _debuggee;
    public ProgramSymbols Symbols { get; }
    public TraceLog Log { get; }
    internal SymbolDispenser(SymbolProviderDirect symDirect, Debuggee debuggee);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual ProgramSymbols get_Symbols();
    public sealed virtual TraceLog get_Log();
    internal void ResetSymbols();
}
internal class Microsoft.VisualStudio.TraceDebugger.SymbolLoadNotifyEvent : NotifyEvent {
    internal Guid _moduleId;
    internal UInt32 _appDomainId;
    internal string _modulePath;
    internal ulong _baseAddress;
    internal SymbolLoadNotifyEvent(long eventCounter, ulong id, Guid moduleId, UInt32 appDomainId, string modulePath, ulong baseAddress);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.SymbolProviderDirect : object {
    private IDebugSymbolProviderDirect _symDirect;
    public bool SymbolsAreConst { get; }
    public SymbolProviderDirect(object symDirect);
    public bool get_SymbolsAreConst();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool TryGetModuleSymbols(Guid moduleId, UInt32 appDomainId, TraceLog log, ModuleSymbols& moduleSymbols);
    internal void LoadSymbols(ProgramSymbols programSymbols, ISymbolContextProvider symbolContextProvider, Debuggee debuggee);
    private void LoadLogSymbols(ProgramSymbols programSymbols, ISymbolContextProvider symbolContextProvider, List`1<Module> modules);
    private void LoadLiveSymbols(ProgramSymbols programSymbols, ISymbolContextProvider symbolContextProvider, Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.Thread : ComMarshal {
    private int _loggerTid;
    private int _osTid;
    private long _startOrdinal;
    private long _endOrdinal;
    private Debuggee _debuggee;
    private string _priorityName;
    private string _name;
    private int _category;
    private IList`1<StackFrame> _frames;
    private EngineLock _engineLock;
    private UInt32 _syncCount;
    private TimeContext _timeContext;
    private EventHandle _event;
    public int LoggerThreadId { get; }
    public int OsThreadId { get; }
    public long StartOrdinal { get; }
    public long EndOrdinal { get; }
    public string PriorityName { get; }
    public string Name { get; }
    public int Category { get; }
    internal Thread(Debuggee debuggee, TimeContext timeContext, ThreadData data);
    private void EnsureStackFrames();
    private string GetThreadStatus();
    internal StackFrame GetLeafFrameOfThread();
    public int get_LoggerThreadId();
    public int get_OsThreadId();
    public long get_StartOrdinal();
    public long get_EndOrdinal();
    public string get_PriorityName();
    public string get_Name();
    public int get_Category();
    private int _CanRemapLeafFrame();
    private int _CanSetNextStatement(IDebugStackFrame2 pStackFrame, IDebugCodeContext2 pCodeContext);
    private int _EnumFrameInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix, IEnumDebugFrameInfo2& ppEnum);
    private int _GetLogicalThread(IDebugStackFrame2 pStackFrame, IDebugLogicalThread2& ppLogicalThread);
    private int _GetName(String& pbstrName);
    private int _GetProgram(IDebugProgram2& ppProgram);
    private int _GetThreadId(UInt32& pdwThreadId);
    private int _GetThreadProperties(enum_THREADPROPERTY_FIELDS dwFields, THREADPROPERTIES[] ptp);
    private int _IsCurrentException();
    private int _RemapLeafFrame();
    private int _Resume(UInt32& pdwSuspendCount);
    private int _SetNextStatement(IDebugStackFrame2 pStackFrame, IDebugCodeContext2 pCodeContext);
    private int _SetThreadName(string pszName);
    private int _Suspend(UInt32& pdwSuspendCount);
    public int _CanDoFuncEval();
    public int _GetFlags(UInt32& pFlags);
    public int _GetThreadDisplayName(String& bstrDisplayName);
    public int _GetThreadProperties100(UInt32 dwFields, THREADPROPERTIES100[] ptp);
    public int _SetFlags(UInt32 flags);
    public int _SetThreadDisplayName(string bstrDisplayName);
    public sealed virtual int CanRemapLeafFrame();
    public sealed virtual int CanSetNextStatement(IDebugStackFrame2 pStackFrame, IDebugCodeContext2 pCodeContext);
    public sealed virtual int EnumFrameInfo(enum_FRAMEINFO_FLAGS dwFieldSpec, UInt32 nRadix, IEnumDebugFrameInfo2& ppEnum);
    public sealed virtual int GetLogicalThread(IDebugStackFrame2 pStackFrame, IDebugLogicalThread2& ppLogicalThread);
    public sealed virtual int GetName(String& pbstrName);
    public sealed virtual int GetProgram(IDebugProgram2& ppProgram);
    public sealed virtual int GetThreadId(UInt32& pdwThreadId);
    public sealed virtual int GetThreadProperties(enum_THREADPROPERTY_FIELDS dwFields, THREADPROPERTIES[] ptp);
    public sealed virtual int IsCurrentException();
    public sealed virtual int RemapLeafFrame();
    public sealed virtual int Resume(UInt32& pdwSuspendCount);
    public sealed virtual int SetNextStatement(IDebugStackFrame2 pStackFrame, IDebugCodeContext2 pCodeContext);
    public sealed virtual int SetThreadName(string pszName);
    public sealed virtual int Suspend(UInt32& pdwSuspendCount);
    public sealed virtual int CanDoFuncEval();
    public sealed virtual int GetFlags(UInt32& pFlags);
    public sealed virtual int GetThreadDisplayName(String& bstrDisplayName);
    public sealed virtual int GetThreadProperties100(UInt32 dwFields, THREADPROPERTIES100[] ptp);
    public sealed virtual int SetFlags(UInt32 flags);
    public sealed virtual int SetThreadDisplayName(string bstrDisplayName);
    [CompilerGeneratedAttribute]
private int <CanRemapLeafFrame>b__51_0();
    [CompilerGeneratedAttribute]
private int <IsCurrentException>b__59_0();
    [CompilerGeneratedAttribute]
private int <RemapLeafFrame>b__60_0();
    [CompilerGeneratedAttribute]
private int <CanDoFuncEval>b__65_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadCreateEvent : DebugEvent`1<IDebugThreadCreateEvent2> {
    public ThreadCreateEvent(Engine engine, Program program, Thread thread);
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadCreateNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal string _priorityName;
    internal string _name;
    internal UInt32 _category;
    internal ThreadCreateNotifyEvent(long eventCounter, ulong id, UInt32 tid, string priorityName, string name, UInt32 category);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadDestroyEvent : DebugEvent`1<IDebugThreadDestroyEvent2> {
    public ThreadDestroyEvent(Engine engine, Program program, Thread thread);
    public sealed virtual int GetExitCode(UInt32& exitCode);
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadDestroyNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal ThreadDestroyNotifyEvent(long eventCounter, ulong id, UInt32 tid);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadEnumerator : DebugInterfaceEnumerator`2<Thread, IDebugThread2> {
    internal ThreadEnumerator(Thread[] threads);
    private int _Clone(IEnumDebugThreads2& clone);
    public sealed virtual int Clone(IEnumDebugThreads2& clone);
}
internal class Microsoft.VisualStudio.TraceDebugger.ThreadNameChangeNotifyEvent : NotifyEvent {
    internal UInt32 _tid;
    internal string _name;
    internal UInt32 _category;
    internal ThreadNameChangeNotifyEvent(long eventCounter, ulong id, UInt32 tid, string name, UInt32 category);
    internal virtual void HandleNotifyEvent(Debuggee debuggee);
}
internal class Microsoft.VisualStudio.TraceDebugger.TimeContext : ComMarshal {
    private EventHandle _event;
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    public EventHandle Event { get; }
    internal Debuggee Debuggee { get; }
    internal TimeContext(EventHandle ev, Debuggee debuggee);
    public EventHandle get_Event();
    internal Debuggee get_Debuggee();
    private int _GetCanonicalValue(UInt64& pullCanonical);
    private int _GetFriendlyValue(DateTime[] pdFriendly);
    private int _Resolve(IDebugResolvedTimeContext100& ppResolved);
    private int _GetTimeStamp(UInt64& timeStamp);
    private int _GetDebugTimeContextType(DEBUG_TIME_CONTEXT_TYPE[] type);
    private int _GetProgram(IDebugProgram2& ppProgram);
    internal ResolvedTimeContext Resolve(int loggerThreadId);
    public sealed virtual int GetCanonicalValue(UInt64& pullCanonical);
    public sealed virtual int GetFriendlyValue(DateTime[] pdFriendly);
    public sealed virtual int Resolve(IDebugResolvedTimeContext100& ppResolved);
    public sealed virtual int GetTimeStamp(UInt64& timeStamp);
    public sealed virtual int GetDebugTimeContextType(DEBUG_TIME_CONTEXT_TYPE[] type);
    public sealed virtual int GetProgram(IDebugProgram2& ppProgram);
}
internal class Microsoft.VisualStudio.TraceDebugger.TimeContextActivatedEvent : DebugEvent`1<IDebugTimeContextActivatedEvent156> {
    private IDebugTimeContext100 _pTimeContext;
    public TimeContextActivatedEvent(Engine engine, Program program, Thread thread, IDebugTimeContext100 pTimeContext);
    public sealed virtual int GetTimeContext(IDebugTimeContext100& pTimeContext);
}
internal class Microsoft.VisualStudio.TraceDebugger.TimeContextChangeEvent : DebugEvent`1<IDebugTimeContextChangeEvent100> {
    private IDebugTimeContext100 _pOldTimeContext;
    private IDebugTimeContext100 _pNewTimeContext;
    internal TimeContextChangeEvent(Engine engine, Program program, Thread thread, IDebugTimeContext100 pOldTimeContext, IDebugTimeContext100 pNewTimeContext);
    public sealed virtual int GetOldTimeContext(IDebugTimeContext100& ppOldTimeContext);
    public sealed virtual int GetNewTimeContext(IDebugTimeContext100& ppNewTimeContext);
}
internal class Microsoft.VisualStudio.TraceDebugger.TraceAttachSettingsCallback : object {
    private TRACE_ATTACH_SETTINGS _traceAttachSettings;
    private bool _disposed;
    public TRACE_ATTACH_SETTINGS TraceAttachSettings { get; }
    public TraceAttachSettingsCallback(Guid engineGuid, UInt32 dwProcessId);
    public TRACE_ATTACH_SETTINGS get_TraceAttachSettings();
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    public sealed virtual int GetTraceAttachSettings(TRACE_ATTACH_SETTINGS[] pTraceAttachSettings);
    public sealed virtual int SetTraceAttachSettings(TRACE_ATTACH_SETTINGS[] pTraceAttachSettings);
    public sealed virtual int GetAttributes(UInt32& pdwAttrib);
    public sealed virtual int GetCustomEventInfo(Guid& guidVSService, VsComponentMessage[] message);
}
internal class Microsoft.VisualStudio.TraceDebugger.TraceEventQuery : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    private IBidiEnum`1<NPEventData> _events;
    private Predicate`1<NPEventData> _predicate;
    private Dictionary`2<long, NPEventData> _knownEvents;
    private Nullable`1<UInt32> _count;
    private EventToken _cachedFirstValidToken;
    private EventToken _cachedAfterLastToken;
    private bool _needToAdjustCount;
    private bool _needToClearKnownEvents;
    private Byte[] _pCachedQuery;
    private static int MAX_KNOWN_EVENTS;
    internal TraceEventQuery(UInt32 ctQueryBytes, Byte[] pQuery, Debuggee debuggee);
    internal bool CompareFilter(Byte[] pQuery);
    internal bool HasBeenTruncated(IChainTokenOwner newChain);
    internal void SetCountRequiresAdjustment();
    private void UpdateActiveTokens();
    private void MoveToFirstValidToken();
    private bool HasUnderlyingChainBeenUpdated();
    private void FailIfCountRequiresAdjustment();
    private UInt32 CountMatchingElementsTillEnd();
    private void RegisterEvent(NPEventData npEvtData);
    private TRACE_EVENT_INFO GetFormattedData(NPEventData npEvtData);
    private string GetFormattedPropertyValue(TRACE_EVENT_INFO formattedValue, string propertyName);
    private int ConvertNPEventDataToTraceEventInfo(NPEventData[] npData, UInt32 npDataCount, TRACE_EVENT_INFO[] regelt, UInt32& pceltFetched);
    public int _ResetToBeginning();
    public int _ResetToEnd();
    public int _GetRefreshRequired(Int32& fRefreshRequired);
    public int _SkipForward(UInt32 celt, int fUseFilter, UInt32& pceltSkipped);
    public int _SkipBackward(UInt32 celt, int fUseFilter, UInt32& pceltSkipped);
    public int _Next(UInt32 celt, int fUseFilter, TRACE_EVENT_INFO[] regelt, UInt32& pceltFetched);
    internal int Next(UInt32 celt, int fUseFilter, NPEventData[] npData, UInt32& pceltFetched);
    public int _Previous(UInt32 celt, int fUseFilter, TRACE_EVENT_INFO[] regelt, UInt32& pceltFetched);
    internal int Previous(UInt32 celt, int fUseFilter, NPEventData[] npData, UInt32& pceltFetched);
    private int _GetTimeContextOfEvent(ulong eventId, IDebugTimeContext100& pTimeContext);
    private int _GetDebugProperty(ulong eventId, IDebugProperty3& pProperty);
    private int _UpdateCountAndCache();
    private int _GetCount(UInt32& pCount);
    private int _Seek(ulong eventId, Int32& pItemIndex);
    private int _GetEvent(ulong eventId, TRACE_EVENT_INFO[] pTraceEvent);
    public sealed virtual int Next(UInt32 celt, int fUseFilter, TRACE_EVENT_INFO[] regelt, UInt32& pceltFetched);
    public sealed virtual int Previous(UInt32 celt, int fUseFilter, TRACE_EVENT_INFO[] regelt, UInt32& pceltFetched);
    public sealed virtual int ResetToBeginning();
    public sealed virtual int ResetToEnd();
    public sealed virtual int SkipForward(UInt32 celt, int fUseFilter, UInt32& pceltSkipped);
    public sealed virtual int SkipBackward(UInt32 celt, int fUseFilter, UInt32& pceltSkipped);
    public sealed virtual int GetTimeContextOfEvent(ulong eventId, IDebugTimeContext100& ppTimeContext);
    public sealed virtual int GetDebugProperty(ulong eventId, IDebugProperty3& ppProperty);
    public sealed virtual int GetCount(UInt32& pCount);
    public sealed virtual int Seek(ulong eventId, Int32& pItemIndex);
    public sealed virtual int GetRefreshRequired(Int32& fRefreshRequired);
    public sealed virtual int UpdateCountAndCache();
    public sealed virtual int GetEvent(ulong eventId, TRACE_EVENT_INFO[] pTraceEvent);
    [CompilerGeneratedAttribute]
private int <ResetToBeginning>b__42_0();
    [CompilerGeneratedAttribute]
private int <ResetToEnd>b__43_0();
    [CompilerGeneratedAttribute]
private int <UpdateCountAndCache>b__51_0();
}
internal class Microsoft.VisualStudio.TraceDebugger.TraceSettings : ComMarshal {
    private Debuggee _debuggee;
    private EngineLock _engineLock;
    internal TraceSettings(Debuggee debuggee);
    public int _GetIsInErrorState(Int32& isInErrorState);
    public int _GetSettings(TRACE_SETTINGS[] pSettings);
    public int _GetTraceEventCategoriesCount(UInt32& pCount);
    public int _GetTraceEventCategories(UInt32 celt, EventCategoryInfo[] rgelt, UInt32& pceltFetched);
    private int _GetLoggerProcessInfo(String& logFilePath, UInt32& loggerProcessID, UInt64& loggerProcessCreationTime);
    private int _GetTraceLoggerName(String& loggerName);
    public sealed virtual int GetSettings(TRACE_SETTINGS[] pSettings);
    public sealed virtual int GetTraceEventCategoriesCount(UInt32& pCount);
    public sealed virtual int GetTraceEventCategories(UInt32 celt, EventCategoryInfo[] rgelt, UInt32& pceltFetched);
    public sealed virtual int GetIsInErrorState(Int32& isInErrorState);
    public sealed virtual int GetLoggerProcessInfo(String& logFilePath, UInt32& loggerProcessID, UInt64& loggerProcessCreationTime);
    public sealed virtual int GetTraceLoggerName(String& loggerName);
}
internal class Microsoft.VisualStudio.TraceDebugger.TransitionCallsiteNode : TreeNode {
    internal TransitionCallsiteNode(EventHandle evt, CallTree callTree);
    internal virtual NODEINFO GetNode(CallTree callTree, NODEINFO_FLAGS flags, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.TransitionNodeChildEnum : TreeNodeChildEnum {
    private Stack`1<Descendent> _descendents;
    internal TransitionNodeChildEnum(TreeNode parent, CallTree callTree, EngineLock engineLock, NODEINFO_FLAGS flags, UInt32 radix, bool filterEnabled);
    protected virtual int _Reset(ENUM_ORIGIN origin);
    protected virtual int _Next(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected virtual int _Previous(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected virtual int _SkipToNode(ulong nodeId);
    protected virtual int _Clone(IBidiEnumChildNodeInfo100& ppEnum);
    private bool IsTransition(ITreeNode childNode);
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.TreeNode : object {
    protected CallTree _callTree;
    protected EventHandle _evtHandle;
    [CompilerGeneratedAttribute]
private ulong <Id>k__BackingField;
    internal ulong Id { get; internal set; }
    internal EventHandle PrimaryEventHandle { get; }
    internal TreeNode(EventHandle evtHandle, CallTree callTree);
    [CompilerGeneratedAttribute]
internal ulong get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(ulong value);
    internal EventHandle get_PrimaryEventHandle();
    internal abstract virtual NODEINFO GetNode(CallTree callTree, NODEINFO_FLAGS flags, UInt32 radix);
    protected NODEINFO GetNode(CallTree callTree, ITreeNode evt, EventHandle root, NODEINFO_FLAGS flags, UInt32 radix);
}
internal abstract class Microsoft.VisualStudio.TraceDebugger.TreeNodeChildEnum : ComMarshal {
    protected CallTree _callTree;
    protected EngineLock _engineLock;
    protected UInt32 _syncCount;
    protected TreeNode _parent;
    protected IBidiEnum`1<EventHandle> _childEnum;
    protected NODEINFO_FLAGS _flags;
    protected UInt32 _radix;
    protected bool _filterEnabled;
    protected bool _fBuildWithJMC;
    internal TreeNodeChildEnum(TreeNode parent, CallTree callTree, EngineLock engineLock, NODEINFO_FLAGS flags, UInt32 radix, bool filterEnabled);
    protected static EnumOrigin ConvertToEnumOrigin(ENUM_ORIGIN origin);
    protected static bool DoEventHandlesPointToSameNode(EventHandle evt1, EventHandle evt2);
    protected int _GetCount(UInt32& pcelt);
    protected int _SkipBackward(UInt32 celt, UInt32& pcelt);
    protected int _SkipForward(UInt32 celt, UInt32& pcelt);
    protected abstract virtual int _Next(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected abstract virtual int _Previous(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected abstract virtual int _SkipToNode(ulong nodeId);
    protected abstract virtual int _Reset(ENUM_ORIGIN origin);
    protected abstract virtual int _Clone(IBidiEnumChildNodeInfo100& ppEnum);
    public sealed virtual int Next(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched);
    public sealed virtual int Previous(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched);
    public sealed virtual int Reset(ENUM_ORIGIN origin);
    public sealed virtual int SkipBackward(UInt32 celt, UInt32& pcelt);
    public sealed virtual int SkipForward(UInt32 celt, UInt32& pcelt);
    public sealed virtual int SkipToNode(ulong nodeId);
    public sealed virtual int GetCount(UInt32& pcelt);
    public sealed virtual int Clone(IBidiEnumChildNodeInfo100& ppEnum);
}
internal class Microsoft.VisualStudio.TraceDebugger.UserCallsiteNode : TreeNode {
    internal UserCallsiteNode(EventHandle evt, CallTree callTree);
    internal virtual NODEINFO GetNode(CallTree callTree, NODEINFO_FLAGS flags, UInt32 radix);
}
internal class Microsoft.VisualStudio.TraceDebugger.UserCallsiteNodeChildEnum : TreeNodeChildEnum {
    internal UserCallsiteNodeChildEnum(TreeNode parent, CallTree callTree, EngineLock engineLock, NODEINFO_FLAGS flags, UInt32 radix, bool filterEnabled);
    protected virtual int _Reset(ENUM_ORIGIN origin);
    protected virtual int _Next(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected virtual int _Previous(UInt32 celt, NODEINFO[] regelt, UInt32& pceltFetched, bool fBuildNodeInfo);
    protected virtual int _SkipToNode(ulong nodeId);
    protected virtual int _Clone(IBidiEnumChildNodeInfo100& ppEnum);
    private NODEINFO ConvertHandleToNodeInfo(EventHandle child);
}
internal class Microsoft.VisualStudio.TraceDebugger.VBFormatter : Formatter {
    public DebugLanguage Language { get; }
    public virtual DebugLanguage get_Language();
    protected virtual string GetMethodName(MethodType method);
    protected virtual string FormatType(PrimitiveType type, string typePrefix, string suffix);
    protected virtual string GetCharValue(char value);
    protected virtual string FormatPrimitive(bool value, UInt32 radix);
    protected virtual string GetHexPrefix();
    public virtual string FormatString(string value, UInt32 radix, bool partialData);
    protected virtual string GetSimpleTypeName(TypeDefType type);
    protected virtual string FormatDateTime(DateTime value, UInt32 radix);
    public virtual string FormatKeyword(FormatterKeyword keyword);
    public virtual char GetArrayDecorative(bool isStart);
    protected virtual string GetTypePrefix(Symbol symbol);
    protected sealed virtual void GetMethodAttributeAsPrefixOrPostfix(MethodType method, String& methodPrefixPostfix, Boolean& isPostfix);
}
internal class Microsoft.VisualStudio.TraceDebugger.WrapperProperty : Property {
    protected Property _prop;
    protected string _expression;
    public WrapperProperty(Property prop, string expression);
    public virtual string GetFullName(UInt32 radix);
    public virtual string GetName(UInt32 radix);
    public virtual string GetTypeName(UInt32 dwRadix);
    public virtual string GetValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual enum_DBG_ATTRIB_FLAGS GetAttribs(enum_DEBUGPROP_INFO_FLAGS dwFields);
    public virtual string GetStringValue(enum_DEBUGPROP_INFO_FLAGS dwFields, UInt32 dwRadix);
    public virtual List`1<Property> GetChildren(Guid& filter);
    public virtual object GetDataValue();
}
internal static class PackageGuids : object {
    internal static Guid guidIntelliTracePackage;
    internal static Guid guidIntelliTraceCmdSet;
    internal static Guid guidIntelliTraceHubExtensionCmdSet;
    internal static Guid guidDetailsEditorFactory;
    internal static Guid guidAD7Engine;
    internal static Guid guidTraceDebugEngine;
    internal static Guid guidCustomDebuggerEventHandlerService;
    internal static Guid guidNativeEngine;
    internal static string strIntelliTracePackageGuid;
    internal static string strSolutionExplorerToolWindowGuid;
    internal static string strDebugLaunchHookGuid;
    internal static string strEditorFactoryChooserGuid;
    internal static string strToolsOptionsAdvancedGuid;
    internal static string strToolsOptionsDiagnosticEventsGuid;
    internal static string strToolsOptionsGeneralGuid;
    internal static string strToolsOptionsModulesGuid;
    internal static string strTraceLogEditorFactoryGuid;
    internal static string strDetailsEditorFactoryGuid;
    internal static string strDebugEngineGuid;
    internal static string strProgramProviderGuid;
    internal static string strCustomDebuggerEventHandlerServiceGuid;
    internal static string strSnapshotDebuggerEventHandlerServiceGuid;
    private static PackageGuids();
}
internal static class VsComponentMessageCodes : object {
    internal static UInt32 GetTraceAttachSettings;
}
