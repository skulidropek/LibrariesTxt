[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal abstract class Ilrun.AbstractObjectSlot : DefaultSlot {
    private Type m_type;
    private Dictionary`2<FieldInfo, Slot> m_fields;
    internal ICollection`1<Slot> ChildSlots { get; }
    protected AbstractObjectSlot(Type type, IHost host);
    public virtual Type GetTypeX();
    public virtual string ToString();
    protected virtual void AssertValidImpl();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    private void GetBytesHelper(Byte[] buffer, IObjectLayout layout);
    private string DebuggerDisplay();
    private string ToStringInternal(Dictionary`2<Slot, int> objectDict);
    private string GetFieldsAsString(Dictionary`2<Slot, int> objectDict);
    public virtual Slot GetField(FieldInfo field);
    protected abstract virtual Slot GetUninitializedField(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.AccessCheck : object {
    internal static bool IsTypeVisibleTo(Type targetType, Type type);
    internal static bool IsMethodVisibleTo(Type targetType, MethodInfo method);
    internal static bool ArePrivateMembersVisibleTo(Type typeToCheck, Type typeWithPrivateAttribs);
    internal static bool AreProtectedMembersVisibleTo(Type typeToCheck, Type typeWithProtectedAttribs);
    internal static bool AreInternalMembersVisibleTo(Type typeToCheck, Type typeWithInternalAttribs);
    internal static bool AreInternalsVisibleTo(Assembly targetAssembly, Assembly assemblyWithInternals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.AppDomainSlot : HookedObjectSlot {
    private IHost m_host;
    private int m_id;
    internal int Id { get; }
    internal AppDomainSlot(IHost host, int id);
    internal int get_Id();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ArgumentAddressSlot : BaseAddressSlot {
    private IVirtualStackFrame m_frame;
    private int m_argIdx;
    internal ICollection`1<Slot> ChildSlots { get; }
    public ArgumentAddressSlot(IVirtualStackFrame frame, int argIdx, IHost host);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot LoadIndirect();
    public virtual string ToString();
    public virtual VirtualAddress GetVirtualAddress();
}
[FlagsAttribute]
internal enum Ilrun.ArithmeticFlags : Enum {
    public int value__;
    public static ArithmeticFlags Signed;
    public static ArithmeticFlags Unsigned;
    public static ArithmeticFlags OverflowCheck;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ArithmeticProvider : object {
    public sealed virtual Slot Add(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot AddOvf(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot AddOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Div(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot DivUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Mul(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot MulOvf(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot MulOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Neg(VirtualMachine vm, Slot s);
    public sealed virtual Slot Rem(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot RemUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Sub(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot SubOvf(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot SubOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot And(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Or(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Not(VirtualMachine vm, Slot s);
    public sealed virtual Slot Shl(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Shr(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot ShrUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual Slot Xor(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool Beq(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool Bge(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BgeUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool Bgt(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BgtUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool Ble(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BleUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool Blt(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BltUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BneUn(VirtualMachine vm, Slot s1, Slot s2);
    public sealed virtual bool BrTrue(VirtualMachine vm, Slot s);
    public sealed virtual bool BrFalse(VirtualMachine vm, Slot s);
    public sealed virtual Slot ConvertUnsafe(VirtualMachine vm, Slot s, CorElementType targetType);
    public sealed virtual Slot ConvertSafe(VirtualMachine vm, Slot s, CorElementType targetType);
    public sealed virtual Slot ConvertSafeUnsigned(VirtualMachine vm, Slot s, CorElementType targetType);
    private Slot ConvertSafeWorker(VirtualMachine vm, Slot s, PrimitiveType targetType, bool fTreatArgAsSigned);
    private Slot DoBinaryOperation(VirtualMachine vm, Slot s1, Slot s2, BinaryOperation op, ArithmeticFlags flags);
    private Slot DoBinaryOperationWorker(VirtualMachine vm, Slot s1, Slot s2, BinaryOperation op, ArithmeticFlags flags);
    private Slot DoBinaryOperationWithPointerSupport(VirtualMachine vm, BinaryOperation op, Slot s1, Slot s2, ArithmeticFlags flags);
    private static Slot AndWithPointerSupport(Slot pointerSlot, Slot nonPointerSlot);
    private Slot OrWithPointerSupport(Slot pointerSlot, Slot nonPointerSlot);
    private Slot ModulusWithPointerSupport(VirtualMachine vm, Slot pointerSlot, Slot nonPointerSlot);
    private static Slot AddWithPointerSupport(Slot pointerSlot, Slot nonPointerSlot);
    private static Slot SubtractWithPointerSupport(Slot pointerSlot, Slot nonPointerSlot);
    private static int DecodePointerOffset(Slot intSlot);
    internal bool DoComparison(VirtualMachine vm, Slot s1, Slot s2, BinaryComparison comp, ArithmeticFlags flags);
    private static PrimitiveValue GetPrimitiveValueForComparison(Slot s1);
    private Slot BitOperationImpl(VirtualMachine vm, Slot s1, Slot s2, BitOperation op);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ArrayElementAddressSlot : BaseAddressSlot {
    private Slot m_arraySlot;
    private int m_index;
    internal ICollection`1<Slot> ChildSlots { get; }
    public ArrayElementAddressSlot(Slot arraySlot, int index);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot ConvertToPointer(Type pointerType);
    public virtual string ToString();
    public virtual void BulkLoadIndirect(int slotOffset, Byte[] data, int offset, int length);
    public virtual VirtualAddress GetVirtualAddress();
    public virtual void BulkStoreIndirect(Byte[] data, int offset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ArrayElementPointerSlot : ArrayElementPointerSlotBase {
    public ArrayElementPointerSlot(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    protected ArrayElementPointerSlot(ArrayElementPointerSlot sArrayPointer, int elementOffset);
    protected virtual int GetBaseVirtualOffset();
    protected virtual int GetArrayElementSize(Slot sArray);
    protected virtual void SanityCheckArraySlot(Slot sArray);
    protected virtual Slot ConvertToPointer(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    protected virtual Slot GetArrayElement(Slot sArray, int index);
    protected virtual void SetArrayElement(Slot sArray, int index, Slot value);
    protected virtual Type GetArrayElementType(Slot sArray);
    protected virtual int GetArrayLength(Slot sArray);
    internal virtual ArrayElementPointerSlotBase MoveToNextElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.ArrayElementPointerSlotBase : BaseAddressSlot {
    protected Slot m_array;
    protected Type m_type;
    [CompilerGeneratedAttribute]
private int <ElementOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ByteOffset>k__BackingField;
    protected int ElementOffset { get; }
    protected int ByteOffset { get; }
    internal ICollection`1<Slot> ChildSlots { get; }
    private int ArrayElementSize { get; }
    protected internal bool UsesPointerArithmeticSemantics { get; }
    protected ArrayElementPointerSlotBase(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    [CompilerGeneratedAttribute]
protected int get_ElementOffset();
    [CompilerGeneratedAttribute]
protected int get_ByteOffset();
    protected Type GetElementType();
    protected abstract virtual void SanityCheckArraySlot(Slot sArray);
    protected abstract virtual int GetArrayLength(Slot sArray);
    protected abstract virtual Slot ConvertToPointer(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    protected abstract virtual Slot GetArrayElement(Slot sArray, int index);
    protected abstract virtual void SetArrayElement(Slot sArray, int index, Slot value);
    protected abstract virtual Type GetArrayElementType(Slot sArray);
    protected abstract virtual int GetArrayElementSize(Slot sArray);
    protected abstract virtual int GetBaseVirtualOffset();
    internal virtual ArrayElementPointerSlotBase MoveToNextElement();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot ConvertToPointer(Type pointerType);
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot LoadIndirect();
    private void CheckBounds();
    private int get_ArrayElementSize();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    private Byte[] GetBytes();
    private void SetBytes(Byte[] bytes, Type arrayElementType);
    public virtual void StoreIndirect(Slot value);
    public virtual Slot PointerAdd(int offset);
    protected internal virtual bool get_UsesPointerArithmeticSemantics();
    private static Byte[] GetBytesForValueTypeElement(Slot value, Type arrayElementType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ArrayRuntimeAddedMethodInfo : RuntimeAddedMethodInfo {
    public ArrayRuntimeAddedMethodInfo(MethodInfo method, Type declaringType);
    public virtual Slot TryExecute(VirtualMachine virtualMachine, CallArgs callArguments);
    private Type GetArrayHelper();
    private Type GetGenericArrayEnumerator();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.ArraySlot`1 : DefaultSlot {
    private T[] m_data;
    private int m_length;
    private Type m_elementType;
    private Int32[] m_dims;
    private Int32[] m_lowerBounds;
    protected T[] Data { get; }
    protected Type ElementType { get; }
    protected Int32[] Dimensions { get; }
    protected int Rank { get; }
    protected Int32[] LowerBounds { get; }
    protected ArraySlot`1(IHost host, Type elementType, Int32[] dims, Int32[] lowerBounds);
    protected ArraySlot`1(IHost host, Type elementType, Int64[] dims, Int64[] lowerBounds);
    protected T[] get_Data();
    protected Type get_ElementType();
    protected Int32[] get_Dimensions();
    protected int get_Rank();
    protected Int32[] get_LowerBounds();
    public virtual int GetArrayLength();
    public virtual Int32[] GetDimensions();
    public virtual Int32[] GetLowerBounds();
    public virtual bool IsNull();
    public virtual Type GetTypeX();
    protected abstract virtual T ConvertSlotToData(Slot value);
    protected abstract virtual Slot ConvertDataToSlot(T value);
    public virtual void StoreElementAtPosition(int index, Slot sElement);
    public virtual Slot GetElementAtPosition(int index);
    private static int CalculateNumberOfElements(Int32[] dims);
    private static Int32[] ConvertLongArrayToIntArray(Int64[] arr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.AssemblySlot : HookedObjectSlot {
    private Assembly m_assembly;
    internal AssemblySlot(IHost host, Assembly assembly, Type tAssembly);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    private Slot GetVersionImpl(VirtualMachine vm);
    private Slot GetFlagsImpl();
    private Slot GetPublicKeyImpl();
    public virtual Assembly GetAssemblyWorker();
    private Slot CreateInstanceImpl(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments);
}
internal static class Ilrun.Assert : object {
    internal static void Verify(bool value);
    [NullableContextAttribute("1")]
[DebuggerStepThroughAttribute]
internal static void Verify(bool value, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.AssertedInterpreterExecutionException : InterpreterExecutionException {
    public AssertedInterpreterExecutionException(string message);
    public AssertedInterpreterExecutionException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.BaseAddressSlot : DefaultSlot {
    protected BaseAddressSlot(IHost host);
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual Slot GetField(FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public abstract virtual Slot LoadIndirect();
    public abstract virtual void StoreIndirect(Slot value);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.BaseDataPathWalker : BaseMethodWalker {
    public FlowNetwork FlowNetwork;
    private DataPathNode[] m_pathNodes;
    private int m_currentPosition;
    public DataPathNode CurrentNode { get; }
    protected int InstructionIndex { get; }
    public BaseDataPathWalker(DataPath dataPath);
    public DataPathNode get_CurrentNode();
    public void WalkAll();
    [MemberNotNullAttribute("m_pathNodes")]
public void ChangeToPath(DataPath newPath);
    protected virtual int get_InstructionIndex();
    protected virtual void TeminateWalk();
    protected virtual void DoWalk();
    protected virtual void WalkException();
    protected virtual void WalkOrigin();
    protected virtual void WalkMultiInput();
    protected virtual void WalkDivergentPaths();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.BaseFrame : object {
    public VirtualMachine VM;
    public MethodBase Method;
    private Stack`1<Slot> m_evalStack;
    private int m_ip;
    private int m_codeLength;
    private bool m_fDisposed;
    private bool m_fInitialized;
    public bool IsDisposed { get; }
    public bool IsInterpreted { get; }
    public int IP { get; public set; }
    private MethodBase Ilrun.IVirtualStackFrame.Method { get; }
    public BaseFrame(VirtualMachine vm, MethodBase method);
    protected virtual override void Finalize();
    public abstract virtual Slot GetArgument(int index);
    public abstract virtual Type GetArgType(int index);
    public abstract virtual void SetArgument(int index, Slot value);
    public abstract virtual Slot GetArgumentAddress(int index);
    public abstract virtual Slot GetLocalVariable(int index);
    public abstract virtual Type GetLocalType(int index);
    public abstract virtual void SetLocalVariable(int index, Slot value);
    public abstract virtual Slot GetLocalVariableAddress(int index);
    public abstract virtual VirtualAddress GetVAForLocal(int index);
    public abstract virtual VirtualAddress GetVAForArg(int index);
    protected abstract virtual int GetLocalCount();
    protected abstract virtual string FormatLocal(int index);
    protected abstract virtual string FormatArg(int index);
    public sealed virtual void Dispose();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual void InitForInterpretation(CallArgs args);
    public bool get_IsDisposed();
    public sealed virtual bool get_IsInterpreted();
    public sealed virtual int get_IP();
    public sealed virtual void set_IP(int value);
    private sealed virtual override MethodBase Ilrun.IVirtualStackFrame.get_Method();
    public virtual Slot Push(Slot slot);
    public virtual Slot Pop();
    public sealed virtual void ClearILStack();
    public virtual bool CanFuncEvalFromFrame();
    public virtual void OnBeforeFuncEval();
    public static string FormatStackFrame(MethodBase method, int ilOffset, bool fLastFrameFromForeignException);
    public sealed virtual void DumpVariableInfo(DumpFrameFlags flags, List`1<string> textLines);
    [ConditionalAttribute("DEBUG")]
private void AssertIsInMethodBounds(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Ilrun.BaseInterpreterException : Exception {
    [NullableAttribute("2")]
private StackTrace m_originalStackTrace;
    public StackTrace OriginalStackTrace { get; }
    public BaseInterpreterException(string message);
    public BaseInterpreterException(string message, Exception innerException);
    public StackTrace get_OriginalStackTrace();
    public void PreserveStackTrace();
}
internal abstract class Ilrun.BaseMarshaller : object {
    [NullableContextAttribute("1")]
public virtual object GetAsHostObject(Slot s, Type expectedType);
    [NullableContextAttribute("1")]
internal abstract virtual object GetAsHostObjectWorker(Slot s, Type expectedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.BaseMethodWalker : object {
    protected DecodedMethod DecodedMethod;
    protected int InstructionIndex { get; }
    protected DecodedInstruction CurrentInstruction { get; }
    protected BaseMethodWalker(DecodedMethod method);
    protected abstract virtual int get_InstructionIndex();
    protected DecodedInstruction get_CurrentInstruction();
    protected virtual void DoWalk();
    protected abstract virtual void DefaultWalk();
    protected virtual void WalkNop();
    protected virtual void WalkBreak();
    protected virtual void WalkLoadFrameVariable(DecodedOpCode opCode);
    protected virtual void WalkStoreFrameVariable(DecodedOpCode opCode);
    protected virtual void WalkLoadImmediate(DecodedOpCode opCode);
    protected virtual void WalkDup();
    protected virtual void WalkPop();
    protected virtual void WalkCallStub(MethodStub stub);
    protected virtual void WalkCallHook(HookedMethod hook);
    protected virtual void WalkCallIndirect();
    protected virtual void WalkCallVirt(MethodBase method);
    protected virtual void WalkNewObj(MethodStub stub);
    protected virtual void WalkNewObjHook(HookedMethod hook);
    protected virtual void WalkReturn();
    protected virtual void WalkBranch(int target);
    protected virtual void WalkCompareBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkBooleanBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkSwitch(Int32[] switchJumpTable);
    protected virtual void WalkStoreIndirect(DecodedOpCode opCode);
    protected virtual void WalkBinaryOperation(BinaryOperation binOpr);
    protected virtual void WalkUnaryOperation(DecodedOpCode opCode);
    protected virtual void WalkLoadInstanceField(bool isAddress);
    protected virtual void WalkStoreInstanceField();
    protected virtual void WalkLoadStaticField(bool isAddress);
    protected virtual void WalkStoreStaticField();
    protected virtual void WalkConversion(DecodedOpCode opCode);
    protected virtual void WalkNewArr();
    protected virtual void WalkLoadArrayElement(bool isAddress);
    protected virtual void WalkStoreArrayElement();
    protected virtual void WalkThrow();
    protected virtual void WalkRethrow();
    protected virtual void WalkEndFinally();
    protected virtual void WalkEndFilter();
    protected virtual void WalkLeave(int target);
    protected virtual void WalkComparison(DecodedOpCode opCode);
    protected virtual void WalkLocalAlloc();
    protected virtual void WalkInitObj();
    protected virtual void WalkCallPrefix(DecodedOpCode opCode);
    protected virtual void WalkLoadVirtualFunction();
    protected virtual void WalkDecodingError(DecodedOpCode opCode);
}
[DebuggerDisplayAttribute("{BlockStartIndex} to {BlockEndIndex}")]
internal class Ilrun.BasicBlock : object {
    public int BlockStartIndex;
    public int BlockEndIndex;
    public int StartingStackSize;
    public bool IsHandlerStart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private BasicBlock[] <Predecessors>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private BasicBlock[] <Successors>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public BasicBlock[] Predecessors { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public BasicBlock[] Successors { get; private set; }
    public BasicBlock(int blockStartIndex, int blockEndIndex, int startingStackSize, bool isHandlerStart);
    [CompilerGeneratedAttribute]
public BasicBlock[] get_Predecessors();
    [CompilerGeneratedAttribute]
private void set_Predecessors(BasicBlock[] value);
    [CompilerGeneratedAttribute]
public BasicBlock[] get_Successors();
    [CompilerGeneratedAttribute]
private void set_Successors(BasicBlock[] value);
    [NullableContextAttribute("1")]
public void InitializePredecessorsAndSuccessors(BasicBlock[] predecessors, BasicBlock[] successors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.BasicBlockAnalyzer : StackAwareMethodWalker {
    private Queue`1<StartingPoint> m_pendingStartingPoints;
    private InstructionAnalysis[] m_instructionAnalyses;
    private int m_instructionIndex;
    private bool m_isAtLastInstruction;
    private int m_evalStackSize;
    protected int InstructionIndex { get; }
    public BasicBlockAnalyzer(DecodedMethod method);
    public BasicBlock[] FindBasicBlocksInternal();
    protected virtual int get_InstructionIndex();
    protected virtual void DefaultWalk();
    protected virtual void ClearStack();
    protected virtual void Pop();
    protected virtual void Push();
    protected virtual void OnStackAnalysisFail();
    protected virtual void WalkBooleanBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkBranch(int target);
    protected virtual void WalkCompareBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkEndFinally();
    protected virtual void WalkEndFilter();
    protected virtual void WalkLeave(int target);
    protected virtual void WalkRethrow();
    protected virtual void WalkReturn();
    protected virtual void WalkSwitch(Int32[] switchJumpTable);
    protected virtual void WalkThrow();
    private void AddBasicBlock(List`1<BasicBlock> basicBlocks, int startIndex, int endIndex);
    private void AddAnalysisFlag(InstructionAnalysisFlags flag);
    private void AddAnalysisFlag(int instructionIndex, InstructionAnalysisFlags flag);
    private void Branch(int target, BranchType type);
    private void Terminal();
}
public class Ilrun.BeginEvaluationEventHandler : MulticastDelegate {
    public BeginEvaluationEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, string expressionName);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, string expressionName, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.BeginExecuteMethodEventHandler : MulticastDelegate {
    public BeginExecuteMethodEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(string moduleName, string typeName, string methodName);
    public virtual IAsyncResult BeginInvoke(string moduleName, string typeName, string methodName, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.BeginRealFuncEvalEventHandler : MulticastDelegate {
    public BeginRealFuncEvalEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, int ilOffsetOfCall, string moduleName, string typeName, string methodName);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, int ilOffsetOfCall, string moduleName, string typeName, string methodName, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Ilrun.BinaryOperation : Enum {
    public int value__;
    public static BinaryOperation Add;
    public static BinaryOperation Subtract;
    public static BinaryOperation Multiply;
    public static BinaryOperation Divide;
    public static BinaryOperation UnsignedDivide;
    public static BinaryOperation Remainder;
    public static BinaryOperation UnsignedRemainder;
    public static BinaryOperation And;
    public static BinaryOperation Or;
    public static BinaryOperation Xor;
    public static BinaryOperation ShiftLeft;
    public static BinaryOperation ShiftRight;
    public static BinaryOperation UnsignedShiftRight;
    public static BinaryOperation AddOvf;
    public static BinaryOperation SubtractOvf;
    public static BinaryOperation MultiplyOvf;
    public static BinaryOperation UnsignedAddOvf;
    public static BinaryOperation UnsignedSubtractOvf;
    public static BinaryOperation UnsignedMultiplyOvf;
    public static BinaryOperation Count;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.BoxSlot : DefaultSlot {
    private Slot m_slot;
    internal ICollection`1<Slot> ChildSlots { get; }
    public bool IsBox { get; }
    public BoxSlot(Slot value);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual string ToString();
    public virtual bool get_IsBox();
    public virtual Slot GetField(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual Slot GetUnboxValue();
    public virtual Type GetTypeX();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ByReferenceSlot : DefaultSlot {
    private Slot m_element;
    private Type m_type;
    public Slot ElementSlot { get; }
    public ByReferenceSlot(Slot elementSlot, Type byRefType);
    public ByReferenceSlot(Slot elementSlot);
    public virtual Slot MakeValueTypeCopy();
    public virtual Type GetTypeX();
    public Slot get_ElementSlot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CachedMethod : MetadataOnlyMethodInfo {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ParameterInfo[] m_params;
    internal CachedMethod(MetadataOnlyModule resolver, Token methodDef, Type[] typeArgs, Type[] methodArgs);
    public virtual ParameterInfo[] GetParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CachedMethodBody : MetadataOnlyMethodBody {
    private MetadataOnlyMethodBody m_definitionBody;
    public int LocalSignatureMetadataToken { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public int CodeSize { get; }
    private CachedMethodBody(MetadataOnlyMethodInfo method, MetadataOnlyMethodBody definitionBody);
    public static bool TryCreate(MetadataOnlyMethodInfo method, CachedMethodBody& cachedMethodBody);
    public virtual int get_LocalSignatureMetadataToken();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual int get_CodeSize();
    public virtual Byte[] GetILAsByteArray();
    [NullableContextAttribute("2")]
internal virtual Byte[] GetLocalSignatureBlob();
    internal virtual IEHClause[] GetRawHandlerClauses();
    private static MetadataOnlyMethodBody FindOriginalBody(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CachedReflectionFactory : DefaultFactory {
    private Dictionary`2<MetadataOnlyModule, ModuleEntry> m_moduleCache;
    private object m_genericCacheLock;
    private Dictionary`2<GenericInstantiation, CachedTypeDef> m_genericInstantiationCache;
    internal void RemoveModuleFromCache(Module m);
    public virtual MetadataOnlyCommonType CreateSimpleType(MetadataOnlyModule scope, Token tokenTypeDef);
    public virtual MetadataOnlyCommonType CreateGenericType(MetadataOnlyModule scope, Token tokenTypeDef, Type[] typeArgs);
    public virtual Type CreateTypeRef(MetadataOnlyModule scope, Token tokenTypeRef);
    public virtual MethodBase CreateMethodOrConstructor(MetadataOnlyModule resolver, Token methodDef, Type[] typeArgs, Type[] methodArgs);
    public virtual MetadataOnlyCommonType CreateVectorType(MetadataOnlyCommonType elementType);
    public virtual bool AreModulesEqual(MetadataOnlyModule module1, MetadataOnlyModule module2);
    public virtual bool TryCreateMethodBody(MetadataOnlyMethodInfo method, MethodBody& body);
    private ModuleEntry GetModuleEntry(MetadataOnlyModule scope);
    private static Type ResolveType(Type type);
    private static void FillModuleDependencyList(Type type, List`1<Module> moduleList);
    private static bool IsRawConstructor(MethodInfo m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CachedTypeDef : MetadataOnlyTypeDef {
    public ModuleEntry CachedModule;
    private bool m_isPropertyBaseTypeInitialized;
    [NullableAttribute("2")]
private Type m_baseType;
    [NullableAttribute("2")]
private string m_fullName;
    [NullableAttribute("2")]
private string m_assemblyQualifiedName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Type[] m_interfaces;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodInfo[] m_instanceMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodInfo[] m_staticMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodInfo[] m_allMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodInfo[] m_publicInstanceMethods;
    [NullableAttribute("2")]
private Type m_declaringType;
    private bool m_fGotDeclaringType;
    private Dictionary`2<BindingFlags, FieldInfo[]> m_fieldCache;
    private static int MaxCacheSize;
    [NullableAttribute("2")]
private ConstructorInfo m_staticCtor;
    [NullableAttribute("2")]
private ConstructorInfo m_defaultPublicCtor;
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    internal CachedTypeDef(MetadataOnlyModule scope, ModuleEntry cachedModule, Token token);
    internal CachedTypeDef(MetadataOnlyModule scope, ModuleEntry cachedModule, Token token, Type[] typeParameters);
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual bool Equals(Type objOther);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual FieldInfo[] GetFields(BindingFlags flags);
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type[] GetInterfaces();
    public virtual MethodInfo[] GetMethods(BindingFlags flags);
    private List`1<MethodInfo> Filter(MethodInfo[] arr, BindingFlags flags);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsureMethodsInited();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CachedTypeRef : MetadataOnlyTypeReference {
    private ModuleEntry m_cache;
    [NullableAttribute("2")]
private string m_fullName;
    public string FullName { get; }
    internal CachedTypeRef(Token typeRef, ModuleEntry cache);
    public virtual string get_FullName();
    public virtual Type GetResolvedType();
    internal Type BaseGetResolvedType();
    internal void InvalidateCache();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.CachedTypeUniverse : object {
    [NullableAttribute("2")]
private Type[] m_builtInTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Type[] m_knownTypes;
    private Dictionary`2<Module, Dictionary`2<Token, AssemblyResolutionCache>> m_assemblyResolutionCache;
    private Dictionary`2<Assembly, Dictionary`2<AssemblyResolutionCache, object>> m_cachesResolvingToAssembly;
    [NullableAttribute("2")]
[LockedByAttribute("m_lock")]
private IlrunHooksAssemblyProvider m_ilHooksAssemblyProvider;
    private object m_lock;
    public sealed virtual Type GetBuiltInType(CorElementType elementType);
    [DoesNotReturnAttribute]
private void ThrowCorElementTypeNotFound(CorElementType elementType);
    public sealed virtual Type GetKnownType(KnownType knownType);
    [NullableContextAttribute("2")]
public sealed virtual Type GetKnownTypeNoThrow(KnownType knownType);
    [NullableContextAttribute("2")]
protected virtual Type TryResolveKnownType(KnownType knownType);
    private Type GetSystemType(string fullName);
    public abstract virtual Assembly GetSystemAssembly();
    [NullableContextAttribute("2")]
public abstract virtual Assembly TryGetSystemAssembly();
    [NullableContextAttribute("2")]
public abstract virtual Assembly TryGetEntryPointAssembly();
    public abstract virtual Assembly ResolveAssembly(AssemblyName name, bool fThrowOnError);
    public abstract virtual Assembly ResolveWinMDAssembly(string typeName);
    public sealed virtual Assembly ResolveAssembly(Module scope, Token tokenAssemblyRef, string typeName);
    public virtual Module ResolveModule(Assembly containingAssembly, string moduleName);
    protected virtual void RemoveAssemblyFromCache(Assembly assembly);
    protected virtual void RemoveModuleFromCache(Module module);
    internal Assembly GetILHooksAssembly();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ComVisibleAttribute("True")]
[DebuggerDisplayAttribute("{DebuggerToString()}")]
internal class Ilrun.CallArgs : object {
    [NullableAttribute("2")]
private Slot m_this;
    private Slot[] m_args;
    [NullableAttribute("2")]
public Slot This { get; public set; }
    public Slot[] Args { get; public set; }
    public CallArgs(Slot slotThis);
    public CallArgs(Slot slotThis, Slot[] args);
    private string DebuggerToString();
    [NullableContextAttribute("2")]
public Slot get_This();
    [NullableContextAttribute("2")]
public void set_This(Slot value);
    public Slot GetRequiredThis();
    public Slot[] get_Args();
    public void set_Args(Slot[] value);
    public Slot[] Merge();
}
public enum Ilrun.ClrVersion : Enum {
    public int value__;
    public static ClrVersion All;
    public static ClrVersion NetCoreAll;
    public static ClrVersion V2;
    public static ClrVersion V35;
    public static ClrVersion V35SP1;
    public static ClrVersion V40;
    public static ClrVersion V45;
    public static ClrVersion V451;
    public static ClrVersion V452;
    public static ClrVersion V461;
    public static ClrVersion NetNative;
    public static ClrVersion NetCore20;
    public static ClrVersion NetCore7;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.ClrVersionImpl : object {
    private IHost m_host;
    private ClrVersion m_clrVersion;
    internal ClrVersion Version { get; }
    internal ITypeUniverse TypeUniverse { get; }
    internal IHost Host { get; }
    protected ClrVersionImpl(IHost host, ClrVersion clrVersion);
    internal ClrVersion get_Version();
    internal ITypeUniverse get_TypeUniverse();
    internal IHost get_Host();
    internal abstract virtual KnownType GetTypeForRuntimeReflectionObject(ReflectionObjectType type);
    internal abstract virtual ReflectionObjectType GetReflectionObjectType(Type runtimeType);
    internal abstract virtual Slot GetSlotForType(Type type);
    internal abstract virtual Slot GetSlotForAssembly(Assembly assembly);
    internal abstract virtual Slot GetSlotForField(FieldInfo field);
    internal abstract virtual Slot GetSlotForMethod(MethodBase method);
    internal abstract virtual Slot GetSlotForModule(Module module);
    internal abstract virtual Slot GetSlotForPrimitive(PrimitiveValue pv);
    internal abstract virtual bool IsTransparentProxy(Type type);
    internal abstract virtual MethodHookDelegate TryGetHook(MethodBase method);
    internal abstract virtual Slot GetFieldOfPrimitive(Slot value, FieldInfo field);
    internal abstract virtual RuntimeAddedMethodInfo GetHookedInterfaceMethod(MethodBase method, Type slotType);
    internal abstract virtual KnownType GetByReferenceType();
    internal abstract virtual bool IsWhitelistReflectionMethod(string methodName, ReflectionObjectType reflectionType);
    public abstract virtual IObjectLayout GetObjectLayout(Type type);
    public abstract virtual int CalculateObjectSize(Type type, IObjectLayout layout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImpl35 : ClrVersionImpl {
    private static string RuntimeFieldInfoTypeName;
    private static string RtFieldInfoTypeName;
    private static string RuntimeConstructorInfoTypeName;
    private static string RuntimeMethodInfoTypeName;
    private static string RuntimeTypeName;
    private static string RuntimeModuleTypeName;
    private static string RuntimeAssemblyTypeName;
    private static string RuntimePropertyInfoTypeName;
    private static string RuntimeParameterInfoTypeName;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static InfiniteRecursionGuard s_irgGetSlotForPrimitive;
    private static InfiniteRecursionGuard IrgGetSlotForPrimitive { get; }
    protected ClrVersionImpl35(IHost host, ClrVersion clrVersion);
    internal virtual Slot GetSlotForType(Type type);
    internal virtual Slot GetSlotForField(FieldInfo field);
    internal virtual Slot GetSlotForMethod(MethodBase method);
    internal virtual Slot GetSlotForAssembly(Assembly assembly);
    internal virtual Slot GetSlotForModule(Module module);
    private static InfiniteRecursionGuard get_IrgGetSlotForPrimitive();
    internal virtual Slot GetSlotForPrimitive(PrimitiveValue pv);
    internal virtual bool IsTransparentProxy(Type type);
    internal virtual KnownType GetTypeForRuntimeReflectionObject(ReflectionObjectType type);
    internal virtual ReflectionObjectType GetReflectionObjectType(Type runtimeType);
    internal virtual MethodHookDelegate TryGetHook(MethodBase method);
    private MethodHookDelegate MaybeGetReflectionHook(MethodBase method);
    public static ClrVersionImpl35 Create(IHost host);
    internal virtual RuntimeAddedMethodInfo GetHookedInterfaceMethod(MethodBase method, Type slotType);
    internal virtual Slot GetFieldOfPrimitive(Slot value, FieldInfo field);
    private static string GetValueFieldName();
    internal virtual KnownType GetByReferenceType();
    internal virtual bool IsWhitelistReflectionMethod(string methodName, ReflectionObjectType reflectionType);
    public virtual IObjectLayout GetObjectLayout(Type type);
    public virtual int CalculateObjectSize(Type type, IObjectLayout layout);
    private FieldInfo GetDeclaredFieldWithHighestEndOffset(Type type, IObjectLayout layout, Int32& highestDeclaredFieldEnd);
    internal static bool IsTypeBlittable(Type type);
    internal static bool SupportsSequentialObjectLayout(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImpl40 : ClrVersionImpl35 {
    private static string RuntimeAssemblyTypeName;
    private static string RuntimeModuleTypeName;
    private static string RuntimeParameterInfoTypeName;
    protected ClrVersionImpl40(IHost host, ClrVersion clrVersion);
    internal virtual ReflectionObjectType GetReflectionObjectType(Type runtimeType);
    internal virtual KnownType GetTypeForRuntimeReflectionObject(ReflectionObjectType type);
    public static ClrVersionImpl40 Create(IHost host);
    internal virtual bool IsWhitelistReflectionMethod(string methodName, ReflectionObjectType reflectionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImpl45 : ClrVersionImpl40 {
    protected ClrVersionImpl45(IHost host, ClrVersion clrVersion);
    public static ClrVersionImpl45 Create(IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImpl451 : ClrVersionImpl45 {
    protected ClrVersionImpl451(IHost host, ClrVersion clrVersion);
    public static ClrVersionImpl451 Create(IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImplCore20 : ClrVersionImpl451 {
    protected ClrVersionImplCore20(IHost host, ClrVersion clrVersion);
    public static ClrVersionImplCore20 Create(IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImplCore7 : ClrVersionImplCore20 {
    protected ClrVersionImplCore7(IHost host, ClrVersion clrVersion);
    public static ClrVersionImplCore7 Create(IHost host);
    public virtual IObjectLayout GetObjectLayout(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionImplPN : ClrVersionImpl45 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static HookManager`1<MethodHookDelegate> s_customHookManager;
    protected ClrVersionImplPN(IHost host, ClrVersion clrVersion);
    private KnownType GetRuntimeTypeKnownType(ITypeUniverse typeUniverse);
    internal virtual Slot GetSlotForType(Type type);
    internal virtual KnownType GetTypeForRuntimeReflectionObject(ReflectionObjectType type);
    internal virtual ReflectionObjectType GetReflectionObjectType(Type runtimeType);
    public static ClrVersionImplPN Create(IHost host);
    internal virtual MethodHookDelegate TryGetHook(MethodBase method);
    internal virtual RuntimeAddedMethodInfo GetHookedInterfaceMethod(MethodBase method, Type slotType);
    internal virtual KnownType GetByReferenceType();
    internal virtual bool IsWhitelistReflectionMethod(string methodName, ReflectionObjectType reflectionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ClrVersionUtility : object {
    internal static ClrVersionImpl GetClrVersion(IHost host);
    internal static ReflectionObjectType GetReflectionObjectType(Slot slot);
    internal static object GetReflectionObject(Slot slot);
    internal static bool IsDotNetCore(ClrVersion clrVersion);
}
internal static class Ilrun.CommonConstId : object {
    public static int I4_0;
    public static int I4_1;
    public static int I4_2;
    public static int I4_3;
    public static int I4_4;
    public static int I4_5;
    public static int I4_6;
    public static int I4_7;
    public static int I4_8;
    public static int EmptyStr;
    public static int Count;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Ilrun.CommonSlotConst : object {
    public static int MaxIntConst;
    private Slot[] m_value;
    public Slot Item { get; }
    public CommonSlotConst(IHost host);
    public Slot get_Item(int index);
}
internal class Ilrun.ComparableProxyObject : ProxyBase {
    [NullableContextAttribute("1")]
public ComparableProxyObject(VirtualMachine vm, Slot s);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CultureCache : object {
    [NullableAttribute("2")]
private CultureInfo m_culture;
    [NullableAttribute("2")]
private CultureInfo m_uiCulture;
    internal CultureCache(CultureInfo explicitCurrentCulture, CultureInfo explicitCurrentUICulture);
    internal CultureInfo GetCurrentCulture(VirtualMachine vm);
    internal CultureInfo GetCurrentUICulture(VirtualMachine vm);
    internal void FlushCurrentCultureCache();
    internal void FlushCurrentUICultureCache();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CustomAttributeDataSlot : HookedObjectSlot {
    private CustomAttributeData m_cad;
    internal CustomAttributeDataSlot(IHost host, Type tCustomAttributeData, CustomAttributeData cad);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.CustomAttributeTypedArgumentSlot : HookedObjectSlot {
    private CustomAttributeTypedArgument m_cata;
    internal CustomAttributeTypedArgumentSlot(IHost host, Type tCustomAttributeTypedArgument, CustomAttributeTypedArgument cata);
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DataPath : object {
    public FlowNetwork FlowNetwork;
    public DataPathNode[] PathNodes;
    public DataPath(FlowNetwork network, DataPathNode[] pathNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{NodeType} Index: {InstructionIndex}")]
internal class Ilrun.DataPathNode : object {
    [CompilerGeneratedAttribute]
private IList`1<DataPathNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private DataPathNodeType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstructionIndex>k__BackingField;
    public IList`1<DataPathNode> Children { get; private set; }
    public DataPathNodeType NodeType { get; private set; }
    public int InstructionIndex { get; private set; }
    public DataPathNode(int instructionIndex);
    public DataPathNode(DataPathNodeType type, int instructionIndex);
    [CompilerGeneratedAttribute]
public IList`1<DataPathNode> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<DataPathNode> value);
    [CompilerGeneratedAttribute]
public DataPathNodeType get_NodeType();
    [CompilerGeneratedAttribute]
private void set_NodeType(DataPathNodeType value);
    [CompilerGeneratedAttribute]
public int get_InstructionIndex();
    [CompilerGeneratedAttribute]
private void set_InstructionIndex(int value);
    public void SetType(DataPathNodeType type);
}
public enum Ilrun.DataPathNodeType : Enum {
    public int value__;
    public static DataPathNodeType UnderConstruction;
    public static DataPathNodeType Origin;
    public static DataPathNodeType SingleInput;
    public static DataPathNodeType MultiInput;
    public static DataPathNodeType Exception;
    public static DataPathNodeType DivergentPath;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DebugIdGenerator : object {
    public static DebugIdGenerator Slots;
    public static DebugIdGenerator FakeValues;
    public static DebugIdGenerator CorValues;
    public static DebugIdGenerator Properties;
    public static DebugIdGenerator PropertyEnums;
    public int NextId { get; }
    private static DebugIdGenerator();
    public int get_NextId();
    public static void Reset();
}
public static class Ilrun.DebugOptions : object {
    [CompilerGeneratedAttribute]
private static bool <OutputMethodEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OutputMethodExit>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OutputInstructions>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OutputLoadStore>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OutputArithmetic>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OutputHookedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnNoIL>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnFailedDelegateFuncEval>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnInterpreterException>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnInterpreterExecutionException>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnMethodNotHooked>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnInterpreterExceptionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnFieldAccessOnHookedObjectSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnCreatingObjectSlotOfSpecialType>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AssertOnReflectionInvokerException>k__BackingField;
    public static bool OutputMethodEntry { get; public set; }
    public static bool OutputMethodExit { get; public set; }
    public static bool OutputInstructions { get; public set; }
    public static bool OutputLoadStore { get; public set; }
    public static bool OutputArithmetic { get; public set; }
    public static bool OutputHookedMethods { get; public set; }
    public static bool AssertOnNoIL { get; public set; }
    public static bool AssertOnFailedDelegateFuncEval { get; public set; }
    public static bool AssertOnInterpreterException { get; public set; }
    public static bool AssertOnInterpreterExecutionException { get; public set; }
    public static bool AssertOnMethodNotHooked { get; public set; }
    public static bool AssertOnInterpreterExceptionConstructor { get; public set; }
    public static bool AssertOnFieldAccessOnHookedObjectSlot { get; public set; }
    public static bool AssertOnCreatingObjectSlotOfSpecialType { get; public set; }
    public static bool AssertOnReflectionInvokerException { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_OutputMethodEntry();
    [CompilerGeneratedAttribute]
public static void set_OutputMethodEntry(bool value);
    [CompilerGeneratedAttribute]
public static bool get_OutputMethodExit();
    [CompilerGeneratedAttribute]
public static void set_OutputMethodExit(bool value);
    [CompilerGeneratedAttribute]
public static bool get_OutputInstructions();
    [CompilerGeneratedAttribute]
public static void set_OutputInstructions(bool value);
    [CompilerGeneratedAttribute]
public static bool get_OutputLoadStore();
    [CompilerGeneratedAttribute]
public static void set_OutputLoadStore(bool value);
    [CompilerGeneratedAttribute]
public static bool get_OutputArithmetic();
    [CompilerGeneratedAttribute]
public static void set_OutputArithmetic(bool value);
    [CompilerGeneratedAttribute]
public static bool get_OutputHookedMethods();
    [CompilerGeneratedAttribute]
public static void set_OutputHookedMethods(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnNoIL();
    [CompilerGeneratedAttribute]
public static void set_AssertOnNoIL(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnFailedDelegateFuncEval();
    [CompilerGeneratedAttribute]
public static void set_AssertOnFailedDelegateFuncEval(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnInterpreterException();
    [CompilerGeneratedAttribute]
public static void set_AssertOnInterpreterException(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnInterpreterExecutionException();
    [CompilerGeneratedAttribute]
public static void set_AssertOnInterpreterExecutionException(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnMethodNotHooked();
    [CompilerGeneratedAttribute]
public static void set_AssertOnMethodNotHooked(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnInterpreterExceptionConstructor();
    [CompilerGeneratedAttribute]
public static void set_AssertOnInterpreterExceptionConstructor(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnFieldAccessOnHookedObjectSlot();
    [CompilerGeneratedAttribute]
public static void set_AssertOnFieldAccessOnHookedObjectSlot(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnCreatingObjectSlotOfSpecialType();
    [CompilerGeneratedAttribute]
public static void set_AssertOnCreatingObjectSlotOfSpecialType(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AssertOnReflectionInvokerException();
    [CompilerGeneratedAttribute]
public static void set_AssertOnReflectionInvokerException(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.DebugOutput : object {
    private static DebugOutput();
    public static void SetTracingOutputEnabled(bool fEnable);
    [ConditionalAttribute("DEBUG")]
internal static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
internal static void WriteLine(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebugString}")]
internal class Ilrun.DecodedHandlerClause : object {
    public ExceptionHandlingClauseOptions Flags;
    public int TryBegin;
    public int TryEnd;
    public int HandlerBegin;
    public int HandlerEnd;
    public int FilterBegin;
    [NullableAttribute("2")]
public Type CatchType;
    private string DebugString { get; }
    [NullableContextAttribute("2")]
public DecodedHandlerClause(ExceptionHandlingClauseOptions flags, int tryBegin, int tryEnd, int handlerBegin, int handlerEnd, int filterBegin, Type catchType);
    public bool IsInTryBlock(int instructionOffset);
    public bool IsInHandlerBlock(int instructionOffset);
    private string get_DebugString();
}
[DebuggerDisplayAttribute("{OpCode} {Operand}")]
internal class Ilrun.DecodedInstruction : ValueType {
    public DecodedOpCode OpCode;
    public int Operand;
    public DecodedInstruction(DecodedOpCode opCode, int operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{FormattedName}")]
internal class Ilrun.DecodedMethod : object {
    public MethodStub Stub;
    public DecodedInstruction[] Instructions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DecodedHandlerClause[] ExceptionHandlerClauses;
    public Int32[] ILMappingTable;
    public bool DebuggingEnabled;
    public bool HasAssemblyResolutionFailures;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Slot[] SlotOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MemberInfo[] MetadataOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodStub[] MethodOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HookedMethod[] HookedMethodOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Int32[][] SwitchJumpTableOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BasicBlock[] m_cachedBasicBlocks;
    public string FormattedName { get; }
    public DecodedMethod(MethodStub stub, DecodedInstruction[] instructions, DecodedHandlerClause[] exceptionHandlerClauses, Slot[] slotOperands, MemberInfo[] metadataOperands, MethodStub[] methodStubOperands, HookedMethod[] hookedMethodOperands, Int32[][] switchJumpTableOperands, Int32[] ilMappingTable, bool debuggingEnabled, bool hasAssemblyResolutionFailures);
    public string get_FormattedName();
    public int InstructionIndexToILOffset(int instructionIndex);
    public int ILOffsetToInstructionIndex(int ilOffset);
    public BasicBlock[] GetBasicBlocks();
    internal string DumpDebugInformation(DumpFrameFlags flags);
    internal void DumpText(DumpFrameFlags flags, int ip, List`1<string> textLines);
    private string FormatOpCode(DecodedInstruction instruction);
    private string FormatOperand(DumpFrameFlags flags, DecodedInstruction instruction);
    private string FormatSlotOperand(DecodedInstruction instruction);
    private static string FormatCommonConstOperand(int operand);
    private string FormatMetadataOperand(DumpFrameFlags flags, DecodedInstruction instruction);
    private string FormatMethodStubOperand(DecodedInstruction instruction);
    private string FormatHookedMethodOperand(DecodedInstruction instruction);
    private static string FormatCorElementTypeOperand(int operand);
    private string FormatJumpTable(DecodedInstruction instruction);
    private static string FormatInstructionOffset(int offset);
    private static string FormatIlOpCode(int opCode);
}
internal enum Ilrun.DecodedOpCode : Enum {
    public int value__;
    public static DecodedOpCode Nop;
    public static DecodedOpCode Break;
    public static DecodedOpCode LdLoc;
    public static DecodedOpCode LdArg;
    public static DecodedOpCode StLoc;
    public static DecodedOpCode StArg;
    public static DecodedOpCode LdLocA;
    public static DecodedOpCode LdArgA;
    public static DecodedOpCode LdNull;
    public static DecodedOpCode Ldc;
    public static DecodedOpCode LdcC;
    public static DecodedOpCode Dup;
    public static DecodedOpCode Pop;
    public static DecodedOpCode Call;
    public static DecodedOpCode Calli;
    public static DecodedOpCode CallVirt;
    public static DecodedOpCode CallHook;
    public static DecodedOpCode Ret;
    public static DecodedOpCode Br;
    public static DecodedOpCode BrFalse;
    public static DecodedOpCode BrTrue;
    public static DecodedOpCode Beq;
    public static DecodedOpCode Bge;
    public static DecodedOpCode Bgt;
    public static DecodedOpCode Ble;
    public static DecodedOpCode Blt;
    public static DecodedOpCode BneUn;
    public static DecodedOpCode BgeUn;
    public static DecodedOpCode BgtUn;
    public static DecodedOpCode BleUn;
    public static DecodedOpCode BltUn;
    public static DecodedOpCode Switch;
    public static DecodedOpCode LdInd;
    public static DecodedOpCode StInd;
    public static DecodedOpCode BinOpr;
    public static DecodedOpCode Not;
    public static DecodedOpCode Neg;
    public static DecodedOpCode LdFld;
    public static DecodedOpCode LdFldA;
    public static DecodedOpCode StFld;
    public static DecodedOpCode LdSFld;
    public static DecodedOpCode LdSFldA;
    public static DecodedOpCode StSFld;
    public static DecodedOpCode Conv;
    public static DecodedOpCode ConvOvf;
    public static DecodedOpCode ConvOvfUn;
    public static DecodedOpCode LdObj;
    public static DecodedOpCode StObj;
    public static DecodedOpCode NewObj;
    public static DecodedOpCode NewObjHk;
    public static DecodedOpCode NewArr;
    public static DecodedOpCode LdLen;
    public static DecodedOpCode LdElem;
    public static DecodedOpCode LdElemA;
    public static DecodedOpCode StElem;
    public static DecodedOpCode CastClass;
    public static DecodedOpCode IsInst;
    public static DecodedOpCode Box;
    public static DecodedOpCode Unbox;
    public static DecodedOpCode UnboxAny;
    public static DecodedOpCode Throw;
    public static DecodedOpCode Rethrow;
    public static DecodedOpCode EndFinally;
    public static DecodedOpCode EndFilter;
    public static DecodedOpCode Leave;
    public static DecodedOpCode Ceq;
    public static DecodedOpCode Cgt;
    public static DecodedOpCode CgtUn;
    public static DecodedOpCode Clt;
    public static DecodedOpCode CltUn;
    public static DecodedOpCode LocAlloc;
    public static DecodedOpCode InitObj;
    public static DecodedOpCode Constrained;
    public static DecodedOpCode TailCall;
    public static DecodedOpCode LdFtn;
    public static DecodedOpCode LdFtnHk;
    public static DecodedOpCode LdVirtFtn;
    public static DecodedOpCode LdToken;
    public static DecodedOpCode MkRefAny;
    public static DecodedOpCode MissingField;
    public static DecodedOpCode MissingMethod;
    public static DecodedOpCode TypeLoadException;
    public static DecodedOpCode FileNotFound;
    public static DecodedOpCode Unsupported;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.DefaultHost : object {
    public static int MaxAllocationBytes;
    private DefaultSlotFactory m_factory;
    private IVirtualDispatchResolver m_vdr;
    private ITypeUniverse m_universe;
    private ResourceAssemblyManager m_ram;
    private IArithmeticProvider m_arithProv;
    private StubTable m_stubTable;
    [NullableAttribute("2")]
private CommonSlotConst m_commonConst;
    [NullableAttribute("2")]
private ClrVersionImpl m_clrVersionImpl;
    private Nullable`1<int> m_offsetToStringData;
    private static Dictionary`2<ClrVersion, HookManager`1<MethodHookDelegate>> s_cachedHookManagers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HookManager`1<MethodBase> m_ilHookManager;
    [NullableAttribute("2")]
private IObjectLayout m_cachedSystemObjectLayout;
    [NullableAttribute("2")]
private IObjectLayout m_cachedSystemStringLayout;
    public ITypeUniverse TypeUniverse { get; }
    public ResourceAssemblyManager ResourceAssemblyManager { get; public set; }
    public IArithmeticProvider ArithmeticProvider { get; }
    [ThreadSafeAttribute]
public StubTable StubTable { get; }
    public CommonSlotConst CommonConst { get; }
    internal CultureCache CultureCache { get; }
    protected StaticFieldRepository StaticFieldRepository { get; }
    public DefaultSlotFactory SlotFactory { get; }
    private ISlotFactory Ilrun.IHost.SlotFactory { get; }
    public IVirtualDispatchResolver VirtualDispatchResolver { get; }
    public ClrVersionImpl ClrVersionImpl { get; }
    public DefaultHost(ITypeUniverse universe);
    public DefaultHost(Func`2<DefaultHost, DefaultSlotFactory> slotFactoryCreator, ITypeUniverse u, IVirtualDispatchResolver vdr, ResourceAssemblyManager ram);
    private static DefaultHost();
    public sealed virtual ITypeUniverse get_TypeUniverse();
    public ResourceAssemblyManager get_ResourceAssemblyManager();
    public void set_ResourceAssemblyManager(ResourceAssemblyManager value);
    public sealed virtual IArithmeticProvider get_ArithmeticProvider();
    public sealed virtual StubTable get_StubTable();
    public sealed virtual CommonSlotConst get_CommonConst();
    internal CultureCache get_CultureCache();
    public sealed virtual VirtualMachine CreateVM();
    public virtual SourceLocation[] GetSourceLocations(ExceptionStackFrame[] frames);
    public virtual IObjectLayout GetObjectLayout(Type type);
    public virtual Slot GetStaticFieldAddress(FieldInfo field, VirtualMachine virtualMachine);
    public virtual Slot ReadStaticField(FieldInfo field, VirtualMachine virtualMachine);
    public sealed virtual void EnsureStaticCtorRun(Type type, bool fAccessingStaticField, VirtualMachine vm);
    public virtual Slot GetOrCreateTaskId(Slot sTask, VirtualMachine vm);
    public virtual void VerifyCanInterpretMethod(MethodBase method);
    public virtual void WriteStaticField(FieldInfo field, Slot value, VirtualMachine virtualMachine);
    public virtual void GetMethodHooks(MethodBase method, List`1<MethodHookDelegate> hooks, MethodBase& ilHookMethod);
    private static Slot ProfilerNop(VirtualMachine vm, MethodBase method, CallArgs args);
    public virtual MethodHookDelegate TryHookCallInInspectionMethod(MethodBase method);
    protected abstract virtual StaticFieldRepository get_StaticFieldRepository();
    public DefaultSlotFactory get_SlotFactory();
    private sealed virtual override ISlotFactory Ilrun.IHost.get_SlotFactory();
    public sealed virtual IVirtualDispatchResolver get_VirtualDispatchResolver();
    public sealed virtual bool IsTransparentProxy(Type type);
    public virtual IVirtualStackFrame CreateStackFrameForMethodCall(VirtualMachine virtualMachine, MethodBase method, IVirtualStackFrame caller);
    public virtual void OnFirstChanceException(Slot exception, VirtualMachine virtualMachine);
    public virtual void OnExceptionUnwind(Slot exception, VirtualMachine virtualMachine);
    private void CaptureStackTrace(Slot exceptionSlot, VirtualMachine virtualMachine);
    internal Assembly GetMscorlibResourceAssembly(CultureInfo culture, String& baseName);
    internal abstract virtual Assembly ResolveAssemblyNoThrowOnError(AssemblyName name);
    internal virtual string GetVirtualExceptionMessageForLmrException(VirtualMachine vm, Exception lmrException);
    public virtual ExceptionAction GetInterpreterExecutionExceptionHandler(VirtualMachine vm, InterpreterExecutionException exception);
    public virtual bool IsClrNativeCompilation();
    public virtual IClrNcHostService GetClrNcHostService();
    public virtual bool IsReflectionObjectDecodingNecessaryForObjectIdentityComparison(Slot s1, Slot s2);
    public virtual bool AreSlotsEqual(Slot s1, Slot s2);
    public ClrVersionImpl get_ClrVersionImpl();
    private ClrVersionImpl GetClrVersionFromSystemAssembly();
    private bool IsDev11OrBetterClr(Assembly systemAssembly);
    private bool IsDev12OrBetterClr(Assembly systemAssembly);
    internal int GetOffsetToStringData();
    public virtual bool IsEvaluationCanceled();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Ilrun.DefaultHostResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ClassLoadBadFormat { get; }
    internal static string ClassLoadExplicitGeneric { get; }
    internal static string ClassLoadExplicitLayout { get; }
    internal static string ClassLoadGeneral { get; }
    internal static string ClassLoadInlineArrayExplicit { get; }
    internal static string ClassLoadInlineArrayFieldCount { get; }
    internal static string ClassLoadInlineArrayLength { get; }
    internal static string ClassLoadValueClassTooLarge { get; }
    internal static string Exception_EndStackTraceFromPreviousThrow { get; }
    internal static string IDS_EE_OUT_OF_MEMORY { get; }
    internal static string IDS_EE_THREAD_ABORT { get; }
    internal static string IDS_EE_THREAD_INTERRUPTED { get; }
    internal static string LargeArraySize { get; }
    internal static string NegativeArraySize { get; }
    internal static string NotSupported_CaseInsensitiveTypeLookups { get; }
    internal static string ProxyCreationFailed { get; }
    internal static string StackTrace_GenericMissingBinary { get; }
    internal static string StackTrace_InFileLineNumber { get; }
    internal static string StackTrace_SpecificMissingBinary { get; }
    internal static string Unknown { get; }
    internal static string UnsupportedOperation_MissingBinary { get; }
    internal static string UnsupportedOperation_MissingUnknownBinary { get; }
    internal static string UnsupportedOperation_TaskCtor { get; }
    internal static string Word_At { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ClassLoadBadFormat();
    internal static string get_ClassLoadExplicitGeneric();
    internal static string get_ClassLoadExplicitLayout();
    internal static string get_ClassLoadGeneral();
    internal static string get_ClassLoadInlineArrayExplicit();
    internal static string get_ClassLoadInlineArrayFieldCount();
    internal static string get_ClassLoadInlineArrayLength();
    internal static string get_ClassLoadValueClassTooLarge();
    internal static string get_Exception_EndStackTraceFromPreviousThrow();
    internal static string get_IDS_EE_OUT_OF_MEMORY();
    internal static string get_IDS_EE_THREAD_ABORT();
    internal static string get_IDS_EE_THREAD_INTERRUPTED();
    internal static string get_LargeArraySize();
    internal static string get_NegativeArraySize();
    internal static string get_NotSupported_CaseInsensitiveTypeLookups();
    internal static string get_ProxyCreationFailed();
    internal static string get_StackTrace_GenericMissingBinary();
    internal static string get_StackTrace_InFileLineNumber();
    internal static string get_StackTrace_SpecificMissingBinary();
    internal static string get_Unknown();
    internal static string get_UnsupportedOperation_MissingBinary();
    internal static string get_UnsupportedOperation_MissingUnknownBinary();
    internal static string get_UnsupportedOperation_TaskCtor();
    internal static string get_Word_At();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.DefaultHostUtility : object {
    internal static BindingFlags InstanceBindingFlags;
    private static DefaultHostUtility();
    public static void SetConsoleOutput(VirtualMachine vm, TextWriter output);
    internal static Slot GetAddressOfFirstChar(Slot sString);
    internal static int GetDefaultHashCode(Slot slot);
    internal static Encoding GetHostEncodingFromSlot(VirtualMachine vm, Slot slot);
    internal static string GetResourceString(Assembly assembly, string baseName, string resourceName);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointerOrByRefType(DefaultHost host, Type pointerType);
    public static Slot GetDefaultValueForType(Type type, ISlotFactory factory, IObjectLayout layout);
    internal static bool IsVoidStar(Type type);
    public static void DeepCopyFieldsOfValueType(Slot src, Slot dest);
    private static Slot GetArgumentExceptionHelper(VirtualMachine vm, KnownType type, bool fMessageFirstOrOnly, string paramName, string message);
    public static Slot GetArgumentException(VirtualMachine vm, string message, string paramName);
    public static Slot GetArgumentExceptionFromResource(VirtualMachine vm, string messageResourceName, string paramName);
    public static Slot VThrowArgumentNull(VirtualMachine vm, string paramName);
    public static Slot GetArgumentNullException(VirtualMachine vm, string message, string paramName);
    public static Slot GetArgumentNullExceptionFromResource(VirtualMachine vm, string messageResourceName, string paramName);
    public static Slot GetArgumentOutOfRangeException(VirtualMachine vm, string message, string paramName);
    public static Slot GetArgumentOutOfRangeExceptionFromResource(VirtualMachine vm, string messageResourceName, string paramName);
    public static Slot GetBuiltInSystemExceptionFromResource(VirtualMachine vm, KnownType builtinExceptionType, string resourceName);
    public static Slot GetSlotForCurrentThread(VirtualMachine vm);
    public static void SetSlotForCurrentAppDomain(VirtualMachine vm, Slot appDomainSlot);
    public static void SetSlotForCurrentAppDomain(VirtualMachine vm, Slot sThread, Slot appDomainSlot);
    internal static string GetMscorlibResourceValue(VirtualMachine vm, string resourceName);
    internal static string GetFallbackDefaultCultureName();
    internal static int GetDefaultCultureLCID();
    internal static Slot InvokeDelegate(VirtualMachine vm, Slot sDelegate, Slot[] args);
    private static Slot GetCurrentCulture(VirtualMachine vm);
    private static Slot GetCurrentUICulture(VirtualMachine vm);
    internal static CultureInfo GetCurrentCultureAsHostObject(VirtualMachine vm);
    internal static CultureInfo GetCurrentCultureAsHostObjectWithCache(VirtualMachine vm);
    internal static CultureInfo GetCurrentUICultureAsHostObject(VirtualMachine vm);
    internal static CultureInfo GetCurrentUICultureAsHostObjectWithCache(VirtualMachine vm);
    internal static CultureInfo GetAsCultureInfo(Slot slot, VirtualMachine vm);
    internal static void GetTaskIdFields(IHost host, Type& tTask, FieldInfo& fs_taskIdCounter, FieldInfo& fm_taskId);
    internal static bool CanConvert(Type fromType, Type toType);
    internal static bool CanCastArray(Type fromType, Type toType);
    internal static Slot GetValueToStoreInArray(VirtualMachine vm, Type elementType, Slot sValue, bool boxIn);
    private static Slot GetSlotForList(VirtualMachine vm, IList`1<T> hostList, KnownType reflectionType);
    internal static Slot GetSlotForListOfCustomAttributeData(VirtualMachine vm, IList`1<CustomAttributeData> cad);
    internal static Slot GetSlotForListOfCustomAttributeTypedArgument(VirtualMachine vm, IList`1<CustomAttributeTypedArgument> cata);
    internal static string GetExceptionMessage(VirtualMachine vm, Slot sException);
    internal static string TryGetDefaultStringForException(VirtualMachine vm, Type tException);
    internal static Slot GetExceptionFromHostException(VirtualMachine vm, Exception hostException, string messageOverride);
    internal static string GetRawMessage(ArgumentException argumentException);
    internal static Slot GetTypeLoadException(VirtualMachine vm, string name);
    internal static Slot GetValueTypeSlotFromBytes(ISlotFactory factory, Type type, Byte[] bytes, int arrayOffset, int length);
    internal static void AssignBytesToValueType(Slot sValueType, Byte[] bytes, int arrayOffset, int length);
    internal static bool IsTrue(Slot s);
    internal static Slot GetFieldAddressOfString(DefaultSlot slot, FieldInfo field);
    internal static MethodBody GetMethodBodyNoThrow(MethodBase method);
    public static MetadataFile GetManifestResourceStreamAsMetadataFile(Assembly assembly, string resourceStreamName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DefaultMarshaller : BaseMarshaller {
    private VirtualMachine m_vm;
    internal DefaultMarshaller(VirtualMachine vm);
    internal virtual object GetAsHostObjectWorker(Slot s, Type expectedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.DefaultSlot : Slot {
    [NullableAttribute("2")]
private IObjectLayout m_layout;
    private DefaultHost m_host;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static InfiniteRecursionGuard s_irgGetBytes;
    internal ICollection`1<Slot> ChildSlots { get; }
    private static InfiniteRecursionGuard IrgGetBytes { get; }
    public DefaultHost DefaultHost { get; }
    public IHost Host { get; }
    public DefaultSlotFactory SlotFactory { get; }
    protected bool HasLayoutBeenCreated { get; }
    internal bool IsException { get; }
    [NullableAttribute("2")]
internal ExceptionStackTrace CapturedStackTrace { get; internal set; }
    protected DefaultSlot(IHost host);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual void UpdateCanonicalType(Type type);
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryAutoMarshal(Type expected);
    public virtual void BulkStoreIndirect(Byte[] data, int offset, int length);
    public virtual void BulkCopyArrayElementsTo(DefaultSlot targetArray);
    private static InfiniteRecursionGuard get_IrgGetBytes();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public virtual Slot GetElementAddress(int index);
    public virtual Slot GetElementAddress(Int32[] indices);
    public virtual Slot ConvertToInteger(CorElementType integerType);
    internal Slot DefaultConvert(CorElementType targetType);
    public DefaultHost get_DefaultHost();
    public void AssertValid();
    protected virtual void AssertValidImpl();
    public virtual IHost get_Host();
    public virtual Slot ConvertToPointer(Type pointerType);
    public DefaultSlotFactory get_SlotFactory();
    public virtual IObjectLayout GetObjectLayout();
    public virtual int GetArrayElementSize();
    internal void InternalSetLayout(IObjectLayout layout);
    protected bool get_HasLayoutBeenCreated();
    public virtual int GetDefaultHashCode();
    internal int InternalGetHashCode();
    internal virtual Integer GetAsIntegerValue();
    internal bool get_IsException();
    [NullableContextAttribute("2")]
internal virtual ExceptionStackTrace get_CapturedStackTrace();
    [NullableContextAttribute("2")]
internal virtual void set_CapturedStackTrace(ExceptionStackTrace value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DefaultSlotFactory : object {
    private DefaultHost m_host;
    public ITypeUniverse TypeUniverse { get; }
    public DefaultHost Host { get; }
    private ClrVersionImpl ClrVersion { get; }
    public DefaultSlotFactory(DefaultHost host);
    public sealed virtual ITypeUniverse get_TypeUniverse();
    public DefaultHost get_Host();
    public virtual Slot CreateBox(Slot value);
    public virtual Slot CreateStackAllocatedData(int sizeInBytes, Type type, IVirtualStackFrame frame);
    public virtual Slot CreateHeapObject(Type type);
    public virtual Slot CreateReferenceToValueType(Slot value);
    public virtual Slot CreateArray(Type elementType, Int32[] dims, Int32[] lowerBounds);
    public virtual Slot CreateNullReference(Type type);
    public virtual Slot CreateValueType(Type type);
    public virtual Slot CreateValueTypeCopy(Type type, Slot src);
    protected virtual Slot CreateValueTypeSlot(Type type);
    public virtual Slot GetSlotForEnum(Type enumType, Slot value);
    public virtual Slot GetSlotForHostObject(object value);
    public sealed virtual Slot GetSlotForPrimitive(PrimitiveValue pv);
    public sealed virtual Slot CreateTypedReference(Slot reference, Type type);
    public sealed virtual Slot GetSlotForRuntimeMethodHandle(MethodBase method);
    public sealed virtual Slot GetSlotForRuntimeTypeHandle(Type type, Type handleType);
    public sealed virtual Slot GetSlotForRuntimeFieldHandle(FieldInfo field);
    public sealed virtual Slot GetDefaultValueForType(Type type);
    private ClrVersionImpl get_ClrVersion();
    [ConditionalAttribute("DEBUG")]
private void AssertCorrectUniverse(Type elementType);
    private static Slot CreatePrimitiveArraySlot(DefaultHost host, Type elementType, long length);
    public virtual Slot CreatePointerSlotFromAddress(Type pointerType, ulong addr);
    public Slot CreatePointerSlotFromAddressBytes(Type pointerType, Byte[] buffer);
    public virtual Slot CreateUntypedAddressSlot(BaseAddressSlot slot, ulong address, CorElementType integerType);
}
internal class Ilrun.DelegateFuncEvalException : InterpreterExecutionException {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DelegateSlot : HookedObjectSlot {
    [NullableAttribute("2")]
private Slot m_slotInstance;
    [NullableAttribute("2")]
private MethodBase m_method;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Slot[] m_invocationList;
    internal ICollection`1<Slot> ChildSlots { get; }
    public DelegateSlot(IHost host, Slot slotInstance, MethodBase method, Type type);
    public DelegateSlot(IHost host, Slot slotInstance, Slot func, Type type);
    private DelegateSlot(IHost host, Slot[] invocationList, Type type);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    internal void BindToMethod(Slot sTarget, MethodBase method);
    [NullableContextAttribute("2")]
public virtual MethodBase GetMethodOfDelegate();
    [NullableContextAttribute("2")]
public virtual Slot GetTargetObjectOfDelegate();
    private static Slot[] GetInvocationList(VirtualMachine vm, Slot sDelegate);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    private Slot RemoveImpl(VirtualMachine virtualMachine, CallArgs callArguments);
    private static bool CallEquals(VirtualMachine vm, Slot s1, Slot s2);
    private Slot InvokeImpl(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments);
    private Slot GetInvocationListImpl(VirtualMachine virtualMachine);
    private Slot CombineImpl(CallArgs callArguments);
    public virtual string ToString();
    private static bool IsInvocationListEqual(VirtualMachine vm, Slot s1, Slot s2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DirectExecuteHook : object {
    private bool m_returnRealObject;
    private IObjectMarshaller m_marshaller;
    private DirectExecuteHook(IObjectMarshaller marshaller);
    private DirectExecuteHook(IObjectMarshaller marshaller, bool returnRealObject);
    public static Slot Execute(VirtualMachine vm, MethodBase method, CallArgs args);
    public static Slot Execute(VirtualMachine vm, MethodBase method, CallArgs args, MethodBase hostMethod);
    public static Slot ExecuteWithProxyMarshaler(VirtualMachine vm, MethodBase method, CallArgs args);
    public static Slot ExecuteAndReturnRealObject(VirtualMachine vm, MethodBase method, CallArgs args);
    public static MethodBase FindHostMethod(MethodBase method);
    private Slot ExecuteHelper(VirtualMachine vm, MethodBase method, CallArgs args);
    private Slot ExecuteHostMethod(VirtualMachine vm, MethodBase method, CallArgs args, MethodBase hostMethod);
    private static Slot GetSlotForHostException(VirtualMachine vm, Exception hostException);
    private bool NeedCurrentCulture(VirtualMachine vm, MethodBase method, CallArgs args);
    private Slot GetSlotForHostObject(VirtualMachine vm, CallArgs args, Object[] hostArgs, object oThis, object oResult);
    private object ConvertToHostObject(VirtualMachine vm, Slot s, Type expected);
    internal static Type ConvertToHostType(Type type);
    internal static Type TryConvertToHostType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DirectExecuteMarshaller : HostMarshalerBase {
    private bool m_fProxy;
    private VirtualMachine m_vm;
    internal DirectExecuteMarshaller(bool fProxy, VirtualMachine vm);
    protected virtual object MarshalEnumSlot(Slot slot);
    protected virtual object MarshalComplexObjectSlot(Slot slot);
    private object MarshalProxiedObject(Slot slot);
    protected virtual object MarshalTypeSlot(Slot typeSlot);
}
[FlagsAttribute]
internal enum Ilrun.DisassemblerFlags : Enum {
    public int value__;
    public static DisassemblerFlags None;
    public static DisassemblerFlags ResolveTokens;
    public static DisassemblerFlags SubstituteGenericArgs;
    public static DisassemblerFlags IncludeCodeBytes;
    public static DisassemblerFlags IncludeHeader;
    public static DisassemblerFlags All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.DisassemblyLine : object {
    public DisassemblyLineType Type;
    public DisassemblyLineFlags Flags;
    public int Offset;
    public string Opcode;
    public string Operand;
    public string Annotation;
    public Token MetadataToken;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ResolvedOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <CodeBytes>k__BackingField;
    [NullableAttribute("2")]
public string ResolvedOperand { get; internal set; }
    public int Length { get; internal set; }
    [NullableAttribute("2")]
public Byte[] CodeBytes { get; internal set; }
    private DisassemblyLine(DisassemblyLineType type, DisassemblyLineFlags flags, int offset, string opcode, string operand, string annotation, Token metadataToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ResolvedOperand();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ResolvedOperand(string value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_CodeBytes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_CodeBytes(Byte[] value);
    public static DisassemblyLine Create(int offset, ILOpCode ilOpCode, object operand);
    public static DisassemblyLine CreateInvalidOpcodeFormat(int offset);
    public static DisassemblyLine CreateWithOffsetOperand(int offset, ILOpCode ilOpCode, int offsetOperand);
    public static DisassemblyLine CreateWithTokenOperand(int offset, ILOpCode ilOpCode, Token token);
    public static DisassemblyLine CreateExtraLine(int offset, string operand);
    public static DisassemblyLine CreateAnnotationOnly(int offset, string text);
}
[FlagsAttribute]
internal enum Ilrun.DisassemblyLineFlags : Enum {
    public int value__;
    public static DisassemblyLineFlags None;
    public static DisassemblyLineFlags HasToken;
}
internal enum Ilrun.DisassemblyLineType : Enum {
    public int value__;
    public static DisassemblyLineType NonCode;
    public static DisassemblyLineType Code;
    public static DisassemblyLineType CodeAdditionalLine;
}
[FlagsAttribute]
internal enum Ilrun.DumpFrameFlags : Enum {
    public int value__;
    public static DumpFrameFlags None;
    public static DumpFrameFlags IncludeIpMarkers;
    public static DumpFrameFlags IncludeFrameArgs;
    public static DumpFrameFlags IncludeFrameLocals;
    public static DumpFrameFlags IncludeCodeBytes;
    public static DumpFrameFlags ResolveTokens;
    public static DumpFrameFlags DecodedAssembly;
    public static DumpFrameFlags ReturnAsString;
    public static DumpFrameFlags ExpandExceptionRegions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.EETypeSlot : DefaultSlot {
    private Type m_type;
    private Type m_containerType;
    public EETypeSlot(Type type, Type containerType, IHost host);
    public virtual Type GetTypeX();
    public virtual string ToString();
    public Type GetContainerType();
}
public class Ilrun.EmulatingCallEventHandler : MulticastDelegate {
    public EmulatingCallEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, int ilOffsetOfCall, string moduleName, string typeName, string methodName);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, int ilOffsetOfCall, string moduleName, string typeName, string methodName, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.EmulatorExceptionEventHandler : MulticastDelegate {
    public EmulatorExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, string message, int frameCount);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, string message, int frameCount, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.EmulatorFrameDumpEventHandler : MulticastDelegate {
    public EmulatorFrameDumpEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, int frameNum, int ilOffset, string textLines);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, int frameNum, int ilOffset, string textLines, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.EndEvaluationEventHandler : MulticastDelegate {
    public EndEvaluationEventHandler(object object, IntPtr method);
    public virtual void Invoke(int sequenceNum, bool succeeded);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, bool succeeded, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Ilrun.EndRealFuncEvalEventHandler : MulticastDelegate {
    public EndRealFuncEvalEventHandler(object object, IntPtr method);
    public virtual void Invoke(int sequenceNum, int ilOffsetOfCall);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, int ilOffsetOfCall, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.EnumSlot : DefaultSlot {
    private Slot m_value;
    private Type m_typeEnum;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal EnumSlot(Slot value, Type typeEnum);
    public virtual Type GetTypeX();
    public virtual string ToString();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual Slot GetField(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.EqualityProvider : object {
    private DefaultHost m_host;
    private SlotEqualityWrapper m_s1;
    private SlotEqualityWrapper m_s2;
    private Nullable`1<bool> m_result;
    private bool ShouldTryReflectionDecoding { get; }
    public EqualityProvider(DefaultHost host, Slot s1, Slot s2);
    public bool GetResult();
    private bool AreSlotsEqual();
    private bool get_ShouldTryReflectionDecoding();
}
internal class Ilrun.ExceptionAction : MulticastDelegate {
    public ExceptionAction(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.ExceptionStackFrame : object {
    private MethodBase m_method;
    private int m_ilOffset;
    private bool m_fLastFrameFromForeignException;
    private ulong m_nativeIP;
    private string m_missingModuleName;
    internal MethodBase Method { get; }
    internal int ILOffset { get; }
    internal ulong NativeIP { get; }
    internal bool IsLastFrameFromForeignException { get; }
    internal string MissingModuleName { get; }
    internal ExceptionStackFrame(MethodBase method, int ilOffset, bool fLastFrameFromForeignException, ulong nativeIP, string missingModuleName);
    internal MethodBase get_Method();
    internal int get_ILOffset();
    internal ulong get_NativeIP();
    internal bool get_IsLastFrameFromForeignException();
    internal string get_MissingModuleName();
    [NullableContextAttribute("1")]
private string DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ExceptionStackTrace : object {
    private List`1<ExceptionStackFrame> m_stackTrace;
    [NullableAttribute("2")]
private string m_cachedStackTraceString;
    [NullableAttribute("2")]
public string CachedStackTraceString { get; }
    public ExceptionStackFrame TopFrame { get; }
    public ExceptionStackTrace(VirtualMachine virtualMachine);
    public ExceptionStackTrace(ExceptionStackFrame[] frames);
    internal void EnsureStringCalculated(DefaultHost host);
    public ExceptionStackFrame[] GetFrames();
    [NullableContextAttribute("2")]
public string get_CachedStackTraceString();
    public ExceptionStackFrame get_TopFrame();
    public void RemoveFrames(int numFramesToRemove);
}
internal class Ilrun.ExceptionStackTraceNotSupportedException : InterpreterExecutionException {
    [NullableContextAttribute("1")]
private ExceptionStackTraceNotSupportedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ExecutionContextSlot : HookedObjectSlot {
    public ExecutionContextSlot(IHost host);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
public class Ilrun.ExpressionEvaluatorErrorEventHandler : MulticastDelegate {
    public ExpressionEvaluatorErrorEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, string message);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Ilrun.FastExecuteDisabledReason : Enum {
    public int value__;
    public static FastExecuteDisabledReason None;
    public static FastExecuteDisabledReason DecodeException;
    public static FastExecuteDisabledReason IlLength;
    public static FastExecuteDisabledReason ExceptionClauses;
    public static FastExecuteDisabledReason MaxStackHeightExceeded;
    public static FastExecuteDisabledReason BackwardBranchEncountered;
    public static FastExecuteDisabledReason ExecutionException;
}
internal class Ilrun.FastExecuteExceededException : InterpreterExecutionException {
    [CompilerGeneratedAttribute]
private FastExecuteDisabledReason <Reason>k__BackingField;
    public FastExecuteDisabledReason Reason { get; }
    public FastExecuteExceededException(FastExecuteDisabledReason reason);
    [CompilerGeneratedAttribute]
public FastExecuteDisabledReason get_Reason();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FieldAccessOfHookedObjectSlotException : InterpreterExecutionException {
    private HookedObjectSlot m_slot;
    private FieldInfo m_field;
    public Slot Slot { get; }
    public FieldInfo Field { get; }
    [DebuggerStepThroughAttribute]
internal FieldAccessOfHookedObjectSlotException(HookedObjectSlot slot, FieldInfo field);
    public Slot get_Slot();
    public FieldInfo get_Field();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FieldAddressSlot : BaseAddressSlot {
    private Slot m_owner;
    private FieldInfo m_field;
    [NullableAttribute("2")]
private VirtualAddress m_fieldAddress;
    internal ICollection`1<Slot> ChildSlots { get; }
    public FieldAddressSlot(Slot owner, FieldInfo field);
    public FieldAddressSlot(Slot owner, FieldInfo field, VirtualAddress fieldAddress);
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual string ToString();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot LoadIndirect();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot PointerAdd(int offset);
    [NullableContextAttribute("2")]
public FieldAddressSlot TryPointerAdd(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FieldKeyComparer : object {
    public static FieldKeyComparer Instance;
    private static FieldKeyComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FieldInfo this, FieldInfo other);
    public sealed virtual int GetHashCode(FieldInfo this);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FieldSlot : HookedObjectSlot {
    private FieldInfo m_field;
    internal FieldSlot(IHost host, FieldInfo field, Type typeOfField);
    public virtual FieldInfo GetFieldWorker();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual string ToString();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
internal static class Ilrun.FlowAnalysisUtilities : object {
    [NullableContextAttribute("1")]
public static BasicBlock FindContainingBlock(BasicBlock[] blocks, int instructionIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FlowNetwork : object {
    public DecodedMethod Method;
    private InstructionInfo[] m_instructionInfos;
    private FlowNetworkBlock[] m_blocks;
    private FlowNetwork(DecodedMethod method, BasicBlock[] basicBlocks);
    public static FlowNetwork Create(DecodedMethod method);
    public DataPath GetSingleInputPath(int instructionIndex);
    public IEnumerable`1<DataPath> GetChildSingleInputPaths(DataPathNode startingNode);
    public IEnumerable`1<DataPath> GetForwardDataPaths(int instructionIndex);
    private DataPath GetSingleInputPath(DataPathNode position);
    private DataPathNode GetDataPathNode(int instructionIndex);
    private DataPathNode GetDataPathNodeFromDataSource(FlowNetworkBlock block, DataSource source);
    private DataPathNode GetDataPathNodeForBasicBlockInput(FlowNetworkBlock block, int blockInputIndex);
    private IList`1<DataSource> GetInstructionDataSources(int instructionIndex);
    private FlowNetworkBlock FindContainingBlock(int instructionIndex);
    private void EnsureInitialized(FlowNetworkBlock block);
}
internal class Ilrun.FormattableProxyObject : ProxyBase {
    [NullableContextAttribute("1")]
public FormattableProxyObject(VirtualMachine vm, Slot s);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.Frame : BaseFrame {
    private FrameVariableContainer m_varContainer;
    public Frame(VirtualMachine vm, MethodBase method);
    [NullableContextAttribute("2")]
public virtual void InitForInterpretation(CallArgs args);
    public virtual Type GetArgType(int index);
    public virtual Type GetLocalType(int index);
    public virtual Slot GetArgument(int index);
    public virtual void SetArgument(int index, Slot value);
    public virtual Slot GetArgumentAddress(int index);
    public virtual Slot GetLocalVariable(int index);
    public virtual void SetLocalVariable(int index, Slot value);
    public virtual Slot GetLocalVariableAddress(int index);
    public virtual VirtualAddress GetVAForLocal(int localIdx);
    public virtual VirtualAddress GetVAForArg(int argIdx);
    protected virtual int GetLocalCount();
    protected virtual string FormatLocal(int index);
    protected virtual string FormatArg(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.FrameVariableContainer : object {
    public VirtualMachine VM;
    public MethodBase Method;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private VirtualAddress[] m_localVAs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private VirtualAddress[] m_argVAs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LocalVariableInfo[] m_localInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Slot[] m_locals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Slot[] m_args;
    public FrameVariableContainer(VirtualMachine vm, MethodBase method);
    [NullableContextAttribute("2")]
public void Initialize(CallArgs args);
    public int GetLocalCount();
    public Slot GetArg(int argIdx);
    public void SetArg(int argIdx, Slot value);
    public Type GetArgType(int argIdx);
    public Type GetLocalType(int idx);
    public Slot GetLocal(int localIndex);
    public void SetLocal(int localIdx, Slot value);
    public VirtualAddress GetVAForLocal(int localIdx);
    public VirtualAddress GetVAForArg(int argIdx);
    [NullableContextAttribute("2")]
public Slot[] GetRawLocals();
    public string FormatLocal(int index);
    public string FormatArg(int index);
    private VirtualAddress CreateVAForLocal(int i);
    private VirtualAddress CreateVAForArg(int i);
}
internal class Ilrun.FuncEvalDisabledException : InterpreterExecutionException {
    [NullableContextAttribute("1")]
public FuncEvalDisabledException(string reason);
}
internal class Ilrun.FuncEvalException : InterpreterExecutionException {
    internal int HResult { get; }
    public FuncEvalException(HResult hr);
    internal int get_HResult();
}
internal class Ilrun.FunctionCallNotSupportedException : InterpreterExecutionException {
    [NullableContextAttribute("1")]
private FunctionCallNotSupportedException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.GCHandleSlot : HookedObjectSlot {
    private Slot m_value;
    public GCHandleSlot(Slot value, IHost host, Type type);
    internal static Slot __cctor(VirtualMachine vm, MethodBase method, CallArgs args);
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.GenericHelper : object {
    internal static Type GetRawType(Type type);
    internal static Type InstantiateGenericTypeArguments(Type instantiatedType, Type toInstantiate);
    internal static bool IsInstantiatedGenericType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.GenericInstantiation : ValueType {
    private CachedTypeDef m_typeDefinition;
    private Type[] m_typeArguments;
    public CachedTypeDef TypeDefinition { get; }
    public Type[] TypeParameters { get; }
    public GenericInstantiation(CachedTypeDef typeDefinition, Type[] typeArguments);
    public CachedTypeDef get_TypeDefinition();
    public Type[] get_TypeParameters();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GenericInstantiation other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HookedFrame : object {
    private MethodBase m_method;
    private IVirtualStackFrame m_caller;
    public MethodBase Method { get; }
    public bool IsInterpreted { get; }
    public int IP { get; public set; }
    public HookedFrame(MethodBase method, IVirtualStackFrame caller);
    public sealed virtual MethodBase get_Method();
    public sealed virtual bool get_IsInterpreted();
    public sealed virtual int get_IP();
    public sealed virtual void set_IP(int value);
    public virtual string ToString();
    public sealed virtual bool CanFuncEvalFromFrame();
    public sealed virtual void ClearILStack();
    public sealed virtual void Dispose();
    public sealed virtual void DumpVariableInfo(DumpFrameFlags flags, List`1<string> textLines);
    public sealed virtual Type GetArgType(int index);
    public sealed virtual Slot GetArgument(int index);
    public sealed virtual Slot GetArgumentAddress(int index);
    public sealed virtual Type GetLocalType(int index);
    public sealed virtual Slot GetLocalVariable(int index);
    public sealed virtual Slot GetLocalVariableAddress(int index);
    public sealed virtual VirtualAddress GetVAForArg(int index);
    public sealed virtual VirtualAddress GetVAForLocal(int index);
    [NullableContextAttribute("2")]
public sealed virtual void InitForInterpretation(CallArgs args);
    public sealed virtual void OnBeforeFuncEval();
    public sealed virtual Slot Pop();
    public sealed virtual Slot Push(Slot value);
    public sealed virtual void SetArgument(int index, Slot value);
    public sealed virtual void SetLocalVariable(int index, Slot value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Hooks for: {FormattedName}")]
internal class Ilrun.HookedMethod : object {
    public MethodBase OriginalMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<MethodHookDelegate> <HookDelegates>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodBase <IlHookMethod>k__BackingField;
    public string FormattedName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<MethodHookDelegate> HookDelegates { get; }
    [NullableAttribute("2")]
public MethodBase IlHookMethod { get; }
    public HookedMethod(MethodBase originalMethod, List`1<MethodHookDelegate> hookDelegates, MethodBase ilHookMethod);
    [CompilerGeneratedAttribute]
public List`1<MethodHookDelegate> get_HookDelegates();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodBase get_IlHookMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HookedObjectSlot : DefaultSlot {
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    public HookedObjectSlot(IHost host, Type type);
    public sealed virtual Type GetTypeX();
    public virtual string ToString();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public sealed virtual bool IsNull();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    protected Slot ThrowMethodNotHooked(MethodBase method);
    public virtual Slot GetField(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.HookKey : object {
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <ParameterTypesForOverloadsToHook>k__BackingField;
    internal string ClassName { get; internal set; }
    internal string MethodName { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] ParameterTypesForOverloadsToHook { get; internal set; }
    internal HookKey(string className, string methodName);
    internal HookKey(MethodBase method);
    internal HookKey(MethodBase method, bool fSpecifyOverload);
    private string DebuggerDisplay();
    private string GetOverloadString();
    [CompilerGeneratedAttribute]
internal string get_ClassName();
    [CompilerGeneratedAttribute]
internal void set_ClassName(string value);
    [CompilerGeneratedAttribute]
internal string get_MethodName();
    [CompilerGeneratedAttribute]
internal void set_MethodName(string value);
    [CompilerGeneratedAttribute]
internal String[] get_ParameterTypesForOverloadsToHook();
    [CompilerGeneratedAttribute]
internal void set_ParameterTypesForOverloadsToHook(String[] value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool AreArraysEqual(T[] a1, T[] a2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HookManager`1 : object {
    private Dictionary`2<HookKey, T> m_methodNameWithSignatureHooks;
    private Dictionary`2<HookKey, T> m_methodNameHooks;
    private Dictionary`2<HookKey, T> m_anyMethodHooks;
    public T TryGetHook(MethodBase method);
    public void AddHook(IEnumerable`1<string> classNames, string methodName, T hook, String[] signature);
    public void AddHook(string className, string methodName, T hook);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.HooksInitialization.HookMethodInfoWrapper : object {
    protected TypeWrapper m_hookImplDeclaringType;
    protected MethodHookAttribute m_methodHookAttribute;
    [NullableAttribute("2")]
protected SupportedRuntimesAttribute m_supportedRuntimesAttribute;
    [NullableAttribute("2")]
protected UnsupportedRuntimesAttribute m_unsupportedRuntimesAttribute;
    public bool HookOnlyIfNativeMethod { get; }
    public string HookTargetMethodName { get; }
    protected string HookImplementationMethodName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] HookTargetSignature { get; }
    protected HookMethodInfoWrapper(TypeWrapper hookImplDeclaringType, MethodHookAttribute methodHookAttribute, SupportedRuntimesAttribute supportedRuntimesAttribute, UnsupportedRuntimesAttribute unsupportedRuntimesAttribute);
    public bool SupportsRuntime(ClrVersion target);
    public bool get_HookOnlyIfNativeMethod();
    public string get_HookTargetMethodName();
    protected abstract virtual string get_HookImplementationMethodName();
    public IEnumerable`1<string> GetHookTargetClassNames();
    public virtual String[] get_HookTargetSignature();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HooksInitialization.LmrMethodInfoWrapper : HookMethodInfoWrapper {
    private MethodInfo m_method;
    private bool m_isExtensionMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private String[] m_hookTargetSignature;
    protected string HookImplementationMethodName { get; }
    public String[] HookTargetSignature { get; }
    public MethodInfo LmrMethod { get; }
    public LmrMethodInfoWrapper(TypeWrapper hookImplDeclaringType, MethodInfo lmrMethodInfo, bool isExtensionMethod, MethodHookAttribute methodHookAttribute, SupportedRuntimesAttribute supportedRuntimesAttribute, UnsupportedRuntimesAttribute unsupportedRuntimesAttribute);
    protected virtual string get_HookImplementationMethodName();
    public virtual String[] get_HookTargetSignature();
    public MethodInfo get_LmrMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HooksInitialization.LmrTypeWrapper : TypeWrapper {
    private Type m_lmrType;
    [NullableAttribute("2")]
private MethodHookDeclaringTypeAttribute m_methodHookDeclaringTypeAttribute;
    protected string TypeName { get; }
    public LmrTypeWrapper(Type lmrType);
    protected virtual string get_TypeName();
    [NullableContextAttribute("2")]
protected virtual MethodHookDeclaringTypeAttribute GetMethodHookDeclaringTypeAttribute();
    private static bool IsAttributeArgsEmptyStringArray(CustomAttributeData attributeData);
    private static ClrVersion[] GetClrVersionsForRuntimesConstraintAttribute(CustomAttributeData attributeData);
    private static void ForEachCustomAttribute(MethodInfo method, AttributeAction`1<T1> c1, AttributeAction`1<T2> c2, AttributeAction`1<T3> c3, AttributeAction`1<T4> c4);
    public virtual IEnumerable`1<HookMethodInfoWrapper> GetDeclaredHooks(BindingFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HooksInitialization.SystemReflectionMethodInfoWrapper : HookMethodInfoWrapper {
    private MethodInfo m_method;
    protected string HookImplementationMethodName { get; }
    public SystemReflectionMethodInfoWrapper(TypeWrapper hookImplDeclaringType, MethodInfo method, MethodHookAttribute methodHookAttribute, SupportedRuntimesAttribute supportedRuntimesAttribute, UnsupportedRuntimesAttribute unsupportedRuntimesAttribute);
    protected virtual string get_HookImplementationMethodName();
    public MethodHookDelegate GetMethodHookDelegate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HooksInitialization.SystemTypeWrapper : TypeWrapper {
    private Type m_type;
    private MethodHookDeclaringTypeAttribute m_methodHookDeclaringTypeAttribute;
    protected string TypeName { get; }
    public SystemTypeWrapper(Type type);
    [NullableContextAttribute("2")]
protected virtual MethodHookDeclaringTypeAttribute GetMethodHookDeclaringTypeAttribute();
    protected virtual string get_TypeName();
    public virtual IEnumerable`1<HookMethodInfoWrapper> GetDeclaredHooks(BindingFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.HooksInitialization.TypeWrapper : object {
    protected string TypeName { get; }
    public bool HasMethodHookDeclaringTypeAttribute();
    public IEnumerable`1<string> GetHookTargetClassNames();
    [NullableContextAttribute("2")]
protected abstract virtual MethodHookDeclaringTypeAttribute GetMethodHookDeclaringTypeAttribute();
    protected abstract virtual string get_TypeName();
    public abstract virtual IEnumerable`1<HookMethodInfoWrapper> GetDeclaredHooks(BindingFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.HooksInitialization.Utils : object {
    private static string StripModifiers(string argTypeName);
    private static bool IsSupportedRuntime(ClrVersion runtimeToTest, ClrVersion supportedRuntime);
    [NullableContextAttribute("2")]
internal static bool IsHookSupported(ClrVersion targetRuntime, ClrVersion[] supportedRuntimes, ClrVersion[] unsupportedRuntimes);
    internal static HookManager`1<MethodHookDelegate> GetHooks(ClrVersion targetRuntime);
    internal static HookManager`1<MethodBase> GetIlHooks(ClrVersion targetRuntime, Assembly ilHooksAssembly);
    private static void ForEachMethodHook(ClrVersion targetRuntime, TypeWrapper type, ForEachMethodHookCallback callback);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Ilrun.HostMarshalerBase : SlotMarshaler`1<object> {
    protected bool IsTypeSupportedInHost(Type type, bool fTypeOnly);
    protected virtual bool IsTypeSupportedInHostWorker(Type type, bool fTypeOnly);
    protected virtual Type GetHostTypeForTypeX(Type type, bool fTypeOnly);
    protected virtual object CreateUninitializedArray(Type elementType, Int32[] dimensions, Int32[] lowerBounds);
    protected virtual void MarshalArrayElements(object emptyArray, Slot sourceArraySlot);
    protected virtual object CreateUninitializedComplexObject(Type objectType);
    [NullableContextAttribute("2")]
protected virtual void MarshalComplexObjectData(object hostObject, IDictionary`2<FieldInfo, object> fieldValues);
    protected virtual object MarshalStringSlot(Slot slot);
    protected virtual object MarshalPrimitiveSlot(Slot slot);
    protected virtual object MarshalNullSlot(Slot slot);
    protected virtual object MarshalEnumSlot(Slot slot);
    protected virtual object MarshalTypeSlot(Slot typeSlot);
    protected virtual object MarshalAssemblySlot(Slot assemblySlot);
    protected virtual object MarshalDecimalSlot(Slot slot);
}
internal enum Ilrun.HResult : Enum {
    public int value__;
    public static HResult HR_E_PARTIAL_COPY;
    public static HResult HR_E_ERROR_NOACCESS;
    public static HResult HR_E_ERROR_FILE_NOT_FOUND;
    public static HResult E_UNEXPECTED;
    public static HResult E_NOTIMPL;
    public static HResult E_OUTOFMEMORY;
    public static HResult E_INVALIDARG;
    public static HResult E_NOINTERFACE;
    public static HResult E_POINTER;
    public static HResult E_HANDLE;
    public static HResult E_ABORT;
    public static HResult E_FAIL;
    public static HResult E_ACCESSDENIED;
    public static HResult E_PENDING;
    public static HResult CO_E_INIT_TLS;
    public static HResult CO_E_INIT_SHARED_ALLOCATOR;
    public static HResult CO_E_INIT_MEMORY_ALLOCATOR;
    public static HResult CO_E_INIT_CLASS_CACHE;
    public static HResult CO_E_INIT_RPC_CHANNEL;
    public static HResult CO_E_INIT_TLS_SET_CHANNEL_CONTROL;
    public static HResult CO_E_INIT_TLS_CHANNEL_CONTROL;
    public static HResult CO_E_INIT_UNACCEPTED_USER_ALLOCATOR;
    public static HResult CO_E_INIT_SCM_MUTEX_EXISTS;
    public static HResult CO_E_INIT_SCM_FILE_MAPPING_EXISTS;
    public static HResult CO_E_INIT_SCM_MAP_VIEW_OF_FILE;
    public static HResult CO_E_INIT_SCM_EXEC_FAILURE;
    public static HResult CO_E_INIT_ONLY_SINGLE_THREADED;
    public static HResult CO_E_CANT_REMOTE;
    public static HResult CO_E_BAD_SERVER_NAME;
    public static HResult CO_E_WRONG_SERVER_IDENTITY;
    public static HResult CO_E_OLE1DDE_DISABLED;
    public static HResult CO_E_RUNAS_SYNTAX;
    public static HResult CO_E_CREATEPROCESS_FAILURE;
    public static HResult CO_E_RUNAS_CREATEPROCESS_FAILURE;
    public static HResult CO_E_RUNAS_LOGON_FAILURE;
    public static HResult CO_E_LAUNCH_PERMSSION_DENIED;
    public static HResult CO_E_START_SERVICE_FAILURE;
    public static HResult CO_E_REMOTE_COMMUNICATION_FAILURE;
    public static HResult CO_E_SERVER_START_TIMEOUT;
    public static HResult CO_E_CLSREG_INCONSISTENT;
    public static HResult CO_E_IIDREG_INCONSISTENT;
    public static HResult CO_E_NOT_SUPPORTED;
    public static HResult CO_E_RELOAD_DLL;
    public static HResult CO_E_MSI_ERROR;
    public static HResult CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT;
    public static HResult CO_E_SERVER_PAUSED;
    public static HResult CO_E_SERVER_NOT_PAUSED;
    public static HResult CO_E_CLASS_DISABLED;
    public static HResult CO_E_CLRNOTAVAILABLE;
    public static HResult CO_E_ASYNC_WORK_REJECTED;
    public static HResult CO_E_SERVER_INIT_TIMEOUT;
    public static HResult CO_E_NO_SECCTX_IN_ACTIVATE;
    public static HResult CO_E_TRACKER_CONFIG;
    public static HResult CO_E_THREADPOOL_CONFIG;
    public static HResult CO_E_SXS_CONFIG;
    public static HResult CO_E_MALFORMED_SPN;
    public static HResult S_OK;
    public static HResult S_FALSE;
    public static HResult OLE_E_FIRST;
    public static HResult OLE_E_LAST;
    public static HResult OLE_S_FIRST;
    public static HResult OLE_S_LAST;
    public static HResult OLE_E_OLEVERB;
    public static HResult OLE_E_ADVF;
    public static HResult OLE_E_ENUM_NOMORE;
    public static HResult OLE_E_ADVISENOTSUPPORTED;
    public static HResult OLE_E_NOCONNECTION;
    public static HResult OLE_E_NOTRUNNING;
    public static HResult OLE_E_NOCACHE;
    public static HResult OLE_E_BLANK;
    public static HResult OLE_E_CLASSDIFF;
    public static HResult OLE_E_CANT_GETMONIKER;
    public static HResult OLE_E_CANT_BINDTOSOURCE;
    public static HResult OLE_E_STATIC;
    public static HResult OLE_E_PROMPTSAVECANCELLED;
    public static HResult OLE_E_INVALIDRECT;
    public static HResult OLE_E_WRONGCOMPOBJ;
    public static HResult OLE_E_INVALIDHWND;
    public static HResult OLE_E_NOT_INPLACEACTIVE;
    public static HResult OLE_E_CANTCONVERT;
    public static HResult OLE_E_NOSTORAGE;
    public static HResult DV_E_FORMATETC;
    public static HResult DV_E_DVTARGETDEVICE;
    public static HResult DV_E_STGMEDIUM;
    public static HResult DV_E_STATDATA;
    public static HResult DV_E_LINDEX;
    public static HResult DV_E_TYMED;
    public static HResult DV_E_CLIPFORMAT;
    public static HResult DV_E_DVASPECT;
    public static HResult DV_E_DVTARGETDEVICE_SIZE;
    public static HResult DV_E_NOIVIEWOBJECT;
    public static HResult DRAGDROP_E_FIRST;
    public static HResult DRAGDROP_E_LAST;
    public static HResult DRAGDROP_S_FIRST;
    public static HResult DRAGDROP_S_LAST;
    public static HResult DRAGDROP_E_NOTREGISTERED;
    public static HResult DRAGDROP_E_ALREADYREGISTERED;
    public static HResult DRAGDROP_E_INVALIDHWND;
    public static HResult CLASSFACTORY_E_FIRST;
    public static HResult CLASSFACTORY_E_LAST;
    public static HResult CLASSFACTORY_S_FIRST;
    public static HResult CLASSFACTORY_S_LAST;
    public static HResult CLASS_E_NOAGGREGATION;
    public static HResult CLASS_E_CLASSNOTAVAILABLE;
    public static HResult CLASS_E_NOTLICENSED;
    public static HResult MARSHAL_E_FIRST;
    public static HResult MARSHAL_E_LAST;
    public static HResult MARSHAL_S_FIRST;
    public static HResult MARSHAL_S_LAST;
    public static HResult DATA_E_FIRST;
    public static HResult DATA_E_LAST;
    public static HResult DATA_S_FIRST;
    public static HResult DATA_S_LAST;
    public static HResult VIEW_E_FIRST;
    public static HResult VIEW_E_LAST;
    public static HResult VIEW_S_FIRST;
    public static HResult VIEW_S_LAST;
    public static HResult VIEW_E_DRAW;
    public static HResult REGDB_E_FIRST;
    public static HResult REGDB_E_LAST;
    public static HResult REGDB_S_FIRST;
    public static HResult REGDB_S_LAST;
    public static HResult REGDB_E_READREGDB;
    public static HResult REGDB_E_WRITEREGDB;
    public static HResult REGDB_E_KEYMISSING;
    public static HResult REGDB_E_INVALIDVALUE;
    public static HResult REGDB_E_CLASSNOTREG;
    public static HResult REGDB_E_IIDNOTREG;
    public static HResult REGDB_E_BADTHREADINGMODEL;
    public static HResult CAT_E_FIRST;
    public static HResult CAT_E_LAST;
    public static HResult CAT_E_CATIDNOEXIST;
    public static HResult CAT_E_NODESCRIPTION;
    public static HResult CS_E_FIRST;
    public static HResult CS_E_LAST;
    public static HResult CS_E_PACKAGE_NOTFOUND;
    public static HResult CS_E_NOT_DELETABLE;
    public static HResult CS_E_CLASS_NOTFOUND;
    public static HResult CS_E_INVALID_VERSION;
    public static HResult CS_E_NO_CLASSSTORE;
    public static HResult CS_E_OBJECT_NOTFOUND;
    public static HResult CS_E_OBJECT_ALREADY_EXISTS;
    public static HResult CS_E_INVALID_PATH;
    public static HResult CS_E_NETWORK_ERROR;
    public static HResult CS_E_ADMIN_LIMIT_EXCEEDED;
    public static HResult CS_E_SCHEMA_MISMATCH;
    public static HResult CS_E_INTERNAL_ERROR;
    public static HResult CACHE_E_FIRST;
    public static HResult CACHE_E_LAST;
    public static HResult CACHE_S_FIRST;
    public static HResult CACHE_S_LAST;
    public static HResult CACHE_E_NOCACHE_UPDATED;
    public static HResult OLEOBJ_E_FIRST;
    public static HResult OLEOBJ_E_LAST;
    public static HResult OLEOBJ_S_FIRST;
    public static HResult OLEOBJ_S_LAST;
    public static HResult OLEOBJ_E_NOVERBS;
    public static HResult OLEOBJ_E_INVALIDVERB;
    public static HResult CLIENTSITE_E_FIRST;
    public static HResult CLIENTSITE_E_LAST;
    public static HResult CLIENTSITE_S_FIRST;
    public static HResult CLIENTSITE_S_LAST;
    public static HResult INPLACE_E_NOTUNDOABLE;
    public static HResult INPLACE_E_NOTOOLSPACE;
    public static HResult INPLACE_E_FIRST;
    public static HResult INPLACE_E_LAST;
    public static HResult INPLACE_S_FIRST;
    public static HResult INPLACE_S_LAST;
    public static HResult ENUM_E_FIRST;
    public static HResult ENUM_E_LAST;
    public static HResult ENUM_S_FIRST;
    public static HResult ENUM_S_LAST;
    public static HResult CONVERT10_E_FIRST;
    public static HResult CONVERT10_E_LAST;
    public static HResult CONVERT10_S_FIRST;
    public static HResult CONVERT10_S_LAST;
    public static HResult CONVERT10_E_OLESTREAM_GET;
    public static HResult CONVERT10_E_OLESTREAM_PUT;
    public static HResult CONVERT10_E_OLESTREAM_FMT;
    public static HResult CONVERT10_E_OLESTREAM_BITMAP_TO_DIB;
    public static HResult CONVERT10_E_STG_FMT;
    public static HResult CONVERT10_E_STG_NO_STD_STREAM;
    public static HResult CONVERT10_E_STG_DIB_TO_BITMAP;
    public static HResult CLIPBRD_E_FIRST;
    public static HResult CLIPBRD_E_LAST;
    public static HResult CLIPBRD_S_FIRST;
    public static HResult CLIPBRD_S_LAST;
    public static HResult CLIPBRD_E_CANT_OPEN;
    public static HResult CLIPBRD_E_CANT_EMPTY;
    public static HResult CLIPBRD_E_CANT_SET;
    public static HResult CLIPBRD_E_BAD_DATA;
    public static HResult CLIPBRD_E_CANT_CLOSE;
    public static HResult MK_E_FIRST;
    public static HResult MK_E_LAST;
    public static HResult MK_S_FIRST;
    public static HResult MK_S_LAST;
    public static HResult MK_E_CONNECTMANUALLY;
    public static HResult MK_E_EXCEEDEDDEADLINE;
    public static HResult MK_E_NEEDGENERIC;
    public static HResult MK_E_UNAVAILABLE;
    public static HResult MK_E_SYNTAX;
    public static HResult MK_E_NOOBJECT;
    public static HResult MK_E_INVALIDEXTENSION;
    public static HResult MK_E_INTERMEDIATEINTERFACENOTSUPPORTED;
    public static HResult MK_E_NOTBINDABLE;
    public static HResult MK_E_NOTBOUND;
    public static HResult MK_E_CANTOPENFILE;
    public static HResult MK_E_MUSTBOTHERUSER;
    public static HResult MK_E_NOINVERSE;
    public static HResult MK_E_NOSTORAGE;
    public static HResult MK_E_NOPREFIX;
    public static HResult MK_E_ENUMERATION_FAILED;
    public static HResult CO_E_FIRST;
    public static HResult CO_E_LAST;
    public static HResult CO_S_FIRST;
    public static HResult CO_S_LAST;
    public static HResult CO_E_NOTINITIALIZED;
    public static HResult CO_E_ALREADYINITIALIZED;
    public static HResult CO_E_CANTDETERMINECLASS;
    public static HResult CO_E_CLASSSTRING;
    public static HResult CO_E_IIDSTRING;
    public static HResult CO_E_APPNOTFOUND;
    public static HResult CO_E_APPSINGLEUSE;
    public static HResult CO_E_ERRORINAPP;
    public static HResult CO_E_DLLNOTFOUND;
    public static HResult CO_E_ERRORINDLL;
    public static HResult CO_E_WRONGOSFORAPP;
    public static HResult CO_E_OBJNOTREG;
    public static HResult CO_E_OBJISREG;
    public static HResult CO_E_OBJNOTCONNECTED;
    public static HResult CO_E_APPDIDNTREG;
    public static HResult CO_E_RELEASED;
    public static HResult EVENT_E_FIRST;
    public static HResult EVENT_E_LAST;
    public static HResult EVENT_S_FIRST;
    public static HResult EVENT_S_LAST;
    public static HResult EVENT_S_SOME_SUBSCRIBERS_FAILED;
    public static HResult EVENT_E_ALL_SUBSCRIBERS_FAILED;
    public static HResult EVENT_S_NOSUBSCRIBERS;
    public static HResult EVENT_E_QUERYSYNTAX;
    public static HResult EVENT_E_QUERYFIELD;
    public static HResult EVENT_E_INTERNALEXCEPTION;
    public static HResult EVENT_E_INTERNALERROR;
    public static HResult EVENT_E_INVALID_PER_USER_SID;
    public static HResult EVENT_E_USER_EXCEPTION;
    public static HResult EVENT_E_TOO_MANY_METHODS;
    public static HResult EVENT_E_MISSING_EVENTCLASS;
    public static HResult EVENT_E_NOT_ALL_REMOVED;
    public static HResult EVENT_E_COMPLUS_NOT_INSTALLED;
    public static HResult EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT;
    public static HResult EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT;
    public static HResult EVENT_E_INVALID_EVENT_CLASS_PARTITION;
    public static HResult EVENT_E_PER_USER_SID_NOT_LOGGED_ON;
    public static HResult XACT_E_FIRST;
    public static HResult XACT_E_LAST;
    public static HResult XACT_S_FIRST;
    public static HResult XACT_S_LAST;
    public static HResult XACT_E_ALREADYOTHERSINGLEPHASE;
    public static HResult XACT_E_CANTRETAIN;
    public static HResult XACT_E_COMMITFAILED;
    public static HResult XACT_E_COMMITPREVENTED;
    public static HResult XACT_E_HEURISTICABORT;
    public static HResult XACT_E_HEURISTICCOMMIT;
    public static HResult XACT_E_HEURISTICDAMAGE;
    public static HResult XACT_E_HEURISTICDANGER;
    public static HResult XACT_E_ISOLATIONLEVEL;
    public static HResult XACT_E_NOASYNC;
    public static HResult XACT_E_NOENLIST;
    public static HResult XACT_E_NOISORETAIN;
    public static HResult XACT_E_NORESOURCE;
    public static HResult XACT_E_NOTCURRENT;
    public static HResult XACT_E_NOTRANSACTION;
    public static HResult XACT_E_NOTSUPPORTED;
    public static HResult XACT_E_UNKNOWNRMGRID;
    public static HResult XACT_E_WRONGSTATE;
    public static HResult XACT_E_WRONGUOW;
    public static HResult XACT_E_XTIONEXISTS;
    public static HResult XACT_E_NOIMPORTOBJECT;
    public static HResult XACT_E_INVALIDCOOKIE;
    public static HResult XACT_E_INDOUBT;
    public static HResult XACT_E_NOTIMEOUT;
    public static HResult XACT_E_ALREADYINPROGRESS;
    public static HResult XACT_E_ABORTED;
    public static HResult XACT_E_LOGFULL;
    public static HResult XACT_E_TMNOTAVAILABLE;
    public static HResult XACT_E_CONNECTION_DOWN;
    public static HResult XACT_E_CONNECTION_DENIED;
    public static HResult XACT_E_REENLISTTIMEOUT;
    public static HResult XACT_E_TIP_CONNECT_FAILED;
    public static HResult XACT_E_TIP_PROTOCOL_ERROR;
    public static HResult XACT_E_TIP_PULL_FAILED;
    public static HResult XACT_E_DEST_TMNOTAVAILABLE;
    public static HResult XACT_E_TIP_DISABLED;
    public static HResult XACT_E_NETWORK_TX_DISABLED;
    public static HResult XACT_E_PARTNER_NETWORK_TX_DISABLED;
    public static HResult XACT_E_XA_TX_DISABLED;
    public static HResult XACT_E_UNABLE_TO_READ_DTC_CONFIG;
    public static HResult XACT_E_UNABLE_TO_LOAD_DTC_PROXY;
    public static HResult XACT_E_ABORTING;
    public static HResult XACT_E_CLERKNOTFOUND;
    public static HResult XACT_E_CLERKEXISTS;
    public static HResult XACT_E_RECOVERYINPROGRESS;
    public static HResult XACT_E_TRANSACTIONCLOSED;
    public static HResult XACT_E_INVALIDLSN;
    public static HResult XACT_E_REPLAYREQUEST;
    public static HResult XACT_S_ASYNC;
    public static HResult XACT_S_DEFECT;
    public static HResult XACT_S_READONLY;
    public static HResult XACT_S_SOMENORETAIN;
    public static HResult XACT_S_OKINFORM;
    public static HResult XACT_S_MADECHANGESCONTENT;
    public static HResult XACT_S_MADECHANGESINFORM;
    public static HResult XACT_S_ALLNORETAIN;
    public static HResult XACT_S_ABORTING;
    public static HResult XACT_S_SINGLEPHASE;
    public static HResult XACT_S_LOCALLY_OK;
    public static HResult XACT_S_LASTRESOURCEMANAGER;
    public static HResult CONTEXT_E_FIRST;
    public static HResult CONTEXT_E_LAST;
    public static HResult CONTEXT_S_FIRST;
    public static HResult CONTEXT_S_LAST;
    public static HResult CONTEXT_E_ABORTED;
    public static HResult CONTEXT_E_ABORTING;
    public static HResult CONTEXT_E_NOCONTEXT;
    public static HResult CONTEXT_E_WOULD_DEADLOCK;
    public static HResult CONTEXT_E_SYNCH_TIMEOUT;
    public static HResult CONTEXT_E_OLDREF;
    public static HResult CONTEXT_E_ROLENOTFOUND;
    public static HResult CONTEXT_E_TMNOTAVAILABLE;
    public static HResult CO_E_ACTIVATIONFAILED;
    public static HResult CO_E_ACTIVATIONFAILED_EVENTLOGGED;
    public static HResult CO_E_ACTIVATIONFAILED_CATALOGERROR;
    public static HResult CO_E_ACTIVATIONFAILED_TIMEOUT;
    public static HResult CO_E_INITIALIZATIONFAILED;
    public static HResult CONTEXT_E_NOJIT;
    public static HResult CONTEXT_E_NOTRANSACTION;
    public static HResult CO_E_THREADINGMODEL_CHANGED;
    public static HResult CO_E_NOIISINTRINSICS;
    public static HResult CO_E_NOCOOKIES;
    public static HResult CO_E_DBERROR;
    public static HResult CO_E_NOTPOOLED;
    public static HResult CO_E_NOTCONSTRUCTED;
    public static HResult CO_E_NOSYNCHRONIZATION;
    public static HResult CO_E_ISOLEVELMISMATCH;
    public static HResult OLE_S_USEREG;
    public static HResult OLE_S_STATIC;
    public static HResult DRAGDROP_S_DROP;
    public static HResult DRAGDROP_S_CANCEL;
    public static HResult DRAGDROP_S_USEDEFAULTCURSORS;
    public static HResult DATA_S_SAMEFORMATETC;
    public static HResult VIEW_S_ALREADY_FROZEN;
    public static HResult CACHE_S_FORMATETC_NOTSUPPORTED;
    public static HResult CACHE_S_SAMECACHE;
    public static HResult CACHE_S_SOMECACHES_NOTUPDATED;
    public static HResult OLEOBJ_S_INVALIDVERB;
    public static HResult OLEOBJ_S_CANNOT_DOVERB_NOW;
    public static HResult OLEOBJ_S_INVALIDHWND;
    public static HResult INPLACE_S_TRUNCATED;
    public static HResult CONVERT10_S_NO_PRESENTATION;
    public static HResult MK_S_REDUCED_TO_SELF;
    public static HResult MK_S_ME;
    public static HResult MK_S_HIM;
    public static HResult MK_S_US;
    public static HResult MK_S_MONIKERALREADYREGISTERED;
    public static HResult SCHED_S_TASK_READY;
    public static HResult SCHED_S_TASK_RUNNING;
    public static HResult SCHED_S_TASK_DISABLED;
    public static HResult SCHED_S_TASK_HAS_NOT_RUN;
    public static HResult SCHED_S_TASK_NO_MORE_RUNS;
    public static HResult SCHED_S_TASK_NOT_SCHEDULED;
    public static HResult SCHED_S_TASK_TERMINATED;
    public static HResult SCHED_S_TASK_NO_VALID_TRIGGERS;
    public static HResult SCHED_S_EVENT_TRIGGER;
    public static HResult SCHED_E_TRIGGER_NOT_FOUND;
    public static HResult SCHED_E_TASK_NOT_READY;
    public static HResult SCHED_E_TASK_NOT_RUNNING;
    public static HResult SCHED_E_SERVICE_NOT_INSTALLED;
    public static HResult SCHED_E_CANNOT_OPEN_TASK;
    public static HResult SCHED_E_INVALID_TASK;
    public static HResult SCHED_E_ACCOUNT_INFORMATION_NOT_SET;
    public static HResult SCHED_E_ACCOUNT_NAME_NOT_FOUND;
    public static HResult SCHED_E_ACCOUNT_DBASE_CORRUPT;
    public static HResult SCHED_E_NO_SECURITY_SERVICES;
    public static HResult SCHED_E_UNKNOWN_OBJECT_VERSION;
    public static HResult SCHED_E_UNSUPPORTED_ACCOUNT_OPTION;
    public static HResult SCHED_E_SERVICE_NOT_RUNNING;
    public static HResult CO_E_CLASS_CREATE_FAILED;
    public static HResult CO_E_SCM_ERROR;
    public static HResult CO_E_SCM_RPC_FAILURE;
    public static HResult CO_E_BAD_PATH;
    public static HResult CO_E_SERVER_EXEC_FAILURE;
    public static HResult CO_E_OBJSRV_RPC_FAILURE;
    public static HResult MK_E_NO_NORMALIZED;
    public static HResult CO_E_SERVER_STOPPING;
    public static HResult MEM_E_INVALID_ROOT;
    public static HResult MEM_E_INVALID_LINK;
    public static HResult MEM_E_INVALID_SIZE;
    public static HResult CO_S_NOTALLINTERFACES;
    public static HResult CO_S_MACHINENAMENOTFOUND;
    public static HResult DISP_E_UNKNOWNINTERFACE;
    public static HResult DISP_E_MEMBERNOTFOUND;
    public static HResult DISP_E_PARAMNOTFOUND;
    public static HResult DISP_E_TYPEMISMATCH;
    public static HResult DISP_E_UNKNOWNNAME;
    public static HResult DISP_E_NONAMEDARGS;
    public static HResult DISP_E_BADVARTYPE;
    public static HResult DISP_E_EXCEPTION;
    public static HResult DISP_E_OVERFLOW;
    public static HResult DISP_E_BADINDEX;
    public static HResult DISP_E_UNKNOWNLCID;
    public static HResult DISP_E_ARRAYISLOCKED;
    public static HResult DISP_E_BADPARAMCOUNT;
    public static HResult DISP_E_PARAMNOTOPTIONAL;
    public static HResult DISP_E_BADCALLEE;
    public static HResult DISP_E_NOTACOLLECTION;
    public static HResult DISP_E_DIVBYZERO;
    public static HResult DISP_E_BUFFERTOOSMALL;
    public static HResult TYPE_E_BUFFERTOOSMALL;
    public static HResult TYPE_E_FIELDNOTFOUND;
    public static HResult TYPE_E_INVDATAREAD;
    public static HResult TYPE_E_UNSUPFORMAT;
    public static HResult TYPE_E_REGISTRYACCESS;
    public static HResult TYPE_E_LIBNOTREGISTERED;
    public static HResult TYPE_E_UNDEFINEDTYPE;
    public static HResult TYPE_E_QUALIFIEDNAMEDISALLOWED;
    public static HResult TYPE_E_INVALIDSTATE;
    public static HResult TYPE_E_WRONGTYPEKIND;
    public static HResult TYPE_E_ELEMENTNOTFOUND;
    public static HResult TYPE_E_AMBIGUOUSNAME;
    public static HResult TYPE_E_NAMECONFLICT;
    public static HResult TYPE_E_UNKNOWNLCID;
    public static HResult TYPE_E_DLLFUNCTIONNOTFOUND;
    public static HResult TYPE_E_BADMODULEKIND;
    public static HResult TYPE_E_SIZETOOBIG;
    public static HResult TYPE_E_DUPLICATEID;
    public static HResult TYPE_E_INVALIDID;
    public static HResult TYPE_E_TYPEMISMATCH;
    public static HResult TYPE_E_OUTOFBOUNDS;
    public static HResult TYPE_E_IOERROR;
    public static HResult TYPE_E_CANTCREATETMPFILE;
    public static HResult TYPE_E_CANTLOADLIBRARY;
    public static HResult TYPE_E_INCONSISTENTPROPFUNCS;
    public static HResult TYPE_E_CIRCULARTYPE;
    public static HResult STG_E_INVALIDFUNCTION;
    public static HResult STG_E_FILENOTFOUND;
    public static HResult STG_E_PATHNOTFOUND;
    public static HResult STG_E_TOOMANYOPENFILES;
    public static HResult STG_E_ACCESSDENIED;
    public static HResult STG_E_INVALIDHANDLE;
    public static HResult STG_E_INSUFFICIENTMEMORY;
    public static HResult STG_E_INVALIDPOINTER;
    public static HResult STG_E_NOMOREFILES;
    public static HResult STG_E_DISKISWRITEPROTECTED;
    public static HResult STG_E_SEEKERROR;
    public static HResult STG_E_WRITEFAULT;
    public static HResult STG_E_READFAULT;
    public static HResult STG_E_SHAREVIOLATION;
    public static HResult STG_E_LOCKVIOLATION;
    public static HResult STG_E_FILEALREADYEXISTS;
    public static HResult STG_E_INVALIDPARAMETER;
    public static HResult STG_E_MEDIUMFULL;
    public static HResult STG_E_PROPSETMISMATCHED;
    public static HResult STG_E_ABNORMALAPIEXIT;
    public static HResult STG_E_INVALIDHEADER;
    public static HResult STG_E_INVALIDNAME;
    public static HResult STG_E_UNKNOWN;
    public static HResult STG_E_UNIMPLEMENTEDFUNCTION;
    public static HResult STG_E_INVALIDFLAG;
    public static HResult STG_E_INUSE;
    public static HResult STG_E_NOTCURRENT;
    public static HResult STG_E_REVERTED;
    public static HResult STG_E_CANTSAVE;
    public static HResult STG_E_OLDFORMAT;
    public static HResult STG_E_OLDDLL;
    public static HResult STG_E_SHAREREQUIRED;
    public static HResult STG_E_NOTFILEBASEDSTORAGE;
    public static HResult STG_E_EXTANTMARSHALLINGS;
    public static HResult STG_E_DOCFILECORRUPT;
    public static HResult STG_E_BADBASEADDRESS;
    public static HResult STG_E_DOCFILETOOLARGE;
    public static HResult STG_E_NOTSIMPLEFORMAT;
    public static HResult STG_E_INCOMPLETE;
    public static HResult STG_E_TERMINATED;
    public static HResult STG_S_CONVERTED;
    public static HResult STG_S_BLOCK;
    public static HResult STG_S_RETRYNOW;
    public static HResult STG_S_MONITORING;
    public static HResult STG_S_MULTIPLEOPENS;
    public static HResult STG_S_CONSOLIDATIONFAILED;
    public static HResult STG_S_CANNOTCONSOLIDATE;
    public static HResult STG_E_STATUS_COPY_PROTECTION_FAILURE;
    public static HResult STG_E_CSS_AUTHENTICATION_FAILURE;
    public static HResult STG_E_CSS_KEY_NOT_PRESENT;
    public static HResult STG_E_CSS_KEY_NOT_ESTABLISHED;
    public static HResult STG_E_CSS_SCRAMBLED_SECTOR;
    public static HResult STG_E_CSS_REGION_MISMATCH;
    public static HResult STG_E_RESETS_EXHAUSTED;
    public static HResult RPC_E_CALL_REJECTED;
    public static HResult RPC_E_CALL_CANCELED;
    public static HResult RPC_E_CANTPOST_INSENDCALL;
    public static HResult RPC_E_CANTCALLOUT_INASYNCCALL;
    public static HResult RPC_E_CANTCALLOUT_INEXTERNALCALL;
    public static HResult RPC_E_CONNECTION_TERMINATED;
    public static HResult RPC_E_SERVER_DIED;
    public static HResult RPC_E_CLIENT_DIED;
    public static HResult RPC_E_INVALID_DATAPACKET;
    public static HResult RPC_E_CANTTRANSMIT_CALL;
    public static HResult RPC_E_CLIENT_CANTMARSHAL_DATA;
    public static HResult RPC_E_CLIENT_CANTUNMARSHAL_DATA;
    public static HResult RPC_E_SERVER_CANTMARSHAL_DATA;
    public static HResult RPC_E_SERVER_CANTUNMARSHAL_DATA;
    public static HResult RPC_E_INVALID_DATA;
    public static HResult RPC_E_INVALID_PARAMETER;
    public static HResult RPC_E_CANTCALLOUT_AGAIN;
    public static HResult RPC_E_SERVER_DIED_DNE;
    public static HResult RPC_E_SYS_CALL_FAILED;
    public static HResult RPC_E_OUT_OF_RESOURCES;
    public static HResult RPC_E_ATTEMPTED_MULTITHREAD;
    public static HResult RPC_E_NOT_REGISTERED;
    public static HResult RPC_E_FAULT;
    public static HResult RPC_E_SERVERFAULT;
    public static HResult RPC_E_CHANGED_MODE;
    public static HResult RPC_E_INVALIDMETHOD;
    public static HResult RPC_E_DISCONNECTED;
    public static HResult RPC_E_RETRY;
    public static HResult RPC_E_SERVERCALL_RETRYLATER;
    public static HResult RPC_E_SERVERCALL_REJECTED;
    public static HResult RPC_E_INVALID_CALLDATA;
    public static HResult RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
    public static HResult RPC_E_WRONG_THREAD;
    public static HResult RPC_E_THREAD_NOT_INIT;
    public static HResult RPC_E_VERSION_MISMATCH;
    public static HResult RPC_E_INVALID_HEADER;
    public static HResult RPC_E_INVALID_EXTENSION;
    public static HResult RPC_E_INVALID_IPID;
    public static HResult RPC_E_INVALID_OBJECT;
    public static HResult RPC_S_CALLPENDING;
    public static HResult RPC_S_WAITONTIMER;
    public static HResult RPC_E_CALL_COMPLETE;
    public static HResult RPC_E_UNSECURE_CALL;
    public static HResult RPC_E_TOO_LATE;
    public static HResult RPC_E_NO_GOOD_SECURITY_PACKAGES;
    public static HResult RPC_E_ACCESS_DENIED;
    public static HResult RPC_E_REMOTE_DISABLED;
    public static HResult RPC_E_INVALID_OBJREF;
    public static HResult RPC_E_NO_CONTEXT;
    public static HResult RPC_E_TIMEOUT;
    public static HResult RPC_E_NO_SYNC;
    public static HResult RPC_E_FULLSIC_REQUIRED;
    public static HResult RPC_E_INVALID_STD_NAME;
    public static HResult CO_E_FAILEDTOIMPERSONATE;
    public static HResult CO_E_FAILEDTOGETSECCTX;
    public static HResult CO_E_FAILEDTOOPENTHREADTOKEN;
    public static HResult CO_E_FAILEDTOGETTOKENINFO;
    public static HResult CO_E_TRUSTEEDOESNTMATCHCLIENT;
    public static HResult CO_E_FAILEDTOQUERYCLIENTBLANKET;
    public static HResult CO_E_FAILEDTOSETDACL;
    public static HResult CO_E_ACCESSCHECKFAILED;
    public static HResult CO_E_NETACCESSAPIFAILED;
    public static HResult CO_E_WRONGTRUSTEENAMESYNTAX;
    public static HResult CO_E_INVALIDSID;
    public static HResult CO_E_CONVERSIONFAILED;
    public static HResult CO_E_NOMATCHINGSIDFOUND;
    public static HResult CO_E_LOOKUPACCSIDFAILED;
    public static HResult CO_E_NOMATCHINGNAMEFOUND;
    public static HResult CO_E_LOOKUPACCNAMEFAILED;
    public static HResult CO_E_SETSERLHNDLFAILED;
    public static HResult CO_E_FAILEDTOGETWINDIR;
    public static HResult CO_E_PATHTOOLONG;
    public static HResult CO_E_FAILEDTOGENUUID;
    public static HResult CO_E_FAILEDTOCREATEFILE;
    public static HResult CO_E_FAILEDTOCLOSEHANDLE;
    public static HResult CO_E_EXCEEDSYSACLLIMIT;
    public static HResult CO_E_ACESINWRONGORDER;
    public static HResult CO_E_INCOMPATIBLESTREAMVERSION;
    public static HResult CO_E_FAILEDTOOPENPROCESSTOKEN;
    public static HResult CO_E_DECODEFAILED;
    public static HResult CO_E_ACNOTINITIALIZED;
    public static HResult CO_E_CANCEL_DISABLED;
    public static HResult RPC_E_UNEXPECTED;
    public static HResult ERROR_AUDITING_DISABLED;
    public static HResult ERROR_ALL_SIDS_FILTERED;
    public static HResult NTE_BAD_UID;
    public static HResult NTE_BAD_HASH;
    public static HResult NTE_BAD_KEY;
    public static HResult NTE_BAD_LEN;
    public static HResult NTE_BAD_DATA;
    public static HResult NTE_BAD_SIGNATURE;
    public static HResult NTE_BAD_VER;
    public static HResult NTE_BAD_ALGID;
    public static HResult NTE_BAD_FLAGS;
    public static HResult NTE_BAD_TYPE;
    public static HResult NTE_BAD_KEY_STATE;
    public static HResult NTE_BAD_HASH_STATE;
    public static HResult NTE_NO_KEY;
    public static HResult NTE_NO_MEMORY;
    public static HResult NTE_EXISTS;
    public static HResult NTE_PERM;
    public static HResult NTE_NOT_FOUND;
    public static HResult NTE_DOUBLE_ENCRYPT;
    public static HResult NTE_BAD_PROVIDER;
    public static HResult NTE_BAD_PROV_TYPE;
    public static HResult NTE_BAD_PUBLIC_KEY;
    public static HResult NTE_BAD_KEYSET;
    public static HResult NTE_PROV_TYPE_NOT_DEF;
    public static HResult NTE_PROV_TYPE_ENTRY_BAD;
    public static HResult NTE_KEYSET_NOT_DEF;
    public static HResult NTE_KEYSET_ENTRY_BAD;
    public static HResult NTE_PROV_TYPE_NO_MATCH;
    public static HResult NTE_SIGNATURE_FILE_BAD;
    public static HResult NTE_PROVIDER_DLL_FAIL;
    public static HResult NTE_PROV_DLL_NOT_FOUND;
    public static HResult NTE_BAD_KEYSET_PARAM;
    public static HResult NTE_FAIL;
    public static HResult NTE_SYS_ERR;
    public static HResult NTE_SILENT_CONTEXT;
    public static HResult NTE_TOKEN_KEYSET_STORAGE_FULL;
    public static HResult NTE_TEMPORARY_PROFILE;
    public static HResult NTE_FIXEDPARAMETER;
    public static HResult SEC_E_INSUFFICIENT_MEMORY;
    public static HResult SEC_E_INVALID_HANDLE;
    public static HResult SEC_E_UNSUPPORTED_FUNCTION;
    public static HResult SEC_E_TARGET_UNKNOWN;
    public static HResult SEC_E_INTERNAL_ERROR;
    public static HResult SEC_E_SECPKG_NOT_FOUND;
    public static HResult SEC_E_NOT_OWNER;
    public static HResult SEC_E_CANNOT_INSTALL;
    public static HResult SEC_E_INVALID_TOKEN;
    public static HResult SEC_E_CANNOT_PACK;
    public static HResult SEC_E_QOP_NOT_SUPPORTED;
    public static HResult SEC_E_NO_IMPERSONATION;
    public static HResult SEC_E_LOGON_DENIED;
    public static HResult SEC_E_UNKNOWN_CREDENTIALS;
    public static HResult SEC_E_NO_CREDENTIALS;
    public static HResult SEC_E_MESSAGE_ALTERED;
    public static HResult SEC_E_OUT_OF_SEQUENCE;
    public static HResult SEC_E_NO_AUTHENTICATING_AUTHORITY;
    public static HResult SEC_I_CONTINUE_NEEDED;
    public static HResult SEC_I_COMPLETE_NEEDED;
    public static HResult SEC_I_COMPLETE_AND_CONTINUE;
    public static HResult SEC_I_LOCAL_LOGON;
    public static HResult SEC_E_BAD_PKGID;
    public static HResult SEC_E_CONTEXT_EXPIRED;
    public static HResult SEC_I_CONTEXT_EXPIRED;
    public static HResult SEC_E_INCOMPLETE_MESSAGE;
    public static HResult SEC_E_INCOMPLETE_CREDENTIALS;
    public static HResult SEC_E_BUFFER_TOO_SMALL;
    public static HResult SEC_I_INCOMPLETE_CREDENTIALS;
    public static HResult SEC_I_RENEGOTIATE;
    public static HResult SEC_E_WRONG_PRINCIPAL;
    public static HResult SEC_I_NO_LSA_CONTEXT;
    public static HResult SEC_E_TIME_SKEW;
    public static HResult SEC_E_UNTRUSTED_ROOT;
    public static HResult SEC_E_ILLEGAL_MESSAGE;
    public static HResult SEC_E_CERT_UNKNOWN;
    public static HResult SEC_E_CERT_EXPIRED;
    public static HResult SEC_E_ENCRYPT_FAILURE;
    public static HResult SEC_E_DECRYPT_FAILURE;
    public static HResult SEC_E_ALGORITHM_MISMATCH;
    public static HResult SEC_E_SECURITY_QOS_FAILED;
    public static HResult SEC_E_UNFINISHED_CONTEXT_DELETED;
    public static HResult SEC_E_NO_TGT_REPLY;
    public static HResult SEC_E_NO_IP_ADDRESSES;
    public static HResult SEC_E_WRONG_CREDENTIAL_HANDLE;
    public static HResult SEC_E_CRYPTO_SYSTEM_INVALID;
    public static HResult SEC_E_MAX_REFERRALS_EXCEEDED;
    public static HResult SEC_E_MUST_BE_KDC;
    public static HResult SEC_E_STRONG_CRYPTO_NOT_SUPPORTED;
    public static HResult SEC_E_TOO_MANY_PRINCIPALS;
    public static HResult SEC_E_NO_PA_DATA;
    public static HResult SEC_E_PKINIT_NAME_MISMATCH;
    public static HResult SEC_E_SMARTCARD_LOGON_REQUIRED;
    public static HResult SEC_E_SHUTDOWN_IN_PROGRESS;
    public static HResult SEC_E_KDC_INVALID_REQUEST;
    public static HResult SEC_E_KDC_UNABLE_TO_REFER;
    public static HResult SEC_E_KDC_UNKNOWN_ETYPE;
    public static HResult SEC_E_UNSUPPORTED_PREAUTH;
    public static HResult SEC_E_DELEGATION_REQUIRED;
    public static HResult SEC_E_BAD_BINDINGS;
    public static HResult SEC_E_MULTIPLE_ACCOUNTS;
    public static HResult SEC_E_NO_KERB_KEY;
    public static HResult SEC_E_CERT_WRONG_USAGE;
    public static HResult SEC_E_DOWNGRADE_DETECTED;
    public static HResult SEC_E_SMARTCARD_CERT_REVOKED;
    public static HResult SEC_E_ISSUING_CA_UNTRUSTED;
    public static HResult SEC_E_REVOCATION_OFFLINE_C;
    public static HResult SEC_E_PKINIT_CLIENT_FAILURE;
    public static HResult SEC_E_SMARTCARD_CERT_EXPIRED;
    public static HResult SEC_E_NO_S4U_PROT_SUPPORT;
    public static HResult SEC_E_CROSSREALM_DELEGATION_FAILURE;
    public static HResult SEC_E_REVOCATION_OFFLINE_KDC;
    public static HResult SEC_E_ISSUING_CA_UNTRUSTED_KDC;
    public static HResult SEC_E_KDC_CERT_EXPIRED;
    public static HResult SEC_E_KDC_CERT_REVOKED;
    public static HResult CRYPT_E_MSG_ERROR;
    public static HResult CRYPT_E_UNKNOWN_ALGO;
    public static HResult CRYPT_E_OID_FORMAT;
    public static HResult CRYPT_E_INVALID_MSG_TYPE;
    public static HResult CRYPT_E_UNEXPECTED_ENCODING;
    public static HResult CRYPT_E_AUTH_ATTR_MISSING;
    public static HResult CRYPT_E_HASH_VALUE;
    public static HResult CRYPT_E_INVALID_INDEX;
    public static HResult CRYPT_E_ALREADY_DECRYPTED;
    public static HResult CRYPT_E_NOT_DECRYPTED;
    public static HResult CRYPT_E_RECIPIENT_NOT_FOUND;
    public static HResult CRYPT_E_CONTROL_TYPE;
    public static HResult CRYPT_E_ISSUER_SERIALNUMBER;
    public static HResult CRYPT_E_SIGNER_NOT_FOUND;
    public static HResult CRYPT_E_ATTRIBUTES_MISSING;
    public static HResult CRYPT_E_STREAM_MSG_NOT_READY;
    public static HResult CRYPT_E_STREAM_INSUFFICIENT_DATA;
    public static HResult CRYPT_I_NEW_PROTECTION_REQUIRED;
    public static HResult CRYPT_E_BAD_LEN;
    public static HResult CRYPT_E_BAD_ENCODE;
    public static HResult CRYPT_E_FILE_ERROR;
    public static HResult CRYPT_E_NOT_FOUND;
    public static HResult CRYPT_E_EXISTS;
    public static HResult CRYPT_E_NO_PROVIDER;
    public static HResult CRYPT_E_SELF_SIGNED;
    public static HResult CRYPT_E_DELETED_PREV;
    public static HResult CRYPT_E_NO_MATCH;
    public static HResult CRYPT_E_UNEXPECTED_MSG_TYPE;
    public static HResult CRYPT_E_NO_KEY_PROPERTY;
    public static HResult CRYPT_E_NO_DECRYPT_CERT;
    public static HResult CRYPT_E_BAD_MSG;
    public static HResult CRYPT_E_NO_SIGNER;
    public static HResult CRYPT_E_PENDING_CLOSE;
    public static HResult CRYPT_E_REVOKED;
    public static HResult CRYPT_E_NO_REVOCATION_DLL;
    public static HResult CRYPT_E_NO_REVOCATION_CHECK;
    public static HResult CRYPT_E_REVOCATION_OFFLINE;
    public static HResult CRYPT_E_NOT_IN_REVOCATION_DATABASE;
    public static HResult CRYPT_E_INVALID_NUMERIC_STRING;
    public static HResult CRYPT_E_INVALID_PRINTABLE_STRING;
    public static HResult CRYPT_E_INVALID_IA5_STRING;
    public static HResult CRYPT_E_INVALID_X500_STRING;
    public static HResult CRYPT_E_NOT_CHAR_STRING;
    public static HResult CRYPT_E_FILERESIZED;
    public static HResult CRYPT_E_SECURITY_SETTINGS;
    public static HResult CRYPT_E_NO_VERIFY_USAGE_DLL;
    public static HResult CRYPT_E_NO_VERIFY_USAGE_CHECK;
    public static HResult CRYPT_E_VERIFY_USAGE_OFFLINE;
    public static HResult CRYPT_E_NOT_IN_CTL;
    public static HResult CRYPT_E_NO_TRUSTED_SIGNER;
    public static HResult CRYPT_E_MISSING_PUBKEY_PARA;
    public static HResult CRYPT_E_OSS_ERROR;
    public static HResult OSS_MORE_BUF;
    public static HResult OSS_NEGATIVE_UINTEGER;
    public static HResult OSS_PDU_RANGE;
    public static HResult OSS_MORE_INPUT;
    public static HResult OSS_DATA_ERROR;
    public static HResult OSS_BAD_ARG;
    public static HResult OSS_BAD_VERSION;
    public static HResult OSS_OUT_MEMORY;
    public static HResult OSS_PDU_MISMATCH;
    public static HResult OSS_LIMITED;
    public static HResult OSS_BAD_PTR;
    public static HResult OSS_BAD_TIME;
    public static HResult OSS_INDEFINITE_NOT_SUPPORTED;
    public static HResult OSS_MEM_ERROR;
    public static HResult OSS_BAD_TABLE;
    public static HResult OSS_TOO_LONG;
    public static HResult OSS_CONSTRAINT_VIOLATED;
    public static HResult OSS_FATAL_ERROR;
    public static HResult OSS_ACCESS_SERIALIZATION_ERROR;
    public static HResult OSS_NULL_TBL;
    public static HResult OSS_NULL_FCN;
    public static HResult OSS_BAD_ENCRULES;
    public static HResult OSS_UNAVAIL_ENCRULES;
    public static HResult OSS_CANT_OPEN_TRACE_WINDOW;
    public static HResult OSS_UNIMPLEMENTED;
    public static HResult OSS_OID_DLL_NOT_LINKED;
    public static HResult OSS_CANT_OPEN_TRACE_FILE;
    public static HResult OSS_TRACE_FILE_ALREADY_OPEN;
    public static HResult OSS_TABLE_MISMATCH;
    public static HResult OSS_TYPE_NOT_SUPPORTED;
    public static HResult OSS_REAL_DLL_NOT_LINKED;
    public static HResult OSS_REAL_CODE_NOT_LINKED;
    public static HResult OSS_OUT_OF_RANGE;
    public static HResult OSS_COPIER_DLL_NOT_LINKED;
    public static HResult OSS_CONSTRAINT_DLL_NOT_LINKED;
    public static HResult OSS_COMPARATOR_DLL_NOT_LINKED;
    public static HResult OSS_COMPARATOR_CODE_NOT_LINKED;
    public static HResult OSS_MEM_MGR_DLL_NOT_LINKED;
    public static HResult OSS_PDV_DLL_NOT_LINKED;
    public static HResult OSS_PDV_CODE_NOT_LINKED;
    public static HResult OSS_API_DLL_NOT_LINKED;
    public static HResult OSS_BERDER_DLL_NOT_LINKED;
    public static HResult OSS_PER_DLL_NOT_LINKED;
    public static HResult OSS_OPEN_TYPE_ERROR;
    public static HResult OSS_MUTEX_NOT_CREATED;
    public static HResult OSS_CANT_CLOSE_TRACE_FILE;
    public static HResult CRYPT_E_ASN1_ERROR;
    public static HResult CRYPT_E_ASN1_INTERNAL;
    public static HResult CRYPT_E_ASN1_EOD;
    public static HResult CRYPT_E_ASN1_CORRUPT;
    public static HResult CRYPT_E_ASN1_LARGE;
    public static HResult CRYPT_E_ASN1_CONSTRAINT;
    public static HResult CRYPT_E_ASN1_MEMORY;
    public static HResult CRYPT_E_ASN1_OVERFLOW;
    public static HResult CRYPT_E_ASN1_BADPDU;
    public static HResult CRYPT_E_ASN1_BADARGS;
    public static HResult CRYPT_E_ASN1_BADREAL;
    public static HResult CRYPT_E_ASN1_BADTAG;
    public static HResult CRYPT_E_ASN1_CHOICE;
    public static HResult CRYPT_E_ASN1_RULE;
    public static HResult CRYPT_E_ASN1_UTF8;
    public static HResult CRYPT_E_ASN1_PDU_TYPE;
    public static HResult CRYPT_E_ASN1_NYI;
    public static HResult CRYPT_E_ASN1_EXTENDED;
    public static HResult CRYPT_E_ASN1_NOEOD;
    public static HResult CERTSRV_E_BAD_REQUESTSUBJECT;
    public static HResult CERTSRV_E_NO_REQUEST;
    public static HResult CERTSRV_E_BAD_REQUESTSTATUS;
    public static HResult CERTSRV_E_PROPERTY_EMPTY;
    public static HResult CERTSRV_E_INVALID_CA_CERTIFICATE;
    public static HResult CERTSRV_E_SERVER_SUSPENDED;
    public static HResult CERTSRV_E_ENCODING_LENGTH;
    public static HResult CERTSRV_E_ROLECONFLICT;
    public static HResult CERTSRV_E_RESTRICTEDOFFICER;
    public static HResult CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED;
    public static HResult CERTSRV_E_NO_VALID_KRA;
    public static HResult CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL;
    public static HResult CERTSRV_E_NO_CAADMIN_DEFINED;
    public static HResult CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE;
    public static HResult CERTSRV_E_NO_DB_SESSIONS;
    public static HResult CERTSRV_E_ALIGNMENT_FAULT;
    public static HResult CERTSRV_E_ENROLL_DENIED;
    public static HResult CERTSRV_E_TEMPLATE_DENIED;
    public static HResult CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE;
    public static HResult CERTSRV_E_UNSUPPORTED_CERT_TYPE;
    public static HResult CERTSRV_E_NO_CERT_TYPE;
    public static HResult CERTSRV_E_TEMPLATE_CONFLICT;
    public static HResult CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED;
    public static HResult CERTSRV_E_ARCHIVED_KEY_REQUIRED;
    public static HResult CERTSRV_E_SMIME_REQUIRED;
    public static HResult CERTSRV_E_BAD_RENEWAL_SUBJECT;
    public static HResult CERTSRV_E_BAD_TEMPLATE_VERSION;
    public static HResult CERTSRV_E_TEMPLATE_POLICY_REQUIRED;
    public static HResult CERTSRV_E_SIGNATURE_POLICY_REQUIRED;
    public static HResult CERTSRV_E_SIGNATURE_COUNT;
    public static HResult CERTSRV_E_SIGNATURE_REJECTED;
    public static HResult CERTSRV_E_ISSUANCE_POLICY_REQUIRED;
    public static HResult CERTSRV_E_SUBJECT_UPN_REQUIRED;
    public static HResult CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED;
    public static HResult CERTSRV_E_SUBJECT_DNS_REQUIRED;
    public static HResult CERTSRV_E_ARCHIVED_KEY_UNEXPECTED;
    public static HResult CERTSRV_E_KEY_LENGTH;
    public static HResult CERTSRV_E_SUBJECT_EMAIL_REQUIRED;
    public static HResult CERTSRV_E_UNKNOWN_CERT_TYPE;
    public static HResult CERTSRV_E_CERT_TYPE_OVERLAP;
    public static HResult XENROLL_E_KEY_NOT_EXPORTABLE;
    public static HResult XENROLL_E_CANNOT_ADD_ROOT_CERT;
    public static HResult XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND;
    public static HResult XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH;
    public static HResult XENROLL_E_RESPONSE_KA_HASH_MISMATCH;
    public static HResult XENROLL_E_KEYSPEC_SMIME_MISMATCH;
    public static HResult TRUST_E_SYSTEM_ERROR;
    public static HResult TRUST_E_NO_SIGNER_CERT;
    public static HResult TRUST_E_COUNTER_SIGNER;
    public static HResult TRUST_E_CERT_SIGNATURE;
    public static HResult TRUST_E_TIME_STAMP;
    public static HResult TRUST_E_BAD_DIGEST;
    public static HResult TRUST_E_BASIC_CONSTRAINTS;
    public static HResult TRUST_E_FINANCIAL_CRITERIA;
    public static HResult MSSIPOTF_E_OUTOFMEMRANGE;
    public static HResult MSSIPOTF_E_CANTGETOBJECT;
    public static HResult MSSIPOTF_E_NOHEADTABLE;
    public static HResult MSSIPOTF_E_BAD_MAGICNUMBER;
    public static HResult MSSIPOTF_E_BAD_OFFSET_TABLE;
    public static HResult MSSIPOTF_E_TABLE_TAGORDER;
    public static HResult MSSIPOTF_E_TABLE_LONGWORD;
    public static HResult MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT;
    public static HResult MSSIPOTF_E_TABLES_OVERLAP;
    public static HResult MSSIPOTF_E_TABLE_PADBYTES;
    public static HResult MSSIPOTF_E_FILETOOSMALL;
    public static HResult MSSIPOTF_E_TABLE_CHECKSUM;
    public static HResult MSSIPOTF_E_FILE_CHECKSUM;
    public static HResult MSSIPOTF_E_FAILED_POLICY;
    public static HResult MSSIPOTF_E_FAILED_HINTS_CHECK;
    public static HResult MSSIPOTF_E_NOT_OPENTYPE;
    public static HResult MSSIPOTF_E_FILE;
    public static HResult MSSIPOTF_E_CRYPT;
    public static HResult MSSIPOTF_E_BADVERSION;
    public static HResult MSSIPOTF_E_DSIG_STRUCTURE;
    public static HResult MSSIPOTF_E_PCONST_CHECK;
    public static HResult MSSIPOTF_E_STRUCTURE;
    public static HResult TRUST_E_PROVIDER_UNKNOWN;
    public static HResult TRUST_E_ACTION_UNKNOWN;
    public static HResult TRUST_E_SUBJECT_FORM_UNKNOWN;
    public static HResult TRUST_E_SUBJECT_NOT_TRUSTED;
    public static HResult DIGSIG_E_ENCODE;
    public static HResult DIGSIG_E_DECODE;
    public static HResult DIGSIG_E_EXTENSIBILITY;
    public static HResult DIGSIG_E_CRYPTO;
    public static HResult PERSIST_E_SIZEDEFINITE;
    public static HResult PERSIST_E_SIZEINDEFINITE;
    public static HResult PERSIST_E_NOTSELFSIZING;
    public static HResult TRUST_E_NOSIGNATURE;
    public static HResult CERT_E_EXPIRED;
    public static HResult CERT_E_VALIDITYPERIODNESTING;
    public static HResult CERT_E_ROLE;
    public static HResult CERT_E_PATHLENCONST;
    public static HResult CERT_E_CRITICAL;
    public static HResult CERT_E_PURPOSE;
    public static HResult CERT_E_ISSUERCHAINING;
    public static HResult CERT_E_MALFORMED;
    public static HResult CERT_E_UNTRUSTEDROOT;
    public static HResult CERT_E_CHAINING;
    public static HResult TRUST_E_FAIL;
    public static HResult CERT_E_REVOKED;
    public static HResult CERT_E_UNTRUSTEDTESTROOT;
    public static HResult CERT_E_REVOCATION_FAILURE;
    public static HResult CERT_E_CN_NO_MATCH;
    public static HResult CERT_E_WRONG_USAGE;
    public static HResult TRUST_E_EXPLICIT_DISTRUST;
    public static HResult CERT_E_UNTRUSTEDCA;
    public static HResult CERT_E_INVALID_POLICY;
    public static HResult CERT_E_INVALID_NAME;
    public static HResult SPAPI_E_EXPECTED_SECTION_NAME;
    public static HResult SPAPI_E_BAD_SECTION_NAME_LINE;
    public static HResult SPAPI_E_SECTION_NAME_TOO_LONG;
    public static HResult SPAPI_E_GENERAL_SYNTAX;
    public static HResult SPAPI_E_WRONG_INF_STYLE;
    public static HResult SPAPI_E_SECTION_NOT_FOUND;
    public static HResult SPAPI_E_LINE_NOT_FOUND;
    public static HResult SPAPI_E_NO_BACKUP;
    public static HResult SPAPI_E_NO_ASSOCIATED_CLASS;
    public static HResult SPAPI_E_CLASS_MISMATCH;
    public static HResult SPAPI_E_DUPLICATE_FOUND;
    public static HResult SPAPI_E_NO_DRIVER_SELECTED;
    public static HResult SPAPI_E_KEY_DOES_NOT_EXIST;
    public static HResult SPAPI_E_INVALID_DEVINST_NAME;
    public static HResult SPAPI_E_INVALID_CLASS;
    public static HResult SPAPI_E_DEVINST_ALREADY_EXISTS;
    public static HResult SPAPI_E_DEVINFO_NOT_REGISTERED;
    public static HResult SPAPI_E_INVALID_REG_PROPERTY;
    public static HResult SPAPI_E_NO_INF;
    public static HResult SPAPI_E_NO_SUCH_DEVINST;
    public static HResult SPAPI_E_CANT_LOAD_CLASS_ICON;
    public static HResult SPAPI_E_INVALID_CLASS_INSTALLER;
    public static HResult SPAPI_E_DI_DO_DEFAULT;
    public static HResult SPAPI_E_DI_NOFILECOPY;
    public static HResult SPAPI_E_INVALID_HWPROFILE;
    public static HResult SPAPI_E_NO_DEVICE_SELECTED;
    public static HResult SPAPI_E_DEVINFO_LIST_LOCKED;
    public static HResult SPAPI_E_DEVINFO_DATA_LOCKED;
    public static HResult SPAPI_E_DI_BAD_PATH;
    public static HResult SPAPI_E_NO_CLASSINSTALL_PARAMS;
    public static HResult SPAPI_E_FILEQUEUE_LOCKED;
    public static HResult SPAPI_E_BAD_SERVICE_INSTALLSECT;
    public static HResult SPAPI_E_NO_CLASS_DRIVER_LIST;
    public static HResult SPAPI_E_NO_ASSOCIATED_SERVICE;
    public static HResult SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE;
    public static HResult SPAPI_E_DEVICE_INTERFACE_ACTIVE;
    public static HResult SPAPI_E_DEVICE_INTERFACE_REMOVED;
    public static HResult SPAPI_E_BAD_INTERFACE_INSTALLSECT;
    public static HResult SPAPI_E_NO_SUCH_INTERFACE_CLASS;
    public static HResult SPAPI_E_INVALID_REFERENCE_STRING;
    public static HResult SPAPI_E_INVALID_MACHINENAME;
    public static HResult SPAPI_E_REMOTE_COMM_FAILURE;
    public static HResult SPAPI_E_MACHINE_UNAVAILABLE;
    public static HResult SPAPI_E_NO_CONFIGMGR_SERVICES;
    public static HResult SPAPI_E_INVALID_PROPPAGE_PROVIDER;
    public static HResult SPAPI_E_NO_SUCH_DEVICE_INTERFACE;
    public static HResult SPAPI_E_DI_POSTPROCESSING_REQUIRED;
    public static HResult SPAPI_E_INVALID_COINSTALLER;
    public static HResult SPAPI_E_NO_COMPAT_DRIVERS;
    public static HResult SPAPI_E_NO_DEVICE_ICON;
    public static HResult SPAPI_E_INVALID_INF_LOGCONFIG;
    public static HResult SPAPI_E_DI_DONT_INSTALL;
    public static HResult SPAPI_E_INVALID_FILTER_DRIVER;
    public static HResult SPAPI_E_NON_WINDOWS_NT_DRIVER;
    public static HResult SPAPI_E_NON_WINDOWS_DRIVER;
    public static HResult SPAPI_E_NO_CATALOG_FOR_OEM_INF;
    public static HResult SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE;
    public static HResult SPAPI_E_NOT_DISABLEABLE;
    public static HResult SPAPI_E_CANT_REMOVE_DEVINST;
    public static HResult SPAPI_E_INVALID_TARGET;
    public static HResult SPAPI_E_DRIVER_NONNATIVE;
    public static HResult SPAPI_E_IN_WOW64;
    public static HResult SPAPI_E_SET_SYSTEM_RESTORE_POINT;
    public static HResult SPAPI_E_INCORRECTLY_COPIED_INF;
    public static HResult SPAPI_E_SCE_DISABLED;
    public static HResult SPAPI_E_UNKNOWN_EXCEPTION;
    public static HResult SPAPI_E_PNP_REGISTRY_ERROR;
    public static HResult SPAPI_E_REMOTE_REQUEST_UNSUPPORTED;
    public static HResult SPAPI_E_NOT_AN_INSTALLED_OEM_INF;
    public static HResult SPAPI_E_INF_IN_USE_BY_DEVICES;
    public static HResult SPAPI_E_DI_FUNCTION_OBSOLETE;
    public static HResult SPAPI_E_NO_AUTHENTICODE_CATALOG;
    public static HResult SPAPI_E_AUTHENTICODE_DISALLOWED;
    public static HResult SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER;
    public static HResult SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED;
    public static HResult SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;
    public static HResult SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH;
    public static HResult SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE;
    public static HResult SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW;
    public static HResult SPAPI_E_ERROR_NOT_INSTALLED;
    public static HResult SCARD_F_INTERNAL_ERROR;
    public static HResult SCARD_E_CANCELLED;
    public static HResult SCARD_E_INVALID_HANDLE;
    public static HResult SCARD_E_INVALID_PARAMETER;
    public static HResult SCARD_E_INVALID_TARGET;
    public static HResult SCARD_E_NO_MEMORY;
    public static HResult SCARD_F_WAITED_TOO_LONG;
    public static HResult SCARD_E_INSUFFICIENT_BUFFER;
    public static HResult SCARD_E_UNKNOWN_READER;
    public static HResult SCARD_E_TIMEOUT;
    public static HResult SCARD_E_SHARING_VIOLATION;
    public static HResult SCARD_E_NO_SMARTCARD;
    public static HResult SCARD_E_UNKNOWN_CARD;
    public static HResult SCARD_E_CANT_DISPOSE;
    public static HResult SCARD_E_PROTO_MISMATCH;
    public static HResult SCARD_E_NOT_READY;
    public static HResult SCARD_E_INVALID_VALUE;
    public static HResult SCARD_E_SYSTEM_CANCELLED;
    public static HResult SCARD_F_COMM_ERROR;
    public static HResult SCARD_F_UNKNOWN_ERROR;
    public static HResult SCARD_E_INVALID_ATR;
    public static HResult SCARD_E_NOT_TRANSACTED;
    public static HResult SCARD_E_READER_UNAVAILABLE;
    public static HResult SCARD_P_SHUTDOWN;
    public static HResult SCARD_E_PCI_TOO_SMALL;
    public static HResult SCARD_E_READER_UNSUPPORTED;
    public static HResult SCARD_E_DUPLICATE_READER;
    public static HResult SCARD_E_CARD_UNSUPPORTED;
    public static HResult SCARD_E_NO_SERVICE;
    public static HResult SCARD_E_SERVICE_STOPPED;
    public static HResult SCARD_E_UNEXPECTED;
    public static HResult SCARD_E_ICC_INSTALLATION;
    public static HResult SCARD_E_ICC_CREATEORDER;
    public static HResult SCARD_E_UNSUPPORTED_FEATURE;
    public static HResult SCARD_E_DIR_NOT_FOUND;
    public static HResult SCARD_E_FILE_NOT_FOUND;
    public static HResult SCARD_E_NO_DIR;
    public static HResult SCARD_E_NO_FILE;
    public static HResult SCARD_E_NO_ACCESS;
    public static HResult SCARD_E_WRITE_TOO_MANY;
    public static HResult SCARD_E_BAD_SEEK;
    public static HResult SCARD_E_INVALID_CHV;
    public static HResult SCARD_E_UNKNOWN_RES_MNG;
    public static HResult SCARD_E_NO_SUCH_CERTIFICATE;
    public static HResult SCARD_E_CERTIFICATE_UNAVAILABLE;
    public static HResult SCARD_E_NO_READERS_AVAILABLE;
    public static HResult SCARD_E_COMM_DATA_LOST;
    public static HResult SCARD_E_NO_KEY_CONTAINER;
    public static HResult SCARD_E_SERVER_TOO_BUSY;
    public static HResult SCARD_W_UNSUPPORTED_CARD;
    public static HResult SCARD_W_UNRESPONSIVE_CARD;
    public static HResult SCARD_W_UNPOWERED_CARD;
    public static HResult SCARD_W_RESET_CARD;
    public static HResult SCARD_W_REMOVED_CARD;
    public static HResult SCARD_W_SECURITY_VIOLATION;
    public static HResult SCARD_W_WRONG_CHV;
    public static HResult SCARD_W_CHV_BLOCKED;
    public static HResult SCARD_W_EOF;
    public static HResult SCARD_W_CANCELLED_BY_USER;
    public static HResult SCARD_W_CARD_NOT_AUTHENTICATED;
    public static HResult COMADMIN_E_OBJECTERRORS;
    public static HResult COMADMIN_E_OBJECTINVALID;
    public static HResult COMADMIN_E_KEYMISSING;
    public static HResult COMADMIN_E_ALREADYINSTALLED;
    public static HResult COMADMIN_E_APP_FILE_WRITEFAIL;
    public static HResult COMADMIN_E_APP_FILE_READFAIL;
    public static HResult COMADMIN_E_APP_FILE_VERSION;
    public static HResult COMADMIN_E_BADPATH;
    public static HResult COMADMIN_E_APPLICATIONEXISTS;
    public static HResult COMADMIN_E_ROLEEXISTS;
    public static HResult COMADMIN_E_CANTCOPYFILE;
    public static HResult COMADMIN_E_NOUSER;
    public static HResult COMADMIN_E_INVALIDUSERIDS;
    public static HResult COMADMIN_E_NOREGISTRYCLSID;
    public static HResult COMADMIN_E_BADREGISTRYPROGID;
    public static HResult COMADMIN_E_AUTHENTICATIONLEVEL;
    public static HResult COMADMIN_E_USERPASSWDNOTVALID;
    public static HResult COMADMIN_E_CLSIDORIIDMISMATCH;
    public static HResult COMADMIN_E_REMOTEINTERFACE;
    public static HResult COMADMIN_E_DLLREGISTERSERVER;
    public static HResult COMADMIN_E_NOSERVERSHARE;
    public static HResult COMADMIN_E_DLLLOADFAILED;
    public static HResult COMADMIN_E_BADREGISTRYLIBID;
    public static HResult COMADMIN_E_APPDIRNOTFOUND;
    public static HResult COMADMIN_E_REGISTRARFAILED;
    public static HResult COMADMIN_E_COMPFILE_DOESNOTEXIST;
    public static HResult COMADMIN_E_COMPFILE_LOADDLLFAIL;
    public static HResult COMADMIN_E_COMPFILE_GETCLASSOBJ;
    public static HResult COMADMIN_E_COMPFILE_CLASSNOTAVAIL;
    public static HResult COMADMIN_E_COMPFILE_BADTLB;
    public static HResult COMADMIN_E_COMPFILE_NOTINSTALLABLE;
    public static HResult COMADMIN_E_NOTCHANGEABLE;
    public static HResult COMADMIN_E_NOTDELETEABLE;
    public static HResult COMADMIN_E_SESSION;
    public static HResult COMADMIN_E_COMP_MOVE_LOCKED;
    public static HResult COMADMIN_E_COMP_MOVE_BAD_DEST;
    public static HResult COMADMIN_E_REGISTERTLB;
    public static HResult COMADMIN_E_SYSTEMAPP;
    public static HResult COMADMIN_E_COMPFILE_NOREGISTRAR;
    public static HResult COMADMIN_E_COREQCOMPINSTALLED;
    public static HResult COMADMIN_E_SERVICENOTINSTALLED;
    public static HResult COMADMIN_E_PROPERTYSAVEFAILED;
    public static HResult COMADMIN_E_OBJECTEXISTS;
    public static HResult COMADMIN_E_COMPONENTEXISTS;
    public static HResult COMADMIN_E_REGFILE_CORRUPT;
    public static HResult COMADMIN_E_PROPERTY_OVERFLOW;
    public static HResult COMADMIN_E_NOTINREGISTRY;
    public static HResult COMADMIN_E_OBJECTNOTPOOLABLE;
    public static HResult COMADMIN_E_APPLID_MATCHES_CLSID;
    public static HResult COMADMIN_E_ROLE_DOES_NOT_EXIST;
    public static HResult COMADMIN_E_START_APP_NEEDS_COMPONENTS;
    public static HResult COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM;
    public static HResult COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY;
    public static HResult COMADMIN_E_CAN_NOT_START_APP;
    public static HResult COMADMIN_E_CAN_NOT_EXPORT_SYS_APP;
    public static HResult COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT;
    public static HResult COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER;
    public static HResult COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE;
    public static HResult COMADMIN_E_BASE_PARTITION_ONLY;
    public static HResult COMADMIN_E_START_APP_DISABLED;
    public static HResult COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME;
    public static HResult COMADMIN_E_CAT_INVALID_PARTITION_NAME;
    public static HResult COMADMIN_E_CAT_PARTITION_IN_USE;
    public static HResult COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES;
    public static HResult COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED;
    public static HResult COMADMIN_E_AMBIGUOUS_APPLICATION_NAME;
    public static HResult COMADMIN_E_AMBIGUOUS_PARTITION_NAME;
    public static HResult COMADMIN_E_REGDB_NOTINITIALIZED;
    public static HResult COMADMIN_E_REGDB_NOTOPEN;
    public static HResult COMADMIN_E_REGDB_SYSTEMERR;
    public static HResult COMADMIN_E_REGDB_ALREADYRUNNING;
    public static HResult COMADMIN_E_MIG_VERSIONNOTSUPPORTED;
    public static HResult COMADMIN_E_MIG_SCHEMANOTFOUND;
    public static HResult COMADMIN_E_CAT_BITNESSMISMATCH;
    public static HResult COMADMIN_E_CAT_UNACCEPTABLEBITNESS;
    public static HResult COMADMIN_E_CAT_WRONGAPPBITNESS;
    public static HResult COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED;
    public static HResult COMADMIN_E_CAT_SERVERFAULT;
    public static HResult COMQC_E_APPLICATION_NOT_QUEUED;
    public static HResult COMQC_E_NO_QUEUEABLE_INTERFACES;
    public static HResult COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE;
    public static HResult COMQC_E_NO_IPERSISTSTREAM;
    public static HResult COMQC_E_BAD_MESSAGE;
    public static HResult COMQC_E_UNAUTHENTICATED;
    public static HResult COMQC_E_UNTRUSTED_ENQUEUER;
    public static HResult MSDTC_E_DUPLICATE_RESOURCE;
    public static HResult COMADMIN_E_OBJECT_PARENT_MISSING;
    public static HResult COMADMIN_E_OBJECT_DOES_NOT_EXIST;
    public static HResult COMADMIN_E_APP_NOT_RUNNING;
    public static HResult COMADMIN_E_INVALID_PARTITION;
    public static HResult COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE;
    public static HResult COMADMIN_E_USER_IN_SET;
    public static HResult COMADMIN_E_CANTRECYCLELIBRARYAPPS;
    public static HResult COMADMIN_E_CANTRECYCLESERVICEAPPS;
    public static HResult COMADMIN_E_PROCESSALREADYRECYCLED;
    public static HResult COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED;
    public static HResult COMADMIN_E_CANTMAKEINPROCSERVICE;
    public static HResult COMADMIN_E_PROGIDINUSEBYCLSID;
    public static HResult COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET;
    public static HResult COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED;
    public static HResult COMADMIN_E_PARTITION_ACCESSDENIED;
    public static HResult COMADMIN_E_PARTITION_MSI_ONLY;
    public static HResult COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT;
    public static HResult COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS;
    public static HResult COMADMIN_E_COMP_MOVE_SOURCE;
    public static HResult COMADMIN_E_COMP_MOVE_DEST;
    public static HResult COMADMIN_E_COMP_MOVE_PRIVATE;
    public static HResult COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET;
    public static HResult COMADMIN_E_CANNOT_ALIAS_EVENTCLASS;
    public static HResult COMADMIN_E_PRIVATE_ACCESSDENIED;
    public static HResult COMADMIN_E_SAFERINVALID;
    public static HResult COMADMIN_E_REGISTRY_ACCESSDENIED;
    public static HResult COMADMIN_E_PARTITIONS_DISABLED;
    public static HResult CEE_E_ENTRYPOINT;
    public static HResult CEE_E_CVTRES_NOT_FOUND;
    public static HResult MSEE_E_LOADLIBFAILED;
    public static HResult MSEE_E_GETPROCFAILED;
    public static HResult MSEE_E_MULTCOPIESLOADED;
    public static HResult COR_E_APPDOMAINUNLOADED;
    public static HResult COR_E_CANNOTUNLOADAPPDOMAIN;
    public static HResult MSEE_E_ASSEMBLYLOADINPROGRESS;
    public static HResult MSEE_E_CANNOTCREATEAPPDOMAIN;
    public static HResult COR_E_FIXUPSINEXE;
    public static HResult COR_E_NO_LOADLIBRARY_ALLOWED;
    public static HResult COR_E_NEWER_RUNTIME;
    public static HResult HOST_E_DEADLOCK;
    public static HResult HOST_E_INTERRUPTED;
    public static HResult HOST_E_INVALIDOPERATION;
    public static HResult HOST_E_CLRNOTAVAILABLE;
    public static HResult HOST_E_TIMEOUT;
    public static HResult HOST_E_NOT_OWNER;
    public static HResult HOST_E_ABANDONED;
    public static HResult HOST_E_EXITPROCESS_THREADABORT;
    public static HResult HOST_E_EXITPROCESS_ADUNLOAD;
    public static HResult HOST_E_EXITPROCESS_TIMEOUT;
    public static HResult HOST_E_EXITPROCESS_OUTOFMEMORY;
    public static HResult HOST_E_EXITPROCESS_STACKOVERFLOW;
    public static HResult COR_E_MODULE_HASH_CHECK_FAILED;
    public static HResult FUSION_E_REF_DEF_MISMATCH;
    public static HResult FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    public static HResult FUSION_E_ASM_MODULE_MISSING;
    public static HResult FUSION_E_UNEXPECTED_MODULE_FOUND;
    public static HResult FUSION_E_PRIVATE_ASM_DISALLOWED;
    public static HResult FUSION_E_SIGNATURE_CHECK_FAILED;
    public static HResult FUSION_E_DATABASE_ERROR;
    public static HResult FUSION_E_INVALID_NAME;
    public static HResult FUSION_E_CODE_DOWNLOAD_DISABLED;
    public static HResult FUSION_E_UNINSTALL_DISALLOWED;
    public static HResult FUSION_E_HOST_GAC_ASM_MISMATCH;
    public static HResult CLDB_E_FILE_BADREAD;
    public static HResult CLDB_E_FILE_BADWRITE;
    public static HResult CLDB_E_FILE_READONLY;
    public static HResult CLDB_E_NAME_ERROR;
    public static HResult CLDB_S_TRUNCATION;
    public static HResult CLDB_E_TRUNCATION;
    public static HResult CLDB_E_FILE_OLDVER;
    public static HResult CLDB_E_RELOCATED;
    public static HResult CLDB_S_NULL;
    public static HResult CLDB_E_SMDUPLICATE;
    public static HResult CLDB_E_NO_DATA;
    public static HResult CLDB_E_READONLY;
    public static HResult CLDB_E_INCOMPATIBLE;
    public static HResult CLDB_E_FILE_CORRUPT;
    public static HResult CLDB_E_SCHEMA_VERNOTFOUND;
    public static HResult CLDB_E_BADUPDATEMODE;
    public static HResult CLDB_E_INDEX_NONULLKEYS;
    public static HResult CLDB_E_INDEX_DUPLICATE;
    public static HResult CLDB_E_INDEX_BADTYPE;
    public static HResult CLDB_E_INDEX_NOTFOUND;
    public static HResult CLDB_S_INDEX_TABLESCANREQUIRED;
    public static HResult CLDB_E_RECORD_NOTFOUND;
    public static HResult CLDB_E_RECORD_OVERFLOW;
    public static HResult CLDB_E_RECORD_DUPLICATE;
    public static HResult CLDB_E_RECORD_PKREQUIRED;
    public static HResult CLDB_E_RECORD_DELETED;
    public static HResult CLDB_E_RECORD_OUTOFORDER;
    public static HResult CLDB_E_COLUMN_OVERFLOW;
    public static HResult CLDB_E_COLUMN_READONLY;
    public static HResult CLDB_E_COLUMN_SPECIALCOL;
    public static HResult CLDB_E_COLUMN_PKNONULLS;
    public static HResult CLDB_E_TABLE_CANTDROP;
    public static HResult CLDB_E_OBJECT_NOTFOUND;
    public static HResult CLDB_E_OBJECT_COLNOTFOUND;
    public static HResult CLDB_E_VECTOR_BADINDEX;
    public static HResult CLDB_E_TOO_BIG;
    public static HResult META_E_INVALID_TOKEN_TYPE;
    public static HResult TLBX_E_INVALID_TYPEINFO;
    public static HResult TLBX_E_INVALID_TYPEINFO_UNNAMED;
    public static HResult TLBX_E_CTX_NESTED;
    public static HResult TLBX_E_ERROR_MESSAGE;
    public static HResult TLBX_E_CANT_SAVE;
    public static HResult TLBX_W_LIBNOTREGISTERED;
    public static HResult TLBX_E_CANTLOADLIBRARY;
    public static HResult TLBX_E_BAD_VT_TYPE;
    public static HResult TLBX_E_NO_MSCOREE_TLB;
    public static HResult TLBX_E_BAD_MSCOREE_TLB;
    public static HResult TLBX_E_TLB_EXCEPTION;
    public static HResult TLBX_E_MULTIPLE_LCIDS;
    public static HResult TLBX_I_TYPEINFO_IMPORTED;
    public static HResult TLBX_E_AMBIGUOUS_RETURN;
    public static HResult TLBX_E_DUPLICATE_TYPE_NAME;
    public static HResult TLBX_I_USEIUNKNOWN;
    public static HResult TLBX_I_UNCONVERTABLE_ARGS;
    public static HResult TLBX_I_UNCONVERTABLE_FIELD;
    public static HResult TLBX_I_NONSEQUENTIALSTRUCT;
    public static HResult TLBX_W_WARNING_MESSAGE;
    public static HResult TLBX_I_RESOLVEREFFAILED;
    public static HResult TLBX_E_ASANY;
    public static HResult TLBX_E_INVALIDLCIDPARAM;
    public static HResult TLBX_E_LCIDONDISPONLYITF;
    public static HResult TLBX_E_NONPUBLIC_FIELD;
    public static HResult TLBX_I_TYPE_EXPORTED;
    public static HResult TLBX_I_DUPLICATE_DISPID;
    public static HResult TLBX_E_BAD_NAMES;
    public static HResult TLBX_I_REF_TYPE_AS_STRUCT;
    public static HResult TLBX_E_GENERICINST_SIGNATURE;
    public static HResult TLBX_E_GENERICPAR_SIGNATURE;
    public static HResult TLBX_I_GENERIC_TYPE;
    public static HResult META_E_DUPLICATE;
    public static HResult META_E_GUID_REQUIRED;
    public static HResult META_E_TYPEDEF_MISMATCH;
    public static HResult META_E_MERGE_COLLISION;
    public static HResult TLBX_W_NON_INTEGRAL_CA_TYPE;
    public static HResult TLBX_W_IENUM_CA_ON_IUNK;
    public static HResult TLBX_E_NO_SAFEHANDLE_ARRAYS;
    public static HResult META_E_METHD_NOT_FOUND;
    public static HResult META_E_FIELD_NOT_FOUND;
    public static HResult META_S_PARAM_MISMATCH;
    public static HResult META_E_PARAM_MISMATCH;
    public static HResult META_E_BADMETADATA;
    public static HResult META_E_INTFCEIMPL_NOT_FOUND;
    public static HResult TLBX_E_NO_CRITICALHANDLE_ARRAYS;
    public static HResult META_E_CLASS_LAYOUT_INCONSISTENT;
    public static HResult META_E_FIELD_MARSHAL_NOT_FOUND;
    public static HResult META_E_METHODSEM_NOT_FOUND;
    public static HResult META_E_EVENT_NOT_FOUND;
    public static HResult META_E_PROP_NOT_FOUND;
    public static HResult META_E_BAD_SIGNATURE;
    public static HResult META_E_BAD_INPUT_PARAMETER;
    public static HResult META_E_METHDIMPL_INCONSISTENT;
    public static HResult META_E_MD_INCONSISTENCY;
    public static HResult META_E_CANNOTRESOLVETYPEREF;
    public static HResult META_S_DUPLICATE;
    public static HResult META_E_STRINGSPACE_FULL;
    public static HResult META_E_UNEXPECTED_REMAP;
    public static HResult META_E_HAS_UNMARKALL;
    public static HResult META_E_MUST_CALL_UNMARKALL;
    public static HResult META_E_GENERICPARAM_INCONSISTENT;
    public static HResult META_E_EVENT_COUNTS;
    public static HResult META_E_PROPERTY_COUNTS;
    public static HResult META_E_TYPEDEF_MISSING;
    public static HResult TLBX_E_CANT_LOAD_MODULE;
    public static HResult TLBX_E_CANT_LOAD_CLASS;
    public static HResult TLBX_E_NULL_MODULE;
    public static HResult TLBX_E_NO_CLSID_KEY;
    public static HResult TLBX_E_CIRCULAR_EXPORT;
    public static HResult TLBX_E_CIRCULAR_IMPORT;
    public static HResult TLBX_E_BAD_NATIVETYPE;
    public static HResult TLBX_E_BAD_VTABLE;
    public static HResult TLBX_E_CRM_NON_STATIC;
    public static HResult TLBX_E_CRM_INVALID_SIG;
    public static HResult TLBX_E_CLASS_LOAD_EXCEPTION;
    public static HResult TLBX_E_UNKNOWN_SIGNATURE;
    public static HResult TLBX_E_REFERENCED_TYPELIB;
    public static HResult TLBX_S_REFERENCED_TYPELIB;
    public static HResult TLBX_E_INVALID_NAMESPACE;
    public static HResult TLBX_E_LAYOUT_ERROR;
    public static HResult TLBX_E_NOTIUNKNOWN;
    public static HResult TLBX_E_NONVISIBLEVALUECLASS;
    public static HResult TLBX_E_LPTSTR_NOT_ALLOWED;
    public static HResult TLBX_E_AUTO_CS_NOT_ALLOWED;
    public static HResult TLBX_S_NOSTDINTERFACE;
    public static HResult TLBX_S_DUPLICATE_DISPID;
    public static HResult TLBX_E_ENUM_VALUE_INVALID;
    public static HResult TLBX_E_DUPLICATE_IID;
    public static HResult TLBX_E_NO_NESTED_ARRAYS;
    public static HResult TLBX_E_PARAM_ERROR_NAMED;
    public static HResult TLBX_E_PARAM_ERROR_UNNAMED;
    public static HResult TLBX_E_AGNOST_SIGNATURE;
    public static HResult TLBX_E_CONVERT_FAIL;
    public static HResult TLBX_W_DUAL_NOT_DISPATCH;
    public static HResult TLBX_E_BAD_SIGNATURE;
    public static HResult TLBX_E_ARRAY_NEEDS_NT_FIXED;
    public static HResult TLBX_E_CLASS_NEEDS_NT_INTF;
    public static HResult META_E_CA_INVALID_TARGET;
    public static HResult META_E_CA_INVALID_VALUE;
    public static HResult META_E_CA_INVALID_BLOB;
    public static HResult META_E_CA_REPEATED_ARG;
    public static HResult META_E_CA_UNKNOWN_ARGUMENT;
    public static HResult META_E_CA_VARIANT_NYI;
    public static HResult META_E_CA_ARRAY_NYI;
    public static HResult META_E_CA_UNEXPECTED_TYPE;
    public static HResult META_E_CA_INVALID_ARGTYPE;
    public static HResult META_E_CA_INVALID_ARG_FOR_TYPE;
    public static HResult META_E_CA_INVALID_UUID;
    public static HResult META_E_CA_INVALID_MARSHALAS_FIELDS;
    public static HResult META_E_CA_NT_FIELDONLY;
    public static HResult META_E_CA_NEGATIVE_PARAMINDEX;
    public static HResult META_E_CA_NEGATIVE_MULTIPLIER;
    public static HResult META_E_CA_NEGATIVE_CONSTSIZE;
    public static HResult META_E_CA_FIXEDSTR_SIZE_REQUIRED;
    public static HResult META_E_CA_CUSTMARSH_TYPE_REQUIRED;
    public static HResult META_E_CA_FILENAME_REQUIRED;
    public static HResult TLBX_W_NO_PROPS_IN_EVENTS;
    public static HResult META_E_NOT_IN_ENC_MODE;
    public static HResult TLBX_W_ENUM_VALUE_TOOBIG;
    public static HResult META_E_METHOD_COUNTS;
    public static HResult META_E_FIELD_COUNTS;
    public static HResult META_E_PARAM_COUNTS;
    public static HResult TLBX_W_EXPORTING_AUTO_LAYOUT;
    public static HResult TLBX_E_TYPED_REF;
    public static HResult TLBX_W_DEFAULT_INTF_NOT_VISIBLE;
    public static HResult TLBX_W_BAD_SAFEARRAYFIELD_NO_ELEMENTVT;
    public static HResult TLBX_W_LAYOUTCLASS_AS_INTERFACE;
    public static HResult TLBX_I_GENERIC_BASE_TYPE;
    public static HResult TLBX_E_BITNESS_MISMATCH;
    public static HResult VLDTR_S_WRN;
    public static HResult VLDTR_S_ERR;
    public static HResult VLDTR_S_WRNERR;
    public static HResult VLDTR_E_RID_OUTOFRANGE;
    public static HResult VLDTR_E_CDTKN_OUTOFRANGE;
    public static HResult VLDTR_E_CDRID_OUTOFRANGE;
    public static HResult VLDTR_E_STRING_INVALID;
    public static HResult VLDTR_E_GUID_INVALID;
    public static HResult VLDTR_E_BLOB_INVALID;
    public static HResult VLDTR_E_MOD_MULTI;
    public static HResult VLDTR_E_MOD_NULLMVID;
    public static HResult VLDTR_E_TR_NAMENULL;
    public static HResult VLDTR_E_TR_DUP;
    public static HResult VLDTR_E_TD_NAMENULL;
    public static HResult VLDTR_E_TD_DUPNAME;
    public static HResult VLDTR_E_TD_DUPGUID;
    public static HResult VLDTR_E_TD_NOTIFACEOBJEXTNULL;
    public static HResult VLDTR_E_TD_OBJEXTENDSNONNULL;
    public static HResult VLDTR_E_TD_EXTENDSSEALED;
    public static HResult VLDTR_E_TD_DLTNORTSPCL;
    public static HResult VLDTR_E_TD_RTSPCLNOTDLT;
    public static HResult VLDTR_E_MI_DECLPRIV;
    public static HResult VLDTR_E_AS_BADNAME;
    public static HResult VLDTR_E_FILE_SYSNAME;
    public static HResult VLDTR_E_MI_BODYSTATIC;
    public static HResult VLDTR_E_TD_IFACENOTABS;
    public static HResult VLDTR_E_TD_IFACEPARNOTNIL;
    public static HResult VLDTR_E_TD_IFACEGUIDNULL;
    public static HResult VLDTR_E_MI_DECLFINAL;
    public static HResult VLDTR_E_TD_VTNOTSEAL;
    public static HResult VLDTR_E_PD_BADFLAGS;
    public static HResult VLDTR_E_IFACE_DUP;
    public static HResult VLDTR_E_MR_NAMENULL;
    public static HResult VLDTR_E_MR_VTBLNAME;
    public static HResult VLDTR_E_MR_DELNAME;
    public static HResult VLDTR_E_MR_PARNIL;
    public static HResult VLDTR_E_MR_BADCALLINGCONV;
    public static HResult VLDTR_E_MR_NOTVARARG;
    public static HResult VLDTR_E_MR_NAMEDIFF;
    public static HResult VLDTR_E_MR_SIGDIFF;
    public static HResult VLDTR_E_MR_DUP;
    public static HResult VLDTR_E_CL_TDAUTO;
    public static HResult VLDTR_E_CL_BADPCKSZ;
    public static HResult VLDTR_E_CL_DUP;
    public static HResult VLDTR_E_FL_BADOFFSET;
    public static HResult VLDTR_E_FL_TDNIL;
    public static HResult VLDTR_E_FL_NOCL;
    public static HResult VLDTR_E_FL_TDNOTEXPLCT;
    public static HResult VLDTR_E_FL_FLDSTATIC;
    public static HResult VLDTR_E_FL_DUP;
    public static HResult VLDTR_E_MODREF_NAMENULL;
    public static HResult VLDTR_E_MODREF_DUP;
    public static HResult VLDTR_E_TR_BADSCOPE;
    public static HResult VLDTR_E_TD_NESTEDNOENCL;
    public static HResult VLDTR_E_TD_EXTTRRES;
    public static HResult VLDTR_E_SIGNULL;
    public static HResult VLDTR_E_SIGNODATA;
    public static HResult VLDTR_E_MD_BADCALLINGCONV;
    public static HResult VLDTR_E_MD_THISSTATIC;
    public static HResult VLDTR_E_MD_NOTTHISNOTSTATIC;
    public static HResult VLDTR_E_MD_NOARGCNT;
    public static HResult VLDTR_E_SIG_MISSELTYPE;
    public static HResult VLDTR_E_SIG_MISSTKN;
    public static HResult VLDTR_E_SIG_TKNBAD;
    public static HResult VLDTR_E_SIG_MISSFPTR;
    public static HResult VLDTR_E_SIG_MISSFPTRARGCNT;
    public static HResult VLDTR_E_SIG_MISSRANK;
    public static HResult VLDTR_E_SIG_MISSNSIZE;
    public static HResult VLDTR_E_SIG_MISSSIZE;
    public static HResult VLDTR_E_SIG_MISSNLBND;
    public static HResult VLDTR_E_SIG_MISSLBND;
    public static HResult VLDTR_E_SIG_BADELTYPE;
    public static HResult VLDTR_E_SIG_MISSVASIZE;
    public static HResult VLDTR_E_FD_BADCALLINGCONV;
    public static HResult VLDTR_E_MD_NAMENULL;
    public static HResult VLDTR_E_MD_PARNIL;
    public static HResult VLDTR_E_MD_DUP;
    public static HResult VLDTR_E_FD_NAMENULL;
    public static HResult VLDTR_E_FD_PARNIL;
    public static HResult VLDTR_E_FD_DUP;
    public static HResult VLDTR_E_AS_MULTI;
    public static HResult VLDTR_E_AS_NAMENULL;
    public static HResult VLDTR_E_SIG_TOKTYPEMISMATCH;
    public static HResult VLDTR_E_CL_TDINTF;
    public static HResult VLDTR_E_ASOS_OSPLTFRMIDINVAL;
    public static HResult VLDTR_E_AR_NAMENULL;
    public static HResult VLDTR_E_TD_ENCLNOTNESTED;
    public static HResult VLDTR_E_AROS_OSPLTFRMIDINVAL;
    public static HResult VLDTR_E_FILE_NAMENULL;
    public static HResult VLDTR_E_CT_NAMENULL;
    public static HResult VLDTR_E_TD_EXTENDSCHILD;
    public static HResult VLDTR_E_MAR_NAMENULL;
    public static HResult VLDTR_E_FILE_DUP;
    public static HResult VLDTR_E_FILE_NAMEFULLQLFD;
    public static HResult VLDTR_E_CT_DUP;
    public static HResult VLDTR_E_MAR_DUP;
    public static HResult VLDTR_E_MAR_NOTPUBPRIV;
    public static HResult VLDTR_E_TD_ENUMNOVALUE;
    public static HResult VLDTR_E_TD_ENUMVALSTATIC;
    public static HResult VLDTR_E_TD_ENUMVALNOTSN;
    public static HResult VLDTR_E_TD_ENUMFLDNOTST;
    public static HResult VLDTR_E_TD_ENUMFLDNOTLIT;
    public static HResult VLDTR_E_TD_ENUMNOLITFLDS;
    public static HResult VLDTR_E_TD_ENUMFLDSIGMISMATCH;
    public static HResult VLDTR_E_TD_ENUMVALNOT1ST;
    public static HResult VLDTR_E_FD_NOTVALUERTSN;
    public static HResult VLDTR_E_FD_VALUEPARNOTENUM;
    public static HResult VLDTR_E_FD_INSTINIFACE;
    public static HResult VLDTR_E_FD_NOTPUBINIFACE;
    public static HResult VLDTR_E_FMD_GLOBALNOTPUBPRIVSC;
    public static HResult VLDTR_E_FMD_GLOBALNOTSTATIC;
    public static HResult VLDTR_E_FD_GLOBALNORVA;
    public static HResult VLDTR_E_MD_CTORZERORVA;
    public static HResult VLDTR_E_FD_MARKEDNOMARSHAL;
    public static HResult VLDTR_E_FD_MARSHALNOTMARKED;
    public static HResult VLDTR_E_FD_MARKEDNODEFLT;
    public static HResult VLDTR_E_FD_DEFLTNOTMARKED;
    public static HResult VLDTR_E_FMD_MARKEDNOSECUR;
    public static HResult VLDTR_E_FMD_SECURNOTMARKED;
    public static HResult VLDTR_E_FMD_PINVOKENOTSTATIC;
    public static HResult VLDTR_E_FMD_MARKEDNOPINVOKE;
    public static HResult VLDTR_E_FMD_PINVOKENOTMARKED;
    public static HResult VLDTR_E_FMD_BADIMPLMAP;
    public static HResult VLDTR_E_IMAP_BADMODREF;
    public static HResult VLDTR_E_IMAP_BADMEMBER;
    public static HResult VLDTR_E_IMAP_BADIMPORTNAME;
    public static HResult VLDTR_E_IMAP_BADCALLCONV;
    public static HResult VLDTR_E_FMD_BADACCESSFLAG;
    public static HResult VLDTR_E_FD_INITONLYANDLITERAL;
    public static HResult VLDTR_E_FD_LITERALNOTSTATIC;
    public static HResult VLDTR_E_FMD_RTSNNOTSN;
    public static HResult VLDTR_E_MD_ABSTPARNOTABST;
    public static HResult VLDTR_E_MD_NOTSTATABSTININTF;
    public static HResult VLDTR_E_MD_NOTPUBININTF;
    public static HResult VLDTR_E_MD_CTORININTF;
    public static HResult VLDTR_E_MD_GLOBALCTORCCTOR;
    public static HResult VLDTR_E_MD_CTORSTATIC;
    public static HResult VLDTR_E_MD_CTORNOTSNRTSN;
    public static HResult VLDTR_E_MD_CTORVIRT;
    public static HResult VLDTR_E_MD_CTORABST;
    public static HResult VLDTR_E_MD_CCTORNOTSTATIC;
    public static HResult VLDTR_E_MD_ZERORVA;
    public static HResult VLDTR_E_MD_FINNOTVIRT;
    public static HResult VLDTR_E_MD_STATANDFINORVIRT;
    public static HResult VLDTR_E_MD_ABSTANDFINAL;
    public static HResult VLDTR_E_MD_ABSTANDIMPL;
    public static HResult VLDTR_E_MD_ABSTANDPINVOKE;
    public static HResult VLDTR_E_MD_ABSTNOTVIRT;
    public static HResult VLDTR_E_MD_NOTABSTNOTIMPL;
    public static HResult VLDTR_E_MD_NOTABSTBADFLAGSRVA;
    public static HResult VLDTR_E_MD_PRIVSCOPENORVA;
    public static HResult VLDTR_E_MD_GLOBALABSTORVIRT;
    public static HResult VLDTR_E_SIG_LONGFORM;
    public static HResult VLDTR_E_MD_MULTIPLESEMANTICS;
    public static HResult VLDTR_E_MD_INVALIDSEMANTICS;
    public static HResult VLDTR_E_MD_SEMANTICSNOTEXIST;
    public static HResult VLDTR_E_MI_DECLNOTVIRT;
    public static HResult VLDTR_E_FMD_GLOBALITEM;
    public static HResult VLDTR_E_MD_MULTSEMANTICFLAGS;
    public static HResult VLDTR_E_MD_NOSEMANTICFLAGS;
    public static HResult VLDTR_E_FD_FLDINIFACE;
    public static HResult VLDTR_E_AS_HASHALGID;
    public static HResult VLDTR_E_AS_PROCID;
    public static HResult VLDTR_E_AR_PROCID;
    public static HResult VLDTR_E_CN_PARENTRANGE;
    public static HResult VLDTR_E_AS_BADFLAGS;
    public static HResult VLDTR_E_TR_HASTYPEDEF;
    public static HResult VLDTR_E_IFACE_BADIMPL;
    public static HResult VLDTR_E_IFACE_BADIFACE;
    public static HResult VLDTR_E_TD_SECURNOTMARKED;
    public static HResult VLDTR_E_TD_MARKEDNOSECUR;
    public static HResult VLDTR_E_MD_CCTORHASARGS;
    public static HResult VLDTR_E_CT_BADIMPL;
    public static HResult VLDTR_E_MI_ALIENBODY;
    public static HResult VLDTR_E_MD_CCTORCALLCONV;
    public static HResult VLDTR_E_MI_BADCLASS;
    public static HResult VLDTR_E_MI_CLASSISINTF;
    public static HResult VLDTR_E_MI_BADDECL;
    public static HResult VLDTR_E_MI_BADBODY;
    public static HResult VLDTR_E_MI_DUP;
    public static HResult VLDTR_E_FD_BADPARENT;
    public static HResult VLDTR_E_MD_PARAMOUTOFSEQ;
    public static HResult VLDTR_E_MD_PARASEQTOOBIG;
    public static HResult VLDTR_E_MD_PARMMARKEDNOMARSHAL;
    public static HResult VLDTR_E_MD_PARMMARSHALNOTMARKED;
    public static HResult VLDTR_E_MD_PARMMARKEDNODEFLT;
    public static HResult VLDTR_E_MD_PARMDEFLTNOTMARKED;
    public static HResult VLDTR_E_PR_BADSCOPE;
    public static HResult VLDTR_E_PR_NONAME;
    public static HResult VLDTR_E_PR_NOSIG;
    public static HResult VLDTR_E_PR_DUP;
    public static HResult VLDTR_E_PR_BADCALLINGCONV;
    public static HResult VLDTR_E_PR_MARKEDNODEFLT;
    public static HResult VLDTR_E_PR_DEFLTNOTMARKED;
    public static HResult VLDTR_E_PR_BADSEMANTICS;
    public static HResult VLDTR_E_PR_BADMETHOD;
    public static HResult VLDTR_E_PR_ALIENMETHOD;
    public static HResult VLDTR_E_CN_BLOBNOTNULL;
    public static HResult VLDTR_E_CN_BLOBNULL;
    public static HResult VLDTR_E_EV_BADSCOPE;
    public static HResult VLDTR_E_EV_NONAME;
    public static HResult VLDTR_E_EV_DUP;
    public static HResult VLDTR_E_EV_BADEVTYPE;
    public static HResult VLDTR_E_EV_EVTYPENOTCLASS;
    public static HResult VLDTR_E_EV_BADSEMANTICS;
    public static HResult VLDTR_E_EV_BADMETHOD;
    public static HResult VLDTR_E_EV_ALIENMETHOD;
    public static HResult VLDTR_E_EV_NOADDON;
    public static HResult VLDTR_E_EV_NOREMOVEON;
    public static HResult VLDTR_E_CT_DUPTDNAME;
    public static HResult VLDTR_E_MAR_BADOFFSET;
    public static HResult VLDTR_E_DS_BADOWNER;
    public static HResult VLDTR_E_DS_BADFLAGS;
    public static HResult VLDTR_E_DS_NOBLOB;
    public static HResult VLDTR_E_MAR_BADIMPL;
    public static HResult VLDTR_E_MR_VARARGCALLINGCONV;
    public static HResult VLDTR_E_MD_CTORNOTVOID;
    public static HResult VLDTR_E_EV_FIRENOTVOID;
    public static HResult VLDTR_E_AS_BADLOCALE;
    public static HResult VLDTR_E_CN_PARENTTYPE;
    public static HResult VLDTR_E_SIG_SENTINMETHODDEF;
    public static HResult VLDTR_E_SIG_SENTMUSTVARARG;
    public static HResult VLDTR_E_SIG_MULTSENTINELS;
    public static HResult VLDTR_E_SIG_LASTSENTINEL;
    public static HResult VLDTR_E_SIG_MISSARG;
    public static HResult VLDTR_E_SIG_BYREFINFIELD;
    public static HResult VLDTR_E_MD_SYNCMETHODINVTYPE;
    public static HResult VLDTR_E_TD_NAMETOOLONG;
    public static HResult VLDTR_E_AS_PROCDUP;
    public static HResult VLDTR_E_ASOS_DUP;
    public static HResult VLDTR_E_MAR_BADFLAGS;
    public static HResult VLDTR_E_CT_NOTYPEDEFID;
    public static HResult VLDTR_E_FILE_BADFLAGS;
    public static HResult VLDTR_E_FILE_NULLHASH;
    public static HResult VLDTR_E_MOD_NONAME;
    public static HResult VLDTR_E_MOD_NAMEFULLQLFD;
    public static HResult VLDTR_E_TD_RTSPCLNOTSPCL;
    public static HResult VLDTR_E_TD_EXTENDSIFACE;
    public static HResult VLDTR_E_MD_CTORPINVOKE;
    public static HResult VLDTR_E_TD_SYSENUMNOTCLASS;
    public static HResult VLDTR_E_TD_SYSENUMNOTEXTVTYPE;
    public static HResult VLDTR_E_MI_SIGMISMATCH;
    public static HResult VLDTR_E_TD_ENUMHASMETHODS;
    public static HResult VLDTR_E_TD_ENUMIMPLIFACE;
    public static HResult VLDTR_E_TD_ENUMHASPROP;
    public static HResult VLDTR_E_TD_ENUMHASEVENT;
    public static HResult VLDTR_E_TD_BADMETHODLST;
    public static HResult VLDTR_E_TD_BADFIELDLST;
    public static HResult VLDTR_E_CN_BADTYPE;
    public static HResult VLDTR_E_TD_ENUMNOINSTFLD;
    public static HResult VLDTR_E_TD_ENUMMULINSTFLD;
    public static HResult VLDTR_E_INTERRUPTED;
    public static HResult VLDTR_E_NOTINIT;
    public static HResult VLDTR_E_IFACE_NOTIFACE;
    public static HResult VLDTR_E_FD_RVAHASNORVA;
    public static HResult VLDTR_E_FD_RVAHASZERORVA;
    public static HResult VLDTR_E_MD_RVAANDIMPLMAP;
    public static HResult VLDTR_E_TD_EXTRAFLAGS;
    public static HResult VLDTR_E_TD_EXTENDSITSELF;
    public static HResult VLDTR_E_TD_SYSVTNOTEXTOBJ;
    public static HResult VLDTR_E_TD_EXTTYPESPEC;
    public static HResult VLDTR_E_TD_VTNOSIZE;
    public static HResult VLDTR_E_TD_IFACESEALED;
    public static HResult VLDTR_E_NC_BADNESTED;
    public static HResult VLDTR_E_NC_BADENCLOSER;
    public static HResult VLDTR_E_NC_DUP;
    public static HResult VLDTR_E_NC_DUPENCLOSER;
    public static HResult VLDTR_E_FRVA_ZERORVA;
    public static HResult VLDTR_E_FRVA_BADFIELD;
    public static HResult VLDTR_E_FRVA_DUPRVA;
    public static HResult VLDTR_E_FRVA_DUPFIELD;
    public static HResult VLDTR_E_EP_BADTOKEN;
    public static HResult VLDTR_E_EP_INSTANCE;
    public static HResult VLDTR_E_TD_ENUMFLDBADTYPE;
    public static HResult VLDTR_E_MD_BADRVA;
    public static HResult VLDTR_E_FD_LITERALNODEFAULT;
    public static HResult VLDTR_E_IFACE_METHNOTIMPL;
    public static HResult VLDTR_E_CA_BADPARENT;
    public static HResult VLDTR_E_CA_BADTYPE;
    public static HResult VLDTR_E_CA_NOTCTOR;
    public static HResult VLDTR_E_CA_BADSIG;
    public static HResult VLDTR_E_CA_NOSIG;
    public static HResult VLDTR_E_CA_BADPROLOG;
    public static HResult VLDTR_E_MD_BADLOCALSIGTOK;
    public static HResult VLDTR_E_MD_BADHEADER;
    public static HResult VLDTR_E_EP_TOOMANYARGS;
    public static HResult VLDTR_E_EP_BADRET;
    public static HResult VLDTR_E_EP_BADARG;
    public static HResult VLDTR_E_SIG_BADVOID;
    public static HResult VLDTR_E_IFACE_METHMULTIMPL;
    public static HResult VLDTR_E_GP_NAMENULL;
    public static HResult VLDTR_E_GP_OWNERNIL;
    public static HResult VLDTR_E_GP_DUPNAME;
    public static HResult VLDTR_E_GP_DUPNUMBER;
    public static HResult VLDTR_E_GP_NONSEQ_BY_OWNER;
    public static HResult VLDTR_E_GP_NONSEQ_BY_NUMBER;
    public static HResult VLDTR_E_GP_UNEXPECTED_OWNER_FOR_VARIANT_VAR;
    public static HResult VLDTR_E_GP_ILLEGAL_VARIANT_MVAR;
    public static HResult VLDTR_E_GP_ILLEGAL_VARIANCE_FLAGS;
    public static HResult VLDTR_E_GP_REFANDVALUETYPE;
    public static HResult VLDTR_E_GPC_OWNERNIL;
    public static HResult VLDTR_E_GPC_DUP;
    public static HResult VLDTR_E_GPC_NONCONTIGUOUS;
    public static HResult VLDTR_E_MS_METHODNIL;
    public static HResult VLDTR_E_MS_DUP;
    public static HResult VLDTR_E_MS_BADCALLINGCONV;
    public static HResult VLDTR_E_MS_MISSARITY;
    public static HResult VLDTR_E_MS_MISSARG;
    public static HResult VLDTR_E_MS_ARITYMISMATCH;
    public static HResult VLDTR_E_MS_METHODNOTGENERIC;
    public static HResult VLDTR_E_SIG_MISSARITY;
    public static HResult VLDTR_E_SIG_ARITYMISMATCH;
    public static HResult VLDTR_E_MD_GENERIC_CCTOR;
    public static HResult VLDTR_E_MD_GENERIC_CTOR;
    public static HResult VLDTR_E_MD_GENERIC_IMPORT;
    public static HResult VLDTR_E_MD_GENERIC_BADCALLCONV;
    public static HResult VLDTR_E_MD_GENERIC_GLOBAL;
    public static HResult VLDTR_E_EP_GENERIC_METHOD;
    public static HResult VLDTR_E_MD_MISSARITY;
    public static HResult VLDTR_E_MD_ARITYZERO;
    public static HResult VLDTR_E_SIG_ARITYZERO;
    public static HResult VLDTR_E_MS_ARITYZERO;
    public static HResult VLDTR_E_MD_GPMISMATCH;
    public static HResult VLDTR_E_EP_GENERIC_TYPE;
    public static HResult VLDTR_E_MI_DECLNOTGENERIC;
    public static HResult VLDTR_E_MI_IMPLNOTGENERIC;
    public static HResult VLDTR_E_MI_ARITYMISMATCH;
    public static HResult VLDTR_E_TD_EXTBADTYPESPEC;
    public static HResult VLDTR_E_SIG_BYREFINST;
    public static HResult VLDTR_E_MS_BYREFINST;
    public static HResult VLDTR_E_TS_EMPTY;
    public static HResult VLDTR_E_TS_HASSENTINALS;
    public static HResult VLDTR_E_TD_GENERICHASEXPLAYOUT;
    public static HResult VLDTR_E_SIG_BADTOKTYPE;
    public static HResult VLDTR_E_IFACE_METHNOTIMPLTHISMOD;
    public static HResult CORDBG_E_UNRECOVERABLE_ERROR;
    public static HResult CORDBG_E_PROCESS_TERMINATED;
    public static HResult CORDBG_E_PROCESS_NOT_SYNCHRONIZED;
    public static HResult CORDBG_E_CLASS_NOT_LOADED;
    public static HResult CORDBG_E_INDEX_NOT_FOUND;
    public static HResult CORDBG_E_IL_VAR_NOT_AVAILABLE;
    public static HResult CORDBG_E_BAD_REFERENCE_VALUE;
    public static HResult CORDBG_E_FIELD_NOT_AVAILABLE;
    public static HResult CORDBG_E_NON_NATIVE_FRAME;
    public static HResult CORDBG_E_NONCONTINUABLE_EXCEPTION;
    public static HResult CORDBG_E_CODE_NOT_AVAILABLE;
    public static HResult CORDBG_E_FUNCTION_NOT_IL;
    public static HResult CORDBG_S_BAD_START_SEQUENCE_POINT;
    public static HResult CORDBG_S_BAD_END_SEQUENCE_POINT;
    public static HResult CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP;
    public static HResult CORDBG_E_CANT_SET_IP_INTO_FINALLY;
    public static HResult CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY;
    public static HResult CORDBG_E_CANT_SET_IP_INTO_CATCH;
    public static HResult CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME;
    public static HResult CORDBG_E_SET_IP_IMPOSSIBLE;
    public static HResult CORDBG_E_FUNC_EVAL_BAD_START_POINT;
    public static HResult CORDBG_E_INVALID_OBJECT;
    public static HResult CORDBG_E_FUNC_EVAL_NOT_COMPLETE;
    public static HResult CORDBG_S_FUNC_EVAL_HAS_NO_RESULT;
    public static HResult CORDBG_S_VALUE_POINTS_TO_VOID;
    public static HResult CORDBG_E_INPROC_NOT_IMPL;
    public static HResult CORDBG_S_FUNC_EVAL_ABORTED;
    public static HResult CORDBG_E_STATIC_VAR_NOT_AVAILABLE;
    public static HResult CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS;
    public static HResult CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER;
    public static HResult CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE;
    public static HResult CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64;
    public static HResult CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64;
    public static HResult CORDBG_E_REMOTE_CONNECTION_CONN_RESET;
    public static HResult CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE;
    public static HResult CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR;
    public static HResult CORDBG_E_CANT_SET_TO_JMC;
    public static HResult CORDBG_E_BAD_THREAD_STATE;
    public static HResult CORDBG_E_DEBUGGER_ALREADY_ATTACHED;
    public static HResult CORDBG_E_SUPERFLOUS_CONTINUE;
    public static HResult CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME;
    public static HResult CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE;
    public static HResult CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED;
    public static HResult CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION;
    public static HResult CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL;
    public static HResult CORDBG_E_PROCESS_DETACHED;
    public static HResult CORDBG_E_ENC_METHOD_SIG_CHANGED;
    public static HResult CORDBG_E_ENC_METHOD_NO_LOCAL_SIG;
    public static HResult CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS;
    public static HResult CORDBG_E_ENC_CANT_CHANGE_FIELD;
    public static HResult CORDBG_E_ENC_CANT_ADD_NON_PRIVATE_MEMBER;
    public static HResult CORDBG_E_FIELD_NOT_STATIC;
    public static HResult CORDBG_E_FIELD_NOT_INSTANCE;
    public static HResult CORDBG_E_ENC_ZAPPED_WITHOUT_ENC;
    public static HResult CORDBG_E_ENC_BAD_METHOD_INFO;
    public static HResult CORDBG_E_ENC_JIT_CANT_UPDATE;
    public static HResult CORDBG_E_ENC_MISSING_CLASS;
    public static HResult CORDBG_E_ENC_INTERNAL_ERROR;
    public static HResult CORDBG_E_ENC_HANGING_FIELD;
    public static HResult CORDBG_E_MODULE_NOT_LOADED;
    public static HResult CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS;
    public static HResult CORDBG_E_UNABLE_TO_SET_BREAKPOINT;
    public static HResult CORDBG_E_DEBUGGING_NOT_POSSIBLE;
    public static HResult CORDBG_E_KERNEL_DEBUGGER_ENABLED;
    public static HResult CORDBG_E_KERNEL_DEBUGGER_PRESENT;
    public static HResult CORDBG_E_HELPER_THREAD_DEAD;
    public static HResult CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE;
    public static HResult CORDBG_E_INCOMPATIBLE_PROTOCOL;
    public static HResult CORDBG_E_TOO_MANY_PROCESSES;
    public static HResult CORDBG_E_INTEROP_NOT_SUPPORTED;
    public static HResult CORDBG_E_NO_REMAP_BREAKPIONT;
    public static HResult CORDBG_E_OBJECT_NEUTERED;
    public static HResult CORDBG_E_APPDOMAIN_MISMATCH;
    public static HResult CORDBG_E_READVIRTUAL_FAILURE;
    public static HResult CORDBG_E_MISSING_METADATA;
    public static HResult CORDBG_E_TARGET_INCONSISTENT;
    public static HResult CORPROF_E_FUNCTION_NOT_COMPILED;
    public static HResult CORPROF_E_DATAINCOMPLETE;
    public static HResult CORPROF_E_NOT_REJITABLE_METHODS;
    public static HResult CORPROF_E_CANNOT_UPDATE_METHOD;
    public static HResult CORPROF_E_FUNCTION_NOT_IL;
    public static HResult CORPROF_E_NOT_MANAGED_THREAD;
    public static HResult CORPROF_E_CALL_ONLY_FROM_INIT;
    public static HResult CORPROF_E_INPROC_NOT_ENABLED;
    public static HResult CORPROF_E_JITMAPS_NOT_ENABLED;
    public static HResult CORPROF_E_INPROC_ALREADY_BEGUN;
    public static HResult CORPROF_E_INPROC_NOT_AVAILABLE;
    public static HResult CORPROF_E_NOT_YET_AVAILABLE;
    public static HResult CORPROF_E_TYPE_IS_PARAMETERIZED;
    public static HResult CORPROF_E_FUNCTION_IS_PARAMETERIZED;
    public static HResult SECURITY_E_XML_TO_ASN_ENCODING;
    public static HResult SECURITY_E_INCOMPATIBLE_SHARE;
    public static HResult SECURITY_E_UNVERIFIABLE;
    public static HResult SECURITY_E_INCOMPATIBLE_EVIDENCE;
    public static HResult CLDB_E_INTERNALERROR;
    public static HResult CORSEC_E_DECODE_SET;
    public static HResult CORSEC_E_ENCODE_SET;
    public static HResult CORSEC_E_UNSUPPORTED_FORMAT;
    public static HResult SN_CRYPTOAPI_CALL_FAILED;
    public static HResult CORSEC_E_CRYPTOAPI_CALL_FAILED;
    public static HResult SN_NO_SUITABLE_CSP;
    public static HResult CORSEC_E_NO_SUITABLE_CSP;
    public static HResult CORSEC_E_INVALID_ATTR;
    public static HResult CORSEC_E_POLICY_EXCEPTION;
    public static HResult CORSEC_E_MIN_GRANT_FAIL;
    public static HResult CORSEC_E_NO_EXEC_PERM;
    public static HResult CORSEC_E_XMLSYNTAX;
    public static HResult CORSEC_E_INVALID_STRONGNAME;
    public static HResult CORSEC_E_MISSING_STRONGNAME;
    public static HResult CORSEC_E_CONTAINER_NOT_FOUND;
    public static HResult CORSEC_E_INVALID_IMAGE_FORMAT;
    public static HResult CORSEC_E_INVALID_PUBLICKEY;
    public static HResult CORSEC_E_SIGNATURE_MISMATCH;
    public static HResult CORSEC_E_CRYPTO;
    public static HResult CORSEC_E_CRYPTO_UNEX_OPER;
    public static HResult CORSECATTR_E_BAD_ATTRIBUTE;
    public static HResult CORSECATTR_E_MISSING_CONSTRUCTOR;
    public static HResult CORSECATTR_E_FAILED_TO_CREATE_PERM;
    public static HResult CORSECATTR_E_BAD_ACTION_ASM;
    public static HResult CORSECATTR_E_BAD_ACTION_OTHER;
    public static HResult CORSECATTR_E_BAD_PARENT;
    public static HResult CORSECATTR_E_TRUNCATED;
    public static HResult CORSECATTR_E_BAD_VERSION;
    public static HResult CORSECATTR_E_BAD_ACTION;
    public static HResult CORSECATTR_E_NO_SELF_REF;
    public static HResult CORSECATTR_E_BAD_NONCAS;
    public static HResult CORSECATTR_E_ASSEMBLY_LOAD_FAILED;
    public static HResult CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX;
    public static HResult CORSECATTR_E_TYPE_LOAD_FAILED;
    public static HResult CORSECATTR_E_TYPE_LOAD_FAILED_EX;
    public static HResult CORSECATTR_E_ABSTRACT;
    public static HResult CORSECATTR_E_UNSUPPORTED_TYPE;
    public static HResult CORSECATTR_E_UNSUPPORTED_ENUM_TYPE;
    public static HResult CORSECATTR_E_NO_FIELD;
    public static HResult CORSECATTR_E_NO_PROPERTY;
    public static HResult CORSECATTR_E_EXCEPTION;
    public static HResult CORSECATTR_E_EXCEPTION_HR;
    public static HResult ISS_E_ISOSTORE;
    public static HResult ISS_E_OPEN_STORE_FILE;
    public static HResult ISS_E_OPEN_FILE_MAPPING;
    public static HResult ISS_E_MAP_VIEW_OF_FILE;
    public static HResult ISS_E_GET_FILE_SIZE;
    public static HResult ISS_E_CREATE_MUTEX;
    public static HResult ISS_E_LOCK_FAILED;
    public static HResult ISS_E_FILE_WRITE;
    public static HResult ISS_E_SET_FILE_POINTER;
    public static HResult ISS_E_CREATE_DIR;
    public static HResult ISS_E_STORE_NOT_OPEN;
    public static HResult ISS_E_CORRUPTED_STORE_FILE;
    public static HResult ISS_E_STORE_VERSION;
    public static HResult ISS_E_FILE_NOT_MAPPED;
    public static HResult ISS_E_BLOCK_SIZE_TOO_SMALL;
    public static HResult ISS_E_ALLOC_TOO_LARGE;
    public static HResult ISS_E_USAGE_WILL_EXCEED_QUOTA;
    public static HResult ISS_E_TABLE_ROW_NOT_FOUND;
    public static HResult ISS_E_DEPRECATE;
    public static HResult ISS_E_CALLER;
    public static HResult ISS_E_PATH_LENGTH;
    public static HResult ISS_E_MACHINE;
    public static HResult ISS_E_MACHINE_DACL;
    public static HResult ISS_E_ISOSTORE_START;
    public static HResult ISS_E_ISOSTORE_END;
    public static HResult COR_E_APPLICATION;
    public static HResult COR_E_ARGUMENT;
    public static HResult COR_E_ARGUMENTOUTOFRANGE;
    public static HResult COR_E_ARITHMETIC;
    public static HResult COR_E_ARRAYTYPEMISMATCH;
    public static HResult COR_E_CONTEXTMARSHAL;
    public static HResult COR_E_TIMEOUT;
    public static HResult COR_E_KEYNOTFOUND;
    public static HResult COR_E_DEVICESNOTSUPPORTED;
    public static HResult COR_E_DIVIDEBYZERO;
    public static HResult COR_E_EXCEPTION;
    public static HResult COR_E_EXECUTIONENGINE;
    public static HResult COR_E_FIELDACCESS;
    public static HResult COR_E_FORMAT;
    public static HResult COR_E_BADIMAGEFORMAT;
    public static HResult COR_E_ASSEMBLYEXPECTED;
    public static HResult COR_E_TYPEUNLOADED;
    public static HResult COR_E_INDEXOUTOFRANGE;
    public static HResult COR_E_INVALIDCAST;
    public static HResult COR_E_INVALIDOPERATION;
    public static HResult COR_E_INVALIDPROGRAM;
    public static HResult COR_E_MEMBERACCESS;
    public static HResult COR_E_METHODACCESS;
    public static HResult COR_E_MISSINGFIELD;
    public static HResult COR_E_MISSINGMANIFESTRESOURCE;
    public static HResult COR_E_MISSINGMEMBER;
    public static HResult COR_E_MISSINGMETHOD;
    public static HResult COR_E_MISSINGSATELLITEASSEMBLY;
    public static HResult COR_E_MULTICASTNOTSUPPORTED;
    public static HResult COR_E_NOTFINITENUMBER;
    public static HResult COR_E_DUPLICATEWAITOBJECT;
    public static HResult COR_E_PLATFORMNOTSUPPORTED;
    public static HResult COR_E_NOTSUPPORTED;
    public static HResult COR_E_NULLREFERENCE;
    public static HResult COR_E_OUTOFMEMORY;
    public static HResult COR_E_OVERFLOW;
    public static HResult COR_E_RANK;
    public static HResult COR_E_REMOTING;
    public static HResult COR_E_SERVER;
    public static HResult COR_E_SERVICEDCOMPONENT;
    public static HResult COR_E_SECURITY;
    public static HResult COR_E_SERIALIZATION;
    public static HResult COR_E_STACKOVERFLOW;
    public static HResult COR_E_SYNCHRONIZATIONLOCK;
    public static HResult COR_E_SYSTEM;
    public static HResult COR_E_THREADABORTED;
    public static HResult COR_E_OPERATIONCANCELED;
    public static HResult COR_E_NOTCANCELABLE;
    public static HResult COR_E_THREADINTERRUPTED;
    public static HResult COR_E_THREADSTATE;
    public static HResult COR_E_THREADSTOP;
    public static HResult COR_E_TYPEINITIALIZATION;
    public static HResult COR_E_TYPELOAD;
    public static HResult COR_E_ENTRYPOINTNOTFOUND;
    public static HResult COR_E_DLLNOTFOUND;
    public static HResult COR_E_UNAUTHORIZEDACCESS;
    public static HResult COR_E_VERIFICATION;
    public static HResult COR_E_INVALIDCOMOBJECT;
    public static HResult COR_E_COMOBJECTINUSE;
    public static HResult COR_E_SEMAPHOREFULL;
    public static HResult COR_E_WAITHANDLECANNOTBEOPENED;
    public static HResult COR_E_ABANDONEDMUTEX;
    public static HResult COR_E_MARSHALDIRECTIVE;
    public static HResult COR_E_INVALIDOLEVARIANTTYPE;
    public static HResult COR_E_SAFEARRAYTYPEMISMATCH;
    public static HResult COR_E_SAFEARRAYRANKMISMATCH;
    public static HResult COR_E_DATAMISALIGNED;
    public static HResult COR_E_TARGETPARAMCOUNT;
    public static HResult COR_E_AMBIGUOUSMATCH;
    public static HResult COR_E_INVALIDFILTERCRITERIA;
    public static HResult COR_E_REFLECTIONTYPELOAD;
    public static HResult COR_E_TARGET;
    public static HResult COR_E_TARGETINVOCATION;
    public static HResult COR_E_CUSTOMATTRIBUTEFORMAT;
    public static HResult COR_E_FILELOAD;
    public static HResult COR_E_IO;
    public static HResult COR_E_OBJECTDISPOSED;
    public static HResult COR_E_HOSTPROTECTION;
    public static HResult COR_E_FAILFAST;
    public static HResult CLR_E_SHIM_RUNTIMELOAD;
    public static HResult CLR_E_SHIM_RUNTIMEEXPORT;
    public static HResult CLR_E_SHIM_INSTALLROOT;
    public static HResult CLR_E_SHIM_INSTALLCOMP;
    public static HResult VER_E_HRESULT;
    public static HResult VER_E_OFFSET;
    public static HResult VER_E_OPCODE;
    public static HResult VER_E_OPERAND;
    public static HResult VER_E_TOKEN;
    public static HResult VER_E_EXCEPT;
    public static HResult VER_E_STACK_SLOT;
    public static HResult VER_E_LOC;
    public static HResult VER_E_ARG;
    public static HResult VER_E_FOUND;
    public static HResult VER_E_EXPECTED;
    public static HResult VER_E_LOC_BYNAME;
    public static HResult VER_E_UNKNOWN_OPCODE;
    public static HResult VER_E_SIG_CALLCONV;
    public static HResult VER_E_SIG_ELEMTYPE;
    public static HResult VER_E_RET_SIG;
    public static HResult VER_E_FIELD_SIG;
    public static HResult VER_E_INTERNAL;
    public static HResult VER_E_STACK_TOO_LARGE;
    public static HResult VER_E_ARRAY_NAME_LONG;
    public static HResult VER_E_FALLTHRU;
    public static HResult VER_E_TRY_GTEQ_END;
    public static HResult VER_E_TRYEND_GT_CS;
    public static HResult VER_E_HND_GTEQ_END;
    public static HResult VER_E_HNDEND_GT_CS;
    public static HResult VER_E_FLT_GTEQ_CS;
    public static HResult VER_E_TRY_START;
    public static HResult VER_E_HND_START;
    public static HResult VER_E_FLT_START;
    public static HResult VER_E_TRY_OVERLAP;
    public static HResult VER_E_TRY_EQ_HND_FIL;
    public static HResult VER_E_TRY_SHARE_FIN_FAL;
    public static HResult VER_E_HND_OVERLAP;
    public static HResult VER_E_HND_EQ;
    public static HResult VER_E_FIL_OVERLAP;
    public static HResult VER_E_FIL_EQ;
    public static HResult VER_E_FIL_CONT_TRY;
    public static HResult VER_E_FIL_CONT_HND;
    public static HResult VER_E_FIL_CONT_FIL;
    public static HResult VER_E_FIL_GTEQ_CS;
    public static HResult VER_E_FIL_START;
    public static HResult VER_E_FALLTHRU_EXCEP;
    public static HResult VER_E_FALLTHRU_INTO_HND;
    public static HResult VER_E_FALLTHRU_INTO_FIL;
    public static HResult VER_E_LEAVE;
    public static HResult VER_E_RETHROW;
    public static HResult VER_E_ENDFINALLY;
    public static HResult VER_E_ENDFILTER;
    public static HResult VER_E_ENDFILTER_MISSING;
    public static HResult VER_E_BR_INTO_TRY;
    public static HResult VER_E_BR_INTO_HND;
    public static HResult VER_E_BR_INTO_FIL;
    public static HResult VER_E_BR_OUTOF_TRY;
    public static HResult VER_E_BR_OUTOF_HND;
    public static HResult VER_E_BR_OUTOF_FIL;
    public static HResult VER_E_BR_OUTOF_FIN;
    public static HResult VER_E_RET_FROM_TRY;
    public static HResult VER_E_RET_FROM_HND;
    public static HResult VER_E_RET_FROM_FIL;
    public static HResult VER_E_BAD_JMP_TARGET;
    public static HResult VER_E_PATH_LOC;
    public static HResult VER_E_PATH_THIS;
    public static HResult VER_E_PATH_STACK;
    public static HResult VER_E_PATH_STACK_DEPTH;
    public static HResult VER_E_THIS;
    public static HResult VER_E_THIS_UNINIT_EXCEP;
    public static HResult VER_E_THIS_UNINIT_STORE;
    public static HResult VER_E_THIS_UNINIT_RET;
    public static HResult VER_E_THIS_UNINIT_V_RET;
    public static HResult VER_E_THIS_UNINIT_BR;
    public static HResult VER_E_LDFTN_CTOR;
    public static HResult VER_E_STACK_NOT_EQ;
    public static HResult VER_E_STACK_UNEXPECTED;
    public static HResult VER_E_STACK_EXCEPTION;
    public static HResult VER_E_STACK_OVERFLOW;
    public static HResult VER_E_STACK_UNDERFLOW;
    public static HResult VER_E_STACK_EMPTY;
    public static HResult VER_E_STACK_UNINIT;
    public static HResult VER_E_STACK_I_I4_I8;
    public static HResult VER_E_STACK_R_R4_R8;
    public static HResult VER_E_STACK_NO_R_I8;
    public static HResult VER_E_STACK_NUMERIC;
    public static HResult VER_E_STACK_OBJREF;
    public static HResult VER_E_STACK_P_OBJREF;
    public static HResult VER_E_STACK_BYREF;
    public static HResult VER_E_STACK_METHOD;
    public static HResult VER_E_STACK_ARRAY_SD;
    public static HResult VER_E_STACK_VALCLASS;
    public static HResult VER_E_STACK_P_VALCLASS;
    public static HResult VER_E_STACK_NO_VALCLASS;
    public static HResult VER_E_LOC_DEAD;
    public static HResult VER_E_LOC_NUM;
    public static HResult VER_E_ARG_NUM;
    public static HResult VER_E_TOKEN_RESOLVE;
    public static HResult VER_E_TOKEN_TYPE;
    public static HResult VER_E_TOKEN_TYPE_MEMBER;
    public static HResult VER_E_TOKEN_TYPE_FIELD;
    public static HResult VER_E_TOKEN_TYPE_SIG;
    public static HResult VER_E_UNVERIFIABLE;
    public static HResult VER_E_LDSTR_OPERAND;
    public static HResult VER_E_RET_PTR_TO_STACK;
    public static HResult VER_E_RET_VOID;
    public static HResult VER_E_RET_MISSING;
    public static HResult VER_E_RET_EMPTY;
    public static HResult VER_E_RET_UNINIT;
    public static HResult VER_E_ARRAY_ACCESS;
    public static HResult VER_E_ARRAY_V_STORE;
    public static HResult VER_E_ARRAY_SD;
    public static HResult VER_E_ARRAY_SD_PTR;
    public static HResult VER_E_ARRAY_FIELD;
    public static HResult VER_E_ARGLIST;
    public static HResult VER_E_VALCLASS;
    public static HResult VER_E_METHOD_ACCESS;
    public static HResult VER_E_FIELD_ACCESS;
    public static HResult VER_E_DEAD;
    public static HResult VER_E_FIELD_STATIC;
    public static HResult VER_E_FIELD_NO_STATIC;
    public static HResult VER_E_ADDR;
    public static HResult VER_E_ADDR_BYREF;
    public static HResult VER_E_ADDR_LITERAL;
    public static HResult VER_E_INITONLY;
    public static HResult VER_E_THROW;
    public static HResult VER_E_CALLVIRT_VALCLASS;
    public static HResult VER_E_CALL_SIG;
    public static HResult VER_E_CALL_STATIC;
    public static HResult VER_E_CTOR;
    public static HResult VER_E_CTOR_VIRT;
    public static HResult VER_E_CTOR_OR_SUPER;
    public static HResult VER_E_CTOR_MUL_INIT;
    public static HResult VER_E_SIG;
    public static HResult VER_E_SIG_ARRAY;
    public static HResult VER_E_SIG_ARRAY_PTR;
    public static HResult VER_E_SIG_ARRAY_BYREF;
    public static HResult VER_E_SIG_ELEM_PTR;
    public static HResult VER_E_SIG_VARARG;
    public static HResult VER_E_SIG_VOID;
    public static HResult VER_E_SIG_BYREF_BYREF;
    public static HResult VER_E_CODE_SIZE_ZERO;
    public static HResult VER_E_BAD_VARARG;
    public static HResult VER_E_TAIL_CALL;
    public static HResult VER_E_TAIL_BYREF;
    public static HResult VER_E_TAIL_RET;
    public static HResult VER_E_TAIL_RET_VOID;
    public static HResult VER_E_TAIL_RET_TYPE;
    public static HResult VER_E_TAIL_STACK_EMPTY;
    public static HResult VER_E_METHOD_END;
    public static HResult VER_E_BAD_BRANCH;
    public static HResult VER_E_FIN_OVERLAP;
    public static HResult VER_E_LEXICAL_NESTING;
    public static HResult VER_E_VOLATILE;
    public static HResult VER_E_UNALIGNED;
    public static HResult VER_E_INNERMOST_FIRST;
    public static HResult VER_E_CALLI_VIRTUAL;
    public static HResult VER_E_CALL_ABSTRACT;
    public static HResult VER_E_STACK_UNEXP_ARRAY;
    public static HResult VER_E_NOT_IN_GC_HEAP;
    public static HResult VER_E_TRY_N_EMPTY_STACK;
    public static HResult VER_E_DLGT_CTOR;
    public static HResult VER_E_DLGT_BB;
    public static HResult VER_E_DLGT_PATTERN;
    public static HResult VER_E_DLGT_LDFTN;
    public static HResult VER_E_FTN_ABSTRACT;
    public static HResult VER_E_SIG_C_VC;
    public static HResult VER_E_SIG_VC_C;
    public static HResult VER_E_BOX_PTR_TO_STACK;
    public static HResult VER_E_SIG_BYREF_TB_AH;
    public static HResult VER_E_SIG_ARRAY_TB_AH;
    public static HResult VER_E_ENDFILTER_STACK;
    public static HResult VER_E_DLGT_SIG_I;
    public static HResult VER_E_DLGT_SIG_O;
    public static HResult VER_E_RA_PTR_TO_STACK;
    public static HResult VER_E_CATCH_VALUE_TYPE;
    public static HResult VER_E_CATCH_BYREF;
    public static HResult VER_E_FIL_PRECEED_HND;
    public static HResult VER_E_LDVIRTFTN_STATIC;
    public static HResult VER_E_CALLVIRT_STATIC;
    public static HResult VER_E_INITLOCALS;
    public static HResult VER_E_BR_TO_EXCEPTION;
    public static HResult VER_E_CALL_CTOR;
    public static HResult VER_E_VALCLASS_OBJREF_VAR;
    public static HResult VER_E_STACK_P_VALCLASS_OBJREF_VAR;
    public static HResult VER_E_SIG_VAR_PARAM;
    public static HResult VER_E_SIG_MVAR_PARAM;
    public static HResult VER_E_SIG_VAR_ARG;
    public static HResult VER_E_SIG_MVAR_ARG;
    public static HResult VER_E_SIG_GENERICINST;
    public static HResult VER_E_SIG_METHOD_INST;
    public static HResult VER_E_SIG_METHOD_PARENT_INST;
    public static HResult VER_E_SIG_FIELD_PARENT_INST;
    public static HResult VER_E_CALLCONV_NOT_GENERICINST;
    public static HResult VER_E_TOKEN_BAD_METHOD_SPEC;
    public static HResult VER_E_BAD_READONLY_PREFIX;
    public static HResult VER_E_BAD_CONSTRAINED_PREFIX;
    public static HResult VER_E_CIRCULAR_VAR_CONSTRAINTS;
    public static HResult VER_E_CIRCULAR_MVAR_CONSTRAINTS;
    public static HResult VER_E_UNSATISFIED_METHOD_INST;
    public static HResult VER_E_UNSATISFIED_METHOD_PARENT_INST;
    public static HResult VER_E_UNSATISFIED_FIELD_PARENT_INST;
    public static HResult VER_E_UNSATISFIED_BOX_OPERAND;
    public static HResult VER_E_CONSTRAINED_CALL_WITH_NON_BYREF_THIS;
    public static HResult VER_E_CONSTRAINED_OF_NON_VARIABLE_TYPE;
    public static HResult VER_E_READONLY_UNEXPECTED_CALLEE;
    public static HResult VER_E_READONLY_ILLEGAL_WRITE;
    public static HResult VER_E_READONLY_IN_MKREFANY;
    public static HResult VER_E_UNALIGNED_ALIGNMENT;
    public static HResult VER_E_TAILCALL_INSIDE_EH;
    public static HResult VER_E_BACKWARD_BRANCH;
    public static HResult VER_E_CALL_TO_VTYPE_BASE;
    public static HResult VER_E_NEWOBJ_OF_ABSTRACT_CLASS;
    public static HResult VER_E_FIELD_OVERLAP;
    public static HResult VER_E_BAD_PE;
    public static HResult VER_E_BAD_MD;
    public static HResult VER_E_BAD_APPDOMAIN;
    public static HResult VER_E_TYPELOAD;
    public static HResult VER_E_PE_LOAD;
    public static HResult VER_E_WRITE_RVA_STATIC;
    public static HResult CORDBG_E_THREAD_NOT_SCHEDULED;
    public static HResult CORDBG_E_HANDLE_HAS_BEEN_DISPOSED;
    public static HResult CORDBG_E_NONINTERCEPTABLE_EXCEPTION;
    public static HResult CORDBG_E_CANT_UNWIND_ABOVE_CALLBACK;
    public static HResult CORDBG_E_INTERCEPT_FRAME_ALREADY_SET;
    public static HResult CORDBG_E_NO_NATIVE_PATCH_AT_ADDR;
    public static HResult CORDBG_E_MUST_BE_INTEROP_DEBUGGING;
    public static HResult CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR;
    public static HResult CORDBG_E_TIMEOUT;
    public static HResult CORDBG_E_CANT_CALL_ON_THIS_THREAD;
    public static HResult CORDBG_E_ENC_INFOLESS_METHOD;
    public static HResult CORDBG_E_ENC_NESTED_HANLDERS;
    public static HResult CORDBG_E_ENC_IN_FUNCLET;
    public static HResult CORDBG_E_ENC_LOCALLOC;
    public static HResult CORDBG_E_ENC_EDIT_NOT_SUPPORTED;
    public static HResult CORDBG_E_FEABORT_DELAYED_UNTIL_THREAD_RESUMED;
    public static HResult CORDBG_E_NOTREADY;
    public static HResult CORDBG_E_CANNOT_RESOLVE_ASSEMBLY;
    public static HResult CORDBG_E_MUST_BE_IN_LOAD_MODULE;
    public static HResult CORDBG_E_CANNOT_BE_ON_ATTACH;
    public static HResult CORDBG_S_NOT_ALL_BITS_SET;
    public static HResult CORDBG_E_NGEN_NOT_SUPPORTED;
    public static HResult CORDBG_E_ILLEGAL_SHUTDOWN_ORDER;
    public static HResult CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS;
    public static HResult CORDBG_E_MUST_BE_IN_CREATE_PROCESS;
    public static HResult CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS;
    public static HResult CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS;
    public static HResult CORDBG_E_CANT_INTEROP_STEP_OUT;
    public static HResult CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS;
    public static HResult CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW;
    public static HResult CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT;
    public static HResult CORDBG_E_ILLEGAL_IN_PROLOG;
    public static HResult CORDBG_E_ILLEGAL_IN_NATIVE_CODE;
    public static HResult CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE;
    public static HResult PEFMT_E_NO_CONTENTS;
    public static HResult PEFMT_E_NO_NTHEADERS;
    public static HResult PEFMT_E_64BIT;
    public static HResult PEFMT_E_NO_CORHEADER;
    public static HResult PEFMT_E_NOT_ILONLY;
    public static HResult PEFMT_E_IMPORT_DLLS;
    public static HResult PEFMT_E_EXE_NOENTRYPOINT;
    public static HResult PEFMT_E_BASE_RELOCS;
    public static HResult PEFMT_E_ENTRYPOINT;
    public static HResult PEFMT_E_ZERO_SIZEOFCODE;
    public static HResult PEFMT_E_BAD_CORHEADER;
    public static HResult S_EVAL_EXCEPTION;
    public static HResult S_EVAL_ABORTED;
    public static HResult S_EVAL_TIMEDOUT;
    public static HResult S_EVAL_NO_RESULT;
    public static HResult S_EVAL_THREAD_SUSPENDED;
    public static HResult S_EVAL_THREAD_SLEEP_WAIT_JOIN;
    public static HResult S_EVAL_BAD_THREAD_STATE;
    public static HResult S_EVAL_THREAD_NOT_STARTED;
    public static HResult S_EVAL_BAD_START_POINT;
    public static HResult S_EVAL_WEB_METHOD;
    public static HResult S_EVAL_STOP_REQUESTED;
    public static HResult S_EVAL_SUSPEND_REQUESTED;
    public static HResult S_EVAL_UNSCHEDULED_FIBER;
    public static HResult S_EVAL_PRIOREVALTIMEDOUT;
    public static HResult S_EVAL_THREADSLIP_REQUIRED;
    public static HResult S_EVAL_RUDE_ABORTED;
    public static HResult E_EVAL_OVERFLOW_HAS_OCCURRED;
    public static HResult E_EVAL_MEMORY_ALIAS_ERROR;
    public static HResult E_EVAL_ILLEGAL_SIDE_EFFECT;
    public static HResult E_EVAL_INTERPRETER_ERROR;
    public static HResult E_EVAL_FUNCEVAL_IN_MINIDUMP;
    public static HResult E_EVAL_OUTOFMEMORY_HAS_OCCURRED;
    public static HResult E_EVAL_USEREXCEPTION;
    public static HResult E_SETVALUE_VALUE_CANNOT_BE_SET;
    public static HResult E_INVALID_MEMORY_ADDRESS;
    public static HResult E_NULL_OUT_PARAM;
    public static HResult E_EVAL_REAL_FUNCEVAL_DISABLED;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.HRUtility : object {
    internal static void AssertedCheckHR(HResult hr);
    internal static void AssertedCheckHR(int hr);
    internal static bool Succeeded(HResult hr);
    internal static bool Failed(HResult hr);
    internal static Exception GetExceptionForHR(HResult hr);
    internal static HResult GetHRForException(Exception e);
    internal static TDest AssertedCast(object obj);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IArithmeticProvider {
    public abstract virtual Slot Add(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot AddOvf(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot AddOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Div(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot DivUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Mul(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot MulOvf(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot MulOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Neg(VirtualMachine vm, Slot s);
    public abstract virtual Slot Rem(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot RemUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Sub(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot SubOvf(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot SubOvfUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot And(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Or(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Not(VirtualMachine vm, Slot s);
    public abstract virtual Slot Shl(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Shr(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot ShrUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual Slot Xor(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool Beq(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool Bge(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BgeUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool Bgt(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BgtUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool Ble(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BleUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool Blt(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BltUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BneUn(VirtualMachine vm, Slot s1, Slot s2);
    public abstract virtual bool BrTrue(VirtualMachine vm, Slot s);
    public abstract virtual bool BrFalse(VirtualMachine vm, Slot s);
    public abstract virtual Slot ConvertUnsafe(VirtualMachine vm, Slot s, CorElementType targetType);
    public abstract virtual Slot ConvertSafe(VirtualMachine vm, Slot s, CorElementType targetType);
    public abstract virtual Slot ConvertSafeUnsigned(VirtualMachine vm, Slot s, CorElementType targetType);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IClrNcHostService {
    public abstract virtual IEnumerable`1<MethodHookDescriptor> GetHostMethodHooks(ITypeUniverse typeUniverse);
    public abstract virtual IObjectLayout GetObjectLayout(Type type);
    public abstract virtual Slot GetSlotForRuntimeMethodHandle(IHost host, MethodBase method);
    public abstract virtual MethodBase TryResolveFunctionPointerDestination(Slot functionPointerSlot);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IHost {
    public ITypeUniverse TypeUniverse { get; }
    public IVirtualDispatchResolver VirtualDispatchResolver { get; }
    public ISlotFactory SlotFactory { get; }
    public IArithmeticProvider ArithmeticProvider { get; }
    public StubTable StubTable { get; }
    public CommonSlotConst CommonConst { get; }
    public abstract virtual Slot ReadStaticField(FieldInfo field, VirtualMachine virtualMachine);
    public abstract virtual void WriteStaticField(FieldInfo field, Slot value, VirtualMachine virtualMachine);
    public abstract virtual Slot GetStaticFieldAddress(FieldInfo field, VirtualMachine virtualMachine);
    public abstract virtual void EnsureStaticCtorRun(Type type, bool fAccessingStaticField, VirtualMachine vm);
    public abstract virtual void GetMethodHooks(MethodBase method, List`1<MethodHookDelegate> hooks, MethodBase& ilHookMethod);
    public abstract virtual MethodHookDelegate TryHookCallInInspectionMethod(MethodBase method);
    public abstract virtual VirtualMachine CreateVM();
    public abstract virtual ITypeUniverse get_TypeUniverse();
    public abstract virtual IVirtualDispatchResolver get_VirtualDispatchResolver();
    public abstract virtual ISlotFactory get_SlotFactory();
    public abstract virtual IArithmeticProvider get_ArithmeticProvider();
    public abstract virtual StubTable get_StubTable();
    public abstract virtual CommonSlotConst get_CommonConst();
    public abstract virtual bool AreSlotsEqual(Slot s1, Slot s2);
    public abstract virtual IVirtualStackFrame CreateStackFrameForMethodCall(VirtualMachine virtualMachine, MethodBase method, IVirtualStackFrame caller);
    public abstract virtual bool IsTransparentProxy(Type value);
    public abstract virtual ExceptionAction GetInterpreterExecutionExceptionHandler(VirtualMachine vm, InterpreterExecutionException exception);
    public abstract virtual void OnFirstChanceException(Slot exception, VirtualMachine virtualMachine);
    public abstract virtual void OnExceptionUnwind(Slot exception, VirtualMachine virtualMachine);
    public abstract virtual bool IsEvaluationCanceled();
    public abstract virtual void VerifyCanInterpretMethod(MethodBase method);
    public abstract virtual bool IsClrNativeCompilation();
    public abstract virtual IClrNcHostService GetClrNcHostService();
    public abstract virtual IObjectLayout GetObjectLayout(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.ILDasmUtil : object {
    public static int StandardMaxCodeSize;
    public static int StandardMaxCodeCharacters;
    public static string GetILOffsetString(int offset);
    public static string FormatCodeBytes(Byte[] codeBytes, bool includePadding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.IlHooksIntegration.IlrunHooksAssemblyProvider : object {
    private Assembly m_ilrunHooksAssembly;
    public Assembly IlrunHooksAssembly { get; }
    private IlrunHooksAssemblyProvider(Assembly ilrunHooksAssembly);
    public static IlrunHooksAssemblyProvider Create(ITypeUniverse typeUniverse);
    public Assembly get_IlrunHooksAssembly();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.IlHooksIntegration.IlrunHooksModule : MetadataOnlyModule {
    public IlrunHooksModule(ITypeUniverse universe, MetadataFile import, IReflectionFactory factory, string modulePath);
    private Type GetKnownOrBuiltInType(string typeName);
    internal virtual Type ResolveTypeRef(ITypeReference typeReference);
    internal virtual FieldInfo ResolveFieldRef(Token memberRef, GenericContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Ilrun.IncompatibleDotnetRuntimeException : InterpreterExecutionException {
    [CompilerGeneratedAttribute]
private string <MissingItem>k__BackingField;
    public string MissingItem { get; }
    internal IncompatibleDotnetRuntimeException(string missingItem);
    [CompilerGeneratedAttribute]
public string get_MissingItem();
    internal static void ThrowIfFalse(bool condition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InfiniteRecursionGuard : object {
    private int m_counter;
    private int m_max;
    private string m_methodName;
    internal InfiniteRecursionGuard(int max, string methodName);
    internal void Enter();
    internal void Exit();
}
internal class Ilrun.InfiniteRecursionGuardClient : object {
    [NullableAttribute("2")]
private InfiniteRecursionGuard m_guard;
    [NullableContextAttribute("1")]
internal InfiniteRecursionGuardClient(InfiniteRecursionGuard guard);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InlineArrayElementAddressSlot : BaseAddressSlot {
    private InlineArraySlot m_parent;
    private int m_index;
    internal ICollection`1<Slot> ChildSlots { get; }
    public InlineArrayElementAddressSlot(InlineArraySlot parent, int index);
    public virtual string ToString();
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot LoadIndirect();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot PointerAdd(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InlineArraySlot : DefaultSlot {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Slot[] m_data;
    private Type m_type;
    private DefaultHost m_host;
    public Type ElementType;
    public int Length { get; }
    public InlineArraySlot(Type type, DefaultHost host);
    public int get_Length();
    public virtual Type GetTypeX();
    public virtual void StoreElementAtPosition(int index, Slot value);
    public virtual Slot GetElementAtPosition(int index);
    public virtual int GetArrayElementSize();
    public virtual Slot GetField(FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.Integer : object {
    private PrimitiveType m_type;
    private ulong m_value;
    private ulong m_mask;
    internal PrimitiveType Type { get; }
    internal ulong Value { get; }
    internal ulong Mask { get; }
    internal Integer(PrimitiveType type, ulong value, ulong mask);
    internal static Integer CreateFromPrimitiveValue(PrimitiveValue pv);
    internal PrimitiveType get_Type();
    internal ulong get_Value();
    internal ulong get_Mask();
    internal Nullable`1<bool> IsTrue();
    internal Integer ConvertUnsafe(PrimitiveType type);
    internal Integer ResolveIntPtr();
    private Integer ConvertUnsafeInternal(PrimitiveType type);
    internal Nullable`1<bool> CanConvertWithoutTruncation(PrimitiveType type);
    private Nullable`1<bool> IsNegative();
    private bool IsNarrowingConversion(PrimitiveType type);
    private bool IsSameSizeConversion(PrimitiveType type);
    private Integer ConvertToBoolean();
    internal Nullable`1<bool> IsEqualTo(Integer value);
    internal Nullable`1<int> CompareTo(Integer value);
    internal Integer BitAnd(Integer other);
    internal Integer BitOr(Integer other);
    internal PrimitiveValue GetAsPrimitiveValue();
    internal object GetAsBoxedValue();
    public virtual string ToString();
    internal string DebuggerDisplay();
    internal bool AreAllBitsValidForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.IntegerSlot : DefaultSlot {
    private Integer m_value;
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal IntegerSlot(Integer value, IHost host);
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot GetField(FieldInfo field);
    internal virtual Integer GetAsIntegerValue();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    internal virtual Slot TryAutoMarshal(Type expected);
    internal string DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InterpreterException : BaseInterpreterException {
    private Slot m_exceptionSlot;
    public Slot ExceptionSlot { get; }
    internal InterpreterException(Slot exceptionSlot);
    public Slot get_ExceptionSlot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InterpreterExecutionException : BaseInterpreterException {
    private IVirtualStackFrame[] m_virtualCallstack;
    public IVirtualStackFrame[] VirtualCallStack { get; }
    public InterpreterExecutionException(string message);
    public InterpreterExecutionException(string message, Exception innerException);
    public IVirtualStackFrame[] get_VirtualCallStack();
    [MemberNotNullAttribute("m_virtualCallstack")]
private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InvalidMetadataException : InterpreterExecutionException {
    public Assembly Assembly;
    public InvalidMetadataException(Assembly assembly);
}
internal class Ilrun.InvalidOpCodeException : InterpreterExecutionException {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.InvalidTypeLayoutException : InterpreterExecutionException {
    public InvalidTypeLayoutException(string message);
    public InvalidTypeLayoutException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IObjectLayout {
    public abstract virtual int GetObjectSize();
    public abstract virtual int GetFieldOffset(FieldInfo field);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IObjectMarshaller {
    public abstract virtual object GetAsHostObject(Slot s, Type expectedType);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IPrimitiveArraySlot {
    public abstract virtual bool TryBulkCopy(Byte[] data, int offset, int slotOffset, int length);
    public abstract virtual bool TryBulkReadBytes(Byte[] data, int offset, int slotOffset, int length);
}
[NullableContextAttribute("1")]
internal interface Ilrun.ISlotFactory {
    public ITypeUniverse TypeUniverse { get; }
    public abstract virtual ITypeUniverse get_TypeUniverse();
    public abstract virtual Slot CreateBox(Slot value);
    public abstract virtual Slot CreateHeapObject(Type type);
    public abstract virtual Slot CreateStackAllocatedData(int sizeInBytes, Type type, IVirtualStackFrame frame);
    public abstract virtual Slot CreateTypedReference(Slot reference, Type type);
    public abstract virtual Slot CreateArray(Type elementType, Int32[] dims, Int32[] lowerBounds);
    public abstract virtual Slot CreateNullReference(Type type);
    public abstract virtual Slot CreateValueType(Type type);
    public abstract virtual Slot GetSlotForHostObject(object value);
    public abstract virtual Slot GetSlotForPrimitive(PrimitiveValue pv);
    public abstract virtual Slot GetSlotForEnum(Type enumType, Slot value);
    public abstract virtual Slot GetSlotForRuntimeMethodHandle(MethodBase method);
    public abstract virtual Slot GetSlotForRuntimeTypeHandle(Type type, Type handleType);
    public abstract virtual Slot GetSlotForRuntimeFieldHandle(FieldInfo field);
    public abstract virtual Slot CreateReferenceToValueType(Slot value);
    public abstract virtual Slot GetDefaultValueForType(Type type);
}
[NullableContextAttribute("1")]
internal interface Ilrun.IVirtualDispatchResolver {
    public abstract virtual MethodBase ResolveVirtual(Slot slotThis, MethodBase method);
    public abstract virtual MethodInfo ResolveStaticVirtual(MethodInfo method, Type targetType);
    public abstract virtual void ClearDispatchCache();
}
[NullableContextAttribute("1")]
internal interface Ilrun.IVirtualStackFrame {
    public MethodBase Method { get; }
    public bool IsInterpreted { get; }
    public int IP { get; public set; }
    public abstract virtual MethodBase get_Method();
    public abstract virtual bool get_IsInterpreted();
    [NullableContextAttribute("2")]
public abstract virtual void InitForInterpretation(CallArgs args);
    public abstract virtual int get_IP();
    public abstract virtual void set_IP(int value);
    public abstract virtual Slot GetArgument(int index);
    public abstract virtual Type GetArgType(int index);
    public abstract virtual void SetArgument(int index, Slot value);
    public abstract virtual Slot GetArgumentAddress(int index);
    public abstract virtual Slot GetLocalVariable(int index);
    public abstract virtual Type GetLocalType(int index);
    public abstract virtual void SetLocalVariable(int index, Slot value);
    public abstract virtual Slot GetLocalVariableAddress(int index);
    public abstract virtual Slot Push(Slot value);
    public abstract virtual Slot Pop();
    public abstract virtual void ClearILStack();
    public abstract virtual VirtualAddress GetVAForLocal(int index);
    public abstract virtual VirtualAddress GetVAForArg(int index);
    public abstract virtual bool CanFuncEvalFromFrame();
    public abstract virtual void OnBeforeFuncEval();
    public abstract virtual void DumpVariableInfo(DumpFrameFlags flags, List`1<string> textLines);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.KnownFieldsHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, KnownField> s_knownFieldNamesMap;
    private static FieldInfo FindInstanceField(Type type, String[] fieldNames);
    public static FieldInfo GetKnownField(ITypeUniverse typeUniverse, KnownField knownField);
    public static FieldInfo TryGetKnownField(ITypeUniverse typeUniverse, KnownField knownField, bool throwOnFailure);
    public static Slot GetKnownFieldValue(Slot sObject, KnownField knownField);
    public static bool TryParse(string knownFieldString, KnownField& knownField);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Ilrun.LMRExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetRequiredMethod(Type lmrType, string name);
    [ExtensionAttribute]
public static MethodInfo GetRequiredMethod(Type lmrType, string name, BindingFlags bindingFlags);
    [ExtensionAttribute]
public static MethodInfo GetRequiredMethod(Type lmrType, string name, Type[] types);
    [ExtensionAttribute]
public static MethodInfo GetRequiredMethod(Type lmrType, string name, BindingFlags bindingFlags, Type[] types, ParameterModifier[] modifiers);
    [ExtensionAttribute]
public static PropertyInfo GetRequiredProperty(Type lmrType, string name);
    [ExtensionAttribute]
public static MethodInfo GetRequiredGetMethod(PropertyInfo property, bool nonPublic);
    [ExtensionAttribute]
public static MethodInfo GetRequiredSetMethod(PropertyInfo property, bool nonPublic);
    [ExtensionAttribute]
public static ConstructorInfo GetRequiredConstructor(Type lmrType, Type[] types);
    [ExtensionAttribute]
public static ConstructorInfo GetRequiredConstructor(Type lmrType, BindingFlags bindingAttr, Type[] types);
    [ExtensionAttribute]
public static FieldInfo GetRequiredField(Type lmrType, string name, BindingFlags bindingFlags);
    [DoesNotReturnAttribute]
private static void ThrowOnMemberNotFound(Type lmrType, string name);
    [DoesNotReturnAttribute]
private static void ThrowOnGetMethodNotFound(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsPointerOrByRef(Type lmrType);
    [ExtensionAttribute]
public static bool IsPointerLike(Type lmrType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.LmrServices : object {
    public static Type[] GetDirectInterfacesOfType(Type type);
    public static MethodBase ResolveMethod2(MetadataOnlyModule module, int token, Type[] typeArgs, Type[] methodArgs);
    internal static MethodBase ReInstantiateMethod(MethodBase method, Type[] typeArgs, Type[] methodArgs);
    [ConditionalAttribute("DEBUG")]
private static void SanityCheckResultOfReInstantiateMethod(MethodBase method, MethodBase result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.LocalAddressSlot : BaseAddressSlot {
    private IVirtualStackFrame m_frame;
    private int m_localIdx;
    internal ICollection`1<Slot> ChildSlots { get; }
    public LocalAddressSlot(IVirtualStackFrame frame, int localIdx, IHost host);
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot LoadIndirect();
    public virtual string ToString();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot ConvertToPointer(Type pointerType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MachineUnwindSlot : Slot {
    private IHost m_host;
    public IHost Host { get; }
    public MachineUnwindSlot(IHost host);
    public virtual IHost get_Host();
    public virtual int GetArrayElementSize();
    public virtual IObjectLayout GetObjectLayout();
    public virtual Type GetTypeX();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MaxInstructionCountExceededException : InterpreterExecutionException {
    public MaxInstructionCountExceededException(string message);
    public MaxInstructionCountExceededException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MDArrayElementAddressSlot : BaseAddressSlot {
    private Slot m_array;
    private Int32[] m_indices;
    internal ICollection`1<Slot> ChildSlots { get; }
    public MDArrayElementAddressSlot(Slot array, Int32[] indices);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MethodBaseSlot : HookedObjectSlot {
    private MethodBase m_method;
    internal MethodBaseSlot(IHost host, MethodBase method, Type methodType);
    public virtual MethodBase GetMethodWorker();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    private Slot ExecuteInvoke(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments);
    private Slot ExecuteTwoArgInvoke(VirtualMachine virtualMachine, CallArgs callArguments);
    private Slot ExecuteConstructorInvoke(VirtualMachine virtualMachine, CallArgs callArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MethodDecoder : object {
    private VirtualMachine m_vm;
    private MethodDecodeResult m_result;
    private MethodBase m_method;
    private MetadataOnlyModule m_containingModule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ExceptionHandlingClause> m_ehClauses;
    private Byte[] m_ilCode;
    private bool m_debuggingEnabled;
    private int m_ilOffset;
    private int m_invalidInstructionOffset;
    private bool m_hasAssemblyResolutionFailures;
    private List`1<DecodedInstruction> m_instructions;
    private List`1<int> m_ilMappingTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DecodedHandlerClause> m_decodedEhClauses;
    [NullableAttribute("2")]
private List`1<int> m_backpatchTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Slot> m_slotOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<MemberInfo> m_metadataOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<MethodStub> m_methodStubOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<HookedMethod> m_hookedMethodOperands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Int32[]> m_switchJumpTableOperands;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DecodedMethod <DecodedMethod>k__BackingField;
    [NullableAttribute("2")]
public DecodedMethod DecodedMethod { get; private set; }
    public int InvalidInstructionOffset { get; }
    public MethodDecoder(Byte[] ilCode, IList`1<ExceptionHandlingClause> ehClauses, MethodBase method, VirtualMachine vm, bool debuggingEnabled);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DecodedMethod get_DecodedMethod();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DecodedMethod(DecodedMethod value);
    public int get_InvalidInstructionOffset();
    public MethodDecodeResult DecodeMethod(MethodStub stub);
    private void DecodeNextInstruction();
    private void DecodeExtendedInstruction();
    private void DecodeHandlerClause(ExceptionHandlingClause ehc);
    private void DecodeSwitchInstruction();
    private void DecodeLoadString();
    private void DecodeTypeTokenInstruction(DecodedOpCode opCode);
    private void DecodeSizeOfInstruction();
    private void DecodeInstanceFieldInstruction(DecodedOpCode opCode);
    private void DecodeStaticFieldInstruction(DecodedOpCode opCode);
    private void DecodeMethodInstruction(DecodedOpCode opCode);
    private void DecodeLoadTokenInstruction();
    [NullableContextAttribute("2")]
private Type ResolveType(Token mdToken);
    [NullableContextAttribute("2")]
private FieldInfo ResolveField(Token mdToken);
    [NullableContextAttribute("2")]
private MethodBase ResolveMethod(Token mdToken);
    [NullableContextAttribute("2")]
private MemberInfo ResolveMemberRef(Token mdToken);
    private void UnsupportedWithToken(int originalOpCode);
    private byte ReadByte();
    private sbyte ReadSByte();
    private short ReadShort();
    private int ReadI4();
    private long ReadI8();
    private float ReadSingleFloat();
    private double ReadDoubleFloat();
    private void Ignore();
    private void Invalid(MethodDecodeResult result);
    private void AddBackpatch();
    private void AddLoadIntegerConstantInstruction(int intConst);
    private void AddInstruction(DecodedOpCode opCode, int operand);
    private void AddInstruction(DecodedOpCode opCode);
    private void AddInstruction(DecodedOpCode opCode, CorElementType type);
    private void AddInstruction(DecodedOpCode opCode, BinaryOperation opr);
    private void AddInstruction(DecodedOpCode opCode, MemberInfo metadataConst);
    private void AddInstruction(DecodedOpCode opCode, MethodStub methodStub);
    private void AddInstructionWithPrimitiveOperand(object value);
    private void AddInstructionWithExceptionMessage(DecodedOpCode opCode, Exception e);
    private void AddInstructionWithOperand(DecodedOpCode opCode, List`1& operandTable, T value);
    private void AddBranchInstruction(DecodedOpCode opCode, int targetOffset);
    private void ApplyBackpatch(int instructionOffset);
    private int RemapTargetOffset(int ilOffset);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Ilrun.MethodHookAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HookOnlyIfNativeMethod>k__BackingField;
    public string MethodName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Signature { get; public set; }
    public string ClassName { get; public set; }
    public bool HookOnlyIfNativeMethod { get; public set; }
    [NullableContextAttribute("1")]
public MethodHookAttribute(string methodName);
    [NullableContextAttribute("1")]
public MethodHookAttribute(string methodName, String[] signature);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(String[] value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public bool get_HookOnlyIfNativeMethod();
    [CompilerGeneratedAttribute]
public void set_HookOnlyIfNativeMethod(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Ilrun.MethodHookDeclaringTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <ClassNames>k__BackingField;
    public String[] ClassNames { get; private set; }
    public MethodHookDeclaringTypeAttribute(String[] classNames);
    [CompilerGeneratedAttribute]
public String[] get_ClassNames();
    [CompilerGeneratedAttribute]
private void set_ClassNames(String[] value);
}
internal class Ilrun.MethodHookDelegate : MulticastDelegate {
    public MethodHookDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Slot Invoke(VirtualMachine vm, MethodBase method, CallArgs args);
    public virtual IAsyncResult BeginInvoke(VirtualMachine vm, MethodBase method, CallArgs args, AsyncCallback callback, object object);
    public virtual Slot EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MethodHookDescriptor : ValueType {
    [NullableAttribute("2")]
public string AssemblyName;
    public string ClassName;
    public string MethodName;
    public MethodHookDelegate Delegate;
    public MethodHookDescriptor(string assemblyName, string className, string methodName, MethodHookDelegate delegate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MethodNotHookedException : InterpreterExecutionException {
    public MethodBase Method;
    internal MethodNotHookedException(MethodBase method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Stub: {FormattedName}")]
internal class Ilrun.MethodStub : object {
    public MethodBase Method;
    public string FormattedName;
    [NullableAttribute("2")]
public DecodedMethod DecodedMethod;
    [NullableAttribute("2")]
public Exception DecodeException;
    public Nullable`1<bool> ShouldTryFastExecute;
    public FastExecuteDisabledReason FastExecuteDisabledReason;
    public Module Module { get; }
    public MethodStub(MethodBase method);
    public Module get_Module();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ModuleEntry : object {
    private object m_lock;
    private MetadataOnlyModule m_resolver;
    private Dictionary`2<Token, CachedTypeDef> m_typeCache;
    private Dictionary`2<Token, CachedMethod> m_methodCache;
    [LockedByAttribute("m_lock")]
private List`1<WeakReference> m_referencesToModule;
    [NullableAttribute("2")]
private List`1<GenericInstantiation> m_dependentGenericInstantiations;
    internal MetadataOnlyModule Module { get; }
    internal ModuleEntry(MetadataOnlyModule resolver);
    internal MetadataOnlyModule get_Module();
    internal CachedTypeDef ResolveTypeDef(Token tokenTypeDef);
    internal CachedTypeRef ResolveTypeRef(Token tokenTypeRef);
    internal CachedTypeDef ResolveTypeRef(CachedTypeRef typeRef);
    internal CachedMethod ResolveMethodDef(Token methodDef, Type[] typeArgs, Type[] methodArgs);
    internal void OnReferenceResolvedToModule(CachedTypeRef referencingTypeRef);
    internal void OnNewDependentGenericInstantiation(GenericInstantiation instantiation);
    internal void InvalidateCachedTypeRefs();
    internal List`1<GenericInstantiation> DetachDependentGenericInstantiationList();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CachedTypeDef <ResolveTypeDef>b__9_0(Token key);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CachedMethod <ResolveMethodDef>b__12_0(Token key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ModuleSlot : HookedObjectSlot {
    private Module m_module;
    internal ModuleSlot(IHost host, Module module, Type typeOfModule);
    public virtual Module GetModuleWorker();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.MscorlibHooks : object {
    internal static MethodHookDelegate GetHookForPublicReflectionMethod(IHost host, MethodBase method);
    private static ReflectionObjectType GetSupportedReflectionTypeForHook(IHost host, MethodBase method);
    private static bool IsReflectionMethodHookedViaTryExecute(MethodBase method);
    private static Slot ExecuteReflectionMethod(VirtualMachine vm, MethodBase method, CallArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.MutableStringSlot : DefaultSlot {
    private int m_stringLength;
    private Char[] m_chars;
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    private int ArrayLength { get; }
    private int StringLength { get; private set; }
    internal MutableStringSlot(int length, IHost host);
    public virtual string ToString();
    protected internal virtual string GetStringWorker(bool _);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual Slot GetField(FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    private int get_ArrayLength();
    private int get_StringLength();
    private void set_StringLength(int value);
    public virtual Slot ConvertToPointer(Type pointerType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Ilrun.NativeMethodException : InterpreterExecutionException {
    public bool IsComMethod;
    private MethodBase m_method;
    public MethodBase Method { get; }
    [DebuggerStepThroughAttribute]
internal NativeMethodException(MethodBase method, bool isComMethod);
    public MethodBase get_Method();
}
public class Ilrun.NoArgumentEventHandler : MulticastDelegate {
    public NoArgumentEventHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.NonPrimitiveArraySlot : ArraySlot`1<Slot> {
    internal ICollection`1<Slot> ChildSlots { get; }
    internal NonPrimitiveArraySlot(IHost host, Type elementType, Int32[] dims, Int32[] lowerBounds);
    internal NonPrimitiveArraySlot(IHost host, Type elementType, Int64[] dims, Int64[] lowerBounds);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    private string DebuggerDisplay();
    public virtual string ToString();
    protected virtual Slot ConvertSlotToData(Slot sElement);
    protected virtual Slot ConvertDataToSlot(Slot value);
    public virtual void StoreElementAtPosition(int index, Slot value);
    public virtual Slot GetElementAtPosition(int index);
    public virtual void BulkCopyArrayElementsTo(DefaultSlot targetArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.NullSlot : DefaultSlot {
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal NullSlot(DefaultHost host, Type type);
    public virtual bool IsNull();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
}
internal static class Ilrun.NumberFormatInfoHelper : object {
    [NullableContextAttribute("1")]
public static bool TryExecuteTCharMethod(NumberFormatInfo realObject, VirtualMachine vm, MethodBase method, CallArgs args, Slot& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ObjectLayouts.Legacy.AutoObjectLayout : DefaultObjectLayout {
    private static List`1<int> StandardFieldSizes;
    private AutoObjectLayout(Type type, Dictionary`2<FieldInfo, int> fieldOffsets, int objectSize);
    private static AutoObjectLayout();
    public static AutoObjectLayout Create(IHost host, Type type);
    private static int CalculateValueTypeSizeHelper(int currentOffset);
    internal static int CalculateObjectSize(IHost host, Type type, FieldInfo declaredFieldWithHighestEndOffset, int highestDeclaredFieldEnd);
    private static int Log2(int standardSize);
    private static void GroupDeclaredFields(IHost host, Type type, Queue`1[]& fieldsOfStandardSize, Queue`1& valueTypeFields);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ObjectLayouts.Legacy.BlittableExplicitObjectLayout : ExplicitObjectLayout {
    private BlittableExplicitObjectLayout(Type type, Dictionary`2<FieldInfo, int> fieldOffsets, int objectSize);
    public static BlittableExplicitObjectLayout Create(IHost host, Type type);
    internal static int CalculateObjectSize(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.ObjectLayouts.Legacy.DefaultObjectLayout : object {
    protected static int OBJHEADER_SIZE;
    protected static int OBJECT_SIZE;
    protected static int OBJECT_BASESIZE;
    protected static int MIN_OBJECT_SIZE;
    private Dictionary`2<FieldInfo, int> m_offsetDict;
    private int m_objectSize;
    private Type m_type;
    [CompilerGeneratedAttribute]
private int <HeapSize>k__BackingField;
    public int HeapSize { get; }
    protected DefaultObjectLayout(Type type, Dictionary`2<FieldInfo, int> offsets, int objectSize);
    private static DefaultObjectLayout();
    public sealed virtual int GetObjectSize();
    [CompilerGeneratedAttribute]
public int get_HeapSize();
    public sealed virtual int GetFieldOffset(FieldInfo field);
    public static IObjectLayout Create(IHost host, Type type);
    protected static int AlignUp(int value, int alignment);
    protected static bool IsAligned(int value, int alignment);
    protected static int GetPackingSizeOrDefaultForType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.ObjectLayouts.Legacy.ExplicitObjectLayout : DefaultObjectLayout {
    protected ExplicitObjectLayout(Type type, Dictionary`2<FieldInfo, int> fieldOffsets, int objectSize);
    public static ExplicitObjectLayout Create(IHost host, Type type);
    protected static int CalculateNativeSizeOfTypeWithLayout(Type type, Int32& largestAlignmentRequirement);
    protected static int GetFieldOffsetFromAttribute(FieldInfo field);
    protected static int GetAlignment(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ObjectLayouts.Legacy.NonBlittableExplicitObjectLayout : ExplicitObjectLayout {
    private NonBlittableExplicitObjectLayout(Type type, Dictionary`2<FieldInfo, int> fieldOffsets, int objectSize);
    public static NonBlittableExplicitObjectLayout Create(IHost host, Type type);
    private static int CalculateObjectSizeHelper(Type type, bool containsReferenceFields, int instanceSliceOffset, int instanceSliceSize);
    internal static int CalculateObjectSize(IHost host, Type type, int highestDeclaredFieldEnd);
    private static bool ContainsAnyDeclaredReferenceFields(Type type);
}
internal class Ilrun.ObjectLayouts.Legacy.PrimitiveOrSimpleValueLayout : object {
    private int m_objectSize;
    [CompilerGeneratedAttribute]
private int <HeapSize>k__BackingField;
    public int HeapSize { get; }
    [NullableContextAttribute("1")]
internal PrimitiveOrSimpleValueLayout(Type type);
    internal PrimitiveOrSimpleValueLayout(int size);
    public sealed virtual int GetObjectSize();
    [CompilerGeneratedAttribute]
public int get_HeapSize();
    [NullableContextAttribute("1")]
public sealed virtual int GetFieldOffset(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ObjectLayouts.Legacy.SequentialObjectLayout : DefaultObjectLayout {
    private SequentialObjectLayout(Type type, Dictionary`2<FieldInfo, int> fieldOffsets, int objectSize);
    public static SequentialObjectLayout TryCreate(IHost host, Type type);
    private static int CalculateObjectSizeHelper(Type type, int lastFieldEnd, int largestAlignmentRequirementOfAllMembers);
    internal static int CalculateObjectSize(Type type, int highestDeclaredFieldEnd);
    private static int GetManagedSequentialAlignment(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Ilrun.ObjectSlot : AbstractObjectSlot {
    private ExceptionStackTrace m_capturedStackTrace;
    internal ExceptionStackTrace CapturedStackTrace { get; internal set; }
    [NullableContextAttribute("1")]
public ObjectSlot(Type type, IHost host);
    [NullableContextAttribute("1")]
protected virtual Slot GetUninitializedField(FieldInfo field);
    internal virtual ExceptionStackTrace get_CapturedStackTrace();
    internal virtual void set_CapturedStackTrace(ExceptionStackTrace value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.OpaqueIntegerSlot : DefaultSlot {
    private AccessExceptionFactory m_accessExceptionFactory;
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    public OpaqueIntegerSlot(Type type, AccessExceptionFactory accessExceptionFactory, IHost host);
    public virtual string ToString();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual Slot ConvertToPointer(Type pointerType);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual Slot GetField(FieldInfo field);
    public Exception GetAccessException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.OpaquePointerSlot : BaseAddressSlot {
    private Type m_type;
    private ulong m_addr;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal Type Type { get; }
    internal ulong Address { get; }
    internal OpaquePointerSlot(IHost host, Type type, ulong addr);
    internal string DebuggerDisplay();
    public virtual long GetAsPointerWorker();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot ConvertToPointer(Type pointerType);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Slot MakeValueTypeCopy();
    public virtual bool IsNull();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual Slot ConvertToInteger(CorElementType integerType);
    public virtual Slot PointerAdd(int offset);
    public virtual Type GetTypeX();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    internal Type get_Type();
    internal ulong get_Address();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ParameterInfoSlot : HookedObjectSlot {
    private ParameterInfo m_param;
    internal ParameterInfoSlot(ParameterInfo pi, IHost host);
    public virtual ParameterInfo GetParameterWorker();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PlaceholderSlot : BaseAddressSlot {
    private Slot m_slot;
    private Type m_staticType;
    private bool m_fReadOnly;
    internal ICollection`1<Slot> ChildSlots { get; }
    public PlaceholderSlot(Type staticType, Slot initialValue, bool fReadOnly);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PointerAsReferenceSlot : BaseAddressSlot {
    private Slot m_pointer;
    public PointerAsReferenceSlot(Slot pointer);
    public virtual string ToString();
    public virtual Type GetTypeX();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    public virtual void BulkLoadIndirect(int slotOffset, Byte[] data, int offset, int length);
    public virtual void BulkStoreIndirect(Byte[] data, int offset, int length);
    public virtual Slot ConvertToPointer(Type pointerType);
    public virtual Slot ConvertToInteger(CorElementType integerType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PointerSlot : BaseAddressSlot {
    private Type m_type;
    private Slot m_addr;
    private int m_offset;
    private int m_size;
    [ThreadStaticAttribute]
private static InfiniteRecursionGuard s_irgLoadIndirect;
    internal ICollection`1<Slot> ChildSlots { get; }
    private static InfiniteRecursionGuard IrgLoadIndirect { get; }
    internal PointerSlot(Type type, Slot addr, int offset);
    private static PointerSlot();
    private Type GetElementType();
    public virtual Slot PointerAdd(int offset);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Slot ConvertToPointer(Type pointerType);
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual long GetAsPointerWorker();
    public virtual VirtualAddress GetVirtualAddress();
    private static InfiniteRecursionGuard get_IrgLoadIndirect();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PrimitiveArraySlot`1 : ArraySlot`1<T> {
    internal PrimitiveArraySlot`1(DefaultHost host, long length);
    public virtual string ToString();
    [NullableContextAttribute("0")]
protected virtual Slot ConvertDataToSlot(T value);
    [NullableContextAttribute("0")]
protected virtual T ConvertSlotToData(Slot value);
    internal virtual Slot TryExecute(VirtualMachine vm, MethodBase method, CallArgs args, Boolean& useInterpreter);
    public sealed virtual bool TryBulkCopy(Byte[] data, int offset, int slotOffset, int length);
    public sealed virtual bool TryBulkReadBytes(Byte[] data, int offset, int slotOffset, int length);
    private static Type GetTypeX(DefaultHost host, Type systemType);
}
internal static class Ilrun.PrimitiveImpl : object {
    internal static PrimitiveType ResolveIntPtrType(PrimitiveType pt);
    [NullableContextAttribute("1")]
internal static PrimitiveValue ResolveIntPtr(PrimitiveValue value);
    [NullableContextAttribute("1")]
internal static PrimitiveType GetPrimitiveTypeFromSystemType(Type t);
    [NullableContextAttribute("1")]
internal static PrimitiveType GetPrimitiveTypeFromTypeX(Type type);
    internal static bool IsFloatingPoint(PrimitiveType pt);
    internal static PrimitiveType GetCompositeType(PrimitiveType pt1, PrimitiveType pt2);
    [NullableContextAttribute("1")]
private static PrimitiveType GetCompositeType(PrimitiveType[] pta);
    [NullableContextAttribute("1")]
private static PrimitiveType SetupOperation(PrimitiveValue[] operends, bool unsigned);
    [NullableContextAttribute("1")]
internal static bool IsEqualToInteger(PrimitiveValue pv, int value);
    [NullableContextAttribute("1")]
private static PrimitiveType SetupBinaryOperation(PrimitiveValue& pv1, PrimitiveValue& pv2, ArithmeticFlags flags);
    [NullableContextAttribute("1")]
private static PrimitiveType SetupUnaryOperation(PrimitiveValue& pv, ArithmeticFlags flags);
    internal static PrimitiveType GetArithmeticType(PrimitiveType pt, bool unsigned);
    [NullableContextAttribute("1")]
[DebuggerStepThroughAttribute]
private static Exception AssertAndThrow(string msg);
    internal static ulong GetValidMaskForType(PrimitiveType pt);
    internal static bool IsSigned(PrimitiveType pt);
    internal static ulong GetSignMask(PrimitiveType pt);
    internal static PrimitiveType FindCommonType(PrimitiveType pt1, PrimitiveType pt2);
    internal static bool SupportsConversion(PrimitiveType fromType, PrimitiveType toType);
    internal static bool AreSameIgnoreSign(PrimitiveType fromType, PrimitiveType toType);
    [NullableContextAttribute("1")]
internal static PrimitiveValue GetDefaultValue(PrimitiveType pt);
    [NullableContextAttribute("1")]
private static byte ToByteInternal(Byte[] b, int idx);
    [NullableContextAttribute("1")]
private static sbyte ToSByteInternal(Byte[] b, int idx);
    [NullableContextAttribute("1")]
private static IntPtr ToIntPtrInternal(Byte[] b, int idx);
    [NullableContextAttribute("1")]
private static UIntPtr ToUIntPtrInternal(Byte[] b, int idx);
    internal static int GetSize(PrimitiveType pt);
    internal static bool IsValidPrimitiveType(PrimitiveType pt);
    internal static string GetNameOfPrimitiveType(PrimitiveType pt);
    internal static Byte[] GetBytes(PrimitiveValue pv);
    internal static PrimitiveValue GetValueFromBytes(PrimitiveType pt, Byte[] bytes);
    internal static bool IsTrue(PrimitiveValue pv);
    internal static PrimitiveValue ConvertUnsafe(PrimitiveValue pv, PrimitiveType pt);
    internal static object GetUnderlyingValueOfEnum(object value);
    internal static PrimitiveValue ConvertSafe(PrimitiveValue pv, PrimitiveType pt);
    internal static PrimitiveType GetPrimitiveTypeFromSystemType(string typeName, bool throwIfNotValid);
    internal static PrimitiveValue Add(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue Subtract(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue Multiply(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue Divide(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue Modulus(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue BitXor(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static bool IsEqual(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static bool IsGreaterThan(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static bool IsGreaterThanOrEqual(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static bool IsLessThan(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static bool IsLessThanOrEqual(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue Negate(PrimitiveValue pv, ArithmeticFlags flags);
    internal static PrimitiveValue BitNot(PrimitiveValue pv, ArithmeticFlags flags);
    internal static PrimitiveValue BitShiftLeft(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
    internal static PrimitiveValue BitShiftRight(PrimitiveValue pv1, PrimitiveValue pv2, ArithmeticFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PrimitiveSlot : DefaultSlot {
    private Type m_type;
    [CompilerGeneratedAttribute]
private PrimitiveValue <Value>k__BackingField;
    public PrimitiveValue Value { get; }
    internal ICollection`1<Slot> ChildSlots { get; }
    internal PrimitiveSlot(PrimitiveValue value, IHost host);
    [CompilerGeneratedAttribute]
public PrimitiveValue get_Value();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual string ToString();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Type GetTypeX();
    public virtual Slot GetField(FieldInfo field);
    internal virtual Integer GetAsIntegerValue();
}
public enum Ilrun.PrimitiveType : Enum {
    public int value__;
    [PrimitiveTypeAttribute]
public static PrimitiveType Invalid;
    [PrimitiveTypeAttribute]
public static PrimitiveType Bool;
    [PrimitiveTypeAttribute]
public static PrimitiveType Char;
    [PrimitiveTypeAttribute]
public static PrimitiveType I1;
    [PrimitiveTypeAttribute]
public static PrimitiveType I2;
    [PrimitiveTypeAttribute]
public static PrimitiveType I4;
    [PrimitiveTypeAttribute]
public static PrimitiveType I8;
    [PrimitiveTypeAttribute]
public static PrimitiveType I;
    [PrimitiveTypeAttribute]
public static PrimitiveType U1;
    [PrimitiveTypeAttribute]
public static PrimitiveType U2;
    [PrimitiveTypeAttribute]
public static PrimitiveType U4;
    [PrimitiveTypeAttribute]
public static PrimitiveType U8;
    [PrimitiveTypeAttribute]
public static PrimitiveType U;
    [PrimitiveTypeAttribute]
public static PrimitiveType R4;
    [PrimitiveTypeAttribute]
public static PrimitiveType R8;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
internal class Ilrun.PrimitiveTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ComputationTypeSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ComputationTypeUnsigned>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SignedEquivelent>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnsignedEquivelent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeFromGeneratedCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConvertToMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConvertFromBytes>k__BackingField;
    public Type RuntimeType { get; public set; }
    public Type ComputationTypeSigned { get; public set; }
    public Type ComputationTypeUnsigned { get; public set; }
    public Type SignedEquivelent { get; public set; }
    public Type UnsignedEquivelent { get; public set; }
    public string Zero { get; public set; }
    public bool ExcludeFromGeneratedCode { get; public set; }
    public string ConvertToMethod { get; public set; }
    public string ConvertFromBytes { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public void set_RuntimeType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ComputationTypeSigned();
    [CompilerGeneratedAttribute]
public void set_ComputationTypeSigned(Type value);
    [CompilerGeneratedAttribute]
public Type get_ComputationTypeUnsigned();
    [CompilerGeneratedAttribute]
public void set_ComputationTypeUnsigned(Type value);
    [CompilerGeneratedAttribute]
public Type get_SignedEquivelent();
    [CompilerGeneratedAttribute]
public void set_SignedEquivelent(Type value);
    [CompilerGeneratedAttribute]
public Type get_UnsignedEquivelent();
    [CompilerGeneratedAttribute]
public void set_UnsignedEquivelent(Type value);
    [CompilerGeneratedAttribute]
public string get_Zero();
    [CompilerGeneratedAttribute]
public void set_Zero(string value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeFromGeneratedCode();
    [CompilerGeneratedAttribute]
public void set_ExcludeFromGeneratedCode(bool value);
    [CompilerGeneratedAttribute]
public string get_ConvertToMethod();
    [CompilerGeneratedAttribute]
public void set_ConvertToMethod(string value);
    [CompilerGeneratedAttribute]
public string get_ConvertFromBytes();
    [CompilerGeneratedAttribute]
public void set_ConvertFromBytes(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PrimitiveValue : object {
    internal static PrimitiveValue IntPtrZero;
    internal static PrimitiveValue UIntPtrZero;
    [CompilerGeneratedAttribute]
private PrimitiveType <PrimType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <BoxedValue>k__BackingField;
    public int ValueAsInt32 { get; }
    public long ValueAsInt64 { get; }
    public UInt32 ValueAsUInt32 { get; }
    public IntPtr ValueAsIntPtr { get; }
    public UIntPtr ValueAsUIntPtr { get; }
    public ulong ValueAsUInt64 { get; }
    public double ValueAsDouble { get; }
    public float ValueAsFloat { get; }
    internal PrimitiveType PrimType { get; }
    internal object BoxedValue { get; }
    internal PrimitiveValue(object boxedValue);
    private static PrimitiveValue();
    public virtual string ToString();
    internal PrimitiveValue AsSigned();
    internal PrimitiveValue AsUnsigned();
    public int get_ValueAsInt32();
    public long get_ValueAsInt64();
    public UInt32 get_ValueAsUInt32();
    public IntPtr get_ValueAsIntPtr();
    public UIntPtr get_ValueAsUIntPtr();
    public ulong get_ValueAsUInt64();
    public double get_ValueAsDouble();
    public float get_ValueAsFloat();
    private static PrimitiveType GetPrimTypeFromBoxedValue(object boxedValue);
    [CompilerGeneratedAttribute]
internal PrimitiveType get_PrimType();
    [CompilerGeneratedAttribute]
internal object get_BoxedValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.PropertyInfoSlot : HookedObjectSlot {
    private PropertyInfo m_property;
    internal PropertyInfoSlot(IHost host, PropertyInfo prop, Type runtimeTypeOfPropertyInfoObject);
    public virtual PropertyInfo GetPropertyWorker();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ProxyBase : object {
    protected Slot m_real;
    protected VirtualMachine m_vm;
    internal Slot Slot { get; }
    public ProxyBase(VirtualMachine vm, Slot s);
    internal Slot get_Slot();
    private MethodInfo GetMethod(Type hostType, string methodName, Type[] hostArgTypes);
    private object ImplementMethodImpl(Type hostType, string methodName, Type[] hostArgTypes, Object[] hostArgs);
    private protected T ImplementMethod(Type hostType, string methodName, Type[] hostArgTypes, Object[] hostArgs);
    private protected T ImplementMethodWithNull(Type hostType, string methodName, Type[] hostArgTypes, Object[] hostArgs);
    private Slot GetSlotForObject(object hostArg);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ProxyMarshaller : BaseMarshaller {
    private VirtualMachine m_vm;
    internal ProxyMarshaller(VirtualMachine vm);
    internal virtual object GetAsHostObjectWorker(Slot s, Type expectedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ReaderWriterLockSlot : HookedObjectSlot {
    internal ReaderWriterLockSlot(IHost host);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ReadOnlySpanPointerSlot : DefaultSlot {
    private ReadOnlySpanSlot m_slot;
    private Type m_type;
    private int m_offset;
    protected internal bool UsesPointerArithmeticSemantics { get; }
    public ReadOnlySpanPointerSlot(ReadOnlySpanSlot slot, Type type);
    public ReadOnlySpanPointerSlot(ReadOnlySpanSlot slot, Type type, int offset);
    public virtual Type GetTypeX();
    public virtual Slot ConvertToPointer(Type t);
    public virtual Slot LoadIndirect();
    public virtual Slot PointerAdd(int offset);
    public virtual bool IsNull();
    protected internal virtual bool get_UsesPointerArithmeticSemantics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ReadOnlySpanSlot : DefaultSlot {
    private Byte[] m_bytes;
    private Type m_elementType;
    private Type m_type;
    private Nullable`1<PrimitiveType> m_primitiveElementType;
    private PrimitiveType PrimitiveType { get; }
    public ReadOnlySpanSlot(IHost host, Type elementType, Byte[] bytes);
    private PrimitiveType get_PrimitiveType();
    public virtual Type GetTypeX();
    public virtual Slot GetField(FieldInfo field);
    public Slot GetElementAtByteOffset(int index, Type type);
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
}
public class Ilrun.RealFuncEvalExceptionEventHandler : MulticastDelegate {
    public RealFuncEvalExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int sequenceNum, int hr, string error, bool willRetry);
    public virtual IAsyncResult BeginInvoke(int sequenceNum, int hr, string error, bool willRetry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay()}")]
internal class Ilrun.RealObjectSlot : HookedObjectSlot {
    private object m_realObject;
    internal object RealObject { get; }
    private RealObjectSlot(IHost host, object realObject, Type type);
    public static RealObjectSlot Create(IHost host, object realObject);
    private string DebuggerDisplay();
    public virtual void SetField(Slot value, FieldInfo field);
    internal object get_RealObject();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    private Slot TryExecuteWorker(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    public virtual Slot GetField(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ReferenceToValueTypeSlot : DefaultSlot {
    private Slot m_slot;
    private bool m_fBox;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal ReferenceToValueTypeSlot(Slot slot);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    internal virtual Slot TryAutoMarshal(Type expected);
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot GetField(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot MakeValueTypeCopy();
    public virtual IObjectLayout GetObjectLayout();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual VirtualAddress GetVirtualAddress();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ReflectionInvokerException : InterpreterExecutionException {
    public MethodBase Method;
    private ReflectionInvokerException(MethodBase method, string message);
    internal static ReflectionInvokerException Create(MethodBase method);
}
internal enum Ilrun.ReflectionObjectType : Enum {
    public int value__;
    public static ReflectionObjectType None;
    public static ReflectionObjectType Type;
    public static ReflectionObjectType Method;
    public static ReflectionObjectType Constructor;
    public static ReflectionObjectType Field;
    public static ReflectionObjectType Property;
    public static ReflectionObjectType Module;
    public static ReflectionObjectType Assembly;
    public static ReflectionObjectType ParameterInfo;
    public static ReflectionObjectType MemberInfo;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.ReflectionSubsystem : object {
    private static Type[] Convert(MethodBase method);
    private static Type Map(Type t);
    private static Type MapKnownHostTypes(Type type);
    public static Slot InvokeReflection(VirtualMachine virtualMachine, object oThis, MethodBase method, CallArgs callArguments);
    private static Slot GetVirtualExceptionForLmrException(VirtualMachine vm, Exception lmrException);
    private static string GetVirtualExceptionMessage(VirtualMachine vm, Exception lmrException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ResourceAssemblyManager : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Assembly> m_resourceAssemblies;
    private bool IsCoreSystem(ITypeUniverse typeUniverse);
    private bool UseMscorlibAssemblyDirectlyForResources(bool fCoreSystem, CultureInfo culture);
    internal Assembly GetMscorlibResourceAssembly(ITypeUniverse typeUniverse, CultureInfo culture, String& baseName);
    public virtual Assembly ResolveMscorlibResourceAssembly(ITypeUniverse universe, AssemblyName assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.RuntimeAddedMethodInfo : MethodInfo {
    protected MethodInfo m_method;
    protected Type m_declaringType;
    public Type ReturnType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public RuntimeAddedMethodInfo(MethodInfo method, Type declaringType);
    public static Slot TryExecute(VirtualMachine vm, MethodBase method, CallArgs args);
    public abstract virtual Slot TryExecute(VirtualMachine virtualMachine, CallArgs callArguments);
    public virtual Type get_ReturnType();
    public virtual MethodInfo MakeGenericMethod(Type[] types);
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual ParameterInfo[] GetParameters();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual string ToString();
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual bool IsEquivalentTo(MemberInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.RuntimeFieldSlot : HookedObjectSlot {
    private FieldInfo m_field;
    public RuntimeFieldSlot(FieldInfo field, IHost host);
    public virtual FieldInfo GetFieldWorker();
    public virtual string ToString();
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.RuntimeFunctionSlot : HookedObjectSlot {
    private MethodBase m_method;
    public RuntimeFunctionSlot(IHost host, MethodBase method);
    private RuntimeFunctionSlot(IHost host, MethodBase method, Type typeMethodHandle);
    public virtual MethodBase GetMethodWorker();
    internal virtual Slot TryAutoMarshal(Type expected);
    public virtual Slot MakeValueTypeCopy();
    private RuntimeFunctionSlot ConvertToIntPtr();
    public virtual string ToString();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.RuntimeHandleSlot : HookedObjectSlot {
    [NullableAttribute("2")]
private Type m_type;
    public RuntimeHandleSlot(IHost host, Type type, Type runtimeHandleType);
    public virtual Type GetTypeWorker();
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual string ToString();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.RuntimeHandleValueSlot : HookedObjectSlot {
    private Slot m_slot;
    internal RuntimeHandleValueSlot(Slot slot, Type type);
    [NullableContextAttribute("2")]
public virtual Type GetTypeWorker();
    [NullableContextAttribute("2")]
public virtual MethodBase GetMethodWorker();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    public virtual Slot GetField(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.Slot : object {
    internal static Slot[] EmptyArray;
    public IHost Host { get; }
    public ISlotFactory SlotFactory { get; }
    protected internal bool UsesPointerArithmeticSemantics { get; }
    public bool IsBox { get; }
    public bool IsComObject { get; }
    internal bool IsValueType { get; }
    public ITypeUniverse TypeUniverse { get; }
    private static Slot();
    public abstract virtual IHost get_Host();
    public abstract virtual Type GetTypeX();
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual long GetAsPointerWorker();
    public virtual Slot ConvertToPointer(Type pointerType);
    public ISlotFactory get_SlotFactory();
    public virtual void BulkStoreIndirect(Byte[] data, int offset, int length);
    public virtual void BulkLoadIndirect(int slotOffset, Byte[] data, int offset, int length);
    [NullableContextAttribute("2")]
protected internal virtual string GetStringWorker(bool ensureMaximumString);
    [NullableContextAttribute("2")]
public virtual Type GetTypeWorker();
    [NullableContextAttribute("2")]
public virtual ParameterInfo GetParameterWorker();
    [NullableContextAttribute("2")]
public virtual FieldInfo GetFieldWorker();
    [NullableContextAttribute("2")]
public virtual MethodBase GetMethodWorker();
    [NullableContextAttribute("2")]
public virtual Assembly GetAssemblyWorker();
    [NullableContextAttribute("2")]
public virtual PropertyInfo GetPropertyWorker();
    [NullableContextAttribute("2")]
public virtual Module GetModuleWorker();
    [NullableContextAttribute("2")]
public virtual MethodBase GetMethodOfDelegate();
    [NullableContextAttribute("2")]
public virtual Slot GetTargetObjectOfDelegate();
    public virtual Slot PointerAdd(int offset);
    protected internal virtual bool get_UsesPointerArithmeticSemantics();
    public virtual bool IsNull();
    public abstract virtual IObjectLayout GetObjectLayout();
    public abstract virtual int GetArrayElementSize();
    public virtual VirtualAddress GetVirtualAddress();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot LoadIndirect();
    public virtual Slot GetField(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public void StoreElement(int index, Slot value);
    public void StoreElement(Int32[] indices, Slot value);
    public virtual void StoreElementAtPosition(int index, Slot value);
    public Slot GetElement(int index);
    public Slot GetElement(Int32[] indices);
    public virtual Slot GetElementAtPosition(int index);
    public virtual Slot GetElementAddress(int index);
    public virtual Slot GetElementAddress(Int32[] indices);
    public virtual int GetArrayLength();
    public virtual Int32[] GetLowerBounds();
    public virtual Int32[] GetDimensions();
    public virtual Slot GetUnboxValue();
    public virtual bool get_IsBox();
    public virtual bool get_IsComObject();
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    internal virtual Slot TryAutoMarshal(Type expected);
    internal bool get_IsValueType();
    [DoesNotReturnAttribute]
internal void Illegal();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool IsEqual(Slot s1, Slot s2);
    public ITypeUniverse get_TypeUniverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.SlotDecoder : object {
    public static int GetSize(Slot slot);
    public static string GetAsString(Slot slot);
    public static Byte[] GetAsByteArray(Slot slot);
    public static Guid GetAsGuid(Slot slot);
    internal static PrimitiveValue GetAsPrimitive(Slot s);
    public static long GetAsInt64(Slot slot);
    public static ulong GetAsUInt64(Slot slot);
    public static float GetAsFloat(Slot slot);
    public static double GetAsDouble(Slot slot);
    public static IntPtr GetAsIntPtr(Slot slot);
    public static bool GetAsBoolean(Slot slot);
    public static int GetAsInt32(Slot slot);
    internal static int GetAsPointerOffset(Slot slot);
    public static long GetAsPointer(Slot slot);
    public static Byte[] GetBytes(Slot slot);
    public static CultureInfo GetAsCultureInfo(Slot slot, VirtualMachine vm);
    private static Slot GetPropertyHelper(VirtualMachine vm, Type type, Slot slot, string propertyName);
    private static Slot GetPrivateFieldHelper(Type type, Slot slot, String[] alternateFieldNames);
    public static Version GetAsVersion(Slot slot, VirtualMachine vm);
    public static AssemblyName GetAsAssemblyName(Slot slot, VirtualMachine vm);
    [NullableContextAttribute("2")]
public static bool TryGetAsHostObject(Slot slot, CustomSlotMarshaler marshaler, Object& result);
    public static object GetAsHostObject(Slot slot);
    private static DateTime GetDateTimeValue(Slot s, Type t);
    private static decimal GetDecimalValue(Slot s, Type t);
    private static T DecodeRuntimeReflectionObjectWorker(Slot slot, GetReflectionObjectWorker`1<T> worker, string handleTypeName, bool fHandle);
    public static Type DecodeRuntimeTypeHandle(Slot slot);
    public static FieldInfo DecodeRuntimeFieldHandle(Slot slot);
    public static MethodBase DecodeRuntimeMethodHandle(Slot slot);
    public static Type GetAsType(Slot slot);
    public static ParameterInfo GetAsParameter(Slot slot);
    public static Assembly GetAsAssembly(Slot slot);
    public static MethodBase GetAsMethod(Slot slot);
    public static FieldInfo GetAsField(Slot slot);
    public static PropertyInfo GetAsProperty(Slot slot);
    public static Module GetAsModule(Slot slot);
    public static int GetFlattenedArrayIndex(Slot arraySlot, int index);
    public static int GetFlattenedArrayIndex(Slot arraySlot, Int32[] indices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.SlotEqualityWrapper : object {
    [CompilerGeneratedAttribute]
private Slot <Slot>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualAddress <VirtualAddress>k__BackingField;
    private PrimitiveType _primitiveType;
    public Slot Slot { get; }
    public Type Type { get; }
    public VirtualAddress VirtualAddress { get; }
    public bool HasPrimitiveData { get; }
    public bool IsUnderlyingPointer { get; }
    public bool IsInteger { get; }
    public bool IsString { get; }
    public bool IsNull { get; }
    public bool IsRawValueType { get; }
    public SlotEqualityWrapper(Slot slot);
    [CompilerGeneratedAttribute]
public Slot get_Slot();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public VirtualAddress get_VirtualAddress();
    public bool CompareWithPrimitiveValue(SlotEqualityWrapper other);
    public bool CompareWithInteger(SlotEqualityWrapper other);
    public bool CompareWithOpaqueInteger(SlotEqualityWrapper other);
    public bool TryCompareWithReflectionObject(SlotEqualityWrapper other, Boolean& result);
    public bool CompareWithString(SlotEqualityWrapper other);
    public bool CompareWithVirtualAddress(SlotEqualityWrapper other);
    public bool get_HasPrimitiveData();
    public bool get_IsUnderlyingPointer();
    public bool get_IsInteger();
    public bool get_IsString();
    public bool get_IsNull();
    public bool get_IsRawValueType();
    public PrimitiveValue GetPrimitiveValueForComparison();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.SlotMarshaler`1 : object {
    private Dictionary`2<Slot, T> m_recursiveCache;
    public T ConvertSlotToValue(Slot slot);
    protected virtual T MarshalSlot(Slot slot);
    protected virtual T MarshalArraySlot(Slot slot);
    protected virtual T MarshalComplexObjectSlot(Slot slot);
    protected abstract virtual T MarshalTypeSlot(Slot typeSlot);
    protected abstract virtual T MarshalAssemblySlot(Slot assemblySlot);
    protected abstract virtual T MarshalStringSlot(Slot slot);
    protected abstract virtual T MarshalPrimitiveSlot(Slot slot);
    protected abstract virtual T MarshalNullSlot(Slot slot);
    protected abstract virtual T MarshalEnumSlot(Slot slot);
    protected abstract virtual T MarshalDecimalSlot(Slot slot);
    protected abstract virtual T CreateUninitializedArray(Type elementType, Int32[] dimensions, Int32[] lowerBounds);
    protected abstract virtual void MarshalArrayElements(T emptyArray, Slot sourceArraySlot);
    protected virtual T MarshalPointerSlot(Slot slot);
    protected virtual T MarshalByRefSlot(Slot slot);
    protected virtual T CreateUninitializedComplexObject(Type objectType);
    protected virtual void MarshalComplexObjectData(T emptyObject, IDictionary`2<FieldInfo, T> fieldValues);
    private static bool ShouldCheckForRecursiveFields(Slot slot);
    private void AddSlotToRecursiveCache(Slot slot, T marshalledValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.SlotWrappers : object {
    internal static Slot GetArrayElement(VirtualMachine vm, Slot sArray, Slot sIdx);
    internal static Slot GetArrayElement(VirtualMachine vm, Slot sArray, int idx);
    internal static void StoreArrayElement(VirtualMachine vm, Slot sArray, Slot sIdx, Slot sValue);
    internal static void StoreArrayElement(VirtualMachine vm, Slot sArray, int idx, Slot sValue);
    internal static Slot GetArrayElementAddress(VirtualMachine vm, Slot sArray, Slot sIdx, Type expectedType);
    internal static Slot GetArrayElementAddress(VirtualMachine vm, Slot sArray, int idx, Type expectedType);
    internal static bool ValidateArrayAccess(VirtualMachine vm, Slot sArray, int startIndex, int elementCount);
    internal static bool IsArrayAccessValid_VThrow(VirtualMachine vm, Slot sArray, Int32[] indices);
    internal static long ResolveArraySize(VirtualMachine vm, Slot sSize);
    private static int ResolveArrayIndex(VirtualMachine vm, Slot sIdx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.SourceLocation : object {
    private string m_fileName;
    private int m_line;
    private int m_column;
    public string FileName { get; }
    public int Line { get; }
    public int Column { get; }
    public SourceLocation(string fileName, int line, int column);
    public string get_FileName();
    public int get_Line();
    public int get_Column();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StackAllocPointerSlot : ArrayElementPointerSlotBase {
    internal StackAllocPointerSlot(StackAllocSlot parent, Type pointerType, int index);
    protected virtual int GetBaseVirtualOffset();
    protected virtual int GetArrayElementSize(Slot sArray);
    protected virtual void SanityCheckArraySlot(Slot sArray);
    protected virtual int GetArrayLength(Slot sArray);
    protected virtual Slot ConvertToPointer(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    protected virtual Slot GetArrayElement(Slot sArray, int index);
    protected virtual void SetArrayElement(Slot sArray, int index, Slot value);
    protected virtual Type GetArrayElementType(Slot sArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StackAllocSlot : DefaultSlot {
    private Byte[] m_data;
    private Type m_type;
    private IVirtualStackFrame m_frame;
    public Byte[] Data { get; }
    internal bool IsDisposed { get; }
    internal ICollection`1<Slot> ChildSlots { get; }
    protected internal bool UsesPointerArithmeticSemantics { get; }
    internal StackAllocSlot(int length, Type type, IVirtualStackFrame frame, IHost host);
    public Byte[] get_Data();
    internal bool get_IsDisposed();
    public virtual Type GetTypeX();
    public virtual string ToString();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    protected internal virtual bool get_UsesPointerArithmeticSemantics();
    internal void VerifyNotDisposed();
    public virtual Slot ConvertToPointer(Type pointerType);
    public virtual Slot PointerAdd(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Ilrun.StackAwareMethodWalker : BaseMethodWalker {
    protected StackAwareMethodWalker(DecodedMethod method);
    protected abstract virtual void Push();
    protected abstract virtual void Pop();
    protected abstract virtual void ClearStack();
    protected abstract virtual void OnStackAnalysisFail();
    protected virtual void WalkBinaryOperation(BinaryOperation binOpr);
    protected virtual void WalkBooleanBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkCallStub(MethodStub stub);
    protected virtual void WalkCallHook(HookedMethod hook);
    protected virtual void WalkCallIndirect();
    protected virtual void WalkCallVirt(MethodBase method);
    protected virtual void WalkComparison(DecodedOpCode opCode);
    protected virtual void WalkCompareBranch(DecodedOpCode opCode, int target);
    protected virtual void WalkConversion(DecodedOpCode opCode);
    protected virtual void WalkDecodingError(DecodedOpCode opCode);
    protected virtual void WalkDup();
    protected virtual void WalkEndFinally();
    protected virtual void WalkEndFilter();
    protected virtual void WalkInitObj();
    protected virtual void WalkLoadArrayElement(bool isAddress);
    protected virtual void WalkLoadFrameVariable(DecodedOpCode opCode);
    protected virtual void WalkLoadImmediate(DecodedOpCode opCode);
    protected virtual void WalkLoadInstanceField(bool isAddress);
    protected virtual void WalkLoadStaticField(bool isAddress);
    protected virtual void WalkLoadVirtualFunction();
    protected virtual void WalkLeave(int target);
    protected virtual void WalkLocalAlloc();
    protected virtual void WalkNewArr();
    protected virtual void WalkNewObj(MethodStub stub);
    protected virtual void WalkNewObjHook(HookedMethod hook);
    protected virtual void WalkPop();
    protected virtual void WalkRethrow();
    protected virtual void WalkReturn();
    protected virtual void WalkStoreArrayElement();
    protected virtual void WalkStoreFrameVariable(DecodedOpCode opCode);
    protected virtual void WalkStoreIndirect(DecodedOpCode opCode);
    protected virtual void WalkStoreInstanceField();
    protected virtual void WalkStoreStaticField();
    protected virtual void WalkSwitch(Int32[] switchJumpTable);
    protected virtual void WalkThrow();
    protected virtual void WalkUnaryOperation(DecodedOpCode opCode);
    private void CallHelper(MethodBase method);
    private void NewObjHelper(MethodBase method);
    private void PopCallArgs(MethodBase method);
}
internal class Ilrun.StackOverflowAbortException : InterpreterExecutionException {
}
public enum Ilrun.StackOverflowBehavior : Enum {
    public int value__;
    public static StackOverflowBehavior ThrowException;
    public static StackOverflowBehavior FailImmediately;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StaticConstructorState : object {
    public static StaticConstructorState NotRun;
    public static StaticConstructorState InProgress;
    public static StaticConstructorState Complete;
    [NullableAttribute("2")]
public Slot TypeInitializationException;
    [NullableAttribute("2")]
public InterpreterExecutionException InterpreterExecutionException;
    private InternalState m_state;
    internal bool IsFailed { get; }
    private StaticConstructorState(InternalState state);
    private StaticConstructorState(Slot typeInitException);
    private StaticConstructorState(InterpreterExecutionException exception);
    private static StaticConstructorState();
    public virtual string ToString();
    internal static StaticConstructorState GetFailedState(Slot typeInitException);
    internal static StaticConstructorState GetFailedState(InterpreterExecutionException exception);
    internal bool get_IsFailed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StaticFieldAddressSlot : BaseAddressSlot {
    private VirtualMachine m_vm;
    private FieldInfo m_field;
    internal ICollection`1<Slot> ChildSlots { get; }
    public StaticFieldAddressSlot(VirtualMachine vm, FieldInfo field);
    public virtual Type GetTypeX();
    public virtual string ToString();
    public virtual Slot LoadIndirect();
    public virtual void BulkLoadIndirect(int slotOffset, Byte[] data, int offset, int length);
    public virtual void StoreIndirect(Slot value);
    internal virtual ICollection`1<Slot> get_ChildSlots();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StaticFieldRepository : object {
    private Dictionary`2<FieldInfo, Slot> m_staticValues;
    private Dictionary`2<Type, StaticConstructorState> m_staticCtorState;
    private CultureCache m_cultureCache;
    public CultureCache CultureCache { get; }
    public virtual CultureCache get_CultureCache();
    internal static Slot ReadStaticField_SpecialCaseInternalMscorlibFields(FieldInfo field, ISlotFactory factory);
    public virtual Slot ReadStaticField(FieldInfo field, VirtualMachine virtualMachine);
    public virtual void WriteStaticField(FieldInfo field, Slot value, VirtualMachine virtualMachine);
    public virtual void ResetStaticFields();
    public virtual void EnsureStaticCtorRun(Type type, bool fAccessingStaticField, VirtualMachine vm);
    protected virtual Slot ReadStaticFieldHelper(FieldInfo field, VirtualMachine virtualMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StringHandleOnStackSlot : HookedObjectSlot {
    private Slot m_backingSlot;
    private IHost m_host;
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal Slot BackingSlot { get; }
    public StringHandleOnStackSlot(IHost host, Type type, Slot backingSlot);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual Slot MakeValueTypeCopy();
    internal Slot get_BackingSlot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StringPointerSlot : ArrayElementPointerSlotBase {
    protected int m_offsetToStringData;
    protected int OffsetToStringData { get; }
    internal StringPointerSlot(Type pointerType, Slot sString, int offsetInBytes, int offsetToStringData);
    protected int get_OffsetToStringData();
    public virtual string ToString();
    protected virtual int GetBaseVirtualOffset();
    protected virtual void SanityCheckArraySlot(Slot sArray);
    protected virtual int GetArrayLength(Slot sArray);
    protected virtual int GetArrayElementSize(Slot sArray);
    protected virtual Slot ConvertToPointer(Type pointerType, Slot sArray, int elementOffset, int byteOffset);
    protected virtual Slot GetArrayElement(Slot sArray, int index);
    protected virtual void SetArrayElement(Slot sArray, int index, Slot value);
    protected virtual Type GetArrayElementType(Slot sArray);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StringSlot : DefaultSlot {
    private Type m_type;
    private string m_val;
    private static string EETypeFieldName;
    internal ICollection`1<Slot> ChildSlots { get; }
    public StringSlot(string value, IHost host);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual string ToString();
    protected internal virtual string GetStringWorker(bool _);
    public virtual Type GetTypeX();
    public virtual Slot GetField(FieldInfo field);
    public virtual Slot GetFieldAddress(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.StubTable : object {
    [LockedByAttribute("m_lock")]
private Dictionary`2<Guid, StubTableModuleEntry> m_moduleEntries;
    private object m_lock;
    public MethodStub GetMethodStub(MethodBase method);
    public MethodStub GetOrCreateMethodStub(MethodBase method);
    public void Clear();
    [LockedByAttribute("m_lock")]
private StubTableModuleEntry GetOrCreateModuleEntry(MethodBase method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.Stuff : object {
    public static String[] Disassemble(MethodBase method, int ipMarker, DisassemblerFlags flags);
    public static DisassemblyLine[] Disassemble(MethodBase method, DisassemblerFlags flags);
    private static void ResolveOperand(DisassemblyLine line, MetadataOnlyModule module, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static ILOpCode DecodeOpcode(Byte[] ilCode, int pc, Int32& opCodeSize);
    internal static int ArgumentSize(ILOpCode opCode, Byte[] ilCode, int pc);
    [ConditionalAttribute("DEBUG")]
[DebuggerStepThroughAttribute]
public static void AssertIsInstance(Slot slotThis, Type type, IsInstanceFlags flags, string message);
    public static bool IsInstance(Slot slotThis, Type toType, IsInstanceFlags flags);
    [ConditionalAttribute("DEBUG")]
[DebuggerStepThroughAttribute]
public static void AssertIsInst(Slot slotThis, Type type, bool exemptProxy);
    [ConditionalAttribute("DEBUG")]
[DebuggerStepThroughAttribute]
public static void AssertIsInst(Slot slotThis, Type type, bool exemptProxy, string message);
    public static void AssertThrowIsInst(Slot slotThis, Type type, bool exemptProxy);
    public static void AssertThrowIsInst(Slot slotThis, Type type, bool exemptProxy, string message);
    public static bool IsInstOrComObject(Slot slotThis, Type type, bool exemptProxy);
    public static bool IsInst(Slot slotThis, Type toType, bool exemptProxy);
    [NullableContextAttribute("2")]
public static bool AreTypesEqualOrCanon(Type t, Type o);
    private static bool CompareGenericTypesDefinition(Type t, Type o, Boolean& needGenericArgsCheck);
    public static Type FindTypeFromAssemblyLocation(Module targetModule, Type typeFromOtherModule);
    public static MethodBase FindMethodFromTypeAssemblyLocation(Type thisDeclaringType, MethodBase methodFromOtherModule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Ilrun.SupportedRuntimesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ClrVersion[] <SupportedRuntimes>k__BackingField;
    public ClrVersion[] SupportedRuntimes { get; private set; }
    public SupportedRuntimesAttribute(ClrVersion[] supportedRuntimes);
    [CompilerGeneratedAttribute]
public ClrVersion[] get_SupportedRuntimes();
    [CompilerGeneratedAttribute]
private void set_SupportedRuntimes(ClrVersion[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.System_Runtime_Intrinsics_Hooks : object {
    [NullableContextAttribute("2")]
internal static bool IsTargetNamespace(string namespace);
    internal static MethodHookDelegate GetHook(MethodBase method);
    public static Slot get_IsSupported(VirtualMachine vm, MethodBase method, CallArgs args);
    public static Slot OnUnhookedMethod(VirtualMachine vm, MethodBase method, CallArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ThreadNotAvailableException : InterpreterExecutionException {
    private MethodBase m_method;
    public MethodBase Method { get; }
    [DebuggerStepThroughAttribute]
internal ThreadNotAvailableException(MethodBase method);
    public MethodBase get_Method();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Ilrun.TraceEvents : object {
    [NullableAttribute("1")]
public static TraceEvents Instance;
    [CompilerGeneratedAttribute]
private BeginEvaluationEventHandler BeginEvaluation;
    [CompilerGeneratedAttribute]
private EndEvaluationEventHandler EndEvaluation;
    [CompilerGeneratedAttribute]
private BeginRealFuncEvalEventHandler BeginRealFuncEval;
    [CompilerGeneratedAttribute]
private EndRealFuncEvalEventHandler EndRealFuncEval;
    [CompilerGeneratedAttribute]
private RealFuncEvalExceptionEventHandler RealFuncEvalException;
    [CompilerGeneratedAttribute]
private EmulatingCallEventHandler EmulatingCall;
    [CompilerGeneratedAttribute]
private EmulatorExceptionEventHandler EmulatorException;
    [CompilerGeneratedAttribute]
private EmulatorFrameDumpEventHandler EmulatorFrameDump;
    [CompilerGeneratedAttribute]
private ExpressionEvaluatorErrorEventHandler ExpressionEvaluatorError;
    [CompilerGeneratedAttribute]
private BeginExecuteMethodEventHandler BeginExecuteMethod;
    [CompilerGeneratedAttribute]
private NoArgumentEventHandler EndExecuteMethod;
    private static TraceEvents();
    [CompilerGeneratedAttribute]
public void add_BeginEvaluation(BeginEvaluationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginEvaluation(BeginEvaluationEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndEvaluation(EndEvaluationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndEvaluation(EndEvaluationEventHandler value);
    [CompilerGeneratedAttribute]
public void add_BeginRealFuncEval(BeginRealFuncEvalEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginRealFuncEval(BeginRealFuncEvalEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndRealFuncEval(EndRealFuncEvalEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndRealFuncEval(EndRealFuncEvalEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RealFuncEvalException(RealFuncEvalExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RealFuncEvalException(RealFuncEvalExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EmulatingCall(EmulatingCallEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EmulatingCall(EmulatingCallEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EmulatorException(EmulatorExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EmulatorException(EmulatorExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EmulatorFrameDump(EmulatorFrameDumpEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EmulatorFrameDump(EmulatorFrameDumpEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ExpressionEvaluatorError(ExpressionEvaluatorErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ExpressionEvaluatorError(ExpressionEvaluatorErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void add_BeginExecuteMethod(BeginExecuteMethodEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeginExecuteMethod(BeginExecuteMethodEventHandler value);
    [CompilerGeneratedAttribute]
public void add_EndExecuteMethod(NoArgumentEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndExecuteMethod(NoArgumentEventHandler value);
    [NullableContextAttribute("1")]
internal void OnBeginEvaluation(int sequenceNum, string expressionName);
    [NullableContextAttribute("1")]
internal void OnBeginInstantiateTypeProxy(int sequenceNum, Type proxyType);
    [NullableContextAttribute("1")]
internal void OnBeginInstantiateResultsViewProxy(int sequenceNum, Type enumerableInterface);
    internal void OnBeginInstantiateDynamicViewProxy(int sequenceNum);
    [NullableContextAttribute("1")]
internal void OnBeginExecutePropertyGetter(int sequenceNum, PropertyInfo property);
    internal void OnEndEvaluation(int sequenceNum, bool succeeded);
    [NullableContextAttribute("1")]
internal void OnBeginRealFuncEval(int sequenceNum, int ilOffsetOfCall, MethodBase method);
    internal void OnEndRealFuncEval(int sequenceNum, int ilOffsetOfCall);
    [NullableContextAttribute("1")]
internal void OnEmulatingCall(int sequenceNum, int ilOffsetOfCall, MethodBase method);
    [NullableContextAttribute("1")]
internal void OnEmulatorException(int sequenceNum, InterpreterExecutionException exception);
    [NullableContextAttribute("1")]
internal void OnExpressionEvaluatorError(int sequenceNum, string message);
    [NullableContextAttribute("1")]
internal void OnRealFuncEvalException(int sequenceNum, int hr, string error, bool willRetry);
    [NullableContextAttribute("1")]
internal void OnBeginExecuteMethod(MethodBase method);
    internal void OnEndExecuteMethod();
    [NullableContextAttribute("1")]
private string GetDeclaringTypeName(MethodBase m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.TypedReferencePointerOnStackSlot : DefaultSlot {
    private TypedReferenceSlot m_slot;
    private Type m_type;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal TypedReferenceSlot TypedReference { get; }
    internal TypedReferencePointerOnStackSlot(TypedReferenceSlot slot);
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    internal TypedReferenceSlot get_TypedReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.TypedReferenceSlot : DefaultSlot {
    private Slot m_slot;
    private Type m_type;
    private Type m_refType;
    internal Slot RefSlot { get; }
    internal ICollection`1<Slot> ChildSlots { get; }
    internal TypedReferenceSlot(Slot slot, Type refType);
    internal Slot get_RefSlot();
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual bool IsNull();
    public virtual string ToString();
    public virtual Slot MakeValueTypeCopy();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.TypeSlot : HookedObjectSlot {
    private Type m_type;
    internal Type TypeX { get; }
    public string FullName { get; }
    public TypeSlot(IHost host, Type type, Type typeOfType);
    internal Type get_TypeX();
    public virtual VirtualAddress GetVirtualAddress();
    public string get_FullName();
    public virtual string ToString();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    public virtual Type GetTypeWorker();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.UnableToDecodeTransparentProxyException : InterpreterExecutionException {
    public UnableToDecodeTransparentProxyException(string message);
    public UnableToDecodeTransparentProxyException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.UnableToFindHostMethodException : InterpreterExecutionException {
    public MethodBase Method;
    public UnableToFindHostMethodException(MethodBase method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.UnableToFindMemberException : InterpreterExecutionException {
    public Type TargetType;
    public MemberInfo Member;
    public UnableToFindMemberException(Type type, MemberInfo member);
}
internal class Ilrun.UnsupportedInterpreterOperationException : InterpreterExecutionException {
    [NullableContextAttribute("1")]
internal UnsupportedInterpreterOperationException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Ilrun.UnsupportedRuntimesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ClrVersion[] <UnsupportedRuntimes>k__BackingField;
    public ClrVersion[] UnsupportedRuntimes { get; private set; }
    public UnsupportedRuntimesAttribute(ClrVersion[] unsupportedRuntimes);
    [CompilerGeneratedAttribute]
public ClrVersion[] get_UnsupportedRuntimes();
    [CompilerGeneratedAttribute]
private void set_UnsupportedRuntimes(ClrVersion[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.UntypedAddressSlot : DefaultSlot {
    private DefaultSlot m_addr;
    [NullableAttribute("2")]
private BaseAddressSlot m_underlyingSlot;
    private Type m_type;
    private CorElementType m_corType;
    internal ICollection`1<Slot> ChildSlots { get; }
    protected internal bool UsesPointerArithmeticSemantics { get; }
    public UntypedAddressSlot(Slot address, CorElementType targetType, BaseAddressSlot underlyingSlotAtAddress);
    public UntypedAddressSlot(Slot address, Type type);
    public static Slot CreateSlotForIntPtr(IHost host, PrimitiveValue pv);
    public virtual void GetBytes(Byte[] buffer, int bufferOffset, int slotOffset, int length);
    public virtual string ToString();
    private bool IsTruncated();
    public virtual Type GetTypeX();
    internal virtual ICollection`1<Slot> get_ChildSlots();
    public virtual bool IsNull();
    public virtual Slot LoadIndirect();
    public virtual void StoreIndirect(Slot value);
    public virtual Slot GetField(FieldInfo field);
    public virtual void SetField(Slot value, FieldInfo field);
    private void ValidateGetOrSetField(FieldInfo field);
    public virtual Slot ConvertToInteger(CorElementType integerType);
    public virtual VirtualAddress GetVirtualAddress();
    public virtual Slot PointerAdd(int offset);
    protected internal virtual bool get_UsesPointerArithmeticSemantics();
    public virtual Slot ConvertToPointer(Type pointerType);
    internal virtual Integer GetAsIntegerValue();
    private static DefaultSlot ValidateAndUnwrapAddr(Slot address);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.Util : object {
    internal static V LookupAndAdd(Dictionary`2<K, V> dict, K key, ValueCreateDelegate`2<K, V> vcd);
    internal static V Remove(Dictionary`2<K, V> dict, K key);
    [NullableContextAttribute("2")]
internal static bool IsNullOrEmpty(Array arr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Ilrun.Utility : object {
    public static Int32[] ZeroArrayLowerBounds;
    private static string InlineArrayAttributeName;
    private static Utility();
    public static Slot GetPrimitiveSlotFromBytes(ISlotFactory factory, Type type, Byte[] bytes);
    public static Slot GetSlotForNull(ISlotFactory factory);
    public static Slot GetSlotForBool(ISlotFactory factory, bool value);
    public static Slot GetSlotForInteger(ISlotFactory factory, int value);
    public static Slot GetSlotForShort(ISlotFactory factory, short value);
    public static Slot GetSlotForString(ISlotFactory factory, string value);
    public static Slot GetSlotForAssembly(ISlotFactory factory, Assembly assembly);
    public static Slot GetSlotForMethod(ISlotFactory factory, MethodBase method);
    public static Slot GetSlotForField(ISlotFactory factory, FieldInfo field);
    public static Slot GetSlotForArray(ISlotFactory factory, Type elementType, int length);
    public static Slot GetSlotForObject(VirtualMachine virtualMachine, object value);
    internal static Slot GetSlotForDecimal(VirtualMachine virtualMachine, decimal value);
    public static Slot GetSlotForObject(ISlotFactory factory, object value);
    public static Slot GetSlotForGuid(VirtualMachine virtualMachine, Guid hostValue);
    public static Slot GetSlotForVersion(VirtualMachine virtualMachine, Version version);
    public static Slot GetSlotForMemoryStream(VirtualMachine virtualMachine, MemoryStream stream);
    public static Slot GetSlotForUnmanagedMemoryStream(VirtualMachine virtualMachine, Byte[] data);
    public static Slot GetSlotForEnum(ISlotFactory factory, Type enumType, Slot value);
    public static Slot GetSlotForType(ISlotFactory factory, Type type);
    internal static Slot GetSlotForPrimitive(ISlotFactory fac, PrimitiveValue pv);
    internal static Slot GetSlotForLiteralStaticField(ISlotFactory factory, FieldInfo fieldInfo);
    public static int ParameterCount(MethodBase method);
    public static Type[] GetParameterTypes(MethodBase method);
    public static bool IsDelegate(Type tx);
    public static bool HasReturnValue(MethodBase method);
    public static bool IsMscorlib(MemberInfo member);
    public static bool IsBuiltInType(Type type);
    public static bool IsBuiltInType(Type type, CorElementType builtInType);
    public static bool IsGenericKnownType(Type type, KnownType knownType);
    [NullableContextAttribute("2")]
public static bool IsKnownType(Type type, KnownType knownType);
    public static bool IsKnownType(Type type);
    public static bool IsKnownTypeName(Type type, string fullName);
    public static bool IsKnownOrBuiltInType(Type type);
    public static bool IsOrDerivedFromKnownType(Type type, KnownType knownType);
    public static bool IsAsyncMethod(MethodInfo method);
    public static ConstructorInfo TryGetStaticConstructor(Type declaringType);
    public static bool IsStaticConstructor(MethodBase method);
    public static bool IsPrimitive(CorElementType type);
    internal static bool IsInteger(PrimitiveType type);
    internal static bool IsReflectionType(Type type);
    public static CorElementType GetRawElementType(object boxedValue);
    public static Byte[] GetBytesForPrimitiveSlot(Slot slot);
    public static int GetPrimitiveTypeSize(CorElementType type);
    public static int GetPrimitiveTypeSize(Type type);
    public static int GetTypeSize(IHost host, Type type);
    public static Type GetUnderlyingEnumType(Type enumType);
    public static CorElementType GetRawElementType(Type type);
    public static Type GetTypeXFromHostType(ITypeUniverse universe, Type type);
    internal static VirtualMachine CreateDummyVM(IHost host);
    public static Byte[] GetBytesForPrimitiveValue(object boxedValue);
    internal static Slot GetCustomAttributesAsArraySlot(VirtualMachine vm, MemberInfo member, CallArgs args);
    internal static Slot GetCustomAttributesAsArraySlot(VirtualMachine vm, Assembly assembly, CallArgs args);
    internal static Slot GetCustomAttributesAsArraySlot(VirtualMachine vm, MemberInfo member, Type tFilter, bool fInherit);
    internal static Slot GetCustomAttributesAsArraySlot(VirtualMachine vm, Assembly assembly, Type tFilter, bool fInherit);
    internal static Slot GetCustomAttributesAsArraySlot(VirtualMachine vm, IList`1<CustomAttributeData> data, Type tFilter);
    internal static void GetBytesFromValueType(Slot sValueType, Byte[] bytes, int arrayOffset, int length);
    private static bool TryGetFieldSizeForFixedBuffer(FieldInfo field, Int32& fieldSize);
    public static int GetFieldSize(IHost host, FieldInfo field);
    public static IList`1<FieldInfo> GetAllInstanceFields(Type type);
    public static FieldInfo[] GetAllInstanceFieldsDeclaredOnType(Type type);
    public static IList`1<FieldInfo> GetAllStaticFields(Type type);
    internal static ConstructorInfo GetDefaultConstructor(Type type);
    internal static Slot InstantiateTypeWithDefaultConstructor(VirtualMachine vm, Type type, bool fAllowNonPublic);
    internal static Slot InvokeMethodViaReflection(VirtualMachine vm, MethodBase method, Slot sThis, Slot sArgArray);
    internal static Slot InvokeMethodViaReflection(VirtualMachine vm, MethodBase method, Slot sThis, Slot[] args);
    internal static bool IsNullable(Slot s);
    internal static bool IsNullable(Type t);
    internal static Type TryGetUnderlyingNullableType(Type t);
    internal static bool NullableHasValue(Slot s);
    public static Slot Box(VirtualMachine vm, Slot slot);
    internal static Slot Box(VirtualMachine vm, Slot slot, Type type);
    [NullableContextAttribute("2")]
private static Slot GetValueOfNullableSlot(VirtualMachine vm, Slot s);
    private static Slot GetValueOfNullableSlotHelper(VirtualMachine vm, Slot s);
    [NullableContextAttribute("2")]
internal static bool IsEqual(object o1, object o2);
    internal static Type GetArgType(MethodBase method, int argIdx);
    internal static bool IsTypeReadOnly(Type t);
    public static string FormatMemberName(MemberInfo member, bool includeModule);
    public static string FormatTypeName(Type type, bool includeModule, bool removeGenericArgumentCount);
    private static void AppendTypeName(Type type, bool includeModule, StringBuilder nameBuilder, bool removeGenericArgumentCount);
    private static void AppendTypeList(Type declaringType, Type[] list, StringBuilder builder, bool removeGenericArgumentCount);
    internal static MethodInfo ResolvePropertyGetter(PropertyInfo propertyInfo);
    internal static PropertyInfo FindPropertyWithGetterByName(Type type, string name);
    internal static FieldInfo FindFirstFieldMatchingNames(Type type, BindingFlags bindingFlags, String[] fieldNames);
    internal static FieldInfo GetFieldInType(Type type, FieldInfo field);
    internal static int SizeOf(IHost host, Type type);
    internal static bool HasLayoutMetadata(Type type, Boolean& explicitOffsets);
    internal static bool HasObjectLayout(Type type);
    internal static bool IsGCPointer(Type type);
    internal static Slot TryAutoMarshal(Slot value, Type expected);
    internal static Slot TryAutoMarshalInternal(Slot value, Type expected);
    public static bool IsByRefLike(Type type);
    public static bool IsInlineArray(Type type);
    public static int GetInlineArrayLength(Type type);
    public static bool CanReadRvaInfoForField(FieldInfo field);
}
internal class Ilrun.ValueCreateDelegate`2 : MulticastDelegate {
    public ValueCreateDelegate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual V Invoke(K key);
    public virtual IAsyncResult BeginInvoke(K key, AsyncCallback callback, object object);
    public virtual V EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.ValueTypeSlot : ObjectSlot {
    public ValueTypeSlot(Type type, IHost host);
    public virtual string ToString();
}
internal class Ilrun.VectorType : MetadataOnlyVectorType {
    private bool System.Reflection.Adds.ITypeForInterpreter.IsVector { get; }
    [NullableContextAttribute("1")]
internal VectorType(MetadataOnlyCommonType elementType);
    private sealed virtual override bool System.Reflection.Adds.ITypeForInterpreter.get_IsVector();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.VilTimeoutException : InterpreterExecutionException {
    public VilTimeoutException(string message);
    public VilTimeoutException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Ilrun.VirtualAddress : object {
    private object m_domain;
    private long m_offset;
    public object Domain { get; }
    public long Offset { get; }
    public VirtualAddress(object domain);
    public VirtualAddress(object domain, long offset);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public bool Equals(VirtualAddress address);
    public object get_Domain();
    public long get_Offset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.VirtualDispatchCache : object {
    [LockedByAttribute("m_lock")]
private Dictionary`2<Type, Dictionary`2<MethodInfo, VirtualDispatchResult>> m_cache;
    private object m_lock;
    internal MethodInfo ResolveVirtualFromCache(Type targetType, MethodInfo baseMethod, List`1<MethodInfo> newSlotsThatHideBaseMethod);
    internal void AddResultToCache(Type targetType, MethodInfo baseMethod, MethodInfo result, List`1<MethodInfo> newSlotsThatHideBaseMethod);
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.VirtualDispatchResolver : object {
    private VirtualDispatchCache m_cache;
    public sealed virtual MethodBase ResolveVirtual(Slot slotThis, MethodBase method);
    public sealed virtual MethodInfo ResolveStaticVirtual(MethodInfo method, Type targetType);
    public sealed virtual void ClearDispatchCache();
    private static Type GetInstantiatedResolvedMethodType(Type targetType, Type baseType);
    private static void StripGenericTypeInstantiationsHelper(Type type, Type baseType, Type instantiatedOrigType, List`1<Type> results, List`1<Type[]> genericArgList);
    private static MethodInfo StripGenericTypeInstantiations(Type type, MethodInfo method, Type[]& genericArgsForRawMethod);
    private MethodInfo ResolveVirtualOrStaticVirtualWorker(Type targetType, MethodInfo baseMethod, List`1<MethodInfo> newSlotMethodsThatHideBaseMethod);
    private void AddResultToCache(Type targetType, MethodInfo baseMethod, MethodInfo result, List`1<MethodInfo> newSlotMethodsThatHideBaseMethod);
    private MethodInfo ResolveVirtualFromCache(Type targetType, MethodInfo baseMethod, List`1<MethodInfo> newSlotMethodsThatHideBaseMethod);
    [NullableContextAttribute("2")]
private static MethodInfo ProcessNewSlotAttribute(MethodInfo result, List`1<MethodInfo> newSlotMethodsThatHideBaseMethod);
    private static MethodInfo GetInterfaceImplementationOnType(Type targetType, MethodInfo baseMethod);
    private static MethodInfo GetDirectExplicitMethodImplementation(Type targetType, MethodInfo baseMethod);
    private static MethodInfo GetVariantExplicitInterfaceImplemention(Type targetType, MethodInfo baseMethod);
    private static MethodInfo FindingMatchingImplementedInterfaceMethod(Type targetType, MethodInfo baseMethod);
    private static Type FindMatchingInterface(Type targetType, Type interfaceType, bool allowVariance);
    private static MethodInfo FindMatchingMethod(Type targetType, MethodInfo baseMethod);
    private static bool IsNewSlot(MethodInfo method);
    private static bool MatchSignatures(MethodInfo candidate, MethodInfo baseMethod);
    private static bool MatchTypesInMethodSignature(Type t1, Type t2);
    private static ClrVersionImpl GetVersion(IHost host);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.VirtualDispatchResult : object {
    private MethodInfo m_result;
    private List`1<MethodInfo> m_newSlotMethodsThatHideBaseMethod;
    internal MethodInfo Result { get; }
    internal ReadOnlyCollection`1<MethodInfo> NewSlotsThatHideBaseMethod { get; }
    internal VirtualDispatchResult(MethodInfo result, List`1<MethodInfo> newSlotsThatHideBaseMethod);
    internal MethodInfo get_Result();
    internal ReadOnlyCollection`1<MethodInfo> get_NewSlotsThatHideBaseMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.VirtualMachine : object {
    private static int c_FastExecuteMaxCodeLength;
    private static int c_FastExecuteMaxStackDepth;
    private static int c_DefaultMaxStackDepth;
    private static int c_DefaultMaxInstructionCount;
    private static TimeoutEnforcementBehavior s_timeoutEnforcement;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static VirtualMachine s_currentInstance;
    private BinaryOperationFunc[] m_binaryOperations;
    private Stack`1<ExecutionInstance> m_executionInstances;
    private ISlotFactory m_slotFactory;
    private IArithmeticProvider m_arithmeticProvider;
    private ITypeUniverse m_typeUniverse;
    private CommonSlotConst m_commonConst;
    private StubTable m_stubTable;
    private StackOverflowBehavior m_stackOverflowBehavior;
    [NullableAttribute("2")]
private Stopwatch m_currentExecutionStopwatch;
    private bool m_debuggingEnabled;
    private bool m_exceptionAtInstruction;
    private bool m_attemptingRootHook;
    private bool m_rootHookCanceled;
    private bool m_fastExecuteEnabled;
    [NullableAttribute("2")]
private MethodBase m_inspectionMethod;
    private MachineState m_machineState;
    [NullableAttribute("2")]
private Slot m_machineReturnValue;
    [NullableAttribute("2")]
private ExecutionInstance m_currentExecutionInstance;
    [NullableAttribute("2")]
private VM2Frame m_currentFrame;
    [NullableAttribute("2")]
private DecodedMethod m_currentMethod;
    [NullableAttribute("2")]
private DecodedInstruction[] m_currentMethodInstructions;
    private int m_instructionOffset;
    private int m_maxStackDepth;
    private int m_framesBeforeStackOverflow;
    private long m_totalInstructionCount;
    [CompilerGeneratedAttribute]
private IHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxExecutionTimeMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxInstructionCount>k__BackingField;
    public IHost Host { get; private set; }
    public int MaxExecutionTimeMilliseconds { get; public set; }
    public int MaxInstructionCount { get; public set; }
    public int MaxStackDepth { get; public set; }
    public ITypeUniverse TypeUniverse { get; }
    public ISlotFactory SlotFactory { get; }
    public IEnumerable`1<IVirtualStackFrame> CallStack { get; }
    public int CallStackFrameCount { get; }
    [NullableAttribute("2")]
public IVirtualStackFrame CurrentFrame { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<IVirtualStackFrame> CurrentVirtualCallStack { get; }
    [NullableAttribute("2")]
public MethodBase CallerOfCurrentMethod { get; }
    internal bool IsFastExecuteEnabled { get; }
    public VirtualMachine(IHost host);
    [CompilerGeneratedAttribute]
public IHost get_Host();
    [CompilerGeneratedAttribute]
private void set_Host(IHost value);
    [CompilerGeneratedAttribute]
public int get_MaxExecutionTimeMilliseconds();
    [CompilerGeneratedAttribute]
public void set_MaxExecutionTimeMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_MaxInstructionCount();
    [CompilerGeneratedAttribute]
public void set_MaxInstructionCount(int value);
    public int get_MaxStackDepth();
    public void set_MaxStackDepth(int value);
    public ITypeUniverse get_TypeUniverse();
    public ISlotFactory get_SlotFactory();
    public IEnumerable`1<IVirtualStackFrame> get_CallStack();
    public int get_CallStackFrameCount();
    [NullableContextAttribute("2")]
public IVirtualStackFrame get_CurrentFrame();
    public static IEnumerable`1<IVirtualStackFrame> get_CurrentVirtualCallStack();
    [NullableContextAttribute("2")]
public MethodBase get_CallerOfCurrentMethod();
    public Slot DirectAllocateObject(Type typeObject);
    public MethodBase ResolveVirtual(Slot slotThis, MethodBase method);
    public MethodInfo ResolveStaticVirtual(MethodInfo method, Type targetType);
    public void EnableDebugging();
    public Slot ExecuteMethod(MethodBase method, CallArgs args);
    public Slot ExecuteMethodNoHooks(MethodBase method, CallArgs args, bool isForInspection);
    public Slot ExecuteInspectionQuery(MethodBase method, IVirtualStackFrame inspectionFrame);
    public void VThrow(Slot exceptionSlot);
    public bool VThrowIfNullSlot(Slot s);
    [NullableContextAttribute("2")]
public Slot GetBuiltInSystemException(KnownType exceptionType, string message, Slot innerException);
    public void ResetExceptionState();
    public Slot CancelHook(CallArgs args);
    internal MethodStub LocateMethodStub(MethodBase method, bool persist);
    internal DecodedMethod GetDecodedMethod(MethodBase method, bool enableDebugging);
    [NullableContextAttribute("2")]
internal HookedMethod TryGetHookedMethod(MethodBase method, MethodBase caller);
    internal bool ShouldTryFastExecute(MethodInfo method, FastExecuteDisabledReason& disabledReason);
    internal void EnableFastExecute();
    internal bool get_IsFastExecuteEnabled();
    private bool DisableFastExecuteAndReturnFalse(MethodBase method, InterpreterExecutionException exception);
    [NullableContextAttribute("2")]
private Slot ExecuteMethodInternal(MethodBase method, CallArgs args, IVirtualStackFrame inspectionFrame);
    private StopReason RunForward();
    private bool Filter_RunForward_InterpreterExecutionException(InterpreterExecutionException e, ExceptionAction& exceptionAction);
    [MemberNotNullAttribute("m_currentExecutionInstance")]
private void BeginExecutionInstance();
    private void EndExecutionInstance();
    [MemberNotNullAttribute("m_currentFrame")]
private void PushFrame(MethodBase method, IVirtualStackFrame inspectionFrame);
    private void PopFrame();
    [NullableContextAttribute("2")]
[MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void BeginExecuteStub(MethodStub stub, CallArgs args, bool tailCall, IVirtualStackFrame inspectionFrame);
    private void DecodeMethod(MethodStub stub, bool enableDebugging, bool doFastDecode);
    private bool AllowFastExecute(MethodBody mb, IList`1<ExceptionHandlingClause> ehClauses, FastExecuteDisabledReason& disabledReason);
    private void TryBranchInstruction(int target);
    private void ForwardLoop();
    internal void CheckForCancellationAndLimits();
    private void FwLdLoc(int loc);
    private void FwLdArg(int arg);
    private void FwStLoc(int loc);
    private void FwStArg(int arg);
    private void FwLdLocA(int loc);
    private void FwLdArgA(int arg);
    private void FwLdNull();
    private void FwLdc(Slot s);
    private void FwLdcC(int id);
    private void FwDup();
    private void FwPop();
    private void FwCall(MethodStub stub);
    private void FwCallHook(HookedMethod hook);
    private void FwCalli();
    private void FwCallVirt(MemberInfo func);
    private void FwRet();
    private void FwBr(int target);
    private void FwBrFalse(int target);
    private void FwBrTrue(int target);
    private void FwBeq(int target);
    private void FwBge(int target);
    private void FwBgt(int target);
    private void FwBle(int target);
    private void FwBlt(int target);
    private void FwBneUn(int target);
    private void FwBgeUn(int target);
    private void FwBgtUn(int target);
    private void FwBleUn(int target);
    private void FwBltUn(int target);
    private void FwSwitch(Int32[] jumpTable);
    private void FwLdInd(CorElementType t);
    private void FwStInd(CorElementType t);
    private void FwBinaryOperation(int operationId);
    private void FwNot();
    private void FwNeg();
    private void FwLdFld(MemberInfo member);
    private void FwLdFldA(MemberInfo field);
    private void FwStFld(MemberInfo member);
    private void FwLdSFld(MemberInfo field);
    private void FwLdSFldA(MemberInfo field);
    private void FwStSFld(MemberInfo member);
    private void FwConv(CorElementType t);
    private void FwConvOvf(CorElementType t);
    private void FwConvOvfUn(CorElementType t);
    private void FwLdObj(MemberInfo t);
    private void FwStObj(MemberInfo t);
    private void FwNewObj(MethodStub stub);
    private void FwNewObjHk(HookedMethod hook);
    private void FwNewArr(MemberInfo t);
    private void FwLdLen();
    private void FwLdElem();
    private void FwLdElemA(MemberInfo t);
    private void FwStElem();
    private void FwCastClass(MemberInfo t);
    private void FwIsInst(MemberInfo t);
    private void FwBox(MemberInfo t);
    private void FwUnbox(MemberInfo t);
    private void FwUnboxAny(MemberInfo memType);
    private void FwThrow();
    private void FwRethrow();
    private void FwLeave(int target);
    private void FwEndFinally();
    private void FwEndFilter();
    private void FwCeq();
    private void FwCgt();
    private void FwCgtUn();
    private void FwClt();
    private void FwCltUn();
    private void FwLocAlloc();
    private void FwInitObj(MemberInfo t);
    private void FwCallPrefix(DecodedInstruction instruction);
    private void FwLdFtn(MethodStub stub);
    private void FwLdFtnHk(HookedMethod hook);
    private void FwLdVirtFtn(MemberInfo ftn);
    private void FwLdToken(MemberInfo member);
    private void FwMkRefAny(MemberInfo member);
    private void FwMissingField(Slot exceptionMessage);
    private void FwMissingMethod(Slot exceptionMessage);
    private void FwTypeLoadException(Slot exceptionMessage);
    private void FwFileNotFound(Slot exceptionMessage);
    private void FwUnsupported(int ilOpCode);
    private void Push(Slot s);
    private Slot Pop();
    private void PushBool(bool b);
    private void PushNull();
    private void ClearEvaluationStack();
    private IEnumerable`1<IVirtualStackFrame> EnumerateFullCallStack();
    private void ExecuteCallStub(MethodStub stub, bool isTailCall);
    private void ExecuteVirtualCall(MethodBase originalMethod, bool isTailCall, Type constrainedType);
    private void ExecuteStaticVirtualCall(MethodInfo originalMethod, bool isTailCall, Type constrainedType);
    private void ExecuteHookedMethod(HookedMethod hook, CallArgs args);
    private void ExecuteIndirectCall(bool isTailCall);
    private void BeginExecuteHandlerBlock(Slot pendingException, int nextHandlerIndex);
    [NullableContextAttribute("2")]
private void EnsureStaticCtorRun(Type declaringType, bool isAccessingField);
    private CallArgs PopArgs(MethodBase method);
    private CallArgs PopStaticArgs(MethodBase method);
    private void CastHelper(Type type);
    private void IsInstHelper(Type type);
    private Slot MaybeBoxCallResult(MethodBase method, Slot result);
    private int GetCurrentIlOffset();
    [DoesNotReturnAttribute]
private void InvalidProgram(string reasonMessage);
    private void ValidateMethodArguments(MethodBase method, CallArgs args);
    public string DumpDebugInformation(DumpFrameFlags flags);
    public void DisassembleMethod(DumpFrameFlags flags, MethodBase method, int ip, List`1<string> textLines);
    [ConditionalAttribute("DEBUG")]
public void AssertClrV2();
    [ConditionalAttribute("DEBUG")]
public void AssertClrV4();
    [ConditionalAttribute("DEBUG")]
private void ValidateMethodToExecute(MethodBase method, CallArgs args);
    private static bool IsDecodedFlagSet(DumpFrameFlags flags);
    private static void DumpDecodedMethodText(DumpFrameFlags flags, DecodedMethod method, int ip, List`1<string> textLines);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.WeakReferenceSlot : HookedObjectSlot {
    private Slot m_target;
    internal ICollection`1<Slot> ChildSlots { get; }
    internal WeakReferenceSlot(Slot target);
    internal virtual ICollection`1<Slot> get_ChildSlots();
    private static Type GetTypeOfWeakReference(Slot target);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.XNameSlot : HookedObjectSlot {
    private XNamespaceSlot m_ns;
    private string m_localName;
    public XNameSlot(IHost host, Type type, XNamespaceSlot ns, string localName);
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    internal static XNameSlot TryGetAsXNameSlot(IHost host, Slot slot);
    internal static bool XNamesEqual(IHost host, Slot slot1, Slot slot2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Ilrun.XNamespaceSlot : HookedObjectSlot {
    private string m_name;
    public string NamespaceName { get; }
    public XNamespaceSlot(IHost host, Type type, string name);
    public string get_NamespaceName();
    internal virtual Slot TryExecute(VirtualMachine virtualMachine, MethodBase method, CallArgs callArguments, Boolean& useInterpreter);
    internal static XNamespaceSlot AsXNamespaceSlot(IHost host, Slot slot);
    internal static XNamespaceSlot TryGetAsXNamespaceSlot(IHost host, Slot slot);
    public static bool XNamespaceEquals(IHost host, Slot slot1, Slot slot2);
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.AlignmentHelper : object {
    [ExtensionAttribute]
public static int AlignUp(int val, int alignment);
}
internal class Internal.TypeSystem.Common.ClassLayoutMetadata : ValueType {
    public int PackingSize;
    public int Size;
    [NullableAttribute("1")]
public FieldAndOffset[] Offsets;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.ComputedInstanceFieldLayout : object {
    public LayoutInt FieldSize;
    public LayoutInt FieldAlignment;
    public LayoutInt ByteCountUnaligned;
    public LayoutInt ByteCountAlignment;
    public bool LayoutAbiStable;
    public bool IsAutoLayoutOrHasAutoLayoutFields;
    public FieldAndOffset[] Offsets;
    public ComputedInstanceFieldLayout(LayoutInt fieldSize, LayoutInt fieldAlignment, LayoutInt byteCountUnaligned, LayoutInt byteCountAlignment, bool layoutAbiStable, bool isAutoLayoutOrHasAutoLayoutFields, FieldAndOffset[] offsets);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.ComputedObjectLayout : object {
    private Dictionary`2<FieldInfo, int> m_offsetDict;
    private int m_objectSize;
    public ComputedObjectLayout(Dictionary`2<FieldInfo, int> offsetDict, int objectSize);
    public static ComputedObjectLayout Create(TypeSystemContext context, Type type);
    public sealed virtual int GetFieldOffset(FieldInfo field);
    public sealed virtual int GetObjectSize();
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.DefTypeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type ContainingType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.DefTypeFieldLayoutExtensions : object {
    [ExtensionAttribute]
public static bool ContainsGCPointers(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static bool IsAutoLayoutOrHasAutoLayoutFields(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static LayoutInt InstanceFieldSize(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static LayoutInt InstanceFieldAlignment(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static LayoutInt InstanceByteCount(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static LayoutInt InstanceByteCountUnaligned(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static LayoutInt InstanceByteAlignment(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static bool IsZeroSizedReferenceType(Type type, TypeSystemContext context);
    [ExtensionAttribute]
public static bool LayoutAbiStable(Type type, TypeSystemContext context);
    public static ComputedInstanceFieldLayout ComputeInstanceLayout(TypeSystemContext context, Type type);
    private static bool ComputeTypeContainsGCPointers(TypeSystemContext context, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.FieldAndOffset : ValueType {
    public static LayoutInt InvalidOffset;
    public FieldInfo Field;
    public LayoutInt Offset;
    public FieldAndOffset(FieldInfo field, LayoutInt offset);
    private static FieldAndOffset();
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.FieldDescExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Type OwningType(FieldInfo field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Internal.TypeSystem.Common.FieldLayoutAlgorithm : object {
    public abstract virtual ComputedInstanceFieldLayout ComputeInstanceLayout(Type type);
    public abstract virtual bool ComputeContainsGCPointers(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.LayoutInt : ValueType {
    private int _value;
    public static LayoutInt Indeterminate;
    public static LayoutInt Zero;
    public static LayoutInt One;
    public bool IsIndeterminate { get; }
    public int AsInt { get; }
    public LayoutInt(int input);
    private static LayoutInt();
    private static LayoutInt CreateIndeterminateLayoutInt();
    public bool get_IsIndeterminate();
    public int get_AsInt();
    public virtual string ToString();
    public string ToStringInvariant();
    public static bool op_Equality(LayoutInt left, LayoutInt right);
    public static bool op_Inequality(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Addition(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Subtraction(LayoutInt left, LayoutInt right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LayoutInt Max(LayoutInt left, LayoutInt right);
    public static LayoutInt Min(LayoutInt left, LayoutInt right);
    public static LayoutInt AlignUp(LayoutInt value, LayoutInt alignment, TargetDetails target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.MetadataTypeExtensions : object {
    private static int GetFieldOffsetFromAttribute(FieldInfo field);
    [ExtensionAttribute]
public static ClassLayoutMetadata GetClassLayout(Type type);
    [ExtensionAttribute]
public static bool IsSequentialLayout(Type type);
    [ExtensionAttribute]
public static bool IsModuleType(Type type);
    [ExtensionAttribute]
public static Type MetadataBaseType(Type type);
    [ExtensionAttribute]
public static bool IsInlineArray(Type type);
    [ExtensionAttribute]
public static int GetInlineArrayLength(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.SystemObjectFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    private FieldLayoutAlgorithm _fallbackAlgorithm;
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    public TypeSystemContext Context { get; }
    public SystemObjectFieldLayoutAlgorithm(TypeSystemContext context, FieldLayoutAlgorithm fallbackAlgorithm);
    [CompilerGeneratedAttribute]
public TypeSystemContext get_Context();
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(Type defType);
    public virtual bool ComputeContainsGCPointers(Type type);
}
internal enum Internal.TypeSystem.Common.TargetAbi : Enum {
    public int value__;
    public static TargetAbi Unknown;
    public static TargetAbi CoreRT;
    public static TargetAbi CoreRTArmel;
    public static TargetAbi Jit;
    public static TargetAbi CppCodegen;
}
internal enum Internal.TypeSystem.Common.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture Unknown;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARM64;
    public static TargetArchitecture X64;
    public static TargetArchitecture X86;
    public static TargetArchitecture Wasm32;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.Common.TargetDetails : object {
    [CompilerGeneratedAttribute]
private TargetArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetOS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetAbi <Abi>k__BackingField;
    public TargetArchitecture Architecture { get; }
    public TargetOS OperatingSystem { get; }
    public TargetAbi Abi { get; }
    public int PointerSize { get; }
    public bool SupportsRelativePointers { get; }
    public int MaximumAlignment { get; }
    public LayoutInt LayoutPointerSize { get; }
    public int DefaultPackingSize { get; }
    public int MinimumFunctionAlignment { get; }
    public int OptimumFunctionAlignment { get; }
    public int MinimumCodeAlignment { get; }
    public static int MaximumLog2PrimitiveSize { get; }
    public static int MaximumPrimitiveSize { get; }
    public bool IsWindows { get; }
    public bool IsOSX { get; }
    public int MaxHomogeneousAggregateElementCount { get; }
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi);
    [CompilerGeneratedAttribute]
public TargetArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public TargetOS get_OperatingSystem();
    [CompilerGeneratedAttribute]
public TargetAbi get_Abi();
    public int get_PointerSize();
    public bool get_SupportsRelativePointers();
    public int get_MaximumAlignment();
    public LayoutInt get_LayoutPointerSize();
    public int get_DefaultPackingSize();
    public int get_MinimumFunctionAlignment();
    public int get_OptimumFunctionAlignment();
    public int get_MinimumCodeAlignment();
    public static int get_MaximumLog2PrimitiveSize();
    public static int get_MaximumPrimitiveSize();
    public LayoutInt GetWellKnownTypeSize(Type type);
    public LayoutInt GetWellKnownTypeAlignment(Type type);
    public LayoutInt GetObjectAlignment(LayoutInt fieldAlignment);
    public bool get_IsWindows();
    public bool get_IsOSX();
    public int get_MaxHomogeneousAggregateElementCount();
    public virtual string ToString();
}
internal enum Internal.TypeSystem.Common.TargetOS : Enum {
    public int value__;
    public static TargetOS Unknown;
    public static TargetOS Windows;
    public static TargetOS Linux;
    public static TargetOS OSX;
    public static TargetOS FreeBSD;
    public static TargetOS NetBSD;
    public static TargetOS SunOS;
    public static TargetOS WebAssembly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Internal.TypeSystem.Common.ThrowHelper : object {
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
public static void ThrowTypeLoadException(string format, Type type, string messageArg);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
public static void ThrowTypeLoadException(string format, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.TypeDescExtensions : object {
    [ExtensionAttribute]
public static bool HasInstantiation(Type type);
    [ExtensionAttribute]
public static bool IsObject(Type type);
    [ExtensionAttribute]
public static bool IsDefType(Type type);
    [ExtensionAttribute]
public static bool IsGCPointer(Type type);
    [ExtensionAttribute]
public static bool HasBaseType(Type type);
    [ExtensionAttribute]
public static Type UnderlyingType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetDeclaredFields(Type type);
    [ExtensionAttribute]
public static bool IsGenericDefinition(Type type);
    [ExtensionAttribute]
public static bool IsByRefLike(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Internal.TypeSystem.Common.TypeSystemContext : object {
    [CompilerGeneratedAttribute]
private IHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetDetails <Target>k__BackingField;
    internal IHost Host { get; }
    public TargetDetails Target { get; }
    public TypeSystemContext(IHost host);
    [CompilerGeneratedAttribute]
internal IHost get_Host();
    [CompilerGeneratedAttribute]
public TargetDetails get_Target();
    public abstract virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(Type type);
    public abstract virtual ComputedInstanceFieldLayout ComputeInstanceLayout(Type type);
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.Common.TypeSystemHelpers : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasLayout(Type mdType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.NetCore7.MetadataFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    public TypeSystemContext Context { get; }
    public MetadataFieldLayoutAlgorithm(TypeSystemContext context);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(Type defType);
    protected ComputedInstanceFieldLayout ComputeInstanceFieldLayout(Type type, int numInstanceFields);
    public virtual bool ComputeContainsGCPointers(Type type);
    protected ComputedInstanceFieldLayout ComputeExplicitFieldLayout(Type type, int numInstanceFields);
    private static LayoutInt AlignUpInstanceFieldOffset(Type typeWithField, LayoutInt cumulativeInstanceFieldPos, LayoutInt alignment, TargetDetails target);
    protected ComputedInstanceFieldLayout ComputeSequentialFieldLayout(Type type, int numInstanceFields);
    private static void AdjustForInlineArray(Type type, int instanceFieldCount, SizeAndAlignment& instanceByteSizeAndAlignment, SizeAndAlignment& instanceSizeAndAlignment);
    protected virtual void AlignBaseOffsetIfNecessary(Type type, LayoutInt& baseOffset, bool requiresAlign8, bool requiresAlignedBase);
    protected ComputedInstanceFieldLayout ComputeAutoFieldLayout(Type type, int numInstanceFields);
    private static void PlaceInstanceField(FieldInfo field, bool hasLayout, int packingSize, FieldAndOffset[] offsets, LayoutInt& instanceFieldPos, Int32& fieldOrdinal, LayoutInt offsetBias, TypeSystemContext context);
    private static LayoutInt GetAlignedNumInstanceFieldBytes(LayoutInt instanceSize);
    private static int CalculateLog2(int size);
    private static bool IsByValueClass(Type type);
    public LayoutInt CalculateFieldBaseOffset(Type type, bool requiresAlign8, bool requiresAlignedBase);
    private static SizeAndAlignment ComputeFieldSizeAndAlignment(Type fieldType, bool hasLayout, int packingSize, Boolean& layoutAbiStable, Boolean& fieldTypeHasAutoLayout, TypeSystemContext context);
    private static int ComputePackingSize(Type type, ClassLayoutMetadata layoutMetadata, TypeSystemContext context);
    private static SizeAndAlignment ComputeInstanceSize(Type type, LayoutInt instanceSize, LayoutInt alignment, int classLayoutSize, SizeAndAlignment& byteCount, TypeSystemContext context);
    [CompilerGeneratedAttribute]
public TypeSystemContext get_Context();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Internal.TypeSystem.NetCore7.TypeSystemContextNetCore7 : TypeSystemContext {
    private Dictionary`2<Type, ComputedInstanceFieldLayout> m_cachedLayouts;
    private MetadataFieldLayoutAlgorithm m_metadatFieldLayoutAlgorithm;
    private SystemObjectFieldLayoutAlgorithm m_systemObjectFieldLayoutAlgorithm;
    public TypeSystemContextNetCore7(IHost host);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(Type type);
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(Type type);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
