[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeCoverage.Interprocess.Cache : object {
    [NullableAttribute("1")]
private ConcurrentDictionary`2<StreamKey, BufferMessage[]> _data;
    public sealed virtual CacheMessage Fetch(FetchCacheMessage message);
    public sealed virtual void Store(CacheMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.ClientConnectedEventArgs : EventArgs {
    public string PipeName;
    public ClientConnectedEventArgs(string pipeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Interprocess.CoveragePipeClient : object {
    private static Byte[] _emptyModuleInstrumentedMessage;
    private static CoveragePipeClient();
    public static void SendConfiguration(string configuration, IPipeClient pipeClient, ILogger logger);
    public static void SendGetInformationResponseMessage(string information, IPipeClient pipeClient, ILogger logger);
    public static void SendInitializeClientResponse(UInt32 communicationTimeout, string updatedPath, IPipeClient pipeClient, ILogger logger);
    public static void SendCreateStreamResponse(LogStreamBase stream, IPipeClient pipeClient, ILogger logger);
    public static void SendEmptyModuleInstrumentedMessage(IPipeClient pipeClient, ILogger logger);
    public static void SendModuleInstrumentedMessage(InstrumentedModuleMessage message, IPipeClient pipeClient, ILogger logger);
    public static void SendPreloadModuleDataResponse(PreloadModuleDataResponseMessage message, IPipeClient pipeClient, ILogger logger);
    public static void SendFilePathsMessage(FilePathsMessage message, IPipeClient pipeClient, ILogger logger);
    public static void SendClientErrorMessage(ClientErrorMessage message, IPipeClient pipeClient, ILogger logger);
    public static void SendSuccessMessage(IPipeClient pipeClient, ILogger logger);
    public static void SendCacheMessageResponse(CacheMessage message, IPipeClient pipeClient, ILogger logger);
    private static void SendMessage(IPipeClient pipeClient, MemoryStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeCoverage.Interprocess.Helper : object {
    public static string GetModulePath(string uri, bool getPath);
    public static long GetModuleWriteTimestamp(string path);
    public static StreamKey GetStreamKey(CreateStreamMessage message);
    public static StreamKey GetStreamKey(string prefix, Guid key);
    internal static void WriteStreamToPipe(Byte[] stream, int streamSize, PipeStream pipeStream, ILogger logger, bool isWindows);
    internal static void Write(Byte[] buffer, int size, PipeStream pipeStream, ILogger logger, bool isWindows);
}
internal interface Microsoft.CodeCoverage.Interprocess.ICache {
    public abstract virtual void Store(CacheMessage message);
    public abstract virtual CacheMessage Fetch(FetchCacheMessage message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IdNamePair : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public string Name { get; public set; }
    public IdNamePair(string Id, string Name);
    [CompilerGeneratedAttribute]
protected IdNamePair(IdNamePair original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(IdNamePair left, IdNamePair right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(IdNamePair left, IdNamePair right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(IdNamePair other);
    [CompilerGeneratedAttribute]
public virtual IdNamePair <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.ILoggerBase {
    public IList`1<string> OutputCoverageFiles { get; }
    public abstract virtual IList`1<string> get_OutputCoverageFiles();
    public abstract virtual Task RunAsync(IEnumerable`1<string> sourceDirectories, IEnumerable`1<string> sourceFiles);
    public abstract virtual void Shutdown();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.ILoggerClient {
    public abstract virtual bool IsLoggerAvailable();
    public abstract virtual int GetLoggerProcessId();
    public abstract virtual DataCollectorConfiguration GetDataCollectorConfiguration();
    public abstract virtual bool IsPreloadSupported(string path);
    public abstract virtual void SendShutdownMessage();
    public abstract virtual String[] SendSnapshotMessage(string path, bool reset, string tagId, string tagName);
    public abstract virtual String[] SendGenerateReportsRequestMessage();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.ILoggerClientFactory {
    public abstract virtual ILoggerClient CreateLoggerClient(string sessionId, ILogger logger, int timeout);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IMessage {
    public bool Complete { get; }
    public abstract virtual void SetLastReadCount(int count);
    public abstract virtual Byte[] GetNextReadBuffer();
    public abstract virtual Byte[] GetData();
    public abstract virtual bool get_Complete();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IO.IMemoryMappedFileFactory {
    public abstract virtual MemoryMappedFile Create(string mapName, long capacity, string processOwnerSid);
    public abstract virtual bool SupportsGlobalNamespace();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IO.INamedPipeServerStreamFactory {
    public abstract virtual NamedPipeServerStream Create(string pipeName, int maxNumberOfServerInstances);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IO.ISecurityHelper {
    public abstract virtual IEnumerable`1<SecurityIdentifier> GetOwnersList(string processOwnerSid);
    public abstract virtual IEnumerable`1<SecurityIdentifier> GetUsersList(string processOwnerSid);
    public abstract virtual void SetAuditAccessControl(NativeObjectSecurity securityObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.MemoryMappedFileFactory : object {
    private IEnvironment _environment;
    public MemoryMappedFileFactory(IEnvironment environment);
    public sealed virtual MemoryMappedFile Create(string mapName, long capacity, string processOwnerSid);
    public sealed virtual bool SupportsGlobalNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.MemoryMappedFileFactoryWithFallback : object {
    private IMemoryMappedFileFactory _innerFactory;
    private IMemoryMappedFileFactory _fallbackFactory;
    private ILogger _logger;
    public MemoryMappedFileFactoryWithFallback(IMemoryMappedFileFactory innerFactory, IMemoryMappedFileFactory fallbackFactory, ILogger logger);
    public sealed virtual MemoryMappedFile Create(string mapName, long capacity, string processOwnerSid);
    public sealed virtual bool SupportsGlobalNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.MemoryMappedFileFactoryWithSecurity : object {
    private ISecurityHelper _securityHelper;
    private bool _supportsGlobalNamespace;
    public MemoryMappedFileFactoryWithSecurity(ISecurityHelper securityHelper, bool supportsGlobalNamespace);
    public sealed virtual MemoryMappedFile Create(string mapName, long capacity, string processOwnerSid);
    public sealed virtual bool SupportsGlobalNamespace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.NamedPipeServerStreamFactory : object {
    private IEnvironment _environment;
    public NamedPipeServerStreamFactory(IEnvironment environment);
    public sealed virtual NamedPipeServerStream Create(string pipeName, int maxNumberOfServerInstances);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.NamedPipeServerStreamFactoryWithFallback : object {
    private INamedPipeServerStreamFactory _innerFactory;
    private INamedPipeServerStreamFactory _fallbackFactory;
    private ILogger _logger;
    public NamedPipeServerStreamFactoryWithFallback(INamedPipeServerStreamFactory innerFactory, INamedPipeServerStreamFactory fallbackFactory, ILogger logger);
    public sealed virtual NamedPipeServerStream Create(string pipeName, int maxNumberOfServerInstances);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.NamedPipeServerStreamFactoryWithSecurity : object {
    private ISecurityHelper _securityHelper;
    public NamedPipeServerStreamFactoryWithSecurity(ISecurityHelper securityHelper);
    public sealed virtual NamedPipeServerStream Create(string pipeName, int maxNumberOfServerInstances);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.IO.SecurityHelper : object {
    private DataCollectorConfiguration _configuration;
    private bool _hasSeSecurityPrivilege;
    public SecurityHelper(DataCollectorConfiguration configuration, bool hasSeSecurityPrivilege);
    public sealed virtual IEnumerable`1<SecurityIdentifier> GetOwnersList(string processOwnerSid);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.IO.SecurityHelper/<GetUsersList>d__4")]
public sealed virtual IEnumerable`1<SecurityIdentifier> GetUsersList(string processOwnerSid);
    public sealed virtual void SetAuditAccessControl(NativeObjectSecurity securityObject);
}
internal interface Microsoft.CodeCoverage.Interprocess.IPipeClient {
    public UInt32 ProcessId { get; }
    public bool IsCodeCoverageEnabled { get; }
    public abstract virtual UInt32 get_ProcessId();
    [NullableContextAttribute("1")]
public abstract virtual void SendMessage(Byte[] message, int size);
    public abstract virtual bool get_IsCodeCoverageEnabled();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IPipeConnectionFactory {
    public abstract virtual PipeConnection Create(string pipeName, int clientsPerPipe);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.IPipeConnectionsManager {
    public abstract virtual void RegisterHandler(EventHandler`1<ServerMessageReceivedEventArgs> handler);
    public abstract virtual Task StartAsync();
    public abstract virtual void Stop();
    public abstract virtual IEnumerable`1<PipeConnection> GetConnections();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.LoggerBase : object {
    private ManualResetEvent _testHostEvent;
    private int _testHostProcessId;
    private static string BufferHeader;
    private bool _addSnapshots;
    private static Byte[] _skippedHeaderData;
    private static Byte[] _instrumentedHeaderData;
    private static Byte[] _successMessage;
    private object _dataLock;
    protected string SessionName;
    private string _pipeName;
    private IStaticNativeRuntimeProvider _staticNativeRuntimeProvider;
    private DataCollectorConfiguration _dataCollectorConfig;
    private string _dynamicNativeConfig;
    private ILogger _logger;
    private IEnvironment _environment;
    private ReportGenerator _reportGenerator;
    private ICache _cache;
    private IStreamCreator _staticStreamCreator;
    private IStaticInstrumenter _staticInstrumenter;
    private IStaticRestorer _staticRestorer;
    private IStaticManagedModuleHolder _staticManagedModuleHolder;
    private IAssemblyResolverFactory _assemblyResolverFactory;
    [NullableAttribute("2")]
private StaticInstrumentationResult _staticInstrumentationResult;
    private ICacheCleaner _cacheCleaner;
    private TimeSpan _processingMaximalTime;
    private TimeSpan _lockMaximalTime;
    private List`1<string> _outputCoverageFiles;
    private ILibraryHelper _libraryHelper;
    private IAssemblyMetadataFactory _assemblyMetadataFactory;
    private IAssemblyMetadataProcessor _assemblyMetadataProcessor;
    private PipeConnectionsManager _pipeConnectionsManager;
    private bool _disposed;
    private int _numberOfClientsConnected;
    private int _numberOfModulesCovered;
    private bool _pipesInitialized;
    public int TestHostProcessId { get; public set; }
    public int NumberOfClientsConnected { get; }
    public int NumberOfModulesCovered { get; }
    public IList`1<string> OutputCoverageFiles { get; }
    private static LoggerBase();
    internal LoggerBase(string sessionName, string pipePath, string coverageFilePath, DataCollectorConfiguration dataCollectorConfiguration, ILogger logger, IEnvironment environment, IStaticNativeInstrumenter staticNativeInstrumenter, IStaticNativeRuntimeProvider staticNativeRuntimeProvider, IDirectoryHelper directoryHelper, IOutputPathGenerator outputPathGenerator, ISourceRootTranslator sourceRootTranslator, IProfilersLocationProvider profilersLocationProvider);
    public int get_TestHostProcessId();
    public void set_TestHostProcessId(int value);
    private void RegisterClient(PipeClient client, RegisterClientMessage message);
    private void RegisterClient(PipeClient client, InitializeClientMessage message);
    private void HandleClientShutdown(PipeClient client);
    private void HandleClientShutdownLogger(PipeClient client);
    private void HandleClientError(PipeClient client, ClientErrorMessage message);
    private void UnregisterClient(IPipeClient client);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.LoggerBase/<LoadModuleDataAsync>d__17")]
private Task LoadModuleDataAsync(IPipeClient client, LoadModuleDataMessage message);
    private void PreloadModuleData(IPipeClient client, PreloadModuleDataMessage message);
    private void HandleCacheMessage(IPipeClient client, CacheMessage message);
    private void HandleFetchCacheMessage(IPipeClient client, FetchCacheMessage message);
    private void CreateStream(IPipeClient client, CreateStreamMessage message);
    private void WriteStream(IPipeClient client, WriteStreamMessage message, Byte[] buffer, long offset);
    private void CloseStream(IPipeClient client, CloseStreamMessage message);
    private void WriteStreamBuffers(IPipeClient client, WriteStreamBuffersMessage message);
    private void WriteCoverageData(GetCoverageDataMessage message);
    private void CreateSnapshot(IPipeClient client, SnapshotMessage message);
    private void SendInformation(IPipeClient client, GetInformationMessage message);
    private void OnDynamicInstrumentation(AssemblyMetadata assemblyMetadata, TimeSpan elapsed);
    private static ValueTuple`2<Byte[], int> GetData(ModuleCoverageContainer moduleCoverageContainer);
    public int get_NumberOfClientsConnected();
    public int get_NumberOfModulesCovered();
    public sealed virtual IList`1<string> get_OutputCoverageFiles();
    protected virtual void OnClientConnected(UInt32 processId);
    protected virtual void OnClientDisconnected(UInt32 processId, UInt32 errorCode);
    protected virtual void OnCreateStream(UInt32 processId, UInt32 streamId, Guid streamType, UInt32 bufferSize, string bufferHeader, string bufferName, string prefix);
    protected virtual void OnWriteStream(UInt32 processId, UInt32 streamId, Guid streamType, Byte[] buffer, long bufferSize);
    protected virtual void OnCloseStream(UInt32 processId, UInt32 streamId, int streamSize);
    protected virtual void OnFatalException(Exception exception);
    protected virtual void OnShutdown(UInt32 processId);
    protected virtual void OnShutdown();
    protected virtual void OnClientError(UInt32 processId, string message);
    protected virtual void OnWriteStreamBuffers(UInt32 processId, Guid streamType, string bufferHeader, bool resetBuffers);
    protected virtual void OnStaticInstrumentation(string path, UInt32 result, TimeSpan elapsed, bool isManaged);
    protected virtual void OnStaticInstrumentationSkipped(string path, bool isManaged);
    protected virtual void OnInstrumentation(string path, Guid id, Guid coverageBufferId, bool isDynamic, bool isManaged, bool isMixed, bool isPortablePdb, UInt32 imageSize, UInt32 imageLinkTime, int numberOfMethodsInstrumented, int numberOfMethodsSkipped, int numberOfMethodsFailed, TimeSpan elapsed, Dictionary`2<string, string> properties);
    protected virtual void OnInstrumentationSkipped(string path, ModuleSkipReason reason, bool isManaged);
    protected virtual void OnBufferClose(Guid identifier, Byte[] bytes);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.LoggerBase/<RunAsync>d__80")]
public sealed virtual Task RunAsync(IEnumerable`1<string> sourceDirectories, IEnumerable`1<string> sourceFiles);
    public void TestStart(TestStart testInformation);
    public void TestEnd(TestEnd testInformation, bool reset);
    public sealed virtual void Shutdown();
    private void SendSuccessMessageAndStopAllPipeConnectionsThatRequestedShutdown();
    private void DisconnectAllPipesAndReadAllMessages();
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.LoggerBase/<PerformStaticInstrumentationAsync>d__86")]
private Task PerformStaticInstrumentationAsync(IEnumerable`1<string> sourcesDirectories, IEnumerable`1<string> sourceFiles);
    private void OnMessageReceivedEvent(object _, ServerMessageReceivedEventArgs e);
    private void HandleGenerateReportsRequestMessage(IPipeClient client, GenerateReportsRequestMessage _);
    private void HandleInstrumentationStatisticsMessage(PipeClient _, InstrumentationStatisticsMessage message);
    private static string GenerateDynamicNativeConfigString(CodeCoverageConfig codeCoverageConfig);
    private static string AddDynamicNativeExclusionsAndModifyRegexes(string configuration);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.LoggerClient : object {
    private NamedPipeClientStream _pipe;
    private ILogger _logger;
    private IEnvironment _environment;
    private int _communicationTimeout;
    public LoggerClient(string sessionName, string pipePath, ILogger logger, IEnvironment environment, int communicationTimeout);
    public sealed virtual bool IsLoggerAvailable();
    public sealed virtual int GetLoggerProcessId();
    public sealed virtual DataCollectorConfiguration GetDataCollectorConfiguration();
    public sealed virtual void SendShutdownMessage();
    public sealed virtual String[] SendSnapshotMessage(string path, bool reset, string tagId, string tagName);
    public sealed virtual String[] SendGenerateReportsRequestMessage();
    public sealed virtual bool IsPreloadSupported(string path);
    public sealed virtual void Dispose();
    private void SendMessage(Action`1<BinaryWriter> writerAction);
    private T ReadMessage(Byte[] buffer, Func`2<InterprocessMessageReader, T> messageDeserializer);
    private Byte[] ReadMessageFromPipe();
    private void ConnectPipe();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.LoggerClientFactory : object {
    private IEnvironment _environment;
    public LoggerClientFactory(IEnvironment environment);
    public sealed virtual ILoggerClient CreateLoggerClient(string sessionId, ILogger logger, int timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Message : object {
    private static int BufferSize;
    private IList`1<int> _buffersCount;
    [CompilerGeneratedAttribute]
private IList`1<Byte[]> <Buffers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageSize>k__BackingField;
    protected IList`1<Byte[]> Buffers { get; private set; }
    protected int MessageSize { get; protected set; }
    public bool Complete { get; }
    [CompilerGeneratedAttribute]
protected IList`1<Byte[]> get_Buffers();
    [CompilerGeneratedAttribute]
private void set_Buffers(IList`1<Byte[]> value);
    [CompilerGeneratedAttribute]
protected int get_MessageSize();
    [CompilerGeneratedAttribute]
protected void set_MessageSize(int value);
    public virtual void SetLastReadCount(int count);
    public virtual Byte[] GetNextReadBuffer();
    public sealed virtual Byte[] GetData();
    public virtual bool get_Complete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.MessageReceivedEventArgs : EventArgs {
    public Byte[] Buffer;
    public MessageReceivedEventArgs(Byte[] buffer);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.ModuleCoverageContainer : object {
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private StreamKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BufferNameEnvironmentVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleInstrumentedMessage <ModuleInstrumentedMessage>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<InstrumentedFunctionMessage> <InstrumentedFunctionMessages>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<FunctionInstrumentedMessage> <FunctionInstrumentedMessages>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<FunctionSkippedMessage> <FunctionSkippedMessages>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<SourceFileDataMessage> <SourceFileDataMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSkipReason <ModuleSkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private SharedMemoryStream <CoverageDataStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SharedMemoryStream <ModuleDataStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMixed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortablePdb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSecurityAttributes>k__BackingField;
    public Guid Identifier { get; private set; }
    [NullableAttribute("1")]
public StreamKey Key { get; private set; }
    public UInt32 BlockSize { get; private set; }
    public string BufferName { get; }
    public string BufferNameEnvironmentVariable { get; public set; }
    public int BufferSize { get; }
    public string PdbPath { get; }
    public ModuleInstrumentedMessage ModuleInstrumentedMessage { get; }
    [NullableAttribute("1")]
public IList`1<InstrumentedFunctionMessage> InstrumentedFunctionMessages { get; }
    [NullableAttribute("1")]
public IList`1<FunctionInstrumentedMessage> FunctionInstrumentedMessages { get; }
    [NullableAttribute("1")]
public IList`1<FunctionSkippedMessage> FunctionSkippedMessages { get; }
    [NullableAttribute("1")]
public IList`1<SourceFileDataMessage> SourceFileDataMessages { get; }
    public bool IsSkipped { get; public set; }
    public ModuleSkipReason ModuleSkipReason { get; public set; }
    public SharedMemoryStream CoverageDataStream { get; public set; }
    public SharedMemoryStream ModuleDataStream { get; public set; }
    public bool IsMixed { get; }
    public bool IsPortablePdb { get; }
    public string TargetFramework { get; }
    public bool HasSecurityAttributes { get; }
    [NullableContextAttribute("1")]
public ModuleCoverageContainer(ModuleInstrumentedMessage moduleInstrumentedMessage, string pdbPath, Guid identifier, UInt32 blockSize, bool isMixed, bool isPortablePdb, string targetFramework, IList`1<FunctionInstrumentedMessage> functionInstrumentedMessages, IList`1<FunctionSkippedMessage> functionSkippedMessages, IList`1<SourceFileDataMessage> sourceFileDataMessages, bool hasSecurityAttributes);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Identifier();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Identifier(Guid value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public StreamKey get_Key();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(StreamKey value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_BlockSize();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BlockSize(UInt32 value);
    public sealed virtual string get_BufferName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BufferNameEnvironmentVariable();
    [CompilerGeneratedAttribute]
public void set_BufferNameEnvironmentVariable(string value);
    public sealed virtual int get_BufferSize();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PdbPath();
    [CompilerGeneratedAttribute]
public sealed virtual ModuleInstrumentedMessage get_ModuleInstrumentedMessage();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IList`1<InstrumentedFunctionMessage> get_InstrumentedFunctionMessages();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionInstrumentedMessage> get_FunctionInstrumentedMessages();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IList`1<FunctionSkippedMessage> get_FunctionSkippedMessages();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IList`1<SourceFileDataMessage> get_SourceFileDataMessages();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSkipped();
    [CompilerGeneratedAttribute]
public void set_IsSkipped(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ModuleSkipReason get_ModuleSkipReason();
    [CompilerGeneratedAttribute]
public void set_ModuleSkipReason(ModuleSkipReason value);
    [CompilerGeneratedAttribute]
public SharedMemoryStream get_CoverageDataStream();
    [CompilerGeneratedAttribute]
public void set_CoverageDataStream(SharedMemoryStream value);
    [CompilerGeneratedAttribute]
public SharedMemoryStream get_ModuleDataStream();
    [CompilerGeneratedAttribute]
public void set_ModuleDataStream(SharedMemoryStream value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMixed();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPortablePdb();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasSecurityAttributes();
}
internal class Microsoft.CodeCoverage.Interprocess.NullStaticManagedModuleHolder : object {
    private bool _configureBufferNameEnvironmentVariable;
    public NullStaticManagedModuleHolder(bool configureBufferNameEnvironmentVariable);
    [NullableContextAttribute("1")]
public sealed virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
    [NullableContextAttribute("1")]
public sealed virtual bool TryInitialize(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeClient : object {
    private PipeStream _server;
    private ILogger _logger;
    private IStreamCreator _streamCreator;
    private IEnvironment _environment;
    [CompilerGeneratedAttribute]
private UInt32 <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCodeCoverageEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShutdownRequested>k__BackingField;
    public UInt32 SchemaVersion { get; public set; }
    public UInt32 ProcessId { get; public set; }
    public bool IsCodeCoverageEnabled { get; public set; }
    public bool ShutdownRequested { get; public set; }
    public PipeClient(PipeStream server, ILogger logger, IStreamCreator streamCreator, IEnvironment environment);
    [CompilerGeneratedAttribute]
public UInt32 get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCodeCoverageEnabled();
    [CompilerGeneratedAttribute]
public void set_IsCodeCoverageEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShutdownRequested();
    [CompilerGeneratedAttribute]
public void set_ShutdownRequested(bool value);
    public void UpdateClient(UInt32 schemaVersion, UInt32 processId, bool codeCoverageEnabled);
    public sealed virtual void SendMessage(Byte[] message, int size);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase GetStream(UInt32 streamId);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase CloseStream(UInt32 streamId);
    public sealed virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey streamKey, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    public sealed virtual void SetProcessOwnerSid(string processOwnerSid);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeConnection : object {
    private object _lock;
    private string _connectionId;
    private string _pipeName;
    private ILogger _logger;
    private IEnvironment _environment;
    private IMemoryMappedFileFactory _memoryMappedFileFactory;
    private IStreamNameGenerator _streamNameGenerator;
    private NamedPipeServerStream _server;
    private CancellationTokenSource _cancellationTokenSource;
    [NullableAttribute("2")]
private Task _internalTask;
    [NullableAttribute("2")]
private PipeClient _pipeClient;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ServerMessageReceivedEventArgs> MessageReceivedEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ClientConnectedEventArgs> ClientConnectedEvent;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    public bool ShutdownRequested { get; }
    public bool Connected { get; private set; }
    public PipeConnection(string pipeName, ILogger logger, IEnvironment environment, INamedPipeServerStreamFactory pipeFactory, IMemoryMappedFileFactory memoryMappedFileFactory, int clientsPerPipe, IStreamNameGenerator streamNameGenerator);
    [CompilerGeneratedAttribute]
public void add_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClientConnectedEvent(EventHandler`1<ClientConnectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClientConnectedEvent(EventHandler`1<ClientConnectedEventArgs> value);
    public bool get_ShutdownRequested();
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
private void set_Connected(bool value);
    public void Start();
    private void OnClientConnected(IAsyncResult result);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.PipeConnection/<ReadMessagesAsync>d__26")]
private Task ReadMessagesAsync(CancellationToken token);
    public void Disconnect();
    public void WaitForDisconnection(CancellationToken token);
    public void SendMessageIfShutdownRequested(Byte[] message, int size);
    public void Stop();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.PipeConnection/<<OnClientConnected>b__25_0>d")]
[CompilerGeneratedAttribute]
private Task <OnClientConnected>b__25_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeConnectionFactory : object {
    private ILogger _logger;
    private IEnvironment _environment;
    private INamedPipeServerStreamFactory _namedPipeServerStreamFactory;
    private IMemoryMappedFileFactory _memoryMappedFileFactory;
    private IStreamNameGenerator _streamNameGenerator;
    public PipeConnectionFactory(ILogger logger, IEnvironment environment, INamedPipeServerStreamFactory namedPipeServerStreamFactory, IMemoryMappedFileFactory memoryMappedFileFactory, IStreamNameGenerator streamNameGenerator);
    public sealed virtual PipeConnection Create(string pipeName, int clientsPerPipe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeConnectionReader : object {
    private ILogger _logger;
    private IEnvironment _environment;
    private PipeStream _pipeStream;
    public PipeConnectionReader(PipeStream pipeStream, ILogger logger, IEnvironment environment);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.PipeConnectionReader/<ReadMessageAsync>d__4")]
public Task`1<Byte[]> ReadMessageAsync(CancellationToken token);
    [NullableContextAttribute("2")]
public Byte[] ReadMessage();
    private bool IsMessageComplete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.PipeConnectionsManager : object {
    private static int OpenConnectionBackoffInMs;
    private static int OpenConnectionMaxRetries;
    private object _connectionLock;
    private string _pipeName;
    private List`1<PipeConnection> _connections;
    private IPipeConnectionFactory _pipeConnectionFactory;
    private ILogger _logger;
    private DataCollectorConfiguration _configuration;
    private int _clientsPerPipe;
    private TimeSpan _lockMaximalTime;
    private bool _shuttingDown;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ServerMessageReceivedEventArgs> MessageReceivedEvent;
    public PipeConnectionsManager(string pipeName, IPipeConnectionFactory pipeConnectionFactory, ILogger logger, DataCollectorConfiguration configuration, int clientsPerPipe);
    private static PipeConnectionsManager();
    [CompilerGeneratedAttribute]
private void add_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_MessageReceivedEvent(EventHandler`1<ServerMessageReceivedEventArgs> value);
    public sealed virtual void RegisterHandler(EventHandler`1<ServerMessageReceivedEventArgs> handler);
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.PipeConnectionsManager/<StartAsync>d__16")]
public sealed virtual Task StartAsync();
    public sealed virtual void Stop();
    public sealed virtual IEnumerable`1<PipeConnection> GetConnections();
    [AsyncStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.PipeConnectionsManager/<OpenConnectionAsync>d__19")]
private Task OpenConnectionAsync(string pipeName);
    private bool OpenConnectionInternal(string pipeName);
    private void OnClientConnectedEvent(object _, ClientConnectedEventArgs e);
    private void OnMessageReceived(object _, ServerMessageReceivedEventArgs args);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeCoverage.Interprocess.PipeStreamDisconnectedEventArgs : EventArgs {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Reports.CoberturaReportGenerator : ReportGeneratorBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<CoberturaPackage, ILogStream>> _packageCoverageData;
    public string DefaultFileExtension { get; }
    public CoberturaReportGenerator(ILogger traceWrapper, IDirectoryHelper directoryHelper);
    public virtual void AddModule(ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddModule(ModuleMessages moduleMessages, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddSkippedModule(ModuleSkippedMessage message);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.CoberturaReportGenerator/<GenerateReport>d__5")]
public virtual IEnumerable`1<string> GenerateReport(string coverageFilePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    public virtual void AddSnapshotTag(IdNamePair snapshotTag, bool reset);
    public virtual string get_DefaultFileExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Reports.DefaultReportGenerator : ReportGeneratorBase {
    private List`1<ModuleStreamContainer> _streamsContainer;
    private ICoverageFileWriter _coverageFileWriter;
    private ICoverageFileDataMerger _coverageFileDataMerger;
    private ICoverageMessagesReader _coverageMessagesReader;
    private bool _splitCoverageFiles;
    private bool _selfMergeReport;
    private Dictionary`2<string, ModuleSkippedMessage> _skippedModuleMessages;
    [CompilerGeneratedAttribute]
private ushort <SchemaVersion>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ModuleStreamContainer, Dictionary`2<string, ValueTuple`2<ArrayByteSource, List`1<IdNamePair>>>> _moduleSnapshotBuffers;
    private List`1<IdNamePair> _snapshotTags;
    private InMemoryArrayByteSourceFactory _inMemoryArrayByteSourceFactory;
    internal ushort SchemaVersion { get; }
    public string DefaultFileExtension { get; }
    public DefaultReportGenerator(ICoverageFileWriter coverageFileWriter, ICoverageMessagesReader coverageMessagesReader, ICoverageFileDataMerger coverageFileDataMerger, bool splitCoverageFiles, bool selfMergeReport, ILogger logger, IDirectoryHelper directoryHelper, ushort schemaVersion);
    [CompilerGeneratedAttribute]
internal ushort get_SchemaVersion();
    public virtual void AddModule(ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddModule(ModuleMessages moduleMessages, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddSkippedModule(ModuleSkippedMessage message);
    public virtual IEnumerable`1<string> GenerateReport(string coverageFilePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.DefaultReportGenerator/<WriteSingleCoverageFile>d__15")]
private IEnumerable`1<string> WriteSingleCoverageFile(string coverageFilePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    private IEnumerable`1<string> WriteSplitCoverageFiles(string coverageFilePath, bool reset, CancellationToken cancellationToken);
    public virtual string get_DefaultFileExtension();
    private void AddSnapshotData(CoverageFileMessages coverageFileMessages, ModuleStreamContainer moduleStream);
    private void AddSnapshotListData(CoverageFileMessages coverageFileMessages);
    public virtual void AddSnapshotTag(IdNamePair snapshotTag, bool reset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator : object {
    private static string BufferHeader;
    private string _sessionName;
    private string _outputCoverageFilePath;
    private DataCollectorConfiguration _dataCollectorConfig;
    private ILogger _logger;
    private IDirectoryHelper _directoryHelper;
    private IOutputPathGenerator _outputPathGenerator;
    private ICoverageMessagesReader _coverageMessagesReader;
    private ConcurrentDictionary`2<string, string> _modulesPathIdMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, Task`1<ModuleCoverageContainer>> _moduleProcessingTasks;
    private IDictionary`2<StreamKey, LogStreamBase> _sharedModuleCoverageBuffers;
    private IDictionary`2<StreamKey, Guid> _sharedModuleCoverageBuffersIds;
    private IList`1<LogStreamBase> _abandonedStreams;
    private ICoverageFileConfiguration _fileConfiguration;
    private bool _reportsGenerated;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private IList`1<ReportGeneratorBase> <ReportGenerators>k__BackingField;
    internal IList`1<ReportGeneratorBase> ReportGenerators { get; }
    public ReportGenerator(string sessionName, string coverageFilePath, DataCollectorConfiguration dataCollectorConfig, ILogger logger, IDirectoryHelper directoryHelper, ICoverageMessagesReader coverageMessagesReader, IOutputPathGenerator outputPathGenerator);
    [CompilerGeneratedAttribute]
internal IList`1<ReportGeneratorBase> get_ReportGenerators();
    public bool ContainsContainerProcessTask(string modulePath);
    public Task`1<ModuleCoverageContainer> GetContainerProcessTask(string modulePath);
    public bool TryStoreModuleIdMapping(string modulePath, AssemblyMetadata assemblyMetadata);
    public bool TryAddModuleProcessingTask(string moduleId, Task`1<ModuleCoverageContainer> moduleProcessingTask);
    public ModuleCoverageContainer ProcessManagedModule(AssemblyMetadata assemblyMetadata, UInt32 blockSize, IStreamCreator streamCreator, CancellationToken token);
    private void StoreFunctionMessages(IModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata);
    public LogStreamBase CreateUnmanagedStream(IPipeClient client, StreamKey key, CreateStreamMessage message);
    public int CloseUnmanagedStream(LogStreamBase stream);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator/<GenerateReports>d__28")]
public IEnumerable`1<string> GenerateReports(bool addSnapshots, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator/<GenerateReports>d__29")]
public IEnumerable`1<string> GenerateReports(string outputCoveragePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.ReportGenerator/<GetSharedMemoryStreams>d__30")]
public IEnumerable`1<SharedMemoryStream> GetSharedMemoryStreams();
    private void LoadGenerators();
    private bool IsStreamDataExcludedByPath(CreateStreamMessage message);
    public void TestStart(TestStart testInformation);
    public void AddSnapshotTag(IdNamePair snapshotTag, bool reset);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Interprocess.Reports.ReportGeneratorBase : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectoryHelper <DirectoryHelper>k__BackingField;
    protected ILogger Logger { get; }
    protected IDirectoryHelper DirectoryHelper { get; }
    public string DefaultFileExtension { get; }
    protected ReportGeneratorBase(ILogger logger, IDirectoryHelper directoryHelper);
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected IDirectoryHelper get_DirectoryHelper();
    public abstract virtual void AddModule(ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, ILogStream sharedModuleCoverageBuffer);
    public abstract virtual void AddModule(ModuleMessages moduleMessages, ILogStream sharedModuleCoverageBuffer);
    public abstract virtual void AddSkippedModule(ModuleSkippedMessage message);
    public abstract virtual IEnumerable`1<string> GenerateReport(string coverageFilePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    protected void CreateDirectoryIfNeeded(string coverageFilePath);
    public abstract virtual void AddSnapshotTag(IdNamePair snapshotTag, bool reset);
    public abstract virtual string get_DefaultFileExtension();
}
internal static class Microsoft.CodeCoverage.Interprocess.Reports.ReportGeneratorFactory : object {
    [NullableContextAttribute("1")]
public static ReportGeneratorBase CreateGenerator(string outputType, bool splitCoverageFile, bool selfMergeReport, ILogger logger, IDirectoryHelper directoryHelper);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ICoverageFileWriter <CreateGenerator>g__GetCoverageFileWriter|0_0(ILogger logger);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ValueTuple`2<ICoverageMessagesReader, ICoverageFileDataMerger> <CreateGenerator>g__GetMergeObjects|0_1(UInt32 schemaVersion, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Reports.XmlReportGenerator : ReportGeneratorBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<ModuleData, ILogStream>> _moduleCoverageData;
    private Dictionary`2<string, SkippedModuleData> _skippedModules;
    public string DefaultFileExtension { get; }
    public XmlReportGenerator(ILogger logger, IDirectoryHelper directoryHelper);
    public static ModuleData ToModuleData(AssemblyMetadata assemblyMetadata);
    public static ModuleData ToModuleData(ModuleMessages moduleMessages);
    public static void PopulateCoverageStatus(ModuleData module, Byte[] coverageBuffer, int coverageBufferSize);
    private static FunctionData GetFunction(UInt32 functionId, UInt32 metadataToken, string name, string typeName, string namespaceName, UInt32 blockCount, UInt32 startBlockIndex, MultiBlockLineData[] lines);
    private static SkippedFunctionData GetSkippedFunction(UInt32 functionId, UInt32 metadataToken, UInt32 originalId, string name, string typeName, FunctionSkipReason functionSkipReason, string exception);
    public virtual void AddModule(ModuleCoverageContainer moduleCoverageContainer, AssemblyMetadata assemblyMetadata, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddModule(ModuleMessages moduleMessages, ILogStream sharedModuleCoverageBuffer);
    public virtual void AddSkippedModule(ModuleSkippedMessage message);
    [IteratorStateMachineAttribute("Microsoft.CodeCoverage.Interprocess.Reports.XmlReportGenerator/<GenerateReport>d__12")]
public virtual IEnumerable`1<string> GenerateReport(string coverageFilePath, bool reset, bool addSnapshots, CancellationToken cancellationToken);
    public virtual void AddSnapshotTag(IdNamePair snapshotTag, bool reset);
    public virtual string get_DefaultFileExtension();
    [CompilerGeneratedAttribute]
internal static ModuleContainer <ToModuleData>g__ProcessModule|1_0(AssemblyMetadata assemblyMetadata);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ValueTuple`2<int, int> <ToModuleData>g__GetFunctionsCount|1_4(IEnumerable`1<TypeMetadata> types);
    [CompilerGeneratedAttribute]
internal static FunctionData <ToModuleData>g__GetMethod|1_1(MethodMetadata method, UInt32 startBlockIndex, ModuleContainer module);
    [CompilerGeneratedAttribute]
internal static MultiBlockLineData[] <ToModuleData>g__PopulateLineData|1_2(MethodMetadata method, UInt32 startBlockIndex, Dictionary`2<string, SourceFileData> sourceFiles);
    [CompilerGeneratedAttribute]
internal static MultiBlockLineData <ToModuleData>g__ToMultiBlockLineData|1_3(SequencePointMetadata sequencePoint, UInt32 sourceId, UInt32 startBlockIndex);
    [CompilerGeneratedAttribute]
internal static void <ToModuleData>g__AddSourceFiles|2_0(ModuleMessages moduleMessages, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    [CompilerGeneratedAttribute]
internal static void <ToModuleData>g__AddSourceFile|2_1(UInt32 id, string path, SourceFileCheckSumType checksumType, Byte[] checksum, Dictionary`2<UInt32, SourceFileData> sourceFiles);
    [CompilerGeneratedAttribute]
internal static UInt32 <ToModuleData>g__AddFunctions|2_2(ModuleMessages moduleMessages, ModuleContainer module);
    [CompilerGeneratedAttribute]
internal static void <ToModuleData>g__AddSkippedFunctions|2_3(ModuleMessages moduleMessages, ModuleContainer module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.ServerMessageReceivedEventArgs : MessageReceivedEventArgs {
    public PipeClient Client;
    public ServerMessageReceivedEventArgs(PipeClient client, Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.StaticManagedModuleHolder : object {
    private ReportGenerator _reportGenerator;
    private IStreamCreator _streamCreator;
    private IDictionary`2<string, SharedMemoryStream> _streams;
    public StaticManagedModuleHolder(ReportGenerator reportGenerator, IStreamCreator streamCreator);
    public sealed virtual IModuleCoverageContainer Store(AssemblyMetadata assemblyMetadata, UInt32 blockSize);
    public sealed virtual bool TryInitialize(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Stream.ArrayStream : object {
    private Byte[] _stream;
    private bool _containsInitializationByte;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    public Guid Identifier { get; }
    public ArrayStream(Byte[] stream, bool initializationByte);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Identifier();
    public sealed virtual UInt32 GetBufferSize();
    public sealed virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    public sealed virtual bool IsInitialized();
    private int GetInternalBufferStart();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.Stream.ILogStream {
    public Guid Identifier { get; }
    public abstract virtual Guid get_Identifier();
    public abstract virtual bool IsInitialized();
    public abstract virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    public abstract virtual UInt32 GetBufferSize();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeCoverage.Interprocess.Stream.IStreamCreator {
    public abstract virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey key, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    [NullableContextAttribute("2")]
public abstract virtual LogStreamBase GetStream(UInt32 streamId);
    [NullableContextAttribute("2")]
public abstract virtual LogStreamBase CloseStream(UInt32 streamId);
    public abstract virtual void SetProcessOwnerSid(string processOwnerSid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Stream.LocalMemoryStream : LogStreamBase {
    private List`1<byte> _bytes;
    public LocalMemoryStream(UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose);
    public virtual void WriteMessage(Byte[] data, int dataSize);
    public virtual RawStream GetModuleBuffer(bool reset);
    public virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    [ExcludeFromCodeCoverageAttribute]
public virtual UInt32 GetBufferSize();
    [ExcludeFromCodeCoverageAttribute]
public virtual bool IsInitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeCoverage.Interprocess.Stream.LogStreamBase : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private StreamKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discard>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoClose>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <BufferName>k__BackingField;
    public StreamKey Key { get; }
    public Guid Identifier { get; }
    public UInt32 StreamId { get; }
    public Guid StreamType { get; }
    public bool Discard { get; public set; }
    public bool AutoClose { get; }
    [NullableAttribute("2")]
public string BufferName { get; public set; }
    protected LogStreamBase(UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose);
    [CompilerGeneratedAttribute]
public StreamKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Identifier();
    [CompilerGeneratedAttribute]
public UInt32 get_StreamId();
    [CompilerGeneratedAttribute]
public Guid get_StreamType();
    [CompilerGeneratedAttribute]
public bool get_Discard();
    [CompilerGeneratedAttribute]
public void set_Discard(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoClose();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_BufferName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_BufferName(string value);
    public abstract virtual RawStream GetModuleBuffer(bool reset);
    public abstract virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferToWriteTo);
    public abstract virtual void WriteMessage(Byte[] data, int dataSize);
    public abstract virtual UInt32 GetBufferSize();
    public abstract virtual bool IsInitialized();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Stream.SharedMemoryStream : LogStreamBase {
    private string _bufferHeader;
    private UInt32 _bufferSize;
    private bool _containsInitializationByte;
    private MemoryMappedFile _file;
    private bool _disposed;
    [NullableAttribute("2")]
private Byte[] _resetBuffer;
    public SharedMemoryStream(MemoryMappedFile file, UInt32 streamId, StreamKey key, Guid streamType, Guid identifier, bool autoClose, string bufferName, string bufferHeader, UInt32 bufferSize, bool initializationByte);
    public virtual void WriteMessage(Byte[] data, int dataSize);
    [NullableContextAttribute("2")]
private RawStream GetModuleBuffer(bool reset, Byte[] coverageBuffer);
    public virtual RawStream GetModuleBuffer(bool reset);
    public virtual Byte[] GetCoverageBuffer(bool reset, Byte[] bufferCache);
    internal void GetCoverageBuffer(bool reset, UInt32[] bufferCache);
    public virtual bool IsInitialized();
    public void MarkInitialized();
    protected virtual void Dispose(bool disposing);
    public virtual UInt32 GetBufferSize();
    private int GetInternalBufferStart();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Stream.StreamCreator : object {
    private ILogger _logger;
    private IMemoryMappedFileFactory _memoryMappedFileFactory;
    private ConcurrentDictionary`2<UInt32, LogStreamBase> _streams;
    private bool _generateStaticStreams;
    private IStreamNameGenerator _streamNameGenerator;
    private int _lastStreamId;
    private bool _disposed;
    private string _processOwnerSid;
    public StreamCreator(ILogger logger, IStreamNameGenerator streamNameGenerator, IMemoryMappedFileFactory memoryMappedFileFactory, bool generateStaticStreams);
    public sealed virtual LogStreamBase CreateStream(string sessionName, Guid streamType, Guid identifier, StreamKey key, bool autoClose, string bufferName, UInt32 bufferSize, string bufferHeader);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase GetStream(UInt32 streamId);
    [NullableContextAttribute("2")]
public sealed virtual LogStreamBase CloseStream(UInt32 streamId);
    public sealed virtual void SetProcessOwnerSid(string processOwnerSid);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.Stream.StreamKey : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Guid Id { get; public set; }
    public string Prefix { get; public set; }
    public StreamKey(Guid Id, string Prefix);
    [CompilerGeneratedAttribute]
protected StreamKey(StreamKey original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(StreamKey left, StreamKey right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(StreamKey left, StreamKey right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(StreamKey other);
    [CompilerGeneratedAttribute]
public virtual StreamKey <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Guid& Id, String& Prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.TestEnd : IdNamePair {
    [CompilerGeneratedAttribute]
private string <Outcome>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Outcome { get; public set; }
    public TestEnd(string Id, string Name, string Outcome);
    [CompilerGeneratedAttribute]
protected TestEnd(TestEnd original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Outcome();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Outcome(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestEnd left, TestEnd right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestEnd left, TestEnd right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdNamePair other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestEnd other);
    [CompilerGeneratedAttribute]
public virtual IdNamePair <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name, String& Outcome);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.TestStart : IdNamePair {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public TestStart(string Id, string Name);
    [CompilerGeneratedAttribute]
protected TestStart(TestStart original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TestStart left, TestStart right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TestStart left, TestStart right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdNamePair other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TestStart other);
    [CompilerGeneratedAttribute]
public virtual IdNamePair <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeCoverage.Interprocess.UnixMessage : Message {
    private Byte[] _messageSizeBuffer;
    private int _expectedMessageSize;
    public bool Complete { get; }
    public virtual void SetLastReadCount(int count);
    public virtual Byte[] GetNextReadBuffer();
    public virtual bool get_Complete();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
