[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Collector.CollectorUtility : object {
    public static string GetVSInstallPath();
    public static void RemoveChildNodeAndReturnValue(XmlElement& owner, string elementName, String& elementValue);
    public static MachineType GetMachineType(string fileName);
    public static string GetDotnetHostFullPath();
    private static string GetVSIDEPathRelativeToTraceDataCollector();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler : object {
    private static string CoverageUri;
    private static string CoverageFileExtension;
    private static string XmlFileExtension;
    private static string CoverageFriendlyName;
    private static Uri CodeCoverageDataCollectorUri;
    private static ICoverageFileUtilityV2 CoverageFileUtilityV2;
    public bool SupportsIncrementalProcessing { get; }
    private static CodeCoverageDataAttachmentsHandler();
    public sealed virtual bool get_SupportsIncrementalProcessing();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler/<GetExtensionUris>d__8")]
public sealed virtual IEnumerable`1<Uri> GetExtensionUris();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler/<ProcessAttachmentSetsAsync>d__9")]
public sealed virtual Task`1<ICollection`1<AttachmentSet>> ProcessAttachmentSetsAsync(XmlElement configurationElement, ICollection`1<AttachmentSet> attachments, IProgress`1<int> progressReporter, IMessageLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler/<MergeCodeCoverageFilesAsync>d__10")]
private Task`1<IList`1<string>> MergeCodeCoverageFilesAsync(IList`1<string> files, IProgress`1<int> progressReporter, XmlElement configurationElement, CancellationToken cancellationToken);
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/CodeCoverage/2.1")]
[DataCollectorFriendlyNameAttribute("Code Coverage 2.1")]
public class Microsoft.VisualStudio.Coverage.DynamicCoverage21DataCollector : DynamicCoverageDataCollector {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataCollectorTypeUriAttribute("datacollector://Microsoft/CodeCoverage/2.0")]
[DataCollectorFriendlyNameAttribute("Code Coverage")]
public class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollector : CommonDataCollector {
    private bool _testcaseEventsUnsubscribed;
    private bool _forceIntellitraceCollection;
    private IEnvironment _environment;
    private IDirectoryHelper _directoryHelper;
    private IFileHelper _fileHelper;
    private IProfilersLocationProvider _profilersLocationProvider;
    private IDynamicCoverageDataCollectorImplFactory _dynamicCoverageDataCollectorImplFactory;
    [NullableAttribute("2")]
private IVanguardProvider _vanguardProvider;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private IPrivilegeChecker _privilegeChecker;
    private ISourceRootTranslatorFactory _sourceRootTranslatorFactory;
    [NullableAttribute("2")]
private DataCollectorConfiguration _collectorConfiguration;
    [NullableAttribute("2")]
private IDynamicCoverageDataCollectorImpl _implementation;
    internal DynamicCoverageDataCollector(IProfilersLocationProvider vanguardLocationProvider, IVanguardProvider vanguardProvider, IDynamicCoverageDataCollectorImplFactory dynamicCoverageDataCollectorImplFactory, IEnvironment environment, IFileHelper fileHelper, IDirectoryHelper directoryHelper, ITraceLogger traceLogger, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, IPrivilegeChecker privilegeChecker, ISourceRootTranslatorFactory sourceRootTranslatorFactory);
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    internal virtual _CollectionPlan BeforeSecondCollectorInitialize(_CollectionPlan plan);
    private void Initialize(XmlElement configurationElement, _CollectionPlan plan, bool isFirstCollectorToInitialize);
    private static void ValidateReportsConfiguration(DataCollectorConfiguration collectorConfiguration);
    protected virtual void Dispose(bool disposing);
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    private void SessionEnd(object sender, SessionEndEventArgs e);
    private void SessionStart(object sender, SessionStartEventArgs e);
    private void Events_TestCaseEnd(object sender, TestCaseEndEventArgs e);
    private void Events_TestCaseStart(object sender, TestCaseStartEventArgs e);
    private void TestHostLaunched(object sender, TestHostLaunchedEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollectorImpl : object {
    private IDirectoryHelper _directoryHelper;
    private IEnvironment _environment;
    [NullableAttribute("2")]
private IDataCollectionLogger _logger;
    [NullableAttribute("2")]
private IDataCollectionSink _dataSink;
    private int _attachmentReferenceCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _uploadedAttachmentsCount;
    private bool _isManualTest;
    private bool _isExecutedRemotely;
    private bool _collectionPlanPopulated;
    [CompilerGeneratedAttribute]
private IVanguardProvider <VanguardProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private DataCollectorConfiguration <DataCollectorConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyVanguardEnabledForRemoteRole>k__BackingField;
    public IVanguardProvider VanguardProvider { get; }
    public DataCollectorConfiguration DataCollectorConfiguration { get; }
    internal bool OnlyVanguardEnabledForRemoteRole { get; private set; }
    public DynamicCoverageDataCollectorImpl(bool isManualTest, bool isExecutedRemotely, IEnvironment environment, _CollectionPlan plan, bool isFirstCollectorToInitialize, IVanguardProvider vanguardProvider, DataCollectorConfiguration dataCollectorConfiguration, IDataCollectionSink dataSink, IDataCollectionLogger logger);
    internal DynamicCoverageDataCollectorImpl(IDirectoryHelper directoryHelper, IEnvironment environment, IVanguardProvider vanguardProvider, DataCollectorConfiguration dataCollectorConfiguration, IDataCollectionSink dataSink, IDataCollectionLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IVanguardProvider get_VanguardProvider();
    [CompilerGeneratedAttribute]
public DataCollectorConfiguration get_DataCollectorConfiguration();
    [CompilerGeneratedAttribute]
internal bool get_OnlyVanguardEnabledForRemoteRole();
    [CompilerGeneratedAttribute]
private void set_OnlyVanguardEnabledForRemoteRole(bool value);
    [NullableContextAttribute("2")]
public virtual void InitializeConfiguration(IISEnvironmentInjector injector);
    private void PopulateCollectionPlan(_CollectionPlan plan, string sessionName, bool collectAspDotNet);
    public sealed virtual _CollectionPlan UpdateCollectionPlanWithVanguardInfo(_CollectionPlan plan);
    public virtual void Dispose();
    public virtual Task SessionStartAsync(object sender, SessionStartEventArgs e);
    public virtual void SessionEnd(object sender, SessionEndEventArgs e);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollectorImpl/<StartVanguardAsync>d__27")]
protected Task StartVanguardAsync(SessionStartEventArgs e);
    public sealed virtual void TestCaseStart(object sender, TestCaseStartEventArgs e);
    public sealed virtual void TestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected void StopVanguard(DataCollectionContext context);
    protected void OnSendFileCompletedEvent(object sender, AsyncCompletedEventArgs e);
    private void CreateDirectory(DataCollectionContext context, string path);
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/CodeCoverage/2.0")]
[DataCollectorFriendlyNameAttribute("Code Coverage")]
[DataCollectorAttachmentProcessorAttribute("Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler")]
public class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollectorWithAttachmentProcessor : DynamicCoverageDataCollector {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataCollectorTypeUriAttribute("datacollector://Microsoft/CodeCoverage/2.0")]
[DataCollectorFriendlyNameAttribute("Code Coverage")]
[DataCollectorAttachmentProcessorAttribute("Microsoft.VisualStudio.Coverage.CodeCoverageDataAttachmentsHandler")]
public class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollectorWithAttachmentProcessorAndTelemetry : DynamicCoverageDataCollector {
    private CoverageTelemetryReporter _coverageTelemetryReporter;
    internal ICoverageTelemetryReporter TelemetryReporter { get; }
    internal virtual ICoverageTelemetryReporter get_TelemetryReporter();
    public sealed virtual void Initialize(ITelemetryReporter telemetryReporter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Coverage.UnitTestDataCollector : DynamicCoverageDataCollectorImpl {
    public UnitTestDataCollector(bool isManualTest, bool isExecutedRemotely, IEnvironment environment, _CollectionPlan plan, bool isFirstCollectorToInitialize, IVanguardProvider vanguardProvider, DataCollectorConfiguration dataCollectorConfiguration, IDataCollectionSink dataSink, IDataCollectionLogger logger);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Coverage.UnitTestDataCollector/<SessionStartAsync>d__1")]
public virtual Task SessionStartAsync(object sender, SessionStartEventArgs e);
    public virtual void SessionEnd(object sender, SessionEndEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(object sender, SessionStartEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Microsoft.VisualStudio.TestPlatform.TestExtensionTypesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    public Type[] Types { get; }
    public TestExtensionTypesAttribute(Type[] types);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Microsoft.VisualStudio.TestPlatform.TestExtensionTypesV2Attribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ExtensionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExtensionImplementation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public string ExtensionType { get; }
    public string ExtensionIdentifier { get; }
    public Type ExtensionImplementation { get; }
    public int Version { get; }
    public TestExtensionTypesV2Attribute(string extensionType, string extensionIdentifier, Type extensionImplementation, int version);
    [CompilerGeneratedAttribute]
public string get_ExtensionType();
    [CompilerGeneratedAttribute]
public string get_ExtensionIdentifier();
    [CompilerGeneratedAttribute]
public Type get_ExtensionImplementation();
    [CompilerGeneratedAttribute]
public int get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.TraceCollector.BaseDataCollector : DataCollector {
    private static List`1<BaseDataCollector> DataCollectors;
    private ICoverageTelemetryReporter _telemetryEventsReporter;
    private static string LogFile;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDataCollectionEvents <Events>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDataCollectionLogger <Logger>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDataCollectionSink <DataSink>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDataCollectionAgentContext <AgentContext>k__BackingField;
    protected bool IsDisposed { get; private set; }
    internal ICoverageTelemetryReporter TelemetryReporter { get; }
    [NullableAttribute("2")]
internal IDataCollectionEvents Events { get; private set; }
    [NullableAttribute("2")]
internal IDataCollectionLogger Logger { get; private set; }
    [NullableAttribute("2")]
internal IDataCollectionSink DataSink { get; private set; }
    [NullableAttribute("2")]
internal IDataCollectionAgentContext AgentContext { get; private set; }
    protected static ReadOnlyCollection`1<BaseDataCollector> Collectors { get; }
    private static BaseDataCollector();
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    internal virtual ICoverageTelemetryReporter get_TelemetryReporter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IDataCollectionEvents get_Events();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Events(IDataCollectionEvents value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IDataCollectionLogger get_Logger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Logger(IDataCollectionLogger value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IDataCollectionSink get_DataSink();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DataSink(IDataCollectionSink value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IDataCollectionAgentContext get_AgentContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_AgentContext(IDataCollectionAgentContext value);
    protected static ReadOnlyCollection`1<BaseDataCollector> get_Collectors();
    public virtual void Initialize(XmlElement configurationElement, DataCollectionEvents events, DataCollectionSink dataSink, DataCollectionLogger logger, DataCollectionEnvironmentContext environmentContext);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, string>> Microsoft.VisualStudio.TestPlatform.ObjectModel.DataCollection.ITestExecutionEnvironmentSpecifier.GetTestExecutionEnvironmentVariables();
    internal void Initialize(XmlElement configurationElement, IDataCollectionEvents events, IDataCollectionSink dataSink, IDataCollectionLogger logger, IDataCollectionAgentContext agentContext);
    [NullableContextAttribute("2")]
protected abstract virtual void OnInitialize(XmlElement configurationElement);
    protected abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    internal abstract virtual void SetCollectionPerProcess(Dictionary`2<string, XmlElement> processCPMap);
    protected void SubscribeToEvents();
    protected void UnsubscribeFromEvents();
    protected void UnsubscribeFromTestCaseEvents();
    protected void SubscribeToTestCaseEvents();
    protected virtual void OnSendFileCompleted(object sender, AsyncCompletedEventArgs e);
    protected virtual void OnSessionEnd(object sender, SessionEndEventArgs e);
    protected virtual void OnTestHostLaunched(object sender, TestHostLaunchedEventArgs e);
    protected virtual void OnSessionStart(object sender, SessionStartEventArgs e);
    protected virtual void OnTestCaseStart(object sender, TestCaseStartEventArgs e);
    protected virtual void OnTestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected void SendFileAsync(DataCollectionContext context, string displayName, string logFilePath, bool sinkOwnsFile, object userToken);
    protected void WriteFile(DataCollectionContext context, string description, string logFilePath, bool deleteFile, object userToken);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
private void EnableLogging(XmlElement configurationElement);
    private string GetTimestampedLogFile(string logFile);
    private void AssertNotDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.TraceCollector.CommonDataCollector : BaseDataCollector {
    private string _collectorName;
    private string _cPlanFileName;
    private static string ActiveProfileFormat;
    private static string SessionZeroActiveProfile;
    private static bool EnvironmentVariablesRequested;
    private static IMessageMemory2 Memory;
    [NullableAttribute("2")]
private Timer _keepAliveTimer;
    private static int KeepAliveTimeout;
    private static object CollectionPlanLock;
    [NullableAttribute("2")]
private static _CollectionPlan CPlanXml;
    private static bool WriteTraceFile;
    private static bool WriteCoverageFile;
    private bool _ownsCollectionPlan;
    private bool _collectionInitiated;
    private List`1<string> _profileValueNames;
    private bool _iisInstrumented;
    private bool _configureIIS;
    internal static string RootPathTIA;
    internal static bool LogFilePath;
    [NullableAttribute("2")]
private IISEnvironmentInjector _iisEnvInjector;
    private bool _IISInitializationAttempted;
    private IEnumerable`1<OverwrittenRegistryValues> _conflicts;
    private Dictionary`2<string, string> _envVars;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _allowedUsers;
    private List`1<LoggerWrapper> _loggers;
    private string _traceLogProfilerCLSID;
    private List`1<TestInfo> _executingTests;
    private HashSet`1<Guid> _testHasLoggers;
    private HashSet`1<Guid> _observedWebRequests;
    private ITraceLogger _traceLogger;
    private object _thisLock;
    [NullableAttribute("2")]
private QueuedIpcPipeServer _ipc;
    [NullableAttribute("2")]
private RegisteredWaitHandle _ipcHandler;
    [NullableAttribute("2")]
private QueuedIpcPipeServer _globalIpc;
    [NullableAttribute("2")]
private RegisteredWaitHandle _globalIpcHandler;
    [NullableAttribute("2")]
private VolatileSettingsStore _store;
    private static string DefaultConfiguration;
    [CompilerGeneratedAttribute]
private bool <IsIntelliTraceAvailable>k__BackingField;
    protected bool IsIntelliTraceAvailable { get; private set; }
    public bool TraceDebuggingEnabled { get; }
    public bool TestImpactEnabled { get; }
    public bool UnitTestIsolationEnabled { get; }
    protected bool OwnsCollectionPlan { get; }
    internal static string RegistryBasePath { get; }
    internal static string RegistryProfilesPath { get; }
    private List`1<string> AllowedUsers { get; }
    private bool CreateSessionZeroFileForIIS { get; }
    private bool IsMtmOrRemote { get; }
    private bool InstrumentLocalIISInSessionScope { get; }
    [NullableAttribute("2")]
internal IISEnvironmentInjector IISInjector { get; }
    internal CommonDataCollector(ITraceLogger traceLogger);
    private static CommonDataCollector();
    [CompilerGeneratedAttribute]
protected bool get_IsIntelliTraceAvailable();
    [CompilerGeneratedAttribute]
private void set_IsIntelliTraceAvailable(bool value);
    [NullableContextAttribute("2")]
internal static _CollectionPlan GetCollectionPlan();
    protected static void SetEnvironmentVariableRequested(bool environmentVariablesRequested);
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    [NullableContextAttribute("2")]
protected virtual void OnInitialize(XmlElement configurationElement);
    private void ConfigureCPForCollection(_CollectionPlan cp);
    private static void ClearEnvironmentVariablesFromProcess(IList`1<KeyValuePair`2<string, string>> envVars);
    private static void AddEnvVariableFromProcess(Dictionary`2<string, string> envVars, string envVariable);
    private static void ClearEnvVariableFromProcess(IList`1<KeyValuePair`2<string, string>> envVars, string envVariable);
    internal virtual void SetCollectionPerProcess(Dictionary`2<string, XmlElement> processCPMap);
    private void InitializeIIS();
    private void CleanupIIS();
    public void InitiateCollection();
    public virtual void InitiateCollectionUnderLock();
    public bool get_TraceDebuggingEnabled();
    public bool get_TestImpactEnabled();
    public bool get_UnitTestIsolationEnabled();
    public void InitializeWriting();
    protected bool get_OwnsCollectionPlan();
    internal abstract virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal abstract virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    internal virtual _CollectionPlan BeforeSecondCollectorInitialize(_CollectionPlan plan);
    private void Cleanup();
    protected virtual void Dispose(bool disposing);
    private void DispatchMessage(MessageCreator mCreate);
    private void CollectLogs(DataCollectionContext cxt, TestCaseEventArgs testCaseEventArgs, bool cleanupLoggers, bool writeTraceLog, bool writeTestImpactLog);
    protected sealed virtual void OnSessionStart(object sender, SessionStartEventArgs e);
    protected sealed virtual void OnTestCaseStart(object sender, TestCaseStartEventArgs e);
    protected sealed virtual void OnTestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected sealed virtual void OnSessionEnd(object sender, SessionEndEventArgs e);
    internal static string get_RegistryBasePath();
    internal static string get_RegistryProfilesPath();
    internal static RegistryKey GetRegKeyProfiles();
    private _TestCaseContext GetTestCaseContextMessage(ITestCaseContextEventArgs eventArgs);
    private void IPCNotEmptyCallback(object ipcObj, bool timedOut);
    private void OnLoggerInfo(_LoggerInfo info);
    private void OnTestMadeWebRequest(_TestMadeWebRequest msg);
    private void SendKeepAlive(object state);
    private bool AreRequiredIISComponentsInstalled();
    private void ConfigureIISProfiling(DataCollectionContext context);
    private void LogWebInstrumentException(DataCollectionContext context, WebInstrumenterException e);
    private List`1<string> get_AllowedUsers();
    private void ClearAndResetIIS();
    private bool get_CreateSessionZeroFileForIIS();
    private bool get_IsMtmOrRemote();
    private bool get_InstrumentLocalIISInSessionScope();
    [NullableContextAttribute("2")]
internal IISEnvironmentInjector get_IISInjector();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.TraceCollector.Constants : object {
    public static string ExtensionTypeName;
    public static string Uri;
    public static string FriendlyName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.DataCollection.DataCollectionEnvironmentContextWrapper : object {
    private DataCollectionEnvironmentContext _environmentContext;
    public DataCollectionContext SessionDataCollectionContext { get; }
    public DataCollectionEnvironmentContextWrapper(DataCollectionEnvironmentContext environmentContext);
    public sealed virtual DataCollectionContext get_SessionDataCollectionContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.DataCollection.DataCollectionEventsWrapper : object {
    private DataCollectionEvents _wrapped;
    public DataCollectionEventsWrapper(DataCollectionEvents wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.add_TestHostLaunched(EventHandler`1<TestHostLaunchedEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.remove_TestHostLaunched(EventHandler`1<TestHostLaunchedEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.add_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.remove_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.add_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.remove_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.add_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.remove_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.add_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents.remove_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.DataCollection.DataCollectionLoggerWrapper : object {
    private DataCollectionLogger _wrapped;
    public DataCollectionLoggerWrapper(DataCollectionLogger wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionLogger.LogError(DataCollectionContext context, Exception exception);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionLogger.LogError(DataCollectionContext context, string text);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionLogger.LogError(DataCollectionContext context, string text, Exception exception);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionLogger.LogWarning(DataCollectionContext context, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.DataCollection.DataCollectionSinkWrapper : object {
    private DataCollectionSink _wrapped;
    public DataCollectionSinkWrapper(DataCollectionSink wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink.add_SendFileCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink.remove_SendFileCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink.SendFileAsync(DataCollectionContext context, string path, bool deleteFile);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink.SendFileAsync(DataCollectionContext context, string path, string description, bool deleteFile);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink.SendFileAsync(FileTransferInformation fileInformation);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionAgentContext {
    public DataCollectionContext SessionDataCollectionContext { get; }
    public abstract virtual DataCollectionContext get_SessionDataCollectionContext();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionEvents {
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestHostLaunched(EventHandler`1<TestHostLaunchedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestHostLaunched(EventHandler`1<TestHostLaunchedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionLogger {
    public abstract virtual void LogError(DataCollectionContext context, Exception exception);
    public abstract virtual void LogError(DataCollectionContext context, string text);
    public abstract virtual void LogError(DataCollectionContext context, string text, Exception exception);
    public abstract virtual void LogWarning(DataCollectionContext context, string text);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.DataCollection.IDataCollectionSink {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SendFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SendFileCompleted(AsyncCompletedEventHandler value);
    public abstract virtual void SendFileAsync(DataCollectionContext context, string path, bool deleteFile);
    public abstract virtual void SendFileAsync(DataCollectionContext context, string path, string displayName, bool deleteFile);
    public abstract virtual void SendFileAsync(FileTransferInformation fileInformation);
}
[CoClassAttribute("Microsoft.VisualStudio.TraceCollector.DiaSourceClass")]
[GuidAttribute("79F1BB5F-B66E-48E5-B6A9-1545C323CA3D")]
internal interface Microsoft.VisualStudio.TraceCollector.DiaSource {
}
[ClassInterfaceAttribute("0")]
[GuidAttribute("E6756135-1E65-4D17-8576-610761398C3C")]
[TypeLibTypeAttribute("2")]
internal class Microsoft.VisualStudio.TraceCollector.DiaSourceClass : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.TraceCollector.DiaSourceObjectClass : object {
    private static IntPtr LoadLibraryEx(string lpFileName, IntPtr hReservedNull, int dwFlags);
    [NullableContextAttribute("2")]
public static IDiaDataSource GetDiaSourceObject();
    internal static object DllGetClassObject(Guid rclsid, Guid riid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.TraceCollector.FileSignature : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlTextAttribute]
public string Signature { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    public sealed virtual bool Equals(FileSignature other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FileSignature left, FileSignature right);
    public static bool op_Inequality(FileSignature left, FileSignature right);
    public sealed virtual int CompareTo(FileSignature other);
    public static bool op_GreaterThan(FileSignature left, FileSignature right);
    public static bool op_LessThan(FileSignature left, FileSignature right);
}
internal static class Microsoft.VisualStudio.TraceCollector.HResult : object {
    public static bool Failed(int hr);
    public static bool Succeeded(int hr);
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("79F1BB5F-B66E-48E5-B6A9-1545C323CA3D")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaDataSource {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int LoadDataForExe(string executable, string searchPath, IntPtr callback);
    public abstract virtual int stub5();
    public abstract virtual int OpenSession(IDiaSession& session);
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("D5612573-6925-4468-8883-98CDEC8C384A")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaEnumInjectedSources {
    public abstract virtual int stub1();
    public abstract virtual int GetCount(UInt32& count);
    public abstract virtual int GetItem(UInt32 index, IDiaInjectedSource& source);
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("FE30E878-54AC-44f1-81BA-39DE940F6052")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaEnumLineNumbers {
    public abstract virtual int stub1();
    public abstract virtual int GetCount(UInt32& count);
    public abstract virtual int GetItem(UInt32 index, IDiaLineNumber& line);
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("AE605CDC-8105-4a23-B710-3259F1E26112")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaInjectedSource {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int GetSource(UInt32 cbData, UInt32& pcbData, Byte* pbData);
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("B388EB14-BE4D-421d-A8A1-6CF7AB057086")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaLineNumber {
    public abstract virtual int stub1();
    public abstract virtual int GetSourceFile(IDiaSourceFile& file);
    public abstract virtual int GetLineNumber(UInt32& line);
    public abstract virtual int stub4();
    public abstract virtual int GetColumnNumber(UInt32& line);
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int stub14();
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("2F609EE1-D1C8-4E24-8288-3326BADCD211")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaSession {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int FindSymbolByToken(UInt32 token, SymTagEnum tag, IDiaSymbol& symbol);
    public abstract virtual int stub15();
    public abstract virtual int stub16();
    public abstract virtual int stub17();
    public abstract virtual int stub18();
    public abstract virtual int stub19();
    public abstract virtual int stub20();
    public abstract virtual int stub21();
    public abstract virtual int FindLinesByAddress(UInt32 section, UInt32 offset, UInt32 length, IDiaEnumLineNumbers& enumerator);
    public abstract virtual int stub23();
    public abstract virtual int stub24();
    public abstract virtual int stub25();
    public abstract virtual int FindInjectedSource(string file, IDiaEnumInjectedSources& injectedSources);
    public abstract virtual int stub27();
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaSourceFile {
    public abstract virtual int stub1();
    public abstract virtual int GetFilename(String& filename);
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("cb787b2f-bd6c-4635-ba52-933126bd2dcd")]
internal interface Microsoft.VisualStudio.TraceCollector.IDiaSymbol {
    public abstract virtual int stub1();
    public abstract virtual int GetSymTag(SymTagEnum& tag);
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int GetAddressSection(UInt32& section);
    public abstract virtual int GetAddressOffset(UInt32& offset);
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int stub14();
    public abstract virtual int GetLength(Int64& length);
    public abstract virtual int stub16();
    public abstract virtual int stub17();
    public abstract virtual int stub18();
    public abstract virtual int stub19();
    public abstract virtual int stub20();
    public abstract virtual int stub21();
    public abstract virtual int stub22();
    public abstract virtual int stub23();
    public abstract virtual int stub24();
    public abstract virtual int stub25();
    public abstract virtual int stub26();
    public abstract virtual int stub27();
    public abstract virtual int stub28();
    public abstract virtual int stub29();
    public abstract virtual int stub30();
    public abstract virtual int stub31();
    public abstract virtual int stub32();
    public abstract virtual int stub33();
    public abstract virtual int stub34();
    public abstract virtual int stub35();
    public abstract virtual int stub36();
    public abstract virtual int stub37();
    public abstract virtual int stub38();
    public abstract virtual int stub39();
    public abstract virtual int stub40();
    public abstract virtual int stub41();
    public abstract virtual int stub42();
    public abstract virtual int stub43();
    public abstract virtual int stub44();
    public abstract virtual int stub45();
    public abstract virtual int stub46();
    public abstract virtual int stub47();
    public abstract virtual int stub48();
    public abstract virtual int stub49();
    public abstract virtual int stub50();
    public abstract virtual int stub51();
    public abstract virtual int stub52();
    public abstract virtual int stub53();
    public abstract virtual int stub54();
    public abstract virtual int stub55();
    public abstract virtual int stub56();
    public abstract virtual int stub57();
    public abstract virtual int stub58();
    public abstract virtual int stub59();
    public abstract virtual int stub60();
    public abstract virtual int stub61();
    public abstract virtual int stub62();
    public abstract virtual int stub63();
    public abstract virtual int stub64();
    public abstract virtual int stub65();
    public abstract virtual int stub66();
    public abstract virtual int stub67();
    public abstract virtual int stub68();
    public abstract virtual int stub69();
    public abstract virtual int stub70();
    public abstract virtual int stub71();
    public abstract virtual int stub72();
    public abstract virtual int stub73();
    public abstract virtual int stub74();
    public abstract virtual int stub75();
    public abstract virtual int stub76();
    public abstract virtual int stub77();
    public abstract virtual int stub78();
    public abstract virtual int stub79();
    public abstract virtual int stub80();
    public abstract virtual int stub81();
    public abstract virtual int stub82();
    public abstract virtual int stub83();
    public abstract virtual int stub84();
    public abstract virtual int stub85();
    public abstract virtual int stub86();
    public abstract virtual int stub87();
    public abstract virtual int stub88();
    public abstract virtual int stub89();
    public abstract virtual int stub90();
    public abstract virtual int stub91();
    public abstract virtual int stub92();
    public abstract virtual int stub93();
    public abstract virtual int stub94();
    public abstract virtual int stub95();
    public abstract virtual int stub96();
    public abstract virtual int stub97();
    public abstract virtual int stub98();
    public abstract virtual int stub99();
    public abstract virtual int stub100();
    public abstract virtual int stub101();
    public abstract virtual int stub102();
    public abstract virtual int stub103();
    public abstract virtual int stub104();
    public abstract virtual int stub105();
    public abstract virtual int stub106();
    public abstract virtual int stub107();
    public abstract virtual int stub108();
    public abstract virtual int stub109();
    public abstract virtual int stub110();
    public abstract virtual int stub111();
    public abstract virtual int stub112();
    public abstract virtual int stub113();
    public abstract virtual int stub114();
    public abstract virtual int stub115();
    public abstract virtual int stub116();
    public abstract virtual int stub117();
    public abstract virtual int stub118();
    public abstract virtual int stub119();
    public abstract virtual int stub120();
    public abstract virtual int stub121();
    public abstract virtual int stub122();
    public abstract virtual int stub123();
    public abstract virtual int stub124();
    public abstract virtual int stub125();
    public abstract virtual int stub126();
    public abstract virtual int stub127();
    public abstract virtual int stub128();
    public abstract virtual int stub129();
    public abstract virtual int stub130();
    public abstract virtual int stub131();
    public abstract virtual int stub132();
    public abstract virtual int stub133();
    public abstract virtual int stub134();
    public abstract virtual int stub135();
    public abstract virtual int stub136();
    public abstract virtual int stub137();
    public abstract virtual int stub138();
    public abstract virtual int stub139();
    public abstract virtual int stub140();
    public abstract virtual int stub141();
    public abstract virtual int stub142();
    public abstract virtual int stub143();
    public abstract virtual int stub144();
    public abstract virtual int stub145();
    public abstract virtual int stub146();
    public abstract virtual int stub147();
    public abstract virtual int stub148();
    public abstract virtual int stub149();
    public abstract virtual int stub150();
    public abstract virtual int stub151();
    public abstract virtual int stub152();
    public abstract virtual int stub153();
    public abstract virtual int stub154();
    public abstract virtual int stub155();
}
internal class Microsoft.VisualStudio.TraceCollector.Interfaces.DynamicCoverageDataCollectorImplFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IDynamicCoverageDataCollectorImpl CreateImpl(IEnvironment environment, _CollectionPlan plan, bool isFirstCollectorToInitialize, IVanguardProvider vanguardProvider, DataCollectorConfiguration dataCollectorConfiguration, IDataCollectionSink dataSink, IDataCollectionLogger logger);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.Interfaces.IDynamicCoverageDataCollectorImplFactory {
    public abstract virtual IDynamicCoverageDataCollectorImpl CreateImpl(IEnvironment environment, _CollectionPlan plan, bool isFirstCollectorToInitialize, IVanguardProvider vanguardProvider, DataCollectorConfiguration dataCollectorConfiguration, IDataCollectionSink dataSink, IDataCollectionLogger logger);
}
internal interface Microsoft.VisualStudio.TraceCollector.Interfaces.IProcessJobObject {
    public abstract virtual void AddProcess(IntPtr handle);
}
internal interface Microsoft.VisualStudio.TraceCollector.Interfaces.ITraceLogger {
    public abstract virtual IList`1<KeyValuePair`2<string, string>> GetProfilerEnvVars();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.ITestCaseContextEventArgs {
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    [NullableAttribute("2")]
public TestCase TestElement { get; }
    public abstract virtual DataCollectionContext get_Context();
    public abstract virtual bool get_IsChildTestCase();
    public abstract virtual Guid get_TestCaseId();
    public abstract virtual string get_TestCaseName();
    [NullableContextAttribute("2")]
public abstract virtual TestCase get_TestElement();
}
internal static class Microsoft.VisualStudio.TraceCollector.NativeMethods : object {
    internal static bool ProcessIdToSessionId(UInt32 dwProcessId, UInt32& pSessionId);
    internal static UInt32 GetCurrentProcessId();
}
internal class Microsoft.VisualStudio.TraceCollector.NullTelemetryEventsReporter : object {
    [NullableContextAttribute("1")]
public sealed virtual void ReportTelemetryEvent(string eventName, IDictionary`2<string, object> properties);
}
internal class Microsoft.VisualStudio.TraceCollector.ProcessJobObject : object {
    private static bool Is32Bit;
    private IntPtr _jobHandle;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private static ProcessJobObject();
    protected virtual override void Finalize();
    public sealed virtual void AddProcess(IntPtr handle);
    public sealed virtual void Dispose();
    private void CreateJobObject();
    private void Dispose(bool disposing);
}
internal static class Microsoft.VisualStudio.TraceCollector.Resources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string AndSeparator { get; }
    internal static string ASPNetNotInstalled { get; }
    internal static string Both { get; }
    internal static string CodeCoverageCollectorDescription { get; }
    internal static string CodeCoverageCollectorFriendlyName { get; }
    internal static string CodeCoverageLoggingDisabled { get; }
    internal static string CodeCoverageRunSettingsProcessorFailed { get; }
    internal static string ErrorLaunchVanguard { get; }
    internal static string ErrorNoEntryPoint { get; }
    internal static string ErrorNoVanguard { get; }
    internal static string ErrorRegisterExecutable { get; }
    internal static string Error_ArgumentIsEmpty { get; }
    internal static string Error_ArgumentIsNegative { get; }
    internal static string Error_ArgumentNotTypeOf { get; }
    internal static string Error_ArgumentPropertyIsEmpty { get; }
    internal static string Error_ArgumentPropertyIsNegative { get; }
    internal static string Error_ArgumentPropertyIsNull { get; }
    internal static string Error_ArgumentPropertyNotTypeOf { get; }
    internal static string Error_ConditionIsFalse { get; }
    internal static string EventsMustHaveId { get; }
    internal static string FailedToCreateCopy { get; }
    internal static string FailedToCreateDirectory { get; }
    internal static string FailedToCreateFile { get; }
    internal static string FailedToDeleteTestImpactFile { get; }
    internal static string FailedToInitializeCodeCoverageDataCollector { get; }
    internal static string GeneralErrorLaunchVanguard { get; }
    internal static string GenericIISFailure { get; }
    internal static string IISAccessLocal { get; }
    internal static string IISAccessRemote { get; }
    internal static string IISNotInstalled { get; }
    internal static string InvalidConfig { get; }
    internal static string InvalidSettingType { get; }
    internal static string LabAgentTaskExecutionFailed { get; }
    internal static string MustSetEnvironmentVariables { get; }
    internal static string NoConfiguration { get; }
    internal static string NoLoggersConnected { get; }
    internal static string NoRunningEventFromVanguard { get; }
    internal static string NoWebRequestsMade { get; }
    internal static string ProfilerNotConnected { get; }
    internal static string ProfilerNotConnectedGlibc { get; }
    internal static string ProfilerNotConnectedNonGlibc { get; }
    internal static string TestImpactCollectorFriendlyName { get; }
    internal static string TestImpactData { get; }
    internal static string TestImpactLogFileFull { get; }
    internal static string TraceDebuggerCollectorFriendlyName { get; }
    internal static string TraceLogName { get; }
    internal static string UnableEnumerateIISService { get; }
    internal static string UnableSetVss { get; }
    internal static string VanguardConnectionTimeout { get; }
    internal static string VanguardNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_AndSeparator();
    internal static string get_ASPNetNotInstalled();
    internal static string get_Both();
    internal static string get_CodeCoverageCollectorDescription();
    internal static string get_CodeCoverageCollectorFriendlyName();
    internal static string get_CodeCoverageLoggingDisabled();
    internal static string get_CodeCoverageRunSettingsProcessorFailed();
    internal static string get_ErrorLaunchVanguard();
    internal static string get_ErrorNoEntryPoint();
    internal static string get_ErrorNoVanguard();
    internal static string get_ErrorRegisterExecutable();
    internal static string get_Error_ArgumentIsEmpty();
    internal static string get_Error_ArgumentIsNegative();
    internal static string get_Error_ArgumentNotTypeOf();
    internal static string get_Error_ArgumentPropertyIsEmpty();
    internal static string get_Error_ArgumentPropertyIsNegative();
    internal static string get_Error_ArgumentPropertyIsNull();
    internal static string get_Error_ArgumentPropertyNotTypeOf();
    internal static string get_Error_ConditionIsFalse();
    internal static string get_EventsMustHaveId();
    internal static string get_FailedToCreateCopy();
    internal static string get_FailedToCreateDirectory();
    internal static string get_FailedToCreateFile();
    internal static string get_FailedToDeleteTestImpactFile();
    internal static string get_FailedToInitializeCodeCoverageDataCollector();
    internal static string get_GeneralErrorLaunchVanguard();
    internal static string get_GenericIISFailure();
    internal static string get_IISAccessLocal();
    internal static string get_IISAccessRemote();
    internal static string get_IISNotInstalled();
    internal static string get_InvalidConfig();
    internal static string get_InvalidSettingType();
    internal static string get_LabAgentTaskExecutionFailed();
    internal static string get_MustSetEnvironmentVariables();
    internal static string get_NoConfiguration();
    internal static string get_NoLoggersConnected();
    internal static string get_NoRunningEventFromVanguard();
    internal static string get_NoWebRequestsMade();
    internal static string get_ProfilerNotConnected();
    internal static string get_ProfilerNotConnectedGlibc();
    internal static string get_ProfilerNotConnectedNonGlibc();
    internal static string get_TestImpactCollectorFriendlyName();
    internal static string get_TestImpactData();
    internal static string get_TestImpactLogFileFull();
    internal static string get_TraceDebuggerCollectorFriendlyName();
    internal static string get_TraceLogName();
    internal static string get_UnableEnumerateIISService();
    internal static string get_UnableSetVss();
    internal static string get_VanguardConnectionTimeout();
    internal static string get_VanguardNotFound();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.SimpleTimer : object {
    private Stopwatch _timer;
    private string _name;
    private long _threshold;
    private bool _disposed;
    public SimpleTimer(string timerName);
    public SimpleTimer(string timerName, long thresholdInMilliseconds);
    public sealed virtual void Dispose();
    private void StopAndLog();
    private void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.SymbolReader : object {
    private static UInt32 InvalidLineNumber;
    [NullableAttribute("2")]
private IDiaSession _session;
    private bool _disposed;
    public SymbolReader(string filename);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public bool IsSessionNull();
    [NullableContextAttribute("2")]
public bool GetTokenFilename(UInt32 token, String& fileName);
    private static bool GetFirstSourceFile(IDiaEnumLineNumbers lines, String& fileName);
    private void Close();
    private void CheckDisposed();
    private static IDiaSession OpenSession(string filename);
}
internal enum Microsoft.VisualStudio.TraceCollector.SymTagEnum : Enum {
    public UInt32 value__;
    public static SymTagEnum SymTagNull;
    public static SymTagEnum SymTagExe;
    public static SymTagEnum SymTagCompiland;
    public static SymTagEnum SymTagCompilandDetails;
    public static SymTagEnum SymTagCompilandEnv;
    public static SymTagEnum SymTagFunction;
    public static SymTagEnum SymTagBlock;
    public static SymTagEnum SymTagData;
    public static SymTagEnum SymTagAnnotation;
    public static SymTagEnum SymTagLabel;
    public static SymTagEnum SymTagPublicSymbol;
    public static SymTagEnum SymTagUDT;
    public static SymTagEnum SymTagEnum;
    public static SymTagEnum SymTagFunctionType;
    public static SymTagEnum SymTagPointerType;
    public static SymTagEnum SymTagArrayType;
    public static SymTagEnum SymTagBaseType;
    public static SymTagEnum SymTagTypedef;
    public static SymTagEnum SymTagBaseClass;
    public static SymTagEnum SymTagFriend;
    public static SymTagEnum SymTagFunctionArgType;
    public static SymTagEnum SymTagFuncDebugStart;
    public static SymTagEnum SymTagFuncDebugEnd;
    public static SymTagEnum SymTagUsingNamespace;
    public static SymTagEnum SymTagVTableShape;
    public static SymTagEnum SymTagVTable;
    public static SymTagEnum SymTagCustom;
    public static SymTagEnum SymTagThunk;
    public static SymTagEnum SymTagCustomType;
    public static SymTagEnum SymTagManagedType;
    public static SymTagEnum SymTagDimension;
}
internal class Microsoft.VisualStudio.TraceCollector.Telemetry.CollectorTelemetryManager : object {
    [NullableAttribute("1")]
private ICoverageTelemetryReporter _telemetryEventsReporter;
    [NullableContextAttribute("1")]
public CollectorTelemetryManager(ICoverageTelemetryReporter telemetryEventsReporter);
    public sealed virtual void ModuleEvent(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public sealed virtual void SessionEvent(IEnumerable`1<KeyValuePair`2<string, object>> properties);
}
internal class Microsoft.VisualStudio.TraceCollector.Telemetry.CoverageTelemetryReporter : object {
    [NullableAttribute("2")]
private ITelemetryReporter _telemetryReporter;
    [NullableContextAttribute("1")]
public sealed virtual void ReportTelemetryEvent(string eventName, IDictionary`2<string, object> properties);
    [NullableContextAttribute("1")]
public void SetTpTelemetryReporter(ITelemetryReporter telemetryReporter);
}
internal interface Microsoft.VisualStudio.TraceCollector.Telemetry.ICollectorTelemetryManager {
    public abstract virtual void ModuleEvent(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public abstract virtual void SessionEvent(IEnumerable`1<KeyValuePair`2<string, object>> properties);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.Telemetry.ICoverageTelemetryReporter {
    public abstract virtual void ReportTelemetryEvent(string eventName, IDictionary`2<string, object> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.Telemetry.TelemetryLogger : LoggerBase {
    private static string FilePathHashKey;
    private static string FileHashKey;
    private static string BlocksKey;
    private static string BlocksCoveredKey;
    private static string BlocksNotCoveredKey;
    private static string BlocksCoverageKey;
    private static string MethodsInstrumentedKey;
    private static string MethodsSkippedKey;
    private static string MethodsFailedKey;
    private static string ModuleInstrumentedKey;
    private static string ModuleSkippedKey;
    private static string ModuleFailedKey;
    private static string ModuleStaticInstrumentedKey;
    private static string ModuleStaticSkippedKey;
    private static string IsManagedKey;
    private static string ElapsedKey;
    private static string ElapsedStaticKey;
    private static string ModulesInstrumentedManagedKey;
    private static string ModulesInstrumentedNativeKey;
    private static string ModulesSkippedManagedKey;
    private static string ModulesSkippedNativeKey;
    private static string ModulesFailedManagedKey;
    private static string ModulesFailedNativeKey;
    private static string ModulesInstrumentedStaticNativeKey;
    private static string ModulesSkippedStaticNativeKey;
    private static string ProcessorCountKey;
    private static string FrameworkDescriptionKey;
    private static object _lock;
    private ICollectorTelemetryManager _telemetryManager;
    private ILogger _logger;
    private IDictionary`2<string, IDictionary`2<string, object>> _moduleProperties;
    private IDictionary`2<Guid, IList`1<string>> _coverageBufferIdMapping;
    internal TelemetryLogger(string sessionName, string pipePath, string configurationFilePath, DataCollectorConfiguration dataCollectorConfiguration, ILogger logger, IEnvironment environment, IStaticNativeInstrumenter staticNativeInstrumenter, IStaticNativeRuntimeProvider staticNativeRuntimeProvider, IDirectoryHelper directoryHelper, ICollectorTelemetryManager telemetryManager, IOutputPathGenerator outputPathGenerator, ISourceRootTranslator sourceRootTranslator, IProfilersLocationProvider profilersLocationProvider);
    private static TelemetryLogger();
    protected virtual void OnBufferClose(Guid identifier, Byte[] bytes);
    protected virtual void OnInstrumentation(string path, Guid id, Guid coverageBufferId, bool isDynamic, bool isManaged, bool isMixed, bool isPortablePdb, UInt32 imageSize, UInt32 imageLinkTime, int numberOfMethodsInstrumented, int numberOfMethodsSkipped, int numberOfMethodsFailed, TimeSpan elapsed, Dictionary`2<string, string> properties);
    protected virtual void OnInstrumentationSkipped(string path, ModuleSkipReason moduleSkipReason, bool isManaged);
    protected virtual void OnStaticInstrumentation(string path, UInt32 staticResult, TimeSpan staticElapsed, bool isManaged);
    protected virtual void OnStaticInstrumentationSkipped(string path, bool isManaged);
    protected virtual void OnShutdown();
    private static void AddOrReplace(IDictionary`2<string, object> properties, string key, object value, bool overwrite);
    private static void Aggregate(IDictionary`2<string, object> sessionProperties, IDictionary`2<string, object> properties, string key);
    private static void Increment(IDictionary`2<string, object> properties, string key);
    private static bool GetFlag(IDictionary`2<string, object> properties, string key);
    private static ulong GetUlongProperty(IDictionary`2<string, object> properties, string key);
    private IDictionary`2<string, object> InitializeModulePropertiesIfNeeded(string path);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.TraceCollector.TelemetryConstants : object {
    public static string BaseEvent;
    public static string BaseProperty;
    public static string Collector;
    public static string CollectorEventBase;
    public static string CollectorPropertyBase;
    public static string VanguardModuleEvent;
    public static string VanguardSessionEvent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.TestCaseEndEventArgsWrapper : object {
    private TestCaseEndEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    [NullableAttribute("2")]
public TestCase TestElement { get; }
    public TestCaseEndEventArgsWrapper(TestCaseEndEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    [NullableContextAttribute("2")]
public sealed virtual TestCase get_TestElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.TestCaseStartEventArgsWrapper : object {
    private TestCaseStartEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    [NullableAttribute("2")]
public TestCase TestElement { get; }
    public TestCaseStartEventArgsWrapper(TestCaseStartEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    [NullableContextAttribute("2")]
public sealed virtual TestCase get_TestElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataCollectorTypeUriAttribute("datacollector://Microsoft/TestImpact/1.0")]
[DataCollectorFriendlyNameAttribute("Test Impact")]
public class Microsoft.VisualStudio.TraceCollector.TestImpactDataCollector : CommonDataCollector {
    internal static string Uri;
    internal static string FriendlyName;
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    private void PopulateCollectionPlan(_CollectionPlan plan, XmlElement settings);
    protected virtual void OnSendFileCompleted(object sender, AsyncCompletedEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.TestImpactDirectoryWrapper : object {
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    public string DirectoryPath { get; private set; }
    [NullableContextAttribute("1")]
public TestImpactDirectoryWrapper(IDataCollectionLogger logger, DataCollectionContext context);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
private void set_DirectoryPath(string value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Delete();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[XmlRootAttribute("Test")]
public class Microsoft.VisualStudio.TraceCollector.TestImpactXmlData : object {
    private static string FileTypeSignature;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, KeyValuePair`2<SymbolReader, bool>> _symbolReaderCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, string> _filePathCacheCache;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <AutomatedTestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<FileSignature> <Signatures>k__BackingField;
    [NullableAttribute("2")]
[XmlAttributeAttribute("Name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("AutomatedTestId")]
public Guid AutomatedTestId { get; public set; }
    [XmlAttributeAttribute("SignatureType")]
public string SignatureType { get; public set; }
    [XmlArrayAttribute("Signatures")]
[XmlArrayItemAttribute("Signature", "Microsoft.VisualStudio.TraceCollector.FileSignature")]
public HashSet`1<FileSignature> Signatures { get; }
    public TestImpactXmlData(TestCaseEventArgs e);
    private static TestImpactXmlData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Guid get_AutomatedTestId();
    [CompilerGeneratedAttribute]
public void set_AutomatedTestId(Guid value);
    [CompilerGeneratedAttribute]
public string get_SignatureType();
    [CompilerGeneratedAttribute]
public void set_SignatureType(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<FileSignature> get_Signatures();
    public void PopulateSignatures(string logPath, Guid testExecId, string rootPath, bool logFilePath);
    internal void PopulateSignatures(string streamFilePath, TestImpactDataEventsMessagePacker packer, string rootPath, bool logFilePath);
    private void PopulateSignatures(IEnumerable`1<_TestImpactDataFlushEvent> dataEvents, string rootPath, bool logFilePath);
    private static bool GetSymbolReader(string assemblyName, SymbolReader& symbolsReader);
    private string GetSignature(string name);
    private static IMetaDataImport2 CreateMetadataImport(string path);
    private static void AppendCodeElementSignature(StringBuilder builder, SHA1CryptoServiceProvider algorithm, string name);
    internal static void CleanCache();
}
internal class Microsoft.VisualStudio.TraceCollector.TraceLoggerWrapper : object {
    public sealed virtual IList`1<KeyValuePair`2<string, string>> GetProfilerEnvVars();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationCollector.FakesAssemblyReflector : object {
    internal static string FakesTypesCacheFileExtension;
    public sealed virtual HashSet`1<string> ReflectShimTypes(string fakesAssemblyFullPath);
    private static string BuildCacheFilePath(string fakesAssemblyFullPath);
    private static bool CheckIfNeedToUpdate(string fakeAssemblyFullPath, string fakedTypesCacheFilePath);
    private static HashSet`1<string> LoadShimTypesFromCache(string fakesAssemblyFullPath, string fakedTypesCacheFilePath);
    private static HashSet`1<string> ReflectShimTypes(string fakesAssembly, string fakedTypesCacheFilePath);
    private static HashSet`1<string> GetShimedTypesInfo(string fakeAssemblyFullPath, StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationCollector.HostEnvironment : DefaultWindowsRuntimeHost {
    [NullableAttribute("2")]
private AssemblyIdentity _externalCoreAssemblySymbolicIdentity;
    [DebuggerBrowsableAttribute("0")]
private AssemblyIdentity ExternalCoreAssemblySymbolicIdentity { get; }
    [DebuggerStepThroughAttribute]
private AssemblyIdentity get_ExternalCoreAssemblySymbolicIdentity();
    public virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.UnitTestIsolationCollector.IFakesAssemblyReflector {
    public abstract virtual HashSet`1<string> ReflectShimTypes(string fakesAssembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationCollector.SingleAssemblyHost : object {
    private HostEnvironment _hostEnvironment;
    private bool _disposed;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IAssembly <Assembly>k__BackingField;
    [NullableAttribute("2")]
public IAssembly Assembly { get; private set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IAssembly get_Assembly();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Assembly(IAssembly value);
    public static SingleAssemblyHost LoadAssemblyFrom(string location);
    private IAssembly ReadAssembly(string assemblyPath);
    private static bool IsInvalidAssembly(IAssembly assembly);
    private static bool EnsureNonManifestModulesArePresent(string assemblyPath, IAssembly assembly);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationCollector.SingleAssemblyWalker : object {
    private static string ShimClassCustomAttribute;
    private static string FakeTopLevelTypePrefix;
    private IAssembly _assembly;
    private StringBuilder _writer;
    private bool _publicOnly;
    private TypeNameCache _typeNameCache;
    private HashSet`1<string> _shimTypes;
    public SingleAssemblyWalker(IAssembly assembly, StringBuilder writer, HashSet`1<string> shimTypes, bool publicOnly);
    public void Start();
    private void WalkType(ITypeDefinition type);
    internal void AccumulateShimType(ITypeDefinition type);
    private ICustomAttribute SafeFindAttribute(IReference reference, string fullyQualifiedAttributeName);
    private bool IsTopLevelType(IMetadataExpression expression);
    private static bool IsPublicType(ITypeDefinition type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataCollectorTypeUriAttribute("datacollector://microsoft/unittestisolation/1.0")]
[DataCollectorFriendlyNameAttribute("UnitTestIsolation")]
public class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationDataCollector : CommonDataCollector {
    internal static string Uri;
    internal static string FriendlyName;
    private static string ShimLeadingKeyword;
    private static string FakesEndingKeyword;
    private static string FakesFrameworkAssemblyName;
    private static string FakesTestPlatformAssemblyName;
    private IFakesAssemblyReflector _fakesAssemblyReflector;
    internal UnitTestIsolationDataCollector(IFakesAssemblyReflector stubReflector);
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    private void PopulateCollectionPlan(_CollectionPlan plan, XmlElement settings);
    private static void BuildCollectionPlan(_CollectionPlan plan, Dictionary`2<string, HashSet`1<string>> knownAssemblies);
    private static void AccumulateShimmedTypeForEachAssembly(Dictionary`2<string, HashSet`1<string>> knownAssemblies, string assemblyName, HashSet`1<string> shimTypes);
    internal static string ExtractAssemblyNameFromFakesAssembly(string fakesAssemblyFullPath);
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.TraceCollector.Validate : object {
    [DebuggerStepThroughAttribute]
public static T NotNull(T arg, string parameterName);
    [DebuggerStepThroughAttribute]
public static void True(bool condition, string message);
    public static void Assert(bool condition, string message);
    public static void Assert(string message);
}
[AttributeUsageAttribute("2048")]
internal class Microsoft.VisualStudio.TraceCollector.ValidatedNotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageAdvancedSettings : object {
    private static string CollectChildProcessStr;
    private static string UseVerifiableInstrumentationStr;
    private static string AllowLowIntegrityProcessStr;
    private static string ExcludeCompilerAutoGeneratedModulesStr;
    internal static string AllowedUserListName;
    internal static string AllowedUserElementName;
    internal static string Everyone;
    private static string SymbolPathListName;
    private static string SymbolPathElementName;
    private static string CompanyNameListName;
    private static string CompanyNameElementName;
    private static string CompanyNameSample;
    private static string PublicKeyTokenListName;
    private static string PublicKeyTokenElementName;
    private static string PublicKeyTokenSample;
    private Dictionary`2<string, object> _generalSettings;
    private XmlDocument _ownerDoc;
    [CompilerGeneratedAttribute]
private SimpleListSettings <AllowedUserList>k__BackingField;
    [CompilerGeneratedAttribute]
private SimpleListSettings <SymbolPathList>k__BackingField;
    [CompilerGeneratedAttribute]
private FilteringListSettings <CompanyNameList>k__BackingField;
    [CompilerGeneratedAttribute]
private FilteringListSettings <PublicKeyTokenList>k__BackingField;
    internal bool UseVerifiableInstrumentation { get; internal set; }
    internal bool AllowLowIntegrityProcess { get; internal set; }
    internal bool CollectChildProcess { get; internal set; }
    internal SimpleListSettings AllowedUserList { get; }
    internal SimpleListSettings SymbolPathList { get; }
    internal FilteringListSettings CompanyNameList { get; internal set; }
    internal FilteringListSettings PublicKeyTokenList { get; internal set; }
    internal DynamicCoverageAdvancedSettings(XmlElement settings);
    internal bool get_UseVerifiableInstrumentation();
    internal void set_UseVerifiableInstrumentation(bool value);
    internal bool get_AllowLowIntegrityProcess();
    internal void set_AllowLowIntegrityProcess(bool value);
    internal bool get_CollectChildProcess();
    internal void set_CollectChildProcess(bool value);
    [CompilerGeneratedAttribute]
internal SimpleListSettings get_AllowedUserList();
    [CompilerGeneratedAttribute]
internal SimpleListSettings get_SymbolPathList();
    [CompilerGeneratedAttribute]
internal FilteringListSettings get_CompanyNameList();
    [CompilerGeneratedAttribute]
internal void set_CompanyNameList(FilteringListSettings value);
    [CompilerGeneratedAttribute]
internal FilteringListSettings get_PublicKeyTokenList();
    [CompilerGeneratedAttribute]
internal void set_PublicKeyTokenList(FilteringListSettings value);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageAdvancedSettings/<ToXml>d__42")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
    internal static void LoadGeneralSettingFromXml(XmlElement settings, Dictionary`2& generalSettings, XmlDocument& ownerDoc);
    internal static T GetSetting(string settingName, Dictionary`2<string, object> generalSettings);
    internal static bool HasSetting(string settingName, Dictionary`2<string, object> generalSettings);
    internal static void UpdateSetting(string settingName, T value, Dictionary`2<string, object> generalSettings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageModuleSettings : object {
    private static string ModulePathListName;
    internal static string ModulePathElementName;
    private static string ModulePathSample;
    internal static string EntryPointListName;
    internal static string EntryPointElementName;
    internal static string EntryPointSample;
    private static string CollectAspDotNetStr;
    private Dictionary`2<string, object> _generalSettings;
    private XmlDocument _ownerDoc;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FilteringListSettings <ModulePathList>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SimpleListSettings <EntryPointList>k__BackingField;
    [NullableAttribute("2")]
internal FilteringListSettings ModulePathList { get; }
    [NullableAttribute("2")]
internal SimpleListSettings EntryPointList { get; }
    internal bool CollectAspDotNet { get; internal set; }
    internal DynamicCoverageModuleSettings(XmlElement settings, bool loadAll);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal FilteringListSettings get_ModulePathList();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SimpleListSettings get_EntryPointList();
    internal bool get_CollectAspDotNet();
    internal void set_CollectAspDotNet(bool value);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageModuleSettings/<ToXml>d__20")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageReadOnlySettings : object {
    private static String[] FunctionSig;
    private static String[] FunctionAttr;
    private static String[] Source;
    private static String[][] ListNames;
    private static List`1<NameElementPair> ReadOnlySettings;
    private static DynamicCoverageReadOnlySettings();
    internal DynamicCoverageReadOnlySettings(XmlElement settings);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.DynamicCoverageReadOnlySettings/<ToXml>d__9")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.FilteringListSettings : object {
    private static string Exclude;
    private static string Include;
    private static string EmptyRegex;
    private List`1<string> _inclusionList;
    private List`1<string> _exclusionList;
    private XmlDocument _ownerDoc;
    [CompilerGeneratedAttribute]
private string <ListName>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterType <ListType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNoneForEmptyList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SampleText>k__BackingField;
    internal string ListName { get; }
    internal FilterType ListType { get; }
    internal bool IncludeNoneForEmptyList { get; }
    internal string ElementName { get; }
    internal string SampleText { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> InclusionList { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> ExclusionList { get; }
    internal FilteringListSettings(XmlElement settings, string listName, string elementName, FilterType type, string sample, bool noneForEmptyInclude);
    [CompilerGeneratedAttribute]
internal string get_ListName();
    [CompilerGeneratedAttribute]
internal FilterType get_ListType();
    [CompilerGeneratedAttribute]
internal bool get_IncludeNoneForEmptyList();
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    [CompilerGeneratedAttribute]
internal string get_SampleText();
    internal List`1<string> get_InclusionList();
    internal List`1<string> get_ExclusionList();
    public static void VerifyFilteringSetting(XmlElement settings, string listName, string elementName, FilterType type);
    private static void VerifyFilteringItem(XmlElement parent, FilterType type);
    [MemberNotNullAttribute("_ownerDoc")]
public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.FilteringListSettings/<ToXml>d__30")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
    private IList`1<XmlNode> GetIncludedItems(XmlNode parent);
    private IList`1<XmlNode> GetExcludedItems(XmlNode parent);
    private static IList`1<XmlNode> GetFilteringItems(XmlNode parent, string filterName, string elementName);
    private void AddNodesToList(IList`1<XmlNode> nodes, IList`1<string> list);
    private XmlElement GetExcludeElement();
    private XmlElement GetIncludeElement();
    private XmlElement GetFilteringElement(bool exclude);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.IDynamicCoverageSettings {
    public abstract virtual IEnumerable`1<XmlElement> ToXml();
    public abstract virtual void LoadFromXml(XmlElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.SimpleListSettings : object {
    private XmlDocument _ownerDoc;
    [CompilerGeneratedAttribute]
private string <ListName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    internal string ListName { get; }
    internal string ElementName { get; }
    internal List`1<string> List { get; }
    internal SimpleListSettings(XmlElement settings, string listName, string elementName);
    [CompilerGeneratedAttribute]
internal string get_ListName();
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    [CompilerGeneratedAttribute]
internal List`1<string> get_List();
    [MemberNotNullAttribute("_ownerDoc")]
public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.SimpleListSettings/<ToXml>d__12")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.Utility : object {
    private static char Semicolon;
    private static char Quote;
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.Utility/<FindChildrenByName>d__2")]
internal static IEnumerable`1<XmlNode> FindChildrenByName(XmlNode parent, string name, bool verify);
    internal static bool ContainsStringIgnoreCase(IEnumerable`1<string> list, string str);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ConfigurationEditor.Utility/<FromSemicolonSeparatedString>d__4")]
internal static IEnumerable`1<string> FromSemicolonSeparatedString(string str);
    internal static string ToSemicolonSeparatedString(IEnumerable`1<string> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.DataCollectionCoverageLogger : object {
    private IDataCollectionLogger _logger;
    private DataCollectionContext _context;
    public DataCollectionCoverageLogger(IDataCollectionLogger logger, DataCollectionContext context);
    public sealed virtual void LogError(string msg);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogWarning(string msg);
    public sealed virtual void LogInfo(string msg);
    public sealed virtual void LogVerbose(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.EqtTraceLogger : object {
    public sealed virtual void LogError(string message);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogWarning(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.EqtTraceWrapper : object {
    private TraceLevel _traceLevel;
    [NullableContextAttribute("2")]
public EqtTraceWrapper(string traceLevel);
    public sealed virtual void LogError(Exception exceptionToTrace);
    public sealed virtual void LogError(string message);
    public sealed virtual void LogInfo(string message);
    public sealed virtual void LogVerbose(string message);
    public sealed virtual void LogWarning(string message);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.VanguardCollector.Interfaces.IDynamicCoverageDataCollectorImpl {
    public IVanguardProvider VanguardProvider { get; }
    public abstract virtual IVanguardProvider get_VanguardProvider();
    public abstract virtual _CollectionPlan UpdateCollectionPlanWithVanguardInfo(_CollectionPlan plan);
    [NullableContextAttribute("2")]
public abstract virtual void InitializeConfiguration(IISEnvironmentInjector iISInjector);
    public abstract virtual void SessionEnd(object sender, SessionEndEventArgs sessionEndEventArgs);
    public abstract virtual Task SessionStartAsync(object sender, SessionStartEventArgs sessionStartEventArgs);
    public abstract virtual void TestCaseStart(object sender, TestCaseStartEventArgs e);
    public abstract virtual void TestCaseEnd(object sender, TestCaseEndEventArgs e);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.VanguardCollector.Interfaces.IVanguard {
    public DataCollectorConfiguration Configuration { get; public set; }
    public int TestHostProcessId { get; public set; }
    public int NumberOfClientsConnected { get; }
    public List`1<string> EntryPoints { get; }
    public abstract virtual DataCollectorConfiguration get_Configuration();
    public abstract virtual void set_Configuration(DataCollectorConfiguration value);
    public abstract virtual int get_TestHostProcessId();
    public abstract virtual void set_TestHostProcessId(int value);
    public abstract virtual int get_NumberOfClientsConnected();
    public abstract virtual List`1<string> get_EntryPoints();
    public abstract virtual Task StartAsync(DataCollectionContext context, IEnvironment environment, IList`1<string> sources, IOutputPathGenerator outputPathGenerator);
    public abstract virtual void Stop();
    public abstract virtual IList`1<string> GetOutputCoverageFiles();
    public abstract virtual void GetCoverageData(string outputName);
    public abstract virtual void TestCaseStart(object sender, TestCaseStartEventArgs e);
    public abstract virtual void TestCaseEnd(object sender, TestCaseEndEventArgs e);
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.TraceCollector.VanguardCollector.Interfaces.IVanguardCommandBuilder {
    public abstract virtual string GenerateCommandLine(VanguardCommand vanguardCommand, string sessionName, string outputName, string configurationFilePath, string entryPoint);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.TraceCollector.VanguardCollector.Interfaces.IVanguardProvider {
    public IVanguard Vanguard { get; }
    public string SessionName { get; }
    [NullableAttribute("2")]
public string PipePath { get; }
    public string SessionDirectory { get; }
    public abstract virtual IVanguard get_Vanguard();
    public abstract virtual string get_SessionName();
    [NullableContextAttribute("2")]
public abstract virtual string get_PipePath();
    public abstract virtual string get_SessionDirectory();
    public abstract virtual void DeleteSessionDirectory();
}
public enum Microsoft.VisualStudio.TraceCollector.VanguardCollector.Interfaces.VanguardCommand : Enum {
    public int value__;
    public static VanguardCommand Collect;
    public static VanguardCommand Shutdown;
    public static VanguardCommand Register;
    public static VanguardCommand Unregister;
    public static VanguardCommand UnregisterAll;
    public static VanguardCommand GetCoverageData;
    public static VanguardCommand StartIISCollection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.ManagedVanguard : VanguardBase {
    [NullableAttribute("2")]
private string _pipePath;
    private IStaticNativeInstrumenterFactory _staticNativeInstrumenterFactory;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private ICoverageTelemetryReporter _telemetryEventsReporter;
    private IFileHelper _fileHelper;
    private IDirectoryHelper _directoryHelper;
    private ISourceRootTranslatorFactory _sourceRootTranslatorFactory;
    private IProfilersLocationProvider _profilersLocationProvider;
    [NullableAttribute("2")]
private IStaticNativeInstrumenter _staticNativeInstrumenter;
    [NullableAttribute("2")]
private LoggerBase _vanguardLogger;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<string> _outputCoverageFiles;
    public int TestHostProcessId { get; public set; }
    public int NumberOfClientsConnected { get; }
    public ManagedVanguard(string sessionName, string pipePath, string sessionDirectory, DataCollectorConfiguration configuration, IDataCollectionLogger logger, IStaticNativeInstrumenterFactory staticNativeInstrumenterFactory, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, IFileHelper fileHelper, IDirectoryHelper directoryHelper, ICoverageTelemetryReporter telemetryEventsReporter, ISourceRootTranslatorFactory sourceRootTranslatorFactory, IProfilersLocationProvider profilersLocationProvider);
    public virtual int get_TestHostProcessId();
    public virtual void set_TestHostProcessId(int value);
    public virtual int get_NumberOfClientsConnected();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.TraceCollector.VanguardCollector.ManagedVanguard/<StartAsync>d__18")]
public virtual Task StartAsync(DataCollectionContext context, IEnvironment environment, IList`1<string> sources, IOutputPathGenerator outputPathGenerator);
    public virtual void TestCaseStart(object sender, TestCaseStartEventArgs e);
    public virtual void TestCaseEnd(object sender, TestCaseEndEventArgs e);
    private bool InitializeTelemetryVanguardLogger(string outputName, IEnvironment environment, ILogger logger, IStaticNativeRuntimeProvider staticNativeRuntimeProvider, IOutputPathGenerator outputPathGenerator, ISourceRootTranslator sourceRootTranslator);
    public virtual void Stop();
    public virtual IList`1<string> GetOutputCoverageFiles();
    public virtual void GetCoverageData(string outputName);
    protected virtual void Dispose(bool disposing);
    private void DisposeDependencies();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.TraceCollector.VanguardCollector.VanguardBase : object {
    private static string SideBySideKeyOnTeamBuildMachine;
    private static string VanguardConfigFileName;
    private bool _disposed;
    private IFileHelper _fileHelper;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDataCollectionLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private DataCollectorConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestHostProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <EntryPoints>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DataCollectionContext <Context>k__BackingField;
    [NullableAttribute("2")]
public IDataCollectionLogger Logger { get; private set; }
    public string SessionName { get; private set; }
    [NullableAttribute("2")]
public string OutputName { get; protected set; }
    public string SessionDirectory { get; private set; }
    public DataCollectorConfiguration Configuration { get; public set; }
    public int TestHostProcessId { get; public set; }
    public int NumberOfClientsConnected { get; }
    public List`1<string> EntryPoints { get; }
    [NullableAttribute("2")]
protected DataCollectionContext Context { get; protected set; }
    protected VanguardBase(string sessionName, string sessionDirectory, DataCollectorConfiguration configuration, IDataCollectionLogger logger, IFileHelper fileHelper);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IDataCollectionLogger get_Logger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Logger(IDataCollectionLogger value);
    [CompilerGeneratedAttribute]
public string get_SessionName();
    [CompilerGeneratedAttribute]
private void set_SessionName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_OutputName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public string get_SessionDirectory();
    [CompilerGeneratedAttribute]
private void set_SessionDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DataCollectorConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configuration(DataCollectorConfiguration value);
    [CompilerGeneratedAttribute]
public virtual int get_TestHostProcessId();
    [CompilerGeneratedAttribute]
public virtual void set_TestHostProcessId(int value);
    public virtual int get_NumberOfClientsConnected();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_EntryPoints();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected DataCollectionContext get_Context();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected void set_Context(DataCollectionContext value);
    public abstract virtual Task StartAsync(DataCollectionContext context, IEnvironment environment, IList`1<string> sources, IOutputPathGenerator outputPathGenerator);
    public abstract virtual void TestCaseStart(object sender, TestCaseStartEventArgs e);
    public abstract virtual void TestCaseEnd(object sender, TestCaseEndEventArgs e);
    public abstract virtual void Stop();
    public abstract virtual IList`1<string> GetOutputCoverageFiles();
    public abstract virtual void GetCoverageData(string outputName);
    public sealed virtual void Dispose();
    protected string WriteConfigurationFiles();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.VanguardCommandBuilder : object {
    [NullableContextAttribute("2")]
public sealed virtual string GenerateCommandLine(VanguardCommand vanguardCommand, string sessionName, string outputName, string configurationFilePath, string entryPoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.VanguardException : Exception {
    [CompilerGeneratedAttribute]
private bool <IsCritical>k__BackingField;
    public bool IsCritical { get; }
    internal VanguardException(string message, bool isCritical);
    public VanguardException(string message);
    public VanguardException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public bool get_IsCritical();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.TraceCollector.VanguardCollector.VanguardProvider : object {
    private static string MagicMtmSessionPrefix;
    private IDirectoryHelper _directoryHelper;
    private IEnvironment _environment;
    private IStaticNativeInstrumenterFactory _staticNativeInstrumenterFactory;
    private IStaticNativeRuntimeProviderFactory _staticNativeRuntimeProviderFactory;
    private bool _disposed;
    [NullableAttribute("2")]
private IDataCollectionLogger _logger;
    private DataCollectorConfiguration _collectorConfiguration;
    private ICoverageTelemetryReporter _telemetryReporter;
    private IProfilersLocationProvider _profilersLocationProvider;
    [CompilerGeneratedAttribute]
private IVanguard <Vanguard>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PipePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionDirectory>k__BackingField;
    public IVanguard Vanguard { get; private set; }
    public string SessionName { get; private set; }
    [NullableAttribute("2")]
public string PipePath { get; private set; }
    public string SessionDirectory { get; private set; }
    public VanguardProvider(IDirectoryHelper directoryHelper, IFileHelper fileHelper, IEnvironment environment, IStaticNativeInstrumenterFactory staticNativeInstrumenterFactory, IStaticNativeRuntimeProviderFactory staticNativeRuntimeProviderFactory, DataCollectorConfiguration collectorConfiguration, IDataCollectionLogger logger, ICoverageTelemetryReporter telemetryReporter, ISourceRootTranslatorFactory sourceRootTranslatorFactory, IProfilersLocationProvider profilersLocationProvider);
    [CompilerGeneratedAttribute]
public sealed virtual IVanguard get_Vanguard();
    [CompilerGeneratedAttribute]
private void set_Vanguard(IVanguard value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionName();
    [CompilerGeneratedAttribute]
private void set_SessionName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_PipePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_PipePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionDirectory();
    [CompilerGeneratedAttribute]
private void set_SessionDirectory(string value);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void SetSessionInfo(DataCollectorConfiguration configuration);
    private static string GetSessionName();
    private IVanguard PrepareVanguard(string sessionName, string sessionDirectory, DataCollectorConfiguration configuration, IFileHelper fileHelper, ISourceRootTranslatorFactory sourceRootTranslatorFactory);
    public sealed virtual void DeleteSessionDirectory();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
