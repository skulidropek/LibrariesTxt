[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.VisualStudio.Coverage.AddItemDialog : Window {
    private Func`2<string, string> validator;
    [CompilerGeneratedAttribute]
private WpfDialogAssistant <DialogAssistant>k__BackingField;
    internal Label m_descriptionLabel;
    internal AccessText m_descriptionLabelContent;
    internal TextBox m_filterText;
    internal Label m_sampleLabel;
    internal AccessText m_sampleLabelContent;
    internal Button m_okButton;
    internal Button m_cancelButton;
    private bool _contentLoaded;
    internal WpfDialogAssistant DialogAssistant { get; private set; }
    unknown string SampleText {internal set; }
    public AddItemDialog(string title, string message, Func`2<string, string> validator);
    public AddItemDialog(IntPtr parentHandle, string title, string message, Func`2<string, string> validator);
    public AddItemDialog(Window parentWindow, string title, string message, Func`2<string, string> validator);
    [CompilerGeneratedAttribute]
internal WpfDialogAssistant get_DialogAssistant();
    [CompilerGeneratedAttribute]
private void set_DialogAssistant(WpfDialogAssistant value);
    internal void set_SampleText(string value);
    private void InitializeText(string title, string message);
    private void AddItemDialogLoaded(object sender, RoutedEventArgs e);
    private void ok_Click(object sender, RoutedEventArgs e);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class Microsoft.VisualStudio.Coverage.AdvancedSettingsControl : UserControl {
    private DynamicCoverageAdvancedSettings advancedSetting;
    internal CheckBox AllowLowIntegrityProcCheck;
    internal TextBlock AllowLowIntegrityProcTextBlock;
    internal CheckBox VerifiableInstrCheck;
    internal TextBlock VerifiableInstrTextBlock;
    internal CheckBox CollectChildCheck;
    internal TextBlock CollectChildTextBlock;
    internal CheckBox SymbolPathCheck;
    internal TextBlock SymbolPathDescriptionTextBlock;
    internal TextBox SymbolPathTextBox;
    internal CheckBox CollectFromEveryone;
    internal TextBox CompanyNamesExcludeList;
    internal TextBox PublicKeysExcludeList;
    private bool _contentLoaded;
    internal AdvancedSettingsControl(DynamicCoverageAdvancedSettings settings);
    public sealed virtual void ApplyChanges();
    public sealed virtual void ResetSettings(IDynamicCoverageSettings settings);
    public sealed virtual void UpdateUI();
    private void SymbolPathCheckChanged(object sender, RoutedEventArgs e);
    private void SelectAllText(object sender, RoutedEventArgs e);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class Microsoft.VisualStudio.Coverage.CenteredMsgBox : Window {
    private WpfDialogAssistant DialogAssistant;
    private string message;
    internal Label m_MessageLabel;
    internal Button m_okButton;
    private bool _contentLoaded;
    public CenteredMsgBox(string msg);
    public CenteredMsgBox(IntPtr parentHandle, string msg);
    public CenteredMsgBox(Window parentWindow, string msg);
    private void InitializeText();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class Microsoft.VisualStudio.Coverage.CodeCoverageDataLogger : object {
    private static UInt32 AppId;
    private static string ProvisionalSqmKey;
    private static CodeCoverageDataLogger m_codeCoverageDataLogger;
    private static int m_sessions;
    private static string m_coverageFileInfo;
    private static int m_sessionDuration;
    internal static CodeCoverageDataLogger Instance { get; }
    internal int Sessions { get; internal set; }
    internal string CoverageFileInfo { get; internal set; }
    internal int SessionDuration { get; internal set; }
    internal static void Initialize();
    internal static void LogSqmData();
    private static string GetSqmString();
    internal static CodeCoverageDataLogger get_Instance();
    internal int get_Sessions();
    internal void set_Sessions(int value);
    internal string get_CoverageFileInfo();
    internal void set_CoverageFileInfo(string value);
    internal int get_SessionDuration();
    internal void set_SessionDuration(int value);
}
internal class Microsoft.VisualStudio.Coverage.ConfigEditorLayoutManager : object {
    private FrameworkElement rootElement;
    private Panel panel;
    public Panel RootPanel { get; }
    public ConfigEditorLayoutManager(ElementHost host, FrameworkElement root);
    public Panel get_RootPanel();
    private void PanelSizeChanged(object sender, EventArgs e);
}
public class Microsoft.VisualStudio.Coverage.ConfigurationConverter2010 : object {
    public sealed virtual void Convert(Uri sourceCollectorUri, XmlElement sourceCollectorRunConfiguration, Uri targetCollectorUri, XmlElement targetCollectorDefaultConfiguration, XmlElement& targetCollectorRunConfiguration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Microsoft.VisualStudio.Coverage.ConfigurationEditorUIResource : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string Add { get; }
    public static string AddEntryPointMessage { get; }
    public static string AddEntryPointTitle { get; }
    public static string AddPattern { get; }
    public static string Advanced { get; }
    public static string Cancel { get; }
    public static string CollectFromAspNetInIIS { get; }
    public static string ComplexRegularExpression { get; }
    public static string EnterPattern { get; }
    public static string EntryPoint { get; }
    public static string Error { get; }
    public static string InvalidCompanyName { get; }
    public static string InvalidConfig { get; }
    public static string InvalidEntryPoint { get; }
    public static string InvalidPublicKey { get; }
    public static string InvalidRegexConfig { get; }
    public static string InvalidSettingType { get; }
    public static string InvalidSymbolPath { get; }
    public static string Module { get; }
    public static string OK { get; }
    public static string OtherModule { get; }
    public static string OutputModule { get; }
    public static string Remove { get; }
    public static string Sample { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_Add();
    public static string get_AddEntryPointMessage();
    public static string get_AddEntryPointTitle();
    public static string get_AddPattern();
    public static string get_Advanced();
    public static string get_Cancel();
    public static string get_CollectFromAspNetInIIS();
    public static string get_ComplexRegularExpression();
    public static string get_EnterPattern();
    public static string get_EntryPoint();
    public static string get_Error();
    public static string get_InvalidCompanyName();
    public static string get_InvalidConfig();
    public static string get_InvalidEntryPoint();
    public static string get_InvalidPublicKey();
    public static string get_InvalidRegexConfig();
    public static string get_InvalidSettingType();
    public static string get_InvalidSymbolPath();
    public static string get_Module();
    public static string get_OK();
    public static string get_OtherModule();
    public static string get_OutputModule();
    public static string get_Remove();
    public static string get_Sample();
}
internal class Microsoft.VisualStudio.Coverage.DynamicCoverageAdvancedSettings : object {
    private Dictionary`2<string, object> generalSettings;
    private XmlDocument ownerDoc;
    private static string CollectAspDotNetStr;
    private static string CollectChildProcessStr;
    private static string UseVerifiableInstrumentationStr;
    private static string AllowLowIntegrityProcessStr;
    private static string ExcludeCompilerAutoGeneratedModulesStr;
    internal static string AllowedUserListName;
    internal static string AllowedUserElementName;
    internal static string Everyone;
    private static string SymbolPathListName;
    private static string SymbolPathElementName;
    private static string CompanyNameListName;
    private static string CompanyNameElementName;
    private static string CompanyNameSample;
    private static string PublicKeyTokenListName;
    private static string PublicKeyTokenElementName;
    private static string PublickeyTokenSample;
    [CompilerGeneratedAttribute]
private SimpleListSettings <AllowedUserList>k__BackingField;
    [CompilerGeneratedAttribute]
private SimpleListSettings <SymbolPathList>k__BackingField;
    [CompilerGeneratedAttribute]
private FilteringListSettings <CompanyNameList>k__BackingField;
    [CompilerGeneratedAttribute]
private FilteringListSettings <PublicKeyTokenList>k__BackingField;
    internal bool UseVerifiableInstrumentation { get; internal set; }
    internal bool AllowLowIntegrityProcess { get; internal set; }
    internal bool CollectChildProcess { get; internal set; }
    internal SimpleListSettings AllowedUserList { get; private set; }
    internal SimpleListSettings SymbolPathList { get; private set; }
    internal FilteringListSettings CompanyNameList { get; internal set; }
    internal FilteringListSettings PublicKeyTokenList { get; internal set; }
    internal DynamicCoverageAdvancedSettings(XmlElement settings);
    internal bool get_UseVerifiableInstrumentation();
    internal void set_UseVerifiableInstrumentation(bool value);
    internal bool get_AllowLowIntegrityProcess();
    internal void set_AllowLowIntegrityProcess(bool value);
    internal bool get_CollectChildProcess();
    internal void set_CollectChildProcess(bool value);
    [CompilerGeneratedAttribute]
internal SimpleListSettings get_AllowedUserList();
    [CompilerGeneratedAttribute]
private void set_AllowedUserList(SimpleListSettings value);
    [CompilerGeneratedAttribute]
internal SimpleListSettings get_SymbolPathList();
    [CompilerGeneratedAttribute]
private void set_SymbolPathList(SimpleListSettings value);
    [CompilerGeneratedAttribute]
internal FilteringListSettings get_CompanyNameList();
    [CompilerGeneratedAttribute]
internal void set_CompanyNameList(FilteringListSettings value);
    [CompilerGeneratedAttribute]
internal FilteringListSettings get_PublicKeyTokenList();
    [CompilerGeneratedAttribute]
internal void set_PublicKeyTokenList(FilteringListSettings value);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.DynamicCoverageAdvancedSettings/<ToXml>d__45")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
    internal static void LoadGeneralSettingFromXml(XmlElement settings, Dictionary`2& generalSettings, XmlDocument& ownerDoc);
    internal static T GetSetting(string settingName, Dictionary`2<string, object> generalSettings);
    internal static bool HasSetting(string settingName, Dictionary`2<string, object> generalSettings);
    internal static void UpdateSetting(string settingName, T value, Dictionary`2<string, object> generalSettings);
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/CodeCoverage/2.0")]
[DataCollectorFriendlyNameAttribute("CodeCoverageCollectorFriendlyName", "True")]
[DataCollectorConfigurationEditorAttribute("configurationeditor://Microsoft/CodeCoverageEditor/2.0")]
[DataCollectorRequiresOutOfProcessCollectionAttribute]
[DataCollectorDescriptionAttribute("CodeCoverageCollectorDescription", "True")]
[DataCollectorTestClientRestrictionAttribute]
public class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollector : CommonDataCollector {
    private DynamicCoverageDataCollectorImpl implementation;
    private bool testcaseEventsUnsubscribed;
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    internal virtual _CollectionPlan BeforeSecondCollectorInitialize(_CollectionPlan plan);
    private void Initialize(XmlElement configurationElement, _CollectionPlan plan, bool isFirstCollectorToInitialize);
    protected virtual void Dispose(bool disposing);
    private void SessionEnd(object sender, SessionEndEventArgs e);
    private void SessionStart(object sender, SessionStartEventArgs e);
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
}
internal abstract class Microsoft.VisualStudio.Coverage.DynamicCoverageDataCollectorImpl : object {
    private static string VanguardConfigFileName;
    private static string CoverageFileSettingName;
    public static string MagicMtmSessionPrefix;
    private string coverageFileName;
    private Vanguard vanguard;
    private IDataCollectionLogger logger;
    private IDataCollectionSink dataSink;
    private IISEnvironmentInjector injector;
    private bool isManualTest;
    private bool isExecutedRemotely;
    private bool onlyVanguardCollectorEnabledForRemoteRole;
    private bool collectionPlanPopulated;
    protected bool collectAspDotNet;
    private string tempPath;
    private string sessionName;
    private XmlElement configurationElement;
    protected Vanguard Vanguard { get; }
    internal bool OnlyVanguardEnabledForRemoteRole { get; }
    internal bool CollectAspDotNet { get; }
    public DynamicCoverageDataCollectorImpl(bool isManualTest, bool isExecutedRemotely);
    protected Vanguard get_Vanguard();
    internal bool get_OnlyVanguardEnabledForRemoteRole();
    internal bool get_CollectAspDotNet();
    public static DynamicCoverageDataCollectorImpl Create(IDataCollectionAgentContext context);
    protected void StartVanguard(DataCollectionContext context);
    protected void StopVanguard(DataCollectionContext context);
    protected void GetCoverageData(DataCollectionContext context);
    protected void OnSendFileCompletedEvent(object sender, AsyncCompletedEventArgs e);
    internal virtual void SessionStart(object sender, SessionStartEventArgs e);
    internal virtual void SessionEnd(object sender, SessionEndEventArgs e);
    public virtual void Initialize(XmlElement configurationElement, _CollectionPlan plan, IDataCollectionSink dataSink, IDataCollectionLogger logger, bool isFirstCollectorToInitalize);
    internal _CollectionPlan UpdateCollectionPlanWithVanguardInfo(_CollectionPlan plan);
    internal void PrepareForIISCollection();
    internal void InitializeBeforeSessionStart();
    private bool CreateSessionDirectory();
    private static string GenerateCoverageFileName();
    private void PrepareVanguardProcess();
    internal virtual void InitializeConfiguration(IISEnvironmentInjector injector);
    private void PopulateCollectionPlan(_CollectionPlan plan, string sessionName, bool collectAspDotNet);
    public virtual void Dispose();
    private void CleanupDirectory();
}
[DataCollectorConfigurationEditorTypeUriAttribute("configurationeditor://Microsoft/CodeCoverageEditor/2.0")]
public class Microsoft.VisualStudio.Coverage.DynamicCoverageEditorPage : UserControl {
    private ConfigEditorLayoutManager layoutManager;
    private XmlDocument ownerDoc;
    private Dictionary`2<IDynamicCoverageSettings, IDynamicCoverageSettingsControl> settingControls;
    private DataCollectorSettings dataCollectorSetting;
    internal static string RootName;
    private static string Configuration;
    private IContainer components;
    public sealed virtual void Initialize(IServiceProvider serviceProvider, DataCollectorSettings settings);
    public sealed virtual void ResetToAgentDefaults();
    public sealed virtual DataCollectorSettings SaveData();
    public sealed virtual bool VerifyData();
    private void InitializeSettings(bool useDefault);
    protected virtual void Dispose(bool disposing);
    private void InitializeComponent();
}
internal class Microsoft.VisualStudio.Coverage.DynamicCoverageModuleSettings : object {
    private Dictionary`2<string, object> generalSettings;
    private XmlDocument ownerDoc;
    private static string ModulePathListName;
    internal static string ModulePathElementName;
    private static string ModulePathSample;
    internal static string EntryPointListName;
    internal static string EntryPointElementName;
    internal static string EntryPointSample;
    private static string CollectAspDotNetStr;
    [CompilerGeneratedAttribute]
private FilteringListSettings <ModulePathList>k__BackingField;
    [CompilerGeneratedAttribute]
private SimpleListSettings <EntryPointList>k__BackingField;
    internal FilteringListSettings ModulePathList { get; private set; }
    internal SimpleListSettings EntryPointList { get; private set; }
    internal bool CollectAspDotNet { get; internal set; }
    internal DynamicCoverageModuleSettings(XmlElement settings, bool loadAll);
    [CompilerGeneratedAttribute]
internal FilteringListSettings get_ModulePathList();
    [CompilerGeneratedAttribute]
private void set_ModulePathList(FilteringListSettings value);
    [CompilerGeneratedAttribute]
internal SimpleListSettings get_EntryPointList();
    [CompilerGeneratedAttribute]
private void set_EntryPointList(SimpleListSettings value);
    internal bool get_CollectAspDotNet();
    internal void set_CollectAspDotNet(bool value);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.DynamicCoverageModuleSettings/<ToXml>d__22")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
internal class Microsoft.VisualStudio.Coverage.DynamicCoverageReadOnlySettings : object {
    private static String[] FunctionSig;
    private static String[] FunctionAttr;
    private static String[] Source;
    private static String[] Company;
    private static String[] ModulePKT;
    private static String[][] ListNames;
    private static List`1<NameElementPair> readOnlySettings;
    private static DynamicCoverageReadOnlySettings();
    internal DynamicCoverageReadOnlySettings(XmlElement settings);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.DynamicCoverageReadOnlySettings/<ToXml>d__11")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
internal class Microsoft.VisualStudio.Coverage.DynamicCoverageSettingsControlFactory : object {
    private static Dictionary`2<Type, IDynamicCoverageSettingsControlFactory> factories;
    private static DynamicCoverageSettingsControlFactory();
    internal static IDynamicCoverageSettingsControl CreateControl(IDynamicCoverageSettings settings);
    internal static string GetTabHeader(IDynamicCoverageSettings settings);
}
internal class Microsoft.VisualStudio.Coverage.ExecutionCallBack : MarshalByRefObject {
    [CompilerGeneratedAttribute]
private string <DeploymentCallBackPortName>k__BackingField;
    private ExecutionDataReceived dataHandler;
    private ProcessExited processExitHandler;
    public string DeploymentCallBackPortName { get; public set; }
    internal ExecutionCallBack(ExecutionDataReceived dataHandler, ProcessExited processExitHandler);
    public virtual object InitializeLifetimeService();
    public sealed virtual void ExecutionDataReceived(string data, bool error, long deploymentTaskId);
    public sealed virtual void UpdateDeploymentTaskStatus(long deploymentTaskId, DeploymentTaskStatus newStatus);
    [CompilerGeneratedAttribute]
public string get_DeploymentCallBackPortName();
    [CompilerGeneratedAttribute]
public void set_DeploymentCallBackPortName(string value);
}
internal class Microsoft.VisualStudio.Coverage.ExecutionDataReceived : MulticastDelegate {
    public ExecutionDataReceived(object object, IntPtr method);
    public virtual void Invoke(string data, bool error);
    public virtual IAsyncResult BeginInvoke(string data, bool error, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Coverage.FilteringListSettings : object {
    private List`1<string> inclusionList;
    private List`1<string> exclusionList;
    private XmlDocument ownerDoc;
    private static string Exclude;
    private static string Include;
    private static string EmptyRegex;
    [CompilerGeneratedAttribute]
private string <ListName>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterType <ListType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNoneForEmptyList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SampleText>k__BackingField;
    internal string ListName { get; private set; }
    internal FilterType ListType { get; private set; }
    internal bool IncludeNoneForEmptyList { get; private set; }
    internal string ElementName { get; private set; }
    internal string SampleText { get; private set; }
    internal List`1<string> InclusionList { get; }
    internal List`1<string> ExclusionList { get; }
    internal FilteringListSettings(XmlElement settings, string listName, string elementName, FilterType type, string sample, bool noneForEmptyInclude);
    [CompilerGeneratedAttribute]
private void set_ListName(string value);
    [CompilerGeneratedAttribute]
internal string get_ListName();
    [CompilerGeneratedAttribute]
private void set_ListType(FilterType value);
    [CompilerGeneratedAttribute]
internal FilterType get_ListType();
    [CompilerGeneratedAttribute]
private void set_IncludeNoneForEmptyList(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeNoneForEmptyList();
    [CompilerGeneratedAttribute]
private void set_ElementName(string value);
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    [CompilerGeneratedAttribute]
private void set_SampleText(string value);
    [CompilerGeneratedAttribute]
internal string get_SampleText();
    internal List`1<string> get_InclusionList();
    internal List`1<string> get_ExclusionList();
    public static void VerifyFilteringSetting(XmlElement settings, string listName, string elementName, FilterType type);
    private static void VerifyFilteringItem(XmlElement parent, FilterType type);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.FilteringListSettings/<ToXml>d__35")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
    private IList`1<XmlNode> GetIncludedItems(XmlNode parent);
    private IList`1<XmlNode> GetExcludedItems(XmlNode parent);
    private static IList`1<XmlNode> GetFilteringItems(XmlNode parent, string filterName, string elementName);
    private void AddNodesToList(IList`1<XmlNode> nodes, IList`1<string> list);
    private XmlElement GetExcludeElement();
    private XmlElement GetIncludeElement();
    private XmlElement GetFilteringElement(bool exclude);
}
internal interface Microsoft.VisualStudio.Coverage.IDynamicCoverageSettings {
    public abstract virtual IEnumerable`1<XmlElement> ToXml();
    public abstract virtual void LoadFromXml(XmlElement element);
}
internal interface Microsoft.VisualStudio.Coverage.IDynamicCoverageSettingsControl {
    public abstract virtual void ApplyChanges();
    public abstract virtual void ResetSettings(IDynamicCoverageSettings settings);
    public abstract virtual void UpdateUI();
}
internal class Microsoft.VisualStudio.Coverage.LabAgentTaskExecutor : object {
    private object lockNode;
    private IDeploymentTaskExecution labAgentExecution;
    private ExecutionCallBack callBack;
    private IpcChannel executionCallBackChannel;
    private ExecutionDataReceived dataHandler;
    private ManualResetEvent taskCompletedEvent;
    private VanguardExecutionTask currentTask;
    private long lastTaskId;
    private IDeploymentTaskExecution LabAgentDeploymentExection { get; }
    public LabAgentTaskExecutor(ExecutionDataReceived dataHandler);
    public DeploymentTaskStatus ExecuteCommand(string command, string arguments, bool wait, Action`1<DeploymentTaskStatus> completionHandler);
    private long GenerateDeloymentTaskId();
    public sealed virtual void Dispose();
    private void ExitHandler(long deploymentTaskId, DeploymentTaskStatus status);
    private DeploymentTaskStatus ExecuteDeploymentTask(VanguardExecutionTask vanguardTask, bool wait);
    private void CreateLabAgentChannel();
    private IDeploymentTaskExecution get_LabAgentDeploymentExection();
}
internal class Microsoft.VisualStudio.Coverage.ModuleInclusionControl : UserControl {
    private DynamicCoverageModuleSettings moduleSetting;
    private Dictionary`2<string, CheckBox> projectOutputs;
    private List`1<string> otherBinaries;
    private static string pathRegexPrefix;
    private static string everything;
    private static String[] unsupportedFileTypes;
    internal Grid grid;
    internal Label outputModLabel;
    internal AccessText outputModLabelContent;
    internal ListView outputModuleListView;
    internal Label entryPointLabel;
    internal AccessText entryPointLabelContent;
    internal TextBox entryPointTextBox;
    internal CheckBox collectFromIISCheckBox;
    internal AccessText collectFromIISCheckBoxContent;
    internal Label otherModLabel;
    internal AccessText otherModLabelContent;
    internal ListView otherModuleListView;
    internal Button addOtherModuleButton;
    internal Button removeOtherModuleButton;
    private bool _contentLoaded;
    internal ModuleInclusionControl(DynamicCoverageModuleSettings settings);
    private static ModuleInclusionControl();
    public sealed virtual void ApplyChanges();
    public sealed virtual void ResetSettings(IDynamicCoverageSettings settings);
    public sealed virtual void UpdateUI();
    private void InitializeText();
    private void OutputModuleListViewSelectionChanged(object sender, SelectionChangedEventArgs e);
    private void OtherModuleListViewSelectionChanged(object sender, SelectionChangedEventArgs e);
    private void AddOtherModuleButtonClick(object sender, RoutedEventArgs e);
    private string GetInput(string title, string message, string sampleText, Func`2<string, string> validator);
    private void RemoveOtherModuleButtonClick(object sender, RoutedEventArgs e);
    private void RemoveButtonClick(ListView control, List`1<string> storage);
    private static string GetFileName(string input);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class Microsoft.VisualStudio.Coverage.NativeMethods : object {
    internal static int DLGC_WANTCHARS;
    internal static int WM_GETDLGCODE;
    public static int WS_MINIMIZEBOX;
    public static int WS_MAXIMIZEBOX;
    public static int WS_BORDER;
    public static int GWL_STYLE;
    public static int GWL_EXSTYLE;
    public static int WS_EX_DLGMODALFRAME;
    public static int WS_EX_CONTROLPARENT;
    public static int WS_POPUP;
    public static int WS_CHILD;
    public static int WM_SETICON;
    public static int ICON_BIG;
    public static int ICON_SMALL;
    internal static void OnSourceChanged(object sender, SourceChangedEventArgs e);
    private static IntPtr ChildHwndSourceHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public static bool GetWindowRect(IntPtr hwnd, RECT& rect);
    public static int GetWindowLong(IntPtr hWnd, int nIndex);
    public static int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    public static IntPtr GetParent(IntPtr window);
    public static IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
}
internal class Microsoft.VisualStudio.Coverage.ProcessExited : MulticastDelegate {
    public ProcessExited(object object, IntPtr method);
    public virtual void Invoke(long deploymentTaskId, DeploymentTaskStatus status);
    public virtual IAsyncResult BeginInvoke(long deploymentTaskId, DeploymentTaskStatus status, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Microsoft.VisualStudio.Coverage.ProjectHelper : object {
    private static IServiceProvider serviceProvider;
    private static int comCallRetryLimit;
    private static UInt32 comCallRejectedErrorCode;
    private static int comRetrySleepTime;
    private static string OutputFileNameStr;
    private static DTE dte;
    internal static DTE Dte { get; }
    internal static bool IsRunningInVS { get; }
    public static void Initialize(IServiceProvider srvProvider);
    internal static DTE get_Dte();
    internal static bool get_IsRunningInVS();
    private static void GetSolution(Solution& solution);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.ProjectHelper/<GetProjectOutputsFromCurrentSolution>d__13")]
public static IEnumerable`1<string> GetProjectOutputsFromCurrentSolution();
    private static IEnumerable`1<string> GetProjectOutputsFromSolution(Solution solution);
    private static void GetRealProjectsFromSolution(Solution solution, Action`1<Project> callback);
    private static void GetSubProjects(Project parentProject, Action`1<Project> callback);
    private static bool IsReallyProject(Project projectToEvaluate);
    private static bool GetProjectOutputFileName(Project project, String& fileName);
    private static string GetVCPrimaryOutput(Project project);
    private static void GetProjectProperties(Project project, Properties& properties);
    private static void GetProjectPropertyItem(Properties properties, string item, Property& property);
    private static object GetProjectPropertyValue(Property property);
    private static void Retry(Subroutine retryDelegate);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Coverage.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CodeCoverageCollectorDescription { get; }
    internal static string CodeCoverageCollectorFriendlyName { get; }
    internal static string ErrorLaunchVanguard { get; }
    internal static string ErrorNoEntryPoint { get; }
    internal static string ErrorNoVanguard { get; }
    internal static string ErrorRegisterExecutable { get; }
    internal static string GeneralErrorLaunchVanguard { get; }
    internal static string LabAgentTaskExecutionFailed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CodeCoverageCollectorDescription();
    internal static string get_CodeCoverageCollectorFriendlyName();
    internal static string get_ErrorLaunchVanguard();
    internal static string get_ErrorNoEntryPoint();
    internal static string get_ErrorNoVanguard();
    internal static string get_ErrorRegisterExecutable();
    internal static string get_GeneralErrorLaunchVanguard();
    internal static string get_LabAgentTaskExecutionFailed();
}
internal class Microsoft.VisualStudio.Coverage.SimpleListSettings : object {
    private XmlDocument ownerDoc;
    [CompilerGeneratedAttribute]
private string <ListName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <List>k__BackingField;
    internal string ListName { get; private set; }
    internal string ElementName { get; private set; }
    internal List`1<string> List { get; private set; }
    internal SimpleListSettings(XmlElement settings, string listName, string elementName);
    [CompilerGeneratedAttribute]
private void set_ListName(string value);
    [CompilerGeneratedAttribute]
internal string get_ListName();
    [CompilerGeneratedAttribute]
private void set_ElementName(string value);
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    [CompilerGeneratedAttribute]
internal List`1<string> get_List();
    [CompilerGeneratedAttribute]
private void set_List(List`1<string> value);
    public sealed virtual void LoadFromXml(XmlElement settings);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.SimpleListSettings/<ToXml>d__15")]
public sealed virtual IEnumerable`1<XmlElement> ToXml();
}
internal class Microsoft.VisualStudio.Coverage.StandaloneVanguard : Vanguard {
    private static string IISResetFileName;
    private LabAgentTaskExecutor taskExecutor;
    private static string IISWorkerProcessName;
    private bool collectAspDotNet;
    private ManualResetEvent loggerExitedEvent;
    public StandaloneVanguard(string sessionName, string configurationFileName, XmlElement configuration, IEnumerable`1<string> entryPoints, IDataCollectionLogger logger, bool collectAspDotNet);
    public virtual void Start(string outputName, DataCollectionContext context);
    public virtual void Stop();
    public virtual void Register(string entryPoint, string configFileName);
    public virtual void Unregister(string entryPoint);
    public virtual void UnregisterAll();
    public void ShutdownIIS();
    public virtual void Dispose();
    private void StartVanguardProcessElevated(string commandLine, bool wait, Action`1<DeploymentTaskStatus> completionHandler);
    private void StartProcessElevated(string fileName, string arguments, bool wait, Action`1<DeploymentTaskStatus> completionHandler);
    private void ProcessDataHandler(string data, bool error);
    private void WaitForSessionStart();
    [CompilerGeneratedAttribute]
private void <Start>b__1_0(DeploymentTaskStatus x);
}
internal class Microsoft.VisualStudio.Coverage.UnitTestDataCollector : DynamicCoverageDataCollectorImpl {
    private object m_lock;
    private List`1<SessionId> activeIISSessions;
    private int maxNumberOfSessions;
    private DateTime firstSessionStart;
    public UnitTestDataCollector(bool isManualTest, bool isExecutedRemotely);
    internal virtual void SessionStart(object sender, SessionStartEventArgs e);
    internal virtual void SessionEnd(object sender, SessionEndEventArgs e);
}
internal static class Microsoft.VisualStudio.Coverage.Utility : object {
    private static char semicolon;
    private static char quote;
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.Utility/<FindChildrenByName>d__2")]
internal static IEnumerable`1<XmlNode> FindChildrenByName(XmlNode parent, string name, bool verify);
    internal static bool ContainsStringIgnoreCase(IEnumerable`1<string> list, string str);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Coverage.Utility/<FromSemicolonSeparatedString>d__4")]
internal static IEnumerable`1<string> FromSemicolonSeparatedString(string str);
    internal static string ToSemicolonSeparatedString(IEnumerable`1<string> list);
}
internal class Microsoft.VisualStudio.Coverage.Vanguard : object {
    private static UInt32 WAIT_LIMIT;
    private static UInt32 WAIT_OBJECT_0;
    private static int PROCESS_EXIT_WAIT_LIMIT;
    private static string VanguardPath;
    public static string SideBySideKeyOnTeamBuildMachine;
    private static string AllowedUsersKey;
    private static string AllowedUsersItemKey;
    private ManualResetEvent vanguardProcessExitEvent;
    private Process vanguardProcess;
    protected string sessionName;
    protected string configurationFileName;
    protected XmlElement configuration;
    protected string outputName;
    protected List`1<string> entryPoints;
    protected ProcessJobObject jobObject;
    protected IDataCollectionLogger logger;
    protected DataCollectionContext context;
    protected static string globalEventNamePrefix;
    public string OutputName { get; }
    public List`1<string> EntryPoints { get; }
    public bool IsRunning { get; }
    public Vanguard(string sessionName, string configurationFileName, XmlElement configuration, IEnumerable`1<string> entryPoints, IDataCollectionLogger logger);
    public Vanguard(string sessionName, string configurationFileName, XmlElement configuration, IEnumerable`1<string> entryPoints);
    private static IntPtr CreateEvent(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, string lpName);
    private static UInt32 WaitForMultipleObjects(UInt32 nCount, IntPtr[] lpHandles, bool bWaitAll, UInt32 dwMilliseconds);
    private static UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
    private static bool CloseHandle(IntPtr hObject);
    public string get_OutputName();
    public List`1<string> get_EntryPoints();
    public bool get_IsRunning();
    public void InitializeConfiguration(IEnumerable`1<SecurityIdentifier> allowedUsers);
    public virtual void Start(string outputName, DataCollectionContext context);
    private void Wait();
    protected void WaitForEvent(string eventName);
    public virtual void Stop();
    public void GetCoverageData(string outputName);
    protected Process StartVanguardProcess(string commandLine, bool wait, bool standardErrorAsynchronousCall);
    private void LoggerProcessExited(object sender, EventArgs e);
    private void LoggerProcessErrorDataReceived(object sender, DataReceivedEventArgs e);
    private void CreateProcessJobObject();
    protected static string GenerateCommandLine(Command command, string sessionName, string outputName, string configurationFileName, string entryPoint);
    protected static string GetVanguardPath();
    public static string GetVSInstallPath();
    private static string GetToolsPathForRascal();
    public static void AddAllowedUser(XmlElement config, IEnumerable`1<SecurityIdentifier> users);
    public virtual void Register(string entryPoint, string configFileName);
    public virtual void Unregister(string entryPoint);
    public virtual void UnregisterAll();
    public virtual void Dispose();
}
internal class Microsoft.VisualStudio.Coverage.VanguardException : Exception {
    [CompilerGeneratedAttribute]
private bool <IsCritical>k__BackingField;
    public bool IsCritical { get; private set; }
    internal VanguardException(string message, bool isCritical);
    [CompilerGeneratedAttribute]
public bool get_IsCritical();
    [CompilerGeneratedAttribute]
private void set_IsCritical(bool value);
}
internal class Microsoft.VisualStudio.Coverage.VanguardExecutionTask : object {
    [CompilerGeneratedAttribute]
private DeploymentTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<DeploymentTaskStatus> <OnTaskComplete>k__BackingField;
    public DeploymentTask Task { get; public set; }
    public Action`1<DeploymentTaskStatus> OnTaskComplete { get; public set; }
    public VanguardExecutionTask(DeploymentTask task, Action`1<DeploymentTaskStatus> taskCompletionHandler);
    [CompilerGeneratedAttribute]
public DeploymentTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(DeploymentTask value);
    [CompilerGeneratedAttribute]
public Action`1<DeploymentTaskStatus> get_OnTaskComplete();
    [CompilerGeneratedAttribute]
public void set_OnTaskComplete(Action`1<DeploymentTaskStatus> value);
}
internal static class Microsoft.VisualStudio.Coverage.WildcardExpressionHelper : object {
    private static bool IsSpecialCharacter(char c);
    public static string AssemblyPathToModuleRegex(string assemblyPath);
    public static string ToRegex(string expression);
    public static string FromRegex(string regex);
}
internal class Microsoft.VisualStudio.Coverage.WpfDialogAssistant : object {
    private Window window;
    private HwndSource hwndSource;
    private WindowInteropHelper interopHelper;
    private static string vsbrushname;
    public bool ShowInTaskbar { get; public set; }
    private IntPtr Handle { get; }
    private HwndSource HandleSource { get; }
    public WpfDialogAssistant(Window window);
    public bool get_ShowInTaskbar();
    public void set_ShowInTaskbar(bool value);
    public void SetOwner(Window owner);
    public void SetOwner(IntPtr hwnd);
    public void SetOwner(Form form);
    public void SetOwner(IWin32Window win32Window);
    private IntPtr GetProperOwnerWindow(IntPtr owner);
    private IntPtr get_Handle();
    private HwndSource get_HandleSource();
    private void InitializeWindowStyle();
    private void InitializeWindowPosition();
    private void SetWindowColor();
    private void Window_SourceInitialized(object sender, EventArgs e);
}
[CoClassAttribute("Microsoft.VisualStudio.TestImpact.Analysis.DiaSourceClass")]
[GuidAttribute("79F1BB5F-B66E-48E5-B6A9-1545C323CA3D")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.DiaSource {
}
[ClassInterfaceAttribute("0")]
[GuidAttribute("E6756135-1E65-4D17-8576-610761398C3C")]
[TypeLibTypeAttribute("2")]
internal class Microsoft.VisualStudio.TestImpact.Analysis.DiaSourceClass : object {
}
internal class Microsoft.VisualStudio.TestImpact.Analysis.DiaSourceObjectClass : object {
    private static IntPtr LoadLibraryEx(string lpFileName, IntPtr hReservedNull, int dwFlags);
    public static IDiaDataSource GetDiaSourceObject();
    internal static object DllGetClassObject(Guid rclsid, Guid riid);
}
internal static class Microsoft.VisualStudio.TestImpact.Analysis.Guids : object {
    internal static Guid CLSID_DiaSource;
    private static Guids();
}
internal static class Microsoft.VisualStudio.TestImpact.Analysis.HResult : object {
    public static bool Failed(int hr);
    public static bool Succeeded(int hr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("79F1BB5F-B66E-48E5-B6A9-1545C323CA3D")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaDataSource {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int LoadDataForExe(string executable, string searchPath, IntPtr callback);
    public abstract virtual int stub5();
    public abstract virtual int OpenSession(IDiaSession& session);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("D5612573-6925-4468-8883-98CDEC8C384A")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaEnumInjectedSources {
    public abstract virtual int stub1();
    public abstract virtual int GetCount(UInt32& count);
    public abstract virtual int GetItem(UInt32 index, IDiaInjectedSource& source);
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("FE30E878-54AC-44f1-81BA-39DE940F6052")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaEnumLineNumbers {
    public abstract virtual int stub1();
    public abstract virtual int GetCount(UInt32& count);
    public abstract virtual int GetItem(UInt32 index, IDiaLineNumber& line);
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("AE605CDC-8105-4a23-B710-3259F1E26112")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaInjectedSource {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int GetSource(UInt32 cbData, UInt32& pcbData, Byte* pbData);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B388EB14-BE4D-421d-A8A1-6CF7AB057086")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaLineNumber {
    public abstract virtual int stub1();
    public abstract virtual int GetSourceFile(IDiaSourceFile& file);
    public abstract virtual int GetLineNumber(UInt32& line);
    public abstract virtual int stub4();
    public abstract virtual int GetColumnNumber(UInt32& line);
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int stub14();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2F609EE1-D1C8-4E24-8288-3326BADCD211")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaSession {
    public abstract virtual int stub1();
    public abstract virtual int stub2();
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int stub9();
    public abstract virtual int stub10();
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int FindSymbolByToken(UInt32 token, SymTagEnum tag, IDiaSymbol& symbol);
    public abstract virtual int stub15();
    public abstract virtual int stub16();
    public abstract virtual int stub17();
    public abstract virtual int stub18();
    public abstract virtual int stub19();
    public abstract virtual int stub20();
    public abstract virtual int stub21();
    public abstract virtual int FindLinesByAddress(UInt32 section, UInt32 offset, UInt32 length, IDiaEnumLineNumbers& enumerator);
    public abstract virtual int stub23();
    public abstract virtual int stub24();
    public abstract virtual int stub25();
    public abstract virtual int FindInjectedSource(string file, IDiaEnumInjectedSources& injectedSources);
    public abstract virtual int stub27();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaSourceFile {
    public abstract virtual int stub1();
    public abstract virtual int GetFilename(String& filename);
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("cb787b2f-bd6c-4635-ba52-933126bd2dcd")]
internal interface Microsoft.VisualStudio.TestImpact.Analysis.IDiaSymbol {
    public abstract virtual int stub1();
    public abstract virtual int GetSymTag(SymTagEnum& tag);
    public abstract virtual int stub3();
    public abstract virtual int stub4();
    public abstract virtual int stub5();
    public abstract virtual int stub6();
    public abstract virtual int stub7();
    public abstract virtual int stub8();
    public abstract virtual int GetAddressSection(UInt32& section);
    public abstract virtual int GetAddressOffset(UInt32& offset);
    public abstract virtual int stub11();
    public abstract virtual int stub12();
    public abstract virtual int stub13();
    public abstract virtual int stub14();
    public abstract virtual int GetLength(Int64& length);
    public abstract virtual int stub16();
    public abstract virtual int stub17();
    public abstract virtual int stub18();
    public abstract virtual int stub19();
    public abstract virtual int stub20();
    public abstract virtual int stub21();
    public abstract virtual int stub22();
    public abstract virtual int stub23();
    public abstract virtual int stub24();
    public abstract virtual int stub25();
    public abstract virtual int stub26();
    public abstract virtual int stub27();
    public abstract virtual int stub28();
    public abstract virtual int stub29();
    public abstract virtual int stub30();
    public abstract virtual int stub31();
    public abstract virtual int stub32();
    public abstract virtual int stub33();
    public abstract virtual int stub34();
    public abstract virtual int stub35();
    public abstract virtual int stub36();
    public abstract virtual int stub37();
    public abstract virtual int stub38();
    public abstract virtual int stub39();
    public abstract virtual int stub40();
    public abstract virtual int stub41();
    public abstract virtual int stub42();
    public abstract virtual int stub43();
    public abstract virtual int stub44();
    public abstract virtual int stub45();
    public abstract virtual int stub46();
    public abstract virtual int stub47();
    public abstract virtual int stub48();
    public abstract virtual int stub49();
    public abstract virtual int stub50();
    public abstract virtual int stub51();
    public abstract virtual int stub52();
    public abstract virtual int stub53();
    public abstract virtual int stub54();
    public abstract virtual int stub55();
    public abstract virtual int stub56();
    public abstract virtual int stub57();
    public abstract virtual int stub58();
    public abstract virtual int stub59();
    public abstract virtual int stub60();
    public abstract virtual int stub61();
    public abstract virtual int stub62();
    public abstract virtual int stub63();
    public abstract virtual int stub64();
    public abstract virtual int stub65();
    public abstract virtual int stub66();
    public abstract virtual int stub67();
    public abstract virtual int stub68();
    public abstract virtual int stub69();
    public abstract virtual int stub70();
    public abstract virtual int stub71();
    public abstract virtual int stub72();
    public abstract virtual int stub73();
    public abstract virtual int stub74();
    public abstract virtual int stub75();
    public abstract virtual int stub76();
    public abstract virtual int stub77();
    public abstract virtual int stub78();
    public abstract virtual int stub79();
    public abstract virtual int stub80();
    public abstract virtual int stub81();
    public abstract virtual int stub82();
    public abstract virtual int stub83();
    public abstract virtual int stub84();
    public abstract virtual int stub85();
    public abstract virtual int stub86();
    public abstract virtual int stub87();
    public abstract virtual int stub88();
    public abstract virtual int stub89();
    public abstract virtual int stub90();
    public abstract virtual int stub91();
    public abstract virtual int stub92();
    public abstract virtual int stub93();
    public abstract virtual int stub94();
    public abstract virtual int stub95();
    public abstract virtual int stub96();
    public abstract virtual int stub97();
    public abstract virtual int stub98();
    public abstract virtual int stub99();
    public abstract virtual int stub100();
    public abstract virtual int stub101();
    public abstract virtual int stub102();
    public abstract virtual int stub103();
    public abstract virtual int stub104();
    public abstract virtual int stub105();
    public abstract virtual int stub106();
    public abstract virtual int stub107();
    public abstract virtual int stub108();
    public abstract virtual int stub109();
    public abstract virtual int stub110();
    public abstract virtual int stub111();
    public abstract virtual int stub112();
    public abstract virtual int stub113();
    public abstract virtual int stub114();
    public abstract virtual int stub115();
    public abstract virtual int stub116();
    public abstract virtual int stub117();
    public abstract virtual int stub118();
    public abstract virtual int stub119();
    public abstract virtual int stub120();
    public abstract virtual int stub121();
    public abstract virtual int stub122();
    public abstract virtual int stub123();
    public abstract virtual int stub124();
    public abstract virtual int stub125();
    public abstract virtual int stub126();
    public abstract virtual int stub127();
    public abstract virtual int stub128();
    public abstract virtual int stub129();
    public abstract virtual int stub130();
    public abstract virtual int stub131();
    public abstract virtual int stub132();
    public abstract virtual int stub133();
    public abstract virtual int stub134();
    public abstract virtual int stub135();
    public abstract virtual int stub136();
    public abstract virtual int stub137();
    public abstract virtual int stub138();
    public abstract virtual int stub139();
    public abstract virtual int stub140();
    public abstract virtual int stub141();
    public abstract virtual int stub142();
    public abstract virtual int stub143();
    public abstract virtual int stub144();
    public abstract virtual int stub145();
    public abstract virtual int stub146();
    public abstract virtual int stub147();
    public abstract virtual int stub148();
    public abstract virtual int stub149();
    public abstract virtual int stub150();
    public abstract virtual int stub151();
    public abstract virtual int stub152();
    public abstract virtual int stub153();
    public abstract virtual int stub154();
    public abstract virtual int stub155();
}
internal class Microsoft.VisualStudio.TestImpact.Analysis.SymbolReader : object {
    private IDiaSession _session;
    private bool _disposed;
    private static UInt32 INVALID_LINE_NUMBER;
    public SymbolReader(string filename);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public bool IsSessionNull();
    public bool GetTokenFilename(UInt32 token, String& fileName);
    private static bool GetFirstSourceFile(IDiaEnumLineNumbers lines, String& fileName);
    private void Close();
    private void CheckDisposed();
    private static IDiaSession OpenSession(string filename);
}
internal enum Microsoft.VisualStudio.TestImpact.Analysis.SymTagEnum : Enum {
    public UInt32 value__;
    public static SymTagEnum SymTagNull;
    public static SymTagEnum SymTagExe;
    public static SymTagEnum SymTagCompiland;
    public static SymTagEnum SymTagCompilandDetails;
    public static SymTagEnum SymTagCompilandEnv;
    public static SymTagEnum SymTagFunction;
    public static SymTagEnum SymTagBlock;
    public static SymTagEnum SymTagData;
    public static SymTagEnum SymTagAnnotation;
    public static SymTagEnum SymTagLabel;
    public static SymTagEnum SymTagPublicSymbol;
    public static SymTagEnum SymTagUDT;
    public static SymTagEnum SymTagEnum;
    public static SymTagEnum SymTagFunctionType;
    public static SymTagEnum SymTagPointerType;
    public static SymTagEnum SymTagArrayType;
    public static SymTagEnum SymTagBaseType;
    public static SymTagEnum SymTagTypedef;
    public static SymTagEnum SymTagBaseClass;
    public static SymTagEnum SymTagFriend;
    public static SymTagEnum SymTagFunctionArgType;
    public static SymTagEnum SymTagFuncDebugStart;
    public static SymTagEnum SymTagFuncDebugEnd;
    public static SymTagEnum SymTagUsingNamespace;
    public static SymTagEnum SymTagVTableShape;
    public static SymTagEnum SymTagVTable;
    public static SymTagEnum SymTagCustom;
    public static SymTagEnum SymTagThunk;
    public static SymTagEnum SymTagCustomType;
    public static SymTagEnum SymTagManagedType;
    public static SymTagEnum SymTagDimension;
}
public abstract class Microsoft.VisualStudio.TraceCollector.BaseDataCollector : DataCollector {
    private static List`1<BaseDataCollector> _collectors;
    [CompilerGeneratedAttribute]
private IDataCollectionEvents <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataCollectionLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataCollectionSink <DataSink>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataCollectionAgentContext <AgentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    internal IDataCollectionEvents Events { get; private set; }
    internal IDataCollectionLogger Logger { get; private set; }
    internal IDataCollectionSink DataSink { get; private set; }
    internal IDataCollectionAgentContext AgentContext { get; private set; }
    protected static ReadOnlyCollection`1<BaseDataCollector> Collectors { get; }
    protected bool IsDisposed { get; private set; }
    private static BaseDataCollector();
    [CompilerGeneratedAttribute]
internal IDataCollectionEvents get_Events();
    [CompilerGeneratedAttribute]
private void set_Events(IDataCollectionEvents value);
    [CompilerGeneratedAttribute]
internal IDataCollectionLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(IDataCollectionLogger value);
    [CompilerGeneratedAttribute]
internal IDataCollectionSink get_DataSink();
    [CompilerGeneratedAttribute]
private void set_DataSink(IDataCollectionSink value);
    [CompilerGeneratedAttribute]
internal IDataCollectionAgentContext get_AgentContext();
    [CompilerGeneratedAttribute]
private void set_AgentContext(IDataCollectionAgentContext value);
    protected static ReadOnlyCollection`1<BaseDataCollector> get_Collectors();
    internal void Initialize(XmlElement configurationElement, IDataCollectionEvents events, IDataCollectionSink dataSink, IDataCollectionLogger logger, IDataCollectionAgentContext agentContext);
    internal IEnumerable`1<KeyValuePair`2<string, string>> RequestEnvironmentVariables();
    public virtual void Initialize(XmlElement configurationElement, DataCollectionEvents events, DataCollectionSink dataSink, DataCollectionLogger logger, DataCollectionEnvironmentContext environmentContext);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, string>> Microsoft.VisualStudio.TestTools.Execution.ITestExecutionEnvironmentSpecifier.GetTestExecutionEnvironmentVariables();
    private void InternalConstruct(XmlElement configurationElement, IDataCollectionEvents events, IDataCollectionSink dataSink, IDataCollectionLogger logger, IDataCollectionAgentContext agentContext);
    protected abstract virtual void OnInitialize(XmlElement configurationElement);
    protected abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    internal abstract virtual void SetCollectionPerProcess(Dictionary`2<string, XmlElement> processCPMap);
    protected void SubscribeToEvents();
    protected void UnsubscribeFromEvents();
    protected void UnsubscribeFromTestCaseEvents();
    protected void SubscribeToTestCaseEvents();
    protected virtual void OnSendFileCompleted(object sender, AsyncCompletedEventArgs e);
    protected virtual void OnCustomNotification(object sender, CustomNotificationEventArgs e);
    protected virtual void OnDataRequest(object sender, DataRequestEventArgs e);
    protected virtual void OnSessionEnd(object sender, SessionEndEventArgs e);
    protected virtual void OnSessionPause(object sender, SessionPauseEventArgs e);
    protected virtual void OnSessionResume(object sender, SessionResumeEventArgs e);
    protected virtual void OnSessionStart(object sender, SessionStartEventArgs e);
    protected virtual void OnTestCasePause(object sender, TestCasePauseEventArgs e);
    protected virtual void OnTestCaseReset(object sender, TestCaseResetEventArgs e);
    protected virtual void OnTestCaseResume(object sender, TestCaseResumeEventArgs e);
    protected virtual void OnTestCaseStart(object sender, TestCaseStartEventArgs e);
    protected virtual void OnTestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected virtual void OnTestStepEnd(object sender, TestStepEndEventArgs e);
    protected virtual void OnTestStepStart(object sender, TestStepStartEventArgs e);
    protected virtual override void Finalize();
    protected void SendFileAsync(DataCollectionContext context, string displayName, string logFilePath, bool sinkOwnsFile, object userToken, bool writeTraceLog);
    protected void WriteFile(DataCollectionContext context, string description, string logFilePath, bool deleteFile, object userToken);
    protected virtual void Dispose(bool disposing);
    private void EnableLogging();
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    private void AssertNotDisposed();
}
public abstract class Microsoft.VisualStudio.TraceCollector.CommonDataCollector : BaseDataCollector {
    private string _collectorName;
    private string _cPlanFileName;
    private static string ActiveProfileFormat;
    private static string SessionZeroActiveProfile;
    private static bool _environmentVariablesRequested;
    private static IMessageMemory2 _memory;
    private Timer _keepAliveTimer;
    private static int _keepAliveTimeout;
    private static object _collectionPlanLock;
    private static _CollectionPlan _cPlanXml;
    private static bool _writeTraceFile;
    private static bool _writeCoverageFile;
    private bool _ownsCollectionPlan;
    private bool _collectionInitiated;
    private List`1<string> _profileValueNames;
    private bool _iisInstrumented;
    private bool _configureIIS;
    internal static bool _fileLevelCollection;
    internal static string _rootPathTIA;
    internal static bool _logFilePath;
    private IISEnvironmentInjector _iisEnvInjector;
    private bool _IISInitializationAttempted;
    private IEnumerable`1<OverwrittenRegistryValues> _conflicts;
    private Dictionary`2<string, string> _envVars;
    private List`1<string> _allowedUsers;
    private List`1<LoggerWrapper> _loggers;
    private string TraceLogProfilerCLSID;
    private static string LoadTestAdapterName;
    private List`1<TestInfo> _executingTests;
    private HashSet`1<Guid> _testHasLoggers;
    private HashSet`1<Guid> _observedWebRequests;
    private object _thisLock;
    private QueuedIpcPipeServer _ipc;
    private RegisteredWaitHandle _ipcHandler;
    private QueuedIpcPipeServer _globalIpc;
    private RegisteredWaitHandle _globalIpcHandler;
    private VolatileSettingsStore _store;
    public bool TraceDebuggingEnabled { get; }
    public bool TestImpactEnabled { get; }
    public bool UnitTestIsolationEnabled { get; }
    protected bool OwnsCollectionPlan { get; }
    internal static string RegistryBasePath { get; }
    internal static string RegistryProfilesPath { get; }
    private List`1<string> AllowedUsers { get; }
    private bool CreateSessionZeroFileForIIS { get; }
    private bool IsMtmOrRemote { get; }
    private bool InstrumentLocalIISInSessionScope { get; }
    internal IISEnvironmentInjector IISInjector { get; }
    private static CommonDataCollector();
    internal static _CollectionPlan GetCollectionPlan();
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    protected virtual void OnInitialize(XmlElement configurationElement);
    private void AddEnvVariableFromProcess(string envVariable);
    private void ConfigureCPForCollection(_CollectionPlan cp);
    internal virtual void SetCollectionPerProcess(Dictionary`2<string, XmlElement> processCPMap);
    private void InitializeIIS();
    private void CleanupIIS();
    public void InitiateCollection();
    public bool get_TraceDebuggingEnabled();
    public bool get_TestImpactEnabled();
    public bool get_UnitTestIsolationEnabled();
    public void InitializeWriting();
    protected bool get_OwnsCollectionPlan();
    internal abstract virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal abstract virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    internal virtual _CollectionPlan BeforeSecondCollectorInitialize(_CollectionPlan plan);
    private void Cleanup();
    protected virtual void Dispose(bool disposing);
    private void DispatchMessage(MessageCreator mcreate);
    private void CollectLogs(DataCollectionContext cxt, TestCaseEventArgs testCaseEventArgs, bool cleanupLoggers, bool writeTraceLog, bool writeTestImpactLog);
    protected sealed virtual void OnSessionStart(object sender, SessionStartEventArgs e);
    protected sealed virtual void OnTestCaseStart(object sender, TestCaseStartEventArgs e);
    protected sealed virtual void OnTestStepEnd(object sender, TestStepEndEventArgs e);
    protected sealed virtual void OnTestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected sealed virtual void OnSessionEnd(object sender, SessionEndEventArgs e);
    protected sealed virtual void OnSessionPause(object sender, SessionPauseEventArgs e);
    protected sealed virtual void OnSessionResume(object sender, SessionResumeEventArgs e);
    protected sealed virtual void OnTestCasePause(object sender, TestCasePauseEventArgs e);
    protected sealed virtual void OnTestCaseResume(object sender, TestCaseResumeEventArgs e);
    protected sealed virtual void OnTestCaseReset(object sender, TestCaseResetEventArgs e);
    protected sealed virtual void OnDataRequest(object sender, DataRequestEventArgs e);
    internal static string get_RegistryBasePath();
    internal static string get_RegistryProfilesPath();
    internal static RegistryKey GetRegKeyProfiles();
    private _TestCaseContext GetTestCaseContextMessage(ITestCaseContextEventArgs eventArgs);
    private void IPCNotEmptyCallback(object ipcObj, bool timedOut);
    private void OnLoggerInfo(_LoggerInfo info);
    private void OnTestMadeWebRequest(_TestMadeWebRequest msg);
    private void SendKeepAlive(object state);
    private bool AreRequiredIISComponentsInstalled();
    private void ConfigureIISProfiling(DataCollectionContext context);
    private void LogWebInstrumentException(DataCollectionContext context, WebInstrumenterException e);
    private List`1<string> get_AllowedUsers();
    private void ClearAndResetIIS();
    private bool get_CreateSessionZeroFileForIIS();
    private bool get_IsMtmOrRemote();
    private bool get_InstrumentLocalIISInSessionScope();
    internal IISEnvironmentInjector get_IISInjector();
    [CompilerGeneratedAttribute]
private MsgHandle <OnLoggerInfo>b__81_0(long eventTick, Int32& msgLen);
}
internal class Microsoft.VisualStudio.TraceCollector.DataCollectionEnvironmentContextWrapper : object {
    private DataCollectionEnvironmentContext _environmentContext;
    public string AgentName { get; }
    public string ControllerName { get; }
    public bool IsExecutedRemotely { get; }
    public bool IsLocalManualTest { get; }
    public DataCollectionContext SessionDataCollectionContext { get; }
    public TcmContext TcmContext { get; }
    public DataCollectionEnvironmentContextWrapper(DataCollectionEnvironmentContext environmentContext);
    public sealed virtual string get_AgentName();
    public sealed virtual string get_ControllerName();
    public sealed virtual bool get_IsExecutedRemotely();
    public sealed virtual bool get_IsLocalManualTest();
    public sealed virtual DataCollectionContext get_SessionDataCollectionContext();
    public sealed virtual TcmContext get_TcmContext();
}
internal class Microsoft.VisualStudio.TraceCollector.DataCollectionEventsWrapper : object {
    private DataCollectionEvents _wrapped;
    public DataCollectionEventsWrapper(DataCollectionEvents wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_CustomNotification(EventHandler`1<CustomNotificationEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_CustomNotification(EventHandler`1<CustomNotificationEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_DataRequest(EventHandler`1<DataRequestEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_DataRequest(EventHandler`1<DataRequestEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_SessionPause(EventHandler`1<SessionPauseEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_SessionPause(EventHandler`1<SessionPauseEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_SessionResume(EventHandler`1<SessionResumeEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_SessionResume(EventHandler`1<SessionResumeEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCasePause(EventHandler`1<TestCasePauseEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCasePause(EventHandler`1<TestCasePauseEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCaseFailed(EventHandler`1<TestCaseFailedEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCaseFailed(EventHandler`1<TestCaseFailedEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCaseReset(EventHandler`1<TestCaseResetEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCaseReset(EventHandler`1<TestCaseResetEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCaseResume(EventHandler`1<TestCaseResumeEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCaseResume(EventHandler`1<TestCaseResumeEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestStepEnd(EventHandler`1<TestStepEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestStepEnd(EventHandler`1<TestStepEndEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.add_TestStepStart(EventHandler`1<TestStepStartEventArgs> value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents.remove_TestStepStart(EventHandler`1<TestStepStartEventArgs> value);
}
internal class Microsoft.VisualStudio.TraceCollector.DataCollectionLoggerWrapper : object {
    private DataCollectionLogger _wrapped;
    public DataCollectionLoggerWrapper(DataCollectionLogger wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionLogger.LogError(DataCollectionContext context, Exception exception);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionLogger.LogError(DataCollectionContext context, string text);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionLogger.LogError(DataCollectionContext context, string text, Exception exception);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionLogger.LogWarning(DataCollectionContext context, string text);
}
internal class Microsoft.VisualStudio.TraceCollector.DataCollectionSinkWrapper : object {
    private DataCollectionSink _wrapped;
    public DataCollectionSinkWrapper(DataCollectionSink wrapped);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.add_SendFileCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.remove_SendFileCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.add_SendStreamCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.remove_SendStreamCompleted(AsyncCompletedEventHandler value);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendFileAsync(DataCollectionContext context, string path, bool deleteFile);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendFileAsync(DataCollectionContext context, string path, string description, bool deleteFile);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendFileAsync(FileTransferInformation fileInformation);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendStreamAsync(DataCollectionContext context, Stream stream, string fileName, bool closeStream);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendStreamAsync(DataCollectionContext context, Stream stream, string fileName, string description, bool closeStream);
    private sealed virtual override void Microsoft.VisualStudio.TraceCollector.IDataCollectionSink.SendStreamAsync(StreamTransferInformation streamInformation);
}
internal class Microsoft.VisualStudio.TraceCollector.FakesAssemblyReflector : object {
    internal static string FakesTypesCacheFileExtension;
    public sealed virtual HashSet`1<string> ReflectShimTypes(string fakesAssemblyFullPath);
    private static string BuildCacheFilePath(string fakesAssemblyFullPath);
    private static bool CheckIfNeedToUpdate(string fakeAssemblyFullPath, string fakedTypesCacheFilePath);
    private static HashSet`1<string> LoadShimTypesFromCache(string fakesAssemblyFullPath, string fakedTypesCacheFilePath);
    private static HashSet`1<string> ReflectShimTypes(string fakesAssembly, string fakedTypesCacheFilePath);
    private static HashSet`1<string> GetShimedTypesInfo(string fakeAssemblyFullPath, StringBuilder builder);
}
internal class Microsoft.VisualStudio.TraceCollector.HostEnvironment : DefaultWindowsRuntimeHost {
    private AssemblyIdentity externalCoreAssemblySymbolicIdentity;
    [DebuggerBrowsableAttribute("0")]
private AssemblyIdentity ExternalCoreAssemblySymbolicIdentity { get; }
    [DebuggerStepThroughAttribute]
private AssemblyIdentity get_ExternalCoreAssemblySymbolicIdentity();
    public virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/HttpProxy/1.0")]
[DataCollectorFriendlyNameAttribute("HttpProxyCollectorFriendlyName", "True")]
[DataCollectorDescriptionAttribute("HttpProxyCollectorDescription", "True")]
public class Microsoft.VisualStudio.TraceCollector.HttpProxyCollector : BaseDataCollector {
    private XmlElement _configuration;
    private Proxy _proxy;
    private DataCollectionContext _currentTestContext;
    private AppDomain currentDomain;
    private static string HTTP_HEADER_NAME;
    protected virtual void OnInitialize(XmlElement configurationElement);
    internal virtual void SetCollectionPerProcess(Dictionary`2<string, XmlElement> processCPMap);
    protected virtual IEnumerable`1<KeyValuePair`2<string, string>> GetEnvironmentVariables();
    protected virtual void Dispose(bool disposing);
    private void StartProxy();
    private void StopProxy();
    private void OnUnHandledException(object sender, UnhandledExceptionEventArgs args);
    private void OnProxyRequestEvent(object sender, RequestReceivedEventArgs e);
    private void OnProxyErrorEvent(object sender, ProxyErrorEventArgs e);
    protected virtual void OnTestCaseStart(object sender, TestCaseStartEventArgs e);
    protected virtual void OnTestCaseEnd(object sender, TestCaseEndEventArgs e);
    protected virtual void OnTestCasePause(object sender, TestCasePauseEventArgs e);
    protected virtual void OnTestCaseResume(object sender, TestCaseResumeEventArgs e);
    protected virtual void OnTestCaseReset(object sender, TestCaseResetEventArgs e);
}
internal interface Microsoft.VisualStudio.TraceCollector.IDataCollectionAgentContext {
    public string AgentName { get; }
    public string ControllerName { get; }
    public bool IsExecutedRemotely { get; }
    public bool IsLocalManualTest { get; }
    public DataCollectionContext SessionDataCollectionContext { get; }
    public TcmContext TcmContext { get; }
    public abstract virtual string get_AgentName();
    public abstract virtual string get_ControllerName();
    public abstract virtual bool get_IsExecutedRemotely();
    public abstract virtual bool get_IsLocalManualTest();
    public abstract virtual DataCollectionContext get_SessionDataCollectionContext();
    public abstract virtual TcmContext get_TcmContext();
}
internal interface Microsoft.VisualStudio.TraceCollector.IDataCollectionEvents {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CustomNotification(EventHandler`1<CustomNotificationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CustomNotification(EventHandler`1<CustomNotificationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_DataRequest(EventHandler`1<DataRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DataRequest(EventHandler`1<DataRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionEnd(EventHandler`1<SessionEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionPause(EventHandler`1<SessionPauseEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionPause(EventHandler`1<SessionPauseEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionResume(EventHandler`1<SessionResumeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionResume(EventHandler`1<SessionResumeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SessionStart(EventHandler`1<SessionStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseEnd(EventHandler`1<TestCaseEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCasePause(EventHandler`1<TestCasePauseEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCasePause(EventHandler`1<TestCasePauseEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseReset(EventHandler`1<TestCaseResetEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseReset(EventHandler`1<TestCaseResetEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseFailed(EventHandler`1<TestCaseFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseFailed(EventHandler`1<TestCaseFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseResume(EventHandler`1<TestCaseResumeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseResume(EventHandler`1<TestCaseResumeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestCaseStart(EventHandler`1<TestCaseStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestStepEnd(EventHandler`1<TestStepEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestStepEnd(EventHandler`1<TestStepEndEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TestStepStart(EventHandler`1<TestStepStartEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TestStepStart(EventHandler`1<TestStepStartEventArgs> value);
}
internal interface Microsoft.VisualStudio.TraceCollector.IDataCollectionLogger {
    public abstract virtual void LogError(DataCollectionContext context, Exception exception);
    public abstract virtual void LogError(DataCollectionContext context, string text);
    public abstract virtual void LogError(DataCollectionContext context, string text, Exception exception);
    public abstract virtual void LogWarning(DataCollectionContext context, string text);
}
internal interface Microsoft.VisualStudio.TraceCollector.IDataCollectionSink {
    [CompilerGeneratedAttribute]
public abstract virtual void add_SendFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SendFileCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SendStreamCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SendStreamCompleted(AsyncCompletedEventHandler value);
    public abstract virtual void SendFileAsync(DataCollectionContext context, string path, bool deleteFile);
    public abstract virtual void SendFileAsync(DataCollectionContext context, string path, string displayName, bool deleteFile);
    public abstract virtual void SendFileAsync(FileTransferInformation fileInformation);
    public abstract virtual void SendStreamAsync(DataCollectionContext context, Stream stream, string fileName, bool closeStream);
    public abstract virtual void SendStreamAsync(DataCollectionContext context, Stream stream, string fileName, string description, bool closeStream);
    public abstract virtual void SendStreamAsync(StreamTransferInformation streamInformation);
}
internal interface Microsoft.VisualStudio.TraceCollector.IFakesAssemblyReflector {
    public abstract virtual HashSet`1<string> ReflectShimTypes(string fakesAssembly);
}
internal interface Microsoft.VisualStudio.TraceCollector.ITestCaseContextEventArgs {
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public int TcmTestCaseId { get; }
    public string TestCaseName { get; }
    public ITestElement TestElement { get; }
    public abstract virtual DataCollectionContext get_Context();
    public abstract virtual bool get_IsChildTestCase();
    public abstract virtual Guid get_TestCaseId();
    public abstract virtual int get_TcmTestCaseId();
    public abstract virtual string get_TestCaseName();
    public abstract virtual ITestElement get_TestElement();
}
public class Microsoft.VisualStudio.TraceCollector.MethodSignature : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlTextAttribute]
public string Signature { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    public sealed virtual bool Equals(MethodSignature other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodSignature left, MethodSignature right);
    public static bool op_Inequality(MethodSignature left, MethodSignature right);
    public sealed virtual int CompareTo(MethodSignature other);
    public static bool op_GreaterThan(MethodSignature left, MethodSignature right);
    public static bool op_LessThan(MethodSignature left, MethodSignature right);
}
internal static class Microsoft.VisualStudio.TraceCollector.NativeMethods : object {
    internal static bool ProcessIdToSessionId(UInt32 dwProcessId, UInt32& pSessionId);
    internal static UInt32 GetCurrentProcessId();
}
internal class Microsoft.VisualStudio.TraceCollector.Resources : object {
    internal static ResourceManager ResourceManager;
    public static string EventsMustHaveId { get; }
    public static string NoConfiguration { get; }
    public static string TestImpactCollectorDescription { get; }
    public static string TestImpactCollectorFriendlyName { get; }
    public static string HttpProxyCollectorDescription { get; }
    public static string HttpProxyCollectorFriendlyName { get; }
    public static string TraceDebuggerCollectorDescription { get; }
    public static string TraceDebuggerCollectorFriendlyName { get; }
    public static string UnableSetVss { get; }
    public static string UnableEnumerateIISService { get; }
    public static string MustSetEnvironmentVariables { get; }
    public static string TestImpactData { get; }
    public static string ProxyNotPresent { get; }
    public static string IISNotInstalled { get; }
    public static string ASPNetNotInstalled { get; }
    public static string NoLoggersConnected { get; }
    public static string LoadTestTurnedOn { get; }
    public static string NoWebRequestsMade { get; }
    public static string TestImpactLogFileFull { get; }
    public static string Both { get; }
    public static string AndSeparator { get; }
    public static string UnitTestIsolationCollectorDescription { get; }
    public static string UnitTestIsolationCollectorFriendlyName { get; }
    private static Resources();
    public static string get_EventsMustHaveId();
    public static string get_NoConfiguration();
    public static string ProxyProcessingError(object param0);
    public static string ProxyStartFailed(object param0);
    public static string ProxyStopFailed(object param0);
    public static string get_TestImpactCollectorDescription();
    public static string get_TestImpactCollectorFriendlyName();
    public static string get_HttpProxyCollectorDescription();
    public static string get_HttpProxyCollectorFriendlyName();
    public static string get_TraceDebuggerCollectorDescription();
    public static string get_TraceDebuggerCollectorFriendlyName();
    public static string TraceLogName(object param0, object param1);
    public static string get_UnableSetVss();
    public static string get_UnableEnumerateIISService();
    public static string get_MustSetEnvironmentVariables();
    public static string get_TestImpactData();
    public static string FailedToDeleteTestImpactFile(object param0);
    public static string FailedToCreateCopy(object param0);
    public static string get_ProxyNotPresent();
    public static string IISAccessRemote(object param0);
    public static string IISAccessLocal(object param0);
    public static string get_IISNotInstalled();
    public static string get_ASPNetNotInstalled();
    public static string GenericIISFailure(object param0);
    public static string get_NoLoggersConnected();
    public static string get_LoadTestTurnedOn();
    public static string get_NoWebRequestsMade();
    public static string get_TestImpactLogFileFull();
    public static string get_Both();
    public static string get_AndSeparator();
    public static string get_UnitTestIsolationCollectorDescription();
    public static string get_UnitTestIsolationCollectorFriendlyName();
}
internal class Microsoft.VisualStudio.TraceCollector.SimpleTimer : object {
    private Stopwatch _timer;
    private string _name;
    private long _threshold;
    private bool _disposed;
    public SimpleTimer(string timerName);
    public SimpleTimer(string timerName, long thresholdInMilliseconds);
    public sealed virtual void Dispose();
    private void StopAndLog();
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.TraceCollector.SingleAssemblyHost : object {
    private HostEnvironment hostEnvironment;
    private bool disposed;
    [CompilerGeneratedAttribute]
private IAssembly <Assembly>k__BackingField;
    public IAssembly Assembly { get; private set; }
    [CompilerGeneratedAttribute]
public IAssembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(IAssembly value);
    public static SingleAssemblyHost LoadAssemblyFrom(string location);
    private IAssembly ReadAssembly(string assemblyPath);
    private static bool IsInvalidAssembly(IAssembly assembly);
    private static bool EnsureNonManifestModulesArePresent(string assemblyPath, IAssembly assembly);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.TraceCollector.SingleAssemblyWalker : object {
    private static string ShimClassCustomAttribute;
    private static string FakeTopLevelTypePrefix;
    private IAssembly assembly;
    private StringBuilder writer;
    private bool publicOnly;
    private TypeNameCache typeNameCache;
    private HashSet`1<string> shimTypes;
    public SingleAssemblyWalker(IAssembly assembly, StringBuilder writer, HashSet`1<string> shimTypes, bool publicOnly);
    public void Start();
    private void WalkType(ITypeDefinition type);
    internal void AccumulateShimType(ITypeDefinition type);
    private ICustomAttribute SafeFindAttribute(IReference reference, string fullyQualifiedAttributeName);
    private bool IsTopLevelType(IMetadataExpression expression);
    private static bool IsPublicType(ITypeDefinition type);
}
internal class Microsoft.VisualStudio.TraceCollector.TestCaseEndEventArgsWrapper : object {
    private TestCaseEndEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    public int TcmTestCaseId { get; }
    public ITestElement TestElement { get; }
    public TestCaseEndEventArgsWrapper(TestCaseEndEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    public sealed virtual int get_TcmTestCaseId();
    public sealed virtual ITestElement get_TestElement();
}
internal class Microsoft.VisualStudio.TraceCollector.TestCasePauseEventArgsWrapper : object {
    private TestCasePauseEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    public int TcmTestCaseId { get; }
    public ITestElement TestElement { get; }
    public TestCasePauseEventArgsWrapper(TestCasePauseEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    public sealed virtual int get_TcmTestCaseId();
    public sealed virtual ITestElement get_TestElement();
}
internal class Microsoft.VisualStudio.TraceCollector.TestCaseResetEventArgsWrapper : object {
    private TestCaseResetEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    public int TcmTestCaseId { get; }
    public ITestElement TestElement { get; }
    public TestCaseResetEventArgsWrapper(TestCaseResetEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    public sealed virtual int get_TcmTestCaseId();
    public sealed virtual ITestElement get_TestElement();
}
internal class Microsoft.VisualStudio.TraceCollector.TestCaseResumeEventArgsWrapper : object {
    private TestCaseResumeEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    public int TcmTestCaseId { get; }
    public ITestElement TestElement { get; }
    public TestCaseResumeEventArgsWrapper(TestCaseResumeEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    public sealed virtual int get_TcmTestCaseId();
    public sealed virtual ITestElement get_TestElement();
}
internal class Microsoft.VisualStudio.TraceCollector.TestCaseStartEventArgsWrapper : object {
    private TestCaseStartEventArgs _args;
    public DataCollectionContext Context { get; }
    public bool IsChildTestCase { get; }
    public int TcmTestCaseId { get; }
    public Guid TestCaseId { get; }
    public string TestCaseName { get; }
    public ITestElement TestElement { get; }
    public TestCaseStartEventArgsWrapper(TestCaseStartEventArgs e);
    public sealed virtual DataCollectionContext get_Context();
    public sealed virtual bool get_IsChildTestCase();
    public sealed virtual int get_TcmTestCaseId();
    public sealed virtual Guid get_TestCaseId();
    public sealed virtual string get_TestCaseName();
    public sealed virtual ITestElement get_TestElement();
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/TestImpact/1.0")]
[DataCollectorFriendlyNameAttribute("TestImpactCollectorFriendlyName", "True")]
[DataCollectorDescriptionAttribute("TestImpactCollectorDescription", "True")]
[DataCollectorConfigurationEditorAttribute("configurationeditor://Microsoft/TestImpact/1.0")]
[DataCollectorRequiresOutOfProcessCollectionAttribute]
public class Microsoft.VisualStudio.TraceCollector.TestImpactDataCollector : CommonDataCollector {
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    private void PopulateCollectionPlan(_CollectionPlan plan, XmlElement settings);
    protected virtual void OnSendFileCompleted(object sender, AsyncCompletedEventArgs e);
}
internal class Microsoft.VisualStudio.TraceCollector.TestImpactDirectoryWrapper : object {
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    public string DirectoryPath { get; private set; }
    public TestImpactDirectoryWrapper(IDataCollectionLogger logger, DataCollectionContext context);
    [CompilerGeneratedAttribute]
public string get_DirectoryPath();
    [CompilerGeneratedAttribute]
private void set_DirectoryPath(string value);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Delete();
}
[XmlRootAttribute("Test")]
public class Microsoft.VisualStudio.TraceCollector.TestImpactXmlData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTestCase>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TestCaseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <AutomatedTestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignatureType>k__BackingField;
    private HashSet`1<MethodSignature> _signatures;
    private static string fileTypeSignature;
    private static string methodTypeSignature;
    private static Dictionary`2<string, KeyValuePair`2<SymbolReader, bool>> _symbolReaderCache;
    private static Dictionary`2<string, string> _filePathCacheCache;
    [XmlAttributeAttribute("Name")]
public string Name { get; public set; }
    [XmlAttributeAttribute("IsTestCase")]
public bool IsTestCase { get; public set; }
    [XmlAttributeAttribute("TestCaseId")]
public int TestCaseId { get; public set; }
    [XmlAttributeAttribute("AutomatedTestId")]
public Guid AutomatedTestId { get; public set; }
    [XmlAttributeAttribute("SignatureType")]
public string SignatureType { get; public set; }
    [XmlArrayAttribute("Signatures")]
[XmlArrayItemAttribute("Signature", "Microsoft.VisualStudio.TraceCollector.MethodSignature")]
public HashSet`1<MethodSignature> Signatures { get; }
    public TestImpactXmlData(TestCaseEventArgs e);
    private static TestImpactXmlData();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsTestCase();
    [CompilerGeneratedAttribute]
public void set_IsTestCase(bool value);
    [CompilerGeneratedAttribute]
public int get_TestCaseId();
    [CompilerGeneratedAttribute]
public void set_TestCaseId(int value);
    [CompilerGeneratedAttribute]
public Guid get_AutomatedTestId();
    [CompilerGeneratedAttribute]
public void set_AutomatedTestId(Guid value);
    [CompilerGeneratedAttribute]
public string get_SignatureType();
    [CompilerGeneratedAttribute]
public void set_SignatureType(string value);
    public HashSet`1<MethodSignature> get_Signatures();
    public void PopulateSignatures(string logPath, Guid testExecId, bool fileLevel, string rootPath, bool logFilePath);
    internal void PopulateSignatures(string streamFilePath, TestImpactDataEventsMessagePacker packer, bool fileLevel, string rootPath, bool logFilePath);
    private void PopulateSignatures(IEnumerable`1<_TestImpactDataFlushEvent> dataEvents, bool fileLevel, string rootPath, bool logFilePath);
    private static bool GetSymbolReader(string assemblyName, SymbolReader& symbolsReader);
    private string GetSignature(string name);
    private static IMetaDataImport2 CreateMetadataImport(string path);
    private static void AppendCodeElementSignature(StringBuilder builder, SHA1CryptoServiceProvider algorithm, string name);
    internal static void CleanCache();
}
[DataCollectorTypeUriAttribute("datacollector://Microsoft/TraceDebugger/1.0")]
[DataCollectorFriendlyNameAttribute("TraceDebuggerCollectorFriendlyName", "True")]
[DataCollectorDescriptionAttribute("TraceDebuggerCollectorDescription", "True")]
[DataCollectorConfigurationEditorAttribute("configurationeditor://Microsoft/TraceDebugger/1.0")]
[DataCollectorRequiresOutOfProcessCollectionAttribute]
public class Microsoft.VisualStudio.TraceCollector.TraceDebuggerDataCollector : CommonDataCollector {
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
}
[DataCollectorTypeUriAttribute("datacollector://microsoft/unittestisolation/1.0")]
[DataCollectorFriendlyNameAttribute("UnitTestIsolationCollectorFriendlyName", "True")]
[DataCollectorDescriptionAttribute("UnitTestIsolationCollectorDescription", "True")]
[DataCollectorRequiresOutOfProcessCollectionAttribute]
[DataCollectorTestClientRestrictionAttribute]
public class Microsoft.VisualStudio.TraceCollector.UnitTestIsolationDataCollector : CommonDataCollector {
    private static string ShimLeadingKeyword;
    private static string FakesEndingKeyword;
    private static string FakesFrameworkAssemblyName;
    private static string FakesTestPlatformAssemblyName;
    private IFakesAssemblyReflector fakesAssemblyReflector;
    internal UnitTestIsolationDataCollector(IFakesAssemblyReflector stubReflector);
    internal virtual _CollectionPlan OnFirstCollectorToInitialize(XmlElement configurationElement);
    internal virtual _CollectionPlan OnSecondCollectorToInitialize(_CollectionPlan plan, XmlElement configurationElement);
    private void PopulateCollectionPlan(_CollectionPlan plan, XmlElement settings);
    private static void BuildCollectionPlan(_CollectionPlan plan, Dictionary`2<string, HashSet`1<string>> knownAssemblies);
    private static void AccumulateShimmedTypeForEachAssembly(Dictionary`2<string, HashSet`1<string>> knownAssemblies, string assemblyName, HashSet`1<string> shimTypes);
    internal static string ExtractAssemblyNameFromFakesAssembly(string fakesAssemblyFullPath);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
